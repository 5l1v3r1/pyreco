__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pyro documentation build configuration file, created by
# sphinx-quickstart on Thu Jun 16 22:20:40 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
import Pyro4.constants

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Pyro'
copyright = u'Irmen de Jong'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = Pyro4.constants.VERSION
# The full version, including alpha/beta/rc tags.
release = Pyro4.constants.VERSION

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    "rightsidebar": True,
    "bodyfont": "Tahoma,Helvetica,\"Helvetica Neue\",Arial,sans-serif",
    "linkcolor": "#3070a0",
    "visitedlinkcolor": "#3070a0",
}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = "_static/pyro.png"

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = False

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pyrodoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Pyro.tex', u'Pyro Documentation',
   u'Irmen de Jong', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyro', u'Pyro Documentation',
     [u'Irmen de Jong'], 1)
]

def setup(app):
    from sphinx.ext.autodoc import cut_lines
    # skip the copyright line in every module docstring (last line of docstring)
    app.connect('autodoc-process-docstring', cut_lines(pre=0, post=1, what=['module']))

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import time
import Pyro4

if sys.version_info<(3,0):
    input=raw_input


uri=input("enter async server object uri: ").strip()
proxy=Pyro4.Proxy(uri)

print("* normal call: (notice the delay)")
print("result=", proxy.divide(100,5))

print("\n* async call:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)   # returns immediately
print("result value available?",asyncresult.ready)   # prints False because the server is still 'busy'
print("client can do other stuff here.")
print("getting result value...(will block until available)")
print("resultvalue=",asyncresult.value)   # blocks until the result is available

print("\n* async call, with normal call inbetween:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)   # returns immediately
print("client does normal call: ",proxy.multiply(5,20))
print("client does normal call: ",proxy.multiply(5,30))
print("getting result value of async call...(will block until available)")
print("resultvalue=",asyncresult.value)   # blocks until the result is available

print("\n* async call with exception:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,0)   # will trigger a zero division error, 100//0
print("getting result value...")
try:
    value=asyncresult.value
    print("Weird, this shouldn't succeed!?... resultvalue=",value)
except ZeroDivisionError:
    print("got exception (expected):",repr(sys.exc_info()[1]))

print("\n* async call with timeout:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)
print("checking if ready within 2 seconds...")
ready=asyncresult.wait(2)   # wait for ready within 2 seconds but the server takes 3
print("status after waiting=",ready)   # should print False
print("checking again if ready within 5 seconds...(should be ok now)")
ready=asyncresult.wait(timeout=5)   # wait 5 seconds now (but server will be done within 1 more second)
print("status after waiting=",ready)
print("available=",asyncresult.ready)
print("resultvalue=",asyncresult.value)

print("\n* a few async calls at the same time:")
async=Pyro4.async(proxy)
results=[
    async.divide(100,7),
    async.divide(100,6),
    async.divide(100,5),
    async.divide(100,4),
    async.divide(100,3),
    ]
print("getting values...")
for result in results:
    print("result=",result.value)

print("\ndone.")

########NEW FILE########
__FILENAME__ = client_batch
from __future__ import print_function
import sys
import time
import Pyro4

if sys.version_info<(3,0):
    input=raw_input


def asyncFunction(values):
    results=[value+1 for value in values]
    print(">>> async batch function called, returning:",results)
    return results


uri=input("enter async server object uri: ").strip()
proxy=Pyro4.Proxy(uri)

print("\n* batch async call:")
batch=Pyro4.batch(proxy)
batch.divide(100,5)
batch.divide(99,9)
batch.divide(555,2)
print("getting results...")
asyncresults = batch(async=True)  # returns immediately
print("result value available?",asyncresults.ready)   # prints False because the server is still 'busy'
print("client can do other stuff here.")
time.sleep(2)
print("such as sleeping ;-)")
time.sleep(2)
print("sleeping some more, batch takes a while")
time.sleep(2)
print("getting result values...(will block until available)")
results=asyncresults.value   # blocks until the result is available
print("resultvalues=",list(results))

print("\n* batch async call with chained function:")
batch=Pyro4.batch(proxy)
batch.divide(100,5)
batch.divide(99,9)
batch.divide(555,2)
asyncresults = batch(async=True)  # returns immediately
asyncresults.then(asyncFunction) \
            .then(asyncFunction) \
            .then(asyncFunction)
print("getting result values...(will block until available)")
print("final value=",asyncresults.value)

print("\n* batch async call with exception:")
batch=Pyro4.batch(proxy)
batch.divide(1,1)   # first call is ok
batch.divide(100,0)   # second call will trigger a zero division error, 100//0
asyncresults = batch(async=True)  # returns immediately
print("getting result values...")
try:
    value=asyncresults.value
    print("Weird, this shouldn't succeed!?... resultvalues=",list(value))
except ZeroDivisionError:
    print("got exception (expected):",repr(sys.exc_info()[1]))

print("\n* batch async call with timeout:")
batch=Pyro4.batch(proxy)
batch.divide(100,5)
batch.divide(99,9)
batch.divide(555,2)
asyncresults = batch(async=True)  # returns immediately
print("checking if ready within 2 seconds...")
ready=asyncresults.wait(2)   # wait for ready within 2 seconds but the server takes 3
print("status after wait=",ready)   # should print False
print("checking again if ready within 10 seconds...(should be ok now)")
ready=asyncresults.wait(timeout=10)   # wait 10 seconds now (but server will be done within ~8 more seconds)
print("status after wait=",ready)
print("available=",asyncresults.ready)
results=asyncresults.value
print("resultvalues=",list(results))

print("\ndone.")

########NEW FILE########
__FILENAME__ = client_callchain
from __future__ import print_function
import sys
import time
import Pyro4

if sys.version_info<(3,0):
    input=raw_input


def asyncFunction(value, increase=1):
    print(">>> async function called with value={0} increase={1}".format(value,increase))
    return value+increase

def asyncWithMoreArgs(a, b, extra=None):
    print(">>> async func called with some arguments: a={0}, b={1}, extra={2}".format(a, b, extra))
    return a+b


uri=input("enter async server object uri: ").strip()
proxy=Pyro4.Proxy(uri)

print("\n* async call with call chain:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)
# set a chain of callables to be invoked once the value is available
asyncresult.then(asyncFunction) \
           .then(asyncFunction) \
           .then(asyncFunction)
print("sleeping 4 seconds")
time.sleep(4)   # the call chain will be invoked during this sleep period
print("back from sleep")
# you can still access the final asyncresult.value. It should be 100/5+3=23
print("final value=",asyncresult.value)
assert asyncresult.value==23

print("\n* async call with call chain that is set 'too late':")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)
# set a chain of callables to be invoked once the value is available
# but we set it 'too late' (when the result is already available)
time.sleep(4)  # result will appear in 3 seconds
asyncresult.then(asyncFunction) \
           .then(asyncFunction) \
           .then(asyncFunction)
# let's see what the result value is, should be 100/5+3=23
print("final value=",asyncresult.value)
assert asyncresult.value==23

print("\n* async call with call chain, where calls have extra arguments:")
async=Pyro4.async(proxy)
asyncresult=async.multiply(5,6)
# set a chain of callables to be invoked once the value is available
# the callable will be invoked like so:  function(asyncvalue, normalarg, kwarg=..., kwarg=...)
# (the value from the previous call is passed as the first argument to the next call)
asyncresult.then(asyncWithMoreArgs, 1) \
           .then(asyncWithMoreArgs, 2, extra=42) \
           .then(asyncWithMoreArgs, 3, extra="last one")
print("sleeping 1 second")
time.sleep(1)   # the call chain will be invoked during this sleep period
print("back from sleep")
# you can still access the final asyncresult.value. It should be 5*6+1+2+3=36
print("final value=",asyncresult.value)
assert asyncresult.value==36

print("\n* async call with call chain, where calls are new pyro calls:")
async=Pyro4.async(proxy)
asyncresult=async.divide(100,5)
# set a chain of callables to be invoked once the value is available
# the callable will be invoked like so:  function(asyncvalue, kwarg=..., kwarg=...)
asyncresult.then(proxy.add, increase=1) \
           .then(proxy.add, increase=2) \
           .then(proxy.add, increase=3)
print("getting result value (will block until available)")
print("final value=",asyncresult.value)
assert asyncresult.value==26    # 100/5+1+2+3=26

print("\ndone.")

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4

class Thingy(object):
    def divide(self, a, b):
        print("dividing {0} by {1} after a slight delay".format(a,b))
        time.sleep(3)
        return a//b
    def multiply(self, a, b):
        print("multiply {0} by {1}, no delay".format(a,b))
        return a*b
    def add(self, value, increase):
        print("adding {1} to {0}, no delay".format(value,increase))
        return value+increase

d=Pyro4.Daemon()
uri=d.register(Thingy(), "example.async")
print("server object uri:",uri)
print("async server running.")
d.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

uri=input("enter attribute server object uri: ").strip()
p=Pyro4.Proxy(uri)

# First do some normal method calls with and without a dotted path notation
# to get at the sub-object. If the server is running with DOTTEDNAMES=False,
# you will get attribute exceptions when trying to access methods with a
# dotted attribute path. If DOTTEDNAMES=True on the server, it will work.
# (however it is a security risk because it is possible to exploit object
# traversal and obtain internal info of your server or execute arbitrary code).
print("DOTTEDNAMES on the server is:",p.dottedNames())
value=p.getSubValue()
print("value gotten from p.getSubValue()=",value)
try:
    value=p.sub.getValue()
    print("value gotten from p.sub.getValue()=",value)
except AttributeError:
    print("AttributeError occurred:",sys.exc_info()[1])
print("setting value to 999")
try:
    p.sub.setValue(999)
except AttributeError:
    print("AttributeError occurred:",sys.exc_info()[1])
value=p.getSubValue()
print("value gotten from p.getSubValue()=",value)
try:
    value=p.sub.getValue()
    print("value gotten from p.sub.getValue()=",value)
except AttributeError:
    print("AttributeError occurred:",sys.exc_info()[1])

# try an object traversal exploit
print("attempt to do an object traversal exploit...")
oldvalue=p.printSomething()
try:
    # this update() call will work when the server has DOTTEDNAMES set to true...:
    p.printSomething.im_func.func_globals.update({"something":"J00 HAVE BEEN HAXX0RD"})
except AttributeError:
    # this exception occurs when the server has DOTTEDNAMES set to false.
    print("Attributeerror, couldn't update the server's global variable")
newvalue=p.printSomething()
if newvalue!=oldvalue:
    print("The server has been exploited, a global variable has been updated with a different value.")
    print("Old value: {0}    new value: {1}".format(oldvalue, newvalue))

# Direct attribute access @todo: not supported yet, will only print a bunch of <RemoteMethod> lines
# print("\nDirect attribute access.  (not supported yet!)")
# print("p.value:",p.value)
# print("p._value:",p._value)
# print("p.__value:",p.__value)
# print("p.sub.value:",p.sub.value)
# print("p.sub._value:",p.sub._value)
# print("p.sub.__value:",p.sub.__value)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

dotted=input("enter value for DOTTEDNAMES config item: ").strip()
Pyro4.config.DOTTEDNAMES = dotted in ("1","true","on","yes")

something="Something"

class SubThingy(object):
    def __init__(self):
        self.value=42
        self._value=123
        self.__value=999
    def getValue(self):
        return self.value
    def setValue(self,value):
        self.value=value

class Thingy(object):
    def __init__(self):
        self.sub=SubThingy()
        self.value=42
        self._value=123
        self.__value=999
    def getSubValue(self):
        return self.sub.getValue()
    def setSubValue(self, value):
        self.sub.setValue(value)
    def dottedNames(self):
        return Pyro4.config.DOTTEDNAMES
    def printSomething(self):
        print("something:",something)
        return something

d=Pyro4.Daemon()
uri=d.register(Thingy(), "example.attributes")
print("server object uri:",uri)
print("DOTTEDNAMES=",Pyro4.config.DOTTEDNAMES)
print("attributes server running.")
d.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input


uri=input("enter factory server object uri: ").strip()
factory=Pyro4.Proxy(uri)

# create several things.
print("Creating things.")
thing1 = factory.createSomething(1)
thing2 = factory.createSomething(2)
thing3 = factory.createSomething(3)

# interact with them on the server.
print("Speaking stuff.")
thing1.speak("I am the first")
thing2.speak("I am second")
thing3.speak("I am last then...")


########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import Pyro4

from thingy import Thingy

class Factory(object):
    def createSomething(self, number):
        # create a new item
        thing=Thingy(number)
        # connect it to the Pyro daemon to make it a Pyro object
        self._pyroDaemon.register(thing)
        # Return it. Pyro's autoproxy feature turns it into a proxy automatically.
        # If that feature is disabled, the object itself (a copy) is returned,
        # and the client won't be able to interact with the actual Pyro object here.
        return thing

d=Pyro4.Daemon()
uri=d.register(Factory(), "example.autoproxy")
print("server object uri:",uri)
print("autoproxy?",Pyro4.config.AUTOPROXY)
print("factory server running.")
d.requestLoop()

########NEW FILE########
__FILENAME__ = thingy

class Thingy(object):
    def __init__(self, number):
        self.number=number
    def speak(self, message):
        print("Thingy {0} says: {1}".format(self.number, message))

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import time
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

print("Autoreconnect using PYRO uri.")

# We create a proxy with a PYRO uri.
# Reconnect logic depends on the server now.
# (it needs to restart the object with the same id)
uri=input("Enter the uri that the server printed:").strip()
obj=Pyro4.core.Proxy(uri)

while True:
    print("call...")
    try:
        obj.method(42)
        print("Sleeping 1 second")
        time.sleep(1)
    except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
        print("Connection lost. REBINDING...")
        print("(restart the server now)")
        obj._pyroReconnect()

########NEW FILE########
__FILENAME__ = clientNS
from __future__ import print_function
import time
import Pyro4

print("Autoreconnect using Name Server.")

# We create a proxy with a PYRONAME uri.
# That allows Pyro to look up the object again in the NS when
# it needs to reconnect later.
obj=Pyro4.core.Proxy("PYRONAME:example.autoreconnect")

while True:
    print("call...")
    try:
        obj.method(42)
        print("Sleeping 1 second")
        time.sleep(1)
    except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
        print("Connection lost. REBINDING...")
        print("(restart the server now)")
        obj._pyroReconnect()

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4

print("Autoreconnect using PYRO uri.")

class TestClass(object):
    def method(self,arg):
        print("Method called with %s" % arg)
        print("You can now try to stop this server with ctrl-C/ctrl-Break")
        time.sleep(1)

obj=TestClass()

# We are responsible to (re)connect objects with the same object Id,
# so that the client can reuse its PYRO-uri directly to reconnect.
# There are a few options, such as depending on the Name server to
# maintain a name registration for our object (see the serverNS for this).
# Or we could store our objects in our own persistent database.
# But for this example we will just use a pre-generated id (fixed name).
# The other thing is that your Daemon must re-bind on the same port.
# By default Pyro will select a random port so we specify a fixed port.

daemon = Pyro4.core.Daemon(port=7777)
uri = daemon.register(obj,objectId="example.autoreconnect_fixed_objectid")

print("Server started, uri=%s" % uri)
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = serverNS
from __future__ import print_function
import time
import Pyro4

print("Autoreconnect using Name Server.")

class TestClass(object):
    def method(self,arg):
        print("Method called with %s" % arg)
        print("You can now try to stop this server with ctrl-C/ctrl-Break")
        time.sleep(1)

obj=TestClass()

# if we reconnect the object, it has to have the same objectId as before.
# for this example, we rely on the Name Server registration to get our old id back.

ns=Pyro4.naming.locateNS()
try:
    existing=ns.lookup("example.autoreconnect")
    print("Object still exists in Name Server with id: %s" % existing.object)
    print("Previous daemon socket port: %d" % existing.port)
    # start the daemon on the previous port
    daemon = Pyro4.core.Daemon(port=existing.port)
    # register the object in the daemon with the old objectId
    daemon.register(obj, objectId=existing.object)
except Pyro4.errors.NamingError:
    # just start a new daemon on a random port
    daemon = Pyro4.core.Daemon()
    # register the object in the daemon and let it get a new objectId
    # also need to register in name server because it's not there yet.
    uri = daemon.register(obj)
    ns.register("example.autoreconnect", uri)
print("Server started.")
daemon.requestLoop()

# note: we are not removing the name server registration!

########NEW FILE########
__FILENAME__ = banks

# Unrestricted account.
class Account(object):
    def __init__(self):
        self._balance = 0.0
    def withdraw(self, amount):
        self._balance -= amount
    def deposit(self, amount):
        self._balance += amount
    def balance(self):
        return self._balance

# Restricted withdrawal account.
class RestrictedAccount(Account):
    def withdraw(self, amount):
        if amount <= self._balance:
            self._balance -= amount
        else:
            raise ValueError('insufficent balance')

# Abstract bank.
class Bank(object):
    def __init__(self):
        self.accounts = {}
    def name(self):
        pass  # must override this!
    def createAccount(self, name):
        pass  # must override this!
    def deleteAccount(self, name):
        try:
            del self.accounts[name]
        except KeyError:
            raise KeyError('unknown account')
    def deposit(self, name, amount):
        try:
            return self.accounts[name].deposit(amount)
        except KeyError:
            raise KeyError('unknown account')
    def withdraw(self, name, amount):
        try:
            return self.accounts[name].withdraw(amount)
        except KeyError:
            raise KeyError('unknown account')
    def balance(self, name):
        try:
            return self.accounts[name].balance()
        except KeyError:
            raise KeyError('unknown account')
    def allAccounts(self):
        accs = {}
        for name in self.accounts.keys():
            accs[name] = self.accounts[name].balance()
        return accs


# Special bank: Rabobank. It has unrestricted accounts.
class Rabobank(Bank):
    def name(self):
        return 'Rabobank'
    def createAccount(self, name):
        if name in self.accounts:
            raise ValueError('Account already exists')
        self.accounts[name] = Account()


# Special bank: ABN. It has restricted accounts.
class ABN(Bank):
    def name(self):
        return 'ABN bank'
    def createAccount(self, name):
        if name in self.accounts:
            raise ValueError('Account already exists')
        self.accounts[name] = RestrictedAccount()

########NEW FILE########
__FILENAME__ = client
#
#    Bank client.
#
#    The client searches the two banks and performs a set of operations.
#    (the banks are searched simply by listing a namespace prefix path)
#

from __future__ import print_function
import sys
import Pyro4

# A bank client.
class client(object):
    def __init__(self,name):
        self.name=name
    def doBusiness(self, bank):
        print("\n*** %s is doing business with %s:" % (self.name, bank.name()))
        print("Creating account")
        try:
            bank.createAccount(self.name)
        except ValueError:
            x=sys.exc_info()[1]
            print("Failed: %s" % x)
            print("Removing account and trying again")
            bank.deleteAccount(self.name)
            bank.createAccount(self.name)

        print("Deposit money")
        bank.deposit(self.name, 200.00)
        print("Deposit money")
        bank.deposit(self.name, 500.75)
        print("Balance=%.2f" % bank.balance(self.name))
        print("Withdraw money")
        bank.withdraw(self.name, 400.00)
        print("Withdraw money (overdraw)")
        try:
            bank.withdraw(self.name, 400.00)
        except ValueError:
            x=sys.exc_info()[1]
            print("Failed: %s" % x)
        print("End balance=%.2f" % bank.balance(self.name))

        print("Withdraw money from non-existing account")
        try:
            bank.withdraw('GOD',2222.22)
            print("!!! Succeeded?!? That is an error")
        except KeyError:
            x=sys.exc_info()[1]
            print("Failed as expected: %s" % x)

        print("Deleting non-existing account")
        try:
            bank.deleteAccount('GOD')
            print("!!! Succeeded?!? That is an error")
        except KeyError:
            x=sys.exc_info()[1]
            print("Failed as expected: %s" % x)


ns=Pyro4.naming.locateNS()

# list the available banks by looking in the NS for the given prefix path
banknames=[name for name in ns.list(prefix="example.banks.")]
if not banknames:
    raise RuntimeError('There are no banks to do business with!')

banks=[]    # list of banks (proxies)
print()
for name in banknames:
    print("Contacting bank: %s" % name)
    uri=ns.lookup(name)
    banks.append(Pyro4.core.Proxy(uri))

# Different clients that do business with all banks
irmen = client('Irmen')
suzy = client('Suzy')

for bank in banks:
    irmen.doBusiness(bank)
    suzy.doBusiness(bank)

# List all accounts
print()
for bank in banks:
    print("The accounts in the %s:" % bank.name())
    accounts = bank.allAccounts()
    for name in accounts.keys():
        print("  %s : %.2f" % (name,accounts[name]))

########NEW FILE########
__FILENAME__ = server
#
#   The banks server
#

from __future__ import print_function
import Pyro4
import banks

ns=Pyro4.naming.locateNS()
daemon=Pyro4.core.Daemon()

uri=daemon.register(banks.Rabobank())
ns.register("example.banks.rabobank",uri)
uri=daemon.register(banks.ABN())
ns.register("example.banks.abn",uri)

print("available banks:")
print(list(ns.list(prefix="example.banks.").keys()))

# enter the service loop.
print("Banks are ready for customers.")
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import time
from Pyro4.util import getPyroTraceback
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

NUMBER_OF_LOOPS=20000


uri=input("enter server object uri: ").strip()
p=Pyro4.Proxy(uri)

# First, we do a loop of N normal remote calls on the proxy
# We time the loop and validate the computation result
print("Normal remote calls...")
begin=time.time()
total=0
p.printmessage("beginning normal calls")
for i in range(NUMBER_OF_LOOPS):
    total+=p.multiply(7,6)
    total+=p.add(10,20)
p.printmessage("end of normal calls")
assert total==(NUMBER_OF_LOOPS*(7*6 + 10+20))   # check
duration=time.time()-begin
print("that took {0:.2f} seconds ({1:.0f} calls/sec)".format(duration, NUMBER_OF_LOOPS*2.0/duration))
duration_normal=duration


# Now we do the same loop of N remote calls but this time we use
# the batched calls proxy. It collects all calls and processes them
# in a single batch. For many subsequent calls on the same proxy this
# is much faster than doing all calls individually.
# (but it has a few limitations and requires changes to your code)
print("\nBatched remote calls...")
begin=time.time()
batch=Pyro4.batch(p)        # get a batched call proxy for 'p'
batch.printmessage("beginning batch #1")
for i in range(NUMBER_OF_LOOPS):
    batch.multiply(7,6)         # queue a call, note that it returns 'None' immediately
    batch.add(10,20)            # queue a call, note that it returns 'None' immediately
batch.printmessage("end of batch #1")
print("processing the results...")
total=0
result=batch()      # execute the batch of remote calls, it returns a generator that produces all results in sequence
for r in result:
    total+=r
duration=time.time()-begin
assert total==(NUMBER_OF_LOOPS*(7*6 + 10+20))   # check
print("total time taken {0:.2f} seconds ({1:.0f} calls/sec)".format(duration, NUMBER_OF_LOOPS*2.0/duration//100*100))
print("batched calls were {0:.1f} times faster than normal remote calls".format(duration_normal/duration))

# Now we do another loop of batched calls, but this time oneway (no results).
print("\nOneway batched remote calls...")
begin=time.time()
batch=Pyro4.batch(p)        # get a batched call proxy for 'p'
batch.printmessage("beginning batch #2")
for i in range(NUMBER_OF_LOOPS):
    batch.multiply(7,6)         # queue a call, note that it returns 'None' immediately
    batch.add(10,20)            # queue a call, note that it returns 'None' immediately
batch.delay(2)     # queue a delay of 2 seconds (but we won't notice)
batch.printmessage("end of batch #2")
print("executing batch, there will be no result values. Check server to see printed messages...")
result=batch(oneway=True)      # execute the batch of remote calls, oneway, will return None
assert result is None
duration=time.time()-begin
print("total time taken {0:.2f} seconds ({1:.0f} calls/sec)".format(duration, NUMBER_OF_LOOPS*2.0/duration//100*100))
print("oneway batched calls were {0:.1f} times faster than normal remote calls".format(duration_normal/duration))

# Batches can be executed async as well
print("\nBatched remote calls, async...")
batch=Pyro4.batch(p)        # get a batched call proxy for 'p'
batch.printmessage("beginning batch #3")
batch.multiply(7,6)         # queue a call, note that it returns 'None' immediately
batch.add(10,20)            # queue a call, note that it returns 'None' immediately
batch.delay(2)      # queue a delay, but this doesn't matter with async
batch.printmessage("end of batch #3")
print("executing the batch... (should return immediately because async)")
asyncresult=batch(async=True)     # execute the batch, async (return immediately)
print("processing the results...(should wait until async results become available)")
results=list(asyncresult.value)
print("results=",results)


# Show what happens when one of the methods in a batch generates an error.
# (the batch is aborted and the error is raised locally again).
# Btw, you can re-use a batch proxy once you've called it and processed the results.
print("\nBatch with an error. Dividing a number by decreasing divisors...")
for d in range(3,-3,-1):    #  divide by 3,2,1,0,-1,-2,-3... but 0 will be a problem ;-)
    batch.divide(100,d)
print("getting results...")
divisor=3
try:
    for result in batch():
        print("100//%d = %d" % (divisor,result))
        divisor-=1
        # this will raise the proper zerodivision exception once we're about
        # to process the batch result from the divide by 0 call.
except Exception:
    print("An error occurred during the batch! (expected)")
    print("".join(getPyroTraceback()))

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4
from Pyro4.socketutil import getIpAddress

class Thingy(object):
    def multiply(self,a,b):
        return a*b
    def add(self,a,b):
        return a+b
    def divide(self,a,b):
        return a//b
    def error(self):
        return 1//0
    def delay(self, seconds):
        time.sleep(seconds)
        return seconds
    def printmessage(self,message):
        print(message)
        return 0

d=Pyro4.Daemon(host=getIpAddress("", workaround127=True), port=0)
uri=d.register(Thingy(), "example.batched")
print("server object uri:",uri)
print("batched calls server running.")
d.requestLoop()

########NEW FILE########
__FILENAME__ = bench
class sub1(object):
    def meth1(s,arg):
        return 'This is sub1.meth1'
class sub2(sub1):
    def meth2(s,arg):
        return 'This is sub2.meth2'
class sub3(sub2):
    def meth3(s,arg):
        return 'This is sub3.meth3'
class sub4(sub3,sub2):
    def meth4(s,arg):
        return 'This is sub4.meth4'

class bench(sub4):
    def ping(self):
        pass
    def length(self, string):
        return len(string)
    def timestwo(self, value):
        return value*2
    def bigreply(self):
        return 'BIG REPLY'*500
    def bigarg(self,arg):
        return len(arg)
    def manyargs(self, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15):
        return a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12+a13+a14+a15
    def noreply(self, arg):
        pass
    def varargs(self, *args):
        return len(args)
    def keywords(self, **args):
        return args
    def echo(self, *args):
        return args
    def oneway(self, *args):
        # oneway doesn't return anything
        pass
    def mapping(self, mapping):
        return mapping

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys,time
import Pyro4
import bench

if sys.version_info<(3,0):
    input=raw_input

uri=input("Uri of benchmark server? ").strip()
object = Pyro4.core.Proxy(uri)
object._pyroOneway.add('oneway')
object._pyroBind()

def f1():
    _=object.length('Irmen de Jong')
def f2():
    _=object.timestwo(21)
def f3():
    _=object.bigreply()
def f4():
    _=object.manyargs(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
def f5():
    _=object.noreply(99993333)
def f6():
    _=object.varargs('een',2,(3,),[4])
def f7():
    _=object.keywords(arg1='zork')
def f8():
    _=object.echo('een',2,(3,),[4])
def f9():
    _=object.meth1('stringetje')
def fa():
    _=object.meth2('stringetje')
def fb():
    _=object.meth3('stringetje')
def fc():
    _=object.meth4('stringetje')
def fd():
    _=object.bigarg('Argument'*50)
def fe():
    object.oneway('stringetje',432423434)
def ff():
    _=object.mapping({"aap":42, "noot": 99, "mies": 987654})

funcs = (f1,f2,f3,f4,f5,f6,f7,f8,f9,fa,fb,fc,fd,fe,ff)

print('-------- BENCHMARK REMOTE OBJECT ---------')
print('Pay attention to the "fe" test -- this is a Oneway call and should be *fast*')
print('(if you are running the server and client on different machines)')
begin = time.time()
iters = 1000
for f in funcs:
    sys.stdout.write("%d times %s " % (iters,f.__name__))
    voor = time.time()
    for i in range(iters):
        f()
    sys.stdout.write("%.3f\n" % (time.time()-voor))
    sys.stdout.flush()
duration = time.time()-begin
print('total time %.3f seconds' % duration)
amount=len(funcs)*iters
print('total method calls: %d' % (amount))
avg_pyro_msec = 1000.0*duration/amount
print('avg. time per method call: %.3f msec (%d/sec) (serializer: %s)' % (avg_pyro_msec,amount/duration, Pyro4.config.SERIALIZER))

print('-------- BENCHMARK LOCAL OBJECT ---------')
object=bench.bench()
begin = time.time()
iters = 200000
for f in funcs:
    sys.stdout.write("%d times %s " % (iters,f.__name__))
    voor = time.time()
    for i in range(iters):
        f()
    sys.stdout.write("%.3f\n" % (time.time()-voor))
    sys.stdout.flush()
duration = time.time()-begin
print('total time %.3f seconds' % duration)
amount=len(funcs)*iters
print('total method calls: %d' % (amount))
avg_normal_msec = 1000.0*duration/amount
print('avg. time per method call: %.3f msec (%d/sec)' % (avg_normal_msec,amount/duration//1000*1000))
print('Normal method call is %.0f times faster than Pyro method call.'%(avg_pyro_msec/avg_normal_msec))

########NEW FILE########
__FILENAME__ = connections
from __future__ import print_function
import time, sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

uri=input("Uri of benchmark server? ").strip()

print("Timing raw connect speed (no method call)...")
p=Pyro4.core.Proxy(uri)
p.ping()
ITERATIONS=2000
begin=time.time()
for loop in range(ITERATIONS):
    if loop%500==0:
        print(loop)
    p._pyroRelease()
    p._pyroBind()
duration=time.time()-begin
print("%d connections in %.3f sec = %.0f conn/sec" % (ITERATIONS, duration, ITERATIONS/duration))
del p

print("Timing proxy creation+connect+methodcall speed...")
ITERATIONS=2000
begin=time.time()
for loop in range(ITERATIONS):
    if loop%500==0:
        print(loop)
    with Pyro4.core.Proxy(uri) as p:
        p.ping()
duration=time.time()-begin
print("%d new proxy calls in %.3f sec = %.0f calls/sec" % (ITERATIONS, duration, ITERATIONS/duration))

print("Timing proxy methodcall speed...")
p=Pyro4.core.Proxy(uri)
p.ping()
ITERATIONS=10000
begin=time.time()
for loop in range(ITERATIONS):
    if loop%1000==0:
        print(loop)
    p.ping()
duration=time.time()-begin
print("%d calls in %.3f sec = %.0f calls/sec" % (ITERATIONS, duration, ITERATIONS/duration))
print("Serializer used:", Pyro4.config.SERIALIZER)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import Pyro4
import bench

obj=bench.bench()
daemon=Pyro4.Daemon()
uri = daemon.register(obj,"example.benchmark")
print("Server running, uri = %s" % uri)
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import with_statement
import random
import Pyro4

# We need to set either a socket communication timeout,
# or use the select based server. Otherwise the daemon requestLoop
# will block indefinitely and is never able to evaluate the loopCondition.
Pyro4.config.COMMTIMEOUT=0.5

NUM_WORKERS=5

class CallbackHandler(object):
    workdone=0
    def done(self, number):
        print("callback: worker %d reports work is done!" % number)
        CallbackHandler.workdone+=1

with Pyro4.core.Daemon() as daemon:
    # register our callback handler
    callback=CallbackHandler()
    daemon.register(callback)

    # contact the server and put it to work
    print("creating a bunch of workers")
    with Pyro4.core.Proxy("PYRONAME:example.callback") as server:
        for _ in range(NUM_WORKERS):
            worker=server.addworker(callback)   # provide our callback handler!
            worker._pyroOneway.add("work")      # to be able to run in the background
            worker.work(random.randint(1,5))

    print("waiting for all work complete...")
    daemon.requestLoop(loopCondition=lambda: CallbackHandler.workdone<NUM_WORKERS)
    print("done!")

########NEW FILE########
__FILENAME__ = client2
from __future__ import print_function
import Pyro4

class CallbackHandler(object):
    def crash(self):
        a=1
        b=0
        return a//b
    def call1(self):
        print("callback 1 received from server!")
        print("going to crash - you won't see the exception here, only on the server")
        return self.crash()
    @Pyro4.callback
    def call2(self):
        print("callback 2 received from server!")
        print("going to crash - but you will see the exception here too")
        return self.crash()


daemon=Pyro4.core.Daemon()
callback=CallbackHandler()
daemon.register(callback)

with Pyro4.core.Proxy("PYRONAME:example.callback2") as server:
    server._pyroOneway.add("doCallback")
    server.doCallback(callback)

print("waiting for callbacks to arrive...")
print("(ctrl-c/break the program once it's done)\n")
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = server
from __future__ import with_statement
import time
import Pyro4

class Worker(object):
    def __init__(self, number, callback):
        self.number=number
        self.callback=callback
        print("Worker %d created" % self.number)
    def work(self, amount):
        print("Worker %d busy..." % self.number)
        time.sleep(amount)
        print("Worker %d done. Informing callback client." % self.number)
        self._pyroDaemon.unregister(self)
        self.callback.done(self.number)    # invoke the callback object

class CallbackServer(object):
    def __init__(self):
        self.number=0
    def addworker(self, callback):
        self.number+=1
        print("server: adding worker %d" % self.number)
        worker=Worker(self.number, callback)
        self._pyroDaemon.register(worker)   # make it a Pyro object
        return worker

with Pyro4.core.Daemon() as daemon:
    with Pyro4.naming.locateNS() as ns:
        obj=CallbackServer()
        uri=daemon.register(obj)
        ns.register("example.callback",uri)
    print("Server ready.")
    daemon.requestLoop()

########NEW FILE########
__FILENAME__ = server2
from __future__ import with_statement
import Pyro4

class CallbackServer(object):
    def doCallback(self, callback):
        print("server: doing callback 1 to client")
        try:
            callback.call1()
        except:
            print("got an exception from the callback.")
            print("".join(Pyro4.util.getPyroTraceback()))
        print("server: doing callback 2 to client")
        try:
            callback.call2()
        except:
            print("got an exception from the callback.")
            print("".join(Pyro4.util.getPyroTraceback()))
        print("server: callbacks done")

with Pyro4.core.Daemon() as daemon:
    with Pyro4.naming.locateNS() as ns:
        obj=CallbackServer()
        uri=daemon.register(obj)
        ns.register("example.callback2",uri)
    print("Server ready.")
    daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import with_statement
import sys
import Pyro4
from Pyro4 import threadutil

if sys.version_info<(3,0):
    input=raw_input

# The daemon is running in its own thread, to be able to deal with server
# callback messages while the main thread is processing user input.

class Chatter(object):
    def __init__(self):
        self.chatbox = Pyro4.core.Proxy('PYRONAME:example.chatbox.server')
        self.abort=0
    def message(self, nick, msg):
        if nick!=self.nick:
            print('[{0}] {1}'.format(nick, msg))
    def start(self):
        nicks=self.chatbox.getNicks()
        if nicks:
            print('The following people are on the server: %s' % (', '.join(nicks)))
        channels=sorted(self.chatbox.getChannels())
        if channels:
            print('The following channels already exist: %s' % (', '.join(channels)))
            self.channel=input('Choose a channel or create a new one: ').strip()
        else:
            print('The server has no active channels.')
            self.channel=input('Name for new channel: ').strip()
        self.nick=input('Choose a nickname: ').strip()
        people=self.chatbox.join(self.channel, self.nick, self)
        print('Joined channel %s as %s' % (self.channel, self.nick))
        print('People on this channel: %s' % (', '.join(people)))
        print('Ready for input! Type /quit to quit')
        try:
            try:
                while not self.abort:
                    line=input('> ').strip()
                    if line=='/quit':
                        break
                    if line:
                        self.chatbox.publish(self.channel ,self.nick ,line)
            except EOFError:
                pass
        finally:
            self.chatbox.leave(self.channel, self.nick)
            self.abort=1
            self._pyroDaemon.shutdown()

class DaemonThread(threadutil.Thread):
    def __init__(self, chatter):
        threadutil.Thread.__init__(self)
        self.chatter=chatter
        self.setDaemon(True)
    def run(self):
        with Pyro4.core.Daemon() as daemon:
            daemon.register(self.chatter)
            daemon.requestLoop(lambda: not self.chatter.abort)

chatter=Chatter()
daemonthread=DaemonThread(chatter)
daemonthread.start()
chatter.start()
print('Exit.')

########NEW FILE########
__FILENAME__ = server
from __future__ import with_statement
import Pyro4

# Chat box administration server.
# Handles logins, logouts, channels and nicknames, and the chatting.
class ChatBox(object):
    def __init__(self):
        self.channels={}        # registered channels { channel --> (nick, client callback) list }
        self.nicks=[]            # all registered nicks on this server
    def getChannels(self):
        return list(self.channels.keys())
    def getNicks(self):
        return self.nicks
    def join(self, channel, nick, callback):
        if not channel or not nick:
            raise ValueError("invalid channel or nick name")
        if nick in self.nicks:
            raise ValueError('this nick is already in use')
        if channel not in self.channels:
            print('CREATING NEW CHANNEL %s' % channel)
            self.channels[channel]=[]
        self.channels[channel].append((nick, callback))
        self.nicks.append(nick)
        callback._pyroOneway.add('message')    # don't wait for results for this method
        print("%s JOINED %s" % (nick, channel))
        self.publish(channel,'SERVER','** '+nick+' joined **')
        return [nick for (nick,c) in self.channels[channel]]  # return all nicks in this channel
    def leave(self,channel,nick):
        if not channel in self.channels:
            print('IGNORED UNKNOWN CHANNEL %s' % channel)
            return
        for (n,c) in self.channels[channel]:
            if n==nick:
                self.channels[channel].remove((n, c))
                break
        self.publish(channel,'SERVER','** '+nick+' left **')
        if len(self.channels[channel])<1:
            del self.channels[channel]
            print('REMOVED CHANNEL %s' % channel)
        self.nicks.remove(nick)
        print("%s LEFT %s" % (nick, channel))
    def publish(self, channel, nick, msg):
        if not channel in self.channels:
            print('IGNORED UNKNOWN CHANNEL %s' % channel)
            return
        for (n,c) in self.channels[channel][:]:        # use a copy of the list
            try:
                c.message(nick,msg)    # oneway call
            except Pyro4.errors.ConnectionClosedError:
                # connection dropped, remove the listener if it's still there
                # check for existence because other thread may have killed it already
                if (n,c) in self.channels[channel]:
                    self.channels[channel].remove((n, c))
                    print('Removed dead listener %s %s' % (n, c))

with Pyro4.core.Daemon() as daemon:
    with Pyro4.naming.locateNS() as ns:
        uri=daemon.register(ChatBox())
        ns.register("example.chatbox.server",uri)
    # enter the service loop.
    print('Chatbox open.')
    daemon.requestLoop()

########NEW FILE########
__FILENAME__ = chain
from __future__ import print_function
import Pyro4

# a Chain member. Passes messages to the next link,
# until the message went full-circle: then it exits.

class Chain(object):
    def __init__(self, name, next):
        self.name=name
        self.nextName=next
        self.next=None
    def process(self,message):
        if self.next is None:
            self.next=Pyro4.core.Proxy("PYRONAME:example.chain."+self.nextName)
        if self.name in message:
            print("Back at %s; we completed the circle!" % self.name)
            return ["complete at "+self.name]
        else:
            print("I'm %s, passing to %s" % (self.name,self.nextName))
            message.append(self.name)
            result=self.next.process(message)
            result.insert(0,"passed on from "+self.name)
            return result

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import Pyro4

obj=Pyro4.core.Proxy("PYRONAME:example.chain.A")
print("Result=%s" % obj.process(["hello"]))

########NEW FILE########
__FILENAME__ = servA
from __future__ import print_function
import Pyro4
import chain

this = "A"
next = "B"

servername="example.chain."+this

daemon=Pyro4.core.Daemon()
obj=chain.Chain(this,next)
uri=daemon.register(obj)
ns=Pyro4.naming.locateNS()
ns.register(servername,uri)

# enter the service loop.
print("Server started %s" % this)
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = servB
from __future__ import print_function
import Pyro4
import chain

this = "B"
next = "C"

servername="example.chain."+this

daemon=Pyro4.core.Daemon()
obj=chain.Chain(this,next)
uri=daemon.register(obj)
ns=Pyro4.naming.locateNS()
ns.register(servername,uri)

# enter the service loop.
print("Server started %s" % this)
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = servC
from __future__ import print_function
import Pyro4
import chain

this = "C"
next = "A"

servername="example.chain."+this

daemon=Pyro4.core.Daemon()
obj=chain.Chain(this,next)
uri=daemon.register(obj)
ns=Pyro4.naming.locateNS()
ns.register(servername,uri)

# enter the service loop.
print("Server started %s" % this)
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = bouncer
from __future__ import print_function, with_statement
import Pyro4.threadutil

# a message bouncer. Passes messages back to the callback
# object, until a certain limit is reached.

class Bouncer(object):
    def __init__(self, name):
        self.name = name
        self.count = 0
        self.callbackMutex = Pyro4.threadutil.Lock()

    def register(self, callback):
        self.callback = callback

    def process(self, message):
        print("in process", self.name)
        if len(message) >= 3:
            print("Back in", self.name, ", message is large enough... stopping!")
            return ["complete at " + self.name + ":" + str(self.count)]

        print("I'm", self.name, ", bouncing back...")
        message.append(self.name)
        with self.callbackMutex:
            result = self.callback.process(message)
        self.count += 1
        result.insert(0, "passed on from " + self.name + ":" + str(self.count))
        print("returned from callback")
        return result

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function

import Pyro4
from Pyro4.threadutil import Thread
import bouncer

abort = False

def PyroLoop(daemon):
    daemon.requestLoop()

def main():
    global abort
    daemon = Pyro4.Daemon()
    server = Pyro4.Proxy("PYRONAME:example.deadlock")

    bounceObj = bouncer.Bouncer("Client")
    daemon.register(bounceObj) # callback objece

    # register callback obj on theserver
    server.register(bounceObj)
    # register server as 'callback' on the bounce object in this client
    # note: we're using the same proxy here as the main program!
    # This is the main cause of the deadlock, because this proxy will already
    # be engaged in a call when the callback object here wants to use it as well.
    # One solution could be to use a new proxy from inside the callback object, like this:
    #   server2 = server.__copy__()
    #   bounceObj.register(server2)
    bounceObj.register(server)

    # create a thread that handles callback requests
    thread = Thread(target=PyroLoop, args=(daemon,))
    thread.setDaemon(True)
    thread.start()

    print("This bounce example will deadlock!")
    print("Read the source or Readme.txt for more info why this is the case!")

    print("Calling server...")
    result = server.process(["hello"])
    print("Result=", result)   # <--- you will never see this, it will deadlock in the previous call

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import Pyro4
import bouncer

daemon = Pyro4.Daemon()
uri = daemon.register(bouncer.Bouncer("Server"))
Pyro4.locateNS().register("example.deadlock",uri)

print("This bounce example will deadlock!")
print("Read the source or Readme.txt for more info why this is the case!")
print("Bouncer started.")
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4
import Pyro4.message
import warnings

warnings.filterwarnings("ignore")

if sys.version_info < (3, 0):
    input = raw_input

print("You can run this client on a different computer so you can disable the network connection (by yanking out the lan cable or whatever).")
print("Alternatively, wait for a timeout on the server, which will then close its connection.")
uri = input("Uri of server? ").strip()


class AutoReconnectingProxy(Pyro4.core.Proxy):
    """
    A Pyro proxy that automatically recovers from a server disconnect.
    It does this by intercepting every method call and then it first 'pings'
    the server to see if it still has a working connection. If not, it
    reconnects the proxy and retries the method call.
    Drawback is that every method call now uses two remote messages (a ping,
    and the actual method call).
    This uses some advanced features of the Pyro API.
    """

    def _pyroInvoke(self, methodname, vargs, kwargs, flags=0):
        # first test if we have an open connection, if not, we just reconnect
        if self._pyroConnection:
            try:
                print("  <proxy: ping>")
                # send the special 'ping' message to the daemon, to see if this connection is still alive
                # we expect a 'ping' response (no-op)
                ping = Pyro4.message.Message(Pyro4.message.MSG_PING, b"ping", 42, 0, 0)
                self._pyroConnection.send(ping.to_bytes())
                Pyro4.message.Message.recv(self._pyroConnection, [Pyro4.message.MSG_PING])
                print("  <proxy: ping reply (still connected)>")
            except Pyro4.errors.ConnectionClosedError:     # or possibly even ProtocolError
                print("  <proxy: Connection lost. REBINDING...>")
                self._pyroReconnect()
                print("  <proxy: Connection restored, continue with actual method call...>")
        return super(AutoReconnectingProxy, self)._pyroInvoke(methodname, vargs, kwargs, flags)


with AutoReconnectingProxy(uri) as obj:
    result = obj.echo("12345")
    print("result =", result)
    print("\nClient proxy connection is still open. Disable the network now (or wait until the connection timeout on the server expires) and see what the server does.")
    print("Once you see on the server that it got a timeout or a disconnect, enable the network again.")
    input("Press enter to continue:")
    print("\nDoing a new call on the same proxy:")
    result = obj.echo("12345")
    print("result =", result)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import logging
import Pyro4

logging.basicConfig(level=logging.DEBUG)
logging.getLogger("Pyro4").setLevel(logging.DEBUG)

Pyro4.config.COMMTIMEOUT = 5.0
Pyro4.config.POLLTIMEOUT = 5.0  # only used for multiplexing server


class TestDisconnect(object):
    def echo(self, arg):
        print("echo: ", arg)
        return arg


d = Pyro4.Daemon()
uri = d.register(TestDisconnect(), "disconnect")
print("uri =", uri)
d.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import with_statement
try:
    import queue
except ImportError:
    import Queue as queue
import random
import Pyro4
from workitem import Workitem

# we're using custom classes, so need to use pickle
Pyro4.config.SERIALIZER='pickle'

NUMBER_OF_ITEMS = 40


def main():
    print("\nThis program will calculate Prime Factorials of a bunch of random numbers.")
    print("The more workers you will start (on different cpus/cores/machines),")
    print("the faster you will get the complete list of results!\n")
    with Pyro4.core.Proxy("PYRONAME:example.distributed.dispatcher") as dispatcher:
        placework(dispatcher)
        numbers=collectresults(dispatcher)
    printresults(numbers)

def placework(dispatcher):
    print("placing work items into dispatcher queue.")
    for i in range(NUMBER_OF_ITEMS):
        number = random.randint(3211, 4999999) * random.randint(3211, 999999)
        item = Workitem(i+1, number)
        dispatcher.putWork(item)

def collectresults(dispatcher):
    print("getting results from dispatcher queue.")
    numbers={}
    while len(numbers)<NUMBER_OF_ITEMS:
        try:
            item = dispatcher.getResult()
            print("Got result: %s (from %s)" % (item, item.processedBy))
            numbers[item.data] = item.result
        except queue.Empty:
            print("Not all results available yet (got %d out of %d). Work queue size: %d" %  \
                    (len(numbers),NUMBER_OF_ITEMS,dispatcher.workQueueSize()))

    if dispatcher.resultQueueSize()>0:
        print("there's still stuff in the dispatcher result queue, that is odd...")
    return numbers

def printresults(numbers):
    print("\nComputed Prime Factorials follow:")
    for (number, factorials) in numbers.items():
        print("%d --> %s" % (number,factorials))

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = dispatcher
from __future__ import print_function

try:
    import queue
except ImportError:
    import Queue as queue
import Pyro4

# we're using custom classes, so need to use pickle
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')


class DispatcherQueue(object):
    def __init__(self):
        self.workqueue = queue.Queue()
        self.resultqueue = queue.Queue()
    def putWork(self, item):
        self.workqueue.put(item)
    def getWork(self, timeout=5):
        return self.workqueue.get(block=True, timeout=timeout)
    def putResult(self, item):
        self.resultqueue.put(item)
    def getResult(self, timeout=5):
        return self.resultqueue.get(block=True, timeout=timeout)
    def workQueueSize(self):
        return self.workqueue.qsize()
    def resultQueueSize(self):
        return self.resultqueue.qsize()

######## main program

Pyro4.Daemon.serveSimple({
        DispatcherQueue(): "example.distributed.dispatcher"
    })

########NEW FILE########
__FILENAME__ = worker
from __future__ import print_function
import os,socket,sys
from math import sqrt
try:
    import queue
except ImportError:
    import Queue as queue
import Pyro4
from workitem import Workitem

if sys.version_info<(3,0):
    range=xrange

# we're using custom classes, so need to use pickle
Pyro4.config.SERIALIZER='pickle'


WORKERNAME = "Worker_%d@%s" % (os.getpid(), socket.gethostname())

def factorize(n):
    """simple algorithm to find the prime factorials of the given number n"""
    def isPrime(n):
        return not [x for x in range(2,int(sqrt(n))+1) if n%x == 0]
    primes = []
    candidates = range(2,n+1)
    candidate = 2
    while not primes and candidate in candidates:
        if n%candidate == 0 and isPrime(candidate):
            primes = primes + [candidate] + factorize(n//candidate)
        candidate+=1
    return primes

def process(item):
    print("factorizing %s -->" % item.data)
    sys.stdout.flush()
    item.result=factorize(int(item.data))
    print(item.result)
    item.processedBy = WORKERNAME

def main():
    dispatcher = Pyro4.core.Proxy("PYRONAME:example.distributed.dispatcher")
    print("This is worker %s" % WORKERNAME)
    print("getting work from dispatcher.")
    while True:
        try:
            item = dispatcher.getWork()
        except queue.Empty:
            print("no work available yet.")
        else:
            process(item)
            dispatcher.putResult(item)

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = workitem
class Workitem(object):
    def __init__(self, itemId, data):
        print("Created workitem %s" % itemId)
        self.itemId=itemId
        self.data=data
        self.result=None
        self.processedBy=None
    def __str__(self):
        return "<Workitem id=%s>" % str(self.itemId)

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4
import Pyro4.util

print("First start the built-in test echo server with something like:")
print("$ python -m Pyro4.test.echoserver")
print("Enter the server's uri that was printed:")
if sys.version_info<(3,0):
    uri=raw_input()
else:
    uri=input()
uri=uri.strip()
echoserver=Pyro4.Proxy(uri)

response=echoserver.echo("hello")
print("\ngot back from the server: %s" % response)
response=echoserver.echo([1,2,3,4])
print("got back from the server: %s" % response)

try:
    echoserver.error()
except:
    print("\ncaught an exception (expected), traceback:")
    print("".join(Pyro4.util.getPyroTraceback()))

print("\nshutting down the test echo server. (restart it if you want to run this again)")
echoserver.shutdown()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import Pyro4
import sys

if sys.version_info<(3,0):
    input=raw_input


with Pyro4.core.Proxy("PYRONAME:example.embedded.server") as proxy:
    print("5*11=%d" % proxy.multiply(5,11))
    print("'x'*10=%s" % proxy.multiply('x',10))

    input("press enter to do a loop of some more calls:")
    for i in range(1,20):
        print("2*i=%d" % proxy.multiply(2,i))
        print("'@'*i=%s" % proxy.multiply('@',i))

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import socket
import select
import sys
import Pyro4.core
import Pyro4.naming
import Pyro4.socketutil

if sys.version_info<(3,0):
    input=raw_input

print("Make sure that you don't have a name server running already.")
servertype=input("Servertype thread/multiplex (t/m)?")
if servertype=='t':
    Pyro4.config.SERVERTYPE="thread"
else:
    Pyro4.config.SERVERTYPE="multiplex"

hostname=socket.gethostname()
my_ip = Pyro4.socketutil.getIpAddress(None, workaround127=True)

class EmbeddedServer(object):
    def multiply(self, x, y):
        return x*y


print("initializing services... servertype=%s" % Pyro4.config.SERVERTYPE)
# start a name server with broadcast server as well
nameserverUri, nameserverDaemon, broadcastServer = Pyro4.naming.startNS(host=my_ip)
assert broadcastServer is not None, "expect a broadcast server to be created"

print("got a Nameserver, uri=%s" % nameserverUri)
print("ns daemon location string=%s" % nameserverDaemon.locationStr)
print("ns daemon sockets=%s" % nameserverDaemon.sockets)
print("bc server socket=%s (fileno %d)" % (broadcastServer.sock, broadcastServer.fileno()))

# create a Pyro daemon
pyrodaemon=Pyro4.core.Daemon(host=hostname)
print("daemon location string=%s" % pyrodaemon.locationStr)
print("daemon sockets=%s" % pyrodaemon.sockets)

# register a server object with the daemon
serveruri=pyrodaemon.register(EmbeddedServer())
print("server uri=%s" % serveruri)

# register it with the embedded nameserver directly
nameserverDaemon.nameserver.register("example.embedded.server",serveruri)

print("")

# below is our custom event loop.
while True:
    print("Waiting for events...")
    # create sets of the socket objects we will be waiting on
    # (a set provides fast lookup compared to a list)
    nameserverSockets = set(nameserverDaemon.sockets)
    pyroSockets = set(pyrodaemon.sockets)
    rs=[broadcastServer]  # only the broadcast server is directly usable as a select() object
    rs.extend(nameserverSockets)
    rs.extend(pyroSockets)
    rs,_,_ = select.select(rs,[],[],3)
    eventsForNameserver=[]
    eventsForDaemon=[]
    for s in rs:
        if s is broadcastServer:
            print("Broadcast server received a request")
            broadcastServer.processRequest()
        elif s in nameserverSockets:
            eventsForNameserver.append(s)
        elif s in pyroSockets:
            eventsForDaemon.append(s)
    if eventsForNameserver:
        print("Nameserver received a request")
        nameserverDaemon.events(eventsForNameserver)
    if eventsForDaemon:
        print("Daemon received a request")
        pyrodaemon.events(eventsForDaemon)


nameserverDaemon.close()
broadcastServer.close()
pyrodaemon.close()
print("done")

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4

test = Pyro4.core.Proxy("PYRONAME:example.exceptions")

print(test.div(2.0,9.0))
try:
    print(2//0)
except ZeroDivisionError:
    print("DIVIDE BY ZERO: %s" % sys.exc_info()[1])
try:
    print(test.div(2,0))
except ZeroDivisionError:
    print("DIVIDE BY ZERO: %s" % sys.exc_info()[1])
try:
    result=test.error()
    print("%r, %s" % (result,result))
except ValueError:
    print("VALUERROR: %s" % sys.exc_info()[1])
try:
    result=test.error2()
    print("%r, %s" % (result,result))
except ValueError:
    print("VALUERROR: %s" % sys.exc_info()[1])
try:
    result=test.othererr()
    print("%r, %s" % (result,result))
except Exception:
    print("ANOTHER ERROR: %s" % sys.exc_info()[1])
try:
    result=test.unserializable()
    print("%r, %s" % (result,result))
except Exception:
    print("UNSERIALIZABLE ERROR: %s" % sys.exc_info()[1])


print("\n*** invoking server method that crashes, catching traceback ***")
try:
    print(test.complexerror())
except Exception:
    print("CAUGHT ERROR  >>> %s" % sys.exc_info()[1])
    print("Printing Pyro traceback >>>>>>")
    print("".join(Pyro4.util.getPyroTraceback()))
    print("<<<<<<< end of Pyro traceback")

print("\n*** installing pyro's excepthook")
sys.excepthook=Pyro4.util.excepthook
print("*** invoking server method that crashes, not catching anything ***")
print(test.complexerror())     # due to the excepthook, the exception will show the pyro error


########NEW FILE########
__FILENAME__ = excep
import pickle


class UnserializableError(Exception):
    def __reduce__(self):
        raise pickle.PicklingError("make this nonpickleable")


class TestClass(object):
    def div(self, arg1, arg2):
        return arg1/arg2
    def error(self):
        raise ValueError('a valueerror! Great!')
    def error2(self):
        return ValueError('a valueerror! Great!')
    def othererr(self):
        raise RuntimeError('a runtime error!')
    def complexerror(self):
        x=Foo()
        x.crash()
    def unserializable(self):
        raise UnserializableError("this error can't be serialized")


class Foo(object):
    def crash(self):
        self.crash2('going down...')
    def crash2(self, arg):
        # this statement will crash on purpose:
        x=arg//2

########NEW FILE########
__FILENAME__ = server
import Pyro4
import excep

Pyro4.Daemon.serveSimple(
    {
        excep.TestClass(): "example.exceptions"
    },
    ns=True, verbose=True)

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4.utils.flame

if sys.version_info<(3,0):
    input=raw_input

Pyro4.config.SERIALIZER = "pickle"  # flame requires pickle serializer

print("Start a Pyro Flame server somewhere.")
location = input("what is the location of the flame server, hostname:portnumber? ")
print()

# connect!
flame = Pyro4.utils.flame.connect(location)

# basic stuff
socketmodule = flame.module("socket")
osmodule = flame.module("os")
print("remote host name=", socketmodule.gethostname())
print("remote server current directory=", osmodule.getcwd())
flame.execute("import math")
root = flame.evaluate("math.sqrt(500)")
print("calculated square root=", root)
try:
    print("remote exceptions also work...", flame.evaluate("1//0"))
except ZeroDivisionError:
    print("(caught ZeroDivisionError)")

# print something to the remote server output
flame.builtin("print")("Hello there, remote server stdout!")

# upload a module source and call a function, on the server, in this new module
modulesource = open("stuff.py").read()
flame.sendmodule("flameexample.stuff", modulesource)
result = flame.module("flameexample.stuff").doSomething("hello", 42)
print("\nresult from uploaded module:", result)

# remote console
with flame.console() as console:
    print("\nStarting a remote console. Enter some commands to execute remotely. End the console as usual.")
    console.interact()
    print("Console session ended.")




########NEW FILE########
__FILENAME__ = stuff
# this module will be sent to the server as 'flameexample.stuff'

from __future__ import print_function

def doSomething(name, number):
    print("This text is printed from a module whose code was uploaded by the client:")
    print("  Hello, my name is {0} and my number is {1}.".format(name,number))
    return 999


  
########NEW FILE########
__FILENAME__ = futures
from __future__ import print_function
import Pyro4

def myfunction(a, b, extra=None):
    print(">>> myfunction called with: a={0}, b={1}, extra={2}".format(a, b, extra))
    return a+b

print("\n* just a single future call:")
future = Pyro4.Future(myfunction)
result = future(5,6)
# we can do stuff here in the meantime...
print("result value=", result.value)
assert result.value==11

print("\n* several calls chained:")
future = Pyro4.Future(myfunction)
future.then(myfunction, 10)
future.then(myfunction, 20, extra="something")
# the callables will be invoked like so:  function(asyncvalue, normalarg, kwarg=..., kwarg=...)
# (the value from the previous call is passed as the first argument to the next call)
result = future(5, 6)
# we can do stuff here in the meantime...
print("result value=", result.value)
assert result.value==41

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import time
import Pyro4

print("First make sure one of the gui servers is running.")
print("Enter the object uri that was printed:")
if sys.version_info<(3,0):
    uri=raw_input()
else:
    uri=input()
uri=uri.strip()
guiserver=Pyro4.Proxy(uri)

guiserver.message("Hello there!")
time.sleep(0.5)
guiserver.message("How's it going?")
time.sleep(2)

for i in range(20):
    guiserver.message("Counting {0}".format(i))

guiserver.message("now calling the sleep method with 5 seconds")
guiserver.sleep(5)
print("done!")

########NEW FILE########
__FILENAME__ = gui_nothreads
"""
This example shows a Tkinter GUI application that uses event loop callbacks
to integrate Pyro's event loop into the Tkinter GUI mainloop.

No threads are used. The Pyro event callback is called every so often
to check if there are Pyro events to handle, and handles them synchronously.
"""
from __future__ import with_statement
import time
import select
import Pyro4
try:
    from tkinter import *
    import tkinter.simpledialog as simpledialog
except ImportError:
    from Tkinter import *
    import tkSimpleDialog as simpledialog

# Set the Pyro servertype to the multiplexing select-based server that doesn't
# use a threadpool to service method calls. This way the method calls are
# handled inside the main thread as well.
Pyro4.config.SERVERTYPE="multiplex"

# The frequency with which the GUI loop calls the Pyro event handler.
PYRO_EVENTLOOP_HZ = 50


class PyroGUI(object):
    """
    The Tkinter GUI application that also listens for Pyro calls.
    """
    def __init__(self):
        self.tk=Tk()
        self.tk.wm_title("Pyro in a Tkinter GUI eventloop - without threads")
        self.tk.wm_geometry("500x500")
        buttonframe=Frame(self.tk)
        button=Button(buttonframe, text="Messagebox", command=self.button_msgbox_clicked)
        button.pack(side=LEFT)
        button=Button(buttonframe, text="Add some text", command=self.button_text_clicked)
        button.pack(side=LEFT)
        button=Button(buttonframe, text="Clear all text", command=self.button_clear_clicked)
        button.pack(side=LEFT)
        quitbutton=Button(buttonframe, text="Quit", command=self.tk.quit)
        quitbutton.pack(side=RIGHT)
        frame=Frame(self.tk, padx=2, pady=2)
        buttonframe.pack(fill=X)
        rlabel=Label(frame, text="Pyro server messages:")
        rlabel.pack(fill=X)
        self.msg=Message(frame, anchor=NW, width=500, aspect=80, background="white", relief="sunken")
        self.msg.pack(fill=BOTH, expand=1)
        frame.pack(fill=BOTH)
        self.serveroutput=[]


    def install_pyro_event_callback(self, daemon):
        """
        Add a callback to the tkinter event loop that is invoked every so often.
        The callback checks the Pyro sockets for activity and dispatches to the
        daemon's event process method if needed.
        """
        def pyro_event():
            while True:
                # for as long as the pyro socket triggers, dispatch events
                s,_,_ = select.select(daemon.sockets,[],[],0.01)
                if s:
                    daemon.events(s)
                else:
                    # no more events, stop the loop, we'll get called again soon anyway
                    break
            self.tk.after(1000//PYRO_EVENTLOOP_HZ, pyro_event)
        self.tk.after(1000//PYRO_EVENTLOOP_HZ, pyro_event)

    def mainloop(self):
        self.tk.mainloop()

    def button_msgbox_clicked(self):
        # this button event handler is here only to show that gui events are still processed normally
        number=simpledialog.askinteger("A normal popup","Hi there enter a number",parent=self.tk)

    def button_clear_clicked(self):
        self.serveroutput=[]
        self.msg.config(text="")

    def button_text_clicked(self):
        # add some random text to the message list
        self.add_message("The quick brown fox jumps over the lazy dog!")

    def add_message(self, message):
        message="[{0}] {1}".format(time.strftime("%X"), message)
        self.serveroutput.append(message)
        self.serveroutput=self.serveroutput[-27:]
        self.msg.config(text="\n".join(self.serveroutput))


class MessagePrinter(object):
    """
    The Pyro object that interfaces with the GUI application.
    """
    def __init__(self, gui):
        self.gui=gui
    def message(self, messagetext):
        # Add the message to the screen.
        # Note that you can't do anything that requires gui interaction
        # (such as popping a dialog box asking for user input),
        # because the gui (tkinter) is busy processing this pyro call.
        # It can't do two things at the same time when embedded this way.
        # If you do something in this method call that takes a long time
        # to process, the GUI is frozen during that time (because no GUI update
        # events are handled while this callback is active).
        self.gui.add_message("from Pyro: "+messagetext)

    def sleep(self, duration):
        # Note that you can't perform blocking stuff at all because the method
        # call is running in the gui mainloop thread and will freeze the GUI.
        # Try it - you will see the first message but everything locks up until
        # the sleep returns and the method call ends
        self.gui.add_message("from Pyro: sleeping {0} seconds...".format(duration))
        self.gui.tk.update()
        time.sleep(duration)
        self.gui.add_message("from Pyro: woke up!")


def main():
    gui=PyroGUI()

    # create a pyro daemon with object
    daemon=Pyro4.Daemon()
    obj=MessagePrinter(gui)
    uri=daemon.register(obj,"pyrogui.message")

    gui.add_message("Pyro server started. Not using threads.")
    gui.add_message("Use the command line client to send messages.")
    urimsg="Pyro object uri = {0}".format(uri)
    gui.add_message(urimsg)
    print(urimsg)

    # add a Pyro event callback to the gui's mainloop
    gui.install_pyro_event_callback(daemon)
    # enter the mainloop
    gui.mainloop()

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = gui_threads
"""
This example shows a Tkinter GUI application that uses a worker thread to
run Pyro's event loop.

Usually, the GUI toolkit requires that GUI operations are done from within
the GUI thread. So, if Pyro interfaces with the GUI, it cannot do that
directly because the method calls are done from a different thread.
This means we need a layer between them, this example uses a Queue to
submit GUI operations to Tkinter's main loop.

For this example, the mainloop runs a callback function every so often
to check for new work in that Queue and will process it if the Pyro worker
thread has put something in it.
"""
from __future__ import with_statement
import time
try:
    import queue
except ImportError:
    import Queue as queue
import Pyro4
import Pyro4.threadutil

try:
    from tkinter import *
    import tkinter.simpledialog as simpledialog
except ImportError:
    from Tkinter import *
    import tkSimpleDialog as simpledialog


# The frequency with which the GUI mainloop checks for work in the Pyro queue.
PYRO_QUEUE_HZ = 50

class PyroGUI(object):
    """
    The Tkinter GUI application that also listens for Pyro calls.
    """
    def __init__(self):
        self.pyro_queue=queue.Queue()
        self.tk=Tk()
        self.tk.wm_title("Pyro in a Tkinter GUI eventloop - with threads")
        self.tk.wm_geometry("500x500")
        buttonframe=Frame(self.tk)
        button=Button(buttonframe, text="Messagebox", command=self.button_msgbox_clicked)
        button.pack(side=LEFT)
        button=Button(buttonframe, text="Add some text", command=self.button_text_clicked)
        button.pack(side=LEFT)
        button=Button(buttonframe, text="Clear all text", command=self.button_clear_clicked)
        button.pack(side=LEFT)
        quitbutton=Button(buttonframe, text="Quit", command=self.tk.quit)
        quitbutton.pack(side=RIGHT)
        frame=Frame(self.tk, padx=2, pady=2)
        buttonframe.pack(fill=X)
        rlabel=Label(frame, text="Pyro server messages:")
        rlabel.pack(fill=X)
        self.msg=Message(frame, anchor=NW, width=500, aspect=80, background="white", relief="sunken")
        self.msg.pack(fill=BOTH, expand=1)
        frame.pack(fill=BOTH)
        self.serveroutput=[]


    def install_pyro_queue_callback(self):
        """
        Add a callback to the tkinter event loop that is invoked every so often.
        The callback checks the Pyro work queue for work and processes it.
        """
        def check_pyro_queue():
            try:
                while True:
                    # get a work item from the queue (until it is empty)
                    workitem=self.pyro_queue.get_nowait()
                    # execute it in the gui's mainloop thread
                    workitem["callable"](*workitem["vargs"], **workitem["kwargs"])
            except queue.Empty:
                pass
            self.tk.after(1000//PYRO_QUEUE_HZ, check_pyro_queue)
        self.tk.after(1000//PYRO_QUEUE_HZ, check_pyro_queue)

    def mainloop(self):
        self.tk.mainloop()

    def button_msgbox_clicked(self):
        # this button event handler is here only to show that gui events are still processed normally
        number=simpledialog.askinteger("A normal popup","Hi there enter a number",parent=self.tk)

    def button_clear_clicked(self):
        self.serveroutput=[]
        self.msg.config(text="")

    def button_text_clicked(self):
        # add some random text to the message list
        self.add_message("The quick brown fox jumps over the lazy dog!")

    def add_message(self, message):
        message="[{0}] {1}".format(time.strftime("%X"), message)
        self.serveroutput.append(message)
        self.serveroutput=self.serveroutput[-27:]
        self.msg.config(text="\n".join(self.serveroutput))


class MessagePrinter(object):
    """
    The Pyro object that interfaces with the GUI application.
    It uses a Queue to transfer GUI update calls to Tkinter's mainloop.
    """
    def __init__(self, gui):
        self.gui=gui
    def message(self, messagetext):
        # put a gui-update work item in the queue
        self.gui.pyro_queue.put( {
            "callable":self.gui.add_message,
            "vargs": ("from Pyro: "+messagetext,),
            "kwargs": {}
            } )
    def sleep(self, duration):
        # Note that you *can* perform blocking stuff now because the method
        # call is running in its own thread. It won't freeze the GUI anymore.
        # However you cannot do anything that requires GUI interaction because
        # that needs to go through the queue so the mainloop can pick that up.
        # (opening a dialog from this worker thread will still freeze the GUI)
        # But a simple sleep() call works fine and the GUI stays responsive.
        self.gui.pyro_queue.put( {
            "callable":self.gui.add_message,
            "vargs": ("from Pyro: sleeping {0} seconds...".format(duration),),
            "kwargs": {}
            } )
        time.sleep(duration)
        self.gui.pyro_queue.put( {
            "callable":self.gui.add_message,
            "vargs": ("from Pyro: woke up!",),
            "kwargs": {}
            } )


class PyroDaemon(Pyro4.threadutil.Thread):
    def __init__(self, gui):
        Pyro4.threadutil.Thread.__init__(self)
        self.gui=gui
        self.started=Pyro4.threadutil.Event()
    def run(self):
        daemon=Pyro4.Daemon()
        obj=MessagePrinter(self.gui)
        self.uri=daemon.register(obj,"pyrogui.message2")
        self.started.set()
        daemon.requestLoop()


def main():
    gui=PyroGUI()

    # create a pyro daemon with object, running in its own worker thread
    pyro_thread=PyroDaemon(gui)
    pyro_thread.setDaemon(True)
    pyro_thread.start()
    pyro_thread.started.wait()

    gui.add_message("Pyro server started. Using Pyro worker thread.")
    gui.add_message("Use the command line client to send messages.")
    urimsg="Pyro object uri = {0}".format(pyro_thread.uri)
    gui.add_message(urimsg)
    print(urimsg)

    # add a Pyro event callback to the gui's mainloop
    gui.install_pyro_queue_callback()
    # enter the mainloop
    gui.mainloop()

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys, time
import warnings
import Pyro4

warnings.filterwarnings("ignore")

#Pyro4.config.COMMTIMEOUT=2

print("Enter the server's uri that was printed:")
if sys.version_info<(3,0):
    uri=raw_input()
else:
    uri=input()
uri=uri.strip()

datasize = 5*1024*1024  # 5 mb

def do_test(data):
    assert len(data)==datasize
    totalsize = 0

    obj=Pyro4.core.Proxy(uri)
    obj._pyroBind()

    begin = time.time()
    for i in range(10):
        print("transferring %d bytes" % datasize)
        size = obj.transfer(data)
        assert size==datasize
        totalsize += datasize
    duration = time.time()-begin

    totalsize = float(totalsize)
    print("It took %.2f seconds to transfer %d mb." % (duration, totalsize/1024/1024))
    print("That is %.0f kb/sec. = %.1f mb/sec. (serializer: %s)" % (totalsize/1024/duration, totalsize/1024/1024/duration, Pyro4.config.SERIALIZER))

data = 'x'*datasize
print("\n\n----test with string data----")
do_test(data)
print("\n\n----test with byte data----")
data = b'x'*datasize
do_test(data)
data = bytearray(b'x'*datasize)
print("\n\n----test with bytearray data----")
do_test(data)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import base64
import Pyro4
import Pyro4.socketutil

#Pyro4.config.COMMTIMEOUT=2


class Testclass(object):
    def transfer(self, data):
        if Pyro4.config.SERIALIZER=="serpent" and type(data) is dict:
            # decode serpent base-64 encoded bytes
            assert data["encoding"]=="base64"
            data = base64.b64decode(data["data"])
        print("received %d bytes" % len(data))
        return len(data)

Pyro4.Daemon.serveSimple({
        Testclass(): "example.hugetransfer"
    },
    host=Pyro4.socketutil.getIpAddress("localhost", workaround127=True),
    ns=False, verbose=True)

########NEW FILE########
__FILENAME__ = itunescontroller
from __future__ import print_function
import subprocess
import Pyro4
import socket


#  You can get a lot more info about scripting iTunes here:
#  http://dougscripts.com/itunes/


class ITunes(object):
    def __init__(self):
        # start itunes
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to player state"])
    def play(self):
        # continue play
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to play"])
    def pause(self):
        # pause play
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to pause"])
    def stop(self):
        # stop playing
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to stop"])
    def next(self):
        # next song in list
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to next track"])
    def previous(self):
        # previous song in list
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to previous track"])
    def playlist(self, listname):
        # start playling a defined play list
        subprocess.call(["osascript", "-e", "tell application \"iTunes\" to play playlist \"{0}\"".format(listname)])
    def currentsong(self):
        # return title and artist of current song
        return subprocess.check_output(["osascript", "-e", "tell application \"iTunes\"",
            "-e", "set thisTitle to name of current track",
            "-e", "set thisArtist to artist of current track",
            "-e", "set output to thisTitle & \" - \" & thisArtist",
            "-e", "end tell"]).strip()
    
print("starting...")
itunes=ITunes()
daemon=Pyro4.Daemon(host=socket.gethostname(), port=39001)
uri=daemon.register(itunes,"itunescontroller")
print("iTunes controller started, uri =",uri)
daemon.requestLoop()


########NEW FILE########
__FILENAME__ = remote
from __future__ import print_function
import Pyro4
import sys
import time

if sys.version_info<(3,0):
	input=raw_input

host=input("enter the hostname of the itunescontroller: ")
itunes=Pyro4.Proxy("PYRO:itunescontroller@{0}:39001".format(host))

print("setting Playlist 'Music'...")
itunes.playlist("Music")
itunes.play()
print("Current song:", itunes.currentsong())
time.sleep(6)

print("next song...")
itunes.next()
print("Current song:", itunes.currentsong())
time.sleep(6)

print("stop.")
itunes.stop()


########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4
import Pyro4.errors


huge_object = [42]*10000
simple_object = {"message": "hello", "irrelevant": huge_object}

print("First start the built-in test echo server with something like:")
print("$ python -m Pyro4.test.echoserver")
print("Enter the server's uri that was printed:")
if sys.version_info<(3,0):
    uri=raw_input()
else:
    uri=input()
uri=uri.strip()
echoserver=Pyro4.Proxy(uri)

Pyro4.config.MAX_MESSAGE_SIZE = 0
print("\nSending big data with no limit on message size...")
response = echoserver.echo(simple_object)
print("success.")

try:
    Pyro4.config.MAX_MESSAGE_SIZE = 2500
    print("\nSending big data with a limit on message size...")
    response = echoserver.echo(simple_object)
    print("Hmm, this should have raised an exception")
except Pyro4.errors.ProtocolError:
    ex_t, ex_v, ex_tb = sys.exc_info()
    print("EXCEPTION (expected):", ex_t, ex_v)


########NEW FILE########
__FILENAME__ = stress
from __future__ import print_function
import sys
import random, time
import Pyro4
from Pyro4 import threadutil

def randomname():
    def partname():
        return str(random.random())[-2:]
    parts=["stresstest"]
    for i in range(random.randint(1,10)):
        parts.append(partname())
    return ".".join(parts)


class NamingTrasher(threadutil.Thread):
    def __init__(self,nsuri,number):
        threadutil.Thread.__init__(self)
        self.daemon=True
        self.number=number
        self.ns=Pyro4.core.Proxy(nsuri)
        self.mustStop=False

    def list(self):
        items=self.ns.list()
    def register(self):
        for i in range(4):
            try:
                self.ns.register(randomname(),'PYRO:objname@host:555')
            except Pyro4.errors.NamingError:
                pass
    def remove(self):
        self.ns.remove(randomname())
    def lookup(self):
        try:
            uri=self.ns.lookup(randomname())
        except Pyro4.errors.NamingError:
            pass
    def listprefix(self):
        entries=self.ns.list(prefix="stresstest.51")
    def listregex(self):
        entries=self.ns.list(regex=r"stresstest\.??\.41.*")
    def run(self):
        print("Name Server trasher running.")
        while not self.mustStop:
            random.choice((self.list, self.register, self.remove, self.lookup, self.listregex, self.listprefix))()
            sys.stdout.write("%d " % self.number)
            sys.stdout.flush()
            time.sleep(0.001)
        print("Trasher exiting.")

def main():
    threads=[]
    ns=Pyro4.naming.locateNS()
    ns.remove(prefix="stresstest.")
    for i in range(5):
        nt=NamingTrasher(ns._pyroUri,i)
        nt.start()
        threads.append(nt)

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        pass

    print("Break-- waiting for threads to stop.")
    for nt in threads:
        nt.mustStop=True
        nt.join()
    count=ns.remove(prefix="stresstest.")
    print("cleaned up %d names." % count)

if __name__=='__main__':
    main()

########NEW FILE########
__FILENAME__ = client
# Client that doesn't use the Name Server. Uses URI directly.

from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

uri = input("Enter the URI of the quote object: ")
quotegen=Pyro4.core.Proxy(uri)
print("Getting some quotes...")
print(quotegen.quote())
print(quotegen.quote())

########NEW FILE########
__FILENAME__ = server
# The server that doesn't use the Name Server.

from __future__ import print_function
import os
import Pyro4

class QuoteGen(object):
    def quote(self):
        try:
            quote=os.popen('fortune').read()
            if len(quote)>0:
                return quote
            return "This system cannot provide you a good fortune, install 'fortune'"
        except:
            return "This system knows no witty quotes :-("

daemon = Pyro4.core.Daemon()
quote1 = QuoteGen()
quote2 = QuoteGen()

uri1=daemon.register(quote1)   # let Pyro create a unique name for this one
uri2=daemon.register(quote2, "example.quotegen")   # provide a logical name ourselves

print("QuoteGen is ready, not using the Name Server.")
print("You can use the following two URIs to connect to me:")
print(uri1)
print(uri2)

daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import time
import Pyro4

serv = Pyro4.core.Proxy("PYRONAME:example.oneway")
serv._pyroOneway.add("start")
serv._pyroOneway.add("nothing")
serv._pyroOneway.add("nonexisting")

print("starting server using a oneway call")
serv.start(6)
print("doing some more oneway calls inbetween")
serv.nothing()
serv.nothing()
serv.nothing()
print("calling a non existing method, but since it is flagged oneway, we won't find out")
serv.nonexisting()

time.sleep(2)
print("\nNow contacting the server to see if it's done.")
print("we are faster, so you should see a few attempts,")
print("until the server is finished.")
while True:
    print("server done?")
    if serv.ready():
        print("yes!")
        break
    else:
        print("no, trying again")
        time.sleep(1)

print("getting the result from the server: %s" % serv.result())

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4

# set the oneway behavior to run inside a new thread, otherwise the client stalls.
# this is the default, but I've added it here just for clarification.
Pyro4.config.ONEWAY_THREADED=True

class Server(object):
    def __init__(self):
        self.busy=False
    def start(self, duration):
        print("start request received. Starting work...")
        self.busy=True
        for i in range(duration):
            time.sleep(1)
            print(duration-i)
        print("work is done!")
        self.busy=False
    def ready(self):
        print("ready status requested (%r)" % (not self.busy))
        return not self.busy
    def result(self):
        return "The result :)"
    def nothing(self):
        print("nothing got called, doing nothing")


######## main program

Pyro4.Daemon.serveSimple({
        Server(): "example.oneway"
    })

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import time
import Pyro4
from Pyro4 import threadutil

if sys.version_info<(3,0):
    current_thread=threadutil.currentThread
else:
    current_thread=threadutil.current_thread

stop=False

def myThread(nsproxy, proxy):
    global stop
    name=current_thread().getName()
    try:
        while not stop:
            result=nsproxy.list(prefix="example.")
            result=proxy.method("the quick brown fox jumps over the lazy dog")
    except Exception:
        x=sys.exc_info()[1]
        print("**** Exception in thread %s: {%s} %s" % (name, type(x), x))

nsproxy = Pyro4.naming.locateNS()
proxy = Pyro4.core.Proxy("PYRONAME:example.proxysharing")

# now create a handful of threads and give each of them the same two proxy objects
threads = []
for i in range(5):
    thread=threadutil.Thread(target=myThread, args=(nsproxy, proxy))
    # thread.setDaemon(True)
    thread.setDaemon(False)
    threads.append(thread)
    thread.start()

print("Running a bunch of threads for 5 seconds.")
print("They're hammering the name server and the test server using the same proxy.")
print("You should not see any exceptions.")
time.sleep(5)
stop=True
for thread in threads:
    thread.join()
print("Done.")

print("\nNow showing why proxy sharing might not be a good idea for parallelism.")
print("Starting 10 threads with the same proxy that all call the work() method.")

def myThread2(proxy):
    global stop
    while not stop:
        proxy.work()

stop=False
proxy.reset_work()
threads = []
for i in range(10):
    thread=threadutil.Thread(target=myThread2, args=[proxy])
    thread.setDaemon(False)
    threads.append(thread)
    thread.start()

print("waiting 5 seconds")
start=time.time()
time.sleep(5)
print("waiting until threads have stopped...")
stop=True
for thread in threads:
    thread.join()
duration=int(time.time()-start)
print("--> time until everything completed: %.2f" % duration)
print("--> work done on the server: %d" % proxy.get_work_done())
print("you can see that the 10 threads are waiting for each other to complete,")
print("and that not a lot of work has been done on the server.")

print("\nDoing the same again but every thread now has its own proxy.")
print("Starting 10 threads with different proxies that all call the work() method.")
proxy.reset_work()
stop=False
threads = []
for i in range(10):
    proxy=Pyro4.core.Proxy(proxy._pyroUri)  # create a new proxy
    thread=threadutil.Thread(target=myThread2, args=[proxy])
    thread.setDaemon(False)
    threads.append(thread)
    thread.start()

print("waiting 5 seconds")
start=time.time()
time.sleep(5)
print("waiting until threads have stopped...")
stop=True
for thread in threads:
    thread.join()
duration=int(time.time()-start)
print("--> time until everything completed: %.2f" % duration)
print("--> work done on the server: %d" % proxy.get_work_done())
print("you can see that this time the 10 threads didn't have to wait for each other,")
print("and that they got a lot more work done because they really ran in parallel.")

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4

class RemoteObject(object):
    def __init__(self):
        self.amount=0
    def method(self, arg):
        return " ~~this is the remote result~~ "
    def work(self):
        print("work... %d" %self.amount)
        time.sleep(0.5)
        self.amount+=1
    def reset_work(self):
        self.amount=0
    def get_work_done(self):
        return self.amount


Pyro4.Daemon.serveSimple({
        RemoteObject(): "example.proxysharing"
    })

########NEW FILE########
__FILENAME__ = client
from __future__ import with_statement
import random
import sys
import remote
import Pyro4


# because we're using some custom classes over the wire, we need to use pickle
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')
Pyro4.config.SERIALIZER='pickle'


class DrunkenGameObserver(remote.GameObserver):
    def world_update(self, iteration, world, robotdata):
        # change directions randomly
        if random.random()>0.8:
            if random.random()>=0.5:
                dx,dy=random.randint(-1,1),0
            else:
                dx,dy=0,random.randint(-1,1)
            if random.random()>0.7:
                self.robot.emote("..Hic! *burp*")
            self.robot.change_direction((dx,dy))

class AngryGameObserver(remote.GameObserver):
    def __init__(self):
        super(AngryGameObserver,self).__init__()
        self.directions=[(1,0), (0,1), (-1,0), (0,-1)]  # clockwise motion
        self.directioncounter=0
    def world_update(self, iteration, world, robotdata):
        # move in a loop yelling angry stuff
        if iteration % 50 == 0:
            self.robot.emote("I'll kill you all! GRR")
        if iteration % 10 ==0:
            self.directioncounter=(self.directioncounter+1)%4
            self.robot.change_direction(self.directions[self.directioncounter])

class ScaredGameObserver(remote.GameObserver):
    def __init__(self):
        super(ScaredGameObserver,self).__init__()
        # run to a corner
        self.direction=random.choice([(-1,-1),(1,-1),(1,1),(-1,1)])
    def start(self):
        super(ScaredGameObserver,self).start()
        self.robot.change_direction(self.direction)
    def world_update(self, iteration, world, robotdata):
        if iteration%50==0:
            self.robot.emote("I'm scared!")

observers= {
    "drunk": DrunkenGameObserver,
    "angry": AngryGameObserver,
    "scared": ScaredGameObserver,
            }

def main(args):
    if len(args)!=3:
        print("usage: client.py <robotname> <robottype>")
        print("   type is one of: %s" % list(observers.keys()))
        return
    name=args[1]
    observertype=args[2]
    with Pyro4.Daemon() as daemon:
        observer=observers[observertype]()
        daemon.register(observer)
        gameserver=Pyro4.Proxy("PYRONAME:example.robotserver")
        robot=gameserver.register(name, observer)
        robot.emote("Hi there! I'm here to kick your ass")
        observer.robot=robot
        print("Pyro server registered on %s" % daemon.locationStr)
        daemon.requestLoop()

if __name__=="__main__":
    main(sys.argv)

########NEW FILE########
__FILENAME__ = gameserver
from __future__ import with_statement
import random
import time
import robot
import remote
try:
    from tkinter import *
except ImportError:
    from Tkinter import *
import Pyro4
from Pyro4 import threadutil

# because we're using some custom classes over the wire, we need to use pickle
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')
Pyro4.config.SERIALIZER='pickle'


class VisibleRobot(robot.Robot):
    """represents a robot that is visible on the screen."""
    def __init__(self, name, position, direction, grid, color='red'):
        super(VisibleRobot,self).__init__(name, (grid.width, grid.height), position, direction)
        self.grid=grid
        x=self.x*grid.squaresize
        y=self.y*grid.squaresize
        self.tkid=grid.create_rectangle(x,y,x+grid.squaresize,y+grid.squaresize,fill=color,outline='black')
        self.text_tkid=None
    def popuptext(self, text, sticky=False):
        if self.text_tkid:
            self.grid.delete(self.text_tkid)
        self.text_tkid=self.grid.create_text(self.x*self.grid.squaresize,self.y*self.grid.squaresize,text=text,anchor=CENTER,fill='red')
        self.text_timer=time.time()
        if not sticky:
            self.grid.after(1000, self.__removetext, self.text_tkid)
    def delete_from_grid(self):
        self.grid.delete(self.tkid)
        if self.text_tkid:
            self.grid.delete(self.text_tkid)
    def __removetext(self, textid):
        self.grid.delete(textid)
        if textid==self.text_tkid:
            self.text_tkid=None
    def move(self, world=None):
        super(VisibleRobot,self).move(world)
        x=self.x*self.grid.squaresize
        y=self.y*self.grid.squaresize
        self.grid.coords(self.tkid, x,y,x+self.grid.squaresize, y+self.grid.squaresize)
        if self.text_tkid:
            # also move the popup text
            self.grid.coords(self.text_tkid, self.x*self.grid.squaresize,self.y*self.grid.squaresize)
    def died(self, killer, world):
        self.popuptext("ARGH I died")
        if killer:
            killer=killer.serializable()
        self.observer.death(killer=killer)
        self.grid.after(800, lambda: self.grid.delete(self.tkid))
    def collision(self, other):
        self.popuptext("Bam!")
        other.popuptext("ouch")
    def emote(self,text):
        self.popuptext(text, False)

class RobotGrid(Canvas):
    def __init__(self, parent, width, height, squaresize=20):
        self.squaresize=squaresize
        self.width=width
        self.height=height
        pixwidth=width*self.squaresize
        pixheight=height*self.squaresize
        Canvas.__init__(self, parent, width=pixwidth, height=pixheight, background='#e0e0e0')
        self.xview_moveto(0)
        self.yview_moveto(0)
        for x in range(width):
            self.create_line(x*self.squaresize,0,x*self.squaresize,pixheight, fill='#d0d0d0')
        for y in range(height):
            self.create_line(0,y*self.squaresize,pixwidth,y*self.squaresize,fill='#d0d0d0')
    def draw_wall(self, wall, color='navy'):
        x=wall.x*self.squaresize
        y=wall.y*self.squaresize
        self.create_rectangle(x,y,x+self.squaresize,y+self.squaresize,fill=color,outline=color)


class GameEngine(object):
    def __init__(self, gui, world):
        self.gui=gui
        self.grid=gui.grid
        self.world=world
        self.build_walls()
        self.gui.buttonhandler=self
        self.survivor=None
        self.open_for_signups=True
        self.iteration=0
    def button_clicked(self, button):
        if button=="add_bot" and self.open_for_signups:
            for i in range(5):
                name="local_bot_%d" % self.gui.listbox.size()
                gameobserver=remote.LocalGameObserver(name)
                robot=self.signup_robot(name, gameobserver)
                gameobserver.robot=robot
        elif button=="start_round":
            self.open_for_signups=False
            if self.survivor:
                self.survivor.delete_from_grid()
            self.gui.enable_buttons(False)
            self.start_round()
    def start_round(self):
        self.gui.statuslabel.config(text="new round!")
        print("WORLD:")
        for line in self.world.dump():
            print(line.tostring())
        print("NUMBER OF ROBOTS: %d" % len(self.world.robots))
        txtid=self.grid.create_text(20,20,text="GO!",font=("Courier",120,"bold"),anchor=NW,fill='purple')
        self.grid.after(1500,lambda:self.grid.delete(txtid))
        self.grid.after(2000,self.update)
        self.grid.after(2000,self.notify_start)
        self.iteration=0
    def notify_start(self):
        for robot in self.world.robots:
            robot.observer.start()
    def notify_worldupdate(self):
        self.iteration+=1
        for robot in self.world.robots:
            robotdata=robot.serializable()
            robot.observer.world_update(self.iteration, self.world, robotdata)
    def notify_winner(self, winner):
        winner.observer.victory()
    def update(self):
        for robot in self.world.robots:
            robot.move(self.world)
        self.notify_worldupdate()
        self.gui.statuslabel.config(text="survivors: %d" % len(self.world.robots))
        if len(self.world.robots)<1:
            print("[server] No results.")
            self.round_ends()
        elif len(self.world.robots)==1:
            self.survivor=self.world.robots[0]
            self.world.remove(self.survivor)
            self.survivor.popuptext("I WIN! HURRAH!", True)
            print("[server] %s wins!" % self.survivor.name)
            self.gui.statuslabel.config(text="winner: %s" % self.survivor.name)
            self.notify_winner(self.survivor)
            self.round_ends()
        else:
            self.gui.tk.after(40, self.update)
    def round_ends(self):
        self.gui.listbox.delete(0,END)
        self.gui.enable_buttons(True)
        self.open_for_signups=True
    def build_walls(self):
        wall_offset=4
        wall_size=10
        for x in range(wall_size):
            wall=robot.Wall((x+wall_offset,wall_offset))
            self.world.add_wall(wall)
            self.grid.draw_wall(wall)
            wall=robot.Wall((x+wall_offset,wall_size+wall_offset+1))
            self.world.add_wall(wall)
            self.grid.draw_wall(wall)
            wall=robot.Wall((wall_offset,x+wall_offset+1))
            self.world.add_wall(wall)
            self.grid.draw_wall(wall)
            wall=robot.Wall((wall_size+wall_offset+2,x+wall_offset+1))
            self.world.add_wall(wall)
            self.grid.draw_wall(wall)
    def signup_robot(self, name, observer=None):
        if not self.open_for_signups:
            raise RuntimeError("signups are closed, try again later")
        for r in self.world.robots:
            if r.name==name:
                raise ValueError("that name is already taken")
        colorint=random.randint(0,0xFFFFFF)
        color='#%06x' % colorint
        inversecolor='black'
        self.gui.listbox.insert(END,name)
        self.gui.listbox.itemconfig(END,bg=color, fg=inversecolor)
        while True:
            x=random.randint(0,self.grid.width-1)
            y=random.randint(int(self.grid.height*0),self.grid.height-1)
            if not self.world.collides(x,y):
                break
        r=VisibleRobot(name,(x,y),(0,0), self.grid, color=color)
        self.world.add_robot(r)
        r.observer=observer
        observer._pyroOneway.add("world_update")
        r.popuptext(name)
        return remote.RemoteBot(r, self)
    def remove_robot(self, robot):
        robot.delete_from_grid()
        self.world.remove(robot)
        # listnames=list(self.gui.listbox.get(0,END))
        # listnames.remove(robot.name)
        # self.gui.listbox.delete(0,END)
        # self.gui.listbox.insert(END,*listnames)

class GUI(object):
    def __init__(self, width, height):
        self.tk=Tk()
        self.tk.wm_title("bot destruction derby")
        lframe=Frame(self.tk, borderwidth=3, relief="raised", padx=2, pady=2, background='#808080')
        self.grid=RobotGrid(lframe, width, height, squaresize=16)
        rframe=Frame(self.tk, padx=2, pady=2)
        rlabel=Label(rframe, text="Signups:")
        rlabel.pack(fill=X)
        self.listbox=Listbox(rframe, width=15, height=20, font=(None,8))
        self.listbox.pack()
        self.addrobotbutton=Button(rframe, text="Add 5 local bots", command=lambda: self.buttonhandler.button_clicked("add_bot"))
        self.addrobotbutton.pack()
        self.startbutton=Button(rframe, text="Start round!", command=lambda: self.buttonhandler.button_clicked("start_round"))
        self.startbutton.pack()
        self.statuslabel=Label(rframe, width=20)
        self.statuslabel.pack(side=BOTTOM)
        self.grid.pack()
        lframe.pack(side=LEFT)
        rframe.pack(side=RIGHT, fill=BOTH)
        self.buttonhandler=None
    def enable_buttons(self, enabled=True):
        if enabled:
            self.addrobotbutton.config(state=NORMAL)
            self.startbutton.config(state=NORMAL)
        else:
            self.addrobotbutton.config(state=DISABLED)
            self.startbutton.config(state=DISABLED)

class PyroDaemonThread(threadutil.Thread):
    def __init__(self, engine):
        threadutil.Thread.__init__(self)
        self.pyroserver=remote.GameServer(engine)
        self.pyrodaemon=Pyro4.Daemon()
        self.ns=Pyro4.locateNS()
        self.setDaemon(True)
    def run(self):
        with self.pyrodaemon:
            with self.ns:
                uri=self.pyrodaemon.register(self.pyroserver)
                self.ns.register("example.robotserver", uri)
                print("Pyro server registered on %s" % self.pyrodaemon.locationStr)
                self.pyrodaemon.requestLoop()

def main():
    width=25
    height=25
    gui=GUI(width,height)
    world=robot.World(width, height)
    engine=GameEngine(gui, world)
    try:
        PyroDaemonThread(engine).start()
    except Pyro4.errors.NamingError:
        print("Can't find the Pyro Nameserver. Running without remote connections.")
    gui.tk.mainloop()

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = remote
from __future__ import print_function
import random
import Pyro4

class GameServer(object):
    def __init__(self, engine):
        self.engine=engine
    def register(self, name, observer):
        robot=self.engine.signup_robot(name, observer)
        self._pyroDaemon.register(robot)    # make the robot a pyro object
        return robot

class RemoteBot(object):
    def __init__(self, robot, engine):
        self.robot=robot
        self.engine=engine
    def get_data(self):
        return self.robot.serializable()
    def change_direction(self, direction):
        self.robot.dx,self.robot.dy = direction
    def emote(self, text):
        self.robot.emote(text)
    def terminate(self):
        self.engine.remove_robot(self.robot)

class LocalGameObserver(object):
    def __init__(self, name):
        self.name=name
        self.robot=None
        self._pyroOneway=set()  # remote observers have this
    def world_update(self, iteration, world, robotdata):
        # change directions randomly
        if random.random()>0.8:
            if random.random()>=0.5:
                dx,dy=random.randint(-1,1),0
            else:
                dx,dy=0,random.randint(-1,1)
            self.robot.change_direction((dx,dy))
    def start(self):
        self.robot.emote("Here we go!")
    def victory(self):
        print("[%s] I WON!!!" % self.name)
    def death(self, killer):
        if killer:
            print("[%s] I DIED (%s did it)" % (self.name, killer.name))
        else:
            print("[%s] I DIED" % self.name)

class GameObserver(object):
    def world_update(self, iteration, world, robotdata):
        pass
    def start(self):
        print("Battle starts!")
    def victory(self):
        print("I WON!!!")
    def death(self, killer):
        print("I DIED")
        if killer:
            print("%s KILLED ME :(" % killer.name)

########NEW FILE########
__FILENAME__ = robot
from __future__ import print_function
import sys
import array

class Wall(object):
    """an obstructing static wall"""
    def __init__(self, position):
        self.x,self.y = position
    def serializable(self):
        return self

class Robot(object):
    """represents a robot moving on a grid."""
    def __init__(self, name, grid_dimensions, position, direction=(0,0), strength=5):
        self.name = name
        self.x, self.y = position
        self.dx, self.dy = direction
        self.gridw, self.gridh = grid_dimensions
        self.strength = strength
    def __str__(self):
        return "ROBOT '%s'; pos(%d,%d); dir(%d,%d); strength %d" %(self.name, self.x, self.y, self.dx, self.dy, self.strength)
    def serializable(self):
        if type(self) is Robot:
            return self
        else:
            return Robot(self.name,(self.gridw,self.gridh),(self.x,self.y),(self.dx,self.dy),self.strength)
    def move(self, world=None):
        # minmax to avoid moving off the sides
        x=min(self.gridw-1, max(0,self.x+self.dx))
        y=min(self.gridh-1, max(0,self.y+self.dy))
        if x==self.x and y==self.y:
            return
        if world and self.__process_collision(x,y,world):
            return
        self.x,self.y = x,y
    def __process_collision(self, newx, newy, world):
        other=world.collides(newx,newy)
        if not other:
            return False  # we didn't hit anything
        self.dx,self.dy = 0,0   # come to a standstill when we hit something
        if isinstance(other,Wall):
            self.strength-=1  # hit wall, decrease our strength
            if self.strength<=0:
                print("[server] %s killed himself!" % self.name)
                world.remove(self)
                self.died(None,world)
        else:
            other.strength-=1  # hit other robot, decrease other robot's strength
            self.collision(other)
            if other.strength<=0:
                world.remove(other)
                other.died(self, world)
                print("[server] %s killed %s!" % (self.name, other.name))
        return True
    def killed(self, victim, world):
        """you can override this to react on kills"""
        pass
    def collision(self, other):
        """you can override this to react on collisions between bots"""
        pass
    def emote(self, text):
        """you can override this"""
        print("[server] %s says: '%s'" % (self.name, text))

class World(object):
    """the world the robots move in (Cartesian grid)"""
    def __init__(self, width, height):
        self.width=width
        self.height=height
        self.all=[]
        self.robots=[]
    def add_wall(self, wall):
        self.all.append(wall)
    def add_robot(self, bot):
        self.all.append(bot)
        self.robots.append(bot)
    def collides(self, x, y):
        for obj in self.all:
            if obj.x==x and obj.y==y:
                return obj
        return None
    def remove(self, obj):
        self.all.remove(obj)
        self.robots.remove(obj)
    def dump(self):
        line=' '*self.width
        if sys.version_info>=(3,0):
            line=bytes(line, "ASCII")
        grid=[array.array('b', line) for y in range(self.height)]
        for obj in self.all:
            grid[obj.y][obj.x]=ord('R') if isinstance(obj, Robot) else ord('#')
        return grid
    def __getstate__(self):
        all=[o.serializable() for o in self.all]
        robots=[r.serializable() for r in self.robots]
        return (self.width,self.height,all,robots)
    def __setstate__(self, args):
        self.width,self.height,self.all,self.robots=args

########NEW FILE########
__FILENAME__ = client
from __future__ import with_statement
import sys
import time
import Pyro4
from Pyro4 import threadutil

if sys.version_info<(3,0):
    current_thread=threadutil.currentThread
else:
    current_thread=threadutil.current_thread

serv = Pyro4.core.Proxy("PYRONAME:example.servertypes")
serv._pyroOneway.add("onewaydelay")

print("--------------------------------------------------------------")
print("    This part is independent of the type of the server.       ")
print("--------------------------------------------------------------")
print("Calling 5 times oneway method. Should return immediately.")
serv.reset()
begin=time.time()
serv.onewaydelay()
serv.onewaydelay()
serv.onewaydelay()
serv.onewaydelay()
serv.onewaydelay()
print("Done with the oneway calls.")
completed=serv.getcount()
print("Number of completed calls in the server: %d" % completed)
print("This should be 0, because all 5 calls are still busy in the background.")
if completed>0:
    print("  !!! The oneway calls were not running in the background !!!")
    print("  ??? Are you sure ONEWAY_THREADED=True on the server ???")
print()
print("Calling normal delay 5 times. They will all be processed")
print("by the same server thread because we're using the same proxy.")
r=serv.delay()
print("  call processed by: %s" % r)
r=serv.delay()
print("  call processed by: %s" % r)
r=serv.delay()
print("  call processed by: %s" % r)
r=serv.delay()
print("  call processed by: %s" % r)
r=serv.delay()
print("  call processed by: %s" % r)
time.sleep(2)
print("Number of completed calls in the server: %d" % serv.getcount())
print("This should be 10, because by now the 5 oneway calls have completed as well.")
serv.reset()

print("\n--------------------------------------------------------------")
print("    This part depends on the type of the server.              ")
print("--------------------------------------------------------------")
print("Creating 5 threads that each call the server at the same time.")
serverconfig=serv.getconfig()
if serverconfig["SERVERTYPE"]=="thread":
    print("Servertype is thread. All calls will run in parallel.")
    print("The time this will take is 1 second (every thread takes 1 second in parallel).")
    print("You will see that the requests are handled by different server threads.")
elif serverconfig["SERVERTYPE"]=="multiplex":
    print("Servertype is multiplex. The threads will need to get in line.")
    print("The time this will take is 5 seconds (every thread takes 1 second sequentially).")
    print("You will see that the requests are handled by a single server thread.")
else:
    print("Unknown servertype")

def func(uri):
    # This will run in a thread. Create a proxy just for this thread:
    with Pyro4.core.Proxy(uri) as p:
        processed=p.delay()
        print("  thread %s called delay, processed by: %s" % (current_thread().getName(), processed))

serv._pyroBind()  # simplify the uri
threads=[]
for i in range(5):
    t=threadutil.Thread(target=func, args=[serv._pyroUri])
    t.setDaemon(True)
    threads.append(t)
    t.start()
print("Waiting for threads to finish:")
for t in threads:
    t.join()
print("Done. Number of completed calls in the server: %d" % serv.getcount())

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import sys
import Pyro4
from Pyro4 import threadutil

if sys.version_info<(3,0):
    input=raw_input
    current_thread=threadutil.currentThread
else:
    current_thread=threadutil.current_thread

class Server(object):
    def __init__(self):
        self.callcount=0
    def reset(self):
        self.callcount=0
    def getcount(self):
        return self.callcount   # the number of completed calls
    def getconfig(self):
        return Pyro4.config.asDict()
    def delay(self):
        threadname=current_thread().getName()
        print("delay called in thread %s" % threadname)
        time.sleep(1)
        self.callcount+=1
        return threadname
    def onewaydelay(self):
        threadname=current_thread().getName()
        print("onewaydelay called in thread %s" % threadname)
        time.sleep(1)
        self.callcount+=1


######## main program

Pyro4.config.SERVERTYPE="undefined"
servertype=input("Servertype threaded or multiplex (t/m)?")
if servertype=="t":
    Pyro4.config.SERVERTYPE="thread"
else:
    Pyro4.config.SERVERTYPE="multiplex"

daemon=Pyro4.core.Daemon()
obj=Server()
uri=daemon.register(obj)
ns=Pyro4.naming.locateNS()
ns.register("example.servertypes", uri)
print("Server is ready.")
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4
from Pyro4.util import SerializerBase
import mycustomclasses

# use serpent
Pyro4.config.SERIALIZER = "serpent"


# register the special serialization hooks

def thingy_class_to_dict(obj):
    print("{serializer hook, converting to dict: %s}" % obj)
    return {
        "__class__": "waheeee-custom-thingy",
        "number-attribute": obj.number
    }

def thingy_dict_to_class(classname, d):
    print("{deserializer hook, converting to class: %s}" % d)
    return mycustomclasses.Thingy(d["number-attribute"])

def otherthingy_dict_to_class(classname, d):
    print("{deserializer hook, converting to class: %s}" % d)
    return mycustomclasses.OtherThingy(d["number"])

# for 'Thingy' we register both serialization and deserialization hooks
SerializerBase.register_class_to_dict(mycustomclasses.Thingy, thingy_class_to_dict)
SerializerBase.register_dict_to_class("waheeee-custom-thingy", thingy_dict_to_class)

# for 'OtherThingy' we only register a deserialization hook (and for serialization depend on serpent's default behavior)
SerializerBase.register_dict_to_class("mycustomclasses.OtherThingy", otherthingy_dict_to_class)



# regular pyro stuff

if sys.version_info < (3, 0):
    input = raw_input

uri = input("Enter the URI of the server object: ")
serv = Pyro4.core.Proxy(uri)
print("\nTransferring thingy...")
o = mycustomclasses.Thingy(42)
response = serv.method(o)
print("type of response object:", type(response))
print("response:", response)
print("\nTransferring otherthingy...")
o = mycustomclasses.OtherThingy(42)
response = serv.othermethod(o)
print("type of response object:", type(response))
print("response:", response)

########NEW FILE########
__FILENAME__ = mycustomclasses
# defines custom classes


class Thingy(object):

    def __init__(self, num):
        self.number = num

    def __str__(self):
        return "<Thingy @"+hex(id(self))+", number="+str(self.number)+">"


class OtherThingy(object):

    def __init__(self, num):
        self.number = num

    def __str__(self):
        return "<OtherThingy @"+hex(id(self))+", number="+str(self.number)+">"

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import Pyro4
from Pyro4.util import SerializerBase
import mycustomclasses

# use serpent
Pyro4.config.SERIALIZER = "serpent"

# register the special serialization hooks

def thingy_class_to_dict(obj):
    print("{serializer hook, converting to dict: %s}" % obj)
    return {
        "__class__": "waheeee-custom-thingy",
        "number-attribute": obj.number
    }

def thingy_dict_to_class(classname, d):
    print("{deserializer hook, converting to class: %s}" % d)
    return mycustomclasses.Thingy(d["number-attribute"])

def otherthingy_dict_to_class(classname, d):
    print("{deserializer hook, converting to class: %s}" % d)
    return mycustomclasses.OtherThingy(d["number"])

# for 'Thingy' we register both serialization and deserialization hooks
SerializerBase.register_dict_to_class("waheeee-custom-thingy", thingy_dict_to_class)
SerializerBase.register_class_to_dict(mycustomclasses.Thingy, thingy_class_to_dict)

# for 'OtherThingy' we only register a deserialization hook (and for serialization depend on serpent's default behavior)
SerializerBase.register_dict_to_class("mycustomclasses.OtherThingy", otherthingy_dict_to_class)


# regular Pyro server stuff

class Server(object):

    def method(self, arg):
        print("\nmethod called, arg=", arg)
        response = mycustomclasses.Thingy(999)
        return response

    def othermethod(self, arg):
        print("\nothermethod called, arg=", arg)
        response = mycustomclasses.OtherThingy(999)
        return response


Pyro4.core.Daemon.serveSimple(
    {
        Server(): "example.customclasses"
    },
    ns=False)

########NEW FILE########
__FILENAME__ = clients
from __future__ import print_function
import random
import Pyro4

shop = Pyro4.Proxy("PYRONAME:example.shop")

print("Simulating some customers.")
harrysCart=shop.enter("Harry")
sallysCart=shop.enter("Sally")
shoplifterCart=shop.enter("shoplifter")
# harry buys 4 things and sally 5, shoplifter takes 3 items
# note that we put the item directly in the shopping cart.
goods=list(shop.goods().keys())
for i in range(4):
    item=random.choice(goods)
    print("Harry buys %s" % item)
    harrysCart.purchase(item)
for i in range(5):
    item=random.choice(goods)
    print("Sally buys %s" % item)
    sallysCart.purchase(item)
for i in range(3):
    item=random.choice(goods)
    print("Shoplifter takes %s" % item)
    shoplifterCart.purchase(item)

print("Customers currently in the shop: %s" % shop.customers())

# Go to the counter to pay and get a receipt.
# The shopping cart is still 'inside the shop' (=on the server)
# so it knows what is in there for every customer in the store.
# Harry pays by just telling his name (and the shop  looks up
# harry's shoppingcart).
# Sally just hands in her shopping cart directly.
# The shoplifter tries to leave without paying.

try:
    receipt=shop.payByName("Harry")
except:
    print("ERROR: %s" % ("".join(Pyro4.util.getPyroTraceback())))
print("Harry payed. The cart now contains: %s (should be empty)" % harrysCart.getContents())
print("Harry got this receipt:")
print(receipt)
receipt=shop.payCart(sallysCart)
print("Sally payed. The cart now contains: %s (should be empty)" % sallysCart.getContents())
print("Sally got this receipt:")
print(receipt)
print("Harry is leaving.")
shop.leave("Harry")
print("Sally is leaving.")
shop.leave("Sally")
print("Shoplifter is leaving. (should be impossible i.e. give an error)")
try:
    shop.leave("shoplifter")
except:
    print("".join(Pyro4.util.getPyroTraceback()))

print("Harry is attempting to put stuff back in his cart again,")
print("which should fail because the cart does no longer exist.")
harrysCart.purchase("crap")

########NEW FILE########
__FILENAME__ = shoppingcart
from __future__ import print_function

class ShoppingCart(object):
    def __init__(self):
        self.contents=[]
        print("(shoppingcart %d taken)" % id(self))
    def purchase(self, item):
        self.contents.append(item)
        print("(%s put into shoppingcart %d)" % (item, id(self)))
    def empty(self):
        self.contents=[]
    def getContents(self):
        return self.contents

########NEW FILE########
__FILENAME__ = shopserver
from __future__ import print_function
import time
import Pyro4
from shoppingcart import ShoppingCart

class Shop(object):
    inventory= {
        "paper"     : 1.25,
        "bread"     : 1.50,
        "meat"      : 5.99,
        "milk"      : 0.80,
        "fruit"     : 2.65,
        "chocolate" : 3.99,
        "pasta"     : 0.50,
        "sauce"     : 1.20,
        "vegetables": 1.40,
        "cookies"   : 1.99,
        "pizza"     : 3.60,
        "shampoo"   : 2.22,
        "whiskey"   : 24.99
        }

    customersInStore={}

    def enter(self, name):
        print("Customer %s enters the store." % name)
        print("Customer takes a shopping cart.")
        # create a cart and return it as a pyro object to the client
        cart=ShoppingCart()
        self.customersInStore[name]=cart
        self._pyroDaemon.register(cart)   # make cart a pyro object
        return cart
    def customers(self):
        return list(self.customersInStore.keys())
    def goods(self):
        return self.inventory
    def payByName(self, name):
        print("Customer %s goes to the counter to pay." % name)
        cart=self.customersInStore[name]
        return self.payCart(cart, name)
    def payCart(self,cart,name=None):
        receipt=[]
        if name:
            receipt.append("Receipt for %s." % name)
        receipt.append("Receipt Date: "+time.asctime())
        total=0.0
        for item in cart.getContents():
            price=self.inventory[item]
            total+=price
            receipt.append("%13s  %.2f" % (item,price))
        receipt.append("")
        receipt.append("%13s  %.2f" % ("total:",total))
        cart.empty()
        return "\n".join(receipt)
    def leave(self, name):
        print("Customer %s leaves." % name)
        cart=self.customersInStore[name]
        print("  their shopping cart contains: %s" % cart.getContents())
        if cart.getContents():
            print("  it is not empty, they are trying to shoplift!")
            raise Exception("attempt to steal a full cart prevented")
        # delete the cart and unregister it with pyro
        del self.customersInStore[name]
        self._pyroDaemon.unregister(cart)


######## main program

Pyro4.Daemon.serveSimple({
        Shop(): "example.shop"
    })

########NEW FILE########
__FILENAME__ = inputoutput
# This is the remote input/output server
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

class RemoteIOManager(object):
    """The Pyro object that provides the remote in/out stream proxies"""
    def __init__(self, stdin_uri, stdout_uri):
        self.stdin_uri=stdin_uri
        self.stdout_uri=stdout_uri
    def getInputOutput(self):
        return Pyro4.Proxy(self.stdout_uri), Pyro4.Proxy(self.stdin_uri)


class SimpleProxy(object):
    """simple proxy to another object.
    Needed to be able to use built-in types as a remote Pyro object"""
    def __init__(self, open_file):
        #self._obj=open_file
        object.__setattr__(self, "_obj", open_file)
    def __getattribute__(self, name):
        if name=="fileno":
            # hack to make it work on Python 3.x
            raise AttributeError(name)
        elif name.startswith("_pyro"):
            # little hack to get Pyro's attributes from this object itself
            return object.__getattribute__(self, name)
        else:
            # all other attributes and methods are passed to the proxied _obj
            return getattr(object.__getattribute__(self, "_obj"), name)


d=Pyro4.Daemon()
stdin_uri=d.register(SimpleProxy(sys.stdin),"inputoutput.stdin")        # remote stdin
stdout_uri=d.register(SimpleProxy(sys.stdout),"inputoutput.stdout")     # remote stdout
uri=d.register(RemoteIOManager(stdin_uri, stdout_uri),"example.inputoutput.manager")
print("object uri=",uri)
print("server running.")
d.requestLoop()

########NEW FILE########
__FILENAME__ = program
# this is the program whose input/output you can redirect
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input

sys.excepthook=Pyro4.util.excepthook


def interaction():
    print("Hello there.")
    name=input("What is your name? ").strip()
    year=input("What year were you born? ").strip()
    print("Nice meeting you, {0}!".format(name))
    print("I heard the wine from {0} was particularly good.".format(year))



def main():
    uri=input("uri of the remote i/o server, or enter for local i/o:").strip()
    print(repr(uri))
    if uri:
        try:
            remoteIO = Pyro4.Proxy(uri)
            remote_stdout, remote_stdin = remoteIO.getInputOutput()
            print("Replacing sys.stdin and sys.stdout. Read and type on the server :-)")
            orig_stdin=sys.stdin
            orig_stdout=sys.stdout
            sys.stdin=remote_stdin   # just put a proxy in place of stdin/stdout...
            sys.stdout=remote_stdout  # ... all i/o calls will be passed to the remote object
            print("---remote interaction starts---")
            interaction()    # call the interaction loop
            print("---remote interaction ends---")
        finally:
            sys.stdout=orig_stdout
            sys.stdin=orig_stdin
    else:
        print("just running locally")
        interaction()

if __name__=="__main__":
    main()
  
########NEW FILE########
__FILENAME__ = aggregator
class Aggregator(object):
    def __init__(self):
        self.viewers = {}
        self.symbols = []

    def add_symbols(self, symbols):
        self.symbols.extend(symbols)

    def available_symbols(self):
        return self.symbols

    def view(self, viewer, symbols):
        self.viewers[viewer] = symbols

    def quotes(self, market, stockquotes):
        for symbol, value in stockquotes.items():
            for viewer, symbols in self.viewers.items():
                if symbol in symbols:
                    viewer.quote(market, symbol, value)

########NEW FILE########
__FILENAME__ = main
from __future__ import print_function
import time
from stockmarket import StockMarket
from aggregator import Aggregator
from viewer import Viewer

def main():
    nasdaq = StockMarket("NASDAQ", ["AAPL", "CSCO", "MSFT", "GOOG"])
    newyork = StockMarket("NYSE", ["IBM", "HPQ", "BP"])

    agg = Aggregator()
    agg.add_symbols(nasdaq.symbols())
    agg.add_symbols(newyork.symbols())
    print("aggregated symbols:", agg.available_symbols())

    nasdaq.listener(agg)
    newyork.listener(agg)

    view = Viewer()
    agg.view(view, ["IBM", "AAPL", "MSFT"])
    print("")
    while True:
        nasdaq.generate()
        newyork.generate()
        time.sleep(0.5)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = stockmarket
import random

class StockMarket(object):
    def __init__(self, marketname, symbols):
        self.name = marketname
        self.symbolmeans = {}
        for symbol in symbols:
            self.symbolmeans[symbol] = random.uniform(20, 200)
        self.aggregators = []

    def generate(self):
        quotes = {}
        for symbol, mean in self.symbolmeans.items():
            if random.random() < 0.2:
                quotes[symbol] = round(random.normalvariate(mean, 20), 2)
        for aggregator in self.aggregators:
            aggregator.quotes(self.name, quotes)

    def listener(self,aggregator):
        self.aggregators.append(aggregator)

    def symbols(self):
        return self.symbolmeans.keys()

########NEW FILE########
__FILENAME__ = viewer
from __future__ import print_function

class Viewer(object):
    def quote(self, market, symbol, value):
        print("{0}.{1}: {2}".format(market, symbol, value))

########NEW FILE########
__FILENAME__ = aggregator
from __future__ import print_function

class Aggregator(object):
    def __init__(self):
        self.viewers = {}
        self.symbols = []

    def add_symbols(self, symbols):
        self.symbols.extend(symbols)

    def available_symbols(self):
        return self.symbols

    def view(self, viewer, symbols):
        print("aggregator gets a new viewer, for symbols:", symbols)
        self.viewers[viewer] = symbols

    def quotes(self, market, stockquotes):
        for symbol, value in stockquotes.items():
            for viewer, symbols in self.viewers.items():
                if symbol in symbols:
                    viewer.quote(market, symbol, value)


def main(stockmarkets):
    aggregator = Aggregator()
    for market in stockmarkets:
        aggregator.add_symbols(market.symbols())
        market.listener(aggregator)
    if not aggregator.available_symbols():
        raise ValueError("no symbols found!")
    print("aggregated symbols:", aggregator.available_symbols())
    return aggregator

########NEW FILE########
__FILENAME__ = main
from __future__ import print_function
import stockmarket
import aggregator
import viewer
import sys

if sys.version_info < (3,0):
    input = raw_input

def main():
    markets = stockmarket.main()
    aggr = aggregator.main(markets)
    viewer.main(aggr)
    print("\nPress enter to quit.\n")
    input()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = stockmarket
from __future__ import print_function
import random
import threading
import time

class StockMarket(object):
    def __init__(self, marketname, symbols):
        self.name = marketname
        self.symbolmeans = {}
        for symbol in symbols:
            self.symbolmeans[symbol] = random.uniform(20, 200)
        self.aggregators = []

    def generate(self):
        quotes = {}
        for symbol, mean in self.symbolmeans.items():
            if random.random() < 0.2:
                quotes[symbol] = round(random.normalvariate(mean, 20), 2)
        print("new quotes generated for", self.name)
        for aggregator in self.aggregators:
            aggregator.quotes(self.name, quotes)

    def listener(self,aggregator):
        print("market {0} adding new aggregator".format(self.name))
        self.aggregators.append(aggregator)

    def symbols(self):
        return self.symbolmeans.keys()

    def run(self):
        def generate_symbols():
            while True:
                time.sleep(random.random())
                self.generate()
        thread = threading.Thread(target=generate_symbols)
        thread.setDaemon(True)
        thread.start()


def main():
    nasdaq = StockMarket("NASDAQ", ["AAPL", "CSCO", "MSFT", "GOOG"])
    newyork = StockMarket("NYSE", ["IBM", "HPQ", "BP"])
    nasdaq.run()
    newyork.run()
    return [nasdaq, newyork]

########NEW FILE########
__FILENAME__ = viewer
from __future__ import print_function

class Viewer(object):
    def quote(self, market, symbol, value):
        print("{0}.{1}: {2}".format(market, symbol, value))


def main(aggregator):
    viewer = Viewer()
    aggregator.view(viewer, ["IBM", "AAPL", "MSFT"])
    return viewer

########NEW FILE########
__FILENAME__ = aggregator
from __future__ import print_function
import Pyro4

Pyro4.config.SERIALIZER = 'pickle'
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')


class Aggregator(object):
    def __init__(self):
        self.viewers = {}
        self.symbols = []

    def add_symbols(self, symbols):
        self.symbols.extend(symbols)

    def available_symbols(self):
        return self.symbols

    def view(self, viewer, symbols):
        print("aggregator gets a new viewer, for symbols:", symbols)
        self.viewers[viewer] = symbols

    def quotes(self, market, stockquotes):
        for symbol, value in stockquotes.items():
            for viewer, symbols in self.viewers.items():
                if symbol in symbols:
                    viewer.quote(market, symbol, value)


def main():
    aggregator = Aggregator()
    daemon = Pyro4.Daemon()
    agg_uri = daemon.register(aggregator)
    ns = Pyro4.locateNS()
    ns.register("example.stockquote.aggregator", agg_uri)
    for market, market_uri in ns.list(prefix="example.stockmarket.").items():
        print("joining market", market)
        stockmarket = Pyro4.Proxy(market_uri)
        stockmarket.listener(aggregator)
        aggregator.add_symbols(stockmarket.symbols())
    if not aggregator.available_symbols():
        raise ValueError("no symbols found! (have you started the stock market first?)")
    print("Aggregator running. Symbols:", aggregator.available_symbols())
    daemon.requestLoop()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = stockmarket
from __future__ import print_function
import random
import threading
import time
import Pyro4

Pyro4.config.SERIALIZER = 'pickle'
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')


class StockMarket(object):
    def __init__(self, marketname, symbols):
        self.name = marketname
        self.symbolmeans = {}
        for symbol in symbols:
            self.symbolmeans[symbol] = random.uniform(20, 200)
        self.aggregators = []

    def generate(self):
        quotes = {}
        for symbol, mean in self.symbolmeans.items():
            if random.random() < 0.2:
                quotes[symbol] = round(random.normalvariate(mean, 20), 2)
        print("new quotes generated for", self.name)
        for aggregator in self.aggregators:
            aggregator.quotes(self.name, quotes)

    def listener(self,aggregator):
        print("market {0} adding new aggregator".format(self.name))
        self.aggregators.append(aggregator)

    def symbols(self):
        return list(self.symbolmeans.keys())

    def run(self):
        def generate_symbols():
            while True:
                time.sleep(random.random())
                self.generate()
        thread = threading.Thread(target=generate_symbols)
        thread.setDaemon(True)
        thread.start()


def main():
    nasdaq = StockMarket("NASDAQ", ["AAPL", "CSCO", "MSFT", "GOOG"])
    newyork = StockMarket("NYSE", ["IBM", "HPQ", "BP"])

    daemon = Pyro4.Daemon()
    nasdaq_uri = daemon.register(nasdaq)
    newyork_uri = daemon.register(newyork)
    ns = Pyro4.locateNS()
    ns.register("example.stockmarket.nasdaq", nasdaq_uri)
    ns.register("example.stockmarket.newyork", newyork_uri)

    nasdaq.run()
    newyork.run()
    print("Stockmarkets running.")
    daemon.requestLoop()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = viewer
from __future__ import print_function
import sys
import Pyro4

Pyro4.config.SERIALIZER = 'pickle'
Pyro4.config.SERIALIZERS_ACCEPTED.add('pickle')

if sys.version_info < (3,0):
    input = raw_input


class Viewer(object):
    def quote(self, market, symbol, value):
        print("{0}.{1}: {2}".format(market, symbol, value))


def main():
    viewer = Viewer()
    daemon = Pyro4.Daemon()
    daemon.register(viewer)
    aggregator = Pyro4.Proxy("PYRONAME:example.stockquote.aggregator")
    print("Available stock symbols:", aggregator.available_symbols())
    symbols = input("Enter symbols you want to view (comma separated):")
    symbols = [symbol.strip() for symbol in symbols.split(",")]
    aggregator.view(viewer, symbols)
    print("Viewer listening on symbols", symbols)
    daemon.requestLoop()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import time, sys
import Pyro4
import Pyro4.errors


# NOTE: the timer in IronPython seems to be wacky.
# So we use wider margins for that, to check if the delays are ok.

def approxEqual(x, y):
    return abs(x-y) < 0.2

# disable timeout globally
Pyro4.config.COMMTIMEOUT = 0

obj = Pyro4.core.Proxy("PYRONAME:example.timeout")
obj._pyroBind()
print("No timeout is configured. Calling delay with 2 seconds.")
start = time.time()
result = obj.delay(2)
assert result == "slept 2 seconds"
duration = time.time()-start
if sys.platform != "cli":
    assert approxEqual(duration, 2), "expected 2 seconds duration"
else:
    assert 1.0 < duration < 3.0, "expected about 2 seconds duration"

# override timeout for this object
obj._pyroTimeout = 1
print("Timeout set to 1 seconds. Calling delay with 2 seconds.")
start = time.time()
try:
    result = obj.delay(2)
    print("!?should have raised TimeoutError!?")
except Pyro4.errors.TimeoutError:
    print("TimeoutError! As expected!")
    duration = time.time()-start
    if sys.platform != "cli":
        assert approxEqual(duration, 1), "expected 1 seconds duration"
    else:
        assert 0.9 < duration < 1.9, "expected about 1 second duration"

# set timeout globally
Pyro4.config.COMMTIMEOUT=1

obj=Pyro4.core.Proxy("PYRONAME:example.timeout")
print("COMMTIMEOUT is set globally. Calling delay with 2 seconds.")
start=time.time()
try:
    result=obj.delay(2)
    print("!?should have raised TimeoutError!?")
except Pyro4.errors.TimeoutError:
    print("TimeoutError! As expected!")
    duration = time.time()-start
    if sys.platform != "cli":
        assert approxEqual(duration, 1), "expected 1 seconds duration"
    else:
        assert 0.9 < duration < 1.9, "expected about 1 second duration"

# override again for this object
obj._pyroTimeout = None
print("No timeout is configured. Calling delay with 3 seconds.")
start = time.time()
result = obj.delay(3)
assert result == "slept 3 seconds"
duration = time.time()-start
if sys.platform != "cli":
    assert approxEqual(duration, 3), "expected 3 seconds duration"
else:
    assert 2.5 < duration < 3.5, "expected about 3 second duration"

print("Trying to connect to the frozen daemon.")
obj = Pyro4.core.Proxy("PYRONAME:example.timeout.frozendaemon")
obj._pyroTimeout = 1
print("Timeout set to 1 seconds. Trying to connect.")
start = time.time()
try:
    result = obj.delay(5)
    print("!?should have raised TimeoutError!?")
except Pyro4.errors.TimeoutError:
    print("TimeoutError! As expected!")
    duration = time.time()-start
    if sys.platform != "cli":
        assert approxEqual(duration,1), "expected 1 seconds duration"
    else:
        assert 0.9 < duration < 1.9, "expected about 1 second duration"

print("Disabling timeout and trying to connect again. This may take forever now.")
print("Feel free to abort with ctrl-c or ctrl-break.")
obj._pyroTimeout = None
obj.delay(1)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import time
import Pyro4


class TimeoutServer(object):
    def delay(self, amount):
        print("sleeping %d" % amount)
        time.sleep(amount)
        print("done.")
        return "slept %d seconds" % amount

Pyro4.config.COMMTIMEOUT = 0        # the server won't be using timeouts

ns = Pyro4.naming.locateNS()
daemon = Pyro4.core.Daemon()
daemon2 = Pyro4.core.Daemon()
obj = TimeoutServer()
obj2 = TimeoutServer()
uri = daemon.register(obj)
uri2 = daemon2.register(obj2)
ns.register("example.timeout", uri)
ns.register("example.timeout.frozendaemon", uri2)
print("Server ready.")
# Note that we're only starting one of the 2 daemons.
# daemon2 is not started to simulate connection timeouts.
daemon.requestLoop()

########NEW FILE########
__FILENAME__ = abstract_namespace_server
# this only works on Linux
# it uses the abstract namespace socket feature.

from __future__ import print_function
import Pyro4

class Thingy(object):
    def message(self, arg):
        print("Message received:",arg)
        return "Roger!"

d=Pyro4.Daemon(unixsocket="\0example_unix.sock")   # notice the 0-byte at the start
uri=d.register(Thingy(), "example.unixsock")
print("Server running, uri=", uri)
string_uri = str(uri)
print("Actually, the uri contains a 0-byte, make sure you copy this to the client:")
print(repr(string_uri))
d.requestLoop()


########NEW FILE########
__FILENAME__ = client
from __future__ import print_function
import sys
import Pyro4

if sys.version_info<(3,0):
    input=raw_input


uri=input("enter the server uri: ").strip()
with Pyro4.Proxy(uri) as p:
    response=p.message("Hello there!")
    print("Response was:",response)

########NEW FILE########
__FILENAME__ = server
from __future__ import print_function
import os
import Pyro4

class Thingy(object):
    def message(self, arg):
        print("Message received:",arg)
        return "Roger!"

if os.path.exists("example_unix.sock"):
    os.remove("example_unix.sock")
d=Pyro4.Daemon(unixsocket="example_unix.sock")
uri=d.register(Thingy(), "example.unixsock")
print("Server running, uri=",uri)
d.requestLoop()


########NEW FILE########
__FILENAME__ = person
from __future__ import print_function
import sys

if sys.version_info < (3, 0):
    input = raw_input


class Person(object):
    def __init__(self, name):
        self.name = name
        
    def visit(self, warehouse):
        print("This is {0}.".format(self.name))
        self.deposit(warehouse)
        self.retrieve(warehouse)
        print("Thank you, come again!")
        
    def deposit(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type a thing you want to store (or empty): ").strip()
        if item:
            warehouse.store(self.name, item)
            
    def retrieve(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type something you want to take (or empty): ").strip()
        if item:
            warehouse.take(self.name, item)

########NEW FILE########
__FILENAME__ = visit
# This is the code that runs this example.
from warehouse import Warehouse
from person import Person

warehouse = Warehouse()
janet = Person("Janet")
henry = Person("Henry")
janet.visit(warehouse)
henry.visit(warehouse)

########NEW FILE########
__FILENAME__ = warehouse
from __future__ import print_function


class Warehouse(object):
    def __init__(self):
        self.contents = ["chair", "bike", "flashlight", "laptop", "couch"]

    def list_contents(self):
        return self.contents

    def take(self, name, item):
        self.contents.remove(item)
        print("{0} took the {1}.".format(name, item))

    def store(self, name, item):
        self.contents.append(item)
        print("{0} stored the {1}.".format(name, item))

########NEW FILE########
__FILENAME__ = person
from __future__ import print_function
import sys

if sys.version_info < (3, 0):
    input = raw_input


class Person(object):
    def __init__(self, name):
        self.name = name
        
    def visit(self, warehouse):
        print("This is {0}.".format(self.name))
        self.deposit(warehouse)
        self.retrieve(warehouse)
        print("Thank you, come again!")
        
    def deposit(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type a thing you want to store (or empty): ").strip()
        if item:
            warehouse.store(self.name, item)
            
    def retrieve(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type something you want to take (or empty): ").strip()
        if item:
            warehouse.take(self.name, item)

########NEW FILE########
__FILENAME__ = visit
# This is the code that visits the warehouse.
import sys
import Pyro4
from person import Person

if sys.version_info<(3,0):
    input = raw_input

uri = input("Enter the uri of the warehouse: ").strip()
warehouse = Pyro4.Proxy(uri)
janet = Person("Janet")
henry = Person("Henry")
janet.visit(warehouse)
henry.visit(warehouse)

########NEW FILE########
__FILENAME__ = warehouse
from __future__ import print_function
import Pyro4
import person


class Warehouse(object):
    def __init__(self):
        self.contents = ["chair", "bike", "flashlight", "laptop", "couch"]

    def list_contents(self):
        return self.contents

    def take(self, name, item):
        self.contents.remove(item)
        print("{0} took the {1}.".format(name, item))

    def store(self, name, item):
        self.contents.append(item)
        print("{0} stored the {1}.".format(name, item))


def main():
    warehouse = Warehouse()
    Pyro4.Daemon.serveSimple(
            {
                warehouse: "example.warehouse"
            },
            ns = False)

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = person
from __future__ import print_function
import sys

if sys.version_info < (3, 0):
    input = raw_input


class Person(object):
    def __init__(self, name):
        self.name = name
        
    def visit(self, warehouse):
        print("This is {0}.".format(self.name))
        self.deposit(warehouse)
        self.retrieve(warehouse)
        print("Thank you, come again!")
        
    def deposit(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type a thing you want to store (or empty): ").strip()
        if item:
            warehouse.store(self.name, item)
            
    def retrieve(self, warehouse):
        print("The warehouse contains:", warehouse.list_contents())
        item = input("Type something you want to take (or empty): ").strip()
        if item:
            warehouse.take(self.name, item)

########NEW FILE########
__FILENAME__ = visit
# This is the code that visits the warehouse.
import sys
import Pyro4
import Pyro4.util
from person import Person

sys.excepthook = Pyro4.util.excepthook

warehouse = Pyro4.Proxy("PYRONAME:example.warehouse")
janet = Person("Janet")
henry = Person("Henry")
janet.visit(warehouse)
henry.visit(warehouse)

########NEW FILE########
__FILENAME__ = warehouse
from __future__ import print_function
import Pyro4
import person


class Warehouse(object):
    def __init__(self):
        self.contents = ["chair", "bike", "flashlight", "laptop", "couch"]

    def list_contents(self):
        return self.contents

    def take(self, name, item):
        self.contents.remove(item)
        print("{0} took the {1}.".format(name, item))

    def store(self, name, item):
        self.contents.append(item)
        print("{0} stored the {1}.".format(name, item))


def main():
    warehouse = Warehouse()
    Pyro4.Daemon.serveSimple(
            {
                warehouse: "example.warehouse"
            },
            ns = True)

if __name__=="__main__":
    main()

########NEW FILE########
__FILENAME__ = configuration
"""
Configuration settings.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

# Env vars used at package import time (see __init__.py):
# PYRO_LOGLEVEL   (enable Pyro log config and set level)
# PYRO_LOGFILE    (the name of the logfile if you don't like the default)

import os
import platform
import pickle


class Configuration(object):
    __slots__=("HOST", "NS_HOST", "NS_PORT", "NS_BCPORT", "NS_BCHOST",
               "COMPRESSION", "SERVERTYPE", "DOTTEDNAMES", "COMMTIMEOUT",
               "POLLTIMEOUT", "THREADING2", "ONEWAY_THREADED",
               "DETAILED_TRACEBACK", "SOCK_REUSE", "PREFER_IP_VERSION",
               "THREADPOOL_SIZE", "HMAC_KEY", "AUTOPROXY", "PICKLE_PROTOCOL_VERSION",
               "BROADCAST_ADDRS", "NATHOST", "NATPORT", "MAX_MESSAGE_SIZE",
               "FLAME_ENABLED", "SERIALIZER", "SERIALIZERS_ACCEPTED", "LOGWIRE" )

    def __init__(self):
        self.reset()

    def reset(self, useenvironment=True):
        """
        Set default config items.
        If useenvironment is False, won't read environment variables settings (useful if you can't trust your env).
        """
        self.HOST = "localhost"  # don't expose us to the outside world by default
        self.NS_HOST = self.HOST
        self.NS_PORT = 9090      # tcp
        self.NS_BCPORT = 9091    # udp
        self.NS_BCHOST = None
        self.NATHOST = None
        self.NATPORT = 0
        self.COMPRESSION = False
        self.SERVERTYPE = "thread"
        self.DOTTEDNAMES = False   # server-side
        self.COMMTIMEOUT = 0.0
        self.POLLTIMEOUT = 2.0     # seconds
        self.SOCK_REUSE = False    # so_reuseaddr on server sockets?
        self.THREADING2 = False    # use threading2 if available?
        self.ONEWAY_THREADED = True     # oneway calls run in their own thread
        self.DETAILED_TRACEBACK = False
        self.THREADPOOL_SIZE = 16
        self.HMAC_KEY = None   # must be bytes type
        self.AUTOPROXY = True
        self.MAX_MESSAGE_SIZE = 0   # 0 = unlimited
        self.BROADCAST_ADDRS = "<broadcast>, 0.0.0.0"   # comma separated list of broadcast addresses
        self.FLAME_ENABLED = False
        self.PREFER_IP_VERSION = 4    # 4, 6 or 0 (let OS choose according to RFC 3484)
        self.SERIALIZER = "serpent"
        self.SERIALIZERS_ACCEPTED = "serpent,marshal,json"
        self.LOGWIRE = False   # log wire-level messages
        self.PICKLE_PROTOCOL_VERSION = pickle.HIGHEST_PROTOCOL

        if useenvironment:
            # process enviroment variables
            PREFIX="PYRO_"
            for symbol in self.__slots__:
                if PREFIX+symbol in os.environ:
                    value=getattr(self, symbol)
                    envvalue=os.environ[PREFIX+symbol]
                    if value is not None:
                        valuetype=type(value)
                        if valuetype is bool:
                            # booleans are special
                            envvalue=envvalue.lower()
                            if envvalue in ("0", "off", "no", "false"):
                                envvalue=False
                            elif envvalue in ("1", "yes", "on", "true"):
                                envvalue=True
                            else:
                                raise ValueError("invalid boolean value: %s%s=%s" % (PREFIX, symbol, envvalue))
                        else:
                            envvalue=valuetype(envvalue)  # just cast the value to the appropriate type
                    setattr(self, symbol, envvalue)
        if self.HMAC_KEY and type(self.HMAC_KEY) is not bytes:
            self.HMAC_KEY = self.HMAC_KEY.encode("utf-8")     # convert to bytes
        self.SERIALIZERS_ACCEPTED = set(self.SERIALIZERS_ACCEPTED.split(','))

    def asDict(self):
        """returns the current config as a regular dictionary"""
        result={}
        for item in self.__slots__:
            result[item]=getattr(self, item)
        return result

    def parseAddressesString(self, addresses):
        """
        Parses the addresses string which contains one or more ip addresses separated by a comma.
        Returns a sequence of these addresses. '' is replaced by the empty string.
        """
        result=[]
        for addr in addresses.split(','):
            addr=addr.strip()
            if addr=="''":
                addr=""
            result.append(addr)
        return result

    def dump(self):
        # easy config diagnostics
        from Pyro4.constants import VERSION
        import inspect
        if hasattr(platform, "python_implementation"):
            implementation = platform.python_implementation()
        else:
            implementation = "Jython" if os.name=="java" else "???"
        config=self.asDict()
        config["LOGFILE"]=os.environ.get("PYRO_LOGFILE")
        config["LOGLEVEL"]=os.environ.get("PYRO_LOGLEVEL")
        result= ["Pyro version: %s" % VERSION,
                 "Loaded from: %s" % os.path.abspath(os.path.split(inspect.getfile(Configuration))[0]),
                 "Python version: %s %s (%s, %s)" % (implementation, platform.python_version(), platform.system(), os.name),
                 "Active configuration settings:"]
        for n, v in sorted(config.items()):
            result.append("%s = %s" % (n, v))
        return "\n".join(result)

if __name__=="__main__":
    print(Configuration().dump())

########NEW FILE########
__FILENAME__ = constants
"""
Definitions of various hard coded constants.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

# Pyro version
VERSION = "4.26-dev"

# standard object name for the Daemon object
DAEMON_NAME = "Pyro.Daemon"

# standard name for the Name server itself
NAMESERVER_NAME = "Pyro.NameServer"

# standard name for Flame server
FLAME_NAME = "Pyro.Flame"

# wire protocol version. Note that if this gets updated, Pyrolite might need an update too.
PROTOCOL_VERSION = 46

########NEW FILE########
__FILENAME__ = core
"""
Core logic (uri, daemon, proxy stuff).

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import re, sys, time, os
import logging, uuid
from Pyro4 import constants, threadutil, util, socketutil, errors
from Pyro4.socketserver.threadpoolserver import SocketServer_Threadpool
from Pyro4.socketserver.multiplexserver import SocketServer_Select, SocketServer_Poll
from Pyro4 import futures
from Pyro4.message import Message
import Pyro4

__all__ = ["URI", "Proxy", "Daemon", "callback", "batch", "async"]

if sys.version_info >= (3, 0):
    basestring = str

log = logging.getLogger("Pyro4.core")


class URI(object):
    """
    Pyro object URI (universal resource identifier).
    The uri format is like this: ``PYRO:objectid@location`` where location is one of:

    - ``hostname:port`` (tcp/ip socket on given port)
    - ``./u:sockname`` (Unix domain socket on localhost)

    There is also a 'Magic format' for simple name resolution using Name server:
      ``PYRONAME:objectname[@location]``  (optional name server location, can also omit location port)

    You can write the protocol in lowercase if you like (``pyro:...``) but it will
    automatically be converted to uppercase internally.
    """
    uriRegEx = re.compile(r"(?P<protocol>[Pp][Yy][Rr][Oo][a-zA-Z]*):(?P<object>\S+?)(@(?P<location>\S+))?$")
    __slots__ = ("protocol", "object", "sockname", "host", "port", "object")

    def __init__(self, uri):
        if isinstance(uri, URI):
            state=uri.__getstate__()
            self.__setstate__(state)
            return
        if not isinstance(uri, basestring):
            raise TypeError("uri parameter object is of wrong type")
        self.sockname=self.host=self.port=None
        match=self.uriRegEx.match(uri)
        if not match:
            raise errors.PyroError("invalid uri")
        self.protocol=match.group("protocol").upper()
        self.object=match.group("object")
        location=match.group("location")
        if self.protocol=="PYRONAME":
            self._parseLocation(location, Pyro4.config.NS_PORT)
            return
        if self.protocol=="PYRO":
            if not location:
                raise errors.PyroError("invalid uri")
            self._parseLocation(location, None)
        else:
            raise errors.PyroError("invalid uri (protocol)")

    def _parseLocation(self, location, defaultPort):
        if not location:
            return
        if location.startswith("./u:"):
            self.sockname=location[4:]
            if (not self.sockname) or ':' in self.sockname:
                raise errors.PyroError("invalid uri (location)")
        else:
            if location.startswith("["):  # ipv6
                if location.startswith("[["):  # possible mistake: double-bracketing
                    raise errors.PyroError("invalid ipv6 address: enclosed in too many brackets")
                self.host, _, self.port = re.match(r"\[([0-9a-fA-F:%]+)](:(\d+))?", location).groups()
            else:
                self.host, _, self.port = location.partition(":")
            if not self.port:
                self.port=defaultPort
            try:
                self.port=int(self.port)
            except (ValueError, TypeError):
                raise errors.PyroError("invalid port in uri, port="+str(self.port))

    @staticmethod
    def isUnixsockLocation(location):
        """determine if a location string is for a Unix domain socket"""
        return location.startswith("./u:")

    @property
    def location(self):
        """property containing the location string, for instance ``"servername.you.com:5555"``"""
        if self.host:
            if ":" in self.host:    # ipv6
                return "[%s]:%d" % (self.host, self.port)
            else:
                return "%s:%d" % (self.host, self.port)
        elif self.sockname:
            return "./u:"+self.sockname
        else:
            return None

    def asString(self):
        """the string representation of this object"""
        result=self.protocol+":"+self.object
        location=self.location
        if location:
            result+="@"+location
        return result

    def __str__(self):
        string=self.asString()
        if sys.version_info<(3, 0) and type(string) is unicode:
            return string.encode("ascii", "replace")
        return string

    def __unicode__(self):
        return self.asString()

    def __repr__(self):
        return "<%s.%s at 0x%x, %s>" % (self.__class__.__module__, self.__class__.__name__, id(self), str(self))

    def __eq__(self, other):
        if not isinstance(other, URI):
            return False
        return (self.protocol, self.object, self.sockname, self.host, self.port) \
            == (other.protocol, other.object, other.sockname, other.host, other.port)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.protocol, self.object, self.sockname, self.host, self.port))

    # note: getstate/setstate are not needed if we use pickle protocol 2,
    # but this way it helps pickle to make the representation smaller by omitting all attribute names.

    def __getstate__(self):
        return self.protocol, self.object, self.sockname, self.host, self.port

    def __setstate__(self, state):
        self.protocol, self.object, self.sockname, self.host, self.port = state

    def __getstate_for_dict__(self):
        return self.__getstate__()

    def __setstate_from_dict__(self, state):
        self.__setstate__(state)


class _RemoteMethod(object):
    """method call abstraction"""
    def __init__(self, send, name):
        self.__send = send
        self.__name = name

    def __getattr__(self, name):
        return _RemoteMethod(self.__send, "%s.%s" % (self.__name, name))

    def __call__(self, *args, **kwargs):
        return self.__send(self.__name, args, kwargs)


def _check_hmac():
    if Pyro4.config.HMAC_KEY:
        if sys.version_info>=(3, 0) and type(Pyro4.config.HMAC_KEY) is not bytes:
            raise errors.PyroError("HMAC_KEY must be bytes type")


class Proxy(object):
    """
    Pyro proxy for a remote object. Intercepts method calls and dispatches them to the remote object.

    .. automethod:: _pyroBind
    .. automethod:: _pyroRelease
    .. automethod:: _pyroReconnect
    .. automethod:: _pyroBatch
    .. automethod:: _pyroAsync
    """
    __pyroAttributes = frozenset(["__getnewargs__", "__getnewargs_ex__", "__getinitargs__", "_pyroConnection", "_pyroUri", "_pyroOneway", "_pyroTimeout", "_pyroSeq"])

    def __init__(self, uri):
        """
        .. autoattribute:: _pyroOneway
        .. autoattribute:: _pyroTimeout
        """
        _check_hmac()  # check if hmac secret key is set
        if isinstance(uri, basestring):
            uri=URI(uri)
        elif not isinstance(uri, URI):
            raise TypeError("expected Pyro URI")
        self._pyroUri=uri
        self._pyroConnection=None
        self._pyroOneway=set()
        self._pyroSeq=0    # message sequence number
        self.__pyroTimeout=Pyro4.config.COMMTIMEOUT
        self.__pyroLock=threadutil.Lock()
        self.__pyroConnLock=threadutil.Lock()
        util.get_serializer(Pyro4.config.SERIALIZER)  # assert that the configured serializer is available
        if os.name=="java" and Pyro4.config.SERIALIZER=="marshal":
            import warnings
            warnings.warn("marshal doesn't work correctly with Jython (issue 2077); please choose another serializer", RuntimeWarning)

    def __del__(self):
        if hasattr(self, "_pyroConnection"):
            self._pyroRelease()

    def __getattr__(self, name):
        if name in Proxy.__pyroAttributes:
            # allows it to be safely pickled
            raise AttributeError(name)
        return _RemoteMethod(self._pyroInvoke, name)

    def __repr__(self):
        connected="connected" if self._pyroConnection else "not connected"
        return "<%s.%s at 0x%x, %s, for %s>" % (self.__class__.__module__, self.__class__.__name__,
               id(self), connected, self._pyroUri)

    def __unicode__(self):
        return str(self)

    def __getstate_for_dict__(self):
        return self._pyroUri.asString(), tuple(self._pyroOneway), self.__pyroTimeout

    def __setstate_from_dict__(self, state):
        uri = Pyro4.core.URI(state[0])
        oneway = set(state[1])
        timeout = state[2]
        self.__setstate__((uri, oneway, timeout))

    def __getstate__(self):
        return self._pyroUri, self._pyroOneway, self.__pyroTimeout    # skip the connection

    def __setstate__(self, state):
        self._pyroUri, self._pyroOneway, self.__pyroTimeout = state
        self._pyroConnection = None
        self._pyroSeq = 0
        self.__pyroLock = threadutil.Lock()
        self.__pyroConnLock = threadutil.Lock()

    def __copy__(self):
        uriCopy=URI(self._pyroUri)
        return Proxy(uriCopy)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._pyroRelease()

    def __eq__(self, other):
        if other is self:
            return True
        return isinstance(other, Proxy) and other._pyroUri == self._pyroUri and other._pyroOneway == self._pyroOneway

    def __ne__(self, other):
        if other and isinstance(other, Proxy):
            return other._pyroUri != self._pyroUri or other._pyroOneway != self._pyroOneway
        return True

    def __hash__(self):
        return hash(self._pyroUri) ^ hash(frozenset(self._pyroOneway))

    def _pyroRelease(self):
        """release the connection to the pyro daemon"""
        with self.__pyroConnLock:
            if self._pyroConnection is not None:
                self._pyroConnection.close()
                self._pyroConnection=None
                log.debug("connection released")

    def _pyroBind(self):
        """
        Bind this proxy to the exact object from the uri. That means that the proxy's uri
        will be updated with a direct PYRO uri, if it isn't one yet.
        If the proxy is already bound, it will not bind again.
        """
        return self.__pyroCreateConnection(True)

    def __pyroGetTimeout(self):
        return self.__pyroTimeout

    def __pyroSetTimeout(self, timeout):
        self.__pyroTimeout=timeout
        if self._pyroConnection is not None:
            self._pyroConnection.timeout=timeout
    _pyroTimeout=property(__pyroGetTimeout, __pyroSetTimeout)

    def _pyroInvoke(self, methodname, vargs, kwargs, flags=0):
        """perform the remote method call communication"""
        if self._pyroConnection is None:
            # rebind here, don't do it from inside the invoke because deadlock will occur
            self.__pyroCreateConnection()
        serializer = util.get_serializer(Pyro4.config.SERIALIZER)
        data, compressed = serializer.serializeCall(
            self._pyroConnection.objectId, methodname, vargs, kwargs,
            compress=Pyro4.config.COMPRESSION)
        if compressed:
            flags |= Pyro4.message.FLAGS_COMPRESSED
        if methodname in self._pyroOneway:
            flags |= Pyro4.message.FLAGS_ONEWAY
        with self.__pyroLock:
            self._pyroSeq=(self._pyroSeq+1)&0xffff
            if Pyro4.config.LOGWIRE:
                log.debug("proxy wiredata sending: msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (Pyro4.message.MSG_INVOKE, flags, serializer.serializer_id, self._pyroSeq, data))
            msg = Message(Pyro4.message.MSG_INVOKE, data, serializer.serializer_id, flags, self._pyroSeq)
            try:
                self._pyroConnection.send(msg.to_bytes())
                del msg  # invite GC to collect the object, don't wait for out-of-scope
                if flags & Pyro4.message.FLAGS_ONEWAY:
                    return None    # oneway call, no response data
                else:
                    msg = Message.recv(self._pyroConnection, [Pyro4.message.MSG_RESULT])
                    if Pyro4.config.LOGWIRE:
                        log.debug("proxy wiredata received: msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (msg.type, msg.flags, msg.serializer_id, msg.seq, msg.data))
                    self.__pyroCheckSequence(msg.seq)
                    if msg.serializer_id != serializer.serializer_id:
                        error = "invalid serializer in response: %d" % msg.serializer_id
                        log.error(error)
                        raise errors.ProtocolError(error)
                    data = serializer.deserializeData(msg.data, compressed=msg.flags & Pyro4.message.FLAGS_COMPRESSED)
                    if msg.flags & Pyro4.message.FLAGS_EXCEPTION:
                        if sys.platform=="cli":
                            util.fixIronPythonExceptionForPickle(data, False)
                        raise data
                    else:
                        return data
            except (errors.CommunicationError, KeyboardInterrupt):
                # Communication error during read. To avoid corrupt transfers, we close the connection.
                # Otherwise we might receive the previous reply as a result of a new methodcall!
                # Special case for keyboardinterrupt: people pressing ^C to abort the client
                # may be catching the keyboardinterrupt in their code. We should probably be on the
                # safe side and release the proxy connection in this case too, because they might
                # be reusing the proxy object after catching the exception...
                self._pyroRelease()
                raise

    def __pyroCheckSequence(self, seq):
        if seq!=self._pyroSeq:
            err="invoke: reply sequence out of sync, got %d expected %d" % (seq, self._pyroSeq)
            log.error(err)
            raise errors.ProtocolError(err)

    def __pyroCreateConnection(self, replaceUri=False):
        """
        Connects this proxy to the remote Pyro daemon. Does connection handshake.
        Returns true if a new connection was made, false if an existing one was already present.
        """
        with self.__pyroConnLock:
            if self._pyroConnection is not None:
                return False     # already connected
            from Pyro4.naming import resolve  # don't import this globally because of cyclic dependancy
            uri=resolve(self._pyroUri)
            # socket connection (normal or Unix domain socket)
            conn=None
            log.debug("connecting to %s", uri)
            connect_location=uri.sockname if uri.sockname else (uri.host, uri.port)
            with self.__pyroLock:
                try:
                    if self._pyroConnection is not None:
                        return False    # already connected
                    sock=socketutil.createSocket(connect=connect_location, reuseaddr=Pyro4.config.SOCK_REUSE, timeout=self.__pyroTimeout)
                    conn=socketutil.SocketConnection(sock, uri.object)
                    # Do handshake. For now, no need to send anything. (message type CONNECT is not yet used)
                    msg = Message.recv(conn, None)
                    # any trailing data (dataLen>0) is an error message, if any
                except Exception:
                    x=sys.exc_info()[1]
                    if conn:
                        conn.close()
                    err="cannot connect: %s" % x
                    log.error(err)
                    if isinstance(x, errors.CommunicationError):
                        raise
                    else:
                        ce = errors.CommunicationError(err)
                        ce.__cause__ = x
                        raise ce
                else:
                    if msg.type==Pyro4.message.MSG_CONNECTFAIL:
                        error="connection rejected"
                        if msg.data:
                            serializer = util.get_serializer_by_id(msg.serializer_id)
                            data = serializer.deserializeData(msg.data, compressed=msg.flags & Pyro4.message.FLAGS_COMPRESSED)
                            error += ", reason: " + data
                        conn.close()
                        log.error(error)
                        raise errors.CommunicationError(error)
                    elif msg.type==Pyro4.message.MSG_CONNECTOK:
                        self._pyroConnection=conn
                        if replaceUri:
                            self._pyroUri=uri
                        log.debug("connected to %s", self._pyroUri)
                        return True
                    else:
                        conn.close()
                        err="connect: invalid msg type %d received" % msg.type
                        log.error(err)
                        raise errors.ProtocolError(err)

    def _pyroReconnect(self, tries=100000000):
        """(re)connect the proxy to the daemon containing the pyro object which the proxy is for"""
        self._pyroRelease()
        while tries:
            try:
                self.__pyroCreateConnection()
                return
            except errors.CommunicationError:
                tries-=1
                if tries:
                    time.sleep(2)
        msg="failed to reconnect"
        log.error(msg)
        raise errors.ConnectionClosedError(msg)

    def _pyroBatch(self):
        """returns a helper class that lets you create batched method calls on the proxy"""
        return _BatchProxyAdapter(self)

    def _pyroAsync(self):
        """returns a helper class that lets you do asynchronous method calls on the proxy"""
        return _AsyncProxyAdapter(self)

    def _pyroInvokeBatch(self, calls, oneway=False):
        flags=Pyro4.message.FLAGS_BATCH
        if oneway:
            flags|=Pyro4.message.FLAGS_ONEWAY
        return self._pyroInvoke("<batch>", calls, None, flags)


class _BatchedRemoteMethod(object):
    """method call abstraction that is used with batched calls"""
    def __init__(self, calls, name):
        self.__calls = calls
        self.__name = name

    def __getattr__(self, name):
        return _BatchedRemoteMethod(self.__calls, "%s.%s" % (self.__name, name))

    def __call__(self, *args, **kwargs):
        self.__calls.append((self.__name, args, kwargs))


class _BatchProxyAdapter(object):
    """Helper class that lets you batch multiple method calls into one.
    It is constructed with a reference to the normal proxy that will
    carry out the batched calls. Call methods on this object thatyou want to batch,
    and finally call the batch proxy itself. That call will return a generator
    for the results of every method call in the batch (in sequence)."""
    def __init__(self, proxy):
        self.__proxy=proxy
        self.__calls=[]

    def __getattr__(self, name):
        return _BatchedRemoteMethod(self.__calls, name)

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass

    def __copy__(self):
        return self

    def __resultsgenerator(self, results):
        for result in results:
            if isinstance(result, futures._ExceptionWrapper):
                result.raiseIt()   # re-raise the remote exception locally.
            else:
                yield result   # it is a regular result object, yield that and continue.

    def __call__(self, oneway=False, async=False):
        if oneway and async:
            raise errors.PyroError("async oneway calls make no sense")
        if async:
            return _AsyncRemoteMethod(self, "<asyncbatch>")()
        else:
            results=self.__proxy._pyroInvokeBatch(self.__calls, oneway)
            self.__calls=[]   # clear for re-use
            if not oneway:
                return self.__resultsgenerator(results)

    def _pyroInvoke(self, name, args, kwargs):
        # ignore all parameters, we just need to execute the batch
        results=self.__proxy._pyroInvokeBatch(self.__calls)
        self.__calls=[]   # clear for re-use
        return self.__resultsgenerator(results)


class _AsyncProxyAdapter(object):
    def __init__(self, proxy):
        self.__proxy=proxy

    def __getattr__(self, name):
        return _AsyncRemoteMethod(self.__proxy, name)


class _AsyncRemoteMethod(object):
    """async method call abstraction (call will run in a background thread)"""
    def __init__(self, proxy, name):
        self.__proxy = proxy
        self.__name = name

    def __getattr__(self, name):
        return _AsyncRemoteMethod(self.__proxy, "%s.%s" % (self.__name, name))

    def __call__(self, *args, **kwargs):
        result=futures.FutureResult()
        thread=threadutil.Thread(target=self.__asynccall, args=(result, args, kwargs))
        thread.setDaemon(True)
        thread.start()
        return result

    def __asynccall(self, asyncresult, args, kwargs):
        try:
            # use a copy of the proxy otherwise calls would be serialized,
            # and use contextmanager to close the proxy after we're done
            with self.__proxy.__copy__() as proxy:
                value = proxy._pyroInvoke(self.__name, args, kwargs)
            asyncresult.value=value
        except Exception:
            # ignore any exceptions here, return them as part of the async result instead
            asyncresult.value=futures._ExceptionWrapper(sys.exc_info()[1])


def batch(proxy):
    """convenience method to get a batch proxy adapter"""
    return proxy._pyroBatch()


def async(proxy):
    """convenience method to get an async proxy adapter"""
    return proxy._pyroAsync()


def pyroObjectToAutoProxy(self):
    """reduce function that automatically replaces Pyro objects by a Proxy"""
    if Pyro4.config.AUTOPROXY:
        daemon = getattr(self, "_pyroDaemon", None)
        if daemon:
            # only return a proxy if the object is a registered pyro object
            return Pyro4.core.Proxy(daemon.uriFor(self))
    return self


class DaemonObject(object):
    """The part of the daemon that is exposed as a Pyro object."""
    def __init__(self, daemon):
        self.daemon=daemon

    def registered(self):
        """returns a list of all object names registered in this daemon"""
        return list(self.daemon.objectsById.keys())

    def ping(self):
        """a simple do-nothing method for testing purposes"""
        pass


class Daemon(object):
    """
    Pyro daemon. Contains server side logic and dispatches incoming remote method calls
    to the appropriate objects.
    """
    def __init__(self, host=None, port=0, unixsocket=None, nathost=None, natport=None):
        _check_hmac()  # check if hmac secret key is set
        if host is None:
            host=Pyro4.config.HOST
        if nathost is None:
            nathost=Pyro4.config.NATHOST
        if natport is None:
            natport=Pyro4.config.NATPORT or None
        if nathost and unixsocket:
            raise ValueError("cannot use nathost together with unixsocket")
        if (nathost is None) ^ (natport is None):
            raise ValueError("must provide natport with nathost")
        if Pyro4.config.SERVERTYPE=="thread":
            self.transportServer=SocketServer_Threadpool()
        elif Pyro4.config.SERVERTYPE=="multiplex":
            # choose the 'best' multiplexing implementation
            if os.name=="java":
                self.transportServer = SocketServer_Select()    # poll doesn't work as given in jython ('socket must be in nonblocking mode')
            else:
                self.transportServer = SocketServer_Poll() if socketutil.hasPoll else SocketServer_Select()
        else:
            raise errors.PyroError("invalid server type '%s'" % Pyro4.config.SERVERTYPE)
        self.transportServer.init(self, host, port, unixsocket)
        #: The location (str of the form ``host:portnumber``) on which the Daemon is listening
        self.locationStr=self.transportServer.locationStr
        log.debug("created daemon on %s", self.locationStr)
        natport_for_loc = natport
        if natport==0:
            # expose internal port number as NAT port as well. (don't use port because it could be 0 and will be chosen by the OS)
            natport_for_loc = int(self.locationStr.split(":")[1])
        #: The NAT-location (str of the form ``nathost:natportnumber``) on which the Daemon is exposed for use with NAT-routing
        self.natLocationStr = "%s:%d" % (nathost, natport_for_loc) if nathost else None
        if self.natLocationStr:
            log.debug("NAT address is %s", self.natLocationStr)
        pyroObject=DaemonObject(self)
        pyroObject._pyroId=constants.DAEMON_NAME
        #: Dictionary from Pyro object id to the actual Pyro object registered by this id
        self.objectsById={pyroObject._pyroId: pyroObject}
        self.__mustshutdown=threadutil.Event()
        self.__loopstopped=threadutil.Event()
        self.__loopstopped.set()
        # assert that the configured serializers are available, and remember their ids:
        self.__serializer_ids = set([util.get_serializer(ser_name).serializer_id for ser_name in Pyro4.config.SERIALIZERS_ACCEPTED])
        log.debug("accepted serializers: %s" % Pyro4.config.SERIALIZERS_ACCEPTED)

    @property
    def sock(self):
        return self.transportServer.sock

    @property
    def sockets(self):
        return self.transportServer.sockets

    @staticmethod
    def serveSimple(objects, host=None, port=0, daemon=None, ns=True, verbose=True):
        """
        Very basic method to fire up a daemon (or supply one yourself).
        objects is a dict containing objects to register as keys, and
        their names (or None) as values. If ns is true they will be registered
        in the naming server as well, otherwise they just stay local.
        """
        if not daemon:
            daemon=Daemon(host, port)
        with daemon:
            if ns:
                ns=Pyro4.naming.locateNS()
            for obj, name in objects.items():
                if ns:
                    localname=None   # name is used for the name server
                else:
                    localname=name   # no name server, use name in daemon
                uri=daemon.register(obj, localname)
                if verbose:
                    print("Object {0}:\n    uri = {1}".format(repr(obj), uri))
                if name and ns:
                    ns.register(name, uri)
                    if verbose:
                        print("    name = {0}".format(name))
            if verbose:
                print("Pyro daemon running.")
            daemon.requestLoop()

    def requestLoop(self, loopCondition=lambda: True):
        """
        Goes in a loop to service incoming requests, until someone breaks this
        or calls shutdown from another thread.
        """
        self.__mustshutdown.clear()
        log.info("daemon %s entering requestloop", self.locationStr)
        try:
            self.__loopstopped.clear()
            condition=lambda: not self.__mustshutdown.isSet() and loopCondition()
            self.transportServer.loop(loopCondition=condition)
        finally:
            self.__loopstopped.set()
        log.debug("daemon exits requestloop")

    def events(self, eventsockets):
        """for use in an external event loop: handle any requests that are pending for this daemon"""
        return self.transportServer.events(eventsockets)

    def shutdown(self):
        """Cleanly terminate a daemon that is running in the requestloop. It must be running
        in a different thread, or this method will deadlock."""
        log.debug("daemon shutting down")
        self.__mustshutdown.set()
        self.transportServer.wakeup()
        time.sleep(0.05)
        self.close()
        self.__loopstopped.wait()
        log.info("daemon %s shut down", self.locationStr)

    def _handshake(self, conn):
        """Perform connection handshake with new clients"""
        # For now, client is not sending anything. Just respond with a CONNECT_OK.
        # We need a minimal amount of data or the socket will remain blocked
        # on some systems... (messages smaller than 40 bytes)
        # Return True for successful handshake, False if something was wrong.
        # We default to the marshal serializer to send message payload of "ok"
        ser = util.get_serializer("marshal")
        data = ser.dumps("ok")
        msg = Message(Pyro4.message.MSG_CONNECTOK, data, ser.serializer_id, 0, 1)
        conn.send(msg.to_bytes())
        return True

    def handleRequest(self, conn):
        """
        Handle incoming Pyro request. Catches any exception that may occur and
        wraps it in a reply to the calling side, as to not make this server side loop
        terminate due to exceptions caused by remote invocations.
        """
        request_flags=0
        request_seq=0
        request_serializer_id = util.MarshalSerializer.serializer_id
        wasBatched=False
        isCallback=False
        try:
            msg = Message.recv(conn, [Pyro4.message.MSG_INVOKE, Pyro4.message.MSG_PING])
            request_flags = msg.flags
            request_seq = msg.seq
            request_serializer_id = msg.serializer_id
            if Pyro4.config.LOGWIRE:
                log.debug("daemon wiredata received: msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (msg.type, msg.flags, msg.serializer_id, msg.seq, msg.data))
            if msg.type == Pyro4.message.MSG_PING:
                # return same seq, but ignore any data (it's a ping, not an echo). Nothing is deserialized.
                msg = Message(Pyro4.message.MSG_PING, b"pong", msg.serializer_id, 0, msg.seq)
                if Pyro4.config.LOGWIRE:
                    log.debug("daemon wiredata sending: msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (msg.type, msg.flags, msg.serializer_id, msg.seq, msg.data))
                conn.send(msg.to_bytes())
                return
            if msg.serializer_id not in self.__serializer_ids:
                raise errors.ProtocolError("message used serializer that is not accepted: %d" % msg.serializer_id)
            serializer = util.get_serializer_by_id(msg.serializer_id)
            objId, method, vargs, kwargs = serializer.deserializeCall(msg.data, compressed=msg.flags & Pyro4.message.FLAGS_COMPRESSED)
            del msg  # invite GC to collect the object, don't wait for out-of-scope
            obj = self.objectsById.get(objId)
            if obj is not None:
                if kwargs and sys.version_info<(2, 6, 5) and os.name!="java":
                    # Python before 2.6.5 doesn't accept unicode keyword arguments
                    kwargs = dict((str(k), kwargs[k]) for k in kwargs)
                if request_flags & Pyro4.message.FLAGS_BATCH:
                    # batched method calls, loop over them all and collect all results
                    data=[]
                    for method, vargs, kwargs in vargs:
                        method=util.resolveDottedAttribute(obj, method, Pyro4.config.DOTTEDNAMES)
                        try:
                            result=method(*vargs, **kwargs)   # this is the actual method call to the Pyro object
                        except Exception:
                            xt, xv = sys.exc_info()[0:2]
                            log.debug("Exception occurred while handling batched request: %s", xv)
                            xv._pyroTraceback=util.formatTraceback(detailed=Pyro4.config.DETAILED_TRACEBACK)
                            if sys.platform=="cli":
                                util.fixIronPythonExceptionForPickle(xv, True)  # piggyback attributes
                            data.append(futures._ExceptionWrapper(xv))
                            break   # stop processing the rest of the batch
                        else:
                            data.append(result)
                    wasBatched=True
                else:
                    # normal single method call
                    method=util.resolveDottedAttribute(obj, method, Pyro4.config.DOTTEDNAMES)
                    if request_flags & Pyro4.message.FLAGS_ONEWAY and Pyro4.config.ONEWAY_THREADED:
                        # oneway call to be run inside its own thread
                        thread=threadutil.Thread(target=method, args=vargs, kwargs=kwargs)
                        thread.setDaemon(True)
                        thread.start()
                    else:
                        isCallback=getattr(method, "_pyroCallback", False)
                        data=method(*vargs, **kwargs)   # this is the actual method call to the Pyro object
            else:
                log.debug("unknown object requested: %s", objId)
                raise errors.DaemonError("unknown object")
            if request_flags & Pyro4.message.FLAGS_ONEWAY:
                return   # oneway call, don't send a response
            else:
                data, compressed = serializer.serializeData(data, compress=Pyro4.config.COMPRESSION)
                response_flags=0
                if compressed:
                    response_flags |= Pyro4.message.FLAGS_COMPRESSED
                if wasBatched:
                    response_flags |= Pyro4.message.FLAGS_BATCH
                if Pyro4.config.LOGWIRE:
                    log.debug("daemon wiredata sending: msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (Pyro4.message.MSG_RESULT, response_flags, serializer.serializer_id, request_seq, data))
                msg = Message(Pyro4.message.MSG_RESULT, data, serializer.serializer_id, response_flags, request_seq)
                conn.send(msg.to_bytes())
        except Exception:
            xt, xv = sys.exc_info()[0:2]
            if xt is not errors.ConnectionClosedError:
                log.debug("Exception occurred while handling request: %r", xv)
                if not request_flags & Pyro4.message.FLAGS_ONEWAY and not isinstance(xv, errors.CommunicationError):
                    # only return the error to the client if it wasn't a oneway call, and not a communication error
                    # (in these cases, it makes no sense to try to report the error back to the client...)
                    tblines=util.formatTraceback(detailed=Pyro4.config.DETAILED_TRACEBACK)
                    self._sendExceptionResponse(conn, request_seq, request_serializer_id, xv, tblines)
            if isCallback or isinstance(xv, (errors.CommunicationError, errors.SecurityError)):
                raise       # re-raise if flagged as callback, communication or security error.

    def _sendExceptionResponse(self, connection, seq, serializer_id, exc_value, tbinfo):
        """send an exception back including the local traceback info"""
        exc_value._pyroTraceback=tbinfo
        if sys.platform=="cli":
            util.fixIronPythonExceptionForPickle(exc_value, True)  # piggyback attributes
        serializer = util.get_serializer_by_id(serializer_id)
        try:
            data, compressed = serializer.serializeData(exc_value)
        except:
            # the exception object couldn't be serialized, use a generic PyroError instead
            xt, xv, tb = sys.exc_info()
            msg = "Error serializing exception: %s. Original exception: %s: %s" % (str(xv), type(exc_value), str(exc_value))
            exc_value = errors.PyroError(msg)
            exc_value._pyroTraceback=tbinfo
            if sys.platform=="cli":
                util.fixIronPythonExceptionForPickle(exc_value, True)  # piggyback attributes
            data, compressed = serializer.serializeData(exc_value)
        flags = Pyro4.message.FLAGS_EXCEPTION
        if compressed:
            flags |= Pyro4.message.FLAGS_COMPRESSED
        if Pyro4.config.LOGWIRE:
            log.debug("daemon wiredata sending (error response): msgtype=%d flags=0x%x ser=%d seq=%d data=%r" % (Pyro4.message.MSG_RESULT, flags, serializer.serializer_id, seq, data))
        msg = Message(Pyro4.message.MSG_RESULT, data, serializer.serializer_id, flags, seq)
        connection.send(msg.to_bytes())

    def register(self, obj, objectId=None):
        """
        Register a Pyro object under the given id. Note that this object is now only
        known inside this daemon, it is not automatically available in a name server.
        This method returns a URI for the registered object.
        """
        if objectId:
            if not isinstance(objectId, basestring):
                raise TypeError("objectId must be a string or None")
        else:
            objectId="obj_"+uuid.uuid4().hex   # generate a new objectId
        if hasattr(obj, "_pyroId") and obj._pyroId != "":     # check for empty string is needed for Cython
            raise errors.DaemonError("object already has a Pyro id")
        if objectId in self.objectsById:
            raise errors.DaemonError("object already registered with that id")
        # set some pyro attributes
        obj._pyroId=objectId
        obj._pyroDaemon=self
        if Pyro4.config.AUTOPROXY:
            # register a custom serializer for the type to automatically return proxies
            # we need to do this for all known serializers
            for ser in util._serializers.values():
                ser.register_type_replacement(type(obj), pyroObjectToAutoProxy)
        # register the object in the mapping
        self.objectsById[obj._pyroId]=obj
        return self.uriFor(objectId)

    def unregister(self, objectOrId):
        """
        Remove an object from the known objects inside this daemon.
        You can unregister an object directly or with its id.
        """
        if objectOrId is None:
            raise ValueError("object or objectid argument expected")
        if not isinstance(objectOrId, basestring):
            objectId=getattr(objectOrId, "_pyroId", None)
            if objectId is None:
                raise errors.DaemonError("object isn't registered")
        else:
            objectId=objectOrId
            objectOrId=None
        if objectId==constants.DAEMON_NAME:
            return
        if objectId in self.objectsById:
            del self.objectsById[objectId]
            if objectOrId is not None:
                del objectOrId._pyroId
                del objectOrId._pyroDaemon
                # Don't remove the custom type serializer because there may be
                # other registered objects of the same type still depending on it.

    def uriFor(self, objectOrId=None, nat=True):
        """
        Get a URI for the given object (or object id) from this daemon.
        Only a daemon can hand out proper uris because the access location is
        contained in them.
        Note that unregistered objects cannot be given an uri, but unregistered
        object names can (it's just a string we're creating in that case).
        If nat is set to False, the configured NAT address (if any) is ignored and it will
        return an URI for the internal address.
        """
        if not isinstance(objectOrId, basestring):
            objectOrId=getattr(objectOrId, "_pyroId", None)
            if objectOrId is None:
                raise errors.DaemonError("object isn't registered")
        if nat:
            loc=self.natLocationStr or self.locationStr
        else:
            loc=self.locationStr
        return URI("PYRO:%s@%s" % (objectOrId, loc))

    def close(self):
        """Close down the server and release resources"""
        log.debug("daemon closing")
        if self.transportServer:
            self.transportServer.close()
            self.transportServer=None

    def __repr__(self):
        return "<%s.%s at 0x%x, %s, %d objects>" % (self.__class__.__module__, self.__class__.__name__,
               id(self), self.locationStr, len(self.objectsById))

    def __enter__(self):
        if not self.transportServer:
            raise errors.PyroError("cannot reuse this object")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def __getstate__(self):
        return {}   # a little hack to make it possible to serialize Pyro objects, because they can reference a daemon

    def __getstate_for_dict__(self):
        return self.__getstate__()

    def __setstate_from_dict__(self, state):
        pass


# decorators

def callback(object):
    """
    decorator to mark a method to be a 'callback'. This will make Pyro
    raise any errors also on the callback side, and not only on the side
    that does the callback call.
    """
    object._pyroCallback=True
    return object


try:
    import serpent

    def pyro_class_serpent_serializer(obj, serializer, stream, level):
        # Override the default way that a Pyro URI/proxy/daemon is serialized.
        # Because it defines a __getstate__ it would otherwise just become a tuple,
        # and not be deserialized as a class.
        d = Pyro4.util.SerializerBase.class_to_dict(obj)
        serializer.ser_builtins_dict(d, stream, level)

    # register the special serializers for the pyro objects with Serpent
    serpent.register_class(URI, pyro_class_serpent_serializer)
    serpent.register_class(Proxy, pyro_class_serpent_serializer)
    serpent.register_class(Daemon, pyro_class_serpent_serializer)
    serpent.register_class(futures._ExceptionWrapper, pyro_class_serpent_serializer)
except ImportError:
    pass


def serialize_core_object_to_dict(obj):
    return {
        "__class__": "Pyro4.core." + obj.__class__.__name__,
        "state": obj.__getstate_for_dict__()
    }

Pyro4.util.SerializerBase.register_class_to_dict(URI, serialize_core_object_to_dict, serpent_too=False)
Pyro4.util.SerializerBase.register_class_to_dict(Proxy, serialize_core_object_to_dict, serpent_too=False)
Pyro4.util.SerializerBase.register_class_to_dict(Daemon, serialize_core_object_to_dict, serpent_too=False)
Pyro4.util.SerializerBase.register_class_to_dict(futures._ExceptionWrapper, futures._ExceptionWrapper.__serialized_dict__, serpent_too=False)

########NEW FILE########
__FILENAME__ = errors
"""
Definition of the various exceptions that are used in Pyro.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""


class PyroError(Exception):
    """Generic base of all Pyro-specific errors."""
    pass


class CommunicationError(PyroError):
    """Base class for the errors related to network communication problems."""
    pass


class ConnectionClosedError(CommunicationError):
    """The connection was unexpectedly closed."""
    pass


class TimeoutError(CommunicationError):
    """
    A call could not be completed within the set timeout period,
    or the network caused a timeout.
    """
    pass


class ProtocolError(CommunicationError):
    """Pyro received a message that didn't match the active Pyro network protocol, or there was a protocol related error."""
    pass


class NamingError(PyroError):
    """There was a problem related to the name server or object names."""
    pass


class DaemonError(PyroError):
    """The Daemon encountered a problem."""
    pass


class SecurityError(PyroError):
    """A security related error occurred."""
    pass

########NEW FILE########
__FILENAME__ = futures
"""
Support for Futures (asynchronously executed callables).
If you're using Python 3.2 or newer, also see
http://docs.python.org/3/library/concurrent.futures.html#future-objects

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys
import functools
import logging
from Pyro4 import threadutil, util

__all__=["Future", "FutureResult", "_ExceptionWrapper"]

log=logging.getLogger("Pyro4.futures")


class Future(object):
    """
    Holds a callable that will be executed asynchronously and provide its
    result value some time in the future.
    This is a more general implementation than the AsyncRemoteMethod, which
    only works with Pyro proxies (and provides a bit different syntax).
    """
    def __init__(self, callable):
        self.callable = callable
        self.chain = []

    def __call__(self, *args, **kwargs):
        """
        Start the future call with the provided arguments.
        Control flow returns immediately, with a FutureResult object.
        """
        chain = self.chain
        del self.chain  # make it impossible to add new calls to the chain once we started executing it
        result=FutureResult()  # notice that the call chain doesn't sit on the result object
        thread=threadutil.Thread(target=self.__asynccall, args=(result, chain, args, kwargs))
        thread.setDaemon(True)
        thread.start()
        return result

    def __asynccall(self, asyncresult, chain, args, kwargs):
        try:
            value = self.callable(*args, **kwargs)
            # now walk the callchain, passing on the previous value as first argument
            for call, args, kwargs in chain:
                call = functools.partial(call, value)
                value = call(*args, **kwargs)
            asyncresult.value = value
        except Exception:
            # ignore any exceptions here, return them as part of the async result instead
            asyncresult.value=_ExceptionWrapper(sys.exc_info()[1])

    def then(self, call, *args, **kwargs):
        """
        Add a callable to the call chain, to be invoked when the results become available.
        The result of the current call will be used as the first argument for the next call.
        Optional extra arguments can be provided in args and kwargs.
        """
        self.chain.append((call, args, kwargs))


class FutureResult(object):
    """
    The result object for asynchronous calls.
    """
    def __init__(self):
        self.__ready=threadutil.Event()
        self.callchain=[]
        self.valueLock=threadutil.Lock()

    def wait(self, timeout=None):
        """
        Wait for the result to become available, with optional timeout (in seconds).
        Returns True if the result is ready, or False if it still isn't ready.
        """
        result=self.__ready.wait(timeout)
        if result is None:
            # older pythons return None from wait()
            return self.__ready.isSet()
        return result

    @property
    def ready(self):
        """Boolean that contains the readiness of the async result"""
        return self.__ready.isSet()

    def get_value(self):
        self.__ready.wait()
        if isinstance(self.__value, _ExceptionWrapper):
            self.__value.raiseIt()
        else:
            return self.__value

    def set_value(self, value):
        with self.valueLock:
            self.__value=value
            # walk the call chain but only as long as the result is not an exception
            if not isinstance(value, _ExceptionWrapper):
                for call, args, kwargs in self.callchain:
                    call = functools.partial(call, self.__value)
                    self.__value = call(*args, **kwargs)
                    if isinstance(self.__value, _ExceptionWrapper):
                        break
            self.callchain=[]
            self.__ready.set()

    value=property(get_value, set_value, None, "The result value of the call. Reading it will block if not available yet.")

    def then(self, call, *args, **kwargs):
        """
        Add a callable to the call chain, to be invoked when the results become available.
        The result of the current call will be used as the first argument for the next call.
        Optional extra arguments can be provided in args and kwargs.
        """
        if self.__ready.isSet():
            # value is already known, we need to process it immediately (can't use the callchain anymore)
            call = functools.partial(call, self.__value)
            self.__value = call(*args, **kwargs)
        else:
            # add the call to the callchain, it will be processed later when the result arrives
            with self.valueLock:
                self.callchain.append((call, args, kwargs))
        return self


class _ExceptionWrapper(object):
    """Class that wraps a remote exception. If this is returned, Pyro will
    re-throw the exception on the receiving side. Usually this is taken care of
    by a special response message flag, but in the case of batched calls this
    flag is useless and another mechanism was needed."""
    def __init__(self, exception):
        self.exception=exception

    def raiseIt(self):
        if sys.platform=="cli":
            util.fixIronPythonExceptionForPickle(self.exception, False)
        raise self.exception

    def __serialized_dict__(self):
        """serialized form as a dictionary"""
        return {
            "__class__": "Pyro4.futures._ExceptionWrapper",
            "exception": util.SerializerBase.class_to_dict(self.exception)
        }

########NEW FILE########
__FILENAME__ = message
"""
The pyro wire protocol message.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import hashlib
import hmac
import struct
import logging
import sys

import Pyro4
from Pyro4 import constants, errors

__all__ = ["Message"]

log = logging.getLogger("Pyro4.message")

MSG_CONNECT = 1
MSG_CONNECTOK = 2
MSG_CONNECTFAIL = 3
MSG_INVOKE = 4
MSG_RESULT = 5
MSG_PING = 6
FLAGS_EXCEPTION = 1<<0
FLAGS_COMPRESSED = 1<<1
FLAGS_ONEWAY = 1<<2
FLAGS_BATCH = 1<<3
SERIALIZER_SERPENT = 1
SERIALIZER_JSON = 2
SERIALIZER_MARSHAL = 3
SERIALIZER_PICKLE = 4


class Message(object):
    """
    Pyro write protocol message.

    Wire messages contains of a fixed size header, an optional set of annotation chunks,
    and then the payload data. This class doesn't deal with the payload data:
    (de)serialization and handling of that data is done elsewhere.
    Annotation chunks are only parsed, except the 'HMAC' chunk: that is created
    and validated because it is used as a message digest.

    The header format is::

       4   id ('PYRO')
       2   protocol version
       2   message type
       2   message flags
       2   sequence number
       4   data length
       2   data serialization format (serializer id)
       2   annotations length (total of all chunks, 0 if no annotation chunks present)
       2   (reserved)
       2   checksum

    After the header, zero or more annotation chunks may follow, of the format::

       4   id (ASCII)
       2   chunk length
       x   annotation chunk databytes

    After that, the actual payload data bytes follow.

    The sequencenumber is used to check if response messages correspond to the
    actual request message. This prevents the situation where Pyro would perhaps return
    the response data from another remote call (which would not result in an error otherwise!)
    This could happen for instance if the socket data stream gets out of sync, perhaps due To
    some form of signal that interrupts I/O.

    The header checksum is a simple sum of the header fields to make reasonably sure
    that we are dealing with an actual correct PYRO protocol header and not some random
    data that happens to start with the 'PYRO' protocol identifier.

    An 'HMAC' annotation chunk contains the hmac digest of the message data bytes and
    all of the annotation chunk data bytes (except those of the HMAC chunk itself).
    """
    __slots__ = ["type", "flags", "seq", "data", "data_size", "serializer_id", "annotations", "annotations_size"]
    header_format = '!4sHHHHiHHHH'
    header_size = struct.calcsize(header_format)
    checksum_magic = 0x34E9

    def __init__(self, msgType, databytes, serializer_id, flags, seq, annotations=None):
        self.type = msgType
        self.flags = flags
        self.seq = seq
        self.data = databytes
        self.data_size = len(self.data)
        self.serializer_id = serializer_id
        self.annotations = annotations or {}
        if Pyro4.config.HMAC_KEY:
            self.annotations["HMAC"] = self.hmac()
        self.annotations_size = sum([6+len(v) for v in self.annotations.values()])
        if 0 < Pyro4.config.MAX_MESSAGE_SIZE < (self.data_size + self.annotations_size):
            raise errors.ProtocolError("max message size exceeded (%d where max=%d)" % (self.data_size+self.annotations_size, Pyro4.config.MAX_MESSAGE_SIZE))

    def __repr__(self):
        return "<%s.%s at %x, type=%d flags=%d seq=%d datasize=%d #ann=%d>" % (self.__module__, self.__class__.__name__, id(self), self.type, self.flags, self.seq, self.data_size, len(self.annotations))

    def to_bytes(self):
        """creates a byte stream containing the header followed by annotations (if any) followed by the data"""
        return self.__header_bytes() + self.__annotations_bytes() + self.data

    def __header_bytes(self):
        checksum = (self.type+constants.PROTOCOL_VERSION+self.data_size+self.annotations_size+self.serializer_id+self.flags+self.seq+self.checksum_magic)&0xffff
        return struct.pack(self.header_format, b"PYRO", constants.PROTOCOL_VERSION, self.type, self.flags, self.seq, self.data_size, self.serializer_id, self.annotations_size, 0, checksum)

    def __annotations_bytes(self):
        if self.annotations:
            a = []
            for k, v in self.annotations.items():
                if len(k)!=4:
                    raise errors.ProtocolError("annotation key must be of length 4")
                if sys.version_info>=(3, 0):
                    k = k.encode("ASCII")
                a.append(struct.pack("!4sH", k, len(v)))
                a.append(v)
            if sys.platform=="cli":
                return "".join(a)
            return b"".join(a)
        return b""

    # Note: this 'chunked' way of sending is not used because it triggers Nagle's algorithm
    # on some systems (linux). This causes massive delays, unless you change the socket option
    # TCP_NODELAY to disable the algorithm. What also works, is sending all the message bytes
    # in one go: connection.send(message.to_bytes())
    # def send(self, connection):
    #    """send the message as bytes over the connection"""
    #    connection.send(self.__header_bytes())
    #    if self.annotations:
    #        connection.send(self.__annotations_bytes())
    #    connection.send(self.data)

    @classmethod
    def from_header(cls, headerData):
        """Parses a message header. Does not yet process the annotations chunks and message data."""
        if not headerData or len(headerData)!=cls.header_size:
            raise errors.ProtocolError("header data size mismatch")
        tag, ver, msg_type, flags, seq, data_size, serializer_id, annotations_size, _, checksum = struct.unpack(cls.header_format, headerData)
        if tag!=b"PYRO" or ver!=constants.PROTOCOL_VERSION:
            raise errors.ProtocolError("invalid data or unsupported protocol version")
        if checksum!=(msg_type+ver+data_size+annotations_size+flags+serializer_id+seq+cls.checksum_magic)&0xffff:
            raise errors.ProtocolError("header checksum mismatch")
        msg = Message(msg_type, b"", serializer_id, flags, seq)
        msg.data_size = data_size
        msg.annotations_size = annotations_size
        return msg

    @classmethod
    def recv(cls, connection, requiredMsgTypes=None):
        """
        Receives a pyro message from a given connection.
        Accepts the given message types (None=any, or pass a sequence).
        Also reads annotation chunks and the actual payload data.
        Validates a HMAC chunk if present.
        """
        msg = cls.from_header(connection.recv(cls.header_size))
        if 0 < Pyro4.config.MAX_MESSAGE_SIZE < (msg.data_size+msg.annotations_size):
            errorMsg = "max message size exceeded (%d where max=%d)" % (msg.data_size+msg.annotations_size, Pyro4.config.MAX_MESSAGE_SIZE)
            log.error("connection "+str(connection)+": "+errorMsg)
            connection.close()   # close the socket because at this point we can't return the correct sequence number for returning an error message
            raise errors.ProtocolError(errorMsg)
        if requiredMsgTypes and msg.type not in requiredMsgTypes:
            err = "invalid msg type %d received" % msg.type
            log.error(err)
            raise errors.ProtocolError(err)
        if msg.annotations_size:
            # read annotation chunks
            annotations_data = connection.recv(msg.annotations_size)
            msg.annotations = {}
            i = 0
            while i < msg.annotations_size:
                anno, length = struct.unpack("!4sH", annotations_data[i:i+6])
                if sys.version_info>=(3, 0):
                    anno = anno.decode("ASCII")
                msg.annotations[anno] = annotations_data[i+6:i+6+length]
                i += 6+length
        # read data
        msg.data = connection.recv(msg.data_size)
        if "HMAC" in msg.annotations and Pyro4.config.HMAC_KEY:
            if msg.annotations["HMAC"] != msg.hmac():
                raise errors.SecurityError("message hmac mismatch")
        elif ("HMAC" in msg.annotations) != bool(Pyro4.config.HMAC_KEY):
            # Message contains hmac and local HMAC_KEY not set, or vice versa. This is not allowed.
            err = "hmac key config not symmetric"
            log.warning(err)
            raise errors.SecurityError(err)
        return msg

    def hmac(self):
        """returns the hmac of the data and the annotation chunk values (except HMAC chunk itself)"""
        mac = hmac.new(Pyro4.config.HMAC_KEY, self.data, digestmod=hashlib.sha1)
        for k, v in self.annotations.items():
            if k != "HMAC":
                mac.update(v)
        return mac.digest()

########NEW FILE########
__FILENAME__ = naming
"""
Name Server and helper functions.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import re, logging, socket, sys
from Pyro4 import constants, core, socketutil
from Pyro4.threadutil import RLock, Thread
from Pyro4.errors import PyroError, NamingError
import Pyro4

__all__=["locateNS", "resolve", "startNS"]

if sys.version_info>=(3, 0):
    basestring=str

log=logging.getLogger("Pyro4.naming")


class NameServer(object):
    """Pyro name server. Provides a simple flat name space to map logical object names to Pyro URIs."""

    def __init__(self):
        self.namespace={}
        self.lock=RLock()

    def lookup(self, name):
        """Lookup the given name, returns an URI if found"""
        try:
            return core.URI(self.namespace[name])
        except KeyError:
            raise NamingError("unknown name: "+name)

    def register(self, name, uri, safe=False):
        """Register a name with an URI. If safe is true, name cannot be registered twice.
        The uri can be a string or an URI object."""
        if isinstance(uri, core.URI):
            uri=uri.asString()
        elif not isinstance(uri, basestring):
            raise TypeError("only URIs or strings can be registered")
        else:
            core.URI(uri)  # check if uri is valid
        if not isinstance(name, basestring):
            raise TypeError("name must be a str")
        if safe and name in self.namespace:
            raise NamingError("name already registered: "+name)
        with self.lock:
            self.namespace[name]=uri

    def remove(self, name=None, prefix=None, regex=None):
        """Remove a registration. returns the number of items removed."""
        if name and name in self.namespace and name!=constants.NAMESERVER_NAME:
            with self.lock:
                del self.namespace[name]
            return 1
        if prefix:
            with self.lock:
                items=list(self.list(prefix=prefix).keys())
                if constants.NAMESERVER_NAME in items:
                    items.remove(constants.NAMESERVER_NAME)
                for item in items:
                    del self.namespace[item]
                return len(items)
        if regex:
            with self.lock:
                items=list(self.list(regex=regex).keys())
                if constants.NAMESERVER_NAME in items:
                    items.remove(constants.NAMESERVER_NAME)
                for item in items:
                    del self.namespace[item]
                return len(items)
        return 0

    def list(self, prefix=None, regex=None):
        """Retrieve the registered items as a dictionary name-to-URI. The URIs
        in the resulting dict are strings, not URI objects.
        You can filter by prefix or by regex."""
        with self.lock:
            if prefix:
                result={}
                for name in self.namespace:
                    if name.startswith(prefix):
                        result[name]=self.namespace[name]
                return result
            elif regex:
                result={}
                try:
                    regex=re.compile(regex+"$")  # add end of string marker
                except re.error:
                    x=sys.exc_info()[1]
                    raise NamingError("invalid regex: "+str(x))
                else:
                    for name in self.namespace:
                        if regex.match(name):
                            result[name]=self.namespace[name]
                    return result
            else:
                # just return (a copy of) everything
                return self.namespace.copy()

    def ping(self):
        """A simple test method to check if the name server is running correctly."""
        pass


class NameServerDaemon(core.Daemon):
    """Daemon that contains the Name Server."""
    def __init__(self, host=None, port=None, unixsocket=None, nathost=None, natport=None):
        if Pyro4.config.DOTTEDNAMES:
            raise PyroError("Name server won't start with DOTTEDNAMES enabled because of security reasons")
        if host is None:
            host=Pyro4.config.HOST
        if port is None:
            port=Pyro4.config.NS_PORT
        if nathost is None:
            nathost=Pyro4.config.NATHOST
        if natport is None:
            natport=Pyro4.config.NATPORT or None
        super(NameServerDaemon, self).__init__(host, port, unixsocket, nathost=nathost, natport=natport)
        self.nameserver=NameServer()
        self.register(self.nameserver, constants.NAMESERVER_NAME)
        self.nameserver.register(constants.NAMESERVER_NAME, self.uriFor(self.nameserver))
        log.info("nameserver daemon created")

    def close(self):
        super(NameServerDaemon, self).close()
        self.nameserver=None

    def __enter__(self):
        if not self.nameserver:
            raise PyroError("cannot reuse this object")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.nameserver=None
        return super(NameServerDaemon, self).__exit__(exc_type, exc_value, traceback)


class BroadcastServer(object):
    REQUEST_NSURI = "GET_NSURI" if sys.platform=="cli" else b"GET_NSURI"

    def __init__(self, nsUri, bchost=None, bcport=None):
        self.nsUri=nsUri
        if bcport is None:
            bcport=Pyro4.config.NS_BCPORT
        if bchost is None:
            bchost=Pyro4.config.NS_BCHOST
        if ":" in nsUri.host:  # ipv6
            bchost = bchost or "::"
            self.sock=Pyro4.socketutil.createBroadcastSocket((bchost, bcport, 0, 0), reuseaddr=Pyro4.config.SOCK_REUSE, timeout=2.0)
        else:
            self.sock=Pyro4.socketutil.createBroadcastSocket((bchost, bcport), reuseaddr=Pyro4.config.SOCK_REUSE, timeout=2.0)
        self._sockaddr=self.sock.getsockname()
        bchost=bchost or self._sockaddr[0]
        bcport=bcport or self._sockaddr[1]
        if ":" in bchost:  # ipv6
            self.locationStr="[%s]:%d" % (bchost, bcport)
        else:
            self.locationStr="%s:%d" % (bchost, bcport)
        log.info("ns broadcast server created on %s", self.locationStr)
        self.running=True

    def close(self):
        log.debug("ns broadcast server closing")
        self.running=False
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error):
            pass
        self.sock.close()

    def getPort(self):
        return self.sock.getsockname()[1]

    def fileno(self):
        return self.sock.fileno()

    def runInThread(self):
        """Run the broadcast server loop in its own thread. This is mainly for Jython,
        which has problems with multiplexing it using select() with the Name server itself."""
        thread=Thread(target=self.__requestLoop)
        thread.setDaemon(True)
        thread.start()
        log.debug("broadcast server loop running in own thread")

    def __requestLoop(self):
        while self.running:
            self.processRequest()
        log.debug("broadcast server loop terminating")

    def processRequest(self):
        try:
            data, addr=self.sock.recvfrom(100)
            if data==self.REQUEST_NSURI:
                responsedata=core.URI(self.nsUri)
                if responsedata.host=="0.0.0.0":
                    # replace INADDR_ANY address by the interface IP adress that connects to the requesting client
                    try:
                        interface_ip=socketutil.getInterfaceAddress(addr[0])
                        responsedata.host=interface_ip
                    except socket.error:
                        pass
                log.debug("responding to broadcast request from %s: interface %s", addr[0], responsedata.host)
                responsedata = str(responsedata).encode("iso-8859-1")
                self.sock.sendto(responsedata, 0, addr)
        except socket.error:
            pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()


def startNSloop(host=None, port=None, enableBroadcast=True, bchost=None, bcport=None, unixsocket=None, nathost=None, natport=None):
    """utility function that starts a new Name server and enters its requestloop."""
    daemon=NameServerDaemon(host, port, unixsocket, nathost=nathost, natport=natport)
    nsUri=daemon.uriFor(daemon.nameserver)
    internalUri=daemon.uriFor(daemon.nameserver, nat=False)
    bcserver=None
    if unixsocket:
        hostip="Unix domain socket"
    else:
        hostip=daemon.sock.getsockname()[0]
        if hostip.startswith("127."):
            print("Not starting broadcast server for localhost.")
            log.info("Not starting NS broadcast server because NS is bound to localhost")
            enableBroadcast=False
        if enableBroadcast:
            # Make sure to pass the internal uri to the broadcast responder.
            # It is almost always useless to let it return the external uri,
            # because external systems won't be able to talk to this thing anyway.
            bcserver=BroadcastServer(internalUri, bchost, bcport)
            print("Broadcast server running on %s" % bcserver.locationStr)
            bcserver.runInThread()
    print("NS running on %s (%s)" % (daemon.locationStr, hostip))
    if daemon.natLocationStr:
        print("internal URI = %s" % internalUri)
        print("external URI = %s" % nsUri)
    else:
        print("URI = %s" % nsUri)
    try:
        daemon.requestLoop()
    finally:
        daemon.close()
        if bcserver is not None:
            bcserver.close()
    print("NS shut down.")


def startNS(host=None, port=None, enableBroadcast=True, bchost=None, bcport=None, unixsocket=None, nathost=None, natport=None):
    """utility fuction to quickly get a Name server daemon to be used in your own event loops.
    Returns (nameserverUri, nameserverDaemon, broadcastServer)."""
    daemon=NameServerDaemon(host, port, unixsocket, nathost=nathost, natport=natport)
    bcserver=None
    nsUri=daemon.uriFor(daemon.nameserver)
    if not unixsocket:
        hostip=daemon.sock.getsockname()[0]
        if hostip.startswith("127."):
            # not starting broadcast server for localhost.
            enableBroadcast=False
        if enableBroadcast:
            internalUri=daemon.uriFor(daemon.nameserver, nat=False)
            bcserver=BroadcastServer(internalUri, bchost, bcport)
    return nsUri, daemon, bcserver


def locateNS(host=None, port=None):
    """Get a proxy for a name server somewhere in the network."""
    if host is None:
        # first try localhost if we have a good chance of finding it there
        if Pyro4.config.NS_HOST in ("localhost", "::1") or Pyro4.config.NS_HOST.startswith("127."):
            host = Pyro4.config.NS_HOST
            if ":" in host:   # ipv6
                host="[%s]" % host
            uristring="PYRO:%s@%s:%d" % (constants.NAMESERVER_NAME, host, port or Pyro4.config.NS_PORT)
            log.debug("locating the NS: %s", uristring)
            proxy=core.Proxy(uristring)
            try:
                proxy.ping()
                log.debug("located NS")
                return proxy
            except PyroError:
                pass
        # broadcast lookup
        if not port:
            port=Pyro4.config.NS_BCPORT
        log.debug("broadcast locate")
        sock=Pyro4.socketutil.createBroadcastSocket(reuseaddr=Pyro4.config.SOCK_REUSE, timeout=0.7)
        for _ in range(3):
            try:
                for bcaddr in Pyro4.config.parseAddressesString(Pyro4.config.BROADCAST_ADDRS):
                    try:
                        sock.sendto(BroadcastServer.REQUEST_NSURI, 0, (bcaddr, port))
                    except socket.error:
                        x=sys.exc_info()[1]
                        err=getattr(x, "errno", x.args[0])
                        if err not in Pyro4.socketutil.ERRNO_EADDRNOTAVAIL:    # yeah, windows likes to throw these...
                            if err not in Pyro4.socketutil.ERRNO_EADDRINUSE:     # and jython likes to throw thses...
                                raise
                data, _=sock.recvfrom(100)
                sock.close()
                if sys.version_info>=(3, 0):
                    data=data.decode("iso-8859-1")
                log.debug("located NS: %s", data)
                return core.Proxy(data)
            except socket.timeout:
                continue
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error):
            pass
        sock.close()
        log.debug("broadcast locate failed, try direct connection on NS_HOST")
        # broadcast failed, try PYRO directly on specific host
        host=Pyro4.config.NS_HOST
        port=Pyro4.config.NS_PORT
    # pyro direct lookup
    if not port:
        port=Pyro4.config.NS_PORT
    if ":" in host:
        host = "[%s]" % host
    if core.URI.isUnixsockLocation(host):
        uristring="PYRO:%s@%s" % (constants.NAMESERVER_NAME, host)
    else:
        uristring="PYRO:%s@%s:%d" % (constants.NAMESERVER_NAME, host, port)
    uri=core.URI(uristring)
    log.debug("locating the NS: %s", uri)
    proxy=core.Proxy(uri)
    try:
        proxy.ping()
        log.debug("located NS")
        return proxy
    except PyroError as x:
        e = NamingError("Failed to locate the nameserver")
        e.__cause__=x
        raise e


def resolve(uri):
    """Resolve a 'magic' uri (PYRONAME) into the direct PYRO uri."""
    if isinstance(uri, basestring):
        uri=core.URI(uri)
    elif not isinstance(uri, core.URI):
        raise TypeError("can only resolve Pyro URIs")
    if uri.protocol=="PYRO":
        return uri
    log.debug("resolving %s", uri)
    if uri.protocol=="PYRONAME":
        nameserver=locateNS(uri.host, uri.port)
        uri=nameserver.lookup(uri.object)
        nameserver._pyroRelease()
        return uri
    else:
        raise PyroError("invalid uri protocol")


def main(args):
    from optparse import OptionParser
    parser=OptionParser()
    parser.add_option("-n", "--host", dest="host", help="hostname to bind server on")
    parser.add_option("-p", "--port", dest="port", type="int", help="port to bind server on (0=random)")
    parser.add_option("-u", "--unixsocket", help="Unix domain socket name to bind server on")
    parser.add_option("", "--bchost", dest="bchost", help="hostname to bind broadcast server on (default is \"\")")
    parser.add_option("", "--bcport", dest="bcport", type="int",
                      help="port to bind broadcast server on (0=random)")
    parser.add_option("", "--nathost", dest="nathost", help="external hostname in case of NAT")
    parser.add_option("", "--natport", dest="natport", type="int", help="external port in case of NAT")
    parser.add_option("-x", "--nobc", dest="enablebc", action="store_false", default=True,
                      help="don't start a broadcast server")
    options, args = parser.parse_args(args)
    startNSloop(options.host, options.port, enableBroadcast=options.enablebc,
            bchost=options.bchost, bcport=options.bcport, unixsocket=options.unixsocket,
            nathost=options.nathost, natport=options.natport)

if __name__=="__main__":
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = nsc
"""
Name server control tool.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys
from Pyro4 import naming, errors

if sys.version_info<(3, 0):
    input=raw_input


def handleCommand(nameserver, options, args):
    def printListResult(resultdict, title=""):
        print("--------START LIST %s" % title)
        for name, uri in sorted(resultdict.items()):
            print("%s --> %s" % (name, uri))
        print("--------END LIST %s" % title)

    def cmd_ping():
        nameserver.ping()
        print("Name server ping ok.")

    def cmd_listprefix():
        if len(args)==1:
            printListResult(nameserver.list())
        else:
            printListResult(nameserver.list(prefix=args[1]), "- prefix '%s'" % args[1])

    def cmd_listregex():
        if len(args)!=2:
            raise SystemExit("requires one argument: pattern")
        printListResult(nameserver.list(regex=args[1]), "- regex '%s'" % args[1])

    def cmd_register():
        if len(args)!=3:
            raise SystemExit("requires two arguments: name uri")
        nameserver.register(args[1], args[2], safe=True)
        print("Registered %s" % args[1])

    def cmd_remove():
        count=nameserver.remove(args[1])
        if count>0:
            print("Removed %s" % args[1])
        else:
            print("Nothing removed")

    def cmd_removeregex():
        if len(args)!=2:
            raise SystemExit("requires one argument: pattern")
        sure=input("Potentially removing lots of items from the Name server. Are you sure (y/n)?").strip()
        if sure in ('y', 'Y'):
            count=nameserver.remove(regex=args[1])
            print("%d items removed." % count)

    commands={
        "ping": cmd_ping,
        "list": cmd_listprefix,
        "listmatching": cmd_listregex,
        "register": cmd_register,
        "remove": cmd_remove,
        "removematching": cmd_removeregex
    }
    try:
        commands[args[0]]()
    except Exception:
        xt, xv, tb = sys.exc_info()
        print("Error: %s - %s" % (xt.__name__, xv))


def main(args):
    from optparse import OptionParser
    usage = "usage: %prog [options] command [arguments]\nCommand is one of: " \
            "register remove removematching list listmatching ping"
    parser = OptionParser(usage=usage)
    parser.add_option("-n", "--host", dest="host", help="hostname of the NS")
    parser.add_option("-p", "--port", dest="port", type="int",
                      help="port of the NS (or bc-port if host isn't specified)")
    parser.add_option("-u", "--unixsocket", help="Unix domain socket name of the NS")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help="verbose output")
    options, args = parser.parse_args(args)
    if not args or args[0] not in ("register", "remove", "removematching", "list", "listmatching", "ping"):
        parser.error("invalid or missing command")
    if options.verbose:
        print("Locating name server...")
    if options.unixsocket:
        options.host="./u:"+options.unixsocket
    try:
        nameserver=naming.locateNS(options.host, options.port)
    except errors.PyroError:
        x = sys.exc_info()[1]
        print("Failed to locate the name server: %s" % x)
        return
    if options.verbose:
        print("Name server found: %s" % nameserver._pyroUri)
    handleCommand(nameserver, options, args)
    if options.verbose:
        print("Done.")

if __name__ == "__main__":
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = multiplexserver
"""
Socket server based on socket multiplexing. Doesn't use threads.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import socket, select, sys, logging, os
from Pyro4 import socketutil, errors, util
import Pyro4

log=logging.getLogger("Pyro4.socketserver.multiplexed")


class MultiplexedSocketServerBase(object):
    """base class for multiplexed transport server for socket connections"""
    def init(self, daemon, host, port, unixsocket=None):
        log.info("starting multiplexed socketserver")
        self.sock=None
        bind_location=unixsocket if unixsocket else (host, port)
        self.sock=socketutil.createSocket(bind=bind_location, reuseaddr=Pyro4.config.SOCK_REUSE, timeout=Pyro4.config.COMMTIMEOUT, noinherit=True)
        self.clients=set()
        self.daemon=daemon
        sockaddr=self.sock.getsockname()
        if not unixsocket and sockaddr[0].startswith("127."):
            if host is None or host.lower()!="localhost" and not host.startswith("127."):
                log.warning("weird DNS setup: %s resolves to localhost (127.x.x.x)", host)
        if unixsocket:
            self.locationStr="./u:"+unixsocket
        else:
            host=host or sockaddr[0]
            port=port or sockaddr[1]
            if ":" in host:   # ipv6
                self.locationStr="[%s]:%d" % (host, port)
            else:
                self.locationStr="%s:%d" % (host, port)

    def __repr__(self):
        return "<%s on %s, %d connections>" % (self.__class__.__name__, self.locationStr, len(self.clients))

    def __del__(self):
        if self.sock is not None:
            self.sock.close()
            self.sock=None

    def events(self, eventsockets):
        """used for external event loops: handle events that occur on one of the sockets of this server"""
        for s in eventsockets:
            if s is self.sock:
                # server socket, means new connection
                conn=self._handleConnection(self.sock)
                if conn:
                    self.clients.add(conn)
            else:
                # must be client socket, means remote call
                active = self.handleRequest(s)
                if not active:
                    s.close()
                    self.clients.discard(s)

    def _handleConnection(self, sock):
        try:
            if sock is None:
                return
            csock, caddr = sock.accept()
            if Pyro4.config.COMMTIMEOUT:
                csock.settimeout(Pyro4.config.COMMTIMEOUT)
        except socket.error:
            x=sys.exc_info()[1]
            err=getattr(x, "errno", x.args[0])
            if err in socketutil.ERRNO_RETRIES:
                # just ignore this error for now and continue
                log.warning("accept() failed errno=%d, shouldn't happen", err)
                return None
            if err in socketutil.ERRNO_BADF or err in socketutil.ERRNO_ENOTSOCK:
                # our server socket got destroyed
                raise errors.ConnectionClosedError("server socket closed")
            raise
        try:
            conn=socketutil.SocketConnection(csock)
            if self.daemon._handshake(conn):
                return conn
        except:     # catch all errors, otherwise the event loop could terminate
            ex_t, ex_v, ex_tb = sys.exc_info()
            tb = util.formatTraceback(ex_t, ex_v, ex_tb)
            log.warning("error during connect/handshake: %s; %s", ex_v, "\n".join(tb))
            try:
                csock.shutdown(socket.SHUT_RDWR)
            except (OSError, socket.error):
                pass
            csock.close()
        return None

    def close(self):
        log.debug("closing socketserver")
        if self.sock:
            sockname=None
            try:
                sockname=self.sock.getsockname()
            except socket.error:
                pass
            self.sock.close()
            if type(sockname) is str:
                # it was a Unix domain socket, remove it from the filesystem
                if os.path.exists(sockname):
                    os.remove(sockname)
        self.sock=None
        for c in self.clients:
            try:
                c.close()
            except Exception:
                pass
        self.clients=set()

    @property
    def sockets(self):
        socks=[self.sock]
        socks.extend(self.clients)
        return socks

    def wakeup(self):
        """bit of a hack to trigger a blocking server to get out of the loop, useful at clean shutdowns"""
        socketutil.triggerSocket(self.sock)

    def handleRequest(self, conn):
        """Handles a single connection request event and returns if the connection is still active"""
        try:
            self.daemon.handleRequest(conn)
            return True
        except (socket.error, errors.ConnectionClosedError, errors.SecurityError):
            # client went away or caused a security error.
            # close the connection silently.
            return False
        except:
            # other error occurred, close the connection, but also log a warning
            ex_t, ex_v, ex_tb = sys.exc_info()
            tb = util.formatTraceback(ex_t, ex_v, ex_tb)
            log.warning("error during handleRequest: %s; %s", ex_v, "\n".join(tb))
            return False


class SocketServer_Poll(MultiplexedSocketServerBase):
    """transport server for socket connections, poll loop multiplex version."""

    def loop(self, loopCondition=lambda: True):
        log.debug("enter poll-based requestloop")
        poll=select.poll()
        try:
            fileno2connection={}  # map fd to original connection object
            rlist=list(self.clients)+[self.sock]
            for r in rlist:
                poll.register(r.fileno(), select.POLLIN | select.POLLPRI)
                fileno2connection[r.fileno()]=r
            while loopCondition():
                polls=poll.poll(1000*Pyro4.config.POLLTIMEOUT)
                for (fd, mask) in polls:
                    conn=fileno2connection[fd]
                    if conn is self.sock:
                        conn=self._handleConnection(self.sock)
                        if conn:
                            poll.register(conn.fileno(), select.POLLIN | select.POLLPRI)
                            fileno2connection[conn.fileno()]=conn
                            self.clients.add(conn)
                    else:
                        active = self.handleRequest(conn)
                        if not active:
                            try:
                                fn=conn.fileno()
                            except socket.error:
                                pass
                            else:
                                conn.close()
                                self.clients.discard(conn)
                                if fn in fileno2connection:
                                    poll.unregister(fn)
                                    del fileno2connection[fn]
        except KeyboardInterrupt:
            log.debug("stopping on break signal")
            pass
        finally:
            if hasattr(poll, "close"):
                poll.close()
        log.debug("exit poll-based requestloop")


class SocketServer_Select(MultiplexedSocketServerBase):
    """transport server for socket connections, select loop version."""

    def loop(self, loopCondition=lambda: True):
        log.debug("entering select-based requestloop")
        while loopCondition():
            try:
                rlist=list(self.clients)
                rlist.append(self.sock)
                try:
                    rlist, _, _ = socketutil.selectfunction(rlist, [], [], Pyro4.config.POLLTIMEOUT)
                except select.error:
                    if loopCondition():
                        raise
                    else:
                        # swallow the select error if the loopcondition is no longer true, and exit loop
                        # this can occur if we are shutting down and the socket is no longer valid
                        break
                if self.sock in rlist:
                    try:
                        rlist.remove(self.sock)
                    except ValueError:
                        pass  # this can occur when closing down, even when we just tested for presence in the list
                    conn=self._handleConnection(self.sock)
                    if conn:
                        self.clients.add(conn)
                for conn in rlist:
                    # no need to remove conn from rlist, because no more processing is done after this
                    if conn in self.clients:
                        active = self.handleRequest(conn)
                        if not active:
                            conn.close()
                            self.clients.discard(conn)
            except socket.timeout:
                pass   # just continue the loop on a timeout
            except KeyboardInterrupt:
                log.debug("stopping on break signal")
                break
        log.debug("exit select-based requestloop")

########NEW FILE########
__FILENAME__ = threadpool
"""
Thread pooled job queue with a fixed number of worker threads.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import logging
import Pyro4.threadutil
import Pyro4.util
try:
    import queue
except ImportError:
    import Queue as queue


__all__ = ["PoolError", "Pool"]

log = logging.getLogger("Pyro4.threadpool")


class PoolError(Exception):
    pass


class Worker(Pyro4.threadutil.Thread):
    """
    Worker thread that picks jobs from the job queue and executes them.
    If it encounters the sentinel None, it will stop running.
    """
    def __init__(self, jobs):
        super(Worker, self).__init__()
        self.daemon = True
        self.jobs = jobs
        self.name = "Pyro-Worker-%d " % id(self)

    def run(self):
        for job in self.jobs:
            if job is None:
                break
            try:
                job()
            except Exception:
                tb = "".join(Pyro4.util.getPyroTraceback())
                log.error("unhandled exception from job in worker thread %s: %s", self.name, tb)
                # we continue running, just pick another job from the queue


class Pool(object):
    """
    A job queue that is serviced by a pool of worker threads.
    The size of the pool is configurable but stays fixed.
    """
    def __init__(self):
        self.pool = []
        self.jobs = queue.Queue()
        self.closed = False
        for _ in range(Pyro4.config.THREADPOOL_SIZE):
            worker = Worker(self.jobs_generator())
            self.pool.append(worker)
            worker.start()
        log.debug("worker pool of size %d created", self.num_workers())

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def close(self):
        """Close down the thread pool, signaling to all remaining worker threads to shut down."""
        for _ in range(self.num_workers()):
            self.jobs.put(None)  # None as a job means: terminate the worker
        log.debug("closing down, %d halt-jobs issued", self.num_workers())
        self.closed = True
        self.pool = []

    def __repr__(self):
        return "<%s.%s at 0x%x, %d workers, %d jobs>" % \
            (self.__class__.__module__, self.__class__.__name__, id(self), self.num_workers(), self.num_jobs())

    def num_jobs(self):
        return self.jobs.qsize()

    def num_workers(self):
        return len(self.pool)

    def process(self, job):
        """
        Add the job to the general job queue. Job is any callable object.
        """
        if self.closed:
            raise PoolError("job queue is closed")
        self.jobs.put(job)

    def jobs_generator(self):
        """generator that yields jobs from the queue"""
        while not self.closed:
            yield self.jobs.get()   # this is a thread-safe operation (on queue) so we don't need our own locking

########NEW FILE########
__FILENAME__ = threadpoolserver
"""
Socket server based on a worker thread pool. Doesn't use select.

Uses a single worker thread per client connection.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import socket, logging, sys, os
import struct
import Pyro4.util
from Pyro4 import socketutil, errors
from .threadpool import Pool

log=logging.getLogger("Pyro4.threadpoolserver")


class ClientConnectionJob(object):
    """
    Takes care of a single client connection and all requests
    that may arrive during its life span.
    """
    def __init__(self, clientSocket, clientAddr, daemon):
        self.csock = socketutil.SocketConnection(clientSocket)
        self.caddr = clientAddr
        self.daemon = daemon

    def __call__(self):
        if self.handleConnection():
            try:
                while True:
                    try:
                        self.daemon.handleRequest(self.csock)
                    except (socket.error, errors.ConnectionClosedError):
                        # client went away.
                        log.debug("disconnected %s", self.caddr)
                        break
                    except errors.SecurityError:
                        log.debug("security error on client %s", self.caddr)
                        break
                    # other errors simply crash this loop and abort the job (and close the client connection)
            finally:
                self.csock.close()

    def handleConnection(self):
        # connection handshake
        try:
            if self.daemon._handshake(self.csock):
                return True
        except:
            ex_t, ex_v, ex_tb = sys.exc_info()
            tb = Pyro4.util.formatTraceback(ex_t, ex_v, ex_tb)
            log.warning("error during connect/handshake: %s; %s", ex_v, "\n".join(tb))
            self.csock.close()
        return False

    def interrupt(self):
        """attempt to interrupt the worker's request loop"""
        try:
            self.csock.sock.shutdown(socket.SHUT_RDWR)
            self.csock.sock.setblocking(False)
        except (OSError, socket.error):
            pass
        if hasattr(socket, "SO_RCVTIMEO"):
            # setting a recv timeout seems to break the blocking call to recv() on some systems
            try:
                self.csock.sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVTIMEO, struct.pack("ii", 1, 1))
            except socket.error:
                pass
        self.csock.close()


class SocketServer_Threadpool(object):
    """transport server for socket connections, worker thread pool version."""
    def init(self, daemon, host, port, unixsocket=None):
        log.info("starting thread pool socketserver")
        self.daemon = daemon
        self.sock=None
        bind_location=unixsocket if unixsocket else (host, port)
        self.sock=socketutil.createSocket(bind=bind_location, reuseaddr=Pyro4.config.SOCK_REUSE, timeout=Pyro4.config.COMMTIMEOUT, noinherit=True)
        self._socketaddr=self.sock.getsockname()
        if not unixsocket and self._socketaddr[0].startswith("127."):
            if host is None or host.lower()!="localhost" and not host.startswith("127."):
                log.warning("weird DNS setup: %s resolves to localhost (127.x.x.x)", host)
        if unixsocket:
            self.locationStr="./u:"+unixsocket
        else:
            host=host or self._socketaddr[0]
            port=port or self._socketaddr[1]
            if ":" in host:  # ipv6
                self.locationStr="[%s]:%d" % (host, port)
            else:
                self.locationStr="%s:%d" % (host, port)
        self.pool = Pool()

    def __del__(self):
        if self.sock is not None:
            self.sock.close()
        if self.pool is not None:
            self.pool.close()

    def __repr__(self):
        return "<%s on %s, %d workers, %d jobs>" % (self.__class__.__name__, self.locationStr,
            self.pool.num_workers(), self.pool.num_jobs())

    def loop(self, loopCondition=lambda: True):
        log.debug("threadpool server requestloop")
        while (self.sock is not None) and loopCondition():
            try:
                self.events([self.sock])
            except socket.error:
                x=sys.exc_info()[1]
                err=getattr(x, "errno", x.args[0])
                if not loopCondition():
                    # swallow the socket error if loop terminates anyway
                    # this can occur if we are asked to shutdown, socket can be invalid then
                    break
                if err in socketutil.ERRNO_RETRIES:
                    continue
                else:
                    raise
            except KeyboardInterrupt:
                log.debug("stopping on break signal")
                break
        log.debug("threadpool server exits requestloop")

    def events(self, eventsockets):
        """used for external event loops: handle events that occur on one of the sockets of this server"""
        # we only react on events on our own server socket.
        # all other (client) sockets are owned by their individual threads.
        assert self.sock in eventsockets
        try:
            csock, caddr=self.sock.accept()
            log.debug("connected %s", caddr)
            if Pyro4.config.COMMTIMEOUT:
                csock.settimeout(Pyro4.config.COMMTIMEOUT)
            self.pool.process(ClientConnectionJob(csock, caddr, self.daemon))
        except socket.timeout:
            pass  # just continue the loop on a timeout on accept

    def close(self):
        log.debug("closing threadpool server")
        if self.sock:
            sockname=None
            try:
                sockname=self.sock.getsockname()
            except socket.error:
                pass
            try:
                self.sock.close()
                if type(sockname) is str:
                    # it was a Unix domain socket, remove it from the filesystem
                    if os.path.exists(sockname):
                        os.remove(sockname)
            except Exception:
                pass
            self.sock=None
        self.pool.close()

    @property
    def sockets(self):
        # the server socket is all we care about, all client sockets are running in their own threads
        return [self.sock]

    def wakeup(self):
        interruptSocket(self._socketaddr)


def interruptSocket(address):
    """bit of a hack to trigger a blocking server to get out of the loop, useful at clean shutdowns"""
    try:
        sock=socketutil.createSocket(connect=address, keepalive=False, timeout=None)
        socketutil.triggerSocket(sock)
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error):
            pass
        sock.close()
    except socket.error:
        pass

########NEW FILE########
__FILENAME__ = socketutil
"""
Low level socket utilities.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import socket, os, errno, time, sys
from Pyro4.errors import ConnectionClosedError, TimeoutError, CommunicationError
import Pyro4

import select

if os.name == "java":
    # jython workaround for 'socket must be in nonblocking mode' error
    from java.nio.channels import ClosedChannelException
    def selectfunction(rlist, wlist, xlist, timeout=None):
        try:
            return select.cpython_compatible_select(rlist, wlist, xlist, timeout)
        except ClosedChannelException:
            return [], [], []
else:
    selectfunction = select.select

if sys.platform == "win32":
    USE_MSG_WAITALL = False   # it doesn't work reliably on Windows even though it's defined
else:
    USE_MSG_WAITALL = hasattr(socket, "MSG_WAITALL")

# Note: other interesting errnos are EPERM, ENOBUFS, EMFILE
# but it seems to me that all these signify an unrecoverable situation.
# So I didn't include them in de list of retryable errors.
ERRNO_RETRIES=[errno.EINTR, errno.EAGAIN, errno.EWOULDBLOCK, errno.EINPROGRESS]
if hasattr(errno, "WSAEINTR"):
    ERRNO_RETRIES.append(errno.WSAEINTR)
if hasattr(errno, "WSAEWOULDBLOCK"):
    ERRNO_RETRIES.append(errno.WSAEWOULDBLOCK)
if hasattr(errno, "WSAEINPROGRESS"):
    ERRNO_RETRIES.append(errno.WSAEINPROGRESS)

ERRNO_BADF=[errno.EBADF]
if hasattr(errno, "WSAEBADF"):
    ERRNO_BADF.append(errno.WSAEBADF)

ERRNO_ENOTSOCK=[errno.ENOTSOCK]
if hasattr(errno, "WSAENOTSOCK"):
    ERRNO_ENOTSOCK.append(errno.WSAENOTSOCK)
if not hasattr(socket, "SOL_TCP"):
    socket.SOL_TCP=socket.IPPROTO_TCP

ERRNO_EADDRNOTAVAIL=[errno.EADDRNOTAVAIL]
if hasattr(errno, "WSAEADDRNOTAVAIL"):
    ERRNO_EADDRNOTAVAIL.append(errno.WSAEADDRNOTAVAIL)

ERRNO_EADDRINUSE=[errno.EADDRINUSE]
if hasattr(errno, "WSAEADDRINUSE"):
    ERRNO_EADDRINUSE.append(errno.WSAEADDRINUSE)

if sys.version_info >= (3, 0):
    basestring = str


def getIpVersion(hostnameOrAddress):
    """
    Determine what the IP version is of the given hostname or ip address (4 or 6).
    First, it resolves the hostname or address to get an IP address.
    Then, if the resolved IP contains a ':' it is considered to be an ipv6 address,
    and if it contains a '.', it is ipv4.
    """
    address = getIpAddress(hostnameOrAddress)
    if "." in address:
        return 4
    elif ":" in address:
        return 6
    else:
        raise CommunicationError("Unknown IP address format" + address)


def getIpAddress(hostname, workaround127=False, ipVersion=None):
    """
    Returns the IP address for the given host. If you enable the workaround,
    it will use a little hack if the ip address is found to be the loopback address.
    The hack tries to discover an externally visible ip address instead (this only works for ipv4 addresses).
    Set ipVersion=6 to return ipv6 addresses, 4 to return ipv4, 0 to let OS choose the best one or None to use Pyro4.config.PREFER_IP_VERSION.
    """
    def getaddr(ipVersion):
        if ipVersion == 6:
            family=socket.AF_INET6
        elif ipVersion == 4:
            family=socket.AF_INET
        elif ipVersion == 0:
            family=socket.AF_UNSPEC
        else:
            raise ValueError("unknown value for argument ipVersion.")
        ip=socket.getaddrinfo(hostname or socket.gethostname(), 80, family, socket.SOCK_STREAM, socket.SOL_TCP)[0][4][0]
        if workaround127 and (ip.startswith("127.") or ip=="0.0.0.0"):
            ip=getInterfaceAddress("4.2.2.2")
        return ip
    try:
        if hostname and ':' in hostname and ipVersion is None:
            ipVersion = 0
        return getaddr(Pyro4.config.PREFER_IP_VERSION) if ipVersion is None else getaddr(ipVersion)
    except socket.gaierror:
        if ipVersion == 6 or (ipVersion is None and Pyro4.config.PREFER_IP_VERSION == 6):
            # try a (inefficient, but hey) workaround to obtain the ipv6 address:
            # attempt to connect to one of a few ipv6-servers (google's public dns servers),
            # and obtain the connected socket's address. (This will only work with an active internet connection)
            # The Google Public DNS IP addresses are as follows: 8.8.8.8, 8.8.4.4
            # The Google Public DNS IPv6 addresses are as follows:  2001:4860:4860::8888, 2001:4860:4860::8844
            for address in ["2001:4860:4860::8888", "2001:4860:4860::8844"]:
                try:
                    return getInterfaceAddress(address)
                except socket.error:
                    pass
            raise socket.error("unable to determine IPV6 address")
        return getaddr(0)


def getInterfaceAddress(ip_address):
    """tries to find the ip address of the interface that connects to the given host's address"""
    family = socket.AF_INET if getIpVersion(ip_address)==4 else socket.AF_INET6
    sock = socket.socket(family, socket.SOCK_DGRAM)
    try:
        sock.connect((ip_address, 53))   # 53=dns
        return sock.getsockname()[0]
    finally:
        sock.close()


def __nextRetrydelay(delay):
    # first try a few very short delays,
    # if that doesn't work, increase by 0.1 sec every time
    if delay==0.0:
        return 0.001
    if delay==0.001:
        return 0.01
    return delay+0.1


def receiveData(sock, size):
    """Retrieve a given number of bytes from a socket.
    It is expected the socket is able to supply that number of bytes.
    If it isn't, an exception is raised (you will not get a zero length result
    or a result that is smaller than what you asked for). The partial data that
    has been received however is stored in the 'partialData' attribute of
    the exception object."""
    try:
        retrydelay=0.0
        msglen=0
        chunks=[]
        EMPTY_BYTES = b""
        if sys.platform=="cli":
            EMPTY_BYTES = ""
        if USE_MSG_WAITALL:
            # waitall is very convenient and if a socket error occurs,
            # we can assume the receive has failed. No need for a loop,
            # unless it is a retryable error.
            # Some systems have an erratic MSG_WAITALL and sometimes still return
            # less bytes than asked. In that case, we drop down into the normal
            # receive loop to finish the task.
            while True:
                try:
                    data=sock.recv(size, socket.MSG_WAITALL)
                    if len(data)==size:
                        return data
                    # less data than asked, drop down into normal receive loop to finish
                    msglen=len(data)
                    chunks=[data]
                    break
                except socket.timeout:
                    raise TimeoutError("receiving: timeout")
                except socket.error:
                    x=sys.exc_info()[1]
                    err=getattr(x, "errno", x.args[0])
                    if err not in ERRNO_RETRIES:
                        raise ConnectionClosedError("receiving: connection lost: "+str(x))
                    time.sleep(0.00001+retrydelay)  # a slight delay to wait before retrying
                    retrydelay=__nextRetrydelay(retrydelay)
        # old fashioned recv loop, we gather chunks until the message is complete
        while True:
            try:
                while msglen<size:
                    # 60k buffer limit avoids problems on certain OSes like VMS, Windows
                    chunk=sock.recv(min(60000, size-msglen))
                    if not chunk:
                        break
                    chunks.append(chunk)
                    msglen+=len(chunk)
                data = EMPTY_BYTES.join(chunks)
                del chunks
                if len(data)!=size:
                    err=ConnectionClosedError("receiving: not enough data")
                    err.partialData=data  # store the message that was received until now
                    raise err
                return data  # yay, complete
            except socket.timeout:
                raise TimeoutError("receiving: timeout")
            except socket.error:
                x=sys.exc_info()[1]
                err=getattr(x, "errno", x.args[0])
                if err not in ERRNO_RETRIES:
                    raise ConnectionClosedError("receiving: connection lost: "+str(x))
                time.sleep(0.00001+retrydelay)  # a slight delay to wait before retrying
                retrydelay=__nextRetrydelay(retrydelay)
    except socket.timeout:
        raise TimeoutError("receiving: timeout")


def sendData(sock, data):
    """
    Send some data over a socket.
    Some systems have problems with ``sendall()`` when the socket is in non-blocking mode.
    For instance, Mac OS X seems to be happy to throw EAGAIN errors too often.
    This function falls back to using a regular send loop if needed.
    """
    if sock.gettimeout() is None:
        # socket is in blocking mode, we can use sendall normally.
        try:
            sock.sendall(data)
            return
        except socket.timeout:
            raise TimeoutError("sending: timeout")
        except socket.error:
            x=sys.exc_info()[1]
            raise ConnectionClosedError("sending: connection lost: "+str(x))
    else:
        # Socket is in non-blocking mode, use regular send loop.
        retrydelay=0.0
        while data:
            try:
                sent = sock.send(data)
                data = data[sent:]
            except socket.timeout:
                raise TimeoutError("sending: timeout")
            except socket.error:
                x=sys.exc_info()[1]
                err=getattr(x, "errno", x.args[0])
                if err not in ERRNO_RETRIES:
                    raise ConnectionClosedError("sending: connection lost: "+str(x))
                time.sleep(0.00001+retrydelay)  # a slight delay to wait before retrying
                retrydelay=__nextRetrydelay(retrydelay)


_GLOBAL_DEFAULT_TIMEOUT = object()


def createSocket(bind=None, connect=None, reuseaddr=False, keepalive=True, timeout=_GLOBAL_DEFAULT_TIMEOUT, noinherit=False, ipv6=False, nodelay=False):
    """
    Create a socket. Default socket options are keepalive and IPv4 family.
    If 'bind' or 'connect' is a string, it is assumed a Unix domain socket is requested.
    Otherwise, a normal tcp/ip socket is used.
    Set ipv6=True to create an IPv6 socket rather than IPv4.
    Set ipv6=None to use the PREFER_IP_VERSION config setting.
    """
    if bind and connect:
        raise ValueError("bind and connect cannot both be specified at the same time")
    forceIPv6=ipv6 or (ipv6 is None and Pyro4.config.PREFER_IP_VERSION == 6)
    if isinstance(bind, basestring) or isinstance(connect, basestring):
        family=socket.AF_UNIX
    elif not bind and not connect:
        family=socket.AF_INET6 if forceIPv6 else socket.AF_INET
    elif type(bind) is tuple:
        if not bind[0]:
            family=socket.AF_INET6 if forceIPv6 else socket.AF_INET
        else:
            if getIpVersion(bind[0]) == 4:
                if forceIPv6:
                    raise ValueError("IPv4 address is used bind argument with forceIPv6 argument:" + bind[0] + ".")
                family=socket.AF_INET
            elif getIpVersion(bind[0]) == 6:
                family=socket.AF_INET6
                # replace bind addresses by their ipv6 counterparts (4-tuple)
                bind=(bind[0], bind[1], 0, 0)
            else:
                raise ValueError("unknown bind format.")
    elif type(connect) is tuple:
        if not connect[0]:
            family=socket.AF_INET6 if forceIPv6 else socket.AF_INET
        else:
            if getIpVersion(connect[0]) == 4:
                if forceIPv6:
                    raise ValueError("IPv4 address is used in connect argument with forceIPv6 argument:" + bind[0] + ".")
                family=socket.AF_INET
            elif getIpVersion(connect[0]) == 6:
                family=socket.AF_INET6
                # replace connect addresses by their ipv6 counterparts (4-tuple)
                connect=(connect[0], connect[1], 0, 0)
            else:
                raise ValueError("unknown connect format.")
    else:
        raise ValueError("unknown bind or connect format.")
    sock=socket.socket(family, socket.SOCK_STREAM)
    if nodelay:
        setNoDelay(sock)
    if reuseaddr:
        setReuseAddr(sock)
    if noinherit:
        setNoInherit(sock)
    if timeout==0:
        timeout = None
    if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
        sock.settimeout(timeout)
    if bind:
        if type(bind) is tuple and bind[1]==0:
            bindOnUnusedPort(sock, bind[0])
        else:
            sock.bind(bind)
        try:
            sock.listen(100)
        except Exception:
            pass  # jython sometimes raises errors here
    if connect:
        try:
            sock.connect(connect)
        except socket.error:
            # This can happen when the socket is in non-blocking mode (or has a timeout configured).
            # We check if it is a retryable errno (usually EINPROGRESS).
            # If so, we use select() to wait until the socket is in writable state,
            # essentially rebuilding a blocking connect() call.
            xv = sys.exc_info()[1]
            errno = getattr(xv, "errno", 0)
            if errno in ERRNO_RETRIES:
                if timeout is _GLOBAL_DEFAULT_TIMEOUT:
                    timeout = None
                timeout = max(0.1, timeout)   # avoid polling behavior with timeout=0
                while True:
                    sr, sw, se = selectfunction([], [sock], [sock], timeout)
                    if sock in sw:
                        break   # yay, writable now, connect() completed
                    elif sock in se:
                        raise socket.error("connect failed")
            else:
                raise
    if keepalive:
        setKeepalive(sock)
    return sock


def createBroadcastSocket(bind=None, reuseaddr=False, timeout=_GLOBAL_DEFAULT_TIMEOUT, ipv6=False):
    """
    Create a udp broadcast socket.
    Set ipv6=True to create an IPv6 socket rather than IPv4.
    Set ipv6=None to use the PREFER_IP_VERSION config setting.
    """
    forceIPv6=ipv6 or (ipv6 is None and Pyro4.config.PREFER_IP_VERSION == 6)
    if not bind:
        family=socket.AF_INET6 if forceIPv6 else socket.AF_INET
    elif type(bind) is tuple:
        if not bind[0]:
            family=socket.AF_INET6 if forceIPv6 else socket.AF_INET
        else:
            if getIpVersion(bind[0]) == 4:
                if forceIPv6:
                    raise ValueError("IPv4 address is used with forceIPv6 option:" + bind[0] + ".")
                family=socket.AF_INET
            elif getIpVersion(bind[0]) == 6:
                family=socket.AF_INET6
                bind=(bind[0], bind[1], 0, 0)
            else:
                raise ValueError("unknown bind format: %r" % (bind,))
    else:
        raise ValueError("unknown bind format: %r" % (bind,))
    sock=socket.socket(family, socket.SOCK_DGRAM)
    if family == socket.AF_INET:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    if reuseaddr:
        setReuseAddr(sock)
    if timeout is None:
        sock.settimeout(None)
    else:
        if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
            sock.settimeout(timeout)
    if bind:
        host = bind[0] or ""
        port = bind[1]
        if port==0:
            bindOnUnusedPort(sock, host)
        else:
            if len(bind) == 2:
                sock.bind((host, port))  # ipv4
            elif len(bind) == 4:
                sock.bind((host, port, 0, 0))  # ipv6
            else:
                raise ValueError("bind must be None, 2-tuple or 4-tuple")
    return sock


def setReuseAddr(sock):
    """sets the SO_REUSEADDR option on the socket, if possible."""
    try:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    except Exception:
        pass


def setNoDelay(sock):
    """sets the TCP_NODELAY option on the socket (to disable Nagle's algorithm), if possible."""
    try:
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    except Exception:
        pass


def setKeepalive(sock):
    """sets the SO_KEEPALIVE option on the socket, if possible."""
    try:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
    except Exception:
        pass

try:
    import fcntl

    def setNoInherit(sock):
        """Mark the given socket fd as non-inheritable to child processes"""
        fd = sock.fileno()
        flags = fcntl.fcntl(fd, fcntl.F_GETFD)
        fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)

except ImportError:
    # no fcntl available, try the windows version
    try:
        if sys.platform=="cli":
            raise NotImplementedError("IronPython can't obtain a proper HANDLE from a socket")
        from ctypes import windll, WinError, wintypes
        # help ctypes to set the proper args for this kernel32 call on 64-bit pythons
        _SetHandleInformation = windll.kernel32.SetHandleInformation
        _SetHandleInformation.argtypes = [wintypes.HANDLE, wintypes.DWORD, wintypes.DWORD]
        _SetHandleInformation.restype = wintypes.BOOL  # don't need this, but might as well

        def setNoInherit(sock):
            """Mark the given socket fd as non-inheritable to child processes"""
            if not _SetHandleInformation(sock.fileno(), 1, 0):
                raise WinError()

    except (ImportError, NotImplementedError):
        # nothing available, define a dummy function
        def setNoInherit(sock):
            """Mark the given socket fd as non-inheritable to child processes (dummy)"""
            pass


class SocketConnection(object):
    """A wrapper class for plain sockets, containing various methods such as :meth:`send` and :meth:`recv`"""
    __slots__=["sock", "objectId"]

    def __init__(self, sock, objectId=None):
        self.sock=sock
        self.objectId=objectId

    def __del__(self):
        self.close()

    def send(self, data):
        sendData(self.sock, data)

    def recv(self, size):
        return receiveData(self.sock, size)

    def close(self):
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
        except (OSError, socket.error):
            pass
        try:
            self.sock.close()
        except AttributeError:
            pass

    def fileno(self):
        return self.sock.fileno()

    def setTimeout(self, timeout):
        self.sock.settimeout(timeout)

    def getTimeout(self):
        return self.sock.gettimeout()
    timeout=property(getTimeout, setTimeout)


def findProbablyUnusedPort(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
    """Returns an unused port that should be suitable for binding (likely, but not guaranteed).
    This code is copied from the stdlib's test.test_support module."""
    tempsock = socket.socket(family, socktype)
    port = bindOnUnusedPort(tempsock)
    tempsock.close()
    del tempsock
    if sys.platform=="cli":
        return port+1  # the actual port is somehow still in use by the socket when using IronPython
    return port


def bindOnUnusedPort(sock, host='localhost'):
    """Bind the socket to a free port and return the port number.
    This code is based on the code in the stdlib's test.test_support module."""
    if os.name!="java" and sock.family in(socket.AF_INET, socket.AF_INET6) and sock.type == socket.SOCK_STREAM:
        if hasattr(socket, "SO_EXCLUSIVEADDRUSE"):
            # even though Jython has this socket option, it doesn't support it. Hence the check in the if statement above.
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_EXCLUSIVEADDRUSE, 1)
    if sock.family == socket.AF_INET:
        if host == 'localhost':
            sock.bind(('127.0.0.1', 0))
        else:
            sock.bind((host, 0))
    elif sock.family == socket.AF_INET6:
        if host == 'localhost':
            sock.bind(('::1', 0, 0, 0))
        else:
            sock.bind((host, 0, 0, 0))
    else:
        raise CommunicationError("unsupported socket family: " + sock.family)
    if os.name=="java":
        try:
            sock.listen(100)  # otherwise jython always just returns 0 for the port
        except Exception:
            pass  # jython sometimes throws errors here
    port = sock.getsockname()[1]
    return port


"""is select() available?"""
hasSelect = select and hasattr(select, "select")

"""is poll() available?"""
hasPoll = select and hasattr(select, "poll")


def triggerSocket(sock):
    """send a small data packet over the socket, to trigger it"""
    try:
        data = b"!"*16
        if sys.platform=="cli":
            data = "!"*16
        sock.send(data)
    except (socket.error, AttributeError):    # attributeerror can occur here in jython
        pass

########NEW FILE########
__FILENAME__ = echoserver
"""
Echo server for test purposes.
This is usually invoked by starting this module as a script:

  :command:`python -m Pyro4.test.echoserver`

It is also possible to use the :class:`EchoServer` in user code
but that is not terribly useful.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys
import time
from Pyro4 import threadutil
from Pyro4 import naming
import Pyro4

__all__ = ["EchoServer"]


class EchoServer(object):
    """
    The echo server object that is provided as a Pyro object by this module.
    If its :attr:`verbose` attribute is set to ``True``, it will print messages as it receives calls.
    """
    verbose=False
    must_shutdown=False

    def echo(self, args):
        """return the args"""
        if self.verbose:
            print("%s - echo: %s" % (time.asctime(), args))
        return args

    def error(self):
        """generates a simple exception (division by zero)"""
        if self.verbose:
            print("%s - error: generating exception" % time.asctime())
        return 1//0   # division by zero error

    def shutdown(self):
        """called to signal the echo server to shut down"""
        if self.verbose:
            print("%s - shutting down" % time.asctime())
        self.must_shutdown=True


class NameServer(threadutil.Thread):
    def __init__(self, hostname):
        super(NameServer, self).__init__()
        self.setDaemon(1)
        self.hostname=hostname
        self.started=threadutil.Event()

    def run(self):
        self.uri, self.ns_daemon, self.bc_server = naming.startNS(self.hostname)
        self.started.set()
        if self.bc_server:
            self.bc_server.runInThread()
        self.ns_daemon.requestLoop()


def startNameServer(host):
    ns=NameServer(host)
    ns.start()
    ns.started.wait()
    return ns


def main(args, returnWithoutLooping=False):
    from optparse import OptionParser
    parser=OptionParser()
    parser.add_option("-H", "--host", default="localhost", help="hostname to bind server on (default=localhost)")
    parser.add_option("-p", "--port", type="int", default=0, help="port to bind server on")
    parser.add_option("-u", "--unixsocket", help="Unix domain socket name to bind server on")
    parser.add_option("-n", "--naming", action="store_true", default=False, help="register with nameserver")
    parser.add_option("-N", "--nameserver", action="store_true", default=False, help="also start a nameserver")
    parser.add_option("-v", "--verbose", action="store_true", default=False, help="verbose output")
    parser.add_option("-q", "--quiet", action="store_true", default=False, help="don't output anything")
    parser.add_option("-k", "--key", help="the HMAC key to use")
    options, args = parser.parse_args(args)

    if options.verbose:
        options.quiet=False
    if not options.quiet:
        print("Starting Pyro's built-in test echo server.")
    Pyro4.config.SERVERTYPE="multiplex"

    hmac = (options.key or "").encode("utf-8")
    Pyro4.config.HMAC_KEY=hmac or Pyro4.config.HMAC_KEY
    if not options.quiet and Pyro4.config.HMAC_KEY:
        print("HMAC_KEY set to: %s" % Pyro4.config.HMAC_KEY)

    nameserver=None
    if options.nameserver:
        options.naming=True
        nameserver=startNameServer(options.host)

    d=Pyro4.Daemon(host=options.host, port=options.port, unixsocket=options.unixsocket)
    echo=EchoServer()
    echo.verbose=options.verbose
    objectName="test.echoserver"
    uri=d.register(echo, objectName)
    if options.naming:
        host, port = None, None
        if nameserver is not None:
            host, port=nameserver.uri.host, nameserver.uri.port
        ns=naming.locateNS(host, port)
        ns.register(objectName, uri)
        if options.verbose:
            print("using name server at %s" % ns._pyroUri)
            if nameserver is not None:
                if nameserver.bc_server:
                    print("broadcast server running at %s" % nameserver.bc_server.locationStr)
                else:
                    print("not using a broadcast server")
    else:
        if options.verbose:
            print("not using a name server.")
    if not options.quiet:
        print("object name: %s" % objectName)
        print("echo uri: %s" % uri)
        print("echoserver running.")

    if returnWithoutLooping:
        return d, echo, uri        # for unit testing
    else:
        d.requestLoop(loopCondition=lambda: not echo.must_shutdown)
    d.close()

if __name__=="__main__":
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = threadutil
"""
Threading abstraction which allows for :mod:`threading2` use with a
transparent fallback to :mod:`threading` when it is not available.
Pyro doesn't use :mod:`threading` directly: it imports all
thread related items via this module instead. Code using Pyro can do
the same (but it is not required).

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from Pyro4 import config

if config.THREADING2:
    try:
        from threading2 import *
    except ImportError:
        from threading import *
else:
    from threading import *

########NEW FILE########
__FILENAME__ = util
"""
Miscellaneous utilities.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys, zlib, logging
import traceback, linecache
try:
    import copyreg
except ImportError:
    import copy_reg as copyreg
import Pyro4
import Pyro4.errors
import Pyro4.message

log=logging.getLogger("Pyro4.util")


def getPyroTraceback(ex_type=None, ex_value=None, ex_tb=None):
    """Returns a list of strings that form the traceback information of a
    Pyro exception. Any remote Pyro exception information is included.
    Traceback information is automatically obtained via ``sys.exc_info()`` if
    you do not supply the objects yourself."""
    def formatRemoteTraceback(remote_tb_lines):
        result=[" +--- This exception occured remotely (Pyro) - Remote traceback:"]
        for line in remote_tb_lines:
            if line.endswith("\n"):
                line = line[:-1]
            lines = line.split("\n")
            for line in lines:
                result.append("\n | ")
                result.append(line)
        result.append("\n +--- End of remote traceback\n")
        return result
    try:
        if ex_type is not None and ex_value is None and ex_tb is None:
            # possible old (3.x) call syntax where caller is only providing exception object
            if type(ex_type) is not type:
                raise TypeError("invalid argument: ex_type should be an exception type, or just supply no arguments at all")
        if ex_type is None and ex_tb is None:
            ex_type, ex_value, ex_tb=sys.exc_info()

        remote_tb=getattr(ex_value, "_pyroTraceback", None)
        local_tb=formatTraceback(ex_type, ex_value, ex_tb, Pyro4.config.DETAILED_TRACEBACK)
        if remote_tb:
            remote_tb=formatRemoteTraceback(remote_tb)
            return local_tb + remote_tb
        else:
            # hmm. no remote tb info, return just the local tb.
            return local_tb
    finally:
        # clean up cycle to traceback, to allow proper GC
        del ex_type, ex_value, ex_tb


def formatTraceback(ex_type=None, ex_value=None, ex_tb=None, detailed=False):
    """Formats an exception traceback. If you ask for detailed formatting,
    the result will contain info on the variables in each stack frame.
    You don't have to provide the exception info objects, if you omit them,
    this function will obtain them itself using ``sys.exc_info()``."""
    if ex_type is not None and ex_value is None and ex_tb is None:
        # possible old (3.x) call syntax where caller is only providing exception object
        if type(ex_type) is not type:
            raise TypeError("invalid argument: ex_type should be an exception type, or just supply no arguments at all")
    if ex_type is None and ex_tb is None:
        ex_type, ex_value, ex_tb=sys.exc_info()
    if detailed and sys.platform!="cli":    # detailed tracebacks don't work in ironpython (most of the local vars are omitted)
        def makeStrValue(value):
            try:
                return repr(value)
            except:
                try:
                    return str(value)
                except:
                    return "<ERROR>"
        try:
            result=["-"*52+"\n"]
            result.append(" EXCEPTION %s: %s\n" % (ex_type, ex_value))
            result.append(" Extended stacktrace follows (most recent call last)\n")
            skipLocals=True  # don't print the locals of the very first stackframe
            while ex_tb:
                frame=ex_tb.tb_frame
                sourceFileName=frame.f_code.co_filename
                if "self" in frame.f_locals:
                    location="%s.%s" % (frame.f_locals["self"].__class__.__name__, frame.f_code.co_name)
                else:
                    location=frame.f_code.co_name
                result.append("-"*52+"\n")
                result.append("File \"%s\", line %d, in %s\n" % (sourceFileName, ex_tb.tb_lineno, location))
                result.append("Source code:\n")
                result.append("    "+linecache.getline(sourceFileName, ex_tb.tb_lineno).strip()+"\n")
                if not skipLocals:
                    names=set()
                    names.update(getattr(frame.f_code, "co_varnames", ()))
                    names.update(getattr(frame.f_code, "co_names", ()))
                    names.update(getattr(frame.f_code, "co_cellvars", ()))
                    names.update(getattr(frame.f_code, "co_freevars", ()))
                    result.append("Local values:\n")
                    for name in sorted(names):
                        if name in frame.f_locals:
                            value=frame.f_locals[name]
                            result.append("    %s = %s\n" % (name, makeStrValue(value)))
                            if name=="self":
                                # print the local variables of the class instance
                                for name, value in vars(value).items():
                                    result.append("        self.%s = %s\n" % (name, makeStrValue(value)))
                skipLocals=False
                ex_tb=ex_tb.tb_next
            result.append("-"*52+"\n")
            result.append(" EXCEPTION %s: %s\n" % (ex_type, ex_value))
            result.append("-"*52+"\n")
            return result
        except Exception:
            return ["-"*52+"\nError building extended traceback!!! :\n",
                    "".join(traceback.format_exception(*sys.exc_info())) + '-'*52 + '\n',
                    "Original Exception follows:\n",
                    "".join(traceback.format_exception(ex_type, ex_value, ex_tb))]
    else:
        # default traceback format.
        return traceback.format_exception(ex_type, ex_value, ex_tb)


all_exceptions = {}
if sys.version_info < (3, 0):
    import exceptions
    for name, t in vars(exceptions).items():
        if type(t) is type and issubclass(t, BaseException):
            all_exceptions[name] = t
else:
    import builtins
    for name, t in vars(builtins).items():
        if type(t) is type and issubclass(t, BaseException):
            all_exceptions[name] = t
for name, t in vars(Pyro4.errors).items():
    if type(t) is type and issubclass(t, Pyro4.errors.PyroError):
        all_exceptions[name] = t


class SerializerBase(object):
    """Base class for (de)serializer implementations (which must be thread safe)"""
    __custom_class_to_dict_registry = {}
    __custom_dict_to_class_registry = {}

    def serializeData(self, data, compress=False):
        """Serialize the given data object, try to compress if told so.
        Returns a tuple of the serialized data (bytes) and a bool indicating if it is compressed or not."""
        data=self.dumps(data)
        return self.__compressdata(data, compress)

    def deserializeData(self, data, compressed=False):
        """Deserializes the given data (bytes). Set compressed to True to decompress the data first."""
        if compressed:
            data=zlib.decompress(data)
        return self.loads(data)

    def serializeCall(self, obj, method, vargs, kwargs, compress=False):
        """Serialize the given method call parameters, try to compress if told so.
        Returns a tuple of the serialized data and a bool indicating if it is compressed or not."""
        data=self.dumpsCall(obj, method, vargs, kwargs)
        return self.__compressdata(data, compress)

    def deserializeCall(self, data, compressed=False):
        """Deserializes the given call data back to (object, method, vargs, kwargs) tuple.
        Set compressed to True to decompress the data first."""
        if compressed:
            data=zlib.decompress(data)
        return self.loadsCall(data)

    def loads(self, data):
        raise NotImplementedError("implement in subclass")

    def loadsCall(self, data):
        raise NotImplementedError("implement in subclass")

    def dumps(self, data):
        raise NotImplementedError("implement in subclass")

    def dumpsCall(self, obj, method, vargs, kwargs):
        raise NotImplementedError("implement in subclass")

    def __compressdata(self, data, compress):
        if not compress or len(data)<200:
            return data, False  # don't waste time compressing small messages
        compressed=zlib.compress(data)
        if len(compressed)<len(data):
            return compressed, True
        return data, False

    @classmethod
    def register_type_replacement(cls, object_type, replacement_function):
        raise NotImplementedError("implement in subclass")

    @classmethod
    def register_class_to_dict(cls, clazz, converter, serpent_too=True):
        """Registers a custom function that returns a dict representation of objects of the given class.
        The function is called with a single parameter; the object to be converted to a dict."""
        cls.__custom_class_to_dict_registry[clazz] = converter
        if serpent_too:
            try:
                get_serializer_by_id(SerpentSerializer.serializer_id)
                import serpent
                def serpent_converter(obj, serializer, stream, level):
                    d = converter(obj)
                    serializer.ser_builtins_dict(d, stream, level)
                serpent.register_class(clazz, serpent_converter)
            except Pyro4.errors.ProtocolError:
                pass

    @classmethod
    def unregister_class_to_dict(cls, clazz):
        """Removes the to-dict conversion function registered for the given class. Objects of the class
        will be serialized by the default mechanism again."""
        if clazz in cls.__custom_class_to_dict_registry:
            del cls.__custom_class_to_dict_registry[clazz]
        try:
            get_serializer_by_id(SerpentSerializer.serializer_id)
            import serpent
            serpent.unregister_class(clazz)
        except Pyro4.errors.ProtocolError:
            pass

    @classmethod
    def register_dict_to_class(cls, classname, converter):
        """Registers a custom converter function that creates objects from a dict with the given classname tag in it.
        The function is called with two parameters: the classname and the dictionary to convert to an instance of the class."""
        cls.__custom_dict_to_class_registry[classname] = converter

    @classmethod
    def unregister_dict_to_class(cls, classname):
        """Removes the converter registered for the given classname. Dicts with that classname tag
        will be deserialized by the default mechanism again."""
        if classname in cls.__custom_dict_to_class_registry:
            del cls.__custom_dict_to_class_registry[classname]

    @classmethod
    def class_to_dict(cls, obj):
        """Convert a non-serializable object to a dict. Mostly borrowed from serpent."""
        for clazz in cls.__custom_class_to_dict_registry:
            if isinstance(obj, clazz):
                return cls.__custom_class_to_dict_registry[clazz](obj)
        if type(obj) in (set, dict, tuple, list):
            raise Pyro4.errors.ProtocolError("couldn't serialize sequence " + str(obj.__class__) + ", one of its elements is unserializable")
        if hasattr(obj, "_pyroDaemon"):
            obj._pyroDaemon = None
        if isinstance(obj, BaseException):
            # special case for exceptions
            value={"args": obj.args}
            value["__class__"] = obj.__class__.__module__ + "." + obj.__class__.__name__
            value["attributes"] = vars(obj)  # add custom exception attributes
            return value
        try:
            value = obj.__getstate__()
        except AttributeError:
            pass
        else:
            if isinstance(value, dict):
                return value
        try:
            value = dict(vars(obj))  # make sure we can serialize anything that resembles a dict
            value["__class__"] = obj.__class__.__module__ + "." + obj.__class__.__name__
            return value
        except TypeError:
            if hasattr(obj, "__slots__"):
                # use the __slots__ instead of the vars dict
                value = {}
                for slot in obj.__slots__:
                    value[slot] = getattr(obj, slot)
                value["__class__"] = obj.__class__.__module__ + "." + obj.__class__.__name__
                return value
            else:
                raise Pyro4.errors.ProtocolError("don't know how to serialize class " + str(obj.__class__) + ". Give it vars() or an appropriate __getstate__")

    @classmethod
    def dict_to_class(cls, data):
        """
        Recreate an object out of a dict containing the class name and the attributes.
        Only a fixed set of classes are recognized.
        """
        classname = data.get("__class__", "<unknown>")
        if classname in cls.__custom_dict_to_class_registry:
            converter = cls.__custom_dict_to_class_registry[classname]
            return converter(classname, data)
        if "__" in classname:
            raise Pyro4.errors.SecurityError("refused to deserialize types with double underscores in their name: "+classname)
        # because of efficiency reasons the constructors below are hardcoded here instead of added on a per-class basis to the dict-to-class registry
        if classname.startswith("Pyro4.core."):
            if classname == "Pyro4.core.URI":
                uri = Pyro4.core.URI.__new__(Pyro4.core.URI)
                uri.__setstate_from_dict__(data["state"])
                return uri
            elif classname == "Pyro4.core.Proxy":
                proxy = Pyro4.core.Proxy.__new__(Pyro4.core.Proxy)
                proxy.__setstate_from_dict__(data["state"])
                return proxy
            elif classname == "Pyro4.core.Daemon":
                daemon = Pyro4.core.Daemon.__new__(Pyro4.core.Daemon)
                daemon.__setstate_from_dict__(data["state"])
                return daemon
        elif classname.startswith("Pyro4.util."):
            if classname == "Pyro4.util.PickleSerializer":
                return PickleSerializer()
            elif classname == "Pyro4.util.MarshalSerializer":
                return MarshalSerializer()
            elif classname == "Pyro4.util.JsonSerializer":
                return JsonSerializer()
            elif classname == "Pyro4.util.SerpentSerializer":
                return SerpentSerializer()
        elif classname.startswith("Pyro4.errors."):
            errortype = getattr(Pyro4.errors, classname.split('.', 2)[2])
            if issubclass(errortype, Pyro4.errors.PyroError):
                return SerializerBase.make_exception(errortype, data)
        elif classname == "Pyro4.futures._ExceptionWrapper":
            ex = SerializerBase.dict_to_class(data["exception"])
            return Pyro4.futures._ExceptionWrapper(ex)
        elif classname.startswith("builtins."):
            exceptiontype = getattr(builtins, classname.split('.', 1)[1])
            if issubclass(exceptiontype, BaseException):
                return SerializerBase.make_exception(exceptiontype, data)
        elif classname.startswith("exceptions."):
            exceptiontype = getattr(exceptions, classname.split('.', 1)[1])
            if issubclass(exceptiontype, BaseException):
                return SerializerBase.make_exception(exceptiontype, data)
        elif classname in all_exceptions:
            return SerializerBase.make_exception(all_exceptions[classname], data)
        # try one of the serializer classes
        for serializer in _serializers.values():
            if classname == serializer.__class__.__name__:
                return serializer
        raise Pyro4.errors.ProtocolError("unsupported serialized class: "+classname)

    @staticmethod
    def make_exception(exceptiontype, data):
        ex = exceptiontype(*data["args"])
        if "attributes" in data:
            # restore custom attributes on the exception object
            for attr, value in data["attributes"].items():
                setattr(ex, attr, value)
        return ex

    def recreate_classes(self, literal):
        t = type(literal)
        if t is set:
            return set([self.recreate_classes(x) for x in literal])
        if t is list:
            return [self.recreate_classes(x) for x in literal]
        if t is tuple:
            return tuple(self.recreate_classes(x) for x in literal)
        if t is dict:
            if "__class__" in literal:
                return self.dict_to_class(literal)
            result = {}
            for key, value in literal.items():
                result[key] = self.recreate_classes(value)
            return result
        return literal

    def __eq__(self, other):
        """this equality method is only to support the unit tests of this class"""
        return isinstance(other, SerializerBase) and vars(self)==vars(other)

    def __ne__(self, other):
        return not self.__eq__(other)
    __hash__=object.__hash__


class PickleSerializer(SerializerBase):
    """
    A (de)serializer that wraps the Pickle serialization protocol.
    It can optionally compress the serialized data, and is thread safe.
    """
    serializer_id = Pyro4.message.SERIALIZER_PICKLE

    def dumpsCall(self, obj, method, vargs, kwargs):
        return pickle.dumps((obj, method, vargs, kwargs), Pyro4.config.PICKLE_PROTOCOL_VERSION)

    def dumps(self, data):
        return pickle.dumps(data, Pyro4.config.PICKLE_PROTOCOL_VERSION)

    def loadsCall(self, data):
        return pickle.loads(data)

    def loads(self, data):
        return pickle.loads(data)

    @classmethod
    def register_type_replacement(cls, object_type, replacement_function):
        def copyreg_function(obj):
            return replacement_function(obj).__reduce__()
        try:
            copyreg.pickle(object_type, copyreg_function)
        except TypeError:
            pass


class MarshalSerializer(SerializerBase):
    """(de)serializer that wraps the marshal serialization protocol."""
    serializer_id = Pyro4.message.SERIALIZER_MARSHAL

    def dumpsCall(self, obj, method, vargs, kwargs):
        return marshal.dumps((obj, method, vargs, kwargs))

    def dumps(self, data):
        try:
            return marshal.dumps(data)
        except (ValueError, TypeError):
            return marshal.dumps(self.class_to_dict(data))

    def loadsCall(self, data):
        obj, method, vargs, kwargs = marshal.loads(data)
        vargs = self.recreate_classes(vargs)
        kwargs = self.recreate_classes(kwargs)
        return obj, method, vargs, kwargs

    def loads(self, data):
        return self.recreate_classes(marshal.loads(data))

    @classmethod
    def register_type_replacement(cls, object_type, replacement_function):
        pass    # marshal serializer doesn't support per-type hooks


class SerpentSerializer(SerializerBase):
    """(de)serializer that wraps the serpent serialization protocol."""
    serializer_id = Pyro4.message.SERIALIZER_SERPENT

    def dumpsCall(self, obj, method, vargs, kwargs):
        return serpent.dumps((obj, method, vargs, kwargs), module_in_classname=True)

    def dumps(self, data):
        return serpent.dumps(data, module_in_classname=True)

    def loadsCall(self, data):
        obj, method, vargs, kwargs = serpent.loads(data)
        vargs = self.recreate_classes(vargs)
        kwargs = self.recreate_classes(kwargs)
        return obj, method, vargs, kwargs

    def loads(self, data):
        return self.recreate_classes(serpent.loads(data))

    @classmethod
    def register_type_replacement(cls, object_type, replacement_function):
        def custom_serializer(object, serpent_serializer, outputstream, indentlevel):
            replaced = replacement_function(object)
            if replaced is object:
                serpent_serializer.ser_default_class(replaced, outputstream, indentlevel)
            else:
                serpent_serializer._serialize(replaced, outputstream, indentlevel)
        serpent.register_class(object_type, custom_serializer)


class JsonSerializer(SerializerBase):
    """(de)serializer that wraps the json serialization protocol."""
    serializer_id = Pyro4.message.SERIALIZER_JSON

    __type_replacements = {}
    def dumpsCall(self, obj, method, vargs, kwargs):
        data = {"object": obj, "method": method, "params": vargs, "kwargs": kwargs}
        data = json.dumps(data, ensure_ascii=False, default=self.default)
        return data.encode("utf-8")
    def dumps(self, data):
        data = json.dumps(data, ensure_ascii=False, default=self.default)
        return data.encode("utf-8")
    def loadsCall(self, data):
        data=data.decode("utf-8")
        data = json.loads(data)
        vargs = self.recreate_classes(data["params"])
        kwargs = self.recreate_classes(data["kwargs"])
        return data["object"], data["method"], vargs, kwargs
    def loads(self, data):
        data=data.decode("utf-8")
        return self.recreate_classes(json.loads(data))
    def default(self, obj):
        replacer = self.__type_replacements.get(type(obj), None)
        if replacer:
            obj = replacer(obj)
        return self.class_to_dict(obj)
    @classmethod
    def register_type_replacement(cls, object_type, replacement_function):
        cls.__type_replacements[object_type] = replacement_function


"""The various serializers that are supported"""
_serializers = {}
_serializers_by_id = {}
def get_serializer(name):
    try:
        return _serializers[name]
    except KeyError:
        raise Pyro4.errors.ProtocolError("serializer '%s' is unknown or not available" % name)

def get_serializer_by_id(sid):
    try:
        return _serializers_by_id[sid]
    except KeyError:
        raise Pyro4.errors.ProtocolError("no serializer available for id %d" % sid)

# determine the serializers that are supported
try:
    import cPickle as pickle
except ImportError:
    import pickle
assert Pyro4.config.PICKLE_PROTOCOL_VERSION>=2, "pickle protocol needs to be 2 or higher"
_ser = PickleSerializer()
_serializers["pickle"] = _ser
_serializers_by_id[_ser.serializer_id] = _ser
import marshal
_ser = MarshalSerializer()
_serializers["marshal"] = _ser
_serializers_by_id[_ser.serializer_id] = _ser
try:
    import json
    _ser = JsonSerializer()
    _serializers["json"] = _ser
    _serializers_by_id[_ser.serializer_id] = _ser
except ImportError:
    pass
try:
    import serpent
    if '-' in serpent.__version__:
        ver = serpent.__version__.split('-', 1)[0]
    else:
        ver = serpent.__version__
    ver = tuple(map(int, ver.split(".")))
    if ver<(1, 5):
        raise RuntimeError("requires serpent 1.5 or better")
    _ser = SerpentSerializer()
    _serializers["serpent"] = _ser
    _serializers_by_id[_ser.serializer_id] = _ser
except ImportError:
    # warnings.warn("serpent serializer not available", RuntimeWarning)
    pass
del _ser


def resolveDottedAttribute(obj, attr, allowDotted):
    """
    Resolves a dotted attribute name to an object.  Raises
    an AttributeError if any attribute in the chain starts with a '``_``'.
    If the optional allowDotted argument is false, dots are not
    supported and this function operates similar to ``getattr(obj, attr)``.
    """
    if allowDotted:
        attrs = attr.split('.')
        for i in attrs:
            if i.startswith('_'):
                raise AttributeError('attempt to access private attribute "%s"' % i)
            else:
                obj = getattr(obj, i)
        return obj
    else:
        return getattr(obj, attr)


def excepthook(ex_type, ex_value, ex_tb):
    """An exception hook you can use for ``sys.excepthook``, to automatically print remote Pyro tracebacks"""
    traceback = "".join(getPyroTraceback(ex_type, ex_value, ex_tb))
    sys.stderr.write(traceback)


def fixIronPythonExceptionForPickle(exceptionObject, addAttributes):
    """
    Function to hack around a bug in IronPython where it doesn't pickle
    exception attributes. We piggyback them into the exception's args.
    Bug report is at http://ironpython.codeplex.com/workitem/30805
    """
    if hasattr(exceptionObject, "args"):
        if addAttributes:
            # piggyback the attributes on the exception args instead.
            ironpythonArgs = vars(exceptionObject)
            ironpythonArgs["__ironpythonargs__"] = True
            exceptionObject.args += (ironpythonArgs,)
        else:
            # check if there is a piggybacked object in the args
            # if there is, extract the exception attributes from it.
            if len(exceptionObject.args) > 0:
                piggyback = exceptionObject.args[-1]
                if type(piggyback) is dict and piggyback.get("__ironpythonargs__"):
                    del piggyback["__ironpythonargs__"]
                    exceptionObject.args = exceptionObject.args[:-1]
                    exceptionObject.__dict__.update(piggyback)

########NEW FILE########
__FILENAME__ = flame
"""
Pyro FLAME:  Foreign Location Automatic Module Exposer.
Easy but potentially very dangerous way of exposing remote modules and builtins.
Flame requires the pickle serializer to be used.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys
import types
import code
import Pyro4.core
import Pyro4.util
import Pyro4.constants
import Pyro4.errors
try:
    import importlib
except ImportError:
    importlib = None
try:
    import builtins
except ImportError:
    import __builtin__ as builtins
try:
    from cStringIO import StringIO
except ImportError:
    from io import StringIO

__all__ = ["connect", "start", "createModule", "Flame"]


# Exec is a statement in Py2, a function in Py3
# Workaround as written by Ned Batchelder on his blog.
if sys.version_info > (3, 0):
    def exec_function(source, filename, global_map):
        source=fixExecSourceNewlines(source)
        exec(compile(source, filename, "exec"), global_map)
else:
    # OK, this is pretty gross.  In Py2, exec was a statement, but that will
    # be a syntax error if we try to put it in a Py3 file, even if it isn't
    # executed.  So hide it inside an evaluated string literal instead.
    eval(compile("""\
def exec_function(source, filename, global_map):
    source=fixExecSourceNewlines(source)
    exec compile(source, filename, "exec") in global_map
""",
    "<exec_function>", "exec"
    ))


def fixExecSourceNewlines(source):
    if sys.version_info < (2, 7) or sys.version_info[:2] in ((3, 0), (3, 1)):
        # for python versions prior to 2.7 (and 3.0/3.1), compile is kinda picky.
        # it needs unix type newlines and a trailing newline to work correctly.
        source = source.replace("\r\n", "\n")
        source = source.rstrip() + "\n"
    # remove trailing whitespace that might cause IndentationErrors
    source = source.rstrip()
    return source


class FlameModule(object):
    """Proxy to a remote module."""
    def __init__(self, flameserver, module):
        # store a proxy to the flameserver regardless of autoproxy setting
        self.flameserver = Pyro4.core.Proxy(flameserver._pyroDaemon.uriFor(flameserver))
        self.module = module

    def __getattr__(self, item):
        if item in ("__getnewargs__", "__getnewargs_ex__", "__getinitargs__"):
            raise AttributeError(item)
        return Pyro4.core._RemoteMethod(self.__invoke, "%s.%s" % (self.module, item))

    def __getstate__(self):
        return self.__dict__

    def __setstate__(self, args):
        self.__dict__ = args

    def __invoke(self, module, args, kwargs):
        return self.flameserver._invokeModule(module, args, kwargs)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.flameserver._pyroRelease()

    def __repr__(self):
        return "<%s.%s at 0x%x, module '%s' at %s>" % (self.__class__.__module__, self.__class__.__name__,
            id(self), self.module, self.flameserver._pyroUri.location)


class FlameBuiltin(object):
    """Proxy to a remote builtin function."""
    def __init__(self, flameserver, builtin):
        # store a proxy to the flameserver regardless of autoproxy setting
        self.flameserver = Pyro4.core.Proxy(flameserver._pyroDaemon.uriFor(flameserver))
        self.builtin = builtin

    def __call__(self, *args, **kwargs):
        return self.flameserver._invokeBuiltin(self.builtin, args, kwargs)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.flameserver._pyroRelease()

    def __repr__(self):
        return "<%s.%s at 0x%x, builtin '%s' at %s>" % (self.__class__.__module__, self.__class__.__name__,
            id(self), self.builtin, self.flameserver._pyroUri.location)


class RemoteInteractiveConsole(object):
    """Proxy to a remote interactive console."""

    class LineSendingConsole(code.InteractiveConsole):
        """makes sure the lines are sent to the remote console"""
        def __init__(self, remoteconsole):
            code.InteractiveConsole.__init__(self, filename="<remoteconsole>")
            self.remoteconsole = remoteconsole

        def push(self, line):
            output, more = self.remoteconsole.push_and_get_output(line)
            if output:
                sys.stdout.write(output)
            return more

    def __init__(self, remoteconsoleuri):
        # store a proxy to the console regardless of autoproxy setting
        self.remoteconsole = Pyro4.core.Proxy(remoteconsoleuri)

    def interact(self):
        console = self.LineSendingConsole(self.remoteconsole)
        console.interact(banner=self.remoteconsole.get_banner())
        print("(Remote session ended)")

    def close(self):
        self.remoteconsole.terminate()
        self.remoteconsole._pyroRelease()

    def __repr__(self):
        return "<%s.%s at 0x%x, for %s>" % (self.__class__.__module__, self.__class__.__name__,
            id(self), self.remoteconsole._pyroUri.location)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()


class InteractiveConsole(code.InteractiveConsole):
    """Interactive console wrapper that saves output written to stdout so it can be returned as value"""
    def push_and_get_output(self, line):
        output, more = "", False
        stdout_save = sys.stdout
        try:
            sys.stdout = StringIO()
            more = self.push(line)
            output = sys.stdout.getvalue()
            sys.stdout.close()
        finally:
            sys.stdout = stdout_save
        return output, more

    def get_banner(self):
        return self.banner          # custom banner string, set by Pyro daemon

    def write(self, data):
        sys.stdout.write(data)      # stdout instead of stderr

    def terminate(self):
        self._pyroDaemon.unregister(self)
        self.resetbuffer()


class Flame(object):
    """
    The actual FLAME server logic.
    Usually created by using :py:meth:`Pyro4.core.Daemon.startFlame`.
    Be *very* cautious before starting this: it allows the clients full access to everything on your system.
    """
    def __init__(self):
        if "pickle" not in Pyro4.config.SERIALIZERS_ACCEPTED:
            raise RuntimeError("flame requires the pickle serializer to be enabled")

    def module(self, name):
        """import a module on the server given by the module name and returns a proxy to it"""
        if importlib:
            importlib.import_module(name)
        else:
            __import__(name)
        return FlameModule(self, name)

    def builtin(self, name):
        """returns a proxy to the given builtin on the server"""
        return FlameBuiltin(self, name)

    def execute(self, code):
        """execute a piece of code"""
        exec_function(code, "<remote-code>", globals())

    def evaluate(self, expression):
        """evaluate an expression and return its result"""
        return eval(expression)

    def sendmodule(self, modulename, modulesource):
        """
        Send the source of a module to the server and make the server load it.
        Note that you still have to actually ``import`` it on the server to access it.
        Sending a module again will replace the previous one with the new.
        """
        createModule(modulename, modulesource)

    def getmodule(self, modulename):
        """obtain the source code from a module on the server"""
        import inspect
        module = __import__(modulename, globals={}, locals={})
        return inspect.getsource(module)

    def sendfile(self, filename, filedata):
        """store a new file on the server"""
        import os, stat
        with open(filename, "wb") as targetfile:
            os.chmod(filename, stat.S_IRUSR | stat.S_IWUSR)    # readable/writable by owner only
            targetfile.write(filedata)

    def getfile(self, filename):
        """read any accessible file from the server"""
        with open(filename, "rb") as file:
            return file.read()

    def console(self):
        """get a proxy for a remote interactive console session"""
        console = InteractiveConsole(filename="<remoteconsole>")
        uri = self._pyroDaemon.register(console)
        console.banner = "Python %s on %s\n(Remote console on %s)" % (sys.version, sys.platform, uri.location)
        return RemoteInteractiveConsole(uri)

    def _invokeBuiltin(self, builtin, args, kwargs):
        return getattr(builtins, builtin)(*args, **kwargs)

    def _invokeModule(self, dottedname, args, kwargs):
        # dottedname is something like "os.path.walk" so strip off the module name
        modulename, dottedname = dottedname.split('.', 1)
        module = sys.modules[modulename]
        # we override the DOTTEDNAMES setting here because this safeguard makes no sense
        # with the Flame server (if enabled it already allows full access to anything):
        method = Pyro4.util.resolveDottedAttribute(module, dottedname, True)
        return method(*args, **kwargs)


def createModule(name, source, filename="<dynamic-module>", namespace=None):
    """
    Utility function to create a new module with the given name (dotted notation allowed), directly from the source string.
    Adds it to sys.modules, and returns the new module object.
    If you provide a namespace dict (such as ``globals()``), it will import the module into that namespace too.
    """
    path = ""
    components = name.split('.')
    module = types.ModuleType("pyro-flame-module-context")
    for component in components:
        # build the module hierarchy.
        path += '.' + component
        real_path = path[1:]
        if real_path in sys.modules:
            # use already loaded modules instead of overwriting them
            module = sys.modules[real_path]
        else:
            setattr(module, component, types.ModuleType(real_path))
            module = getattr(module, component)
            sys.modules[real_path] = module
    exec_function(source, filename, module.__dict__)
    if namespace is not None:
        namespace[components[0]] = __import__(name)
    return module


def start(daemon):
    """
    Create and register a Flame server in the given daemon.
    Be *very* cautious before starting this: it allows the clients full access to everything on your system.
    """
    if Pyro4.config.FLAME_ENABLED:
        return daemon.register(Flame(), Pyro4.constants.FLAME_NAME)
    else:
        raise Pyro4.errors.SecurityError("Flame is disabled in the server configuration")


def connect(location):
    """
    Connect to a Flame server on the given location, for instance localhost:9999 or ./u:unixsock
    This is just a convenience function to creates an appropriate Pyro proxy.
    """
    proxy = Pyro4.core.Proxy("PYRO:%s@%s" % (Pyro4.constants.FLAME_NAME, location))
    proxy._pyroBind()
    return proxy

########NEW FILE########
__FILENAME__ = flameserver
"""
Pyro FLAME:  Foreign Location Automatic Module Exposer.
Easy but potentially very dangerous way of exposing remote modules and builtins.
This is the commandline server.

You can start this module as a script from the command line, to easily get a
flame server running:

  :command:`python -m Pyro4.utils.flameserver`

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys
import Pyro4.utils.flame
import Pyro4.core


def main(args, returnWithoutLooping=False):
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-H", "--host", default="localhost", help="hostname to bind server on (default=localhost)")
    parser.add_option("-p", "--port", type="int", default=0, help="port to bind server on")
    parser.add_option("-u", "--unixsocket", help="Unix domain socket name to bind server on")
    parser.add_option("-q", "--quiet", action="store_true", default=False, help="don't output anything")
    parser.add_option("-k", "--key", help="the HMAC key to use")
    options, args = parser.parse_args(args)

    if not options.quiet:
        print("Starting Pyro Flame server.")

    hmac = (options.key or "").encode("utf-8")
    if not hmac:
        print("Warning: HMAC key not set. Anyone can connect to this server!")
    Pyro4.config.HMAC_KEY = hmac or Pyro4.config.HMAC_KEY
    if not options.quiet and Pyro4.config.HMAC_KEY:
        print("HMAC_KEY set to: %s" % Pyro4.config.HMAC_KEY)

    Pyro4.config.SERIALIZERS_ACCEPTED = set(["pickle"])   # flame requires pickle serializer

    daemon = Pyro4.core.Daemon(host=options.host, port=options.port, unixsocket=options.unixsocket)
    uri = Pyro4.utils.flame.start(daemon)
    if not options.quiet:
        print("server uri: %s" % uri)
        print("server is running.")

    if returnWithoutLooping:
        return daemon, uri        # for unit testing
    else:
        daemon.requestLoop()
    daemon.close()
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))

########NEW FILE########
__FILENAME__ = testsupport
"""
Support code for the test suite.
There's some Python 2.x <-> 3.x compatibility code here.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys
import threading
import pickle


__all__=["tobytes", "tostring", "unicode", "unichr", "basestring", "StringIO", "next",
         "AtomicCounter", "NonserializableError", "MyThing2", "unittest" ]

if sys.version_info<(3,0):
    from StringIO import StringIO
    def tobytes(string, encoding=None):
        return string
    def tostring(bytes):
        return bytes
    unicode=unicode
    unichr=unichr
    basestring=basestring
else:
    from io import StringIO
    def tobytes(string, encoding="iso-8859-1"):
        return bytes(string,encoding)
    def tostring(bytes, encoding="utf-8"):
        return str(bytes, encoding)
    unicode=str
    unichr=chr
    basestring=str


if sys.version_info<(2,6):
    def next(iterable):
        return iterable.next()
else:
    next=next


if (sys.version_info >= (2, 7) and sys.version_info < (3, 0)) or \
        (sys.version_info >= (3, 1)):
    import unittest
else:
    import unittest2 as unittest


class AtomicCounter(object):
    def __init__(self):
        self.lock = threading.Lock()
        self.count = 0
    def reset(self):
        self.count = 0
    def incr(self):
        with self.lock:
            self.count += 1
    def value(self):
        with self.lock:
            return self.count


class NonserializableError(Exception):
    def __reduce__(self):
        raise pickle.PicklingError("to make this error non-serializable")


class MyThing2(object):
    def __init__(self, name="?"):
        self.name = name



########NEW FILE########
__FILENAME__ = test_core
"""
Tests for the core logic.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import copy
import logging
import os, sys, time
import warnings
import Pyro4.configuration
import Pyro4.core
import Pyro4.errors
import Pyro4.constants
import Pyro4.futures
from testsupport import *


if sys.version_info>=(3,0):
    import imp
    reload=imp.reload

class Thing(object):
    def __init__(self, arg):
        self.arg=arg
    def __eq__(self,other):
        return self.arg==other.arg
    __hash__=object.__hash__


class CoreTestsWithoutHmac(unittest.TestCase):
    def setUp(self):
        warnings.simplefilter("ignore")
        Pyro4.config.reset()
    def testProxy(self):
        Pyro4.config.HMAC_KEY=None
        # check that proxy without hmac is possible
        _=Pyro4.Proxy("PYRO:object@host:9999")
    def testDaemon(self):
        Pyro4.config.HMAC_KEY=None
        # check that daemon without hmac is possible
        d=Pyro4.Daemon()
        d.shutdown()


class CoreTests(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY = b"testsuite"
    def tearDown(self):
        Pyro4.config.HMAC_KEY = None

    def testConfig(self):
        self.assertTrue(type(Pyro4.config.COMPRESSION) is bool)
        self.assertTrue(type(Pyro4.config.NS_PORT) is int)
        config=Pyro4.config.asDict()
        self.assertTrue(type(config) is dict)
        self.assertTrue("COMPRESSION" in config)
        self.assertEqual(Pyro4.config.COMPRESSION, config["COMPRESSION"])

    def testConfigValid(self):
        try:
            Pyro4.config.XYZ_FOOBAR=True  # don't want to allow weird config names
            self.fail("expected exception for weird config item")
        except AttributeError:
            pass

    def testConfigParseBool(self):
        config=Pyro4.configuration.Configuration()
        self.assertTrue(type(config.COMPRESSION) is bool)
        os.environ["PYRO_COMPRESSION"]="yes"
        config.reset()
        self.assertTrue(config.COMPRESSION)
        os.environ["PYRO_COMPRESSION"]="off"
        config.reset()
        self.assertFalse(config.COMPRESSION)
        os.environ["PYRO_COMPRESSION"]="foobar"
        self.assertRaises(ValueError, config.reset)
        del os.environ["PYRO_COMPRESSION"]
        config.reset()

    def testConfigDump(self):
        config=Pyro4.configuration.Configuration()
        dump=config.dump()
        self.assertTrue("version:" in dump)
        self.assertTrue("LOGLEVEL" in dump)

    def testLogInit(self):
        _=logging.getLogger("Pyro4")
        os.environ["PYRO_LOGLEVEL"]="DEBUG"
        os.environ["PYRO_LOGFILE"]="{stderr}"
        reload(Pyro4)
        _=logging.getLogger("Pyro4")
        del os.environ["PYRO_LOGLEVEL"]
        del os.environ["PYRO_LOGFILE"]
        reload(Pyro4)

    def testUriStrAndRepr(self):
        uri="PYRONAME:some_obj_name"
        p=Pyro4.core.URI(uri)
        self.assertEqual(uri,str(p))
        uri="PYRONAME:some_obj_name@host.com"
        p=Pyro4.core.URI(uri)
        self.assertEqual(uri+":"+str(Pyro4.config.NS_PORT),str(p))   # a PYRONAME uri with a hostname gets a port too if omitted
        uri="PYRONAME:some_obj_name@host.com:8888"
        p=Pyro4.core.URI(uri)
        self.assertEqual(uri,str(p))
        expected="<Pyro4.core.URI at 0x%x, PYRONAME:some_obj_name@host.com:8888>" % id(p)
        self.assertEqual(expected, repr(p))
        uri="PYRO:12345@host.com:9999"
        p=Pyro4.core.URI(uri)
        self.assertEqual(uri,str(p))
        self.assertEqual(uri,p.asString())
        uri="PYRO:12345@./u:sockname"
        p=Pyro4.core.URI(uri)
        self.assertEqual(uri,str(p))
        uri="PYRO:12345@./u:sockname"
        unicodeuri=unicode(uri)
        p=Pyro4.core.URI(unicodeuri)
        self.assertEqual(uri,str(p))
        self.assertEqual(unicodeuri,unicode(p))
        self.assertTrue(type(p.sockname) is unicode)

    def testUriParsingPyro(self):
        p=Pyro4.core.URI("PYRONAME:some_obj_name")
        self.assertEqual("PYRONAME",p.protocol)
        self.assertEqual("some_obj_name",p.object)
        self.assertEqual(None,p.host)
        self.assertEqual(None,p.sockname)
        self.assertEqual(None,p.port)
        p=Pyro4.core.URI("PYRONAME:some_obj_name@host.com:9999")
        self.assertEqual("PYRONAME",p.protocol)
        self.assertEqual("some_obj_name",p.object)
        self.assertEqual("host.com",p.host)
        self.assertEqual(9999,p.port)

        p=Pyro4.core.URI("PYRO:12345@host.com:4444")
        self.assertEqual("PYRO",p.protocol)
        self.assertEqual("12345",p.object)
        self.assertEqual("host.com",p.host)
        self.assertEqual(None,p.sockname)
        self.assertEqual(4444,p.port)
        p=Pyro4.core.URI("PYRO:12345@./u:sockname")
        self.assertEqual("12345",p.object)
        self.assertEqual("sockname",p.sockname)
        p=Pyro4.core.URI("PYRO:12345@./u:/tmp/sockname")
        self.assertEqual("12345",p.object)
        self.assertEqual("/tmp/sockname",p.sockname)
        p=Pyro4.core.URI("PYRO:12345@./u:../sockname")
        self.assertEqual("12345",p.object)
        self.assertEqual("../sockname",p.sockname)
        p=Pyro4.core.URI("pyro:12345@host.com:4444")
        self.assertEqual("PYRO",p.protocol)
        self.assertEqual("12345",p.object)
        self.assertEqual("host.com",p.host)
        self.assertEqual(None,p.sockname)
        self.assertEqual(4444,p.port)

    def testUriParsingPyroname(self):
        p=Pyro4.core.URI("PYRONAME:objectname")
        self.assertEqual("PYRONAME",p.protocol)
        self.assertEqual("objectname",p.object)
        self.assertEqual(None,p.host)
        self.assertEqual(None,p.port)
        p=Pyro4.core.URI("PYRONAME:objectname@nameserverhost")
        self.assertEqual("PYRONAME",p.protocol)
        self.assertEqual("objectname",p.object)
        self.assertEqual("nameserverhost",p.host)
        self.assertEqual(Pyro4.config.NS_PORT,p.port)   # Pyroname uri with host gets a port too if not specified
        p=Pyro4.core.URI("PYRONAME:objectname@nameserverhost:4444")
        self.assertEqual("PYRONAME",p.protocol)
        self.assertEqual("objectname",p.object)
        self.assertEqual("nameserverhost",p.host)
        self.assertEqual(4444,p.port)
        p=Pyro4.core.URI("PyroName:some_obj_name@host.com:9999")
        self.assertEqual("PYRONAME",p.protocol)
        p=Pyro4.core.URI("pyroname:some_obj_name@host.com:9999")
        self.assertEqual("PYRONAME",p.protocol)

    def testInvalidUris(self):
        self.assertRaises(TypeError, Pyro4.core.URI, None)
        self.assertRaises(TypeError, Pyro4.core.URI, 99999)
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "a")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYR")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO::")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:a")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:x@")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:x@hostname")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:@hostname:portstr")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:@hostname:7766")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:objid@hostname:7766:bogus")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYROLOC:objname")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYROLOC:objname@host")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYROLOC:objectname@hostname:4444")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRONAME:")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRONAME:objname@nameserver:bogus")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRONAME:objname@nameserver:7766:bogus")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "FOOBAR:")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "FOOBAR:objid@hostname:7766")
        self.assertRaises(Pyro4.errors.PyroError, Pyro4.core.URI, "PYRO:12345@./u:sockname:9999")

    def testUriUnicode(self):
        p=Pyro4.core.URI(unicode("PYRO:12345@host.com:4444")) 
        self.assertEqual("PYRO",p.protocol)
        self.assertEqual("12345",p.object)
        self.assertEqual("host.com",p.host)
        self.assertTrue(type(p.protocol) is unicode)
        self.assertTrue(type(p.object) is unicode)
        self.assertTrue(type(p.host) is unicode)
        self.assertEqual(None,p.sockname)
        self.assertEqual(4444,p.port)

        uri="PYRO:12345@hostname:9999"
        p=Pyro4.core.URI(uri)
        pu=Pyro4.core.URI(unicode(uri))
        self.assertEqual("PYRO",pu.protocol)
        self.assertEqual("hostname",pu.host)
        self.assertEqual(p,pu)
        self.assertEqual(str(p), str(pu))
        unicodeuri="PYRO:weirdchars"+unichr(0x20ac)+"@host"+unichr(0x20AC)+".com:4444"
        pu=Pyro4.core.URI(unicodeuri)
        self.assertEqual("PYRO",pu.protocol)
        self.assertEqual("host"+unichr(0x20AC)+".com",pu.host)
        self.assertEqual("weirdchars"+unichr(0x20AC),pu.object)
        if sys.version_info<=(3,0):
            self.assertEqual("PYRO:weirdchars?@host?.com:4444", pu.__str__())
            expected="<Pyro4.core.URI at 0x%x, PYRO:weirdchars?@host?.com:4444>" % id(pu)
            self.assertEqual(expected, repr(pu))
        else:
            self.assertEqual("PYRO:weirdchars"+unichr(0x20ac)+"@host"+unichr(0x20ac)+".com:4444", pu.__str__())
            expected=("<Pyro4.core.URI at 0x%x, PYRO:weirdchars"+unichr(0x20ac)+"@host"+unichr(0x20ac)+".com:4444>") % id(pu)
            self.assertEqual(expected, repr(pu))
        self.assertEqual("PYRO:weirdchars"+unichr(0x20ac)+"@host"+unichr(0x20ac)+".com:4444", pu.asString())
        self.assertEqual("PYRO:weirdchars"+unichr(0x20ac)+"@host"+unichr(0x20ac)+".com:4444", unicode(pu))

    def testUriCopy(self):
        p1=Pyro4.core.URI("PYRO:12345@hostname:9999")
        p2=Pyro4.core.URI(p1)
        p3=copy.copy(p1)
        self.assertEqual(p1.protocol, p2.protocol)
        self.assertEqual(p1.host, p2.host)
        self.assertEqual(p1.port, p2.port)
        self.assertEqual(p1.object, p2.object)
        self.assertEqual(p1,p2)
        self.assertEqual(p1.protocol, p3.protocol)
        self.assertEqual(p1.host, p3.host)
        self.assertEqual(p1.port, p3.port)
        self.assertEqual(p1.object, p3.object)
        self.assertEqual(p1,p3)
        
    def testUriEqual(self):
        p1=Pyro4.core.URI("PYRO:12345@host.com:9999")
        p2=Pyro4.core.URI("PYRO:12345@host.com:9999")
        p3=Pyro4.core.URI("PYRO:99999@host.com:4444")
        self.assertEqual(p1,p2)
        self.assertNotEqual(p1,p3)
        self.assertNotEqual(p2,p3)
        self.assertTrue(p1==p2)
        self.assertFalse(p1==p3)
        self.assertFalse(p2==p3)
        self.assertFalse(p1!=p2)
        self.assertTrue(p1!=p3)
        self.assertTrue(p2!=p3)
        self.assertTrue(hash(p1)==hash(p2))
        self.assertTrue(hash(p1)!=hash(p3))
        p2.port=4444
        p2.object="99999"
        self.assertNotEqual(p1,p2)
        self.assertEqual(p2,p3)
        self.assertFalse(p1==p2)
        self.assertTrue(p2==p3)
        self.assertTrue(p1!=p2)
        self.assertFalse(p2!=p3)
        self.assertTrue(hash(p1)!=hash(p2))
        self.assertTrue(hash(p2)==hash(p3))
        self.assertFalse(p1==42)
        self.assertTrue(p1!=42)

    def testLocation(self):
        self.assertTrue(Pyro4.core.URI.isUnixsockLocation("./u:name"))
        self.assertFalse(Pyro4.core.URI.isUnixsockLocation("./p:name"))
        self.assertFalse(Pyro4.core.URI.isUnixsockLocation("./x:name"))
        self.assertFalse(Pyro4.core.URI.isUnixsockLocation("foobar"))

    def testProxyOffline(self):
        # only offline stuff here.
        # online stuff needs a running daemon, so we do that in another test, to keep this one simple
        self.assertRaises(TypeError, Pyro4.core.Proxy, 999)  # wrong arg
        p1=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        p2=Pyro4.core.Proxy(Pyro4.core.URI("PYRO:9999@localhost:15555"))
        self.assertEqual(p1._pyroUri, p2._pyroUri)
        self.assertTrue(p1._pyroConnection is None)
        p1._pyroRelease()
        p1._pyroRelease()
        # try copying a not-connected proxy
        p3=copy.copy(p1)
        self.assertTrue(p3._pyroConnection is None)
        self.assertTrue(p1._pyroConnection is None)
        self.assertEqual(p3._pyroUri, p1._pyroUri)
        self.assertFalse(p3._pyroUri is p1._pyroUri)

    def testProxyRepr(self):
        p=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        address=id(p)
        expected="<Pyro4.core.Proxy at 0x%x, not connected, for PYRO:9999@localhost:15555>" % address
        self.assertEqual(expected, repr(p))
        self.assertEqual(unicode(expected), unicode(p))

    def testProxySettings(self):
        p1=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        p2=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        p1._pyroOneway.add("method")
        self.assertTrue("method" in p1._pyroOneway, "p1 should have oneway method")
        self.assertFalse("method" in p2._pyroOneway, "p2 should not have the same oneway method")
        self.assertFalse(p1._pyroOneway is p2._pyroOneway, "p1 and p2 should have different oneway tables")
        
    def testProxyWithStmt(self):
        class ConnectionMock(object):
            closeCalled=False
            def close(self):
                self.closeCalled=True

        connMock=ConnectionMock()
        # first without a 'with' statement
        p=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        p._pyroConnection=connMock
        self.assertFalse(connMock.closeCalled)
        p._pyroRelease()
        self.assertTrue(p._pyroConnection is None)
        self.assertTrue(connMock.closeCalled)
        
        connMock=ConnectionMock()
        with Pyro4.core.Proxy("PYRO:9999@localhost:15555") as p:
            p._pyroConnection=connMock
        self.assertTrue(p._pyroConnection is None)
        self.assertTrue(connMock.closeCalled)
        connMock=ConnectionMock()
        try:
            with Pyro4.core.Proxy("PYRO:9999@localhost:15555") as p:
                p._pyroConnection=connMock
                print(1//0)  # cause an error
            self.fail("expected error")
        except ZeroDivisionError:
            pass
        self.assertTrue(p._pyroConnection is None)
        self.assertTrue(connMock.closeCalled)
        p=Pyro4.core.Proxy("PYRO:9999@localhost:15555")
        with p:
            self.assertTrue(p._pyroUri is not None)
        with p:
            self.assertTrue(p._pyroUri is not None)

    def testNoConnect(self):
        wrongUri=Pyro4.core.URI("PYRO:foobar@localhost:59999")
        with Pyro4.core.Proxy(wrongUri) as p:
            try:
                p.ping()
                self.fail("CommunicationError expected")
            except Pyro4.errors.CommunicationError:
                pass

    def testTimeoutGetSet(self):
        class ConnectionMock(object):
            def __init__(self):
                self.timeout=Pyro4.config.COMMTIMEOUT
            def close(self):
                pass
        Pyro4.config.COMMTIMEOUT=None
        p=Pyro4.core.Proxy("PYRO:obj@host:555")
        self.assertEqual(None, p._pyroTimeout)
        p._pyroTimeout=5
        self.assertEqual(5, p._pyroTimeout)
        p=Pyro4.core.Proxy("PYRO:obj@host:555")
        p._pyroConnection=ConnectionMock()
        self.assertEqual(None, p._pyroTimeout)
        p._pyroTimeout=5
        self.assertEqual(5, p._pyroTimeout)
        self.assertEqual(5, p._pyroConnection.timeout)
        Pyro4.config.COMMTIMEOUT=2
        p=Pyro4.core.Proxy("PYRO:obj@host:555")
        p._pyroConnection=ConnectionMock()
        self.assertEqual(2, p._pyroTimeout)
        self.assertEqual(2, p._pyroConnection.timeout)
        p._pyroTimeout=None
        self.assertEqual(None, p._pyroTimeout)
        self.assertEqual(None, p._pyroConnection.timeout)
        Pyro4.config.COMMTIMEOUT=None

    def testDecorators(self):
        # just test the decorator itself, testing the callback
        # exception handling is kinda hard in unit tests. Maybe later.
        class Test(object):
            @Pyro4.callback
            def method(self):
                pass
            def method2(self):
                pass
        t=Test()
        self.assertEqual(True, getattr(t.method,"_pyroCallback"))
        self.assertEqual(False, getattr(t.method2,"_pyroCallback", False))

    def testProxyEquality(self):
        p1=Pyro4.core.Proxy("PYRO:thing@localhost:15555")
        p2=Pyro4.core.Proxy("PYRO:thing@localhost:15555")
        p3=Pyro4.core.Proxy("PYRO:other@machine:16666")
        self.assertTrue(p1==p2)
        self.assertFalse(p1!=p2)
        self.assertFalse(p1==p3)
        self.assertTrue(p1!=p3)
        self.assertTrue(hash(p1)==hash(p2))
        self.assertFalse(hash(p1)==hash(p3))
        p1._pyroOneway.add("onewaymethod")
        self.assertFalse(p1==p2)
        self.assertFalse(hash(p1)==hash(p2))
        self.assertFalse(p1==42)
        self.assertTrue(p1!=42)


class RemoteMethodTests(unittest.TestCase):
    class BatchProxyMock(object):
        def __copy__(self):
            return self
        def __enter__(self):
            return self
        def __exit__(self, *args):
            pass
        def _pyroBatch(self):
            return Pyro4.core._BatchProxyAdapter(self)
        def _pyroInvokeBatch(self, calls, oneway=False):
            self.result=[]
            for methodname, args, kwargs in calls:
                if methodname=="error":
                    self.result.append(Pyro4.futures._ExceptionWrapper(ValueError("some exception")))
                    break  # stop processing the rest, this is what Pyro should do in case of an error in a batch
                elif methodname=="pause":
                    time.sleep(args[0])
                self.result.append("INVOKED %s args=%s kwargs=%s" % (methodname,args,kwargs))
            if oneway:
                return
            else:
                return self.result

    class AsyncProxyMock(object):
        def __copy__(self):
            return self
        def __enter__(self):
            return self
        def __exit__(self, *args):
            pass
        def _pyroAsync(self):
            return Pyro4.core._AsyncProxyAdapter(self)
        def _pyroInvoke(self, methodname, vargs, kwargs, flags=0):
            if methodname=="pause_and_divide":
                time.sleep(vargs[0])
                return vargs[1]//vargs[2]
            else:
                raise NotImplementedError(methodname)

    def setUp(self):
        Pyro4.config.HMAC_KEY = b"testsuite"
    def tearDown(self):
        Pyro4.config.HMAC_KEY = None

    def testRemoteMethod(self):
        class ProxyMock(object):
            def invoke(self, name, args, kwargs):
                return "INVOKED name=%s args=%s kwargs=%s" % (name,args,kwargs)
            def __getattr__(self, name):
                return Pyro4.core._RemoteMethod(self.invoke, name)
        o=ProxyMock()
        self.assertEqual("INVOKED name=foo args=(1,) kwargs={}", o.foo(1)) #normal
        self.assertEqual("INVOKED name=foo.bar args=(1,) kwargs={}", o.foo.bar(1)) #dotted
        self.assertEqual("INVOKED name=foo.bar args=(1, 'hello') kwargs={'a': True}", o.foo.bar(1,"hello",a=True))
        p=Pyro4.core.Proxy("PYRO:obj@host:666")
        a=p.someattribute
        self.assertTrue(isinstance(a, Pyro4.core._RemoteMethod), "attribute access should just be a RemoteMethod")
        a2=a.nestedattribute
        self.assertTrue(isinstance(a2, Pyro4.core._RemoteMethod), "nested attribute should just be another RemoteMethod")

    def testBatchMethod(self):
        proxy=self.BatchProxyMock()
        batch=Pyro4.batch(proxy)
        self.assertEqual(None, batch.foo(42))
        self.assertEqual(None, batch.bar("abc"))
        self.assertEqual(None, batch.baz(42,"abc",arg=999))
        self.assertEqual(None, batch.error())   # generate an exception
        self.assertEqual(None, batch.foo(42))   # this call should not be performed after the error
        results=batch()
        result=next(results)
        self.assertEqual("INVOKED foo args=(42,) kwargs={}",result)
        result=next(results)
        self.assertEqual("INVOKED bar args=('abc',) kwargs={}",result)
        result=next(results)
        self.assertEqual("INVOKED baz args=(42, 'abc') kwargs={'arg': 999}",result)
        self.assertRaises(ValueError, next, results)  # the call to error() should generate an exception
        self.assertRaises(StopIteration, next, results)   # and now there should not be any more results
        self.assertEqual(4, len(proxy.result))   # should have done 4 calls, not 5

    def testBatchMethodOneway(self):
        proxy=self.BatchProxyMock()
        batch=Pyro4.batch(proxy)
        self.assertEqual(None, batch.foo(42))
        self.assertEqual(None, batch.bar("abc"))
        self.assertEqual(None, batch.baz(42,"abc",arg=999))
        self.assertEqual(None, batch.error())   # generate an exception
        self.assertEqual(None, batch.foo(42))   # this call should not be performed after the error
        results=batch(oneway=True)
        self.assertEqual(None, results)          # oneway always returns None
        self.assertEqual(4, len(proxy.result))   # should have done 4 calls, not 5
        self.assertRaises(Pyro4.errors.PyroError, batch, oneway=True, async=True)   # oneway+async=booboo

    def testBatchMethodAsync(self):
        proxy=self.BatchProxyMock()
        batch=Pyro4.batch(proxy)
        self.assertEqual(None, batch.foo(42))
        self.assertEqual(None, batch.bar("abc"))
        self.assertEqual(None, batch.pause(0.5))    # pause shouldn't matter with async
        self.assertEqual(None, batch.baz(42,"abc",arg=999))
        begin=time.time()
        asyncresult=batch(async=True)
        duration=time.time()-begin
        self.assertTrue(duration<0.1, "batch oneway with pause should still return almost immediately")
        results=asyncresult.value
        self.assertEqual(4, len(proxy.result))   # should have done 4 calls
        result=next(results)
        self.assertEqual("INVOKED foo args=(42,) kwargs={}",result)
        result=next(results)
        self.assertEqual("INVOKED bar args=('abc',) kwargs={}",result)
        result=next(results)
        self.assertEqual("INVOKED pause args=(0.5,) kwargs={}",result)
        result=next(results)
        self.assertEqual("INVOKED baz args=(42, 'abc') kwargs={'arg': 999}",result)
        self.assertRaises(StopIteration, next, results)   # and now there should not be any more results

    def testBatchMethodReuse(self):
        proxy=self.BatchProxyMock()
        batch=Pyro4.batch(proxy)
        batch.foo(1)
        batch.foo(2)
        results=batch()
        self.assertEqual(['INVOKED foo args=(1,) kwargs={}', 'INVOKED foo args=(2,) kwargs={}'], list(results))
        # re-use the batch proxy:
        batch.foo(3)
        batch.foo(4)
        results=batch()
        self.assertEqual(['INVOKED foo args=(3,) kwargs={}', 'INVOKED foo args=(4,) kwargs={}'], list(results))
        results=batch()
        self.assertEqual(0, len(list(results)))

    def testAsyncMethod(self):
        proxy=self.AsyncProxyMock()
        async=Pyro4.async(proxy)
        begin=time.time()
        result=async.pause_and_divide(0.2,10,2)  # returns immediately
        duration=time.time()-begin
        self.assertTrue(duration<0.1)
        self.assertFalse(result.ready)
        _=result.value
        self.assertTrue(result.ready)

    def testAsyncCallbackMethod(self):
        class AsyncFunctionHolder(object):
            asyncFunctionCount=0
            def asyncFunction(self, value, amount=1):
                self.asyncFunctionCount+=1
                return value+amount
        proxy=self.AsyncProxyMock()
        async=Pyro4.async(proxy)
        result=async.pause_and_divide(0.2,10,2)  # returns immediately
        holder=AsyncFunctionHolder()
        result.then(holder.asyncFunction, amount=2) \
              .then(holder.asyncFunction, amount=4) \
              .then(holder.asyncFunction)
        value=result.value
        self.assertEqual(10//2+2+4+1,value)
        self.assertEqual(3,holder.asyncFunctionCount)

    def testCrashingAsyncCallbackMethod(self):
        def normalAsyncFunction(value, x):
            return value+x
        def crashingAsyncFunction(value):
            return 1//0  # crash
        proxy=self.AsyncProxyMock()
        async=Pyro4.async(proxy)
        result=async.pause_and_divide(0.2,10,2)  # returns immediately
        result.then(crashingAsyncFunction).then(normalAsyncFunction,2)
        try:
            value=result.value
            self.fail("expected exception")
        except ZeroDivisionError:
            pass  # ok

    def testAsyncMethodTimeout(self):
        proxy=self.AsyncProxyMock()
        async=Pyro4.async(proxy)
        result=async.pause_and_divide(1,10,2)  # returns immediately
        self.assertFalse(result.ready)
        self.assertFalse(result.wait(0.5))  # won't be ready after 0.5 sec
        self.assertTrue(result.wait(1))  # will be ready within 1 seconds more
        self.assertTrue(result.ready)
        self.assertEqual(5,result.value)


class TestSimpleServe(unittest.TestCase):
    class DaemonMock(object):
        def __init__(self):
            self.objects={}
        def register(self, object, name):
            self.objects[object]=name
        def __enter__(self):
            pass
        def __exit__(self, *args):
            pass
        def requestLoop(self, *args):
            pass

    def testSimpleServe(self):
        d=TestSimpleServe.DaemonMock()
        o1=Thing(1)
        o2=Thing(2)
        objects={ o1: "test.o1", o2: None }
        Pyro4.core.Daemon.serveSimple(objects,daemon=d, ns=False, verbose=False)
        self.assertEqual( {o1: "test.o1", o2: None}, d.objects)


def futurestestfunc(a, b, extra=None):
    if extra is None:
        return a+b
    else:
        return a+b+extra
def crashingfuturestestfunc(a):
    return 1//0  # crash

class TestFutures(unittest.TestCase):
    def testSimpleFuture(self):
        f=Pyro4.Future(futurestestfunc)
        r=f(4,5)
        self.assertTrue(isinstance(r, Pyro4.futures.FutureResult))
        value=r.value
        self.assertEqual(9, value)
    def testFutureChain(self):
        f=Pyro4.Future(futurestestfunc)
        f.then(futurestestfunc, 6)
        f.then(futurestestfunc, 7, extra=10)
        r=f(4,5)
        value=r.value
        self.assertEqual(4+5+6+7+10,value)
    def testCrashingChain(self):
        f=Pyro4.Future(futurestestfunc)
        f.then(futurestestfunc, 6)
        f.then(crashingfuturestestfunc)
        f.then(futurestestfunc, 8)
        r=f(4,5)
        try:
            value=r.value
            self.fail("expected exception")
        except ZeroDivisionError:
            pass   #ok


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_daemon
"""
Tests for the daemon.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys, time, socket
import Pyro4.core
import Pyro4.constants
import Pyro4.socketutil
import Pyro4.message
from Pyro4.errors import DaemonError,PyroError
from testsupport import *


class MyObj(object):
    def __init__(self, arg):
        self.arg=arg
    def __eq__(self,other):
        return self.arg==other.arg
    __hash__=object.__hash__

class DaemonTests(unittest.TestCase):
    # We create a daemon, but notice that we are not actually running the requestloop.
    # 'on-line' tests are all taking place in another test, to keep this one simple.

    def setUp(self):
        Pyro4.config.POLLTIMEOUT=0.1
        Pyro4.config.HMAC_KEY = b"testsuite"
    def tearDown(self):
        Pyro4.config.HMAC_KEY = None

    def testSerializerConfig(self):
        self.assertIsInstance(Pyro4.config.SERIALIZERS_ACCEPTED, set)
        self.assertIsInstance(Pyro4.config.SERIALIZER, basestring)
        self.assertGreater(len(Pyro4.config.SERIALIZERS_ACCEPTED), 1)

    def testSerializerAccepted(self):
        class ConnectionMock(object):
            def __init__(self, msg):
                self.data = msg.to_bytes()
            def recv(self, datasize):
                chunk = self.data[:datasize]
                self.data = self.data[datasize:]
                return chunk
            def send(self, data):
                pass
        self.assertTrue("marshal" in Pyro4.config.SERIALIZERS_ACCEPTED)
        self.assertFalse("pickle" in Pyro4.config.SERIALIZERS_ACCEPTED)
        with Pyro4.core.Daemon(port=0) as d:
            msg = Pyro4.message.Message(Pyro4.message.MSG_INVOKE, b"", Pyro4.message.SERIALIZER_MARSHAL, 0, 0)
            cm = ConnectionMock(msg)
            d.handleRequest(cm)  # marshal serializer should be accepted
            msg = Pyro4.message.Message(Pyro4.message.MSG_INVOKE, b"", Pyro4.message.SERIALIZER_PICKLE, 0, 0)
            cm = ConnectionMock(msg)
            try:
                d.handleRequest(cm)
                self.fail("should crash")
            except Pyro4.errors.ProtocolError as x:
                self.assertTrue("serializer that is not accepted" in str(x))
                pass

    def testDaemon(self):
        with Pyro4.core.Daemon(port=0) as d:
            hostname, port = d.locationStr.split(":")
            port = int(port)
            self.assertTrue(Pyro4.constants.DAEMON_NAME in d.objectsById)
            self.assertEqual("PYRO:"+Pyro4.constants.DAEMON_NAME+"@"+d.locationStr, str(d.uriFor(Pyro4.constants.DAEMON_NAME)))
            # check the string representations
            expected=("<Pyro4.core.Daemon at 0x%x, %s, 1 objects>") % (id(d), d.locationStr)
            self.assertEqual(expected,str(d))
            self.assertEqual(expected,unicode(d))
            self.assertEqual(expected,repr(d))
            sockname=d.sock.getsockname()
            self.assertEqual(port, sockname[1])
            daemonobj=d.objectsById[Pyro4.constants.DAEMON_NAME]
            daemonobj.ping()
            daemonobj.registered()
            try:
                daemonobj.shutdown()
                self.fail("should not succeed to call unexposed method")
            except AttributeError:
                pass

    @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "unix domain sockets required")
    def testDaemonUnixSocket(self):
        SOCKNAME="test_unixsocket"
        with Pyro4.core.Daemon(unixsocket=SOCKNAME) as d:
            locationstr="./u:"+SOCKNAME
            self.assertEqual(locationstr, d.locationStr)
            self.assertEqual("PYRO:"+Pyro4.constants.DAEMON_NAME+"@"+locationstr, str(d.uriFor(Pyro4.constants.DAEMON_NAME)))
            # check the string representations
            expected=("<Pyro4.core.Daemon at 0x%x, %s, 1 objects>") % (id(d), locationstr)
            self.assertEqual(expected,str(d))
            self.assertEqual(SOCKNAME,d.sock.getsockname())
            self.assertEqual(socket.AF_UNIX,d.sock.family)

    @unittest.skipUnless(hasattr(socket, "AF_UNIX") and sys.platform.startswith("linux"), "linux and unix domain sockets required")
    def testDaemonUnixSocketAbstractNS(self):
        SOCKNAME="\0test_unixsocket"  # mind the \0 at the start
        with Pyro4.core.Daemon(unixsocket=SOCKNAME) as d:
            locationstr="./u:"+SOCKNAME
            self.assertEqual(locationstr, d.locationStr)
            self.assertEqual("PYRO:"+Pyro4.constants.DAEMON_NAME+"@"+locationstr, str(d.uriFor(Pyro4.constants.DAEMON_NAME)))
            # check the string representations
            expected=("<Pyro4.core.Daemon at 0x%x, %s, 1 objects>") % (id(d), locationstr)
            self.assertEqual(expected,str(d))
            sn_bytes = tobytes(SOCKNAME)
            self.assertEqual(sn_bytes,d.sock.getsockname())
            self.assertEqual(socket.AF_UNIX,d.sock.family)

    def testServertypeThread(self):
        old_servertype=Pyro4.config.SERVERTYPE
        Pyro4.config.SERVERTYPE="thread"
        with Pyro4.core.Daemon(port=0) as d:
            sock=d.sock
            self.assertTrue(sock in d.sockets, "daemon's socketlist should contain the server socket")
            self.assertTrue(len(d.sockets)==1, "daemon without connections should have just 1 socket")
        Pyro4.config.SERVERTYPE=old_servertype

    def testServertypeMultiplex(self):
        old_servertype=Pyro4.config.SERVERTYPE
        Pyro4.config.SERVERTYPE="multiplex"
        with Pyro4.core.Daemon(port=0) as d:
            sock=d.sock
            self.assertTrue(sock in d.sockets, "daemon's socketlist should contain the server socket")
            self.assertTrue(len(d.sockets)==1, "daemon without connections should have just 1 socket")
        Pyro4.config.SERVERTYPE=old_servertype
                
    def testServertypeFoobar(self):
        old_servertype=Pyro4.config.SERVERTYPE
        Pyro4.config.SERVERTYPE="foobar"
        self.assertRaises(PyroError, Pyro4.core.Daemon)
        Pyro4.config.SERVERTYPE=old_servertype

    def testRegisterTwice(self):
        with Pyro4.core.Daemon(port=0) as d:
            o1=MyObj("object1")
            d.register(o1)
            self.assertRaises(DaemonError, d.register, o1, None)
            d.unregister(o1)
            d.register(o1)
            self.assertTrue(hasattr(o1, "_pyroId"))
            d.unregister(o1)
            self.assertFalse(hasattr(o1, "_pyroId"))
            o1._pyroId="FOOBAR"
            self.assertRaises(DaemonError, d.register, o1, None)
            o1._pyroId=""
            d.register(o1)   # with empty-string _pyroId register should worlk

    def testRegisterEtc(self):
        d=Pyro4.core.Daemon(port=0)
        try:
            self.assertEqual(1, len(d.objectsById))
            o1=MyObj("object1")
            o2=MyObj("object2")
            d.register(o1)
            self.assertRaises(DaemonError, d.register, o2, Pyro4.constants.DAEMON_NAME)  # cannot use daemon name
            d.register(o2, "obj2a")

            self.assertEqual(3, len(d.objectsById))
            self.assertEqual(o1, d.objectsById[o1._pyroId])
            self.assertEqual(o2, d.objectsById["obj2a"])
            self.assertEqual("obj2a", o2._pyroId)
            self.assertEqual(d, o2._pyroDaemon)
    
            # test unregister
            d.unregister("unexisting_thingie")
            self.assertRaises(ValueError, d.unregister, None)
            d.unregister("obj2a")
            d.unregister(o1._pyroId)
            self.assertEqual(1, len(d.objectsById))
            self.assertTrue(o1._pyroId not in d.objectsById)
            self.assertTrue(o2._pyroId not in d.objectsById)
            
            # test unregister objects
            del o2._pyroId
            d.register(o2)
            objectid = o2._pyroId
            self.assertTrue(objectid in d.objectsById)
            self.assertEqual(2, len(d.objectsById))
            d.unregister(o2)
            # no more _pyro attributs must remain after unregistering
            for attr in vars(o2):
                self.assertFalse(attr.startswith("_pyro"))
            self.assertEqual(1, len(d.objectsById))
            self.assertFalse(objectid in d.objectsById)
            self.assertRaises(DaemonError, d.unregister, [1,2,3])
            
            # test unregister daemon name
            d.unregister(Pyro4.constants.DAEMON_NAME)
            self.assertTrue(Pyro4.constants.DAEMON_NAME in d.objectsById)
            
            # weird args
            w=MyObj("weird")
            self.assertRaises(AttributeError, d.register, None)
            self.assertRaises(AttributeError, d.register, 4444)
            self.assertRaises(TypeError, d.register, w, 666)
            
            # uri return value from register
            uri=d.register(MyObj("xyz"))
            self.assertTrue(isinstance(uri, Pyro4.core.URI))
            uri=d.register(MyObj("xyz"), "test.register")
            self.assertTrue("test.register", uri.object)

        finally:
            d.close()

    def testRegisterUnicode(self):
        with Pyro4.core.Daemon(port=0) as d:
            myobj1=MyObj("hello1")
            myobj2=MyObj("hello2")
            myobj3=MyObj("hello3")
            uri1=d.register(myobj1, "str_name")
            uri2=d.register(myobj2, unicode("unicode_name"))
            uri3=d.register(myobj3, "unicode_"+unichr(0x20ac))
            self.assertEqual(4, len(d.objectsById))
            uri=d.uriFor(myobj1)
            self.assertEqual(uri1,uri)
            _=Pyro4.core.Proxy(uri)
            uri=d.uriFor(myobj2)
            self.assertEqual(uri2,uri)
            _=Pyro4.core.Proxy(uri)
            uri=d.uriFor(myobj3)
            self.assertEqual(uri3,uri)
            _=Pyro4.core.Proxy(uri)
            uri=d.uriFor("str_name")
            self.assertEqual(uri1,uri)
            _=Pyro4.core.Proxy(uri)
            uri=d.uriFor(unicode("unicode_name"))
            self.assertEqual(uri2,uri)
            _=Pyro4.core.Proxy(uri)
            uri=d.uriFor("unicode_"+unichr(0x20ac))
            self.assertEqual(uri3,uri)
            _=Pyro4.core.Proxy(uri)

    def testDaemonObject(self):
        with Pyro4.core.Daemon(port=0) as d:
            daemon=Pyro4.core.DaemonObject(d)
            obj1=MyObj("object1")
            obj2=MyObj("object2")
            obj3=MyObj("object2")
            d.register(obj1,"obj1")
            d.register(obj2,"obj2")
            d.register(obj3)
            daemon.ping()
            registered=daemon.registered()
            self.assertTrue(type(registered) is list)
            self.assertEqual(4, len(registered))
            self.assertTrue("obj1" in registered)
            self.assertTrue("obj2" in registered)
            self.assertTrue(obj3._pyroId in registered)
            try:
                daemon.shutdown()
                self.fail("should not succeed to call unexposed method")
            except AttributeError:
                pass
        
    def testUriFor(self):
        d=Pyro4.core.Daemon(port=0)
        try:
            o1=MyObj("object1")
            o2=MyObj("object2")
            self.assertRaises(DaemonError, d.uriFor, o1)
            self.assertRaises(DaemonError, d.uriFor, o2)
            d.register(o1,None)
            d.register(o2,"object_two")
            o3=MyObj("object3")
            self.assertRaises(DaemonError, d.uriFor, o3)  #can't get an uri for an unregistered object (note: unregistered name is allright)
            u1=d.uriFor(o1)
            u2=d.uriFor(o2._pyroId)
            u3=d.uriFor("unexisting_thingie")  # unregistered name is no problem, it's just an uri we're requesting
            u4=d.uriFor(o2)
            self.assertEqual(Pyro4.core.URI, type(u1))
            self.assertEqual("PYRO",u1.protocol)
            self.assertEqual("PYRO",u2.protocol)
            self.assertEqual("PYRO",u3.protocol)
            self.assertEqual("PYRO",u4.protocol)
            self.assertEqual("object_two",u4.object)
            self.assertEqual(Pyro4.core.URI("PYRO:unexisting_thingie@"+d.locationStr), u3)
        finally:
            d.close()
    
    def testDaemonWithStmt(self):
        d=Pyro4.core.Daemon()
        self.assertTrue(d.transportServer is not None)
        d.close()   # closes the transportserver and sets it to None
        self.assertTrue(d.transportServer is None)
        with Pyro4.core.Daemon() as d:
            self.assertTrue(d.transportServer is not None)
            pass
        self.assertTrue(d.transportServer is None)
        try:
            with Pyro4.core.Daemon() as d:
                print(1//0) # cause an error
            self.fail("expected error")
        except ZeroDivisionError: 
            pass
        self.assertTrue(d.transportServer is None)
        d=Pyro4.core.Daemon()
        with d:
            pass
        try:
            with d:
                pass
            self.fail("expected error")
        except PyroError:
            # you cannot re-use a daemon object in multiple with statements
            pass
        d.close()
        
    def testRequestloopCondition(self):
        with Pyro4.core.Daemon(port=0) as d:
            condition=lambda:False
            start=time.time()
            d.requestLoop(loopCondition=condition)   #this should return almost immediately
            duration=time.time()-start
            self.assertAlmostEqual(0.0, duration, places=1)

    def testHandshake(self):
        class ConnectionMock(object):
            def __init__(self):
                self.received = b""
            def send(self, data):
                self.received += data
            def recv(self, datasize):
                chunk = self.received[:datasize]
                self.received = self.received[datasize:]
                return chunk
        conn = ConnectionMock()
        with Pyro4.core.Daemon(port=0) as d:
            success = d._handshake(conn)
            self.assertTrue(success)
            msg = Pyro4.message.Message.recv(conn)
            self.assertEqual(Pyro4.message.MSG_CONNECTOK, msg.type)
            self.assertEqual(1, msg.seq)

    def testNAT(self):
        with Pyro4.core.Daemon() as d:
            self.assertTrue(d.natLocationStr is None)
        with Pyro4.core.Daemon(nathost="nathosttest", natport=12345) as d:
            self.assertEqual("nathosttest:12345", d.natLocationStr)
            self.assertNotEqual(d.locationStr, d.natLocationStr)
            uri=d.register(MyObj(1))
            self.assertEqual("nathosttest:12345", uri.location)
            uri=d.uriFor("object")
            self.assertEqual("nathosttest:12345", uri.location)
            uri=d.uriFor("object", nat=False)
            self.assertNotEqual("nathosttest:12345", uri.location)
        try:
            d=Pyro4.core.Daemon(nathost="bla")
            self.fail("expected error")
        except ValueError:
            pass
        try:
            d=Pyro4.core.Daemon(natport=5555)
            self.fail("expected error")
        except ValueError:
            pass
        try:
            d=Pyro4.core.Daemon(nathost="bla", natport=5555, unixsocket="testsock")
            self.fail("expected error")
        except ValueError:
            pass

    def testNATzeroPort(self):
        servertype = Pyro4.config.SERVERTYPE
        try:
            Pyro4.config.SERVERTYPE="multiplex"
            with Pyro4.core.Daemon(nathost="nathosttest", natport=99999) as d:
                host, port = d.locationStr.split(":")
                self.assertNotEqual(99999, port)
                self.assertEqual("nathosttest:99999", d.natLocationStr)
            with Pyro4.core.Daemon(nathost="nathosttest", natport=0) as d:
                host, port = d.locationStr.split(":")
                self.assertEqual("nathosttest:%s" % port, d.natLocationStr)
            Pyro4.config.SERVERTYPE="thread"
            with Pyro4.core.Daemon(nathost="nathosttest", natport=99999) as d:
                host, port = d.locationStr.split(":")
                self.assertNotEqual(99999, port)
                self.assertEqual("nathosttest:99999", d.natLocationStr)
            with Pyro4.core.Daemon(nathost="nathosttest", natport=0) as d:
                host, port = d.locationStr.split(":")
                self.assertEqual("nathosttest:%s" % port, d.natLocationStr)
        finally:
            Pyro4.config.SERVERTYPE=servertype

    def testNATconfig(self):
        try:
            Pyro4.config.NATHOST=None
            Pyro4.config.NATPORT=0
            with Pyro4.core.Daemon() as d:
                self.assertTrue(d.natLocationStr is None)
            Pyro4.config.NATHOST="nathosttest"
            Pyro4.config.NATPORT=12345
            with Pyro4.core.Daemon() as d:
                self.assertEqual("nathosttest:12345", d.natLocationStr)
        finally:
            Pyro4.config.NATHOST=None
            Pyro4.config.NATPORT=0


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_echoserver
"""
Tests for the built-in test echo server.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import time
import Pyro4.test.echoserver as echoserver
import Pyro4
from threading import Thread,Event
from testsupport import *


class EchoServerThread(Thread):
    def __init__(self):
        super(EchoServerThread,self).__init__()
        self.setDaemon(True)
        self.started=Event()
        self.terminated=Event()
    def run(self):
        self.echodaemon,self.echoserver,self.uri=echoserver.main(["-q"], returnWithoutLooping=True)
        self.started.set()
        self.echodaemon.requestLoop(loopCondition=lambda:not self.echoserver.must_shutdown)
        self.terminated.set()
        
class TestEchoserver(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY = b"testsuite"
        self.echoserverthread=EchoServerThread()
        self.echoserverthread.start()
        self.echoserverthread.started.wait()
        self.uri=self.echoserverthread.uri
    def tearDown(self):
        self.echoserverthread.echodaemon.shutdown()
        time.sleep(0.01)
        self.echoserverthread.terminated.wait()
        Pyro4.config.HMAC_KEY=None
    def testEcho(self):
        echo=Pyro4.Proxy(self.uri)
        try:
            self.assertEqual("hello", echo.echo("hello"))
            self.assertEqual(None, echo.echo(None))
            self.assertEqual([1,2,3], echo.echo([1,2,3]))
        finally:
            echo.shutdown()
    def testError(self):
        try:
            echo=Pyro4.Proxy(self.uri)
            try:
                echo.error()
                self.fail("expected exception")
            except:
                tb="".join(Pyro4.util.getPyroTraceback())
                self.assertTrue("Remote traceback" in tb)
                self.assertTrue("ZeroDivisionError" in tb)
        finally:
            echo.shutdown()


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_flame
"""
Tests for Pyro Flame.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import Pyro4.utils.flame
import Pyro4.utils.flameserver
import Pyro4.errors
from testsupport import *


class FlameDisabledTests(unittest.TestCase):
    def testFlameDisabled(self):
        with Pyro4.core.Daemon() as d:
            self.assertRaises(Pyro4.errors.SecurityError, Pyro4.utils.flame.start, d)   # default should be disabled
    def testRequirePickle(self):
        with Pyro4.core.Daemon() as d:
            Pyro4.config.FLAME_ENABLED=True
            Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")
            self.assertRaises(RuntimeError, Pyro4.utils.flame.start, d)   # require pickle
            Pyro4.config.SERIALIZERS_ACCEPTED.add("pickle")
            Pyro4.utils.flame.start(d)
            Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")


class FlameTests(unittest.TestCase):
    
    def setUp(self):
        Pyro4.config.HMAC_KEY=b"testsuite"
        Pyro4.config.FLAME_ENABLED=True
        Pyro4.config.SERIALIZERS_ACCEPTED.add("pickle")
    def tearDown(self):
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.FLAME_ENABLED=False
        Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")

    def testCreateModule(self):
        module=Pyro4.utils.flame.createModule("testmodule", "def x(y): return y*y")
        self.assertEqual(9, module.x(3))
        module=Pyro4.utils.flame.createModule("testmodule2.submodule.subsub", "def x(y): return y*y")
        self.assertEqual(9, module.x(3))
        import testmodule2.submodule.subsub
        self.assertEqual(9, testmodule2.submodule.subsub.x(3))

    def testCreateModuleNamespace(self):
        namespace={}
        Pyro4.utils.flame.createModule("testmodule2.submodule.subsub", "def x(y): return y*y", namespace=namespace)
        self.assertEqual(9, namespace["testmodule2"].submodule.subsub.x(3))

    def testExecFunction(self):
        namespace={}
        Pyro4.utils.flame.exec_function("foobar=5+6", "<foo>", namespace)
        self.assertEqual(11, namespace["foobar"])

    def testExecFunctionNewlines(self):
        namespace={}
        Pyro4.utils.flame.exec_function("if True:\r\n  foobar=5+6\r\n   ", "<foo>", namespace)
        self.assertEqual(11, namespace["foobar"])

    def testFlameModule(self):
        with Pyro4.core.Daemon() as d:
            Pyro4.utils.flame.start(d)
            flameserver=d.objectsById[Pyro4.constants.FLAME_NAME]
            with Pyro4.utils.flame.FlameModule(flameserver, "sys") as m:
                self.assertTrue("module 'sys' at" in str(m))
                self.assertTrue(isinstance(m.exc_info , Pyro4.core._RemoteMethod))

    def testFlameBuiltin(self):
        with Pyro4.core.Daemon() as d:
            Pyro4.utils.flame.start(d)
            flameserver=d.objectsById[Pyro4.constants.FLAME_NAME]
            with Pyro4.utils.flame.FlameBuiltin(flameserver, "max") as builtin:
                self.assertTrue(hasattr(builtin, "__call__"))
                self.assertTrue("builtin 'max' at" in str(builtin))


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ironpython
"""
Tests for some Ironpython peculiarities.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys
import pickle
from testsupport import unittest


if sys.platform=="cli":

    class IronPythonWeirdnessTests(unittest.TestCase):
        def testExceptionWithAttrsPickle(self):
            # ironpython doesn't pickle exception attributes
            # see bug report http://ironpython.codeplex.com/workitem/30805
            ex=ValueError("some exception")
            ex.custom_attribute=42
            ex2=pickle.loads(pickle.dumps(ex))
            self.assertTrue(hasattr(ex,"custom_attribute"))
            self.assertFalse(hasattr(ex2,"custom_attribute"))   # custom attribute will be gone after pickling
            self.assertNotEqual(ex2,ex)     # the object won't be equal

        def testExceptionReduce(self):
            # ironpython doesn't pickle exception attributes
            # see bug report http://ironpython.codeplex.com/workitem/30805
            # it could be caused by a malfunctioning __reduce__
            ex=ValueError("some exception")
            ex.custom_attribute=42
            r=ex.__reduce__()
            # the reduce result should be:
            # (ValueError, ("some exception",), {"custom_attribute": 42})
            # but in Ironpython the custom attributes are not returned.
            self.assertNotEqual( (ValueError, ("some exception",), {"custom_attribute": 42}), r)
            self.assertEqual( (ValueError, ("some exception",)), r)

        def testTbFrame(self):
            # there's some stuff missing on traceback frames
            # this prevents a detailed stack trace to be printed by
            # the functions in util.py, for instance.
            def crash():
                a=1
                b=0
                return a//b
            try:
                crash()
            except:
                ex_t, ex_v, ex_tb=sys.exc_info()
                while ex_tb.tb_next:
                    ex_tb=ex_tb.tb_next
                self.assertEqual(None, ex_tb.tb_frame.f_back)   # should not be none... :(


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_message
"""
Tests for pyro write protocol message.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import hashlib
import hmac
from testsupport import unittest
import Pyro4.message
from Pyro4.message import Message
import Pyro4.constants
import Pyro4.util
import Pyro4.errors


def pyrohmac(data, annotations={}):
    mac = hmac.new(Pyro4.config.HMAC_KEY, data, digestmod=hashlib.sha1)
    for k, v in annotations.items():
        if k != "HMAC":
            mac.update(v)
    return mac.digest()


class ConnectionMock(object):
    def __init__(self, data=b""):
        self.received = data
    def send(self, data):
        self.received += data
    def recv(self, datasize):
        chunk = self.received[:datasize]
        self.received = self.received[datasize:]
        return chunk


class MessageTestsHmac(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY = b"testsuite"
        self.ser = Pyro4.util.get_serializer(Pyro4.config.SERIALIZER)

    def tearDown(self):
        Pyro4.config.HMAC_KEY = None

    def testMessage(self):
        Message(99, b"", self.ser.serializer_id, 0, 0) # doesn't check msg type here
        self.assertRaises(Pyro4.errors.ProtocolError, Message.from_header, "FOOBAR")
        msg = Message(Pyro4.message.MSG_CONNECT, b"hello", self.ser.serializer_id, 0, 0)
        self.assertEqual(Pyro4.message.MSG_CONNECT, msg.type)
        self.assertEqual(5, msg.data_size)
        self.assertEqual(b"hello", msg.data)
        self.assertEqual(4+2+20, msg.annotations_size)
        mac = pyrohmac(b"hello", msg.annotations)
        self.assertDictEqual({"HMAC": mac}, msg.annotations)

        hdr = msg.to_bytes()[:24]
        msg = Message.from_header(hdr)
        self.assertEqual(Pyro4.message.MSG_CONNECT, msg.type)
        self.assertEqual(4+2+20, msg.annotations_size)
        self.assertEqual(5, msg.data_size)

        hdr = Message(Pyro4.message.MSG_RESULT, b"", self.ser.serializer_id, 0, 0).to_bytes()[:24]
        msg = Message.from_header(hdr)
        self.assertEqual(Pyro4.message.MSG_RESULT, msg.type)
        self.assertEqual(4+2+20, msg.annotations_size)
        self.assertEqual(0, msg.data_size)

        hdr = Message(Pyro4.message.MSG_RESULT, b"hello", 12345, 60006, 30003).to_bytes()[:24]
        msg = Message.from_header(hdr)
        self.assertEqual(Pyro4.message.MSG_RESULT, msg.type)
        self.assertEqual(60006, msg.flags)
        self.assertEqual(5, msg.data_size)
        self.assertEqual(12345, msg.serializer_id)
        self.assertEqual(30003, msg.seq)

        msg = Message(255, b"", self.ser.serializer_id, 0, 255).to_bytes()
        self.assertEqual(50, len(msg))
        msg = Message(1, b"", self.ser.serializer_id, 0, 255).to_bytes()
        self.assertEqual(50, len(msg))
        msg = Message(1, b"", self.ser.serializer_id, flags=253, seq=254).to_bytes()
        self.assertEqual(50, len(msg))

        # compression is a job of the code supplying the data, so the messagefactory should leave it untouched
        data = b"x"*1000
        msg = Message(Pyro4.message.MSG_INVOKE, data, self.ser.serializer_id, 0, 0).to_bytes()
        msg2 = Message(Pyro4.message.MSG_INVOKE, data, self.ser.serializer_id, Pyro4.message.FLAGS_COMPRESSED, 0).to_bytes()
        self.assertEqual(len(msg), len(msg2))

    def testMessageHeaderDatasize(self):
        msg = Message(Pyro4.message.MSG_RESULT, b"hello", 12345, 60006, 30003)
        msg.data_size = 0x12345678   # hack it to a large value to see if it comes back ok
        hdr = msg.to_bytes()[:24]
        msg = Message.from_header(hdr)
        self.assertEqual(Pyro4.message.MSG_RESULT, msg.type)
        self.assertEqual(60006, msg.flags)
        self.assertEqual(0x12345678, msg.data_size)
        self.assertEqual(12345, msg.serializer_id)
        self.assertEqual(30003, msg.seq)

    def testAnnotations(self):
        annotations = { "TEST": b"abcde" }
        msg = Message(Pyro4.message.MSG_CONNECT, b"hello", self.ser.serializer_id, 0, 0, annotations)
        data = msg.to_bytes()
        annotations_size = 4+2+20 + 4+2+5
        self.assertEqual(msg.header_size + 5 + annotations_size, len(data))
        self.assertEqual(annotations_size, msg.annotations_size)
        self.assertEqual(2, len(msg.annotations))
        self.assertEqual(b"abcde", msg.annotations["TEST"])
        mac = pyrohmac(b"hello", annotations)
        self.assertEqual(mac, msg.annotations["HMAC"])

    def testAnnotationsIdLength4(self):
        try:
            msg = Message(Pyro4.message.MSG_CONNECT, b"hello", self.ser.serializer_id, 0, 0, { "TOOLONG": b"abcde" })
            data = msg.to_bytes()
            self.fail("should fail, too long")
        except Pyro4.errors.ProtocolError:
            pass
        try:
            msg = Message(Pyro4.message.MSG_CONNECT, b"hello", self.ser.serializer_id, 0, 0, { "QQ": b"abcde" })
            data = msg.to_bytes()
            self.fail("should fail, too short")
        except Pyro4.errors.ProtocolError:
            pass


    def testRecvAnnotations(self):
        annotations = { "TEST": b"abcde" }
        msg = Message(Pyro4.message.MSG_CONNECT, b"hello", self.ser.serializer_id, 0, 0, annotations)
        c = ConnectionMock()
        c.send(msg.to_bytes())
        msg = Message.recv(c)
        self.assertEqual(0, len(c.received))
        self.assertEqual(5, msg.data_size)
        self.assertEqual(b"hello", msg.data)
        self.assertEqual(b"abcde", msg.annotations["TEST"])
        self.assertTrue("HMAC" in msg.annotations)

    def testProtocolVersion(self):
        version = Pyro4.constants.PROTOCOL_VERSION
        Pyro4.constants.PROTOCOL_VERSION = 0     # fake invalid protocol version number
        msg = Message(Pyro4.message.MSG_RESULT, b"", self.ser.serializer_id, 0, 1).to_bytes()
        Pyro4.constants.PROTOCOL_VERSION = version
        self.assertRaises(Pyro4.errors.ProtocolError, Message.from_header, msg)

    def testHmac(self):
        try:
            hk = Pyro4.config.HMAC_KEY
            Pyro4.config.HMAC_KEY = b"test key"
            data = Message(Pyro4.message.MSG_RESULT, b"test", 42, 0, 1).to_bytes()
            c = ConnectionMock(data)
        finally:
            Pyro4.config.HMAC_KEY = hk
        # test checking of different hmacs
        try:
            Message.recv(c)
            self.fail("crash expected")
        except Pyro4.errors.SecurityError as x:
            self.assertTrue("hmac" in str(x))
        c = ConnectionMock(data)
        # test that it works again when resetting the key
        try:
            hk = Pyro4.config.HMAC_KEY
            Pyro4.config.HMAC_KEY = b"test key"
            Message.recv(c)
        finally:
            Pyro4.config.HMAC_KEY = hk
        c = ConnectionMock(data)
        # test that it doesn't work when no key is set
        try:
            hk = Pyro4.config.HMAC_KEY
            Pyro4.config.HMAC_KEY = b""
            Message.recv(c)
            self.fail("crash expected")
        except Pyro4.errors.SecurityError as x:
            self.assertTrue("hmac key config" in str(x))
        finally:
            Pyro4.config.HMAC_KEY = hk


    def testChecksum(self):
        msg = Message(Pyro4.message.MSG_RESULT, b"test", 42, 0, 1)
        c = ConnectionMock()
        c.send(msg.to_bytes())
        # corrupt the checksum bytes
        data = c.received
        data = data[:msg.header_size-2] + b'\x00\x00' + data[msg.header_size:]
        c = ConnectionMock(data)
        try:
            Message.recv(c)
            self.fail("crash expected")
        except Pyro4.errors.ProtocolError as x:
            self.assertTrue("checksum" in str(x))


class MessageTestsNoHmac(unittest.TestCase):
    def testRecvNoAnnotations(self):
        msg = Message(Pyro4.message.MSG_CONNECT, b"hello", 42, 0, 0)
        c = ConnectionMock()
        c.send(msg.to_bytes())
        msg = Message.recv(c)
        self.assertEqual(0, len(c.received))
        self.assertEqual(5, msg.data_size)
        self.assertEqual(b"hello", msg.data)
        self.assertEqual(0, msg.annotations_size)
        self.assertEqual(0, len(msg.annotations))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_naming
"""
Tests for the name server (online/running).

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import time
import os
import Pyro4.core
import Pyro4.naming
import Pyro4.socketutil
import Pyro4.constants
from Pyro4.errors import CommunicationError, NamingError
from Pyro4 import threadutil
from testsupport import *


class NSLoopThread(threadutil.Thread):
    def __init__(self, nameserver):
        super(NSLoopThread,self).__init__()
        self.setDaemon(True)
        self.nameserver=nameserver
        self.running=threadutil.Event()
        self.running.clear()
    def run(self):
        self.running.set()
        try:
            self.nameserver.requestLoop()
        except CommunicationError:
            pass   # ignore pyro communication errors

class BCSetupTests(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY=b"testsuite"
    def tearDown(self):
        Pyro4.config.HMAC_KEY=None
    def testBCstart(self):
        myIpAddress=Pyro4.socketutil.getIpAddress("", workaround127=True)
        nsUri, nameserver, bcserver = Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0, enableBroadcast=False)
        self.assertTrue(bcserver is None)
        nameserver.close()
        nsUri, nameserver, bcserver = Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0, enableBroadcast=True)
        self.assertTrue(bcserver is not None, "expected a BC server to be running. Check DNS setup (hostname must not resolve to loopback address")
        self.assertTrue(bcserver.fileno() > 1)
        self.assertTrue(bcserver.sock is not None)
        nameserver.close()
        bcserver.close()


class NameServerTests(unittest.TestCase):
    def setUp(self):
        Pyro4.config.POLLTIMEOUT=0.1
        Pyro4.config.HMAC_KEY=b"testsuite"
        myIpAddress=Pyro4.socketutil.getIpAddress("", workaround127=True)
        self.nsUri, self.nameserver, self.bcserver = Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0)
        self.assertTrue(self.bcserver is not None,"expected a BC server to be running")
        self.bcserver.runInThread()
        self.daemonthread=NSLoopThread(self.nameserver)
        self.daemonthread.start()
        self.daemonthread.running.wait()
        time.sleep(0.05)
        self.old_bcPort=Pyro4.config.NS_BCPORT
        self.old_nsPort=Pyro4.config.NS_PORT
        self.old_nsHost=Pyro4.config.NS_HOST
        Pyro4.config.NS_PORT=self.nsUri.port
        Pyro4.config.NS_HOST=myIpAddress
        Pyro4.config.NS_BCPORT=self.bcserver.getPort()
    def tearDown(self):
        time.sleep(0.01)
        self.nameserver.shutdown()
        self.bcserver.close()
        # self.daemonthread.join()
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.NS_HOST=self.old_nsHost
        Pyro4.config.NS_PORT=self.old_nsPort
        Pyro4.config.NS_BCPORT=self.old_bcPort
   
    def testLookupAndRegister(self):
        ns=Pyro4.naming.locateNS() # broadcast lookup
        self.assertTrue(isinstance(ns, Pyro4.core.Proxy))
        ns._pyroRelease()
        ns=Pyro4.naming.locateNS(self.nsUri.host) # normal lookup
        self.assertTrue(isinstance(ns, Pyro4.core.Proxy))
        uri=ns._pyroUri
        self.assertEqual("PYRO",uri.protocol)
        self.assertEqual(self.nsUri.host,uri.host)
        self.assertEqual(Pyro4.config.NS_PORT,uri.port)
        ns._pyroRelease()
        ns=Pyro4.naming.locateNS(self.nsUri.host,Pyro4.config.NS_PORT)
        uri=ns._pyroUri
        self.assertEqual("PYRO",uri.protocol)
        self.assertEqual(self.nsUri.host,uri.host)
        self.assertEqual(Pyro4.config.NS_PORT,uri.port)
        
        # check that we cannot register a stupid type
        self.assertRaises(TypeError, ns.register, "unittest.object1", 5555)
        # we can register str or URI, lookup always returns URI        
        ns.register("unittest.object2", "PYRO:55555@host.com:4444")
        self.assertEqual(Pyro4.core.URI("PYRO:55555@host.com:4444"), ns.lookup("unittest.object2"))
        ns.register("unittest.object3", Pyro4.core.URI("PYRO:66666@host.com:4444"))
        self.assertEqual(Pyro4.core.URI("PYRO:66666@host.com:4444"), ns.lookup("unittest.object3"))
        ns._pyroRelease()

    def testDaemonPyroObj(self):
        uri=self.nsUri
        uri.object=Pyro4.constants.DAEMON_NAME
        with Pyro4.core.Proxy(uri) as daemonobj:
            daemonobj.ping()
            daemonobj.registered()
            try:
                daemonobj.shutdown()
                self.fail("should not succeed to call unexposed method on daemon")
            except AttributeError:
                pass
        
    def testMulti(self):
        uristr=str(self.nsUri)
        p=Pyro4.core.Proxy(uristr)
        p._pyroBind()
        p._pyroRelease()
        uri=Pyro4.naming.resolve(uristr)
        p=Pyro4.core.Proxy(uri)
        p._pyroBind()
        p._pyroRelease()
        uri=Pyro4.naming.resolve(uristr)
        p=Pyro4.core.Proxy(uri)
        p._pyroBind()
        p._pyroRelease()
        uri=Pyro4.naming.resolve(uristr)
        p=Pyro4.core.Proxy(uri)
        p._pyroBind()
        p._pyroRelease()
        uri=Pyro4.naming.resolve(uristr)
        p=Pyro4.core.Proxy(uri)
        p._pyroBind()
        p._pyroRelease()
        uri=Pyro4.naming.resolve(uristr)
        p=Pyro4.core.Proxy(uri)
        p._pyroBind()
        p._pyroRelease()
        daemonUri="PYRO:"+Pyro4.constants.DAEMON_NAME+"@"+uri.location
        _=Pyro4.naming.resolve(daemonUri)
        _=Pyro4.naming.resolve(daemonUri)
        _=Pyro4.naming.resolve(daemonUri)
        _=Pyro4.naming.resolve(daemonUri)
        _=Pyro4.naming.resolve(daemonUri)
        _=Pyro4.naming.resolve(daemonUri)
        uri=Pyro4.naming.resolve(daemonUri)
        pyronameUri="PYRONAME:"+Pyro4.constants.NAMESERVER_NAME+"@"+uri.location
        _=Pyro4.naming.resolve(pyronameUri)
        _=Pyro4.naming.resolve(pyronameUri)
        _=Pyro4.naming.resolve(pyronameUri)
        _=Pyro4.naming.resolve(pyronameUri)
        _=Pyro4.naming.resolve(pyronameUri)
        _=Pyro4.naming.resolve(pyronameUri)
    
    def testResolve(self):
        resolved1=Pyro4.naming.resolve(Pyro4.core.URI("PYRO:12345@host.com:4444"))
        resolved2=Pyro4.naming.resolve("PYRO:12345@host.com:4444")
        self.assertTrue(type(resolved1) is Pyro4.core.URI)
        self.assertEqual(resolved1, resolved2)
        self.assertEqual("PYRO:12345@host.com:4444", str(resolved1))
        
        ns=Pyro4.naming.locateNS(self.nsUri.host, self.nsUri.port)
        host="["+self.nsUri.host+"]" if ":" in self.nsUri.host else self.nsUri.host
        uri=Pyro4.naming.resolve("PYRONAME:"+Pyro4.constants.NAMESERVER_NAME+"@"+host+":"+str(self.nsUri.port))
        self.assertEqual("PYRO",uri.protocol)
        self.assertEqual(self.nsUri.host,uri.host)
        self.assertEqual(Pyro4.constants.NAMESERVER_NAME,uri.object)
        self.assertEqual(uri, ns._pyroUri)
        ns._pyroRelease()

        # broadcast lookup
        self.assertRaises(NamingError, Pyro4.naming.resolve, "PYRONAME:unknown_object")
        uri=Pyro4.naming.resolve("PYRONAME:"+Pyro4.constants.NAMESERVER_NAME)
        self.assertEqual(Pyro4.core.URI,type(uri))
        self.assertEqual("PYRO",uri.protocol)

        # test some errors
        self.assertRaises(NamingError, Pyro4.naming.resolve, "PYRONAME:unknown_object@"+host)
        self.assertRaises(TypeError, Pyro4.naming.resolve, 999)  #wrong arg type


    def testRefuseDottedNames(self):
        with Pyro4.naming.locateNS(self.nsUri.host, self.nsUri.port) as ns:
            # the name server should never have dotted names enabled
            self.assertRaises(AttributeError, ns.namespace.keys)
            self.assertTrue(ns._pyroConnection is not None)
        self.assertTrue(ns._pyroConnection is None)


class NameServerTests0000(unittest.TestCase):
    def setUp(self):
        Pyro4.config.POLLTIMEOUT=0.1
        Pyro4.config.HMAC_KEY=b"testsuite"
        self.nsUri, self.nameserver, self.bcserver = Pyro4.naming.startNS(host="", port=0, bcport=0)
        host_check = self.nsUri.host
        if host_check == "0:0:0:0:0:0:0:0":   # this happens on jython
            host_check = "0.0.0.0"
        self.assertEqual("0.0.0.0", host_check, "for hostname \"\" the resulting ip must be 0.0.0.0 (or ipv6 equivalent)")
        self.assertTrue(self.bcserver is not None,"expected a BC server to be running")
        self.bcserver.runInThread()
        self.old_bcPort=Pyro4.config.NS_BCPORT
        self.old_nsPort=Pyro4.config.NS_PORT
        self.old_nsHost=Pyro4.config.NS_HOST
        Pyro4.config.NS_PORT=self.nsUri.port
        Pyro4.config.NS_HOST=self.nsUri.host
        Pyro4.config.NS_BCPORT=self.bcserver.getPort()
    def tearDown(self):
        time.sleep(0.01)
        self.nameserver.shutdown()
        self.bcserver.close()
        Pyro4.config.NS_HOST=self.old_nsHost
        Pyro4.config.NS_PORT=self.old_nsPort
        Pyro4.config.NS_BCPORT=self.old_bcPort
        Pyro4.config.HMAC_KEY=None

    @unittest.skipUnless(os.name!="java", "jython does strange things with bc server on 0.0.0.0 (it hangs)")
    def testBCLookup0000(self):
        ns=Pyro4.naming.locateNS()  # broadcast lookup
        self.assertTrue(isinstance(ns, Pyro4.core.Proxy))
        self.assertNotEqual("0.0.0.0", ns._pyroUri.host, "returned location must not be 0.0.0.0 when running on 0.0.0.0")
        ns._pyroRelease()


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_naming2
"""
Tests for the name server (offline/basic logic).

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys, select, os
import Pyro4.core
import Pyro4.naming
import Pyro4.nsc
import Pyro4.constants
import Pyro4.socketutil
from Pyro4.errors import NamingError,PyroError
from testsupport import *


class OfflineNameServerTests(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY=b"testsuite"
    def tearDown(self):
        Pyro4.config.HMAC_KEY=None
    def testRegister(self):
        ns=Pyro4.naming.NameServer()
        ns.ping()
        ns.register("test.object1","PYRO:000000@host.com:4444")
        ns.register("test.object2","PYRO:222222@host.com:4444")
        ns.register("test.object3","PYRO:333333@host.com:4444")
        self.assertEqual("PYRO:000000@host.com:4444",str(ns.lookup("test.object1")))
        ns.register("test.object1","PYRO:111111@host.com:4444")  # registering again should be ok by default
        self.assertEqual("PYRO:111111@host.com:4444",str(ns.lookup("test.object1")), "should be new uri")
        ns.register("test.sub.objectA",Pyro4.core.URI("PYRO:AAAAAA@host.com:4444"))
        ns.register("test.sub.objectB",Pyro4.core.URI("PYRO:BBBBBB@host.com:4444"))

        # if safe=True, a registration of an existing name shoould give a NamingError
        self.assertRaises(NamingError, ns.register, "test.object1", "PYRO:X@Y:5555", safe=True)

        self.assertRaises(TypeError, ns.register, None, None)
        self.assertRaises(TypeError, ns.register, 4444, 4444)
        self.assertRaises(TypeError, ns.register, "test.wrongtype", 4444)
        self.assertRaises(TypeError, ns.register, 4444, "PYRO:X@Y:5555")

        self.assertRaises(NamingError, ns.lookup, "unknown_object")
        
        uri=ns.lookup("test.object3")
        self.assertEqual(Pyro4.core.URI("PYRO:333333@host.com:4444"), uri)   # lookup always returns URI
        ns.remove("unknown_object")
        ns.remove("test.object1")
        ns.remove("test.object2")
        ns.remove("test.object3")
        all=ns.list()
        self.assertEqual(2, len(all))  # 2 leftover objects

        self.assertRaises(PyroError, ns.register, "test.nonurivalue", "THISVALUEISNOTANURI")

    def testRemove(self):
        ns=Pyro4.naming.NameServer()
        ns.register(Pyro4.constants.NAMESERVER_NAME, "PYRO:nameserver@host:555")
        for i in range(20):
            ns.register("test.%d" % i, "PYRO:obj@host:555")
        self.assertEqual(21, len(ns.list()))
        self.assertEqual(0, ns.remove("wrong"))
        self.assertEqual(0, ns.remove(prefix="wrong"))
        self.assertEqual(0, ns.remove(regex="wrong.*"))
        self.assertEqual(1, ns.remove("test.0"))
        self.assertEqual(20, len(ns.list()))
        self.assertEqual(11, ns.remove(prefix="test.1"))  # 1, 10-19
        self.assertEqual(8, ns.remove(regex=r"test\.."))  # 2-9
        self.assertEqual(1, len(ns.list()))
            
    def testRemoveProtected(self):
        ns=Pyro4.naming.NameServer()
        ns.register(Pyro4.constants.NAMESERVER_NAME, "PYRO:nameserver@host:555")
        self.assertEqual(0, ns.remove(Pyro4.constants.NAMESERVER_NAME))
        self.assertEqual(0, ns.remove(prefix="Pyro"))
        self.assertEqual(0, ns.remove(regex="Pyro.*"))
        self.assertTrue(Pyro4.constants.NAMESERVER_NAME in ns.list())

    def testUnicodeNames(self):
        ns=Pyro4.naming.NameServer()
        uri=Pyro4.core.URI("PYRO:unicode"+unichr(0x20ac)+"@host:5555")
        ns.register("unicodename"+unichr(0x20ac), uri)
        x=ns.lookup("unicodename"+unichr(0x20ac))
        self.assertEqual(uri, x)

    def testList(self):
        ns=Pyro4.naming.NameServer()
        ns.register("test.objects.1","PYRONAME:something1")
        ns.register("test.objects.2","PYRONAME:something2")
        ns.register("test.objects.3","PYRONAME:something3")
        ns.register("test.other.a","PYRONAME:somethingA")
        ns.register("test.other.b","PYRONAME:somethingB")
        ns.register("test.other.c","PYRONAME:somethingC")
        ns.register("entirely.else","PYRONAME:meh")
        objects=ns.list()
        self.assertEqual(7,len(objects))
        objects=ns.list(prefix="nothing")
        self.assertEqual(0,len(objects))
        objects=ns.list(prefix="test.")
        self.assertEqual(6,len(objects))
        objects=ns.list(regex=r".+other..")
        self.assertEqual(3,len(objects))
        self.assertTrue("test.other.a" in objects)
        self.assertEqual("PYRONAME:somethingA", objects["test.other.a"])
        objects=ns.list(regex=r"\d\d\d\d\d\d\d\d\d\d")
        self.assertEqual(0,len(objects))
        self.assertRaises(NamingError, ns.list, regex="((((((broken")

    def testRefuseDotted(self):
        try:
            Pyro4.config.DOTTEDNAMES=True
            _=Pyro4.naming.NameServerDaemon(port=0)
            self.fail("should refuse to create name server")
        except PyroError:
            pass
        finally:
            Pyro4.config.DOTTEDNAMES=False
        
    def testNameserverWithStmt(self):
        ns=Pyro4.naming.NameServerDaemon(port=0)
        self.assertFalse(ns.nameserver is None)
        ns.close()
        self.assertTrue(ns.nameserver is None)
        with Pyro4.naming.NameServerDaemon(port=0) as ns:
            self.assertFalse(ns.nameserver is None)
            pass
        self.assertTrue(ns.nameserver is None)
        try:
            with Pyro4.naming.NameServerDaemon(port=0) as ns:
                self.assertFalse(ns.nameserver is None)
                print(1//0) # cause an error
            self.fail("expected error")
        except ZeroDivisionError: 
            pass
        self.assertTrue(ns.nameserver is None)
        ns=Pyro4.naming.NameServerDaemon(port=0)
        with ns:
            pass
        try:
            with ns:
                pass
            self.fail("expected error")
        except PyroError:
            # you cannot re-use a name server object in multiple with statements
            pass
        ns.close()

    def testStartNSfunc(self):
        myIpAddress=Pyro4.socketutil.getIpAddress("", workaround127=True)
        uri1,ns1,bc1=Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0, enableBroadcast=False)
        uri2,ns2,bc2=Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0, enableBroadcast=True)
        self.assertTrue(isinstance(uri1, Pyro4.core.URI))
        self.assertTrue(isinstance(ns1, Pyro4.naming.NameServerDaemon))
        self.assertTrue(bc1 is None)
        self.assertTrue(isinstance(bc2, Pyro4.naming.BroadcastServer))
        sock=bc2.sock
        self.assertTrue(hasattr(sock,"fileno"))
        _=bc2.processRequest
        ns1.close()
        ns2.close()
        bc2.close()
    
    def testOwnloopBasics(self):
        myIpAddress=Pyro4.socketutil.getIpAddress("",workaround127=True)
        uri1,ns1,bc1=Pyro4.naming.startNS(host=myIpAddress, port=0, bcport=0, enableBroadcast=True)
        self.assertTrue(bc1.fileno() > 0)
        if Pyro4.socketutil.hasPoll:
            p=select.poll()
            if os.name=="java":
                # jython requires nonblocking sockets for poll
                ns1.sock.setblocking(False)
                bc1.sock.setblocking(False)
            for s in ns1.sockets:
                p.register(s, select.POLLIN)
            p.register(bc1.fileno(), select.POLLIN)
            p.poll(100)
            if hasattr(p,"close"):
                p.close()
        else:
            rs=[bc1]
            rs.extend(ns1.sockets)
            _,_,_ = Pyro4.socketutil.selectfunction(rs,[],[],0.1)
        ns1.close()
        bc1.close()

    def testNSmain(self):
        oldstdout=sys.stdout
        oldstderr=sys.stderr
        try:
            sys.stdout=StringIO()
            sys.stderr=StringIO()
            self.assertRaises(SystemExit, Pyro4.naming.main, ["--invalidarg"])
            self.assertTrue("no such option" in sys.stderr.getvalue())
            sys.stderr.truncate(0)
            sys.stdout.truncate(0)
            self.assertRaises(SystemExit, Pyro4.naming.main, ["-h"])
            self.assertTrue("show this help message" in sys.stdout.getvalue())
        finally:
            sys.stdout=oldstdout
            sys.stderr=oldstderr

    def testNSCmain(self):
        oldstdout=sys.stdout
        oldstderr=sys.stderr
        try:
            sys.stdout=StringIO()
            sys.stderr=StringIO()
            self.assertRaises(SystemExit, Pyro4.nsc.main, ["--invalidarg"])
            self.assertTrue("no such option" in sys.stderr.getvalue())
            sys.stderr.truncate(0)
            sys.stdout.truncate(0)
            self.assertRaises(SystemExit, Pyro4.nsc.main, ["-h"])
            self.assertTrue("show this help message" in sys.stdout.getvalue())
        finally:
            sys.stdout=oldstdout
            sys.stderr=oldstderr
            
    def testNSCfunctions(self):
        oldstdout=sys.stdout
        oldstderr=sys.stderr
        try:
            sys.stdout=StringIO()
            sys.stderr=StringIO()
            ns=Pyro4.naming.NameServer()
            Pyro4.nsc.handleCommand(ns, None, ["foo"])
            self.assertTrue(sys.stdout.getvalue().startswith("Error: KeyError "))
            Pyro4.nsc.handleCommand(ns, None, ["ping"])
            self.assertTrue(sys.stdout.getvalue().endswith("ping ok.\n"))
            Pyro4.nsc.handleCommand(ns, None, ["list"])
            self.assertTrue(sys.stdout.getvalue().endswith("END LIST \n"))
            Pyro4.nsc.handleCommand(ns, None, ["listmatching", "name.$"])
            self.assertTrue(sys.stdout.getvalue().endswith("END LIST - regex 'name.$'\n"))
            self.assertFalse("name1" in sys.stdout.getvalue())
            Pyro4.nsc.handleCommand(ns, None, ["register", "name1", "PYRO:obj1@hostname:9999"])
            self.assertTrue(sys.stdout.getvalue().endswith("Registered name1\n"))
            Pyro4.nsc.handleCommand(ns, None, ["remove", "name2"])
            self.assertTrue(sys.stdout.getvalue().endswith("Nothing removed\n"))
            Pyro4.nsc.handleCommand(ns, None, ["listmatching", "name.$"])
            self.assertTrue("name1 --> PYRO:obj1@hostname:9999" in sys.stdout.getvalue())
            #Pyro4.nsc.handleCommand(ns, None, ["removematching","name?"])
        finally:
            sys.stdout=oldstdout
            sys.stderr=oldstderr

    def testNAT(self):
        uri,ns,bc=Pyro4.naming.startNS(host="", port=0, enableBroadcast=True, nathost="nathosttest", natport=12345)
        self.assertEqual("nathosttest:12345", uri.location)
        self.assertEqual("nathosttest:12345", ns.uriFor("thing").location)
        self.assertNotEqual("nathosttest:12345", bc.nsUri.location, "broadcast location must not be the NAT location")
        ns.close()
        bc.close()


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_package
"""
Tests for the package structure and import names.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import Pyro4
import Pyro4.constants
import Pyro4.core
import Pyro4.errors
import Pyro4.naming
import Pyro4.nsc
import Pyro4.socketutil
import Pyro4.threadutil
import Pyro4.util
from testsupport import unittest

class TestPackage(unittest.TestCase):
    def testPyro4(self):
        self.assertEqual(Pyro4.core.Daemon, Pyro4.Daemon)
        self.assertEqual(Pyro4.core.Proxy, Pyro4.Proxy)
        self.assertEqual(Pyro4.core.URI, Pyro4.URI)
        self.assertEqual(Pyro4.core.callback, Pyro4.callback)
        self.assertEqual(Pyro4.core.async, Pyro4.async)
        self.assertEqual(Pyro4.core.batch, Pyro4.batch)
        self.assertEqual(Pyro4.naming.locateNS, Pyro4.locateNS)
        self.assertEqual(Pyro4.naming.resolve, Pyro4.resolve)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_serialize
"""
Tests for the data serializer.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import sys
import os
import copy
import pprint
import pickle
import Pyro4.util
import Pyro4.errors
import Pyro4.core
import Pyro4.futures
import Pyro4.message
from testsupport import *


class SerializeTests_pickle(unittest.TestCase):
    SERIALIZER="pickle"
    def setUp(self):
        self.previous_serializer=Pyro4.config.SERIALIZER
        Pyro4.config.SERIALIZER=self.SERIALIZER
        Pyro4.config.HMAC_KEY=b"testsuite"
        self.ser=Pyro4.util.get_serializer(Pyro4.config.SERIALIZER)
    def tearDown(self):
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.SERIALIZER=self.previous_serializer
        
    def testSerItself(self):
        s=Pyro4.util.get_serializer(Pyro4.config.SERIALIZER)
        p,_=self.ser.serializeData(s)
        s2=self.ser.deserializeData(p)
        self.assertEqual(s,s2)
        self.assertTrue(s==s2)
        self.assertFalse(s!=s2)

    def testSerUnicode(self):
        data = unicode("x")
        ser,_ = self.ser.serializeData(data)
        expected_type = str if sys.platform=="cli" else bytes   # ironpython serializes into str, not bytes... :(
        self.assertTrue(type(ser) is expected_type)
        ser,_ = self.ser.serializeCall(data, unicode("method"), [], {})
        self.assertTrue(type(ser) is expected_type)

    def testSerCompression(self):
        d1,c1=self.ser.serializeData("small data", compress=True)
        d2,c2=self.ser.serializeData("small data", compress=False)
        self.assertFalse(c1)
        self.assertEqual(d1,d2)
        bigdata="x"*1000
        d1,c1=self.ser.serializeData(bigdata, compress=False)
        d2,c2=self.ser.serializeData(bigdata, compress=True)
        self.assertFalse(c1)
        self.assertTrue(c2)
        self.assertTrue(len(d2) < len(d1))
        self.assertEqual(bigdata, self.ser.deserializeData(d1, compressed=False))
        self.assertEqual(bigdata, self.ser.deserializeData(d2, compressed=True))

    def testSerErrors(self):
        e1=Pyro4.errors.NamingError(unicode("x"))
        e1._pyroTraceback = ["this is the remote traceback"]
        orig_e = copy.copy(e1)
        e2=Pyro4.errors.PyroError(unicode("x"))
        e3=Pyro4.errors.ProtocolError(unicode("x"))
        if sys.platform=="cli":
            Pyro4.util.fixIronPythonExceptionForPickle(e1, True)
        p,_=self.ser.serializeData(e1)
        e=self.ser.deserializeData(p)
        if sys.platform=="cli":
            Pyro4.util.fixIronPythonExceptionForPickle(e, False)
        self.assertTrue(isinstance(e, Pyro4.errors.NamingError))
        self.assertEqual(repr(orig_e), repr(e))
        self.assertEqual(["this is the remote traceback"], e._pyroTraceback, "remote traceback info should be present")
        p,_=self.ser.serializeData(e2)
        e=self.ser.deserializeData(p)
        self.assertTrue(isinstance(e, Pyro4.errors.PyroError))
        self.assertEqual(repr(e2), repr(e))
        p,_=self.ser.serializeData(e3)
        e=self.ser.deserializeData(p)
        self.assertTrue(isinstance(e, Pyro4.errors.ProtocolError))
        self.assertEqual(repr(e3), repr(e))
    
    def testSerializeExceptionWithAttr(self):
        ex=ZeroDivisionError("test error")
        ex._pyroTraceback=["test traceback payload"]
        Pyro4.util.fixIronPythonExceptionForPickle(ex,True) # hack for ironpython
        data,compressed=self.ser.serializeData(ex)
        ex2=self.ser.deserializeData(data,compressed)
        Pyro4.util.fixIronPythonExceptionForPickle(ex2,False) # hack for ironpython
        self.assertEqual(ZeroDivisionError, type(ex2))
        self.assertTrue(hasattr(ex2, "_pyroTraceback"))
        self.assertEqual(["test traceback payload"], ex2._pyroTraceback)

    def testSerCoreOffline(self):
        uri=Pyro4.core.URI("PYRO:9999@host.com:4444")
        p,_=self.ser.serializeData(uri)
        uri2=self.ser.deserializeData(p)
        self.assertEqual(uri, uri2)
        self.assertEqual("PYRO",uri2.protocol)
        self.assertEqual("9999",uri2.object)
        self.assertEqual("host.com:4444",uri2.location)
        self.assertEqual(4444, uri2.port)
        self.assertEqual(None, uri2.sockname)

        uri=Pyro4.core.URI("PYRO:12345@./u:/tmp/socketname")
        p,_=self.ser.serializeData(uri)
        uri2=self.ser.deserializeData(p)
        self.assertEqual(uri, uri2)
        self.assertEqual("PYRO",uri2.protocol)
        self.assertEqual("12345",uri2.object)
        self.assertEqual("./u:/tmp/socketname",uri2.location)
        self.assertEqual(None, uri2.port)
        self.assertEqual("/tmp/socketname", uri2.sockname)

        proxy=Pyro4.core.Proxy("PYRO:9999@host.com:4444")
        proxy._pyroTimeout=42
        self.assertTrue(proxy._pyroConnection is None)
        p,_=self.ser.serializeData(proxy)
        proxy2=self.ser.deserializeData(p)
        self.assertTrue(proxy._pyroConnection is None)
        self.assertTrue(proxy2._pyroConnection is None)
        self.assertEqual(proxy2._pyroUri, proxy._pyroUri)
        self.assertEqual(42, proxy2._pyroTimeout)

    def testNested(self):
        if self.SERIALIZER=="marshal":
            self.skipTest("marshal can't serialize custom objects")
        uri1=Pyro4.core.URI("PYRO:1111@host.com:111")
        uri2=Pyro4.core.URI("PYRO:2222@host.com:222")
        _=self.ser.serializeData(uri1)
        data=[uri1, uri2]
        p,_=self.ser.serializeData(data)
        [u1, u2]=self.ser.deserializeData(p)
        self.assertEqual(uri1, u1)
        self.assertEqual(uri2, u2)

    def testSerDaemonHack(self):
        # This tests the hack that a Daemon should be serializable,
        # but only to support serializing Pyro objects.
        # The serialized form of a Daemon should be empty (and thus, useless)
        with Pyro4.core.Daemon(port=0) as daemon:
            d,_=self.ser.serializeData(daemon)
            d2=self.ser.deserializeData(d)
            self.assertTrue(len(d2.__dict__)==0, "deserialized daemon should be empty")
            try:
                Pyro4.config.AUTOPROXY=False
                obj=pprint.PrettyPrinter(stream="dummy", width=42)
                obj.name="hello"
                daemon.register(obj)
                o,_=self.ser.serializeData(obj)
                if self.SERIALIZER=="pickle":
                    # only pickle can deserialize the PrettyPrinter class without the need of explicit deserialization function
                    o2=self.ser.deserializeData(o)
                    self.assertEqual("hello", o2.name)
                    self.assertEqual(42, o2._width)
            finally:
                Pyro4.config.AUTOPROXY=True

    def testPyroClasses(self):
        uri = Pyro4.core.URI("PYRO:object@host:4444")
        s, c = self.ser.serializeData(uri)
        x = self.ser.deserializeData(s, c)
        self.assertIsInstance(x, Pyro4.core.URI)
        self.assertEqual(uri, x)
        uri=Pyro4.core.URI("PYRO:12345@./u:/tmp/socketname")
        s, c = self.ser.serializeData(uri)
        x = self.ser.deserializeData(s, c)
        self.assertIsInstance(x, Pyro4.core.URI)
        self.assertEqual(uri, x)
        proxy=Pyro4.core.Proxy(uri)
        s, c = self.ser.serializeData(proxy)
        x = self.ser.deserializeData(s, c)
        self.assertIsInstance(x, Pyro4.core.Proxy)
        self.assertEqual(proxy._pyroUri, x._pyroUri)
        self.assertTrue(x._)
        daemon=Pyro4.core.Daemon()
        s, c = self.ser.serializeData(daemon)
        x = self.ser.deserializeData(s, c)
        self.assertIsInstance(x, Pyro4.core.Daemon)
        self.assertTrue(isinstance(x, Pyro4.core.Daemon))
        wrapper = Pyro4.futures._ExceptionWrapper(ZeroDivisionError("divided by zero"))
        s, c = self.ser.serializeData(wrapper)
        x = self.ser.deserializeData(s, c)
        self.assertIsInstance(x, Pyro4.futures._ExceptionWrapper)
        self.assertEqual("divided by zero", str(x.exception))

    def testAutoProxy(self):
        if self.SERIALIZER=="marshal":
            self.skipTest("marshal can't serialize custom objects")
        self.ser.register_type_replacement(MyThing2, Pyro4.core.pyroObjectToAutoProxy)
        t1 = MyThing2("1")
        t2 = MyThing2("2")
        with Pyro4.core.Daemon() as d:
            d.register(t1, "thingy1")
            d.register(t2, "thingy2")
            data = [t1, ["apple", t2] ]
            s, c = self.ser.serializeData(data)
            data = self.ser.deserializeData(s, c)
            self.assertEqual("apple", data[1][0])
            p1 = data[0]
            p2 = data[1][1]
            self.assertIsInstance(p1, Pyro4.core.Proxy)
            self.assertIsInstance(p2, Pyro4.core.Proxy)
            self.assertEqual("thingy1", p1._pyroUri.object)
            self.assertEqual("thingy2", p2._pyroUri.object)

    def testCustomClassFail(self):
        if self.SERIALIZER=="pickle":
            self.skipTest("pickle simply serializes custom classes")
        o = pprint.PrettyPrinter(stream="dummy", width=42)
        s, c = self.ser.serializeData(o)
        try:
            x = self.ser.deserializeData(s, c)
            self.fail("error expected, shouldn't deserialize unknown class")
        except Pyro4.errors.ProtocolError:
            pass

    def testCustomClassOk(self):
        if self.SERIALIZER=="pickle":
            self.skipTest("pickle simply serializes custom classes just fine")
        o = MyThing2("test")
        Pyro4.util.SerializerBase.register_class_to_dict(MyThing2, mything_dict)
        Pyro4.util.SerializerBase.register_dict_to_class("CUSTOM-Mythingymabob", mything_creator)
        s, c = self.ser.serializeData(o)
        o2 = self.ser.deserializeData(s, c)
        self.assertIsInstance(o2, MyThing2)
        self.assertEqual("test", o2.name)
        # unregister the deserializer
        Pyro4.util.SerializerBase.unregister_dict_to_class("CUSTOM-Mythingymabob")
        try:
            self.ser.deserializeData(s, c)
            self.fail("must fail")
        except Pyro4.errors.ProtocolError:
            pass  # ok
        # unregister the serializer
        Pyro4.util.SerializerBase.unregister_class_to_dict(MyThing2)
        s, c = self.ser.serializeData(o)
        try:
            self.ser.deserializeData(s, c)
            self.fail("must fail")
        except Pyro4.errors.ProtocolError as x:
            msg = str(x)
            self.assertTrue(msg in ["unsupported serialized class: testsupport.MyThing2",
                                    "unsupported serialized class: PyroTests.testsupport.MyThing2"])

    def testData(self):
        data = [42, "hello"]
        ser, compressed = self.ser.serializeData(data)
        expected_type = str if sys.platform=="cli" else bytes   # ironpython serializes into str, not bytes... :(
        self.assertTrue(type(ser) is expected_type)
        self.assertFalse(compressed)
        data2 = self.ser.deserializeData(ser, compressed=False)
        self.assertEqual(data, data2)

    def testCallPlain(self):
        ser, compressed = self.ser.serializeCall("object", "method", "vargs", "kwargs")
        self.assertFalse(compressed)
        obj, method, vargs, kwargs = self.ser.deserializeCall(ser, compressed=False)
        self.assertEqual("object", obj)
        self.assertEqual("method", method)
        self.assertEqual("vargs", vargs)
        self.assertEqual("kwargs", kwargs)

    def testCallPyroObjAsArg(self):
        if self.SERIALIZER=="marshal":
            self.skipTest("marshal can't serialize custom objects")
        uri = Pyro4.core.URI("PYRO:555@localhost:80")
        ser, compressed = self.ser.serializeCall("object", "method", [uri], {"thing": uri})
        self.assertFalse(compressed)
        obj, method, vargs, kwargs = self.ser.deserializeCall(ser, compressed=False)
        self.assertEqual("object", obj)
        self.assertEqual("method", method)
        self.assertEqual([uri], vargs)
        self.assertEqual({"thing": uri}, kwargs)

    def testCallCustomObjAsArg(self):
        if self.SERIALIZER=="marshal":
            self.skipTest("marshal can't serialize custom objects")
        e = ZeroDivisionError("hello")
        ser, compressed = self.ser.serializeCall("object", "method", [e], {"thing": e})
        self.assertFalse(compressed)
        obj, method, vargs, kwargs = self.ser.deserializeCall(ser, compressed=False)
        self.assertEqual("object", obj)
        self.assertEqual("method", method)
        self.assertTrue(isinstance(vargs, list))
        self.assertTrue(isinstance(vargs[0], ZeroDivisionError))
        self.assertEqual("hello", str(vargs[0]))
        self.assertTrue(isinstance(kwargs["thing"], ZeroDivisionError))
        self.assertEqual("hello", str(kwargs["thing"]))

    def testSerializeException(self):
        e = ZeroDivisionError()
        d, c = self.ser.serializeData(e)
        e2 = self.ser.deserializeData(d, c)
        self.assertTrue(isinstance(e2, ZeroDivisionError))
        self.assertEqual("", str(e2))
        e = ZeroDivisionError("hello")
        d, c = self.ser.serializeData(e)
        e2 = self.ser.deserializeData(d, c)
        self.assertTrue(isinstance(e2, ZeroDivisionError))
        self.assertEqual("hello", str(e2))
        e = ZeroDivisionError("hello", 42)
        d, c = self.ser.serializeData(e)
        e2 = self.ser.deserializeData(d, c)
        self.assertTrue(isinstance(e2, ZeroDivisionError))
        self.assertTrue(str(e2) in ("('hello', 42)", "(u'hello', 42)"))
        e.custom_attribute = 999
        if sys.platform=="cli":
            Pyro4.util.fixIronPythonExceptionForPickle(e, True)
        ser, compressed = self.ser.serializeData(e)
        e2 = self.ser.deserializeData(ser, compressed)
        if sys.platform=="cli":
            Pyro4.util.fixIronPythonExceptionForPickle(e2, False)
        self.assertTrue(isinstance(e2, ZeroDivisionError))
        self.assertTrue(str(e2) in ("('hello', 42)", "(u'hello', 42)"))
        self.assertEqual(999, e2.custom_attribute)

    def testSerializeSpecialException(self):
        self.assertTrue("GeneratorExit" in Pyro4.util.all_exceptions)
        e = GeneratorExit()
        d, c = self.ser.serializeData(e)
        e2 = self.ser.deserializeData(d, c)
        self.assertTrue(isinstance(e2, GeneratorExit))

    def testRecreateClasses(self):
        self.assertEqual([1,2,3], self.ser.recreate_classes([1,2,3]))
        d = {"__class__": "invalid" }
        try:
            self.ser.recreate_classes(d)
            self.fail("error expected")
        except Pyro4.errors.ProtocolError:
            pass  # ok
        d = {"__class__": "Pyro4.core.URI", "state": ['PYRO', '555', None, 'localhost', 80] }
        uri = self.ser.recreate_classes(d)
        self.assertEqual(Pyro4.core.URI("PYRO:555@localhost:80"), uri)
        number, uri = self.ser.recreate_classes([1,{"uri": d}])
        self.assertEqual(1, number)
        self.assertEqual(Pyro4.core.URI("PYRO:555@localhost:80"), uri["uri"])

    def testProtocolVersion(self):
        self.assertGreaterEqual(Pyro4.config.PICKLE_PROTOCOL_VERSION, 2)
        self.assertEqual(pickle.HIGHEST_PROTOCOL, Pyro4.config.PICKLE_PROTOCOL_VERSION)


class SerializeTests_serpent(SerializeTests_pickle):
    SERIALIZER = "serpent"
    @unittest.skip("pickle specific")
    def testProtocolVersion(self):
        pass

class SerializeTests_json(SerializeTests_pickle):
    SERIALIZER = "json"
    @unittest.skip("pickle specific")
    def testProtocolVersion(self):
        pass


if os.name!="java":
    # The marshal serializer is not working correctly under jython,
    # see http://bugs.jython.org/issue2077
    # So we only include this when not running jython
    class SerializeTests_marshal(SerializeTests_pickle):
        SERIALIZER="marshal"


class GenericTests(unittest.TestCase):
    def testSerializersAvailable(self):
        Pyro4.util.get_serializer("pickle")
        Pyro4.util.get_serializer("marshal")
        try:
            import json
            Pyro4.util.get_serializer("json")
        except ImportError:
            pass
        try:
            import serpent
            Pyro4.util.get_serializer("serpent")
        except ImportError:
            pass

    def testSerializersAvailableById(self):
        Pyro4.util.get_serializer_by_id(Pyro4.message.SERIALIZER_PICKLE)
        Pyro4.util.get_serializer_by_id(Pyro4.message.SERIALIZER_MARSHAL)
        self.assertRaises(Pyro4.errors.ProtocolError, lambda: Pyro4.util.get_serializer_by_id(9999999))

    def testDictClassFail(self):
        o = pprint.PrettyPrinter(stream="dummy", width=42)
        d = Pyro4.util.SerializerBase.class_to_dict(o)
        self.assertEqual(42, d["_width"])
        self.assertEqual("pprint.PrettyPrinter", d["__class__"])
        try:
            _ = Pyro4.util.SerializerBase.dict_to_class(d)
            self.fail("error expected")
        except Pyro4.errors.ProtocolError:
            pass

    def testDictException(self):
        x = ZeroDivisionError("hello", 42)
        expected = {
            "__class__": None,
            "args": ("hello", 42),
            "attributes": {}
        }
        if sys.version_info < (3, 0):
            expected["__class__"] = "exceptions.ZeroDivisionError"
        else:
            expected["__class__"] = "builtins.ZeroDivisionError"
        d = Pyro4.util.SerializerBase.class_to_dict(x)
        self.assertEqual(expected, d)
        x.custom_attribute = 999
        expected["attributes"] = {"custom_attribute": 999}
        d = Pyro4.util.SerializerBase.class_to_dict(x)
        self.assertEqual(expected, d)

    def testDictClassOk(self):
        uri = Pyro4.core.URI("PYRO:object@host:4444")
        d = Pyro4.util.SerializerBase.class_to_dict(uri)
        self.assertEqual("Pyro4.core.URI", d["__class__"])
        self.assertTrue("state" in d)
        x = Pyro4.util.SerializerBase.dict_to_class(d)
        self.assertIsInstance(x, Pyro4.core.URI)
        self.assertEqual(uri, x)
        self.assertEqual(4444, x.port)
        uri = Pyro4.core.URI("PYRO:12345@./u:/tmp/socketname")
        d = Pyro4.util.SerializerBase.class_to_dict(uri)
        self.assertEqual("Pyro4.core.URI", d["__class__"])
        self.assertTrue("state" in d)
        x = Pyro4.util.SerializerBase.dict_to_class(d)
        self.assertIsInstance(x, Pyro4.core.URI)
        self.assertEqual(uri, x)
        self.assertEqual("/tmp/socketname", x.sockname)

    def testCustomDictClass(self):
        o = MyThing2("test")
        Pyro4.util.SerializerBase.register_class_to_dict(MyThing2, mything_dict)
        Pyro4.util.SerializerBase.register_dict_to_class("CUSTOM-Mythingymabob", mything_creator)
        d = Pyro4.util.SerializerBase.class_to_dict(o)
        self.assertEqual("CUSTOM-Mythingymabob", d["__class__"])
        self.assertEqual("test", d["name"])
        x = Pyro4.util.SerializerBase.dict_to_class(d)
        self.assertIsInstance(x, MyThing2)
        self.assertEqual("test", x.name)
        # unregister the conversion functions and try again
        Pyro4.util.SerializerBase.unregister_class_to_dict(MyThing2)
        Pyro4.util.SerializerBase.unregister_dict_to_class("CUSTOM-Mythingymabob")
        d_orig = Pyro4.util.SerializerBase.class_to_dict(o)
        clsname = d_orig["__class__"]
        self.assertTrue(clsname.endswith("testsupport.MyThing2"))
        try:
            _ = Pyro4.util.SerializerBase.dict_to_class(d)
            self.fail("should crash")
        except Pyro4.errors.ProtocolError:
            pass  # ok


def mything_dict(obj):
    return {
        "__class__": "CUSTOM-Mythingymabob",
        "name": obj.name
    }


def mything_creator(classname, d):
    assert classname == "CUSTOM-Mythingymabob"
    assert d["__class__"] == "CUSTOM-Mythingymabob"
    return MyThing2(d["name"])


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server
"""
Tests for a running Pyro server, without timeouts.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement
import Pyro4.core
import Pyro4.errors
import Pyro4.util
import Pyro4.message
import time, os, sys, platform
from Pyro4 import threadutil
from testsupport import *


class MyThing(object):
    def __init__(self):
        self.dictionary={"number":42}
    def getDict(self):
        return self.dictionary
    def multiply(self,x,y):
        return x*y
    def divide(self,x,y):
        return x//y
    def ping(self):
        pass
    def echo(self, obj):
        return obj
    def delay(self, delay):
        time.sleep(delay)
        return "slept %d seconds" % delay
    def delayAndId(self, delay, id):
        time.sleep(delay)
        return "slept for "+str(id)
    def testargs(self,x,*args,**kwargs):
        if kwargs:
            key=list(kwargs.keys())[0]
        return [x, list(args), kwargs]    # don't return tuples, this enables us to test json serialization as well.
    def nonserializableException(self):
        raise NonserializableError(("xantippe", lambda x: 0))


class DaemonLoopThread(threadutil.Thread):
    def __init__(self, pyrodaemon):
        super(DaemonLoopThread,self).__init__()
        self.setDaemon(True)
        self.pyrodaemon=pyrodaemon
        self.running=threadutil.Event()
        self.running.clear()
    def run(self):
        self.running.set()
        try:
            self.pyrodaemon.requestLoop()
        except Pyro4.errors.CommunicationError:
            pass    # ignore pyro communication errors


class DaemonWithSabotagedHandshake(Pyro4.core.Daemon):
    def _handshake(self, conn):
        # a bit of a hack, overriding this internal method to return a CONNECTFAIL...
        serializer = Pyro4.util.get_serializer("marshal")
        data, _ = serializer.serializeData("rigged connection failure", compress=False)
        msg = Pyro4.message.Message(Pyro4.message.MSG_CONNECTFAIL, data, serializer.serializer_id, 0, 1)
        conn.send(msg.to_bytes())
        return False
    
class ServerTestsBrokenHandshake(unittest.TestCase):
    def setUp(self):
        Pyro4.config.HMAC_KEY=b"testsuite"
        Pyro4.config.SERIALIZERS_ACCEPTED.add("pickle")
        self.daemon=DaemonWithSabotagedHandshake(port=0)
        obj=MyThing()
        uri=self.daemon.register(obj, "something")
        self.objectUri=uri
        self.daemonthread=DaemonLoopThread(self.daemon)
        self.daemonthread.start()
        self.daemonthread.running.wait()
        time.sleep(0.05)
    def tearDown(self):
        time.sleep(0.05)
        self.daemon.shutdown()
        self.daemonthread.join()
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")
    def testDaemonConnectFail(self):
        # check what happens when the daemon responds with a failed connection msg
        with Pyro4.Proxy(self.objectUri) as p:
            try:
                p.ping()
                self.fail("expected CommunicationError")
            except Pyro4.errors.CommunicationError:
                xv=sys.exc_info()[1]
                message=str(xv)
                self.assertTrue("reason:" in message)
                self.assertTrue("rigged connection failure" in message)

class ServerTestsOnce(unittest.TestCase):
    """tests that are fine to run with just a single server type"""
    def setUp(self):
        Pyro4.config.HMAC_KEY=b"testsuite"
        Pyro4.config.SERIALIZERS_ACCEPTED.add("pickle")
        self.daemon=Pyro4.core.Daemon(port=0)
        obj=MyThing()
        uri=self.daemon.register(obj, "something")
        self.objectUri=uri
        self.daemonthread=DaemonLoopThread(self.daemon)
        self.daemonthread.start()
        self.daemonthread.running.wait()
        time.sleep(0.05)
    def tearDown(self):
        time.sleep(0.05)
        if self.daemon is not None:
            self.daemon.shutdown()
            self.daemonthread.join()
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")

    def testPingMessage(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            p._pyroBind()
            conn = p._pyroConnection
            msg = Pyro4.message.Message(Pyro4.message.MSG_PING, b"something", 42, 0, 999)
            conn.send(msg.to_bytes())
            msg = Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_PING])
            self.assertEqual(Pyro4.message.MSG_PING, msg.type)
            self.assertEqual(999, msg.seq)
            self.assertEqual(b"pong", msg.data)

    def testNoDottedNames(self):
        Pyro4.config.DOTTEDNAMES=False
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertEqual(55,p.multiply(5,11))
            x=p.getDict()
            self.assertEqual({"number":42}, x)
            try:
                p.dictionary.update({"more":666})     # should fail with DOTTEDNAMES=False (the default)
                self.fail("expected AttributeError")
            except AttributeError:
                pass
            x=p.getDict()
            self.assertEqual({"number":42}, x)

    def testSomeArgumentTypes(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertEqual([1,[],{}], p.testargs(1))
            self.assertEqual([1,[2,3],{'a':4}], p.testargs(1,2,3,a=4))
            self.assertEqual([1,[],{'a':2}], p.testargs(1, **{'a':2}))

    @unittest.skipUnless(sys.version_info>=(2,6,5), "unicode kwargs needs 2.6.5 or newer")
    def testUnicodeKwargs(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertEqual([1,[],{unichr(65):2}], p.testargs(1, **{unichr(65):2}))
            result=p.testargs(unichr(0x20ac), **{unichr(0x20ac):2})
            self.assertEqual(result[0], unichr(0x20ac))
            key=list(result[2].keys())[0]
            self.assertTrue(type(key) is unicode)
            self.assertEqual(key, unichr(0x20ac))

    def testDottedNames(self):
        try:
            Pyro4.config.DOTTEDNAMES=True
            with Pyro4.core.Proxy(self.objectUri) as p:
                self.assertEqual(55,p.multiply(5,11))
                x=p.getDict()
                self.assertEqual({"number":42}, x)
                p.dictionary.update({"more":666})    # updating it remotely should work with DOTTEDNAMES=True
                x=p.getDict()
                self.assertEqual({"number":42, "more":666}, x)  # eek, it got updated!
        finally:
            Pyro4.config.DOTTEDNAMES=False

    def testNormalProxy(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertEqual(42,p.multiply(7,6))

    def testExceptions(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            try:
                p.divide(1,0)
                self.fail("should crash")
            except ZeroDivisionError:
                pass
            try:
                p.multiply("a", "b")
                self.fail("should crash")
            except TypeError:
                pass

    def testNonserializableException_other(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            try:
                p.nonserializableException()
                self.fail("should crash")
            except Exception:
                xt, xv, tb = sys.exc_info()
                self.assertTrue(issubclass(xt, Pyro4.errors.PyroError))
                tblines = "\n".join(Pyro4.util.getPyroTraceback())
                self.assertTrue("unsupported serialized class" in tblines)

    def testNonserializableException_pickle(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            Pyro4.config.SERIALIZER = "pickle"
            try:
                p.nonserializableException()
                self.fail("should crash")
            except Exception:
                xt, xv, tb = sys.exc_info()
                self.assertTrue(issubclass(xt, Pyro4.errors.PyroError))
                tblines = "\n".join(Pyro4.util.getPyroTraceback())
                self.assertTrue("PyroError: Error serializing exception" in tblines)
                s1 = "Original exception: <class 'testsupport.NonserializableError'>:"
                s2 = "Original exception: <class 'PyroTests.testsupport.NonserializableError'>:"
                self.assertTrue(s1 in tblines or s2 in tblines)
                self.assertTrue("raise NonserializableError((\"xantippe" in tblines)
            finally:
                Pyro4.config.SERIALIZER="serpent"

    def testBatchProxy(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            batch=Pyro4.batch(p)
            self.assertEqual(None,batch.multiply(7,6))
            self.assertEqual(None,batch.divide(999,3))
            self.assertEqual(None,batch.ping())
            self.assertEqual(None,batch.divide(999,0))      # force an exception here
            self.assertEqual(None,batch.multiply(3,4))      # this call should not be performed after the error
            results=batch()
            self.assertEqual(42,next(results))
            self.assertEqual(333,next(results))
            self.assertEqual(None,next(results))
            self.assertRaises(ZeroDivisionError, next, results)     # 999//0 should raise this error
            self.assertRaises(StopIteration, next, results)     # no more results should be available after the error

    def testAsyncProxy(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            async=Pyro4.async(p)
            begin=time.time()
            result=async.delayAndId(1,42)
            duration=time.time()-begin
            self.assertTrue(duration<0.1)
            self.assertFalse(result.ready)
            self.assertFalse(result.wait(0.5))    # not available within 0.5 sec
            self.assertEqual("slept for 42",result.value)
            self.assertTrue(result.ready)
            self.assertTrue(result.wait())

    def testAsyncProxyCallchain(self):
        class FuncHolder(object):
            count=AtomicCounter()
            def function(self, value, increase=1):
                self.count.incr()
                return value+increase
        with Pyro4.core.Proxy(self.objectUri) as p:
            async=Pyro4.async(p)
            holder=FuncHolder()
            begin=time.time()
            result=async.multiply(2,3)
            result.then(holder.function, increase=10) \
                  .then(holder.function, increase=5) \
                  .then(holder.function)
            duration=time.time()-begin
            self.assertTrue(duration<0.1)
            value=result.value
            self.assertTrue(result.ready)
            self.assertEqual(22,value)
            self.assertEqual(3,holder.count.value())

    def testBatchOneway(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            batch=Pyro4.batch(p)
            self.assertEqual(None,batch.multiply(7,6))
            self.assertEqual(None,batch.delay(1))           # a delay shouldn't matter with oneway
            self.assertEqual(None,batch.multiply(3,4))
            begin=time.time()
            results=batch(oneway=True)
            duration=time.time()-begin
            self.assertTrue(duration<0.1,"oneway batch with delay should return almost immediately")
            self.assertEqual(None,results)

    def testBatchAsync(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            batch=Pyro4.batch(p)
            self.assertEqual(None,batch.multiply(7,6))
            self.assertEqual(None,batch.delay(1))           # a delay shouldn't matter with async
            self.assertEqual(None,batch.multiply(3,4))
            begin=time.time()
            asyncresult=batch(async=True)
            duration=time.time()-begin
            self.assertTrue(duration<0.1,"async batch with delay should return almost immediately")
            results=asyncresult.value
            self.assertEqual(42,next(results))
            self.assertEqual("slept 1 seconds",next(results))
            self.assertEqual(12,next(results))
            self.assertRaises(StopIteration, next, results)     # no more results should be available

    def testBatchAsyncCallchain(self):
        class FuncHolder(object):
            count=AtomicCounter()
            def function(self, values):
                result=[value+1 for value in values]
                self.count.incr()
                return result
        with Pyro4.core.Proxy(self.objectUri) as p:
            batch=Pyro4.batch(p)
            self.assertEqual(None,batch.multiply(7,6))
            self.assertEqual(None,batch.multiply(3,4))
            result=batch(async=True)
            holder=FuncHolder()
            result.then(holder.function).then(holder.function)
            value=result.value
            self.assertTrue(result.ready)
            self.assertEqual([44,14],value)
            self.assertEqual(2,holder.count.value())

    def testPyroTracebackNormal(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            try:
                p.divide(999,0)  # force error here
                self.fail("expected error")
            except ZeroDivisionError:
                # going to check if the magic pyro traceback attribute is available for batch methods too
                tb="".join(Pyro4.util.getPyroTraceback())
                self.assertTrue("Remote traceback:" in tb)  # validate if remote tb is present
                self.assertTrue("ZeroDivisionError" in tb)  # the error
                self.assertTrue("return x//y" in tb)  # the statement

    def testPyroTracebackBatch(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            batch=Pyro4.batch(p)
            self.assertEqual(None,batch.divide(999,0))      # force an exception here
            results=batch()
            try:
                next(results)
                self.fail("expected error")
            except ZeroDivisionError:
                # going to check if the magic pyro traceback attribute is available for batch methods too
                tb="".join(Pyro4.util.getPyroTraceback())
                self.assertTrue("Remote traceback:" in tb)  # validate if remote tb is present
                self.assertTrue("ZeroDivisionError" in tb)  # the error
                self.assertTrue("return x//y" in tb)  # the statement
            self.assertRaises(StopIteration, next, results)     # no more results should be available after the error

    def testAutoProxy(self):
        obj=MyThing2()
        Pyro4.config.SERIALIZER="pickle"
        try:
            with Pyro4.core.Proxy(self.objectUri) as p:
                Pyro4.config.AUTOPROXY=False   # make sure autoproxy is disabled
                result=p.echo(obj)
                self.assertTrue(isinstance(result,MyThing2))
                self.daemon.register(obj)
                result=p.echo(obj)
                self.assertTrue(isinstance(result,MyThing2), "with autoproxy off the object should be an instance of the class")
                self.daemon.unregister(obj)
                result=p.echo(obj)
                self.assertTrue(isinstance(result,MyThing2), "serialized object must still be normal object")
                Pyro4.config.AUTOPROXY=True   # make sure autoproxying is enabled
                result=p.echo(obj)
                self.assertTrue(isinstance(result,MyThing2), "non-pyro object must be returned as normal class")
                self.daemon.register(obj)
                result=p.echo(obj)
                self.assertTrue(isinstance(result, Pyro4.core.Proxy),"serialized pyro object must be a proxy")
                self.daemon.unregister(obj)
                result=p.echo(obj)
                self.assertTrue(isinstance(result,MyThing2), "unregistered pyro object must be normal class again")
                # note: the custom serializer may still be active but it should be smart enough to see
                # that the object is no longer a pyro object, and therefore, no proxy should be created.
        finally:
            Pyro4.config.AUTOPROXY=True
            Pyro4.config.SERIALIZER="serpent"

    def testConnectOnce(self):
        with Pyro4.core.Proxy(self.objectUri) as proxy:
            self.assertTrue(proxy._pyroBind(), "first bind should always connect")
            self.assertFalse(proxy._pyroBind(), "second bind should not connect again")

    def testConnectingThreads(self):
        class ConnectingThread(threadutil.Thread):
            new_connections=AtomicCounter()
            def __init__(self, proxy, event):
                threadutil.Thread.__init__(self)
                self.proxy=proxy
                self.event=event
                self.setDaemon(True)
                self.new_connections.reset()
            def run(self):
                self.event.wait()
                if self.proxy._pyroBind():
                    ConnectingThread.new_connections.incr()     # 1 more new connection done
        with Pyro4.core.Proxy(self.objectUri) as proxy:
            event = threadutil.Event()
            threads = [ConnectingThread(proxy, event) for _ in range(20)]
            for t in threads:
                t.start()
            event.set()
            for t in threads:
                t.join()
            self.assertEqual(1, ConnectingThread.new_connections.value())  # proxy shared among threads must still have only 1 connect done

    def testMaxMsgSize(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            bigobject = [42] * 1000
            result = p.echo(bigobject)
            self.assertEqual(result, bigobject)
            Pyro4.config.MAX_MESSAGE_SIZE = 999
            try:
                result = p.echo(bigobject)
                self.fail("should fail with ProtocolError msg too large")
            except Pyro4.errors.ProtocolError:
                pass
            Pyro4.config.MAX_MESSAGE_SIZE = 0

    def testCleanup(self):
        p1 = Pyro4.core.Proxy(self.objectUri)
        p2 = Pyro4.core.Proxy(self.objectUri)
        p3 = Pyro4.core.Proxy(self.objectUri)
        p1.echo(42)
        p2.echo(42)
        p3.echo(42)
        # we have several active connections still up, see if we can cleanly shutdown the daemon
        # (it should interrupt the worker's socket connections)
        time.sleep(0.1)
        self.daemon.shutdown()
        self.daemon=None
        p1._pyroRelease()
        p2._pyroRelease()
        p3._pyroRelease()


class ServerTestsThreadNoTimeout(unittest.TestCase):
    SERVERTYPE="thread"
    COMMTIMEOUT=None
    def setUp(self):
        Pyro4.config.POLLTIMEOUT=0.1
        Pyro4.config.SERVERTYPE=self.SERVERTYPE
        Pyro4.config.COMMTIMEOUT=self.COMMTIMEOUT
        Pyro4.config.HMAC_KEY=b"testsuite"
        Pyro4.config.SERIALIZERS_ACCEPTED.add("pickle")
        self.daemon=Pyro4.core.Daemon(port=0)
        obj=MyThing()
        uri=self.daemon.register(obj, "something")
        self.objectUri=uri
        self.daemonthread=DaemonLoopThread(self.daemon)
        self.daemonthread.start()
        self.daemonthread.running.wait()
        time.sleep(0.05)
    def tearDown(self):
        time.sleep(0.05)
        self.daemon.shutdown()
        self.daemonthread.join()
        Pyro4.config.SERVERTYPE="thread"
        Pyro4.config.COMMTIMEOUT=None
        Pyro4.config.HMAC_KEY=None
        Pyro4.config.SERIALIZERS_ACCEPTED.discard("pickle")

    def testConnectionStuff(self):
        p1=Pyro4.core.Proxy(self.objectUri)
        p2=Pyro4.core.Proxy(self.objectUri)
        self.assertTrue(p1._pyroConnection is None)
        self.assertTrue(p2._pyroConnection is None)
        p1.ping()
        p2.ping()
        _=p1.multiply(11,5)
        _=p2.multiply(11,5)
        self.assertTrue(p1._pyroConnection is not None)
        self.assertTrue(p2._pyroConnection is not None)
        p1._pyroRelease()
        p1._pyroRelease()
        p2._pyroRelease()
        p2._pyroRelease()
        self.assertTrue(p1._pyroConnection is None)
        self.assertTrue(p2._pyroConnection is None)
        p1._pyroBind()
        _=p1.multiply(11,5)
        _=p2.multiply(11,5)
        self.assertTrue(p1._pyroConnection is not None)
        self.assertTrue(p2._pyroConnection is not None)
        self.assertEqual("PYRO",p1._pyroUri.protocol)
        self.assertEqual("PYRO",p2._pyroUri.protocol)
        p1._pyroRelease()
        p2._pyroRelease()

    def testReconnectAndCompression(self):
        # try reconnects
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertTrue(p._pyroConnection is None)
            p._pyroReconnect(tries=100)
            self.assertTrue(p._pyroConnection is not None)
        self.assertTrue(p._pyroConnection is None)
        # test compression:
        try:
            with Pyro4.core.Proxy(self.objectUri) as p:
                Pyro4.config.COMPRESSION=True
                self.assertEqual(55, p.multiply(5,11))
                self.assertEqual("*"*1000, p.multiply("*"*500,2))
        finally:
            Pyro4.config.COMPRESSION=False
    
    def testOneway(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            self.assertEqual(55, p.multiply(5,11))
            p._pyroOneway.add("multiply")
            self.assertEqual(None, p.multiply(5,11))
            self.assertEqual(None, p.multiply(5,11))
            self.assertEqual(None, p.multiply(5,11))
            p._pyroOneway.remove("multiply")
            self.assertEqual(55, p.multiply(5,11))
            self.assertEqual(55, p.multiply(5,11))
            self.assertEqual(55, p.multiply(5,11))
            # check nonexisting method behavoir
            self.assertRaises(AttributeError, p.nonexisting)
            p._pyroOneway.add("nonexisting")
            # now it shouldn't fail because of oneway semantics
            p.nonexisting()
        # also test on class:
        class ProxyWithOneway(Pyro4.core.Proxy):
            def __init__(self, arg):
                super(ProxyWithOneway,self).__init__(arg)
                self._pyroOneway=["multiply"]   # set is faster but don't care for this test
        with ProxyWithOneway(self.objectUri) as p:
            self.assertEqual(None, p.multiply(5,11))
            p._pyroOneway=[]   # empty set is better but don't care in this test
            self.assertEqual(55, p.multiply(5,11))
            
    def testOnewayDelayed(self):
        try:
            with Pyro4.core.Proxy(self.objectUri) as p:
                p.ping()
                Pyro4.config.ONEWAY_THREADED=True   # the default
                p._pyroOneway.add("delay")
                now=time.time()
                p.delay(1)  # oneway so we should continue right away
                self.assertTrue(time.time()-now < 0.2, "delay should be running as oneway")
                now=time.time()
                self.assertEqual(55,p.multiply(5,11), "expected a normal result from a non-oneway call")
                self.assertTrue(time.time()-now < 0.2, "delay should be running in its own thread")
                # make oneway calls run in the server thread
                # we can change the config here and the server will pick it up on the fly
                Pyro4.config.ONEWAY_THREADED=False   
                now=time.time()
                p.delay(1)  # oneway so we should continue right away
                self.assertTrue(time.time()-now < 0.2, "delay should be running as oneway")
                now=time.time()
                self.assertEqual(55,p.multiply(5,11), "expected a normal result from a non-oneway call")
                self.assertFalse(time.time()-now < 0.2, "delay should be running in the server thread")
        finally:
            Pyro4.config.ONEWAY_THREADED=True   # back to normal

    def testSerializeConnected(self):
        # online serialization tests
        ser=Pyro4.util.get_serializer(Pyro4.config.SERIALIZER)
        proxy=Pyro4.core.Proxy(self.objectUri)
        proxy._pyroBind()
        self.assertFalse(proxy._pyroConnection is None)
        p,_=ser.serializeData(proxy)
        proxy2=ser.deserializeData(p)
        self.assertTrue(proxy2._pyroConnection is None)
        self.assertFalse(proxy._pyroConnection is None)
        self.assertEqual(proxy2._pyroUri, proxy._pyroUri)
        proxy2._pyroBind()
        self.assertFalse(proxy2._pyroConnection is None)
        self.assertFalse(proxy2._pyroConnection is proxy._pyroConnection)
        proxy._pyroRelease()
        proxy2._pyroRelease()
        self.assertTrue(proxy._pyroConnection is None)
        self.assertTrue(proxy2._pyroConnection is None)
        proxy.ping()
        proxy2.ping()
        # try copying a connected proxy
        import copy
        proxy3=copy.copy(proxy)
        self.assertTrue(proxy3._pyroConnection is None)
        self.assertFalse(proxy._pyroConnection is None)
        self.assertEqual(proxy3._pyroUri, proxy._pyroUri)
        self.assertFalse(proxy3._pyroUri is proxy._pyroUri)
        proxy._pyroRelease()
        proxy2._pyroRelease()
        proxy3._pyroRelease()

    def testException(self):
        with Pyro4.core.Proxy(self.objectUri) as p:
            try:
                p.divide(1,0)
            except:
                et,ev,tb=sys.exc_info()
                self.assertEqual(ZeroDivisionError, et)
                pyrotb="".join(Pyro4.util.getPyroTraceback(et,ev,tb))
                self.assertTrue("Remote traceback" in pyrotb)
                self.assertTrue("ZeroDivisionError" in pyrotb)
                del tb

    def testTimeoutCall(self):
        Pyro4.config.COMMTIMEOUT=None
        with Pyro4.core.Proxy(self.objectUri) as p:
            p.ping()
            start=time.time()
            p.delay(0.5)
            duration=time.time()-start
            self.assertTrue(0.4<duration<0.6)
            p._pyroTimeout=0.1
            start=time.time()
            self.assertRaises(Pyro4.errors.TimeoutError, p.delay, 1)
            duration=time.time()-start
            if sys.platform!="cli":
                self.assertAlmostEqual(0.1, duration, places=1)
            else:
                # ironpython's time is weird
                self.assertTrue(0.0<duration<0.7)

    def testTimeoutConnect(self):
        # set up a unresponsive daemon
        with Pyro4.core.Daemon(port=0) as d:
            time.sleep(0.5)
            obj=MyThing()
            uri=d.register(obj)
            # we're not going to start the daemon's event loop
            p=Pyro4.core.Proxy(uri)
            p._pyroTimeout=0.2
            start=time.time()
            self.assertRaises(Pyro4.errors.TimeoutError, p.ping)
            duration=time.time()-start
            self.assertTrue(duration<2.0)
            
    def testProxySharing(self):
        class SharedProxyThread(threadutil.Thread):
            def __init__(self, proxy):
                super(SharedProxyThread,self).__init__()
                self.proxy=proxy
                self.terminate=False
                self.error=True
                self.setDaemon(True)
            def run(self):
                try:
                    while not self.terminate:
                        reply=self.proxy.multiply(5,11)
                        assert reply==55
                        time.sleep(0.001)
                    self.error=False
                except:
                    print("Something went wrong in the thread (SharedProxyThread):")
                    print("".join(Pyro4.util.getPyroTraceback()))
        with Pyro4.core.Proxy(self.objectUri) as p:
            threads=[]
            for i in range(5):
                t=SharedProxyThread(p)
                threads.append(t)
                t.start()
            time.sleep(1)
            for t in threads:
                t.terminate=True
                t.join()
            for t in threads:
                self.assertFalse(t.error, "all threads should report no errors") 

    def testServerConnections(self):
        # check if the server allows to grow the number of connections
        proxies=[Pyro4.core.Proxy(self.objectUri) for _ in range(10)]
        try:
            for p in proxies:
                p._pyroTimeout=0.5
                p._pyroBind()
            for p in proxies:
                p.ping()
        finally:
            for p in proxies:
                p._pyroRelease()

    def testServerParallelism(self):
        class ClientThread(threadutil.Thread):
            def __init__(self, uri, name):
                super(ClientThread,self).__init__()
                self.setDaemon(True)
                self.proxy=Pyro4.core.Proxy(uri)
                self.name=name
                self.error=True
                self.proxy._pyroTimeout=5.0
                self.proxy._pyroBind()
            def run(self):
                try:
                    reply=self.proxy.delayAndId(0.5, self.name)
                    assert reply=="slept for "+self.name
                    self.error=False
                finally:
                    self.proxy._pyroRelease()
        threads=[]
        start=time.time()
        try:
            for i in range(6):
                t=ClientThread(self.objectUri,"t%d" % i)
                threads.append(t)
        except:
            # some exception (probably timeout) while creating clients
            # try to clean up some connections first
            for t in threads:
                t.proxy._pyroRelease()
            raise  # re-raise the exception
        for t in threads:
            t.start()
        for t in threads:
            t.join()
            self.assertFalse(t.error, "all threads should report no errors")
        del threads
        duration=time.time()-start
        if Pyro4.config.SERVERTYPE=="multiplex":
            # multiplex based server doesn't execute calls in parallel,
            # so 6 threads times 0.5 seconds =~ 3 seconds
            self.assertTrue(2.5<duration<3.5)
        else:
            # thread based server does execute calls in parallel,
            # so 6 threads taking 0.5 seconds =~ 0.5 seconds passed
            self.assertTrue(0.4<duration<0.9)  # loose upper bound for slow jython


class ServerTestsMultiplexNoTimeout(ServerTestsThreadNoTimeout):
    SERVERTYPE = "multiplex"
    COMMTIMEOUT = None
    def testProxySharing(self):
        pass
    def testException(self):
        pass


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_server_timeout
"""
Tests for a running Pyro server, with timeouts.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import os
import test_server
from testsupport import unittest


class ServerTestsThreadTimeout(test_server.ServerTestsThreadNoTimeout):
    SERVERTYPE="thread"
    COMMTIMEOUT=2.0
    def testServerParallelism(self):
        # this test is not suitable on a server with timeout set
        pass
    def testProxySharing(self):
        pass
    def testException(self):
        pass
    

class ServerTestsMultiplexTimeout(test_server.ServerTestsMultiplexNoTimeout):
    SERVERTYPE = "multiplex"
    COMMTIMEOUT = 2.0
    def testServerParallelism(self):
        # this test is not suitable on a server with timeout set
        pass
    def testProxySharing(self):
        pass
    def testException(self):
        pass


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_socket
"""
Tests for the low level socket functions.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import socket, os, sys
import time
import Pyro4.socketutil as SU
from Pyro4 import threadutil, errors
from Pyro4.socketserver.multiplexserver import SocketServer_Select, SocketServer_Poll
from Pyro4.socketserver.threadpoolserver import SocketServer_Threadpool
from Pyro4.core import Daemon
import Pyro4.message
import Pyro4
from testsupport import *


# determine ipv6 capability
has_ipv6 = socket.has_ipv6 and not os.name=="java"    #  jython's ipv6 support isn't really working in Pyro
if has_ipv6:
    s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    try:
        s.connect(("::1", 53))
        s.close()
        socket.getaddrinfo("localhost", 53, socket.AF_INET6)
    except socket.error:
        has_ipv6 = False


class TestSocketStuff(unittest.TestCase):
    def testSockname(self):
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("",0))
        s.listen(5)
        host, port = s.getsockname()
        self.assertNotEqual(0, port)
        if os.name!="java":
            self.assertEqual("0.0.0.0", host)     # ipv4 support only at this time
        else:
            # jython somehow seems to return ipv6 sockname on ipv4 sockets
            self.assertTrue(host in ("0.0.0.0", "0:0:0:0:0:0:0:0"))
        s.close()


class TestSocketutil(unittest.TestCase):
    def setUp(self):
        Pyro4.config.POLLTIMEOUT=0.1
        
    def testGetIP(self):
        Pyro4.config.PREFER_IP_VERSION=4
        myip=SU.getIpAddress("")
        self.assertTrue(len(myip)>4)
        myip=SU.getIpAddress("", workaround127=True)
        self.assertTrue(len(myip)>4)
        self.assertFalse(myip.startswith("127."))
        self.assertEqual("127.0.0.1", SU.getIpAddress("127.0.0.1", workaround127=False))
        self.assertNotEqual("127.0.0.1", SU.getIpAddress("127.0.0.1", workaround127=True))
        
    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testGetIP6(self):
        self.assertTrue(":" in SU.getIpAddress("::1", ipVersion=6))
        # self.assertTrue(":" in SU.getIpAddress("", ipVersion=6))
        self.assertTrue(":" in SU.getIpAddress("localhost", ipVersion=6))

    def testGetIpVersion4(self):
        version = Pyro4.config.PREFER_IP_VERSION
        try:
            Pyro4.config.PREFER_IP_VERSION=4
            self.assertEqual(4, SU.getIpVersion("127.0.0.1"))
            self.assertEqual(4, SU.getIpVersion("localhost"))
            Pyro4.config.PREFER_IP_VERSION=0
            self.assertEqual(4, SU.getIpVersion("127.0.0.1"))
        finally:
            Pyro4.config.PREFER_IP_VERSION = version

    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testGetIpVersion6(self):
        version = Pyro4.config.PREFER_IP_VERSION
        try:
            Pyro4.config.PREFER_IP_VERSION=6
            self.assertEqual(6, SU.getIpVersion("127.0.0.1"))
            self.assertEqual(6, SU.getIpVersion("::1"))
            self.assertEqual(6, SU.getIpVersion("localhost"))
            Pyro4.config.PREFER_IP_VERSION=4
            self.assertEqual(4, SU.getIpVersion("127.0.0.1"))
            self.assertEqual(6, SU.getIpVersion("::1"))
            Pyro4.config.PREFER_IP_VERSION=0
            self.assertEqual(4, SU.getIpVersion("127.0.0.1"))
            self.assertEqual(6, SU.getIpVersion("::1"))
        finally:
            Pyro4.config.PREFER_IP_VERSION = version

    def testGetInterfaceAddress(self):
        self.assertTrue(SU.getInterfaceAddress("localhost").startswith("127."))
        if has_ipv6:
            self.assertTrue(":" in SU.getInterfaceAddress("::1"))

    def testUnusedPort(self):
        port1=SU.findProbablyUnusedPort()
        port2=SU.findProbablyUnusedPort()
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)
        port1=SU.findProbablyUnusedPort(socktype=socket.SOCK_DGRAM)
        port2=SU.findProbablyUnusedPort(socktype=socket.SOCK_DGRAM)
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)

    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testUnusedPort6(self):
        port1=SU.findProbablyUnusedPort(family=socket.AF_INET6)
        port2=SU.findProbablyUnusedPort(family=socket.AF_INET6)
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)
        port1=SU.findProbablyUnusedPort(family=socket.AF_INET6, socktype=socket.SOCK_DGRAM)
        port2=SU.findProbablyUnusedPort(family=socket.AF_INET6, socktype=socket.SOCK_DGRAM)
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)

    def testBindUnusedPort(self):
        sock1=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock2=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        port1=SU.bindOnUnusedPort(sock1)
        port2=SU.bindOnUnusedPort(sock2)
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)
        sockname=sock1.getsockname()
        self.assertEqual(("127.0.0.1",port1), sockname)
        sock1.close()
        sock2.close()

    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testBindUnusedPort6(self):
        sock1=socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
        sock2=socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
        port1=SU.bindOnUnusedPort(sock1)
        port2=SU.bindOnUnusedPort(sock2)
        self.assertTrue(port1>0)
        self.assertNotEqual(port1,port2)
        host,port,_,_=sock1.getsockname()
        self.assertTrue(":" in host)
        self.assertEqual(port1, port)
        sock1.close()
        sock2.close()

    def testCreateUnboundSockets(self):
        s=SU.createSocket()
        self.assertEqual(socket.AF_INET, s.family)
        bs=SU.createBroadcastSocket()
        self.assertEqual(socket.AF_INET, bs.family)
        try:
            host,port=s.getsockname()
            # can either fail with socket.error or return (host,0)
            self.assertEqual(0,port)
        except socket.error:
            pass
        try:
            host,port=bs.getsockname()
            # can either fail with socket.error or return (host,0)
            self.assertEqual(0,port)
        except socket.error:
            pass
        s.close()
        bs.close()

    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testCreateUnboundSockets6(self):
        s=SU.createSocket(ipv6=True)
        self.assertEqual(socket.AF_INET6, s.family)
        bs=SU.createBroadcastSocket(ipv6=True)
        self.assertEqual(socket.AF_INET6, bs.family)
        try:
            host,port,_,_=s.getsockname()
            # can either fail with socket.error or return (host,0)
            self.assertEqual(0,port)
        except socket.error:
            pass
        try:
            host,port,_,_=bs.getsockname()
            # can either fail with socket.error or return (host,0)
            self.assertEqual(0,port)
        except socket.error:
            pass
        s.close()
        bs.close()

    def testCreateBoundSockets(self):
        s=SU.createSocket(bind=('127.0.0.1',0))
        self.assertEqual(socket.AF_INET, s.family)
        bs=SU.createBroadcastSocket(bind=('127.0.0.1',0))
        self.assertEqual('127.0.0.1',s.getsockname()[0])
        self.assertEqual('127.0.0.1',bs.getsockname()[0])
        s.close()
        bs.close()
        self.assertRaises(ValueError, SU.createSocket, bind=('localhost',12345), connect=('localhost',1234))
            
    @unittest.skipUnless(has_ipv6, "ipv6 testcase")
    def testCreateBoundSockets6(self):
        s=SU.createSocket(bind=('::1',0))
        self.assertEqual(socket.AF_INET6, s.family)
        bs=SU.createBroadcastSocket(bind=('::1',0))
        self.assertTrue(':' in s.getsockname()[0])
        self.assertTrue(':' in bs.getsockname()[0])
        s.close()
        bs.close()
        self.assertRaises(ValueError, SU.createSocket, bind=('::1',12345), connect=('::1',1234))

    @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "unix domain sockets required")
    def testCreateBoundUnixSockets(self):
        SOCKNAME="test_unixsocket"
        if os.path.exists(SOCKNAME): os.remove(SOCKNAME)
        s=SU.createSocket(bind=SOCKNAME)
        self.assertEqual(socket.AF_UNIX, s.family)
        self.assertEqual(SOCKNAME,s.getsockname())
        s.close()
        if os.path.exists(SOCKNAME): os.remove(SOCKNAME)
        # unicode arg
        SOCKNAME = unicode(SOCKNAME)
        s=SU.createSocket(bind=SOCKNAME)
        self.assertEqual(socket.AF_UNIX, s.family)
        self.assertEqual(SOCKNAME,s.getsockname())
        s.close()
        if os.path.exists(SOCKNAME): os.remove(SOCKNAME)
        self.assertRaises(ValueError, SU.createSocket, bind=SOCKNAME, connect=SOCKNAME)

    @unittest.skipUnless(hasattr(socket, "AF_UNIX") and sys.platform.startswith("linux"), "linux and unix domain sockets required")
    def testAbstractNamespace(self):
        SOCKNAME="\0test_unixsocket_abstract_ns"   # mind the \0 at the start
        s = SU.createSocket(bind=SOCKNAME)
        sn_bytes = tobytes(SOCKNAME)
        self.assertEqual(sn_bytes, s.getsockname())
        s.close()

    def testSend(self):
        ss=SU.createSocket(bind=("localhost",0))
        port=ss.getsockname()[1]
        cs=SU.createSocket(connect=("localhost",port))
        SU.sendData(cs,tobytes("foobar!")*10)
        cs.shutdown(socket.SHUT_WR)
        a=ss.accept()
        data=SU.receiveData(a[0], 5)
        self.assertEqual(tobytes("fooba"),data)
        data=SU.receiveData(a[0], 5)
        self.assertEqual(tobytes("r!foo"),data)
        a[0].close()
        ss.close()
        cs.close()

    @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "unix domain sockets required")
    def testSendUnix(self):
        SOCKNAME="test_unixsocket"
        ss=SU.createSocket(bind=SOCKNAME)
        cs=SU.createSocket(connect=SOCKNAME)
        SU.sendData(cs,tobytes("foobar!")*10)
        cs.shutdown(socket.SHUT_WR)
        a=ss.accept()
        data=SU.receiveData(a[0], 5)
        self.assertEqual(tobytes("fooba"),data)
        data=SU.receiveData(a[0], 5)
        self.assertEqual(tobytes("r!foo"),data)
        a[0].close()
        ss.close()
        cs.close()
        if os.path.exists(SOCKNAME): os.remove(SOCKNAME)

    def testBroadcast(self):
        ss=SU.createBroadcastSocket((None, 0))
        port=ss.getsockname()[1]
        cs=SU.createBroadcastSocket()
        for bcaddr in Pyro4.config.parseAddressesString(Pyro4.config.BROADCAST_ADDRS):
            try:
                cs.sendto(tobytes("monkey"),0,(bcaddr,port))
            except socket.error:
                x=sys.exc_info()[1]
                err=getattr(x, "errno", x.args[0])
                if err not in Pyro4.socketutil.ERRNO_EADDRNOTAVAIL:    # yeah, windows likes to throw these...
                    if err not in Pyro4.socketutil.ERRNO_EADDRINUSE:     # and jython likes to throw thses...
                        raise
        data,_=ss.recvfrom(500)
        self.assertEqual(tobytes("monkey"),data)
        cs.close()
        ss.close()
        
    def testMsgWaitallProblems(self):
        ss=SU.createSocket(bind=("localhost",0), timeout=2)
        port=ss.getsockname()[1]
        cs=SU.createSocket(connect=("localhost",port), timeout=2)
        a=ss.accept()
        # test some sizes that might be problematic with MSG_WAITALL
        for size in [1000,10000,32000,32768,32780,41950,41952,42000,65000,65535,65600,80000]:
            SU.sendData(cs,tobytes("x")*size)
            data=SU.receiveData(a[0],size)
            SU.sendData(a[0], data)
            data=SU.receiveData(cs,size)
            self.assertEqual(size, len(data))
        a[0].close()
        ss.close()
        cs.close()
        
    def testMsgWaitallProblems2(self):
        class ReceiveThread(threadutil.Thread):
            def __init__(self, sock, sizes):
                super(ReceiveThread,self).__init__()
                self.sock=sock
                self.sizes=sizes
            def run(self):
                cs,_ = self.sock.accept()
                for size in self.sizes:
                    data=SU.receiveData(cs,size)
                    SU.sendData(cs, data)
                cs.close()
        ss=SU.createSocket(bind=("localhost",0))
        SIZES=[1000,10000,32000,32768,32780,41950,41952,42000,65000,65535,65600,80000,999999]
        serverthread=ReceiveThread(ss, SIZES)
        serverthread.setDaemon(True)
        serverthread.start()
        port=ss.getsockname()[1]
        cs=SU.createSocket(connect=("localhost",port), timeout=2)
        # test some sizes that might be problematic with MSG_WAITALL
        for size in SIZES:
            SU.sendData(cs,tobytes("x")*size)
            data=SU.receiveData(cs,size)
            self.assertEqual(size, len(data))
        serverthread.join()
        ss.close()
        cs.close()

class ServerCallback(object):
    def _handshake(self, connection):
        if not isinstance(connection, SU.SocketConnection):
            raise TypeError("handshake expected SocketConnection parameter")
        serializer = Pyro4.util.get_serializer("marshal")
        data, _ = serializer.serializeData("ok", compress=False)
        msg = Pyro4.message.Message(Pyro4.message.MSG_CONNECTOK, data, serializer.serializer_id, 0, 1)
        connection.send(msg.to_bytes())
        return True
    def handleRequest(self, connection):
        if not isinstance(connection, SU.SocketConnection):
            raise TypeError("handleRequest expected SocketConnection parameter")
        msg = Pyro4.message.Message.recv(connection, [Pyro4.message.MSG_PING])
        if msg.type == Pyro4.message.MSG_PING:
            msg = Pyro4.message.Message(Pyro4.message.MSG_PING, b"ping", msg.serializer_id, 0, msg.seq)
            connection.send(msg.to_bytes())
        else:
            print("unhandled message type", msg.type)
            connection.close()


class ServerCallback_BrokenHandshake(ServerCallback):
    def _handshake(self, connection):
        raise ZeroDivisionError("handshake crashed (on purpose)")


class TestDaemon(Daemon):
    def __init__(self):
        pass   # avoid all regular daemon initialization


class TestSocketServer(unittest.TestCase):
    def testServer_thread(self):
        daemon=ServerCallback()
        port=SU.findProbablyUnusedPort()
        serv=SocketServer_Threadpool()
        serv.init(daemon,"localhost",port)
        self.assertEqual("localhost:"+str(port), serv.locationStr)
        self.assertTrue(serv.sock is not None)
        conn=SU.SocketConnection(serv.sock, "ID12345")
        self.assertEqual("ID12345",conn.objectId)
        self.assertTrue(conn.sock is not None)
        conn.close()
        conn.close()
        self.assertFalse(conn.sock is None, "connections keep their socket object even if it's closed")
        serv.close()
        serv.close()
        self.assertTrue(serv.sock is None)
    def testServer_select(self):
        daemon=ServerCallback()
        port=SU.findProbablyUnusedPort()
        serv=SocketServer_Select()
        serv.init(daemon,"localhost",port)
        self.assertEqual("localhost:"+str(port), serv.locationStr)
        self.assertTrue(serv.sock is not None)
        conn=SU.SocketConnection(serv.sock, "ID12345")
        self.assertEqual("ID12345",conn.objectId)
        self.assertTrue(conn.sock is not None)
        conn.close()
        conn.close()
        self.assertFalse(conn.sock is None, "connections keep their socket object even if it's closed")
        serv.close()
        serv.close()
        self.assertTrue(serv.sock is None)
    def testServer_poll(self):
        daemon=ServerCallback()
        port=SU.findProbablyUnusedPort()
        serv=SocketServer_Poll()
        serv.init(daemon,"localhost",port)
        self.assertEqual("localhost:"+str(port), serv.locationStr)
        self.assertTrue(serv.sock is not None)
        conn=SU.SocketConnection(serv.sock, "ID12345")
        self.assertEqual("ID12345",conn.objectId)
        self.assertTrue(conn.sock is not None)
        conn.close()
        conn.close()
        self.assertFalse(conn.sock is None, "connections keep their socket object even if it's closed")
        serv.close()
        serv.close()
        self.assertTrue(serv.sock is None)


@unittest.skipUnless(SU.hasSelect, "requires select()")
class TestServerDOS_select(unittest.TestCase):

    def setUp(self):
        self.orig_poll_timeout = Pyro4.config.POLLTIMEOUT
        self.orig_comm_timeout = Pyro4.config.COMMTIMEOUT
        Pyro4.config.POLLTIMEOUT = 0.5
        Pyro4.config.COMMTIMEOUT = 0.5
        self.socket_server = SocketServer_Select

    def tearDown(self):
        Pyro4.config.POLLTIMEOUT = self.orig_poll_timeout
        Pyro4.config.COMMTIMEOUT = self.orig_comm_timeout

    class ServerThread(threadutil.Thread):
        def __init__(self, server, daemon):
            threadutil.Thread.__init__(self)
            self.serv = server()
            self.serv.init(daemon(), "localhost", 0)
            self.locationStr = self.serv.locationStr
            self.stop_loop = threadutil.Event()
        def run(self):
            self.serv.loop(loopCondition=lambda: not self.stop_loop.is_set())
            self.serv.close()

    def testConnectCrash(self):
        serv_thread = TestServerDOS_select.ServerThread(self.socket_server, ServerCallback_BrokenHandshake)
        serv_thread.start()
        time.sleep(0.2)
        self.assertTrue(serv_thread.is_alive(), "server thread failed to start")
        try:
            host, port = serv_thread.locationStr.split(':')
            port = int(port)
            try:
                # first connection attempt (will fail because server daemon _handshake crashes)
                csock = SU.createSocket(connect=(host, port))
                conn = SU.SocketConnection(csock, "uri")
                Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_CONNECTOK])
            except errors.ConnectionClosedError:
                pass
            conn.close()
            try:
                # second connection attempt, should still work (i.e. server should still be running)
                csock = SU.createSocket(connect=(host, port))
                conn = SU.SocketConnection(csock, "uri")
                Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_CONNECTOK])
            except errors.ConnectionClosedError:
                pass
        finally:
            conn.close()
            serv_thread.stop_loop.set()
            serv_thread.join()

    def testInvalidMessageCrash(self):
        serv_thread = TestServerDOS_select.ServerThread(self.socket_server, TestDaemon)
        serv_thread.start()
        time.sleep(0.2)
        self.assertTrue(serv_thread.is_alive(), "server thread failed to start")

        def connect(host, port):
            # connect to the server
            csock = SU.createSocket(connect=(host, port))
            conn = SU.SocketConnection(csock, "uri")
            # get the handshake/connect response
            Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_CONNECTOK])
            return conn

        try:
            host, port = serv_thread.locationStr.split(':')
            port = int(port)
            conn = connect(host, port)
            # invoke something, but screw up the message (in this case, mess with the protocol version)
            orig_protocol_version = Pyro4.constants.PROTOCOL_VERSION
            Pyro4.constants.PROTOCOL_VERSION = 9999
            msgbytes = Pyro4.message.Message(Pyro4.message.MSG_PING, b"something", 42, 0, 0).to_bytes()
            Pyro4.constants.PROTOCOL_VERSION = orig_protocol_version
            conn.send(msgbytes) # this should cause an error in the server because of invalid msg
            try:
                msg = Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_RESULT])
                data = msg.data
                if sys.version_info >= (2, 7):
                    data = msg.data.decode("ascii", errors="ignore")  # convert raw message to string to check some stuff
                self.assertTrue("Traceback" in data)
                self.assertTrue("ProtocolError" in data)
                self.assertTrue("version" in data)
            except errors.ConnectionClosedError:
                # invalid message can have caused the connection to be closed, this is fine
                pass
            # invoke something again, this should still work (server must still be running)
            conn.close()
            conn = connect(host, port)
            msg = Pyro4.message.Message(Pyro4.message.MSG_PING, b"something", 42, 0, 999)
            conn.send(msg.to_bytes())
            msg = Pyro4.message.Message.recv(conn, [Pyro4.message.MSG_PING])
            self.assertEqual(Pyro4.message.MSG_PING, msg.type)
            self.assertEqual(999, msg.seq)
            self.assertEqual(b"pong", msg.data)
        finally:
            conn.close()
            serv_thread.stop_loop.set()
            serv_thread.join()


@unittest.skipUnless(SU.hasPoll, "requires poll()")
@unittest.skipUnless(os.name!="java", "poll-server not yet supported in jython")
class TestServerDOS_poll(TestServerDOS_select):
    def setUp(self):
        super(TestServerDOS_poll, self).setUp()
        self.socket_server = SocketServer_Poll

class TestServerDOS_threading(TestServerDOS_select):
    def setUp(self):
        super(TestServerDOS_threading, self).setUp()
        self.socket_server = SocketServer_Threadpool
        self.orig_numthreads = Pyro4.config.THREADPOOL_SIZE
        Pyro4.config.THREADPOOL_SIZE = 1

    def tearDown(self):
        Pyro4.config.THREADPOOL_SIZE = self.orig_numthreads


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_threadpool
"""
Tests for the thread pool.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

from __future__ import with_statement, print_function
import time
import random
from Pyro4.socketserver.threadpool import Pool, PoolError
import Pyro4.threadutil
from testsupport import unittest

JOB_TIME = 0.2


class Job(object):
    def __init__(self, name="unnamed"):
        self.name=name
    def __call__(self):
        # print("Job() '%s'" % self.name)
        time.sleep(JOB_TIME - random.random()/10.0)
        # print("Job() '%s' done" % self.name)


class PoolTests(unittest.TestCase):
    def setUp(self):
        pass
    def tearDown(self):
        Pyro4.config.reset()

    def testCreate(self):
        with Pool() as jq:
            _=repr(jq)
        self.assertTrue(jq.closed)

    def testSingle(self):
        with Pool() as p:
            job = Job()
            p.process(job)
            time.sleep(0.02)  # let it pick up the job
            self.assertEqual(0, p.num_jobs())

    def testMany(self):
        class Job2(object):
            def __init__(self, name="unnamed"):
                self.name=name
            def __call__(self):
                time.sleep(0.01)
        with Pool() as p:
            for i in range(1+Pyro4.config.THREADPOOL_SIZE*100):
                p.process(Job2(str(i)))
            time.sleep(2)
            self.assertEqual(0, p.num_jobs(), "queue must be finished in under two seconds")

    def testClose(self):
        # test that after closing a job queue, no more new jobs are taken from the queue, and some other stuff
        with Pool() as p:
            for i in range(2*Pyro4.config.THREADPOOL_SIZE):
                p.process(Job(str(i+1)))
            self.assertTrue(p.num_jobs() > 1)

        self.assertRaises(PoolError, p.process, Job(1))  # must not allow new jobs after closing
        self.assertTrue(p.num_jobs() > 1)
        time.sleep(JOB_TIME*1.1)
        jobs_left = p.num_jobs()
        time.sleep(JOB_TIME*1.1)   # wait till jobs finish and a new one *might* be taken off the queue
        self.assertEqual(jobs_left, p.num_jobs(), "may not process new jobs after close")


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_util
"""
Tests for the utility functions.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys, imp, os, platform
import Pyro4.util
from testsupport import *


if not hasattr(imp,"reload"):
    imp.reload=reload   # python 2.5 doesn't have imp.reload

def crash(arg=100):
    pre1="black"
    pre2=999
    def nest(p1,p2):
        s="white"+pre1
        x=pre2
        y=arg//2
        p3=p1//p2
        return p3
    a=10
    b=0
    s="hello"
    c=nest(a,b)
    return c

class TestUtils(unittest.TestCase):

    def testFormatTracebackNormal(self):
        try:
            crash()
            self.fail("must crash with ZeroDivisionError")
        except ZeroDivisionError:
            tb="".join(Pyro4.util.formatTraceback(detailed=False))
            self.assertTrue("p3=p1//p2" in tb)
            self.assertTrue("ZeroDivisionError" in tb)
            self.assertFalse(" a = 10" in tb)
            self.assertFalse(" s = 'whiteblack'" in tb)
            self.assertFalse(" pre2 = 999" in tb)
            self.assertFalse(" x = 999" in tb)

    def testFormatTracebackDetail(self):
        try:
            crash()
            self.fail("must crash with ZeroDivisionError")
        except ZeroDivisionError:
            tb="".join(Pyro4.util.formatTraceback(detailed=True))
            self.assertTrue("p3=p1//p2" in tb)
            self.assertTrue("ZeroDivisionError" in tb)
            if sys.platform!="cli":
                self.assertTrue(" a = 10" in tb)
                self.assertTrue(" s = 'whiteblack'" in tb)
                self.assertTrue(" pre2 = 999" in tb)
                self.assertTrue(" x = 999" in tb)


    def testPyroTraceback(self):
        try:
            crash()
            self.fail("must crash with ZeroDivisionError")
        except ZeroDivisionError:
            pyro_tb=Pyro4.util.formatTraceback(detailed=True)
            if sys.platform!="cli":
                self.assertTrue(" Extended stacktrace follows (most recent call last)\n" in pyro_tb)
        try:
            crash("stringvalue")
            self.fail("must crash with TypeError")
        except TypeError:
            x=sys.exc_info()[1]
            x._pyroTraceback=pyro_tb        # set the remote traceback info
            pyrotb="".join(Pyro4.util.getPyroTraceback())
            self.assertTrue("Remote traceback" in pyrotb)
            self.assertTrue("crash(\"stringvalue\")" in pyrotb)
            self.assertTrue("TypeError:" in pyrotb)
            self.assertTrue("ZeroDivisionError" in pyrotb)
            del x._pyroTraceback
            pyrotb="".join(Pyro4.util.getPyroTraceback())
            self.assertFalse("Remote traceback" in pyrotb)
            self.assertFalse("ZeroDivisionError" in pyrotb)
            self.assertTrue("crash(\"stringvalue\")" in pyrotb)
            self.assertTrue("TypeError:" in pyrotb)
            
    def testPyroTracebackArgs(self):
        try:
            crash()
            self.fail("must crash with ZeroDivisionError")
        except ZeroDivisionError:
            ex_type, ex_value, ex_tb = sys.exc_info()
            x=ex_value
            tb1=Pyro4.util.getPyroTraceback()
            tb2=Pyro4.util.getPyroTraceback(ex_type, ex_value, ex_tb)
            self.assertEqual(tb1, tb2)
            tb1=Pyro4.util.formatTraceback()
            tb2=Pyro4.util.formatTraceback(ex_type, ex_value, ex_tb)
            self.assertEqual(tb1, tb2)
            tb2=Pyro4.util.formatTraceback(detailed=True)
            if sys.platform!="cli":
                self.assertNotEqual(tb1, tb2)
            # old call syntax, should get an error now:
            self.assertRaises(TypeError, Pyro4.util.getPyroTraceback, x)
            self.assertRaises(TypeError, Pyro4.util.formatTraceback, x)

    def testExcepthook(self):
        # simply test the excepthook by calling it the way Python would
        try:
            crash()
            self.fail("must crash with ZeroDivisionError")
        except ZeroDivisionError:
            pyro_tb=Pyro4.util.formatTraceback()
        try:
            crash("stringvalue")
            self.fail("must crash with TypeError")
        except TypeError:
            ex_type,ex_value,ex_tb=sys.exc_info()
            ex_value._pyroTraceback=pyro_tb        # set the remote traceback info
            oldstderr=sys.stderr
            try:
                sys.stderr=StringIO()
                Pyro4.util.excepthook(ex_type, ex_value, ex_tb)
                output=sys.stderr.getvalue()
                self.assertTrue("Remote traceback" in output)
                self.assertTrue("crash(\"stringvalue\")" in output)
                self.assertTrue("TypeError:" in output)
                self.assertTrue("ZeroDivisionError" in output)
            finally:
                sys.stderr=oldstderr

    def clearEnv(self):
        if "PYRO_HOST" in os.environ: del os.environ["PYRO_HOST"]
        if "PYRO_NS_PORT" in os.environ: del os.environ["PYRO_NS_PORT"]
        if "PYRO_COMPRESSION" in os.environ: del os.environ["PYRO_COMPRESSION"]
        Pyro4.config.reset()
    
    def testConfig(self):
        self.clearEnv()
        try:
            self.assertEqual(9090, Pyro4.config.NS_PORT)
            self.assertEqual("localhost", Pyro4.config.HOST)
            self.assertEqual(False, Pyro4.config.COMPRESSION)
            os.environ["NS_PORT"]="4444"
            Pyro4.config.reset()
            self.assertEqual(9090, Pyro4.config.NS_PORT)
            os.environ["PYRO_NS_PORT"]="4444"
            os.environ["PYRO_HOST"]="something.com"
            os.environ["PYRO_COMPRESSION"]="OFF"
            Pyro4.config.reset()
            self.assertEqual(4444, Pyro4.config.NS_PORT)
            self.assertEqual("something.com", Pyro4.config.HOST)
            self.assertEqual(False, Pyro4.config.COMPRESSION)
        finally:
            self.clearEnv()
            self.assertEqual(9090, Pyro4.config.NS_PORT)
            self.assertEqual("localhost", Pyro4.config.HOST)
            self.assertEqual(False, Pyro4.config.COMPRESSION)

    def testConfigReset(self):
        try:
            Pyro4.config.reset()
            self.assertEqual("localhost", Pyro4.config.HOST)
            Pyro4.config.HOST="foobar"
            self.assertEqual("foobar", Pyro4.config.HOST)
            Pyro4.config.reset()
            self.assertEqual("localhost", Pyro4.config.HOST)
            os.environ["PYRO_HOST"]="foobar"
            Pyro4.config.reset()
            self.assertEqual("foobar", Pyro4.config.HOST)
            del os.environ["PYRO_HOST"]
            Pyro4.config.reset()
            self.assertEqual("localhost", Pyro4.config.HOST)
        finally:
            self.clearEnv()


    def testResolveAttr(self):
        class Test(object):
            def __init__(self,value):
                self.value=value
            def __str__(self):
                return "<%s>" % self.value
        obj=Test("obj")
        obj.a=Test("a")
        obj.a.b=Test("b")
        obj.a.b.c=Test("c")
        obj.a._p=Test("p1")
        obj.a._p.q=Test("q1")
        obj.a.__p=Test("p2")
        obj.a.__p.q=Test("q2")
        #check the method with dotted disabled 
        self.assertEqual("<a>",str(Pyro4.util.resolveDottedAttribute(obj,"a",False)))
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a.b",False)
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a.b.c",False)
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a.b.c.d",False)
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a._p",False)
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a._p.q",False)
        self.assertRaises(AttributeError, Pyro4.util.resolveDottedAttribute, obj, "a.__p.q",False)
        #now with dotted enabled
        self.assertEqual("<a>",str(Pyro4.util.resolveDottedAttribute(obj,"a",True)))
        self.assertEqual("<b>",str(Pyro4.util.resolveDottedAttribute(obj,"a.b",True)))
        self.assertEqual("<c>",str(Pyro4.util.resolveDottedAttribute(obj,"a.b.c",True)))
        self.assertRaises(AttributeError,Pyro4.util.resolveDottedAttribute, obj,"a.b.c.d",True)   # doesn't exist
        self.assertRaises(AttributeError,Pyro4.util.resolveDottedAttribute, obj,"a._p",True)    #private
        self.assertRaises(AttributeError,Pyro4.util.resolveDottedAttribute, obj,"a._p.q",True)    #private
        self.assertRaises(AttributeError,Pyro4.util.resolveDottedAttribute, obj,"a.__p.q",True)    #private

    @unittest.skipUnless(sys.version_info>=(2,6,5), "unicode kwargs needs 2.6.5 or newer")
    def testUnicodeKwargs(self):
        # test the way the interpreter deals with unicode function kwargs
        # those are supported by Python after 2.6.5
        def function(*args, **kwargs):
            return args, kwargs
        processed_args=function(*(1,2,3), **{ unichr(65): 42 })
        self.assertEqual( ((1,2,3), { unichr(65): 42}), processed_args)
        processed_args=function(*(1,2,3), **{ unichr(0x20ac): 42 })
        key = list(processed_args[1].keys())[0]
        self.assertTrue(type(key) is unicode)
        self.assertEqual(key, unichr(0x20ac))
        self.assertEqual( ((1,2,3), { unichr(0x20ac): 42}), processed_args)


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = run_suite
"""
Run the complete test suite.

This requires nose and coverage to be installed.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import sys
import os
import nose

dirname = os.path.dirname(__file__)
if dirname:
    print("chdir to "+dirname)
    os.chdir(dirname)

sys.path.insert(0,"../src")    # add Pyro source directory

nose.main(argv=["noserunner", "--cover-erase","--with-coverage","--cover-package=Pyro4", "--with-xunit"])


########NEW FILE########
__FILENAME__ = run_suite_simple
"""
Run the complete test suite. Doesn't require nose and coverage,
but is more braindead and gives less output.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import unittest
import sys, os

if len(sys.argv)==2 and sys.argv[1]=="--tox":
    # running from Tox, don't screw with paths otherwise it screws up the virtualenv
    pass
else:
    # running from normal shell invocation
    dirname = os.path.dirname(__file__)
    if dirname:
        print("chdir to "+dirname)
        os.chdir(dirname)
    sys.path.insert(0,"../src")    # add Pyro source directory

sys.path.insert(1,"PyroTests")

if __name__=="__main__":
    # add test modules here
    modules = [module[:-3] for module in sorted(os.listdir("PyroTests")) if module.endswith(".py") and not module.startswith("__")]

    print("gathering testcases from %s" % modules)

    suite=unittest.TestSuite()
    for module in modules:
        m=__import__("PyroTests."+module)
        m=getattr(m,module)
        testcases = unittest.defaultTestLoader.loadTestsFromModule(m)
        suite.addTest(testcases)

    print("\nRUNNING UNIT TESTS...")
    result=unittest.TextTestRunner(verbosity=1).run(suite)
    if not result.wasSuccessful():
        sys.exit(10)


########NEW FILE########
__FILENAME__ = run_syntaxcheck
"""
Run some syntax checks.

Pyro - Python Remote Objects.  Copyright by Irmen de Jong (irmen@razorvine.net).
"""

import os
import sys
sys.path.insert(0,"../src")
sys.path.insert(1,"PyroTests")

def Pyflakes(path, modules):
    try:
        from pyflakes.scripts.pyflakes import checkPath
    except ImportError:
        print("PYFLAKES not installed. Skipping.")
        return
    warnings=0
    for m in modules:
        warnings+=checkPath(os.path.join(path,m))
    print("%d warnings occurred in pyflakes check" % warnings)


def main(args):
    pyropath="../src/Pyro4"
    pyromodules=[module for module in os.listdir(pyropath) if module.endswith(".py")]
    checkers=args or ["flakes"]
    if "flakes" in checkers:
        print("-"*20+"PYFLAKES")
        Pyflakes(pyropath, pyromodules)


if __name__=="__main__":
    main(sys.argv[1:])

########NEW FILE########
