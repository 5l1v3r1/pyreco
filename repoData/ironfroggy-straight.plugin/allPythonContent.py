__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# straight.plugin documentation build configuration file, created by
# sphinx-quickstart on Wed Jan 25 22:49:22 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'straight.plugin'
copyright = u'2012, Calvin Spealman'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.4'
# The full version, including alpha/beta/rc tags.
release = '1.4.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'straightplugindoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'straightplugin.tex', u'straight.plugin Documentation',
   u'Calvin Spealman', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'straightplugin', u'straight.plugin Documentation',
     [u'Calvin Spealman'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'straightplugin', u'straight.plugin Documentation',
   u'Calvin Spealman', 'straightplugin', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = loaders
"""Facility to load plugins."""

import sys
import os

from importlib import import_module
from imp import find_module

from straight.plugin.manager import PluginManager


class Loader(object):
    """Base loader class. Only used as a base-class for other loaders."""

    def __init__(self, *args, **kwargs):
        self._cache = []

    def load(self, *args, **kwargs):
        self._fill_cache(*args, **kwargs)
        self._post_fill()
        self._order()
        return PluginManager(self._cache)

    def _meta(self, plugin):
        meta = getattr(plugin, '__plugin__', None)
        return meta

    def _post_fill(self):
        for plugin in self._cache:
            meta = self._meta(plugin)
            if not getattr(meta, 'load', True):
                self._cache.remove(plugin)
            for implied_namespace in getattr(meta, 'imply_plugins', []):
                plugins = self._cache
                self._cache = self.load(implied_namespace)
                self._post_fill()
                combined = []
                combined.extend(plugins)
                combined.extend(self._cache)
                self._cache = combined

    def _order(self):
        self._cache.sort(key=self._plugin_priority, reverse=True)

    def _plugin_priority(self, plugin):
        meta = self._meta(plugin)
        return getattr(meta, 'priority', 0.0)


class ModuleLoader(Loader):
    """Performs the work of locating and loading straight plugins.
    
    This looks for plugins in every location in the import path.
    """

    def __init__(self, recurse=False):
        super(ModuleLoader, self).__init__()
        self.recurse = recurse

    def _isPackage(self, path):
        pkg_init = os.path.join(path, '__init__.py')
        if os.path.exists(pkg_init):
            return True

        return False

    def _findPluginFilePaths(self, namespace):
        already_seen = set()

        # Look in each location in the path
        for path in sys.path:

            # Within this, we want to look for a package for the namespace
            namespace_rel_path = namespace.replace(".", os.path.sep)
            namespace_path = os.path.join(path, namespace_rel_path)
            if os.path.exists(namespace_path):
                for possible in os.listdir(namespace_path):

                    poss_path = os.path.join(namespace_path, possible)
                    if os.path.isdir(poss_path):
                        if not self._isPackage(poss_path):
                            continue
                        if self.recurse:
                            subns = '.'.join((namespace, possible.split('.py')[0]))
                            for path in self._findPluginFilePaths(subns):
                                yield path
                        base = possible
                    else:
                        base, ext = os.path.splitext(possible)
                        if base == '__init__' or ext != '.py':
                            continue
                    
                    if base not in already_seen:
                        already_seen.add(base)
                        yield os.path.join(namespace, possible)

    def _findPluginModules(self, namespace):
        for filepath in self._findPluginFilePaths(namespace):
            path_segments = list(filepath.split(os.path.sep))
            path_segments = [p for p in path_segments if p]
            path_segments[-1] = os.path.splitext(path_segments[-1])[0]
            import_path = '.'.join(path_segments)

            try:
                module = import_module(import_path)
            except ImportError:
                #raise Exception(import_path)

                module = None

            if module is not None:
                yield module

    def _fill_cache(self, namespace):
        """Load all modules found in a namespace"""

        modules = self._findPluginModules(namespace)

        self._cache = list(modules)


class ObjectLoader(Loader):
    """Loads classes or objects out of modules in a namespace, based on a
    provided criteria.
   
    The load() method returns all objects exported by the module.
    """

    def __init__(self, recurse=False):
        self.module_loader = ModuleLoader(recurse=recurse)

    def _fill_cache(self, namespace):
        modules = self.module_loader.load(namespace)
        objects = []

        for module in modules:
            for attr_name in dir(module):
                if not attr_name.startswith('_'):
                    objects.append(getattr(module, attr_name))
        
        self._cache = objects
        return objects


class ClassLoader(ObjectLoader):
    """Loads classes out of plugin modules which are subclasses of a single
    given base class.
    """

    def _fill_cache(self, namespace, subclasses=None):
        objects = super(ClassLoader, self)._fill_cache(namespace)
        classes = []
        for cls in objects:
            if isinstance(cls, type):
                if subclasses is None:
                    classes.append(cls)
                elif issubclass(cls, subclasses) and cls is not subclasses:
                    classes.append(cls)

        self._cache = classes
        return classes


def unified_load(namespace, subclasses=None, recurse=False):
    """Provides a unified interface to both the module and class loaders,
    finding modules by default or classes if given a ``subclasses`` parameter.
    """

    if subclasses is not None:
        return ClassLoader(recurse=recurse).load(namespace, subclasses=subclasses)
    else:
        return ModuleLoader(recurse=recurse).load(namespace)


########NEW FILE########
__FILENAME__ = manager
class PluginManager(object):

    def __init__(self, plugins):
        self._plugins = plugins

    def __iter__(self):
        return iter(self._plugins)

    def __len__(self):
        return len(self._plugins)

    def __getitem__(self, index):
        return self._plugins[index]

    def produce(self, *args, **kwargs):
        """Produce a new set of plugins, treating the current set as plugin
        factories.
        """

        new_plugins = []
        for p in self._plugins:
            r = p(*args, **kwargs)
            new_plugins.append(r)
        return PluginManager(new_plugins)

    def call(self, methodname, *args, **kwargs):
        """Call a common method on all the plugins, if it exists."""

        for plugin in self._plugins:
            method = getattr(plugin, methodname, None)
            if method is None:
                continue
            yield method(*args, **kwargs)

    def first(self, methodname, *args, **kwargs):
        """Call a common method on all the plugins, if it exists. Return the
        first result (the first non-None)
        """

        for r in self.call(methodname, *args, **kwargs):
            if r is not None:
                return r

        raise ValueError("No plugins returned a non-None value")

    def pipe(self, methodname, first_arg, *args, **kwargs):
        """Call a common method on all the plugins, if it exists. The return
        value of each call becomes the replaces the first argument in the given
        argument list to pass to the next.

        Useful to utilize plugins as sets of filters.
        """

        for plugin in self._plugins:
            method = getattr(plugin, methodname, None)
            if method is None:
                continue
            r = method(first_arg, *args, **kwargs)
            if r is not None:
                first_arg = r
        return r


########NEW FILE########
__FILENAME__ = testclasses
class A(object):
    class __plugin__:
        priority = 0.5

class B(object):
    class __plugin__:
        priority = 1.0

class A1(A):
    pass

########NEW FILE########
__FILENAME__ = foo
class __plugin__:
    imply_plugins = (
        'testplugin_2',
    )
    load = False
def do(x):
    return x + 1

########NEW FILE########
__FILENAME__ = bar
def do(x):
    return x + 1

########NEW FILE########
__FILENAME__ = bar
def do(x):
    return x + 1

########NEW FILE########
__FILENAME__ = foo
def do(x):
    return x + " from pep-420"

########NEW FILE########
__FILENAME__ = foo
def do(x):
    return x + 1

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python

import sys
import os
import unittest
from types import ModuleType

import mock

from straight.plugin import loaders, manager

try:
    skipIf = unittest.skipIf
except AttributeError:
    import functools

    class SkipTest(Exception):
        """
        Raise this exception in a test to skip it.

        Usually you can use TestResult.skip() or one of the skipping decorators
        instead of raising this directly.
        """
    def skipIf(cond, reason):
        """
        Unconditionally skip a test.
        """
        def decorator(test_item):
            if cond:
                if not isinstance(test_item, type):
                    @functools.wraps(test_item)
                    def skip_wrapper(*args, **kwargs):
                        pass
                    test_item = skip_wrapper

                test_item.__unittest_skip__ = True
                test_item.__unittest_skip_why__ = reason
                return test_item
            else:
                return test_item
        return decorator


class LoaderTestCaseMixin(object):

    paths = []

    def setUp(self):
        for path in self.paths:
            if isinstance(path, tuple):
                path = os.path.join(*path)
            sys.path.append(path)

        super(LoaderTestCaseMixin, self).setUp()

    def tearDown(self):
        for path in self.paths:
            del sys.path[-1]
        for modname in list(sys.modules):
            if modname.startswith('testplugin'):
                del sys.modules[modname]


class ModuleLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'more-test-plugins'),
        os.path.join(os.path.dirname(__file__), 'test-packages', 'some-test-plugins'),
    )
    
    def setUp(self):
        self.loader = loaders.ModuleLoader()
        super(ModuleLoaderTestCase, self).setUp()
    
    def test_load(self):
        modules = list(self.loader.load('testplugin'))
        assert len(modules) == 2, modules

    def test_plugin(self):
        assert self.loader.load('testplugin')[0].do(1) == 2


class ImpliedNamespaceModuleTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'pep-420-plugins'),
    )
    
    def setUp(self):
        self.loader = loaders.ModuleLoader()
        super(ImpliedNamespaceModuleTestCase, self).setUp()
    
    @skipIf(sys.version_info < (3, 3),"Python < 3.3")
    def test_load(self):
        modules = list(self.loader.load('testplugin'))
        assert len(modules) == 1, modules

    @skipIf(sys.version_info < (3, 3), "Python < 3.3")
    def test_plugin(self):
        r = self.loader.load('testplugin')[0].do("implied namespace packages are")
        self.assertEqual(r, "implied namespace packages are from pep-420")


class ImplyLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'imply-plugins'),
    )
    
    def setUp(self):
        self.loader = loaders.ModuleLoader()
        super(ImplyLoaderTestCase, self).setUp()
    
    def test_load(self):
        modules = list(self.loader.load('testplugin'))
        assert len(modules) == 1, modules
        assert modules[0].__name__ == 'testplugin_2.bar', modules[0].__name__


class ObjectLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'more-test-plugins'),
        os.path.join(os.path.dirname(__file__), 'test-packages', 'some-test-plugins'),
    )

    def setUp(self):
        self.loader = loaders.ObjectLoader()
        super(ObjectLoaderTestCase, self).setUp()

    def test_load_all(self):
        objects = list(self.loader.load('testplugin'))
        self.assertEqual(len(objects), 2, str(objects)[:100] + ' ...')


class ClassLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'class-test-plugins'),
    )

    def setUp(self):
        self.loader = loaders.ClassLoader()
        super(ClassLoaderTestCase, self).setUp()

    def test_all_classes(self):
        classes = list(self.loader.load('testplugin'))

        self.assertEqual(len(classes), 3)

    def test_subclasses(self):
        from testplugin import testclasses
        classes = list(self.loader.load('testplugin', subclasses=testclasses.A))

        self.assertEqual(len(classes), 1)
        self.assertTrue(classes[0] is testclasses.A1)

class PriorityLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):

    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'class-test-plugins'),
    )

    def setUp(self):
        self.loader = loaders.ClassLoader()
        super(PriorityLoaderTestCase, self).setUp()

    def test_all_classes(self):
        classes = list(self.loader.load('testplugin'))

        self.assertEqual(classes[0].__name__, 'B')
        self.assertEqual(classes[1].__name__, 'A')
        self.assertEqual(classes[2].__name__, 'A1')

class PackageLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):
    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'package-test-plugins'),
    )

    def setUp(self):
        self.loader = loaders.ModuleLoader()
        super(PackageLoaderTestCase, self).setUp()
    
    def test_find_packages(self):
        filepaths = list(self.loader._findPluginFilePaths('testplugin'))

        self.assertEqual(len(filepaths), 3)


    def test_load_packages(self):
        packages = list(self.loader.load('testplugin'))

        self.assertEqual(len(packages), 3)

        for pkg in packages:
            self.assertTrue(isinstance(pkg, ModuleType))

    def test_plugin(self):
        plugins = self.loader.load('testplugin')

        results = set(p.do(1) for p in plugins)

        self.assertEqual(results, set((2, 3, 4)))


class RecursingPackageLoaderTestCase(LoaderTestCaseMixin, unittest.TestCase):
    paths = (
        os.path.join(os.path.dirname(__file__), 'test-packages', 'package-test-plugins'),
    )

    def setUp(self):
        self.loader = loaders.ModuleLoader(recurse=True)
        super(RecursingPackageLoaderTestCase, self).setUp()

    def test_find_packages(self):
        filepaths = list(self.loader._findPluginFilePaths('testplugin'))

        self.assertEqual(len(filepaths), 4)


    def test_load_packages(self):
        packages = list(self.loader.load('testplugin'))

        self.assertEqual(len(packages), 4)

        for pkg in packages:
            self.assertTrue(isinstance(pkg, ModuleType))

    def test_plugin(self):
        plugins = self.loader.load('testplugin')

        results = set(p.do(1) for p in plugins)

        self.assertEqual(results, set((2, 3, 4, 'quu')))


class PluginManagerTestCase(unittest.TestCase):

    def setUp(self):
        self.m = manager.PluginManager([
            mock.Mock(),
            mock.Mock(),
        ])

    def test_first(self):
        self.m._plugins[0].x.return_value = 1

        self.assertEqual(1, self.m.first('x', 'a'))
        self.assertFalse(self.m._plugins[1].called)
        self.assertTrue(self.m._plugins[0].called_with('a'))

    def test_pipe(self):
        def plus_one(x):
            return x + 1
        self.m._plugins[0].x.side_effect = plus_one
        self.m._plugins[1].x.side_effect = plus_one

        self.assertEqual(3, self.m.pipe('x', 1))

    def test_call(self):
        results = self.m.call('x', 1)
        self.assertTrue(self.m._plugins[0].called_with('a'))
        self.assertTrue(self.m._plugins[1].x.called_with(1))

    def test_produce(self):
        products = self.m.produce(1, 2)
        assert products[0] is self.m._plugins[0].return_value
        self.m._plugins[0].called_with(1, 2)
        assert products[1] is self.m._plugins[1].return_value
        self.m._plugins[1].called_with(1, 2)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
