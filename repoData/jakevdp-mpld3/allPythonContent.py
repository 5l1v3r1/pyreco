__FILENAME__ = create_example
import os
import urllib2
import numpy as np
import matplotlib.pyplot as plt
from mpld3 import fig_to_d3, show_d3

# Download d3 file locally
d3_filename = 'd3.v3.min.js'
if not os.path.exists(d3_filename):
    page = urllib2.urlopen('http://d3js.org/d3.v3.min.js')
    with open(d3_filename, 'w') as f:
        f.write(page.read())

#----------------------------------------------------------------------
# create the figure and axes
fig, ax = plt.subplots(2, 2, figsize=(8, 8),
                       subplot_kw={'axisbg':'#EEEEEE'})

for axi in ax.flat:
    axi.grid(color='white', linestyle='solid')

#----------------------------------------------------------------------
# first plot: an image
x = np.linspace(-2, 2, 20)
y = x[:, None]
X = np.zeros((20, 20, 4))

X[:, :, 0] = np.exp(- (x - 1) ** 2 - (y) ** 2)
X[:, :, 1] = np.exp(- (x + 0.71) ** 2 - (y - 0.71) ** 2)
X[:, :, 2] = np.exp(- (x + 0.71) ** 2 - (y + 0.71) ** 2)
X[:, :, 3] = np.exp(-0.25 * (x ** 2 + y ** 2))

ax[0, 0].imshow(X)
ax[0, 0].set_title('An Image')
ax[0, 0].grid()

#----------------------------------------------------------------------
# second plot: scatter
x = np.random.normal(size=100)
y = np.random.normal(size=100)
c = np.random.random(100)
s = 100 + 500 * np.random.random(100)

ax[0, 1].scatter(x, y, c=c, s=s, alpha=0.3)
ax[0, 1].set_title('A Scatter Plot')

#----------------------------------------------------------------------
# third plot: some random lines
x = np.linspace(0, 10, 100)
y = np.sin(x)
dy = 0.4

ax[1, 0].plot(x, y, '--k', lw=2)

for i in range(20):
    y_plot = np.convolve(np.ones(5) / 5., np.random.normal(y, dy), mode='same')
    ax[1, 0].plot(x, y_plot, '-b', lw=2, alpha=0.1)

ax[1, 0].set_title('Transparent Lines')

#----------------------------------------------------------------------
# fourth plot: filled regions
x = np.linspace(0, 4 * np.pi, 100)
y1 = np.sin(x / 2)
y2 = np.sin(x)

ax[1, 1].fill_between(x, y1, y2, where=y1 > y2,
                      color='blue', alpha=0.3)
ax[1, 1].fill_between(x, y1, y2, where=y1 <= y2,
                 color='red', alpha=0.3)
ax[1, 1].set_title('fill_between()')

show_d3()

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# mpld3 documentation build configuration file, created by
# sphinx-quickstart on Mon Jan 27 20:45:33 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('sphinxext'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.autosummary',
    'sphinx.ext.doctest',
    'sphinx.ext.coverage',
    'sphinx.ext.viewcode',
]

import numpy_ext.numpydoc
extensions.append('numpy_ext.numpydoc')

import plot_generator
extensions.append('plot_generator')

import notebook_converter
extensions.append('notebook_converter')

autosummary_generate=True

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'mpld3'
copyright = u'2014, mpld3 developers'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
import mpld3
version = mpld3.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'mpld3'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "Bringing Matplotlib to the Browser"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = 'logos/mpld3-medium.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'logos/favicon.png'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'mpld3doc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'mpld3.tex', u'mpld3 Documentation',
   u'mpld3 developers', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'mpld3', u'mpld3 Documentation',
     [u'mpld3 developers'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'mpld3', u'mpld3 Documentation',
   u'mpld3 developers', 'mpld3', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = notebook_converter
import sys
import os
import glob
import shutil
import jinja2

from IPython.nbformat import current as nbformat
from IPython.nbconvert.exporters import HTMLExporter


INDEX_TEMPLATE = jinja2.Template("""
.. _{{ sphinx_tag }}:

Notebook Examples
=================

.. toctree::
   {% for notebook in notebooks %}
   ./{{ notebook }}
   {% endfor %}

""")


RST_TEMPLATE = jinja2.Template("""
{{ title }}
{% for c in title %}={% endfor %}

[
:download:`{{ nbroot }}.html <rendered/{{ nbroot }}.html>`
|
:download:`{{ nbroot }}.ipynb <{{ nbroot }}.ipynb>`
]

.. raw:: html

    <iframe src="../_downloads/{{ nbroot }}.html"
      width="100%" height="400px"></iframe>

""")


def get_notebook_title(nb_json, default=None):
    """Determine a suitable title for the notebook.

    This will return the text of the first header cell.
    If that does not exist, it will return the default.
    """
    worksheets = nb_json['worksheets']
    cells = worksheets[0]['cells']
    for cell in cells:
        if cell['cell_type'] == 'heading':
            return cell['source']
    return default


def main(app):
    static_dir = os.path.join(app.builder.srcdir, '_static')
    target_dir = os.path.join(app.builder.srcdir, 'notebooks')
    source_dir = os.path.abspath(os.path.join(app.builder.srcdir,
                                              '..', 'notebooks'))

    rendered_dir = os.path.join(target_dir, 'rendered')

    if not os.path.exists(static_dir):
        os.makedirs(static_dir)

    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    if not os.path.exists(rendered_dir):
        os.makedirs(rendered_dir)

    nbroots = []
    nbtitles = []
    exporter = HTMLExporter(template_file='full')

    for nb_src in glob.glob(os.path.join(source_dir, '*.ipynb')):
        print("converting notebook {0}".format(nb_src))
        basedir, nbname = os.path.split(nb_src)
        nb_dest = os.path.join(target_dir, nbname)
        shutil.copyfile(nb_src, nb_dest)

        with open(nb_dest, 'r') as f:
            nb_json = nbformat.reads_json(f.read())

        (body, resources) = exporter.from_notebook_node(nb_json)

        root, ext = os.path.splitext(nbname)
        nb_html_dest = os.path.join(rendered_dir, root + '.html')
        with open(nb_html_dest, 'w') as f:
            f.write(body)

        nbroots.append(root)
        nbtitles.append(get_notebook_title(nb_json, root))

    for nbroot, nbtitle in zip(nbroots, nbtitles):
        with open(os.path.join(target_dir, nbroot + '.rst'), 'w') as f:
            f.write(RST_TEMPLATE.render(title=nbtitle, nbroot=nbroot))

    with open(os.path.join(target_dir, 'index.rst'), 'w') as f:
        f.write(INDEX_TEMPLATE.render(notebooks=nbroots,
                                      sphinx_tag='notebook-examples'))


def setup(app):
    app.connect('builder-inited', main)

########NEW FILE########
__FILENAME__ = docscrape
"""Extract reference documentation from the NumPy source tree.

"""

import inspect
import textwrap
import re
import pydoc
from StringIO import StringIO
from warnings import warn

class Reader(object):
    """A line-based string reader.

    """
    def __init__(self, data):
        """
        Parameters
        ----------
        data : str
           String with lines separated by '\n'.

        """
        if isinstance(data,list):
            self._str = data
        else:
            self._str = data.split('\n') # store string as list of lines

        self.reset()

    def __getitem__(self, n):
        return self._str[n]

    def reset(self):
        self._l = 0 # current line nr

    def read(self):
        if not self.eof():
            out = self[self._l]
            self._l += 1
            return out
        else:
            return ''

    def seek_next_non_empty_line(self):
        for l in self[self._l:]:
            if l.strip():
                break
            else:
                self._l += 1

    def eof(self):
        return self._l >= len(self._str)

    def read_to_condition(self, condition_func):
        start = self._l
        for line in self[start:]:
            if condition_func(line):
                return self[start:self._l]
            self._l += 1
            if self.eof():
                return self[start:self._l+1]
        return []

    def read_to_next_empty_line(self):
        self.seek_next_non_empty_line()
        def is_empty(line):
            return not line.strip()
        return self.read_to_condition(is_empty)

    def read_to_next_unindented_line(self):
        def is_unindented(line):
            return (line.strip() and (len(line.lstrip()) == len(line)))
        return self.read_to_condition(is_unindented)

    def peek(self,n=0):
        if self._l + n < len(self._str):
            return self[self._l + n]
        else:
            return ''

    def is_empty(self):
        return not ''.join(self._str).strip()


class NumpyDocString(object):
    def __init__(self, docstring, config={}):
        docstring = textwrap.dedent(docstring).split('\n')

        self._doc = Reader(docstring)
        self._parsed_data = {
            'Signature': '',
            'Summary': [''],
            'Extended Summary': [],
            'Parameters': [],
            'Returns': [],
            'Raises': [],
            'Warns': [],
            'Other Parameters': [],
            'Attributes': [],
            'Methods': [],
            'See Also': [],
            'Notes': [],
            'Warnings': [],
            'References': '',
            'Examples': '',
            'index': {}
            }

        self._parse()

    def __getitem__(self,key):
        return self._parsed_data[key]

    def __setitem__(self,key,val):
        if not self._parsed_data.has_key(key):
            warn("Unknown section %s" % key)
        else:
            self._parsed_data[key] = val

    def _is_at_section(self):
        self._doc.seek_next_non_empty_line()

        if self._doc.eof():
            return False

        l1 = self._doc.peek().strip()  # e.g. Parameters

        if l1.startswith('.. index::'):
            return True

        l2 = self._doc.peek(1).strip() #    ---------- or ==========
        return l2.startswith('-'*len(l1)) or l2.startswith('='*len(l1))

    def _strip(self,doc):
        i = 0
        j = 0
        for i,line in enumerate(doc):
            if line.strip(): break

        for j,line in enumerate(doc[::-1]):
            if line.strip(): break

        return doc[i:len(doc)-j]

    def _read_to_next_section(self):
        section = self._doc.read_to_next_empty_line()

        while not self._is_at_section() and not self._doc.eof():
            if not self._doc.peek(-1).strip(): # previous line was empty
                section += ['']

            section += self._doc.read_to_next_empty_line()

        return section

    def _read_sections(self):
        while not self._doc.eof():
            data = self._read_to_next_section()
            name = data[0].strip()

            if name.startswith('..'): # index section
                yield name, data[1:]
            elif len(data) < 2:
                yield StopIteration
            else:
                yield name, self._strip(data[2:])

    def _parse_param_list(self,content):
        r = Reader(content)
        params = []
        while not r.eof():
            header = r.read().strip()
            if ' : ' in header:
                arg_name, arg_type = header.split(' : ')[:2]
            else:
                arg_name, arg_type = header, ''

            desc = r.read_to_next_unindented_line()
            desc = dedent_lines(desc)

            params.append((arg_name,arg_type,desc))

        return params


    _name_rgx = re.compile(r"^\s*(:(?P<role>\w+):`(?P<name>[a-zA-Z0-9_.-]+)`|"
                           r" (?P<name2>[a-zA-Z0-9_.-]+))\s*", re.X)
    def _parse_see_also(self, content):
        """
        func_name : Descriptive text
            continued text
        another_func_name : Descriptive text
        func_name1, func_name2, :meth:`func_name`, func_name3

        """
        items = []

        def parse_item_name(text):
            """Match ':role:`name`' or 'name'"""
            m = self._name_rgx.match(text)
            if m:
                g = m.groups()
                if g[1] is None:
                    return g[3], None
                else:
                    return g[2], g[1]
            raise ValueError("%s is not a item name" % text)

        def push_item(name, rest):
            if not name:
                return
            name, role = parse_item_name(name)
            items.append((name, list(rest), role))
            del rest[:]

        current_func = None
        rest = []

        for line in content:
            if not line.strip(): continue

            m = self._name_rgx.match(line)
            if m and line[m.end():].strip().startswith(':'):
                push_item(current_func, rest)
                current_func, line = line[:m.end()], line[m.end():]
                rest = [line.split(':', 1)[1].strip()]
                if not rest[0]:
                    rest = []
            elif not line.startswith(' '):
                push_item(current_func, rest)
                current_func = None
                if ',' in line:
                    for func in line.split(','):
                        push_item(func, [])
                elif line.strip():
                    current_func = line
            elif current_func is not None:
                rest.append(line.strip())
        push_item(current_func, rest)
        return items

    def _parse_index(self, section, content):
        """
        .. index: default
           :refguide: something, else, and more

        """
        def strip_each_in(lst):
            return [s.strip() for s in lst]

        out = {}
        section = section.split('::')
        if len(section) > 1:
            out['default'] = strip_each_in(section[1].split(','))[0]
        for line in content:
            line = line.split(':')
            if len(line) > 2:
                out[line[1]] = strip_each_in(line[2].split(','))
        return out

    def _parse_summary(self):
        """Grab signature (if given) and summary"""
        if self._is_at_section():
            return

        summary = self._doc.read_to_next_empty_line()
        summary_str = " ".join([s.strip() for s in summary]).strip()
        if re.compile('^([\w., ]+=)?\s*[\w\.]+\(.*\)$').match(summary_str):
            self['Signature'] = summary_str
            if not self._is_at_section():
                self['Summary'] = self._doc.read_to_next_empty_line()
        else:
            self['Summary'] = summary

        if not self._is_at_section():
            self['Extended Summary'] = self._read_to_next_section()

    def _parse(self):
        self._doc.reset()
        self._parse_summary()

        for (section,content) in self._read_sections():
            if not section.startswith('..'):
                section = ' '.join([s.capitalize() for s in section.split(' ')])
            if section in ('Parameters', 'Attributes', 'Methods',
                           'Returns', 'Raises', 'Warns'):
                self[section] = self._parse_param_list(content)
            elif section.startswith('.. index::'):
                self['index'] = self._parse_index(section, content)
            elif section == 'See Also':
                self['See Also'] = self._parse_see_also(content)
            else:
                self[section] = content

    # string conversion routines

    def _str_header(self, name, symbol='-'):
        return [name, len(name)*symbol]

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        if self['Signature']:
            return [self['Signature'].replace('*','\*')] + ['']
        else:
            return ['']

    def _str_summary(self):
        if self['Summary']:
            return self['Summary'] + ['']
        else:
            return []

    def _str_extended_summary(self):
        if self['Extended Summary']:
            return self['Extended Summary'] + ['']
        else:
            return []

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            for param,param_type,desc in self[name]:
                out += ['%s : %s' % (param, param_type)]
                out += self._str_indent(desc)
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += self[name]
            out += ['']
        return out

    def _str_see_also(self, func_role):
        if not self['See Also']: return []
        out = []
        out += self._str_header("See Also")
        last_had_desc = True
        for func, desc, role in self['See Also']:
            if role:
                link = ':%s:`%s`' % (role, func)
            elif func_role:
                link = ':%s:`%s`' % (func_role, func)
            else:
                link = "`%s`_" % func
            if desc or last_had_desc:
                out += ['']
                out += [link]
            else:
                out[-1] += ", %s" % link
            if desc:
                out += self._str_indent([' '.join(desc)])
                last_had_desc = True
            else:
                last_had_desc = False
        out += ['']
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            out += ['   :%s: %s' % (section, ', '.join(references))]
        return out

    def __str__(self, func_role=''):
        out = []
        out += self._str_signature()
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters','Returns','Raises'):
            out += self._str_param_list(param_list)
        out += self._str_section('Warnings')
        out += self._str_see_also(func_role)
        for s in ('Notes','References','Examples'):
            out += self._str_section(s)
        for param_list in ('Attributes', 'Methods'):
            out += self._str_param_list(param_list)
        out += self._str_index()
        return '\n'.join(out)


def indent(str,indent=4):
    indent_str = ' '*indent
    if str is None:
        return indent_str
    lines = str.split('\n')
    return '\n'.join(indent_str + l for l in lines)

def dedent_lines(lines):
    """Deindent a list of lines maximally"""
    return textwrap.dedent("\n".join(lines)).split("\n")

def header(text, style='-'):
    return text + '\n' + style*len(text) + '\n'


class FunctionDoc(NumpyDocString):
    def __init__(self, func, role='func', doc=None, config={}):
        self._f = func
        self._role = role # e.g. "func" or "meth"

        if doc is None:
            if func is None:
                raise ValueError("No function or docstring given")
            doc = inspect.getdoc(func) or ''
        NumpyDocString.__init__(self, doc)

        if not self['Signature'] and func is not None:
            func, func_name = self.get_func()
            try:
                # try to read signature
                argspec = inspect.getargspec(func)
                argspec = inspect.formatargspec(*argspec)
                argspec = argspec.replace('*','\*')
                signature = '%s%s' % (func_name, argspec)
            except TypeError, e:
                signature = '%s()' % func_name
            self['Signature'] = signature

    def get_func(self):
        func_name = getattr(self._f, '__name__', self.__class__.__name__)
        if inspect.isclass(self._f):
            func = getattr(self._f, '__call__', self._f.__init__)
        else:
            func = self._f
        return func, func_name

    def __str__(self):
        out = ''

        func, func_name = self.get_func()
        signature = self['Signature'].replace('*', '\*')

        roles = {'func': 'function',
                 'meth': 'method'}

        if self._role:
            if not roles.has_key(self._role):
                print "Warning: invalid role %s" % self._role
            out += '.. %s:: %s\n    \n\n' % (roles.get(self._role,''),
                                             func_name)

        out += super(FunctionDoc, self).__str__(func_role=self._role)
        return out


class ClassDoc(NumpyDocString):
    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,
                 config=None):
        if not inspect.isclass(cls) and cls is not None:
            raise ValueError("Expected a class or None, but got %r" % cls)
        self._cls = cls

        if modulename and not modulename.endswith('.'):
            modulename += '.'
        self._mod = modulename

        if doc is None:
            if cls is None:
                raise ValueError("No class or documentation string given")
            doc = pydoc.getdoc(cls)

        NumpyDocString.__init__(self, doc)

        if config is not None and config.get('show_class_members', True):
            if not self['Methods']:
                self['Methods'] = [(name, '', '')
                                   for name in sorted(self.methods)]
            if not self['Attributes']:
                self['Attributes'] = [(name, '', '')
                                      for name in sorted(self.properties)]

    @property
    def methods(self):
        if self._cls is None:
            return []
        return [name for name,func in inspect.getmembers(self._cls)
                if not name.startswith('_') and callable(func)]

    @property
    def properties(self):
        if self._cls is None:
            return []
        return [name for name,func in inspect.getmembers(self._cls)
                if not name.startswith('_') and func is None]

########NEW FILE########
__FILENAME__ = docscrape_sphinx
import re, inspect, textwrap, pydoc
import sphinx
from docscrape import NumpyDocString, FunctionDoc, ClassDoc

class SphinxDocString(NumpyDocString):
    def __init__(self, docstring, config=None):
        config = {} if config is None else config
        self.use_plots = config.get('use_plots', False)
        NumpyDocString.__init__(self, docstring, config=config)

    # string conversion routines
    def _str_header(self, name, symbol='`'):
        return ['.. rubric:: ' + name, '']

    def _str_field_list(self, name):
        return [':' + name + ':']

    def _str_indent(self, doc, indent=4):
        out = []
        for line in doc:
            out += [' '*indent + line]
        return out

    def _str_signature(self):
        return ['']
        if self['Signature']:
            return ['``%s``' % self['Signature']] + ['']
        else:
            return ['']

    def _str_summary(self):
        return self['Summary'] + ['']

    def _str_extended_summary(self):
        return self['Extended Summary'] + ['']

    def _str_param_list(self, name):
        out = []
        if self[name]:
            out += self._str_field_list(name)
            out += ['']
            for param,param_type,desc in self[name]:
                out += self._str_indent(['**%s** : %s' % (param.strip(),
                                                          param_type)])
                out += ['']
                out += self._str_indent(desc,8)
                out += ['']
        return out

    @property
    def _obj(self):
        if hasattr(self, '_cls'):
            return self._cls
        elif hasattr(self, '_f'):
            return self._f
        return None

    def _str_member_list(self, name):
        """
        Generate a member listing, autosummary:: table where possible,
        and a table where not.

        """
        out = []
        if self[name]:
            out += ['.. rubric:: %s' % name, '']
            prefix = getattr(self, '_name', '')

            if prefix:
                prefix = '~%s.' % prefix

            autosum = []
            others = []
            for param, param_type, desc in self[name]:
                param = param.strip()
                if not self._obj or hasattr(self._obj, param):
                    autosum += ["   %s%s" % (prefix, param)]
                else:
                    others.append((param, param_type, desc))

            if autosum:
                # GAEL: Toctree commented out below because it creates
                # hundreds of sphinx warnings
                # out += ['.. autosummary::', '   :toctree:', '']
                out += ['.. autosummary::', '']
                out += autosum

            if others:
                maxlen_0 = max([len(x[0]) for x in others])
                maxlen_1 = max([len(x[1]) for x in others])
                hdr = "="*maxlen_0 + "  " + "="*maxlen_1 + "  " + "="*10
                fmt = '%%%ds  %%%ds  ' % (maxlen_0, maxlen_1)
                n_indent = maxlen_0 + maxlen_1 + 4
                out += [hdr]
                for param, param_type, desc in others:
                    out += [fmt % (param.strip(), param_type)]
                    out += self._str_indent(desc, n_indent)
                out += [hdr]
            out += ['']
        return out

    def _str_section(self, name):
        out = []
        if self[name]:
            out += self._str_header(name)
            out += ['']
            content = textwrap.dedent("\n".join(self[name])).split("\n")
            out += content
            out += ['']
        return out

    def _str_see_also(self, func_role):
        out = []
        if self['See Also']:
            see_also = super(SphinxDocString, self)._str_see_also(func_role)
            out = ['.. seealso::', '']
            out += self._str_indent(see_also[2:])
        return out

    def _str_warnings(self):
        out = []
        if self['Warnings']:
            out = ['.. warning::', '']
            out += self._str_indent(self['Warnings'])
        return out

    def _str_index(self):
        idx = self['index']
        out = []
        if len(idx) == 0:
            return out

        out += ['.. index:: %s' % idx.get('default','')]
        for section, references in idx.iteritems():
            if section == 'default':
                continue
            elif section == 'refguide':
                out += ['   single: %s' % (', '.join(references))]
            else:
                out += ['   %s: %s' % (section, ','.join(references))]
        return out

    def _str_references(self):
        out = []
        if self['References']:
            out += self._str_header('References')
            if isinstance(self['References'], str):
                self['References'] = [self['References']]
            out.extend(self['References'])
            out += ['']
            # Latex collects all references to a separate bibliography,
            # so we need to insert links to it
            if sphinx.__version__ >= "0.6":
                out += ['.. only:: latex','']
            else:
                out += ['.. latexonly::','']
            items = []
            for line in self['References']:
                m = re.match(r'.. \[([a-z0-9._-]+)\]', line, re.I)
                if m:
                    items.append(m.group(1))
            out += ['   ' + ", ".join(["[%s]_" % item for item in items]), '']
        return out

    def _str_examples(self):
        examples_str = "\n".join(self['Examples'])

        if (self.use_plots and 'import matplotlib' in examples_str
                and 'plot::' not in examples_str):
            out = []
            out += self._str_header('Examples')
            out += ['.. plot::', '']
            out += self._str_indent(self['Examples'])
            out += ['']
            return out
        else:
            return self._str_section('Examples')

    def __str__(self, indent=0, func_role="obj"):
        out = []
        out += self._str_signature()
        out += self._str_index() + ['']
        out += self._str_summary()
        out += self._str_extended_summary()
        for param_list in ('Parameters', 'Returns', 'Raises'):
            out += self._str_param_list(param_list)
        out += self._str_warnings()
        out += self._str_see_also(func_role)
        out += self._str_section('Notes')
        out += self._str_references()
        out += self._str_examples()
        for param_list in ('Attributes', 'Methods'):
            out += self._str_member_list(param_list)
        out = self._str_indent(out,indent)
        return '\n'.join(out)

class SphinxFunctionDoc(SphinxDocString, FunctionDoc):
    def __init__(self, obj, doc=None, config={}):
        self.use_plots = config.get('use_plots', False)
        FunctionDoc.__init__(self, obj, doc=doc, config=config)

class SphinxClassDoc(SphinxDocString, ClassDoc):
    def __init__(self, obj, doc=None, func_doc=None, config={}):
        self.use_plots = config.get('use_plots', False)
        ClassDoc.__init__(self, obj, doc=doc, func_doc=None, config=config)

class SphinxObjDoc(SphinxDocString):
    def __init__(self, obj, doc=None, config=None):
        self._f = obj
        SphinxDocString.__init__(self, doc, config=config)

def get_doc_object(obj, what=None, doc=None, config={}):
    if what is None:
        if inspect.isclass(obj):
            what = 'class'
        elif inspect.ismodule(obj):
            what = 'module'
        elif callable(obj):
            what = 'function'
        else:
            what = 'object'
    if what == 'class':
        return SphinxClassDoc(obj, func_doc=SphinxFunctionDoc, doc=doc,
                              config=config)
    elif what in ('function', 'method'):
        return SphinxFunctionDoc(obj, doc=doc, config=config)
    else:
        if doc is None:
            doc = pydoc.getdoc(obj)
        return SphinxObjDoc(obj, doc, config=config)

########NEW FILE########
__FILENAME__ = numpydoc
"""
========
numpydoc
========

Sphinx extension that handles docstrings in the Numpy standard format. [1]

It will:

- Convert Parameters etc. sections to field lists.
- Convert See Also section to a See also entry.
- Renumber references.
- Extract the signature from the docstring, if it can't be determined otherwise.

.. [1] http://projects.scipy.org/numpy/wiki/CodingStyleGuidelines#docstring-standard

"""

import os, re, pydoc
from docscrape_sphinx import get_doc_object, SphinxDocString
from sphinx.util.compat import Directive
import inspect

def mangle_docstrings(app, what, name, obj, options, lines,
                      reference_offset=[0]):

    cfg = dict(use_plots=app.config.numpydoc_use_plots,
               show_class_members=app.config.numpydoc_show_class_members)

    if what == 'module':
        # Strip top title
        title_re = re.compile(ur'^\s*[#*=]{4,}\n[a-z0-9 -]+\n[#*=]{4,}\s*',
                              re.I|re.S)
        lines[:] = title_re.sub(u'', u"\n".join(lines)).split(u"\n")
    else:
        doc = get_doc_object(obj, what, u"\n".join(lines), config=cfg)
        lines[:] = unicode(doc).split(u"\n")

    if app.config.numpydoc_edit_link and hasattr(obj, '__name__') and \
           obj.__name__:
        if hasattr(obj, '__module__'):
            v = dict(full_name=u"%s.%s" % (obj.__module__, obj.__name__))
        else:
            v = dict(full_name=obj.__name__)
        lines += [u'', u'.. htmlonly::', '']
        lines += [u'    %s' % x for x in
                  (app.config.numpydoc_edit_link % v).split("\n")]

    # replace reference numbers so that there are no duplicates
    references = []
    for line in lines:
        line = line.strip()
        m = re.match(ur'^.. \[([a-z0-9_.-])\]', line, re.I)
        if m:
            references.append(m.group(1))

    # start renaming from the longest string, to avoid overwriting parts
    references.sort(key=lambda x: -len(x))
    if references:
        for i, line in enumerate(lines):
            for r in references:
                if re.match(ur'^\d+$', r):
                    new_r = u"R%d" % (reference_offset[0] + int(r))
                else:
                    new_r = u"%s%d" % (r, reference_offset[0])
                lines[i] = lines[i].replace(u'[%s]_' % r,
                                            u'[%s]_' % new_r)
                lines[i] = lines[i].replace(u'.. [%s]' % r,
                                            u'.. [%s]' % new_r)

    reference_offset[0] += len(references)

def mangle_signature(app, what, name, obj, options, sig, retann):
    # Do not try to inspect classes that don't define `__init__`
    if (inspect.isclass(obj) and
        (not hasattr(obj, '__init__') or
        'initializes x; see ' in pydoc.getdoc(obj.__init__))):
        return '', ''

    if not (callable(obj) or hasattr(obj, '__argspec_is_invalid_')): return
    if not hasattr(obj, '__doc__'): return

    doc = SphinxDocString(pydoc.getdoc(obj))
    if doc['Signature']:
        sig = re.sub(u"^[^(]*", u"", doc['Signature'])
        return sig, u''

def setup(app, get_doc_object_=get_doc_object):
    global get_doc_object
    get_doc_object = get_doc_object_

    app.connect('autodoc-process-docstring', mangle_docstrings)
    app.connect('autodoc-process-signature', mangle_signature)
    app.add_config_value('numpydoc_edit_link', None, False)
    app.add_config_value('numpydoc_use_plots', None, False)
    app.add_config_value('numpydoc_show_class_members', True, True)

    # Extra mangling domains
    app.add_domain(NumpyPythonDomain)
    app.add_domain(NumpyCDomain)

#------------------------------------------------------------------------------
# Docstring-mangling domains
#------------------------------------------------------------------------------

from docutils.statemachine import ViewList
from sphinx.domains.c import CDomain
from sphinx.domains.python import PythonDomain

class ManglingDomainBase(object):
    directive_mangling_map = {}

    def __init__(self, *a, **kw):
        super(ManglingDomainBase, self).__init__(*a, **kw)
        self.wrap_mangling_directives()

    def wrap_mangling_directives(self):
        for name, objtype in self.directive_mangling_map.items():
            self.directives[name] = wrap_mangling_directive(
                self.directives[name], objtype)

class NumpyPythonDomain(ManglingDomainBase, PythonDomain):
    name = 'np'
    directive_mangling_map = {
        'function': 'function',
        'class': 'class',
        'exception': 'class',
        'method': 'function',
        'classmethod': 'function',
        'staticmethod': 'function',
        'attribute': 'attribute',
    }

class NumpyCDomain(ManglingDomainBase, CDomain):
    name = 'np-c'
    directive_mangling_map = {
        'function': 'function',
        'member': 'attribute',
        'macro': 'function',
        'type': 'class',
        'var': 'object',
    }

def wrap_mangling_directive(base_directive, objtype):
    class directive(base_directive):
        def run(self):
            env = self.state.document.settings.env

            name = None
            if self.arguments:
                m = re.match(r'^(.*\s+)?(.*?)(\(.*)?', self.arguments[0])
                name = m.group(2).strip()

            if not name:
                name = self.arguments[0]

            lines = list(self.content)
            mangle_docstrings(env.app, objtype, name, None, None, lines)
            self.content = ViewList(lines, self.content.parent)

            return base_directive.run(self)

    return directive


########NEW FILE########
__FILENAME__ = plot_generator
import sys
import os
import glob
import token
import tokenize
import shutil
import json

import matplotlib
matplotlib.use('Agg')  # don't display plots

import mpld3
from matplotlib import image
from matplotlib.figure import Figure


class disable_mpld3(object):
    """Context manager to temporarily disable mpld3.show() command"""
    def __enter__(self):
        self.show = mpld3.show
        mpld3.show = lambda *args, **kwargs: None
        return self

    def __exit__(self, type, value, traceback):
        mpld3.show = self.show


RST_TEMPLATE = """
.. _{sphinx_tag}:

{docstring}

.. raw:: html
    {img_html}

**Python source code:** :download:`[download source: {fname}]<{fname}>`

.. literalinclude:: {fname}
    :lines: {end_line}-
"""


INDEX_TEMPLATE = """

.. raw:: html

    <style type="text/css">
    .figure {{
        float: left;
        margin: 10px;
        width: 180px;
        height: 200px;
    }}

    .figure img {{
        display: inline;
        width: 170px;
        height: 170px;
        opacity:0.4;
        filter:alpha(opacity=40); /* For IE8 and earlier */
    }}

    .figure img:hover
    {{
        opacity:1.0;
        filter:alpha(opacity=100); /* For IE8 and earlier */
    }}

    .figure .caption {{
        width: 180px;
        text-align: center !important;
    }}
    </style>

.. _{sphinx_tag}:

Example Gallery
===============

{toctree}

{contents}

.. raw:: html

    <div style="clear: both"></div>
"""


BANNER_JS_TEMPLATE = """

var banner_data = {banner_data};

banner_data.forEach(function(d, i) {{
  d.i = i;
}});

var height = 150,
    width = 900,
    imageHeight = 150,
    imageWidth = 150,
    zoomfactor = 0.1;

var banner = d3.select(".example-banner");

banner.style("height", height + "px")
      .style("width", width + "px")
      .style("margin-left", "auto")
      .style("margin-right", "auto");

var svg = banner.append("svg")
                .attr("width", width + "px")
                .attr("height", height + "px");

var anchor = svg.append("g")
                  .attr("class", "example-anchor")
                .selectAll("a")
                .data(banner_data.slice(0, 7));

anchor.exit().remove();

var anchor_elements = anchor.enter().append("a")
      .attr("xlink:href", function(d) {{ return d.url; }})
      .attr("xlink:title", function(d) {{ return d.title; }});

anchor_elements.append("svg:image")
      .attr("width", (1 - zoomfactor) * imageWidth)
      .attr("height", (1 - zoomfactor) * imageHeight)
      .attr("xlink:href", function(d){{ return d.thumb; }})
      .attr("xroot", function(d){{return d3.round(imageWidth * (d.i - 0.5));}})
      .attr("x", function(d){{return d3.round(imageWidth * (d.i - 0.5));}})
      .attr("y", d3.round(0.5 * zoomfactor * imageHeight))
      .attr("i", function(d){{return d.i;}})
     .on("mouseover", function() {{
              var img = d3.select(this);
              img.transition()
                    .attr("width", imageWidth)
                    .attr("height", height)
                    .attr("x", img.attr("xroot")
                               - d3.round(0.5 * zoomfactor * imageWidth))
                    .attr("y", 0);
              }})
     .on("mouseout", function() {{
              var img = d3.select(this);
              img.transition()
                    .attr("width", (1 - zoomfactor) * imageWidth)
                    .attr("height", (1 - zoomfactor) * height)
                    .attr("x", img.attr("xroot"))
                    .attr("y", d3.round(0.5 * zoomfactor * imageHeight));
              }});
"""


def create_thumbnail(infile, thumbfile,
                     width=300, height=300,
                     cx=0.5, cy=0.6, border=4):
    # this doesn't really matter, it will cancel in the end, but we
    # need it for the mpl API
    dpi = 100

    baseout, extout = os.path.splitext(thumbfile)
    im = image.imread(infile)
    rows, cols = im.shape[:2]
    x0 = int(cx * cols - 0.5 * width)
    y0 = int(cy * rows - 0.5 * height)
    thumb = im[y0: y0 + height,
               x0: x0 + width]
    thumb[:border, :, :3] = thumb[-border:, :, :3] = 0
    thumb[:, :border, :3] = thumb[:, -border:, :3] = 0

    extension = extout.lower()

    if extension == '.png':
        from matplotlib.backends.backend_agg \
            import FigureCanvasAgg as FigureCanvas
    elif extension == '.pdf':
        from matplotlib.backends.backend_pdf \
            import FigureCanvasPDF as FigureCanvas
    elif extension == '.svg':
        from matplotlib.backends.backend_svg \
            import FigureCanvasSVG as FigureCanvas
    else:
        raise ValueError("Can only handle extensions 'png', 'svg' or 'pdf'")

    fig = Figure(figsize=(float(width) / dpi, float(height) / dpi),
                 dpi=dpi)
    canvas = FigureCanvas(fig)

    ax = fig.add_axes([0, 0, 1, 1], aspect='auto',
                      frameon=False, xticks=[], yticks=[])

    ax.imshow(thumb, aspect='auto', resample=True,
              interpolation='bilinear')
    fig.savefig(thumbfile, dpi=dpi)
    return fig


def indent(s, N=4):
    """indent a string"""
    return s.replace('\n', '\n' + N * ' ')


class ExampleGenerator(object):
    """Tools for generating an example page from a file"""
    def __init__(self, filename, target_dir):
        self.filename = filename
        self.target_dir = target_dir
        self.extract_docstring()
        self.exec_file()

    @property
    def dirname(self):
        return os.path.split(self.filename)[0]

    @property
    def fname(self):
        return os.path.split(self.filename)[1]

    @property
    def modulename(self):
        return os.path.splitext(self.fname)[0]

    @property
    def pyfilename(self):
        return self.modulename + '.py'

    @property
    def rstfilename(self):
        return self.modulename + ".rst"

    @property
    def htmlfilename(self):
        return self.modulename + '.html'

    @property
    def pngfilename(self):
        return self.modulename + '.png'

    @property
    def thumbfilename(self):
        # TODO: don't hard-code image path
        return "_images/" + self.pngfilename

    @property
    def sphinxtag(self):
        return self.modulename

    @property
    def pagetitle(self):
        return self.docstring.strip().split('\n')[0].strip()

    def extract_docstring(self):
        """ Extract a module-level docstring
        """
        lines = open(self.filename).readlines()
        start_row = 0
        if lines[0].startswith('#!'):
            lines.pop(0)
            start_row = 1

        docstring = ''
        first_par = ''
        tokens = tokenize.generate_tokens(lines.__iter__().next)
        for tok_type, tok_content, _, (erow, _), _ in tokens:
            tok_type = token.tok_name[tok_type]
            if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):
                continue
            elif tok_type == 'STRING':
                docstring = eval(tok_content)
                # If the docstring is formatted with several paragraphs,
                # extract the first one:
                paragraphs = '\n'.join(line.rstrip()
                                       for line in docstring.split('\n')
                                       ).split('\n\n')
                if len(paragraphs) > 0:
                    first_par = paragraphs[0]
            break

        self.docstring = docstring
        self.short_desc = first_par
        self.end_line = erow + 1 + start_row

    def exec_file(self):
        print("running {0}".format(self.filename))
        with disable_mpld3():
            import matplotlib.pyplot as plt
            plt.close('all')
            my_globals = {'pl': plt,
                          'plt': plt}
            execfile(self.filename, my_globals)

        fig = plt.gcf()
        self.html = mpld3.fig_to_html(fig)
        thumbfile = os.path.join(self.target_dir,
                                 self.pngfilename)
        fig.savefig(thumbfile)
        create_thumbnail(thumbfile, thumbfile)

    def toctree_entry(self):
        return "   ./%s\n\n" % os.path.splitext(self.htmlfilename)[0]

    def contents_entry(self):
        return (".. figure:: ./{0}\n"
                "    :target: ./{1}\n"
                "    :align: center\n\n"
                "    :ref:`{2}`\n\n".format(self.pngfilename,
                                            self.htmlfilename,
                                            self.sphinxtag))


def main(app):
    static_dir = os.path.join(app.builder.srcdir, '_static')
    target_dir = os.path.join(app.builder.srcdir, 'examples')
    source_dir = os.path.abspath(os.path.join(app.builder.srcdir,
                                              '..', 'examples'))
    if not os.path.exists(static_dir):
        os.makedirs(static_dir)

    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    banner_data = []

    toctree = ("\n\n"
               ".. toctree::\n"
               "   :hidden:\n\n")
    contents = "\n\n"

    # Write individual example files
    for filename in glob.glob(os.path.join(source_dir, "*.py")):
        ex = ExampleGenerator(filename, target_dir)

        banner_data.append({"title": ex.pagetitle,
                            "url": os.path.join('examples', ex.htmlfilename),
                            "thumb": os.path.join(ex.thumbfilename)})
        shutil.copyfile(filename, os.path.join(target_dir, ex.pyfilename))
        output = RST_TEMPLATE.format(sphinx_tag=ex.sphinxtag,
                                     docstring=ex.docstring,
                                     end_line=ex.end_line,
                                     fname=ex.pyfilename,
                                     img_html=indent(ex.html, 4))
        with open(os.path.join(target_dir, ex.rstfilename), 'w') as f:
            f.write(output)

        toctree += ex.toctree_entry()
        contents += ex.contents_entry()

    if len(banner_data) < 10:
        banner_data = (4 * banner_data)[:10]

    # write index file
    index_file = os.path.join(target_dir, 'index.rst')
    with open(index_file, 'w') as index:
        index.write(INDEX_TEMPLATE.format(sphinx_tag="example-gallery",
                                          toctree=toctree,
                                          contents=contents))

    # write javascript include for front page
    js_file = os.path.join(static_dir, 'banner_data.js')
    with open(js_file, 'w') as js:
        js.write(BANNER_JS_TEMPLATE.format(
            banner_data=json.dumps(banner_data)))


def setup(app):
    app.connect('builder-inited', main)

########NEW FILE########
__FILENAME__ = custom_plugin
"""
Defining a Custom Plugin
========================
Test the custom plugin demoed on the `Pythonic Perambulations
<http://jakevdp.github.io/blog/2014/01/10/d3-plugins-truly-interactive/>`_
blog.  Hover over the points to see the associated sinusoid.
Use the toolbar buttons at the bottom-right of the plot to enable zooming
and panning, and to reset the view.
"""
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import mpld3
from mpld3 import plugins, utils


class LinkedView(plugins.PluginBase):
    """A simple plugin showing how multiple axes can be linked"""

    JAVASCRIPT = """
    mpld3.register_plugin("linkedview", LinkedViewPlugin);
    LinkedViewPlugin.prototype = Object.create(mpld3.Plugin.prototype);
    LinkedViewPlugin.prototype.constructor = LinkedViewPlugin;
    LinkedViewPlugin.prototype.requiredProps = ["idpts", "idline", "data"];
    LinkedViewPlugin.prototype.defaultProps = {}
    function LinkedViewPlugin(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    LinkedViewPlugin.prototype.draw = function(){
      var pts = mpld3.get_element(this.props.idpts);
      var line = mpld3.get_element(this.props.idline);
      var data = this.props.data;

      function mouseover(d, i){
        line.data = data[i];
        line.elements().transition()
            .attr("d", line.datafunc(line.data))
            .style("stroke", this.style.fill);
      }
      pts.elements().on("mouseover", mouseover);
    };
    """

    def __init__(self, points, line, linedata):
        if isinstance(points, matplotlib.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None

        self.dict_ = {"type": "linkedview",
                      "idpts": utils.get_id(points, suffix),
                      "idline": utils.get_id(line),
                      "data": linedata}

fig, ax = plt.subplots(2)

# scatter periods and amplitudes
np.random.seed(0)
P = 0.2 + np.random.random(size=20)
A = np.random.random(size=20)
x = np.linspace(0, 10, 100)
data = np.array([[x, Ai * np.sin(x / Pi)]
                 for (Ai, Pi) in zip(A, P)])
points = ax[1].scatter(P, A, c=P + A,
                       s=200, alpha=0.5)
ax[1].set_xlabel('Period')
ax[1].set_ylabel('Amplitude')

# create the line object
lines = ax[0].plot(x, 0 * x, '-w', lw=3, alpha=0.5)
ax[0].set_ylim(-1, 1)

ax[0].set_title("Hover over points to see lines")

# transpose line data and add plugin
linedata = data.transpose(0, 2, 1).tolist()
plugins.connect(fig, LinkedView(points, lines[0], linedata))

mpld3.show()

########NEW FILE########
__FILENAME__ = drag_points
"""
Draggable Points Example
========================
This example shows how a D3 plugin can be created to make plot elements
draggable.  A stopPropagation command is used to allow the drag behavior
and pan/zoom behavior to work in tandem.
"""
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

import mpld3
from mpld3 import plugins, utils


class DragPlugin(plugins.PluginBase):
    JAVASCRIPT = r"""
    mpld3.register_plugin("drag", DragPlugin);
    DragPlugin.prototype = Object.create(mpld3.Plugin.prototype);
    DragPlugin.prototype.constructor = DragPlugin;
    DragPlugin.prototype.requiredProps = ["id"];
    DragPlugin.prototype.defaultProps = {}
    function DragPlugin(fig, props){
        mpld3.Plugin.call(this, fig, props);
        mpld3.insert_css("#" + fig.figid + " path.dragging",
                         {"fill-opacity": "1.0 !important",
                          "stroke-opacity": "1.0 !important"});
    };

    DragPlugin.prototype.draw = function(){
        var obj = mpld3.get_element(this.props.id);

        var drag = d3.behavior.drag()
            .origin(function(d) { return {x:obj.ax.x(d[0]),
                                          y:obj.ax.y(d[1])}; })
            .on("dragstart", dragstarted)
            .on("drag", dragged)
            .on("dragend", dragended);

        obj.elements()
           .data(obj.offsets)
           .style("cursor", "default")
           .call(drag);

        function dragstarted(d) {
          d3.event.sourceEvent.stopPropagation();
          d3.select(this).classed("dragging", true);
        }

        function dragged(d, i) {
          d[0] = obj.ax.x.invert(d3.event.x);
          d[1] = obj.ax.y.invert(d3.event.y);
          d3.select(this)
            .attr("transform", "translate(" + [d3.event.x,d3.event.y] + ")");
        }

        function dragended(d) {
          d3.select(this).classed("dragging", false);
        }
    }
    """

    def __init__(self, points):
        if isinstance(points, mpl.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None

        self.dict_ = {"type": "drag",
                      "id": utils.get_id(points, suffix)}


fig, ax = plt.subplots()
np.random.seed(0)
points = ax.plot(np.random.normal(size=20),
                 np.random.normal(size=20), 'or', alpha=0.5,
                 markersize=50, markeredgewidth=1)
ax.set_title("Click and Drag", fontsize=18)

plugins.connect(fig, DragPlugin(points[0]))

mpld3.show()

########NEW FILE########
__FILENAME__ = heart_path
"""
Patches and Paths
=================
This is a demo adapted from a `matplotlib gallery example
<http://matplotlib.org/examples/shapes_and_collections/path_patch_demo.html>`_

This example adds a custom D3 plugin allowing the user to drag the path
control-points and see the effect on the path.

Use the toolbar buttons at the bottom-right of the plot to enable zooming
and panning, and to reset the view.
"""
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.path as mpath
import matplotlib.patches as mpatches

import mpld3
from mpld3 import plugins, utils


class LinkedDragPlugin(plugins.PluginBase):
    JAVASCRIPT = r"""
    mpld3.register_plugin("drag", DragPlugin);
    DragPlugin.prototype = Object.create(mpld3.Plugin.prototype);
    DragPlugin.prototype.constructor = DragPlugin;
    DragPlugin.prototype.requiredProps = ["idpts", "idline", "idpatch"];
    DragPlugin.prototype.defaultProps = {}
    function DragPlugin(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    DragPlugin.prototype.draw = function(){
        var patchobj = mpld3.get_element(this.props.idpatch, this.fig);
        var ptsobj = mpld3.get_element(this.props.idpts, this.fig);
        var lineobj = mpld3.get_element(this.props.idline, this.fig);

        var drag = d3.behavior.drag()
            .origin(function(d) { return {x:ptsobj.ax.x(d[0]),
                                          y:ptsobj.ax.y(d[1])}; })
            .on("dragstart", dragstarted)
            .on("drag", dragged)
            .on("dragend", dragended);

        lineobj.path.attr("d", lineobj.datafunc(ptsobj.offsets));
        patchobj.path.attr("d", patchobj.datafunc(ptsobj.offsets,
                                                  patchobj.pathcodes));
        lineobj.data = ptsobj.offsets;
        patchobj.data = ptsobj.offsets;

        ptsobj.elements()
           .data(ptsobj.offsets)
           .style("cursor", "default")
           .call(drag);

        function dragstarted(d) {
          d3.event.sourceEvent.stopPropagation();
          d3.select(this).classed("dragging", true);
        }

        function dragged(d, i) {
          d[0] = ptsobj.ax.x.invert(d3.event.x);
          d[1] = ptsobj.ax.y.invert(d3.event.y);
          d3.select(this)
            .attr("transform", "translate(" + [d3.event.x,d3.event.y] + ")");
          lineobj.path.attr("d", lineobj.datafunc(ptsobj.offsets));
          patchobj.path.attr("d", patchobj.datafunc(ptsobj.offsets,
                                                    patchobj.pathcodes));
        }

        function dragended(d, i) {
          d3.select(this).classed("dragging", false);
        }
    }

    mpld3.register_plugin("drag", DragPlugin);
    """

    def __init__(self, points, line, patch):
        if isinstance(points, mpl.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None

        self.dict_ = {"type": "drag",
                      "idpts": utils.get_id(points, suffix),
                      "idline": utils.get_id(line),
                      "idpatch": utils.get_id(patch)}


fig, ax = plt.subplots()

Path = mpath.Path
path_data = [
    (Path.MOVETO, (1.58, -2.57)),
    (Path.CURVE4, (0.35, -1.1)),
    (Path.CURVE4, (-1.75, 2.0)),
    (Path.CURVE4, (0.375, 2.0)),
    (Path.LINETO, (0.85, 1.15)),
    (Path.CURVE4, (2.2, 3.2)),
    (Path.CURVE4, (3, 0.05)),
    (Path.CURVE4, (2.0, -0.5)),
    (Path.CLOSEPOLY, (1.58, -2.57)),
    ]
codes, verts = zip(*path_data)
path = mpath.Path(verts, codes)
patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)
ax.add_patch(patch)

# plot control points and connecting lines
x, y = zip(*path.vertices[:-1])
points = ax.plot(x, y, 'go', ms=10)
line = ax.plot(x, y, '-k')

ax.grid(True, color='gray', alpha=0.5)
ax.axis('equal')
ax.set_title("Drag Points to Change Path", fontsize=18)

plugins.connect(fig, LinkedDragPlugin(points[0], line[0], patch))

mpld3.show()

########NEW FILE########
__FILENAME__ = html_tooltips
"""
HTML tooltip plugin
===================
This is a demonstration of how to add rich HTML annotations to data plots.
The Plugin is defined within mpld3, and the user-provided CSS controls the
format of the information shown on hover.
Use the toolbar buttons at the bottom-right of the plot to enable zooming
and panning, and to reset the view.
"""
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import mpld3
from mpld3 import plugins

# Define some CSS to control our custom labels
css = """
table
{
  border-collapse: collapse;
}
th
{
  color: #ffffff;
  background-color: #000000;
}
td
{
  background-color: #cccccc;
}
table, th, td
{
  font-family:Arial, Helvetica, sans-serif;
  border: 1px solid black;
  text-align: right;
}
"""

fig, ax = plt.subplots()
ax.grid(True, alpha=0.3)

N = 50
df = pd.DataFrame(index=range(N))
df['x'] = np.random.randn(N)
df['y'] = np.random.randn(N)
df['z'] = np.random.randn(N)

labels = []
for i in range(N):
    label = df.ix[[i], :].T
    label.columns = ['Row {0}'.format(i)]
    # .to_html() is unicode; so make leading 'u' go away with str()
    labels.append(str(label.to_html()))

points = ax.plot(df.x, df.y, 'o', color='b',
                 mec='k', ms=15, mew=1, alpha=.6)

ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('HTML tooltips', size=20)

tooltip = plugins.PointHTMLTooltip(points[0], labels,
                                   voffset=10, hoffset=10, css=css)
plugins.connect(fig, tooltip)

mpld3.show()

########NEW FILE########
__FILENAME__ = linked_brush
"""
Linked Brushing Example
=======================
This example uses the standard Iris dataset and plots it with a linked brushing
tool for dynamically exploring the data. The paintbrush button at the bottom
left can be used to enable and disable the behavior.
"""

import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris

import mpld3
from mpld3 import plugins, utils


data = load_iris()
X = data.data
y = data.target

# dither the data for clearer plotting
X += 0.1 * np.random.random(X.shape)

fig, ax = plt.subplots(4, 4, sharex="col", sharey="row", figsize=(8, 8))
fig.subplots_adjust(left=0.05, right=0.95, bottom=0.05, top=0.95,
                    hspace=0.1, wspace=0.1)

for i in range(4):
    for j in range(4):
        points = ax[3 - i, j].scatter(X[:, j], X[:, i],
                                      c=y, s=40, alpha=0.6)

# remove tick labels
for axi in ax.flat:
    for axis in [axi.xaxis, axi.yaxis]:
        axis.set_major_formatter(plt.NullFormatter())

# Here we connect the linked brush plugin
plugins.connect(fig, plugins.LinkedBrush(points))

mpld3.show()

########NEW FILE########
__FILENAME__ = mouse_position
"""
Image with Mouse Position
=========================
This example shows how mpld3 can display images using plt.imshow().
It also includes the mouse position plugin, so that the mouse coordinates
are displayed in the lower-right corner.
"""
import matplotlib.pyplot as plt
import numpy as np

import mpld3
from mpld3 import plugins

fig, ax = plt.subplots()

x = np.linspace(-2, 2, 20)
y = x[:, None]
X = np.zeros((20, 20, 4))

X[:, :, 0] = np.exp(- (x - 1) ** 2 - (y) ** 2)
X[:, :, 1] = np.exp(- (x + 0.71) ** 2 - (y - 0.71) ** 2)
X[:, :, 2] = np.exp(- (x + 0.71) ** 2 - (y + 0.71) ** 2)
X[:, :, 3] = np.exp(-0.25 * (x ** 2 + y ** 2))

im = ax.imshow(X, extent=(10, 20, 10, 20),
               origin='lower', zorder=1, interpolation='nearest')
fig.colorbar(im, ax=ax)

ax.set_title('An Image', size=20)

plugins.connect(fig, plugins.MousePosition(fontsize=14))

mpld3.show()

########NEW FILE########
__FILENAME__ = mpld3_logo
"""
mpld3 Logo Idea
===============
This example shows how mpld3 can be used to generate relatively intricate
vector graphics in the browser. This is an adaptation of a logo proposal by
github user debjan, in turn based on both the matplotlib and D3js logos.
"""
# Author: Jake VanderPlas

import matplotlib.pyplot as plt
from matplotlib import image, patches, colors
from matplotlib.colors import colorConverter
import numpy as np
import mpld3

imsize = np.array([319, 217])
center = [108.5, 108.5]
max_radius = 108.5
radii = np.linspace(16, max_radius, 5)
angles = np.arange(0, 360, 45)


fig = plt.figure(figsize=imsize / 50.)
ax = fig.add_axes([0, 0, 1, 1], frameon=False, xticks=[], yticks=[])

# Create a clip path for the elements
clip_path = patches.Rectangle((0, 0), imsize[0], imsize[1],
                              transform=ax.transData)

# Create the background gradient
x = np.array([0, 104, 196, 300])
y = np.linspace(150, 450, 86)[:, None]

c = np.cos(-np.pi / 4)
s = np.sin(-np.pi / 4)
X, Y = (c * x - s * y) - 116, (s * x + c * y)
C = np.arange(255).reshape((3, 85)).T
C = C[::-1, :]
cmap = colors.LinearSegmentedColormap.from_list("mpld3",
                                                [[0.97, 0.6, 0.29],
                                                 [0.97, 0.59, 0.27],
                                                 [0.97, 0.58, 0.25],
                                                 [0.95, 0.44, 0.34],
                                                 [0.92, 0.51, 0.29],
                                                 [0.68, 0.21, 0.20]])
mesh = ax.pcolormesh(X, Y, C, cmap=cmap, shading='gourand', zorder=0)
mesh.set_clip_path(clip_path)

# cut-off the background to form the "D" and "3" using white patches
# (this could also be done with a clip path)
kwargs = dict(fc='white', ec='none', zorder=1)
ax.add_patch(patches.Rectangle([0, 0], center[0], imsize[1], **kwargs))

ax.add_patch(patches.Circle(center, radii[2], **kwargs))
ax.add_patch(patches.Wedge(center, 127, -90, 90, width=18.5, **kwargs))

ax.add_patch(patches.Circle((252, 66), 18, **kwargs))
ax.add_patch(patches.Rectangle([216, 48], 36, 36, **kwargs))
ax.add_patch(patches.Wedge((252, 66), 101, -90, 40.1, width=35, **kwargs))

ax.add_patch(patches.Circle((252, 151), 18, **kwargs))
ax.add_patch(patches.Rectangle([216, 133], 36, 36, **kwargs))
ax.add_patch(patches.Wedge((252, 151), 101, -40.1, 90, width=35, **kwargs))

ax.add_patch(patches.Rectangle([-200, -200], 719, 200, **kwargs))
ax.add_patch(patches.Rectangle([-200, -200], 200, 617, **kwargs))
ax.add_patch(patches.Rectangle([-200, imsize[1]], 719, 200, **kwargs))
ax.add_patch(patches.Rectangle([imsize[0], -200], 200, 617, **kwargs))

# plot circles and lines
for radius in radii:
    ax.add_patch(patches.Circle(center, radius, lw=0.5,
                                ec='gray', fc='none', zorder=2))
for angle in angles:
    dx, dy = np.sin(np.radians(angle)), np.cos(np.radians(angle))
    ax.plot([max_radius * (1 - dx), max_radius * (1 + dx)],
            [max_radius * (1 - dy), max_radius * (1 + dy)],
            '-', color='gray', lw=0.5, zorder=2)

# plot wedges within the graph
wedges = [(98, 231, 258, '#FF6600'),
          (85, 170, 205, '#FFC500'),
          (60, 80, 103, '#7DFF78'),
          (96, 45, 58, '#FD7C1A'),
          (73, 291, 308, '#CCFF28'),
          (47, 146, 155, '#28FFCC'),
          (25, 340, 360, '#004AFF')]

for (radius, theta1, theta2, color) in wedges:
    ax.add_patch(patches.Wedge(center, radius, theta1, theta2,
                               fc=color, ec='black', alpha=0.6, zorder=3))

for patch in ax.patches:
    patch.set_clip_path(clip_path)

ax.set_xlim(0, imsize[0])
ax.set_ylim(imsize[1], 0)

#plt.savefig('mpld3.png')
mpld3.show()

########NEW FILE########
__FILENAME__ = random_walk
"""
Visualizing Random Walks
========================
This shows the use of transparent lines to visualize random walk data.
Thre is also a custom plugin defined which causes lines to be highlighted
when the mouse hovers over them.
Use the toolbar buttons at the bottom-right of the plot to enable zooming
and panning, and to reset the view.
"""
import jinja2
import json
import numpy as np
import matplotlib.pyplot as plt

import mpld3
from mpld3 import plugins, utils


class HighlightLines(plugins.PluginBase):
    """A plugin to highlight lines on hover"""

    JAVASCRIPT = """
    mpld3.register_plugin("linehighlight", LineHighlightPlugin);
    LineHighlightPlugin.prototype = Object.create(mpld3.Plugin.prototype);
    LineHighlightPlugin.prototype.constructor = LineHighlightPlugin;
    LineHighlightPlugin.prototype.requiredProps = ["line_ids"];
    LineHighlightPlugin.prototype.defaultProps = {alpha_bg:0.3, alpha_fg:1.0}
    function LineHighlightPlugin(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    LineHighlightPlugin.prototype.draw = function(){
      for(var i=0; i<this.props.line_ids.length; i++){
         var obj = mpld3.get_element(this.props.line_ids[i], this.fig),
             alpha_fg = this.props.alpha_fg;
             alpha_bg = this.props.alpha_bg;
         obj.elements()
             .on("mouseover", function(d, i){
                            d3.select(this).transition().duration(50)
                              .style("stroke-opacity", alpha_fg); })
             .on("mouseout", function(d, i){
                            d3.select(this).transition().duration(200)
                              .style("stroke-opacity", alpha_bg); });
      }
    };
    """

    def __init__(self, lines):
        self.lines = lines
        self.dict_ = {"type": "linehighlight",
                      "line_ids": [utils.get_id(line) for line in lines],
                      "alpha_bg": lines[0].get_alpha(),
                      "alpha_fg": 1.0}


N_paths = 50
N_steps = 100

x = np.linspace(0, 10, 100)
y = 0.1 * (np.random.random((N_paths, N_steps)) - 0.5)
y = y.cumsum(1)

fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})
lines = ax.plot(x, y.T, color='blue', lw=4, alpha=0.1)
plugins.connect(fig, HighlightLines(lines))

mpld3.show()

########NEW FILE########
__FILENAME__ = scatter_tooltip
"""
Scatter Plot With Tooltips
==========================
A scatter-plot with tooltip labels on hover.  Hover over the points to see
the point labels.
Use the toolbar buttons at the bottom-right of the plot to enable zooming
and panning, and to reset the view.
"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3

fig, ax = plt.subplots(subplot_kw=dict(axisbg='#EEEEEE'))
N = 100

scatter = ax.scatter(np.random.normal(size=N),
                     np.random.normal(size=N),
                     c=np.random.random(size=N),
                     s=1000 * np.random.random(size=N),
                     alpha=0.3,
                     cmap=plt.cm.jet)
ax.grid(color='white', linestyle='solid')

ax.set_title("Scatter Plot (with tooltips!)", size=20)

labels = ['point {0}'.format(i + 1) for i in range(N)]
tooltip = mpld3.plugins.PointLabelTooltip(scatter, labels=labels)
mpld3.plugins.connect(fig, tooltip)

mpld3.show()

########NEW FILE########
__FILENAME__ = base64_conv
"""
Quick script to output JS code for including the listed icons in base64

Usage: python base64_conv.py <filenames>
"""
import os
import argparse
import json


def compute_base64_encoding(filename):
    base, suffix = os.path.splitext(filename)
    suffix = suffix.lstrip('.')

    with open(filename, 'rb') as f:
        data = f.read().encode("base64")
    
    return (base, "data:image/{0};base64,{1}".format(suffix, data))


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("files", nargs='*', type=str)
    args = parser.parse_args()

    encodings = dict([compute_base64_encoding(filename)
                      for filename in args.files])

    print json.dumps(dict(encodings))

if __name__ == "__main__":
    main()
    
    

########NEW FILE########
__FILENAME__ = mpld3renderer
"""
mpld3 renderer
==============

This is the renderer class which implements the mplexporter framework for mpld3
"""
__all__ = ["MPLD3Renderer"]

import random
import json
import jinja2
import itertools

import numpy as np

from .mplexporter.utils import color_to_hex
from .mplexporter.exporter import Exporter
from .mplexporter.renderers import Renderer

from .utils import get_id
from .plugins import get_plugins


class MPLD3Renderer(Renderer):
    """Renderer class for mpld3

    This renderer class plugs into the ``mplexporter`` package in order to
    convert matplotlib figures into a JSON-serializable dictionary
    representation which can be read by mpld3.js.
    """
    def __init__(self):
        self.figure_json = None
        self.axes_json = None
        self.finished_figures = []

    @staticmethod
    def datalabel(i):
        return "data{0:02d}".format(i)

    def add_data(self, data, key="data"):
        """Add a dataset to the current figure

        If the dataset matches any already added data, we use that instead.

        Parameters
        ----------
        data : array_like
            a shape [N,2] array of data
        key : string (optional)
            the key to use for the data

        Returns
        -------
        datadict : dictionary
            datadict has the keys "data", "xindex", "yindex", which will
            be passed to the mpld3 JSON object.
        """
        # Check if any column of the data exists elsewhere
        # If so, we'll use that dataset rather than duplicating it.
        data = np.asarray(data)
        if data.ndim != 2 and data.shape[1] != 2:
            raise ValueError("Data is expected to be of size [N, 2]")

        for (i, d) in enumerate(self.datasets):
            if data.shape[0] != d.shape[0]:
                continue

            matches = np.array([np.all(col == d.T, axis=1) for col in data.T])
            if not np.any(matches):
                continue

            # If we get here, we've found a dataset with a matching column
            # we'll update this data with additional columns if necessary
            new_data = list(self.datasets[i].T)
            indices = []
            for j in range(data.shape[1]):
                whr = np.where(matches[j])[0]
                if len(whr):
                    indices.append(whr[0])
                else:
                    # append a new column to the data
                    new_data.append(data[:, j])
                    indices.append(len(new_data) - 1)

            self.datasets[i] = np.asarray(new_data).T
            datalabel = self.datalabel(i + 1)
            xindex, yindex = map(int, indices)
            break
        else:
            # else here can be thought of as "if no break"
            # if we get here, then there were no matching datasets
            self.datasets.append(data)
            datalabel = self.datalabel(len(self.datasets))
            xindex = 0
            yindex = 1

        self.datalabels.append(datalabel)
        return {key: datalabel, "xindex": xindex, "yindex": yindex}

    def open_figure(self, fig, props):
        self.datasets = []
        self.datalabels = []
        self.figure_json = dict(width=props['figwidth'] * props['dpi'],
                                height=props['figheight'] * props['dpi'],
                                axes=[],
                                data={},
                                id=get_id(fig))

    def close_figure(self, fig):
        additional_css = []
        additional_js = []
        for i, dataset in enumerate(self.datasets):
            datalabel = self.datalabel(i + 1)
            self.figure_json['data'][datalabel] = np.asarray(dataset).tolist()
        self.figure_json["plugins"] = []
        for plugin in get_plugins(fig):
            self.figure_json["plugins"].append(plugin.get_dict())
            additional_css.append(plugin.css())
            additional_js.append(plugin.javascript())
        self.finished_figures.append((fig, self.figure_json,
                                      "".join(additional_css),
                                      "".join(additional_js)))

    def open_axes(self, ax, props):
        self.axes_json = dict(bbox=props['bounds'],
                              xlim=props['xlim'],
                              ylim=props['ylim'],
                              xdomain=props['xdomain'],
                              ydomain=props['ydomain'],
                              xscale=props['xscale'],
                              yscale=props['yscale'],
                              axes=props['axes'],
                              axesbg=props['axesbg'],
                              axesbgalpha=props['axesbgalpha'],
                              zoomable=bool(props['dynamic']),
                              id=get_id(ax),
                              lines=[],
                              paths=[],
                              markers=[],
                              texts=[],
                              collections=[],
                              images=[])
        self.figure_json['axes'].append(self.axes_json)

        # Get shared axes info
        xsib = ax.get_shared_x_axes().get_siblings(ax)
        ysib = ax.get_shared_y_axes().get_siblings(ax)
        self.axes_json['sharex'] = [get_id(axi) for axi in xsib
                                    if axi is not ax]
        self.axes_json['sharey'] = [get_id(axi) for axi in ysib
                                    if axi is not ax]

    def close_axes(self, ax):
        self.axes_json = None

    # If draw_line() is not implemented, it will be delegated to draw_path
    # Should we get rid of this? There's not really any advantage here
    def draw_line(self, data, coordinates, style, label, mplobj=None):
        line = self.add_data(data)
        line['coordinates'] = coordinates
        line['id'] = get_id(mplobj)
        for key in ['color', 'linewidth', 'dasharray', 'alpha', 'zorder']:
            line[key] = style[key]
        
        # Some browsers do not accept dasharray="10,0"
        # This should probably be addressed in mplexporter.
        if line['dasharray'] == "10,0":
            line['dasharray'] = "none"

        self.axes_json['lines'].append(line)

    def draw_path(self, data, coordinates, pathcodes, style,
                  offset=None, offset_coordinates="data", mplobj=None):
        path = self.add_data(data)
        path['coordinates'] = coordinates
        path['pathcodes'] = pathcodes
        path['id'] = get_id(mplobj)
        if offset is not None:
            path['offset'] = list(offset)
            path['offsetcoordinates'] = offset_coordinates

        for key in ['dasharray', 'alpha', 'facecolor',
                    'edgecolor', 'edgewidth', 'zorder']:
            path[key] = style[key]
        
        # Some browsers do not accept dasharray="10,0"
        # This should probably be addressed in mplexporter.
        if path['dasharray'] == "10,0":
            path['dasharray'] = "none"

        self.axes_json['paths'].append(path)

    # If draw_markers is not implemented, it will be delegated to draw_path
    def draw_markers(self, data, coordinates, style, label, mplobj=None):
        markers = self.add_data(data)
        markers["coordinates"] = coordinates
        markers['id'] = get_id(mplobj, 'pts')
        for key in ['facecolor', 'edgecolor', 'edgewidth',
                    'alpha', 'zorder']:
            markers[key] = style[key]
        if style.get('markerpath'):
            vertices, codes = style['markerpath']
            markers['markerpath'] = (vertices.tolist(), codes)
        self.axes_json['markers'].append(markers)

    # If draw_path_collection is not implemented,
    # it will be delegated to draw_path
    def draw_path_collection(self, paths, path_coordinates, path_transforms,
                             offsets, offset_coordinates, offset_order,
                             styles, mplobj=None):
        styles = dict(alphas=[styles['alpha']],
                      edgecolors=[color_to_hex(ec)
                                  for ec in styles['edgecolor']],
                      facecolors=[color_to_hex(fc)
                                  for fc in styles['facecolor']],
                      edgewidths=styles['linewidth'],
                      offsetcoordinates=offset_coordinates,
                      pathcoordinates=path_coordinates,
                      zorder=styles['zorder'])

        pathsdict = self.add_data(offsets, "offsets")
        pathsdict['paths'] = [(v.tolist(), p) for (v, p) in paths]
        pathsdict['pathtransforms'] = [(t[0, :2].tolist()
                                        + t[1, :2].tolist()
                                        + t[2, :2].tolist())
                                       for t in path_transforms]
        pathsdict.update(styles)
        pathsdict['id'] = get_id(mplobj)
        self.axes_json['collections'].append(pathsdict)

    def draw_text(self, text, position, coordinates, style,
                  text_type=None, mplobj=None):
        text = dict(text=text,
                    position=tuple(position),
                    coordinates=coordinates,
                    h_anchor=TEXT_HA_DICT[style['halign']],
                    v_baseline=TEXT_VA_DICT[style['valign']],
                    rotation=-style['rotation'],
                    fontsize=style['fontsize'],
                    color=style['color'],
                    alpha=style['alpha'],
                    zorder=style['zorder'],
                    id=get_id(mplobj))
        self.axes_json['texts'].append(text)

    def draw_image(self, imdata, extent, coordinates, style, mplobj=None):
        image = dict(data=imdata, extent=extent, coordinates=coordinates)
        image.update(style)
        image['id'] = get_id(mplobj)
        self.axes_json['images'].append(image)


TEXT_VA_DICT = {'bottom': 'auto',
                'baseline': 'auto',
                'center': 'central',
                'top': 'hanging'}
TEXT_HA_DICT = {'left': 'start',
                'center': 'middle',
                'right': 'end'}

########NEW FILE########
__FILENAME__ = plugins
"""
Plugins to add behavior to mpld3 charts
=======================================

Plugins are means of adding additional javascript features to D3-rendered
matplotlib plots.  A number of plugins are defined here; it is also possible
to create nearly any imaginable behavior by defining your own custom plugin.
"""

__all__ = ['connect', 'clear', 'get_plugins', 'PluginBase',
           'Reset', 'Zoom', 'BoxZoom',
           'PointLabelTooltip', 'PointHTMLTooltip', 'LineLabelTooltip',
           'MousePosition']

import collections
import json
import uuid
import matplotlib

from .utils import get_id


def get_plugins(fig):
    """Get the list of plugins in the figure"""
    connect(fig)
    return fig.mpld3_plugins


def connect(fig, *plugins):
    """Connect one or more plugins to a figure

    Parameters
    ----------
    fig : matplotlib Figure instance
        The figure to which the plugins will be connected

    *plugins :
        Additional arguments should be plugins which will be connected
        to the figure.

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import plugins
    >>> fig, ax = plt.subplots()
    >>> lines = ax.plot(range(10), '-k')
    >>> plugins.connect(fig, plugins.LineLabelTooltip(lines[0]))
    """
    if not isinstance(fig, matplotlib.figure.Figure):
        raise ValueError("plugins.connect: first argument must be a figure")
    if not hasattr(fig, 'mpld3_plugins'):
        fig.mpld3_plugins = DEFAULT_PLUGINS[:]
    for plugin in plugins:
        fig.mpld3_plugins.append(plugin)


def clear(fig):
    """Clear all plugins from the figure, including defaults"""
    fig.mpld3_plugins = []


class PluginBase(object):
    def get_dict(self):
        return self.dict_

    def javascript(self):
        if hasattr(self, "JAVASCRIPT"):
            if hasattr(self, "js_args_"):
                return self.JAVASCRIPT.render(self.js_args_)
            else:
                return self.JAVASCRIPT
        else:
            return ""

    def css(self):
        if hasattr(self, "css_"):
            return self.css_
        else:
            return ""


class Reset(PluginBase):
    """A Plugin to add a reset button"""
    dict_ = {"type": "reset"}


class MousePosition(PluginBase):
    """A Plugin to display coordinates for the current mouse position

    Example
    -------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> fig, ax = plt.subplots()
    >>> points = ax.plot(range(10), 'o')
    >>> plugins.connect(fig, plugins.MousePosition())
    >>> fig_to_html(fig)
    """

    def __init__(self, fontsize=12, fmt=".3g"):
        self.dict_ = {"type": "mouseposition",
                      "fontsize": fontsize,
                      "fmt": fmt}


class Zoom(PluginBase):
    """A Plugin to add zoom behavior to the plot

    Parameters
    ----------
    button : boolean, optional
        if True (default), then add a button to enable/disable zoom behavior
    enabled : boolean, optional
        specify whether the zoom should be enabled by default. By default,
        zoom is enabled if button == False, and disabled if button == True.

    Notes
    -----
    Even if ``enabled`` is specified, other plugins may modify this state.
    """
    def __init__(self, button=True, enabled=None):
        if enabled is None:
            enabled = not button
        self.dict_ = {"type": "zoom",
                      "button": button,
                      "enabled": enabled}


class BoxZoom(PluginBase):
    """A Plugin to add box-zoom behavior to the plot

    Parameters
    ----------
    button : boolean, optional
        if True (default), then add a button to enable/disable zoom behavior
    enabled : boolean, optional
        specify whether the zoom should be enabled by default. By default,
        zoom is enabled if button == False, and disabled if button == True.

    Notes
    -----
    Even if ``enabled`` is specified, other plugins may modify this state.
    """
    def __init__(self, button=True, enabled=None):
        if enabled is None:
            enabled = not button
        self.dict_ = {"type": "boxzoom",
                      "button": button,
                      "enabled": enabled}


class PointLabelTooltip(PluginBase):
    """A Plugin to enable a tooltip: text which hovers over points.

    Parameters
    ----------
    points : matplotlib Collection or Line2D object
        The figure element to apply the tooltip to
    labels : array or None
        If supplied, specify the labels for each point in points.  If not
        supplied, the (x, y) values will be used.
    hoffset, voffset : integer
        The number of pixels to offset the tooltip text.  Default is
        hoffset = 0, voffset = 10

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> fig, ax = plt.subplots()
    >>> points = ax.plot(range(10), 'o')
    >>> plugins.connect(fig, PointLabelTooltip(points[0]))
    >>> fig_to_html(fig)
    """
    def __init__(self, points, labels=None,
                 hoffset=0, voffset=10, location="mouse"):
        if location not in ["bottom left", "top left", "bottom right",
                            "top right", "mouse"]:
            raise ValueError("invalid location: {0}".format(location))
        if isinstance(points, matplotlib.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None
        self.dict_ = {"type": "tooltip",
                      "id": get_id(points, suffix),
                      "labels": labels,
                      "hoffset": hoffset,
                      "voffset": voffset,
                      "location": location}


class LineLabelTooltip(PluginBase):
    """A Plugin to enable a tooltip: text which hovers over a line.

    Parameters
    ----------
    line : matplotlib Line2D object
        The figure element to apply the tooltip to
    label : string
        If supplied, specify the labels for each point in points.  If not
        supplied, the (x, y) values will be used.
    hoffset, voffset : integer
        The number of pixels to offset the tooltip text.  Default is
        hoffset = 0, voffset = 10

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> fig, ax = plt.subplots()
    >>> lines = ax.plot(range(10), 'o')
    >>> plugins.connect(fig, LineLabelTooltip(lines[0]))
    >>> fig_to_html(fig)
    """
    def __init__(self, points, label=None,
                 hoffset=0, voffset=10, location="mouse"):
        if location not in ["bottom left", "top left", "bottom right",
                            "top right", "mouse"]:
            raise ValueError("invalid location: {0}".format(location))
        self.dict_ = {"type": "tooltip",
                      "id": get_id(points),
                      "labels": label if label is None else [label],
                      "hoffset": hoffset,
                      "voffset": voffset,
                      "location": location}


class LinkedBrush(PluginBase):
    """A Plugin to enable linked brushing between plots

    Parameters
    ----------
    points : matplotlib Collection or Line2D object
        A representative of the scatter plot elements to brush.
    button : boolean, optional
        if True (default), then add a button to enable/disable zoom behavior
    enabled : boolean, optional
        specify whether the zoom should be enabled by default. default=True.

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> import numpy as np
    >>> from mpld3 import fig_to_html, plugins
    >>> X = np.random.random((3, 100))
    >>> fig, ax = plt.subplots(3, 3)
    >>> for i in range(2):
    ...     for j in range(2):
    ...         points = ax[i, j].scatter(X[i], X[j])
    >>> plugins.connect(fig, LinkedBrush(points))
    >>> fig_to_html(fig)

    Notes
    -----
    Notice that in the above example, only one of the four sets of points is
    passed to the plugin. This is all that is needed: for the sake of efficient
    data storage, mpld3 keeps track of which plot objects draw from the same
    data.

    Also note that for the linked brushing to work correctly, the data must
    not contain any NaNs. The presence of NaNs makes the different data views
    have different sizes, so that mpld3 is unable to link the related points.
    """

    def __init__(self, points, button=True, enabled=True):
        if isinstance(points, matplotlib.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None

        self.dict_ = {"type": "linkedbrush",
                      "button": button,
                      "enabled": enabled,
                      "id": get_id(points, suffix)}


class PointHTMLTooltip(PluginBase):
    """A Plugin to enable an HTML tooltip:
    formated text which hovers over points.

    Parameters
    ----------
    points : matplotlib Collection or Line2D object
        The figure element to apply the tooltip to
    labels : list
        The labels for each point in points, as strings of unescaped HTML.
    hoffset, voffset : integer, optional
        The number of pixels to offset the tooltip text.  Default is
        hoffset = 0, voffset = 10
    css : str, optional
        css to be included, for styling the label html if desired
    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> fig, ax = plt.subplots()
    >>> points = ax.plot(range(10), 'o')
    >>> labels = ['<h1>{title}</h1>'.format(title=i) for i in range(10)]
    >>> plugins.connect(fig, PointHTMLTooltip(points[0], labels))
    >>> fig_to_html(fig)
    """

    JAVASCRIPT = """
    mpld3.register_plugin("htmltooltip", HtmlTooltipPlugin);
    HtmlTooltipPlugin.prototype = Object.create(mpld3.Plugin.prototype);
    HtmlTooltipPlugin.prototype.constructor = HtmlTooltipPlugin;
    HtmlTooltipPlugin.prototype.requiredProps = ["id"];
    HtmlTooltipPlugin.prototype.defaultProps = {labels:null,
                                                hoffset:0,
                                                voffset:10};
    function HtmlTooltipPlugin(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    HtmlTooltipPlugin.prototype.draw = function(){
       var obj = mpld3.get_element(this.props.id);
       var labels = this.props.labels;
       var tooltip = d3.select("body").append("div")
                    .attr("class", "mpld3-tooltip")
                    .style("position", "absolute")
                    .style("z-index", "10")
                    .style("visibility", "hidden");

       obj.elements()
           .on("mouseover", function(d, i){
                              tooltip.html(labels[i])
                                     .style("visibility", "visible");})
           .on("mousemove", function(d, i){
                  tooltip
                    .style("top", d3.event.pageY + this.props.voffset + "px")
                    .style("left",d3.event.pageX + this.props.hoffset + "px");
                 }.bind(this))
           .on("mouseout",  function(d, i){
                           tooltip.style("visibility", "hidden");});
    };
    """

    def __init__(self, points, labels=None,
                 hoffset=0, voffset=10, css=None):
        self.points = points
        self.labels = labels
        self.voffset = voffset
        self.hoffset = hoffset
        self.css_ = css or ""
        if isinstance(points, matplotlib.lines.Line2D):
            suffix = "pts"
        else:
            suffix = None
        self.dict_ = {"type": "htmltooltip",
                      "id": get_id(points, suffix),
                      "labels": labels,
                      "hoffset": hoffset,
                      "voffset": voffset}


class LineHTMLTooltip(PluginBase):
    """A Plugin to enable an HTML tooltip:
    formated text which hovers over points.

    Parameters
    ----------
    points : matplotlib Line2D object
        The figure element to apply the tooltip to
    label : string
        The label for the line, as strings of unescaped HTML.
    hoffset, voffset : integer, optional
        The number of pixels to offset the tooltip text.  Default is
        hoffset = 0, voffset = 10
    css : str, optional
        css to be included, for styling the label html if desired
    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> fig, ax = plt.subplots()
    >>> lines = ax.plot(range(10))
    >>> label = '<h1>line {title}</h1>'.format(title='A')
    >>> plugins.connect(fig, LineHTMLTooltip(lines[0], label))
    >>> fig_to_html(fig)
    """

    JAVASCRIPT = """
    mpld3.register_plugin("linehtmltooltip", LineHTMLTooltip);
    LineHTMLTooltip.prototype = Object.create(mpld3.Plugin.prototype);
    LineHTMLTooltip.prototype.constructor = LineHTMLTooltip;
    LineHTMLTooltip.prototype.requiredProps = ["id"];
    LineHTMLTooltip.prototype.defaultProps = {label:null,
                                              hoffset:0,
                                              voffset:10};
    function LineHTMLTooltip(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    LineHTMLTooltip.prototype.draw = function(){
        var obj = mpld3.get_element(this.props.id, this.fig);
        var label = this.props.label
        var tooltip = d3.select("body").append("div")
                    .attr("class", "mpld3-tooltip")
                    .style("position", "absolute")
                    .style("z-index", "10")
                    .style("visibility", "hidden");

        obj.elements()
           .on("mouseover", function(d, i){
                               tooltip.html(label)
                                      .style("visibility", "visible");
                                     })
            .on("mousemove", function(d, i){
                  tooltip
                    .style("top", d3.event.pageY + this.props.voffset + "px")
                    .style("left",d3.event.pageX + this.props.hoffset + "px");
                 }.bind(this))
           .on("mouseout",  function(d, i){
                           tooltip.style("visibility", "hidden");})
    };
    """

    def __init__(self, line, label=None,
                 hoffset=0, voffset=10,
                 css=None):
        self.line = line
        self.label = label
        self.voffset = voffset
        self.hoffset = hoffset
        self.css_ = css or ""
        self.dict_ = {"type": "linehtmltooltip",
                      "id": get_id(line),
                      "label": label,
                      "hoffset": hoffset,
                      "voffset": voffset}


class InteractiveLegendPlugin(PluginBase):
    """A plugin for an interactive legends.

    Inspired by http://bl.ocks.org/simzou/6439398

    Parameters
    ----------
    plot_elements : iterable of matplotliblib elements
        the elements to associate with a given legend items
    labels : iterable of strings
        The labels for each legend element
    ax :  matplotlib axes instance, optional
        the ax to which the legend belongs. Default is the first
        axes. The legend will be plotted to the right of the specified
        axes
    alpha_sel : float, optional
        the alpha value to apply to the plot_element(s) associated
        with the legend item when the legend item is selected.
        Default is 1.0
    alpha_unsel : float, optional
        the alpha value to apply to the plot_element(s) associated
        with the legend item when the legend item is unselected.
        Default is 0.2
    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> from mpld3 import fig_to_html, plugins
    >>> N_paths = 5
    >>> N_steps = 100
    >>> x = np.linspace(0, 10, 100)
    >>> y = 0.1 * (np.random.random((N_paths, N_steps)) - 0.5)
    >>> y = y.cumsum(1)
    >>> fig, ax = plt.subplots()
    >>> labels = ["a", "b", "c", "d", "e"]
    >>> line_collections = ax.plot(x, y.T, lw=4, alpha=0.1)
    >>> interactive_legend = plugins.InteractiveLegendPlugin(line_collections,
    ...                                                      labels,
    ...                                                      alpha_unsel=0.1)
    >>> plugins.connect(fig, interactive_legend)
    >>> fig_to_html(fig)
    """

    JAVASCRIPT = """
    mpld3.register_plugin("interactive_legend", InteractiveLegend);
    InteractiveLegend.prototype = Object.create(mpld3.Plugin.prototype);
    InteractiveLegend.prototype.constructor = InteractiveLegend;
    InteractiveLegend.prototype.requiredProps = ["element_ids", "labels"];
    InteractiveLegend.prototype.defaultProps = {"ax":null,
                                                "alpha_sel":1.0,
                                                "alpha_unsel":0}
    function InteractiveLegend(fig, props){
        mpld3.Plugin.call(this, fig, props);
    };

    InteractiveLegend.prototype.draw = function(){
        var alpha_sel = this.props.alpha_sel;
        var alpha_unsel = this.props.alpha_unsel;

        var legendItems = new Array();
        for(var i=0; i<this.props.labels.length; i++){
            var obj = {};
            obj.label = this.props.labels[i];

            var element_id = this.props.element_ids[i];
            mpld3_elements = [];
            for(var j=0; j<element_id.length; j++){
                var mpld3_element = mpld3.get_element(element_id[j], this.fig);

                // mpld3_element might be null in case of Line2D instances
                // for we pass the id for both the line and the markers. Either
                // one might not exist on the D3 side
                if(mpld3_element){
                    mpld3_elements.push(mpld3_element);
                }
            }

            obj.mpld3_elements = mpld3_elements;
            obj.visible = false; // should become be setable from python side
            legendItems.push(obj);
        }

        // determine the axes with which this legend is associated
        var ax = this.props.ax
        if(!ax){
            ax = this.fig.axes[0];
        } else{
            ax = mpld3.get_element(ax, this.fig);
        }

        // add a legend group to the canvas of the figure
        var legend = this.fig.canvas.append("svg:g")
                               .attr("class", "legend");

        // add the rectangles
        legend.selectAll("rect")
                .data(legendItems)
             .enter().append("rect")
                .attr("height",10)
                .attr("width", 25)
                .attr("x",ax.width+10+ax.position[0])
                .attr("y",function(d,i) {
                            return ax.position[1]+ i * 25 - 10;})
                .attr("stroke", get_color)
                .attr("class", "legend-box")
                .style("fill", function(d, i) {
                            return d.visible ? get_color(d) : "white";})
                .on("click", click);

        // add the labels
        legend.selectAll("text")
                .data(legendItems)
            .enter().append("text")
              .attr("x", function (d) {
                            return ax.width+10+ax.position[0] + 40;})
              .attr("y", function(d,i) {
                            return ax.position[1]+ i * 25;})
              .text(function(d) { return d.label });

        // specify the action on click
        function click(d,i){
            d.visible = !d.visible;
            d3.select(this)
              .style("fill",function(d, i) {
                return d.visible ? get_color(d) : "white";
              })

            for(var i=0; i<d.mpld3_elements.length; i++){
                var type = d.mpld3_elements[i].constructor.name;
                if(type =="mpld3_Line"){
                    d3.select(d.mpld3_elements[i].path[0][0])
                        .style("stroke-opacity",
                                d.visible ? alpha_sel : alpha_unsel);
                } else if((type=="mpld3_PathCollection")||
                         (type=="mpld3_Markers")){
                    d3.selectAll(d.mpld3_elements[i].pathsobj[0])
                        .style("stroke-opacity",
                                d.visible ? alpha_sel : alpha_unsel)
                        .style("fill-opacity",
                                d.visible ? alpha_sel : alpha_unsel);
                } else{
                    console.log(type + " not yet supported");
                }
            }
        };

        // helper function for determining the color of the rectangles
        function get_color(d){
            var type = d.mpld3_elements[0].constructor.name;
            var color = "black";
            if(type =="mpld3_Line"){
                color = d.mpld3_elements[0].props.edgecolor;
            } else if((type=="mpld3_PathCollection")||
                      (type=="mpld3_Markers")){
                color = d.mpld3_elements[0].props.facecolors[0];
            } else{
                console.log(type + " not yet supported");
            }
            return color;
        };
    };
    """

    css_ = """
    .legend-box {
      cursor: pointer;
    }
    """

    def __init__(self, plot_elements, labels, ax=None,
                 alpha_sel=1, alpha_unsel=0.2):

        self.ax = ax

        if ax:
            ax = get_id(ax)

        mpld3_element_ids = self._determine_mpld3ids(plot_elements)
        self.mpld3_element_ids = mpld3_element_ids
        self.dict_ = {"type": "interactive_legend",
                      "element_ids": mpld3_element_ids,
                      "labels": labels,
                      "ax": ax,
                      "alpha_sel": alpha_sel,
                      "alpha_unsel": alpha_unsel}

    def _determine_mpld3ids(self, plot_elements):
        """
        Helper function to get the mpld3_id for each
        of the specified elements.
        """
        mpld3_element_ids = []

        # There are two things being done here. First,
        # we make sure that we have a list of lists, where
        # each inner list is associated with a single legend
        # item. Second, in case of Line2D object we pass
        # the id for both the marker and the line.
        # on the javascript side we filter out the nulls in
        # case either the line or the marker has no equivalent
        # D3 representation.
        for entry in plot_elements:
            ids = []
            if isinstance(entry, collections.Iterable):
                for element in entry:
                    mpld3_id = get_id(element)
                    ids.append(mpld3_id)
                    if isinstance(element, matplotlib.lines.Line2D):
                        mpld3_id = get_id(element, 'pts')
                        ids.append(mpld3_id)
            else:
                ids.append(get_id(entry))
                if isinstance(entry, matplotlib.lines.Line2D):
                    mpld3_id = get_id(entry, 'pts')
                    ids.append(mpld3_id)
            mpld3_element_ids.append(ids)

        return mpld3_element_ids

DEFAULT_PLUGINS = [Reset(), Zoom(), BoxZoom()]

########NEW FILE########
__FILENAME__ = test_elements
"""
Test creation of basic plot elements
"""
import numpy as np
import matplotlib.pyplot as plt
from .. import fig_to_dict
from numpy.testing import assert_equal


def test_line():
    fig, ax = plt.subplots()
    ax.plot(np.arange(10), np.random.random(10),
            '--k', alpha=0.3, zorder=10, lw=2)
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    line = axrep['lines'][0]

    assert_equal(list(sorted(line.keys())),
                 ['alpha', 'color', 'coordinates', 'dasharray', 'data', 'id',
                  'linewidth', 'xindex', 'yindex', 'zorder'])
    assert_equal(line['alpha'], 0.3)
    assert_equal(line['color'], "#000000")
    assert_equal(line['coordinates'], 'data')
    assert_equal(line['dasharray'], '6,6')
    assert_equal(line['zorder'], 10)
    assert_equal(line['linewidth'], 2)


def test_markers():
    fig, ax = plt.subplots()
    ax.plot(np.arange(10), np.random.random(10),
            '^k', alpha=0.3, zorder=10, mec='r', mew=2, c='b')
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    markers = axrep['markers'][0]

    assert_equal(list(sorted(markers.keys())),
                 ['alpha', 'coordinates', 'data', 'edgecolor', 'edgewidth',
                  'facecolor', 'id', 'markerpath', 'xindex', 'yindex',
                  'zorder'])
    assert_equal(markers['alpha'], 0.3)
    assert_equal(markers['zorder'], 10)
    assert_equal(markers['coordinates'], 'data')
    assert_equal(markers['edgecolor'], '#FF0000')
    assert_equal(markers['edgewidth'], 2)
    assert_equal(markers['facecolor'], '#0000FF')
    assert_equal(markers['markerpath'][0],
                 [[0.0, -3.0], [-3.0, 3.0], [3.0, 3.0]])
    assert_equal(markers['markerpath'][1],
                 ['M', 'L', 'L', 'Z'])


def test_scatter():
    fig, ax = plt.subplots()
    ax.scatter(np.arange(10), np.random.random(10), c='r', s=30,
               marker='^', alpha=0.3, lw=2, edgecolors='b', zorder=10)
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    points = axrep['collections'][0]

    assert_equal(list(sorted(points.keys())),
                 ['alphas', 'edgecolors', 'edgewidths', 'facecolors', 'id',
                  'offsetcoordinates', 'offsets', 'pathcoordinates', 'paths',
                  'pathtransforms', 'xindex', 'yindex', 'zorder'])
    assert_equal(points['alphas'], [0.3])
    assert_equal(points['zorder'], 10)
    assert_equal(points['edgecolors'], ['#0000FF'])
    assert_equal(points['facecolors'], ['#FF0000'])
    assert_equal(points['edgewidths'], (2.0,))
    assert_equal(points['paths'][0][0],
                 [[0.0, 0.5], [-0.5, -0.5], [0.5, -0.5]])
    assert_equal(points['paths'][0][1],
                 ['M', 'L', 'L', 'Z'])
    assert_equal(points['pathtransforms'],
                 [[6.085806194501846, 0.0, 0.0, 6.085806194501846, 0.0, 0.0]])


def test_patch():
    fig, ax = plt.subplots()
    ax.add_patch(plt.Rectangle((0, 0), 1, 2, alpha=0.2, linewidth=2,
                               edgecolor='green', facecolor='red', zorder=3))
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    path = axrep['paths'][0]

    assert_equal(list(sorted(path.keys())),
                 ['alpha', 'coordinates', 'dasharray', 'data', 'edgecolor',
                  'edgewidth', 'facecolor', 'id', 'pathcodes',
                  'xindex', 'yindex', 'zorder'])

    assert_equal(path['alpha'], 0.2)
    assert_equal(path['edgecolor'], "#008000")
    assert_equal(path['facecolor'], "#FF0000")
    assert_equal(path['edgewidth'], 2)
    assert_equal(path['zorder'], 3)


def test_text():
    fig, ax = plt.subplots()
    ax.text(0.1, 0.1, "abcde", size=14, color='red', alpha=0.7,
            rotation=15, ha='center', va='center')
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    text = axrep['texts'][0]

    assert_equal(list(sorted(text.keys())),
                 ['alpha', 'color', 'coordinates', 'fontsize', 'h_anchor',
                  'id', 'position', 'rotation', 'text', 'v_baseline',
                  'zorder'])
    assert_equal(text['alpha'], 0.7)
    assert_equal(text['color'], "#FF0000")
    assert_equal(text['text'], "abcde")
    assert_equal(text['rotation'], -15)
    assert_equal(text['fontsize'], 14)
    assert_equal(text['position'], [0.1, 0.1])
    assert_equal(text['h_anchor'], 'middle')
    assert_equal(text['v_baseline'], 'central')
    assert_equal(text['zorder'], 3)
    assert_equal(text['coordinates'], "data")


def test_image():
    fig, ax = plt.subplots()
    ax.imshow(np.random.random((20, 20)), cmap=plt.cm.binary,
              alpha=0.2, zorder=4, extent=(2, 4, 3, 5))
    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]
    image = axrep['images'][0]

    # TODO: how to test data?
    assert_equal(list(sorted(image.keys())),
                 ['alpha', 'coordinates', 'data', 'extent', 'id', 'zorder'])
    assert_equal(image['alpha'], 0.2)
    assert_equal(image['extent'], (2, 4, 3, 5))
    assert_equal(image['zorder'], 4)
    assert_equal(image['coordinates'], "data")

########NEW FILE########
__FILENAME__ = test_figure
"""
Test creation of a figure
"""
import matplotlib.pyplot as plt
from .. import fig_to_dict
from numpy.testing import assert_equal


def test_basic_figure():
    size = (8, 6)
    dpi = 80
    fig = plt.figure(figsize=size, dpi=dpi)
    rep = fig_to_dict(fig)
    plt.close(fig)

    assert_equal(list(sorted(rep.keys())),
                 ['axes', 'data', 'height', 'id', 'plugins', 'width'])
    assert_equal(rep['width'], size[0] * dpi)
    assert_equal(rep['height'], size[1] * dpi)
    assert_equal(rep['data'], {})
    assert_equal(rep['axes'], [])


def test_axes():
    bbox = [0.1, 0.1, 0.8, 0.8]
    xlim = [-10, 10]
    ylim = [-20, 20]

    fig = plt.figure()
    ax = fig.add_axes(bbox)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)

    rep = fig_to_dict(fig)
    axrep = rep['axes'][0]

    assert_equal(list(sorted(axrep.keys())),
                 ['axes', 'axesbg', 'axesbgalpha', 'bbox', 'collections',
                  'id', 'images', 'lines', 'markers', 'paths', 'sharex',
                  'sharey', 'texts', 'xdomain', 'xlim', 'xscale', 'ydomain',
                  'ylim', 'yscale', 'zoomable'])

    for key in ['collections', 'images', 'lines', 'markers', 'paths', 'texts']:
        assert_equal(axrep[key], [])

    for key in ['xlim', 'xdomain']:
        assert_equal(axrep[key], xlim)

    for key in ['ylim', 'ydomain']:
        assert_equal(axrep[key], ylim)

    for key in ['xscale', 'yscale']:
        assert_equal(axrep[key], 'linear')

    assert_equal(axrep['zoomable'], True)

    assert_equal(axrep['bbox'], bbox)

########NEW FILE########
__FILENAME__ = test_html
"""
Test html output
"""
import numpy as np
import matplotlib.pyplot as plt
from .. import fig_to_html, urls
from numpy.testing import assert_equal


def test_html():
    fig, ax = plt.subplots()
    ax.plot(np.arange(10), np.random.random(10),
            '--ok', alpha=0.3, zorder=10, lw=2)

    d3_url = "http://this.is.a.test/d3.js"
    mpld3_url = "http://this.is.a.test/mpld3.js"

    for template_type in ["simple", "notebook", "general"]:
        html1 = fig_to_html(fig, template_type=template_type)
        html2 = fig_to_html(fig, d3_url, mpld3_url,
                            template_type=template_type)

        # use [:-3] to strip .js from the end (it's not used in require)
        assert urls.D3_URL[:-3] in html1
        assert urls.MPLD3_URL[:-3] in html1
        assert d3_url[:-3] in html2
        assert mpld3_url[:-3] in html2

########NEW FILE########
__FILENAME__ = test_js_libs
import os
from ..urls import MPLD3_LOCAL, MPLD3MIN_LOCAL, D3_LOCAL


def test_js_libs_exist():
    for jsfile in [MPLD3_LOCAL, MPLD3MIN_LOCAL, D3_LOCAL]:
        assert os.path.exists(jsfile)

########NEW FILE########
__FILENAME__ = test_plugin
"""
Test plugins
"""
import numpy as np
import matplotlib.pyplot as plt
from .. import fig_to_html, plugins
from numpy.testing import assert_equal


class FakePlugin(plugins.PluginBase):
    JAVASCRIPT = """TEST--this is the javascript--TEST"""

    def __init__(self, fig):
        self.fig = fig
        self.dict_ = {}
        self.css_ = """TEST--this is the css--TEST"""


def test_plugins():
    fig, ax = plt.subplots()
    ax.plot(np.arange(10), np.random.random(10),
            '--ok', alpha=0.3, zorder=10, lw=2)
    plug = FakePlugin(fig)
    plugins.connect(fig, plug)

    for template_type in ["simple", "notebook", "general"]:
        html = fig_to_html(fig, template_type=template_type)
        assert plug.JAVASCRIPT in html
        assert plug.css_ in html

########NEW FILE########
__FILENAME__ = test_contour
"""Plot to test line contours"""
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.mlab as mlab
import mpld3


def create_plot():
    x = np.linspace(-3.0, 3.0, 30)
    y = np.linspace(-2.0, 2.0, 30)
    X, Y = np.meshgrid(x, y)
    Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
    Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
    Z = 10.0 * (Z2 - Z1)

    fig, ax = plt.subplots()
    CS = ax.contour(X, Y, Z)
    ax.clabel(CS, inline=True, fontsize=10)
    return fig


def test_contour():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_contourf
"""Plot to test line contours"""
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.mlab as mlab
import mpld3


def create_plot():
    x = np.linspace(-3.0, 3.0, 30)
    y = np.linspace(-2.0, 2.0, 30)
    X, Y = np.meshgrid(x, y)
    Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
    Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
    Z = 10.0 * (Z2 - Z1)

    fig, ax = plt.subplots()
    CS = ax.contourf(X, Y, Z, 30)
    return fig


def test_contourf():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_date
"""Plot to test date axis"""
import matplotlib.pyplot as plt
import numpy as np
import matplotlib
import datetime
import time
import mpld3


def create_plot():
    otimes = [datetime.date(2013, 12, i) for i in range(1, 11)]
    times = matplotlib.dates.date2num(otimes)

    np.random.seed(0)

    fig, ax = plt.subplots()
    ax.xaxis_date()
    fig.autofmt_xdate()
    ax.plot(times, np.random.random(len(times)), "-", linewidth=3)

    return fig


def test_date():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_errorbar
"""
Test Error bars
"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    np.random.seed(1)

    x = np.linspace(0, 10, 100)
    y = np.sin(x)
    xdata = 10 * np.random.random(25)
    dy = 0.2 + 0.2 * np.random.random(xdata.shape)
    ydata = np.random.normal(np.sin(xdata), dy)

    fig, ax = plt.subplots()
    ax.plot(x, y, lw=2, alpha=0.5)
    ax.errorbar(xdata, ydata, dy, fmt='ok', ecolor='gray', label='errors')
    ax.legend()

    return fig


def test_errorbar():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_fill
"""Plot to test text"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()
    ax.grid(color='lightgray')

    x = np.linspace(0, 4 * np.pi, 1000)
    y1 = 0.5 * np.sin(0.5 * x)
    y2 = np.sin(x)
    y3 = np.cos(x)

    y1[450:550] = np.nan

    ax.fill(x, y1, alpha=0.3, facecolor='green')
    ax.fill_between(x, y2, y3, alpha=0.3, facecolor='red')
    ax.fill_between(x, -y2, -y3, alpha=0.3, facecolor='blue')

    ax.set_xlim(0, 4 * np.pi)
    ax.set_ylim(-1.1, 1.1)

    ax.set_title("fill() and fill_between()", size=18)
    return fig


def test_fill():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_hist
"""Plot to test polygons"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()
    ax.grid(color='gray')

    x = np.random.normal(size=500)
    ax.hist(x, 30, fc='blue', alpha=0.5)

    ax.xaxis.set_major_locator(plt.NullLocator())

    return fig


def test_hist():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_imshow
"""Plot to test imshow"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()

    x = np.linspace(-2, 2, 20)
    y = x[:, None]
    X = np.zeros((20, 20, 4))

    X[:, :, 0] = np.exp(- (x - 1) ** 2 - (y) ** 2)
    X[:, :, 1] = np.exp(- (x + 0.71) ** 2 - (y - 0.71) ** 2)
    X[:, :, 2] = np.exp(- (x + 0.71) ** 2 - (y + 0.71) ** 2)
    X[:, :, 3] = np.exp(-0.25 * (x ** 2 + y ** 2))

    im = ax.imshow(X, extent=(10, 20, 10, 20),
                   origin='lower', zorder=1, interpolation='nearest')
    fig.colorbar(im, ax=ax)

    ax.text(16, 16, "overlaid text")
    ax.text(16, 15, "covered text", zorder=0)

    ax.set_title('An Image', size=20)
    ax.set_xlim(9, 21)
    ax.set_ylim(9, 21)
    return fig


def test_imshow():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_interactive_legend
"""Plot to test legend"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3
from mpld3 import plugins

def create_plot():
    fig, ax = plt.subplots()

    x = np.linspace(0, 10, 100)
    l1 = ax.plot(x, np.sin(x), label='sin', lw=3, alpha=0.2)
    l2 = ax.plot(x, np.cos(x), label='cos', lw=3, alpha=0.2)
    l3 = ax.plot(x[::5], 0.5 * np.sin(x[::5] + 2), 'ob', label='dots',
                 alpha=0.2)

    labels = ['sin', 'cos', 'dots']
    interactive_legend = plugins.InteractiveLegendPlugin([l1, l2, l3], labels)
    plugins.connect(fig, interactive_legend)

    ax.set_title("Interactive legend test", size=20)

    return fig


def test_legend():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_legend
"""Plot to test legend"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()

    x = np.linspace(0, 10, 100)
    ax.plot(x, np.sin(x), label='sin', lw=3, alpha=0.5)
    ax.plot(x, np.cos(x), label='cos', lw=3, alpha=0.5)
    ax.plot(x[::5], 0.5 * np.sin(x[::5] + 2), 'ob', label='dots')

    ax.legend(fancybox=True)
    ax.set_title("Legend test", size=20)

    return fig


def test_legend():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_lines
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import mpld3


def create_plot():
    fig, ax = plt.subplots()

    x = [0, 1]

    for i, color in enumerate(['red', 'green', '#0000FF']):
        x = 1 + 6 * i
        for j, alpha in enumerate([0.3, 0.6, 1.0]):
            for k, linestyle in enumerate(['solid', 'dashed',
                                           'dashdot', 'dotted', '--']):
                y = 0.5 + k + 0.33 * j
                lines = ax.plot([x, x + 2.5, x + 5], [y, y + 0.2, y],
                                lw=6 * alpha,
                                c=color, ls=linestyle, alpha=alpha)
                if linestyle == '--':
                    lines[0].set_dashes([8, 4, 2, 4, 2, 4])

    ax.set_ylim(0, 5.5)
    ax.set_title("Line Styles, Widths, Transparencies", size=20)
    return fig


def test_lines():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_line_collections
"""Plot to test line collections"""
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.collections import LineCollection
import mpld3


def create_plot():
    t = np.linspace(0, 10, 100)
    x = 0.1 * t * np.cos(np.pi * t)
    y = 0.1 * t * np.sin(np.pi * t)
    points = np.array([x, y]).T.reshape(100, 1, 2)
    segments = np.hstack([points[:-1], points[1:]])

    lc = LineCollection(segments, cmap=plt.cm.jet,
                        norm=plt.Normalize(0, 10),
                        array=t, linewidths=3)

    fig, ax = plt.subplots()
    ax.add_collection(lc)
    plt.xlim(-1, 1)
    plt.ylim(-1, 1)

    ax.set_title("Line Collections", size=18)

    ax.xaxis.set_major_formatter(plt.NullFormatter())
    ax.yaxis.set_major_formatter(plt.NullFormatter())
    return fig


def test_line_collections():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_line_HTMLtooltips
"""Plot to test HTML line tooltip"""
import matplotlib.pyplot as plt

import mpld3
from mpld3 import plugins


def create_plot():
    fig, ax = plt.subplots()
    line, = ax.plot([0, 1, 3, 8, 5], '-', lw=5)
    label = '<h1>Line {}</h1>'.format('A')
    plugins.connect(fig, plugins.LineHTMLTooltip(line, label))
    ax.set_title('Line with HTML Tooltip')
    return fig


def test_line_tooltips():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_line_tooltips
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import numpy as np

import mpld3
from mpld3 import plugins


def create_plot():
    fig, ax = plt.subplots()
    line, = ax.plot([0, 1, 3, 8, 5], '-', lw=5)
    plugins.connect(fig, plugins.LineLabelTooltip(line, ['Line A']))
    ax.set_title('Line with Tooltip')
    return fig


def test_line_tooltips():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_logscale
"""Plot to test logscale"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig = plt.figure()
    fig.subplots_adjust(hspace=0.4, wspace=0.4)

    ax1 = fig.add_subplot(2, 2, 1)
    ax2 = fig.add_subplot(2, 2, 2, sharey=ax1, xscale='log')
    ax3 = fig.add_subplot(2, 2, 3, sharex=ax1, yscale='log')
    ax4 = fig.add_subplot(2, 2, 4, sharex=ax2, sharey=ax3)

    x = np.linspace(1, 1e2)
    y = x ** 2

    for ax in [ax1, ax2, ax3, ax4]:
        ax.plot(x, y)

    return fig


def test_logscale():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_markers
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()

    np.random.seed(0)
    numPoints = 10
    for marker in ['oc', 'vr', '^g', '+k', 'db']:
        ax.plot(np.random.normal(size=numPoints),
                np.random.normal(size=numPoints),
                marker, ms=5+20*np.random.uniform(),
                alpha=0.5*np.random.uniform(),
                mew=1)

    ax.set_xlabel('this is x')
    ax.set_ylabel('this is y')
    ax.set_title('Marker test!', size=14)
    ax.grid(color='lightgray', alpha=0.7)
    return fig


def test_markers():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_nan
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()

    np.random.seed(0)
    numPoints = 10

    xx = np.arange(numPoints, dtype=float)
    xx[6] = np.nan

    yy = np.random.normal(size=numPoints)
    yy[3] = np.nan

    ax.plot(xx, yy, 'ks-', ms=10, mec='w', mew=3)

    ax.set_xlabel('x has uniform spacing')
    ax.set_ylabel('y includes a nan')
    ax.set_title('NaN test', size=14)
    return fig


def test_nan():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_pandas_timeaxis
import matplotlib.pyplot as plt
import numpy as np
import mpld3


def create_plot():
    try:
        import pandas as pd
    except:
        from nose import SkipTest
        raise SkipTest("pandas not installed")
    df2_index = pd.DatetimeIndex(start="2010-01-01", periods=100, freq='D')
    df2 = pd.DataFrame({'a': range(100)}, index=df2_index)
    ax = df2.plot(title="Datetime DF")
    return plt.gcf()


def test_pandas_timeaxis():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_patches
"""Plot to test patches"""
import matplotlib.pyplot as plt
from matplotlib import patches
import numpy as np
import mpld3


def create_plot():
    fig, ax = plt.subplots()
    ax.grid(color='lightgray')

    rcolor = lambda: np.random.random(3)

    p = [patches.Arrow(0.75, 0.75, 0.5, 0.5),
         patches.Circle((1, 2), 0.4),
         patches.RegularPolygon((1, 3), 5, 0.4),
         patches.Rectangle((1.6, 0.75), 0.8, 0.5),
         patches.CirclePolygon((2, 2), 0.4),
         patches.Polygon([[1.75, 3], [2, 3.25], [2.25, 3],
                          [2, 2.75], [1.75, 3]]),
         patches.Wedge((3, 1), 0.4, 0, 270),
         patches.Ellipse((3, 2), 0.6, 0.4),
         patches.Arc((3, 3), 0.5, 0.5, 270, 90)]

    for patch in p:
        patch.set_facecolor(rcolor())
        patch.set_edgecolor(rcolor())
        patch.set_alpha(0.5)
        patch.set_linewidth(2)
        ax.add_patch(patch)

    # add a static patch
    ax.add_patch(patches.Rectangle((0.3, 0.4), 0.4, 0.4,
                                   fc='yellow', ec='black', alpha=0.3,
                                   transform=ax.transAxes))

    # add a patch with facecolor=None
    ax.add_patch(patches.Circle((4.0, 2.5), 0.4,
                                facecolor='none', edgecolor='k'))

    # add a patch with edgecolor=None
    ax.add_patch(patches.Circle((4.0, 1.5), 0.4, facecolor='#9999FF',
                                edgecolor='none', linewidth=2))

    # make sure axes ratio is equal
    ax.set_xlim(0.5, 0.5 + 3. * 4. / 3.)
    ax.set_ylim(0.5, 3.5)

    ax.set_title("Various Patches", size=16)
    return fig


def test_patches():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_subplots
"""Plot to test text"""
import matplotlib.pyplot as plt
import mpld3
from mpld3 import plugins


def create_plot():
    fig, ax = plt.subplots(2, 2, sharex='col', sharey='row')
    fig.subplots_adjust(hspace=0.3)

    for i in range(2):
        for j in range(2):
            txt = '({i}, {j})'.format(i=i, j=j)
            ax[i, j].set_title(txt, size=14)
            ax[i, j].text(0.5, 0.5, txt, size=40, ha='center')
            ax[i, j].grid(True, color='lightgray')
            ax[i, j].set_xlabel('xlabel')
            ax[i, j].set_ylabel('ylabel')

    plugins.connect(fig, plugins.MousePosition())
    return fig


def test_subplots():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_text
"""Plot to test text"""
import matplotlib.pyplot as plt
import mpld3


def create_plot():
    fig, ax = plt.subplots()
    ax.grid(color='gray')

    # test font sizes
    x = 0.1
    for y, size in zip([0.1, 0.3, 0.5, 0.7, 0.9],
                       [8, 12, 16, 20, 24]):
        ax.text(x, y, "size={0}".format(size), size=size, ha='left')

    # test horizontal alignment
    x = 0.5
    for y, align in zip([0.2, 0.4, 0.6],
                        ['left', 'center', 'right']):
        ax.text(x, y, "ha=" + align, ha=align, size=20)

    # test vertical alignment
    y = 0.9
    for x, align in zip([0.5, 0.7, 0.9],
                        ['top', 'center', 'bottom']):
        ax.text(x, y, "va=" + align, ha='center', va=align, size=14)

    # test colors & rotations
    x = 0.8
    for y, c, r in zip([0.15, 0.4, 0.65],
                       ['red', 'blue', 'green'],
                       [-45, 0, 45]):
        ax.text(x, y, "{0} rot={1}".format(c, r),
                size=18, color=c, rotation=r, ha='center', va='center')

    ax.set_xlabel('x label')
    ax.set_ylabel('y label')
    ax.set_title('title', size=20)
    return fig


def test_text():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_tooltips_basic
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3
from mpld3 import plugins


def create_plot():
    fig, ax = plt.subplots()
    points = ax.plot(range(10), 'o', ms=20)
    plugins.connect(fig, plugins.PointLabelTooltip(points[0],
                                                   location="top left"))
    return fig


def test_tooltips_basic():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = test_tooltips_labels
"""Plot to test line styles"""
import matplotlib.pyplot as plt
import numpy as np
import mpld3
from mpld3 import plugins


def create_plot():
    fig, ax = plt.subplots()
    colors = plt.rcParams['axes.color_cycle']
    points = []

    for i, color in enumerate(colors):
        points = ax.plot(i, 0, 'o', c=color, ms=20)
        plugins.connect(fig,
                        plugins.PointLabelTooltip(points[0], [color]))
    ax.set_xlim(-1, len(colors) + 1)
    return fig


def test_tooltips_labels():
    fig = create_plot()
    html = mpld3.fig_to_html(fig)
    plt.close(fig)


if __name__ == "__main__":
    mpld3.show(create_plot())

########NEW FILE########
__FILENAME__ = urls
"""
mpld3 URLs
==========
URLs and filepaths for the mpld3 javascript libraries
"""

import os
from . import __path__, __version__
import warnings

__all__ = ["D3_URL", "MPLD3_URL", "MPLD3MIN_URL",
           "D3_LOCAL", "MPLD3_LOCAL", "MPLD3MIN_LOCAL"]

WWW_JS_DIR = "https://mpld3.github.io/js/"
D3_URL = WWW_JS_DIR + "d3.v3.min.js"
MPLD3_URL = WWW_JS_DIR + "mpld3.v{0}.js".format(__version__)
MPLD3MIN_URL = WWW_JS_DIR + "mpld3.v{0}.min.js".format(__version__)

LOCAL_JS_DIR = os.path.join(__path__[0], "js")
D3_LOCAL = os.path.join(LOCAL_JS_DIR, "d3.v3.min.js")
MPLD3_LOCAL = os.path.join(LOCAL_JS_DIR,
                           "mpld3.v{0}.js".format(__version__))
MPLD3MIN_LOCAL = os.path.join(LOCAL_JS_DIR,
                              "mpld3.v{0}.min.js".format(__version__))

########NEW FILE########
__FILENAME__ = utils
"""
mpld3 Utilities
===============
Utility routines for the mpld3 package
"""

import os
import re
import shutil
import warnings
from functools import wraps
from . import urls

# Make sure that DeprecationWarning gets printed
warnings.simplefilter("always", DeprecationWarning)


def html_id_ok(objid, html5=False):
    """Check whether objid is valid as an HTML id attribute.

    If html5 == True, then use the more liberal html5 rules.
    """
    if html5:
        return not re.search('\s', objid)
    else:
        return bool(re.match("^[a-zA-Z][a-zA-Z0-9\-\.\:\_]*$", objid))


def get_id(obj, suffix="", prefix="el", warn_on_invalid=True):
    """Get a unique id for the object"""
    if not suffix:
        suffix = ""
    if not prefix:
        prefix = ""

    objid = prefix + str(os.getpid()) + str(id(obj)) + suffix

    if warn_on_invalid and not html_id_ok(objid):
        warnings.warn('"{0}" is not a valid html ID. This may cause problems')

    return objid


def deprecated(func, old_name, new_name):
    """Decorator to mark functions as deprecated."""
    @wraps(func)
    def new_func(*args, **kwargs):
        warnings.warn(("{0} is deprecated and will be removed.  "
                       "Use {1} instead".format(old_name, new_name)),
                      category=DeprecationWarning)
        return func(*args, **kwargs)
    new_func.__doc__ = ("*%s is deprecated: use %s instead*\n\n    "
                        % (old_name, new_name)) + new_func.__doc__
    return new_func


def write_ipynb_local_js(location=None, d3_src=None, mpld3_src=None):
    """
    Write the mpld3 and d3 javascript libraries to the given file location.

    This utility is used by the IPython notebook tools to enable easy use
    of mpld3 with no web connection.

    Parameters
    ----------
    location : string (optioal)
        the directory in which the d3 and mpld3 javascript libraries will be
        written. If not specified, the IPython nbextensions directory will be
        used. If IPython doesn't support nbextensions (< 2.0),
        the current working directory will be used.
    d3_src : string (optional)
        the source location of the d3 library. If not specified, the standard
        path in mpld3.urls.D3_LOCAL will be used.
    mpld3_src : string (optional)
        the source location of the mpld3 library. If not specified, the
        standard path in mpld3.urls.MPLD3_LOCAL will be used.

    Returns
    -------
    d3_url, mpld3_url : string
        The URLs to be used for loading these js files.
    """
    if location is None:
        try:
            from IPython.html import install_nbextension
        except ImportError:
            location = os.getcwd()
            nbextension = False
        else:
            nbextension = True
    else:
        nbextension = False

    if d3_src is None:
        d3_src = urls.D3_LOCAL
    if mpld3_src is None:
        mpld3_src = urls.MPLD3_LOCAL

    d3js = os.path.basename(d3_src)
    mpld3js = os.path.basename(mpld3_src)

    if not os.path.exists(d3_src):
        raise ValueError("d3 src not found at '{0}'".format(d3_src))
    if not os.path.exists(mpld3_src):
        raise ValueError("mpld3 src not found at '{0}'".format(mpld3_src))

    if nbextension:
        # IPython 2.0+.
        # This will not work if a url prefix is added
        prefix = '/nbextensions/'

        try:
            install_nbextension([d3_src, mpld3_src])
        except IOError:
            # files may be read only. We'll try deleting them and re-installing
            from IPython.utils.path import get_ipython_dir
            nbext = os.path.join(get_ipython_dir(), "nbextensions")

            for src in [d3_src, mpld3_src]:
                dest = os.path.join(nbext, os.path.basename(src))
                if os.path.exists(dest):
                    os.remove(dest)
            install_nbextension([d3_src, mpld3_src])

    else:
        # IPython < 2.0 or explicit path.
        # This won't work if users have changed the kernel directory.
        prefix = '/files/'

        d3_dest = os.path.join(location, d3js)
        mpld3_dest = os.path.join(location, mpld3js)

        for src, dest in [(d3_src, d3_dest), (mpld3_src, mpld3_dest)]:
            try:
                shutil.copyfile(src, dest)
            except IOError:
                # file may be read only. We'll try deleting it first
                if os.path.exists(dest):
                    os.remove(dest)
                shutil.copyfile(src, dest)


    return prefix + d3js, prefix + mpld3js

########NEW FILE########
__FILENAME__ = _display
import warnings
import random
import json
import jinja2
import re
import os
from ._server import serve_and_open
from .utils import deprecated, get_id, write_ipynb_local_js
from .mplexporter import Exporter
from .mpld3renderer import MPLD3Renderer
from . import urls

__all__ = ["fig_to_html", "fig_to_dict", "fig_to_d3",
           "display_d3", "display",
           "show_d3", "show",
           "enable_notebook", "disable_notebook",
           "save_html", "save_json"]


# Simple HTML template. This works in standalone web pages for single figures,
# but will not work within the IPython notebook due to the presence of
# requirejs
SIMPLE_HTML = jinja2.Template("""
<script type="text/javascript" src="{{ d3_url }}"></script>
<script type="text/javascript" src="{{ mpld3_url }}"></script>

<style>
{{ extra_css }}
</style>

<div id={{ figid }}></div>
<script type="text/javascript">

  !function(mpld3){
       {{ extra_js }}
       mpld3.draw_figure({{ figid }}, {{ figure_json }});
  }(mpld3);


</script>
""")


# RequireJS template.  If requirejs and jquery are not defined, this will
# result in an error.  This is suitable for use within the IPython notebook.
REQUIREJS_HTML = jinja2.Template("""
<style>
{{ extra_css }}
</style>

<div id={{ figid }}></div>
<script type="text/javascript">

if(typeof(window.mpld3) !== "undefined" && window.mpld3._mpld3IsLoaded){
    !function (mpld3){
            {{ extra_js }}
            mpld3.draw_figure({{ figid }}, {{ figure_json }});
    }(mpld3);
}else{
  require.config({paths: {d3: "{{ d3_url[:-3] }}"}});
  require(["d3"], function(d3){
    window.d3 = d3;
    $.getScript("{{ mpld3_url }}", function(){
       {{ extra_js }}
       mpld3.draw_figure({{ figid }}, {{ figure_json }});
    });
  });
}
</script>
""")


# General HTML template.  This should work correctly whether or not requirejs
# is defined, and whether it's embedded in a notebook or in a standalone
# HTML page.
GENERAL_HTML = jinja2.Template("""

<style>
{{ extra_css }}
</style>

<div id={{ figid }}></div>
<script>
function mpld3_load_lib(url, callback){
  var s = document.createElement('script');
  s.src = url;
  s.async = true;
  s.onreadystatechange = s.onload = callback;
  s.onerror = function(){console.warn("failed to load library " + url);};
  document.getElementsByTagName("head")[0].appendChild(s);
}

if(typeof(mpld3) !== "undefined" && mpld3._mpld3IsLoaded){
   // already loaded: just create the figure
   !function(mpld3){
       {{ extra_js }}
       mpld3.draw_figure({{ figid }}, {{ figure_json }});
   }(mpld3);
}else if(typeof define === "function" && define.amd){
   // require.js is available: use it to load d3/mpld3
   require.config({paths: {d3: "{{ d3_url[:-3] }}"}});
   require(["d3"], function(d3){
      window.d3 = d3;
      mpld3_load_lib("{{ mpld3_url }}", function(){
         {{ extra_js }}
         mpld3.draw_figure({{ figid }}, {{ figure_json }});
      });
    });
}else{
    // require.js not available: dynamically load d3 & mpld3
    mpld3_load_lib("{{ d3_url }}", function(){
         mpld3_load_lib("{{ mpld3_url }}", function(){
                 {{ extra_js }}
                 mpld3.draw_figure({{ figid }}, {{ figure_json }});
            })
         });
}
</script>
""")

TEMPLATE_DICT = {"simple": SIMPLE_HTML,
                 "notebook": REQUIREJS_HTML,
                 "general": GENERAL_HTML}


def fig_to_dict(fig, **kwargs):
    """Output json-serializable dictionary representation of the figure

    Parameters
    ----------
    fig : matplotlib figure
        The figure to display
    **kwargs :
        Additional keyword arguments passed to mplexporter.Exporter

    Returns
    -------
    fig_dict : dict
        the Python dictionary representation of the figure, which is
        directly convertible to json using the standard json package.

    See Also
    --------
    :func:`save_json`: save json representation of a figure to file
    :func:`save_html` : save html representation of a figure to file
    :func:`fig_to_html` : output html representation of the figure
    :func:`show` : launch a local server and show a figure in a browser
    :func:`display` : embed figure within the IPython notebook
    :func:`enable_notebook` : automatically embed figures in IPython notebook
    """
    renderer = MPLD3Renderer()
    Exporter(renderer, close_mpl=False, **kwargs).run(fig)
    fig, figure_dict, extra_css, extra_js = renderer.finished_figures[0]
    return figure_dict


def fig_to_html(fig, d3_url=None, mpld3_url=None, no_extras=False,
                template_type="general", figid=None, use_http=False, **kwargs):
    """Output html representation of the figure

    Parameters
    ----------
    fig : matplotlib figure
        The figure to display
    d3_url : string (optional)
        The URL of the d3 library.  If not specified, a standard web path
        will be used.
    mpld3_url : string (optional)
        The URL of the mpld3 library.  If not specified, a standard web path
        will be used.
    no_extras : boolean
        If true, remove any extra javascript or CSS. The output will be similar
        to that if the representation output by fig_to_json is embedded in
        a web page.
    template_type : string
        string specifying the type of HTML template to use. Options are:

        ``"simple"``
             suitable for a simple html page with one figure.  Will
             fail if require.js is available on the page.
        ``"notebook"``
             assumes require.js and jquery are available.
        ``"general"``
             more complicated, but works both in and out of the
             notebook, whether or not require.js and jquery are available
    figid : string (optional)
        The html/css id of the figure div, which must not contain spaces.
        If not specified, a random id will be generated.
    use_http : boolean (optional)
        If true, use http:// instead of https:// for d3_url and mpld3_url.

    **kwargs :
        Additional keyword arguments passed to mplexporter.Exporter

    Returns
    -------
    fig_html : string
        the HTML representation of the figure

    See Also
    --------
    :func:`save_json`: save json representation of a figure to file
    :func:`save_html` : save html representation of a figure to file
    :func:`fig_to_dict` : output dictionary representation of the figure
    :func:`show` : launch a local server and show a figure in a browser
    :func:`display` : embed figure within the IPython notebook
    :func:`enable_notebook` : automatically embed figures in IPython notebook
    """
    template = TEMPLATE_DICT[template_type]

    # TODO: allow fig to be a list of figures?
    d3_url = d3_url or urls.D3_URL
    mpld3_url = mpld3_url or urls.MPLD3_URL

    if use_http:
        d3_url = d3_url.replace('https://', 'http://')
        mpld3_url = mpld3_url.replace('https://', 'http://')

    if figid is None:
        figid = 'fig_' + get_id(fig) + str(int(random.random() * 1E10))
    elif re.search('\s', figid):
        raise ValueError("figid must not contain spaces")

    renderer = MPLD3Renderer()
    Exporter(renderer, close_mpl=False, **kwargs).run(fig)

    fig, figure_json, extra_css, extra_js = renderer.finished_figures[0]

    if no_extras:
        extra_css = ""
        extra_js = ""

    return template.render(figid=json.dumps(figid),
                           d3_url=d3_url,
                           mpld3_url=mpld3_url,
                           figure_json=json.dumps(figure_json),
                           extra_css=extra_css,
                           extra_js=extra_js)


def display(fig=None, closefig=True, local=False, **kwargs):
    """Display figure in IPython notebook via the HTML display hook

    Parameters
    ----------
    fig : matplotlib figure
        The figure to display (grabs current figure if missing)
    closefig : boolean (default: True)
        If true, close the figure so that the IPython matplotlib mode will not
        display the png version of the figure.
    local : boolean (optional, default=False)
        if True, then copy the d3 & mpld3 libraries to a location visible to
        the notebook server, and source them from there. See Notes below.
    **kwargs :
        additional keyword arguments are passed through to :func:`fig_to_html`.

    Returns
    -------
    fig_d3 : IPython.display.HTML object
        the IPython HTML rich display of the figure.

    Notes
    -----
    Known issues: using ``local=True`` may not work correctly in certain cases:

    - In IPython < 2.0, ``local=True`` may fail if the current working
      directory is changed within the notebook (e.g. with the %cd command).
    - In IPython 2.0+, ``local=True`` may fail if a url prefix is added
      (e.g. by setting NotebookApp.base_url).

    See Also
    --------
    :func:`show` : launch a local server and show a figure in a browser
    :func:`enable_notebook` : automatically embed figures in IPython notebook
    """
    # import here, in case users don't have requirements installed
    from IPython.display import HTML
    import matplotlib.pyplot as plt

    if local:
        if 'mpld3_url' in kwargs or 'd3_url' in kwargs:
            warnings.warn(
                "display: specified urls are ignored when local=True")
        kwargs['d3_url'], kwargs['mpld3_url'] = write_ipynb_local_js()

    if fig is None:
        fig = plt.gcf()
    if closefig:
        plt.close(fig)
    return HTML(fig_to_html(fig, **kwargs))


def show(fig=None, ip='127.0.0.1', port=8888, n_retries=50,
         local=True, **kwargs):
    """Open figure in a web browser

    Similar behavior to plt.show().  This opens the D3 visualization of the
    specified figure in the web browser.  On most platforms, the browser
    will open automatically.

    Parameters
    ----------
    fig : matplotlib figure
        The figure to display.  If not specified, the current active figure
        will be used.
    ip : string, default = '127.0.0.1'
        the ip address used for the local server
    port : int, default = 8888
        the port number to use for the local server.  If already in use,
        a nearby open port will be found (see n_retries)
    n_retries : int, default = 50
        the maximum number of ports to try when locating an empty port.
    local : bool, default = True
        if True, use the local d3 & mpld3 javascript versions, within the
        js/ folder.  If False, use the standard urls.
    **kwargs :
        additional keyword arguments are passed through to :func:`fig_to_html`

    See Also
    --------
    :func:`display` : embed figure within the IPython notebook
    :func:`enable_notebook` : automatically embed figures in IPython notebook
    """
    if local:
        kwargs['mpld3_url'] = '/mpld3.js'
        kwargs['d3_url'] = '/d3.js'
        files = {'/mpld3.js': ["text/javascript",
                               open(urls.MPLD3_LOCAL, 'r').read()],
                 '/d3.js': ["text/javascript",
                            open(urls.D3_LOCAL, 'r').read()]}
    else:
        files = None

    if fig is None:
        # import here, in case matplotlib.use(...) is called by user
        import matplotlib.pyplot as plt
        fig = plt.gcf()
    html = fig_to_html(fig, **kwargs)
    serve_and_open(html, ip=ip, port=port, n_retries=n_retries, files=files)


def enable_notebook(local=False, **kwargs):
    """Enable the automatic display of figures in the IPython Notebook.

    This function should be used with the inline Matplotlib backend
    that ships with IPython that can be enabled with `%pylab inline`
    or `%matplotlib inline`. This works by adding an HTML formatter
    for Figure objects; the existing SVG/PNG formatters will remain
    enabled.

    Parameters
    ----------
    local : boolean (optional, default=False)
        if True, then copy the d3 & mpld3 libraries to a location visible to
        the notebook server, and source them from there. See Notes below.
    **kwargs :
        all keyword parameters are passed through to :func:`fig_to_html`

    Notes
    -----
    Known issues: using ``local=True`` may not work correctly in certain cases:

    - In IPython < 2.0, ``local=True`` may fail if the current working
      directory is changed within the notebook (e.g. with the %cd command).
    - In IPython 2.0+, ``local=True`` may fail if a url prefix is added
      (e.g. by setting NotebookApp.base_url).

    See Also
    --------
    :func:`disable_notebook` : undo the action of enable_notebook
    :func:`display` : embed figure within the IPython notebook
    :func:`show` : launch a local server and show a figure in a browser
    """
    try:
        from IPython.core.getipython import get_ipython
        from matplotlib.figure import Figure
    except ImportError:
        raise ImportError('This feature requires IPython 1.0+ and Matplotlib')

    if local:
        if 'mpld3_url' in kwargs or 'd3_url' in kwargs:
            warnings.warn(
                "enable_notebook: specified urls are ignored when local=True")
        kwargs['d3_url'], kwargs['mpld3_url'] = write_ipynb_local_js()

    ip = get_ipython()
    formatter = ip.display_formatter.formatters['text/html']
    formatter.for_type(Figure,
                       lambda fig, kwds=kwargs: fig_to_html(fig, **kwds))


def disable_notebook():
    """Disable the automatic display of figures in the IPython Notebook.

    See Also
    --------
    :func:`enable_notebook` : automatically embed figures in IPython notebook
    """
    try:
        from IPython.core.getipython import get_ipython
        from matplotlib.figure import Figure
    except ImportError:
        raise ImportError('This feature requires IPython 1.0+ and Matplotlib')
    ip = get_ipython()
    formatter = ip.display_formatter.formatters['text/html']
    formatter.type_printers.pop(Figure, None)


def save_html(fig, fileobj, **kwargs):
    """Save a matplotlib figure to an html file

    Parameters
    ----------
    fig : matplotlib Figure instance
        The figure to write to file.
    fileobj : filename or file object
        The filename or file-like object in which to write the HTML
        representation of the figure.
    **kwargs :
        additional keyword arguments will be passed to :func:`fig_to_html`

    See Also
    --------
    :func:`save_json`: save json representation of a figure to file
    :func:`fig_to_html` : output html representation of the figure
    :func:`fig_to_dict` : output dictionary representation of the figure
    """
    if isinstance(fileobj, str):
        fileobj = open(fileobj, 'w')
    if not hasattr(fileobj, 'write'):
        raise ValueError("fileobj should be a filename or a writable file")
    fileobj.write(fig_to_html(fig, **kwargs))


def save_json(fig, fileobj, **kwargs):
    """Save a matplotlib figure to a json file.

    Note that any plugins which depend on generated HTML will not be included
    in the JSON encoding.

    Parameters
    ----------
    fig : matplotlib Figure instance
        The figure to write to file.
    fileobj : filename or file object
        The filename or file-like object in which to write the HTML
        representation of the figure.
    **kwargs :
        additional keyword arguments will be passed to :func:`fig_to_dict`

    See Also
    --------
    :func:`save_html` : save html representation of a figure to file
    :func:`fig_to_html` : output html representation of the figure
    :func:`fig_to_dict` : output dictionary representation of the figure
    """
    if isinstance(fileobj, str):
        fileobj = open(fileobj, 'w')
    if not hasattr(fileobj, 'write'):
        raise ValueError("fileobj should be a filename or a writable file")
    json.dump(fig_to_dict(fig, **kwargs), fileobj)


# Deprecated versions of these functions
show_d3 = deprecated(show, "mpld3.show_d3", "mpld3.show")
fig_to_d3 = deprecated(fig_to_html, "mpld3.fig_to_d3", "mpld3.fig_to_html")
display_d3 = deprecated(display, "mpld3.display_d3", "mpld3.display")

########NEW FILE########
__FILENAME__ = _server
"""
A Simple server used to show mpld3 images.
"""
import sys
import threading
import webbrowser
import socket
import itertools
import random

IPYTHON_WARNING = """
Note: if you're in the IPython notebook, mpld3.show() is not the best command
      to use. Consider using mpld3.display(), or mpld3.enable_notebook().
      See more information at http://mpld3.github.io/quickstart.html .

You must interrupt the kernel to end this command
"""

try:
    # Python 2.x
    import BaseHTTPServer as server
except ImportError:
    # Python 3.x
    from http import server


def generate_handler(html, files=None):
    if files is None:
        files = {}

    class MyHandler(server.BaseHTTPRequestHandler):
        def do_GET(self):
            """Respond to a GET request."""
            if self.path == '/':
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write("<html><head>"
                                 "<title>mpld3 plot</title>"
                                 "</head><body>\n")
                self.wfile.write(html)
                self.wfile.write("</body></html>")
            elif self.path in files:
                content_type, content = files[self.path]
                self.send_response(200)
                self.send_header("Content-type", content_type)
                self.end_headers()
                self.wfile.write(content)
            else:
                self.send_error(404)

    return MyHandler


def find_open_port(ip, port, n=50):
    """Find an open port near the specified port"""
    ports = itertools.chain((port + i for i in range(n)),
                            (port + random.randint(-2 * n, 2 * n)))

    for port in ports:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = s.connect_ex((ip, port))
        s.close()
        if result != 0:
            return port
    raise ValueError("no open ports found")


def serve_and_open(html, ip='127.0.0.1', port=8888, n_retries=50, files=None,
                   ipython_warning=True):
    """Start a server serving the given HTML, and open a browser

    Parameters
    ----------
    html : string
        HTML to serve
    ip : string (default = '127.0.0.1')
        ip address at which the HTML will be served.
    port : int (default = 8888)
        the port at which to serve the HTML
    n_retries : int (default = 50)
        the number of nearby ports to search if the specified port is in use.
    files : dictionary (optional)
        dictionary of extra content to serve
    ipython_warning : bool (optional)
        if True (default), then print a warning if this is used within IPython
    """
    port = find_open_port(ip, port, n_retries)
    Handler = generate_handler(html, files)
    srvr = server.HTTPServer((ip, port), Handler)

    if ipython_warning:
        try:
            __IPYTHON__
        except:
            pass
        else:
            print(IPYTHON_WARNING)

    # Start the server
    print("Serving to http://{0}:{1}/    [Ctrl-C to exit]".format(ip, port))
    sys.stdout.flush()

    # Use a thread to open a web browser pointing to the server
    b = lambda: webbrowser.open('http://{0}:{1}'.format(ip, port))
    threading.Thread(target=b).start()

    try:
        srvr.serve_forever()
    except (KeyboardInterrupt, SystemExit):
        print("\nstopping Server...")

    srvr.server_close()

########NEW FILE########
__FILENAME__ = __about__
"""Metadata for the mpld3 package."""
__version__ = '0.3git'

########NEW FILE########
__FILENAME__ = version
"""
Short script which prints the mpld3 version to stdout

This is used within the Javascript build system.
"""
from _mpld3_setup import get_version
print(get_version())

########NEW FILE########
__FILENAME__ = visual_tests
"""
Visualize Test Plots

This script will go through all the plots in the ``mpld3/test_plots``
directory, and save them as D3js to a single HTML file for inspection.
"""
import os
import glob
import sys
import gc
import traceback
import itertools
import json
import contextlib

import matplotlib
matplotlib.use('Agg')  # don't display plots
import matplotlib.pyplot as plt

import mpld3
from mpld3 import urls
from mpld3.mpld3renderer import MPLD3Renderer
from mpld3.mplexporter import Exporter

plt.rcParams['figure.figsize'] = (6, 4.5)
plt.rcParams['savefig.dpi'] = 80

TEMPLATE = """
<html>
<head>
<script type="text/javascript" src={d3_url}></script>
<script type="text/javascript" src={mpld3_url}></script>
<style type="text/css">
.left_col {{
    float: left;
    width: 50%;
}}

.right_col {{
    margin-left: 50%;
    width: 50%;
}}

.fig {{
  height: 500px;
}}

{extra_css}

</style>
</head>

<body>
<div id="wrap">
    <div class="left_col">
        {left_col}
    </div>
    <div class="right_col">
        {right_col}
    </div>
</div>
<script>
    {js_commands}
</script>
</body>
</html>
"""

MPLD3_TEMPLATE = """
<div class="fig" id="fig{figid:03d}"></div>
"""

JS_TEMPLATE = """
!function(mpld3){{
  {extra_js}
  mpld3.draw_figure("fig{figid:03d}", {figure_json});
}}(mpld3);
"""


@contextlib.contextmanager
def mpld3_noshow():
    """context manager to use mpld3 with show() disabled"""
    import mpld3
    _show = mpld3.show
    mpld3.show = lambda *args, **kwargs: None
    yield mpld3
    mpld3.show = _show


@contextlib.contextmanager
def use_dir(dirname=None):
    """context manager to temporarily change the working directory"""
    cwd = os.getcwd()
    if dirname is None:
        dirname = cwd
    os.chdir(dirname)
    yield
    os.chdir(cwd)


class ExecFile(object):
    """
    Class to execute plotting files, and extract the mpl and mpld3 figures.
    """
    def __init__(self, filename, execute=True, pngdir='_pngs'):
        self.filename = filename
        if execute:
            self.execute_file()
        if not os.path.exists(pngdir):
            os.makedirs(pngdir)
        basename = os.path.splitext(os.path.basename(filename))[0]
        self.pngfmt = os.path.join(pngdir, basename + "_{0:2d}.png")

    def execute_file(self):
        """
        Execute the file, catching matplotlib figures
        """
        dirname, fname = os.path.split(self.filename)
        print('plotting {0}'.format(fname))

        # close any currently open figures
        plt.close('all')

        # close any currently open figures
        plt.close('all')

        with mpld3_noshow() as mpld3:
            with use_dir(dirname):
                try:
                    # execute file, forcing __name__ == '__main__'
                    exec(open(os.path.basename(self.filename)).read(),
                         {'plt': plt, 'mpld3': mpld3, '__name__': '__main__'})
                    gcf = matplotlib._pylab_helpers.Gcf
                    fig_mgr_list = gcf.get_all_fig_managers()
                    self.figlist = sorted([manager.canvas.figure
                                           for manager in fig_mgr_list],
                                          key=lambda fig: fig.number)
                except:
                    print(80 * '_')
                    print('{0} is not compiling:'.format(fname))
                    traceback.print_exc()
                    print(80 * '_')
                finally:
                    ncol = gc.collect()

    def iter_png(self):
        for fig in self.figlist:
            fig_png = self.pngfmt.format(fig.number)
            fig.savefig(fig_png)
            yield fig_png

    def iter_json(self):
        for fig in self.figlist:
            renderer = MPLD3Renderer()
            Exporter(renderer, close_mpl=False).run(fig)
            fig, fig_json, extra_css, extra_js = renderer.finished_figures[0]
            yield (json.dumps(fig_json), extra_js, extra_css)


def combine_testplots(wildcard='mpld3/test_plots/*.py',
                      outfile='_test_plots.html',
                      pngdir='_pngs',
                      d3_url=None, mpld3_url=None):
    """Generate figures from the plots and save to an HTML file

    Parameters
    ----------
    wildcard : string or list
        a regexp or list of regexps matching files to test
    outfile : string
        the path at which the output HTML will be saved
    d3_url : string
        the URL of the d3 library to use.  If not specified, a standard web
        address will be used.
    mpld3_url : string
        the URL of the mpld3 library to use.  If not specified, a standard web
        address will be used.
    """
    if isinstance(wildcard, str):
        filenames = glob.glob(wildcard)
    else:
        filenames = itertools.chain(*(glob.glob(w) for w in wildcard))

    fig_png = []
    fig_json = []
    for filename in filenames:
        result = ExecFile(filename, pngdir=pngdir)
        fig_png.extend(result.iter_png())
        fig_json.extend(result.iter_json())

    left_col = [MPLD3_TEMPLATE.format(figid=i)
                for i in range(len(fig_json))]
    js_commands = [JS_TEMPLATE.format(figid=figid,
                                      figure_json=figjson,
                                      extra_js=figjs)
                   for figid, (figjson, figjs, _) in enumerate(fig_json)]
    right_col = ['<div class="fig"><img src="{0}"></div>\n'.format(fig)
                 for fig in fig_png]
    extra_css = [tup[2] for tup in fig_json]

    print("writing results to {0}".format(outfile))
    with open(outfile, 'w') as f:
        f.write(TEMPLATE.format(left_col="".join(left_col),
                                right_col="".join(right_col),
                                d3_url=json.dumps(d3_url),
                                mpld3_url=json.dumps(mpld3_url),
                                js_commands="".join(js_commands),
                                extra_css="".join(extra_css)))


def run_main():
    import argparse
    parser = argparse.ArgumentParser(description=("Run files and convert "
                                                  "output to D3"))
    parser.add_argument("files", nargs='*', type=str)
    parser.add_argument("-d", "--d3-url",
                        help="location of d3 library",
                        type=str, default=None)
    parser.add_argument("-m", "--mpld3-url",
                        help="location of the mpld3 library",
                        type=str, default=None)
    parser.add_argument("-o", "--output",
                        help="output filename",
                        type=str, default='_test_plots.html')
    parser.add_argument("-j", "--minjs", action="store_true")
    parser.add_argument("-l", "--local", action="store_true")
    parser.add_argument("-n", "--nolaunch", action="store_true")
    args = parser.parse_args()

    if len(args.files) == 0:
        wildcard = ['mpld3/test_plots/*.py', 'examples/*.py']
    else:
        wildcard = args.files

    if args.d3_url is None:
        args.d3_url = urls.D3_URL
    if args.mpld3_url is None:
        args.mpld3_url = urls.MPLD3_URL

    if args.local:
        args.d3_url = urls.D3_LOCAL
        if args.minjs:
            args.mpld3_url = urls.MPLD3MIN_LOCAL
        else:
            args.mpld3_url = urls.MPLD3_LOCAL
    else:
        if args.minjs:
            args.mpld3_url = urls.MPLD3MIN_URL

    print("d3 url: {0}".format(args.d3_url))
    print("mpld3 url: {0}".format(args.mpld3_url))

    combine_testplots(wildcard=wildcard,
                      outfile=args.output,
                      d3_url=args.d3_url,
                      mpld3_url=args.mpld3_url)
    return args.output, args.nolaunch


if __name__ == '__main__':
    outfile, nolaunch = run_main()

    if not nolaunch:
        # Open local file (works on OSX; maybe not on other systems)
        import webbrowser
        webbrowser.open_new('file://localhost' + os.path.abspath(outfile))

########NEW FILE########
