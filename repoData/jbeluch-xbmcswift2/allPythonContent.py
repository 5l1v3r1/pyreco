__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# XBMC Swift documentation build configuration file, created by
# sphinx-quickstart on Sat Jan 21 15:24:10 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.join(os.path.abspath('.'), '..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'XBMC Swift'
copyright = u'2012, Jonathan Beluch'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# Add _themes to path
sys.path.append(os.path.abspath('_themes'))

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'default'
html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'XBMCSwiftdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'XBMCSwift.tex', u'XBMC Swift Documentation',
   u'Jonathan Beluch', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'xbmcswift', u'XBMC Swift Documentation',
     [u'Jonathan Beluch'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'XBMCSwift', u'XBMC Swift Documentation',
   u'Jonathan Beluch', 'XBMCSwift', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = fabfile
'''
A fabric file to automate creation of a special distribution of
xbmcswift2 for XBMC. This distribution doesn't include docs and tests.
It has a slightly different folder structure and contains some XBMC
specific files.

Usage:
    # Create a new release for Dharma
    $ fab release:dharma,prepare
    # Edit the changelog.txt in the temp directory and `git add` it
    $ fab release:dharma,perform
'''
import tempfile
import shutil
import os
from xml.etree import ElementTree as ET
import subprocess
import xam
from fabric.api import *
import fabric.colors as colors


EDITOR = 'vim'
REPO_DIR = 'xbmcswift2-xbmc-dist'
REPO_URL = 'git@github.com:jbeluch/xbmcswift2-xbmc-dist.git'
REPO_PUBLIC_URL = 'git://github.com/jbeluch/xbmcswift2-xbmc-dist.git'
BRANCHES = {
    # <xbmc_version>: <git_branch>
    'DHARMA': 'dharma',
    'EDEN': 'eden',
    'FRODO': 'master',
}


def log(msg, important=False):
    if important:
        puts(colors.green(msg))
    else:
        puts(colors.yellow(msg))


class GitRepo(object):
    def __init__(self, path=None, remote_url=None):
        self.path = path
        self.remote_url = remote_url

    def clone(self, parent_dir):
        with lcd(parent_dir):
            local('git clone %s' % self.remote_url)

    def stage_all(self):
        with lcd(self.path):
            local('git add -A')

    def get_head_hash(self):
        with lcd(self.path):
            return local('git log | head -1 | cut -f2 -d" "', capture=True)

    def checkout_remote_branch(self, branch):
        with lcd(self.path):
            if branch == 'master':
                local('git checkout master')
            else:
                local('git checkout -b %s origin/%s' % (branch, branch))

    def push(self, branch):
        with lcd(self.path):
            local('git push --tags origin %s' % branch)

    def tag(self, tag, message):
        with lcd(self.path):
            local('git tag -a %s -m "%s"' % (tag, message))

    def commit(self, version):
        with lcd(self.path):
            local('git commit -m "[xbmcswift2-release-script] prepare release %s"' % version)


def bump_minor(version_str):
    left, right = version_str.rsplit('.', 1)
    right = int(right) + 1
    return '%s.%s' % (left, right)

def get_addon_version(addon_dir):
    filename = os.path.join(addon_dir, 'addon.xml')
    xml = ET.parse(filename).getroot()
    return xam.Addon(xml).version

def get_addon_id(addon_dir):
    filename = os.path.join(addon_dir, 'addon.xml')
    xml = ET.parse(filename).getroot()
    return xam.Addon(xml).id

def set_addon_version(addon_dir, version):
    filename = os.path.join(addon_dir, 'addon.xml')
    xml = ET.parse(filename).getroot()
    addon = xam.Addon(xml)
    addon.version = version
    write_file(filename, addon.to_xml_string())


def bump_version(addon_dir):
    current_version = get_addon_version(addon_dir)
    new_version = prompt('Specify new version number: ', default=bump_minor(current_version))
    set_addon_version(addon_dir, new_version)


def rmdir(path):
    puts('Removing dir %s' % path)
    try:
        shutil.rmtree(path)
    except OSError:
        pass


def copydir(src, dest):
    puts('Copying %s to %s' % (src, dest))
    shutil.copytree(src, dest)


def write_file(path, contents):
    puts('Writing content to %s' % path)
    with open(path, 'w') as out:
        out.write(contents)


def print_email(addon_id, version, git_url, tag, xbmc_version):
    lines = [
        'Mailing List Email',
        '------------------',
        '',
        'Subject: [git pull] %s' % addon_id,
        '*addon - %s' % addon_id,
        '*version - %s' % version,
        '*url - %s' % git_url,
        '*tag - %s' % tag,
        '*xbmc version - %s' % xbmc_version,
        '',
        '',
    ]

    for line in lines:
        puts(colors.cyan(line))

@task
def local_release(xbmc_version=None):
    if xbmc_version is None:
        abort('Must specify an XBMC version, [dharma, eden]')
    xbmc_version = xbmc_version.upper()
    if xbmc_version not in BRANCHES.keys():
        abort('Invalid XBMC version, [dharma, eden]')

    local_repo, dist_repo = release_prepare(xbmc_version)
    print 'Development release created at %s' % dist_repo.path


@task
def release(xbmc_version=None):
    if xbmc_version is None:
        abort('Must specify an XBMC version, [dharma, eden]')
    xbmc_version = xbmc_version.upper()
    if xbmc_version not in BRANCHES.keys():
        abort('Invalid XBMC version, [dharma, eden]')

    local_repo, dist_repo = release_prepare(xbmc_version)
    release_perform(xbmc_version, local_repo, dist_repo)


def release_prepare(xbmc_version):
    assert not os.path.exists(os.path.join(os.path.dirname(__file__), '.release')), 'Release in progress. Either `fab release:perform` or `fab release:clear`'
    parent_dir = tempfile.mkdtemp()
    dist_path = os.path.join(parent_dir, REPO_DIR)

    # First get the current git version so we can include this in the release
    local_repo = GitRepo(path=os.path.dirname(__file__))
    current_git_version =  local_repo.get_head_hash()
    log('Release using commit %s' % current_git_version)

    # Clone a fresh copy of the current dist repo
    log('Cloning fresh copy of distribution repo...')
    dist_repo = GitRepo(path=dist_path, remote_url=REPO_URL)
    dist_repo.clone(parent_dir)

    # Checkout the proper branch
    log('Using branch %s for the distribution repo...' % BRANCHES[xbmc_version])
    dist_repo.checkout_remote_branch(BRANCHES[xbmc_version])

    # We could rsync, but easier to just remove existing xbmcswift2 dir and
    # copy over the current version
    log('Removing old xbmcswift2 dir and copying over current version...')
    rmdir(os.path.join(dist_path, 'lib', 'xbmcswift2'))
    copydir(os.path.join(local_repo.path, 'xbmcswift2'),
            os.path.join(dist_path, 'lib', 'xbmcswift2'))

    # Remove the cli and mockxbmc packages as they are not necessary for XBMC
    # execution
    log('Removing unneccessary cli and mockxbmc packages...')
    rmdir(os.path.join(dist_path, 'lib', 'xbmcswift2', 'cli'))
    rmdir(os.path.join(dist_path, 'lib', 'xbmcswift2', 'mockxbmc'))

    # Now we need to add the current git HEAD to a file in the dist repo
    log('Adding deployed git hash to xbmcswift2_version file...')
    write_file(os.path.join(dist_path, 'xbmcswift2_version'),
               current_git_version)

    # Prompt user for new XBMC version
    log('Bumping version...')
    bump_version(dist_path)

    # open changelog in vim
    log('Opening changelog.txt for editing...')
    changelog = os.path.join(dist_path, 'changelog.txt')

    # if user doesn't want to continue they shouldu be able to :cq
    returncode = subprocess.check_call([EDITOR, changelog])

    # return both repos
    return local_repo, GitRepo(path=dist_path)


def release_perform(xbmc_version, local_repo, dist_repo):
    # Stage everything in the repo
    log('Staging all modified files in the distribution repo...')
    dist_repo.stage_all()

    # Get the current XBMC version
    version = get_addon_version(dist_repo.path)

    # Commit all staged changes and tag
    log('Commiting changes and tagging the release...')
    dist_repo.commit(version)
    dist_repo.tag(version, '%s v%s' % (xbmc_version, version))

    # Tag the local repo as well
    local_repo.tag('xbmc-%s' % version, 'XBMC distribution v%s' % version)

    # Push everything
    log('Pushing changes to remote...')
    dist_repo.push(BRANCHES[xbmc_version])

    puts(colors.green('Release performed.'))

    # write the email
    addon_id = get_addon_id(dist_repo.path)
    print_email(addon_id, version, REPO_PUBLIC_URL, version, xbmc_version.lower())

########NEW FILE########
__FILENAME__ = test_console
import unittest
from xbmcswift2.cli import console


class TestConsole(unittest.TestCase):

    def test_get_max_len(self):
        items = ['a', 'bb', 'ccc', 'dddd']
        self.assertEqual(console.get_max_len(items), 4)
        self.assertEqual(console.get_max_len([]), 0)

########NEW FILE########
__FILENAME__ = test_create
import unittest
import tempfile
from xbmcswift2.cli import create


class TestCreate(unittest.TestCase):

    def test_update_regular_file(self):
        fileobj, filename = tempfile.mkstemp(suffix='.py', text=True)

        # setup
        with open(filename, 'w') as fileobj:
            fileobj.write('This is a test of the emergency {broadcast} system.')

        create.update_file(filename, {'broadcast': 'kitten'})

        with open(filename, 'r') as fileobj:
            result = fileobj.read()
        self.assertEqual('This is a test of the emergency kitten system.', result)

    def test_update_xml_file(self):
        fileobj, filename = tempfile.mkstemp(suffix='addon.xml', text=True)
        print filename

        # setup
        with open(filename, 'w') as fileobj:
            fileobj.write('<tag provider={provider}/>')

        create.update_file(filename, {'provider': 'name aka "another name" <name@domain.com> \'foo\''})

        with open(filename, 'r') as fileobj:
            result = fileobj.read()
        expected = '<tag provider="name aka &quot;another name&quot; &lt;name@domain.com&gt; \'foo\'"/>'
        self.assertEqual(expected, result)

########NEW FILE########
__FILENAME__ = test_common
from unittest import TestCase
from xbmcswift2.common import xbmc_url, enum, clean_dict, pickle_dict, unpickle_dict, unhex


class TestXBMCUrl(TestCase):
    def test_xbmc_url(self):
        known_values = (
            # url, options_dict, expected_value
            ('url', {}, 'url'),
            ('url', {'key': 'val'}, 'url|key=val'),
            ('url', {'key': 3}, 'url|key=3'),
            ('url', {'a': 'b', 'c': 'd'}, 'url|a=b&c=d'),
            ('url', {'symbol': '=', 'c': 'd'}, 'url|symbol=%3D&c=d'),
        )
        for url, options, expected in known_values:
            self.assertEqual(expected, xbmc_url(url, **options))

class TestEnum(TestCase):
    def test_kwargs_enum(self):
        States = enum(NJ='New Jersey', NY='New York')
        self.assertEqual(States.NJ, 'New Jersey')
        self.assertEqual(States.NY, 'New York')
        self.assertEqual(sorted(States._fields), sorted(['NJ', 'NY']))

    def test_args_enum(self):
        States = enum('NEW_JERSEY', 'NEW_YORK')
        self.assertEqual(States.NEW_YORK, 'NEW_YORK')
        self.assertEqual(States.NEW_JERSEY, 'NEW_JERSEY')
        self.assertEqual(sorted(States._fields), sorted(['NEW_YORK', 'NEW_JERSEY']))

    def test_mixed_enum(self):
        States = enum('NEW_JERSEY', NY='NEW_YORK')
        self.assertEqual(States.NY, 'NEW_YORK')
        self.assertEqual(States.NEW_JERSEY, 'NEW_JERSEY')
        self.assertEqual(sorted(States._fields), sorted(['NY', 'NEW_JERSEY']))

#class TestUrlParse(TestCase):
    #def test_url_parse(self):
        ## supposed to return scheme, netloc and path
        #known_values = (
            ## url, scheme, netloc, path
            #('plugin://my.plugin.id/path/', 'plugin', 'my.plugin.id', '/path/'),
            #('plugin://my.plugin.id:8080/path/', 'plugin', 'my.plugin.id:8080', '/path/'),
            #('plugin://my.plugin.id:8080/', 'plugin', 'my.plugin.id:8080', '/'),
            #('http://my.plugin.id/path?foo=bar', 'http', 'my.plugin.id', '/path?foo=bar'),
            #('http://example.com/path/to/video', 'http', 'example.com', '/path/to/video'),
        #)
        #for url, netloc, scheme, path in known_values:
            #self.assertEqual(urlparse(url), (netloc, scheme, path))

class TestCleanDict(TestCase):
    def test_clean_dict(self):
       items = { 'foo': 'foo', 'bar': None, 'baz': False, 'age': 0, }
       expected = { 'foo': 'foo', 'baz': False, 'age': 0, }
       self.assertEqual(expected, clean_dict(items))


class TestPickleDict(TestCase):
    def test_pickle_dict(self):
        items = {
            'name': u'jon',
            'animal': 'dog',
            'boolean': True,
            'number': 42,
            'list': ['a', 'b'],
            'dict': {'foo': 'bar'},
        }
        pickled = pickle_dict(items)
        expected = (
            ('name', u'jon'),
            ('animal', 'dog'),
            ('boolean', 'I01\n.'),
            ('number', 'I42\n.'),
            ('list', "(lp1\nS'a'\naS'b'\na.",),
            ('dict', "(dp1\nS'foo'\np2\nS'bar'\np3\ns."),
        )


        self.assertEqual(len(pickled.items()), 7)
        for key, val in expected:
            self.assertEqual(pickled.get(key), val)
        fields = pickled.get('_pickled').split(',')
        self.assertEqual(sorted(fields), ['boolean', 'dict', 'list', 'number'])
        self.assertEqual(unpickle_dict(pickled), items)
        self.assertEqual(unpickle_dict(pickle_dict(items)), items)


class TestDownloadPage(TestCase):
    def test_download_page(self):
        pass


class TestUnhex(TestCase):
    def test_unhex(self):
        known_values = (
            ('\x20', ' '),
            ('\x3d\x20', '= '),
            ('\x3D\x20', '= '),
        )

        for hexed, unhexed in known_values:
            self.assertEqual(unhexed, unhex(hexed))

########NEW FILE########
__FILENAME__ = test_constants
import unittest
from xbmcswift2 import SortMethod


class TestSortMethod(unittest.TestCase):

    def test_from_string(self):
        known_values = [
            ('title', 9),
            ('TiTLe', 9),
            ('label', 1),
            ('LAbel', 1),
        ]
        for sort_method, value in known_values:
            self.assertEqual(SortMethod.from_string(sort_method), value)

    def test_attrs(self):
        known_values = [
            ('TITLE', 9),
            ('DATE', 3),
            ('LABEL_IGNORE_THE', 2),
        ]

        for sort_method, value in known_values:
            self.assertEqual(getattr(SortMethod, sort_method), value)

########NEW FILE########
__FILENAME__ = test_listitem
from unittest import TestCase
from xbmcswift2 import xbmcgui, ListItem
from mock import Mock, patch

class TestListItem(TestCase):
    def setUp(self):
        self.listitem = ListItem('label', 'label2', 'icon', 'thumbnail', 'path')

    def test_init(self):
        li = self.listitem
        self.assertEqual(li.label, 'label')
        self.assertEqual(li.label2, 'label2')
        self.assertEqual(li.icon, 'icon')
        self.assertEqual(li.thumbnail, 'thumbnail')
        self.assertEqual(li.path, 'path')

    def test_label(self):
        item = ListItem('foo')
        self.assertEqual(item.label, 'foo')
        item.label = 'bar'
        self.assertEqual(item.label, 'bar')
        item.set_label('baz')
        self.assertEqual(item.get_label(), 'baz')

    def test_label2(self):
        item = ListItem('foo')
        self.assertIsNone(item.label2)
        item.label2 = 'bar'
        self.assertEqual(item.label2, 'bar')
        item.set_label2('baz')
        self.assertEqual(item.get_label2(), 'baz')

    def test_icon(self):
        item = ListItem()
        self.assertIsNone(item.icon)

        item.icon = 'bar'
        self.assertEqual(item.icon, 'bar')
        self.assertEqual(item.get_icon(), 'bar')

        item.set_icon('baz')
        self.assertEqual(item.icon, 'baz')
        self.assertEqual(item.get_icon(), 'baz')

    def test_thumbnail(self):
        item = ListItem()
        self.assertIsNone(item.thumbnail)

        item.thumbnail = 'bar'
        self.assertEqual(item.thumbnail, 'bar')
        self.assertEqual(item.get_thumbnail(), 'bar')

        item.set_thumbnail('baz')
        self.assertEqual(item.thumbnail, 'baz')
        self.assertEqual(item.get_thumbnail(), 'baz')

    def test_path(self):
        item = ListItem()
        self.assertIsNone(item.path)

        item.path = 'bar'
        self.assertEqual(item.path, 'bar')
        self.assertEqual(item.get_path(), 'bar')

        item.set_path('baz')
        self.assertEqual(item.path, 'baz')
        self.assertEqual(item.get_path(), 'baz')

    def test_context_menu(self):
        menu_items = [('label1', 'foo'), ('label2', 'bar')]
        item = ListItem()
        item.add_context_menu_items(menu_items)
        self.assertEqual(item.get_context_menu_items(), menu_items)

        extra_menu_item = ('label3', 'baz')
        menu_items.append(extra_menu_item)
        item.add_context_menu_items([extra_menu_item])
        self.assertEqual(item.get_context_menu_items(), menu_items)

    def test_set_info(self):
        with patch.object(xbmcgui.ListItem, 'setInfo') as mock_setInfo:
            item = ListItem()
            item.set_info('video', {'title': '300'})
        mock_setInfo.assert_called_with('video', {'title': '300'})

    def test_stream_info(self):
        with patch.object(xbmcgui.ListItem, 'addStreamInfo') as mock_stream_info:
            item = ListItem()
            item.add_stream_info('video', {'duration': 185})
            mock_stream_info.assert_called_with('video', {'duration': 185})
            item.add_stream_info('audio', {'languange': 'en'})
            mock_stream_info.assert_called_with('audio', {'languange': 'en'})

    def test_selected(self):
        item = ListItem()
        self.assertEqual(item.selected, False)
        self.assertEqual(item.is_selected(), False)

        item.selected = True
        self.assertEqual(item.selected, True)
        self.assertEqual(item.is_selected(), True)

        item.select(False)
        self.assertEqual(item.selected, False)
        self.assertEqual(item.is_selected(), False)

    def test_select_getter(self):
        with patch.object(xbmcgui.ListItem, 'isSelected') as mock_isSelected:
            mock_isSelected.return_value = False
            item = ListItem()
            self.assertEqual(item.selected, False)
        mock_isSelected.assert_called_with()

    def test_select_setter(self):
        with patch.object(xbmcgui.ListItem, 'select') as mock_select:
            item = ListItem()
            item.selected = True
            mock_select.assert_called_with(True)
            item.selected = False
            mock_select.assert_called_with(False)

    def test_select(self):
        with patch.object(xbmcgui.ListItem, 'select') as mock_select:
            item = ListItem()
            item.selected = True
            mock_select.assert_called_with(True)
            item.select(False)
            mock_select.assert_called_with(False)

    def test_is_selected(self):
        with patch.object(xbmcgui.ListItem, 'isSelected') as mock_isSelected:
            mock_isSelected.return_value = False
            item = ListItem()
            self.assertEqual(item.is_selected(), False)
        mock_isSelected.assert_called_with()

    @patch('xbmcswift2.xbmcgui.ListItem.getProperty')
    def test_get_property(self, mock_getProperty):
        mock_getProperty.return_value = 'bar'
        item = ListItem()
        self.assertEqual(item.get_property('foo'), 'bar')
        mock_getProperty.assert_called_with('foo')

    @patch('xbmcswift2.xbmcgui.ListItem.setProperty')
    def test_set_property(self, mock_setProperty):
        item = ListItem()
        item.set_property('foo', 'bar')
        mock_setProperty.assert_called_with('foo', 'bar')

    def test_as_tuple(self):
        item = ListItem()
        self.assertEqual(item.as_tuple(), (None, item._listitem, True))



class TestListItemAsserts(TestCase):

    def test_non_basestring_key(self):
        item = ListItem()
        self.assertRaises(AssertionError, item.add_context_menu_items, [(42, 'action')])
        self.assertRaises(AssertionError, item.add_context_menu_items, [(None, 'action')])

    def test_non_basestring_val(self):
        item = ListItem()
        self.assertRaises(AssertionError, item.add_context_menu_items, [('label', 42)])
        self.assertRaises(AssertionError, item.add_context_menu_items, [('label', None)])



class TestFromDict(TestCase):

    def test_from_dict_props(self):
        dct = {
            'properties': {'StartOffset': '256.4'},
        }
        item = ListItem.from_dict(**dct)
        self.assertEqual(item.get_property('StartOffset'), '256.4')

        dct = {
            'properties': [('StartOffset', '256.4')],
        }
        item = ListItem.from_dict(**dct)
        self.assertEqual(item.get_property('StartOffset'), '256.4')

    def test_from_dict(self):
        dct = {
            'label': 'foo',
            'label2': 'bar',
            'icon': 'icon',
            'thumbnail': 'thumbnail',
            'path': 'plugin://my.plugin.id/',
            'selected': True,
            'info': {'title': 'My title'},
            'info_type': 'pictures',
            'properties': [('StartOffset', '256.4')],
            'stream_info': {
                'video': {'duration': 185}
            },
            'context_menu': [('label', 'action')],
            'is_playable': True}
        with patch.object(ListItem, 'set_info', spec=True) as mock_set_info:
            with patch.object(ListItem, 'add_stream_info', spec=True) as mock_set_stream_info:
                item = ListItem.from_dict(**dct)
        self.assertEqual(item.label, 'foo')
        self.assertEqual(item.label2, 'bar')
        self.assertEqual(item.icon, 'icon')
        self.assertEqual(item.thumbnail, 'thumbnail')
        self.assertEqual(item.path, 'plugin://my.plugin.id/')
        self.assertEqual(item.selected, True)
        mock_set_info.assert_called_with('pictures', {'title': 'My title'})
        mock_set_stream_info.assert_called_with('video', {'duration': 185})
        self.assertEqual(item.get_property('StartOffset'), '256.4')
        self.assertEqual(item.get_context_menu_items(), [('label', 'action')])
        self.assertEqual(item.get_property('isPlayable'), 'true')
        self.assertEqual(item.is_folder, False)

    def test_from_dict_info_default_info_type(self):
        dct = {'info': {'title': 'My title'}}
        with patch.object(ListItem, 'set_info', spec=True) as mock_set_info:
            item = ListItem.from_dict(**dct)
        mock_set_info.assert_called_with('video', {'title': 'My title'})

########NEW FILE########
__FILENAME__ = test_module
import os
import sys
from unittest import TestCase
from xbmcswift2 import Module, Plugin, NotFoundException
from utils import preserve_cwd


TEST_STRINGS_FN = os.path.join(os.path.dirname(__file__), 'data', 'strings.xml')


def create_plugin_module():
        module = Module('namespace')
        sys.argv = ['./addon.py']
        path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
        with preserve_cwd(os.path.dirname(path)):
            plugin = Plugin('Hello XBMC', 'plugin.video.helloxbmc', path)
        return plugin, module


class TestModule(TestCase):

    def test_init(self):
        module = Module('my.module.namespace')
        self.assertEqual('namespace', module._namespace)
        # Test that properties raise an Exception when a module isn't registered
        self.assertRaises(RuntimeError, getattr, module, 'plugin')
        self.assertRaises(RuntimeError, getattr, module, 'cache_path')
        self.assertRaises(RuntimeError, getattr, module, 'addon')
        self.assertRaises(RuntimeError, getattr, module, 'added_items')
        self.assertRaises(RuntimeError, getattr, module, 'handle')
        self.assertRaises(RuntimeError, getattr, module, 'request')
        self.assertRaises(RuntimeError, getattr, module, 'url_prefix')

    def test_properties_after_registration(self):
        plugin, module = create_plugin_module()
        plugin.register_module(module, 'module/')
        self.assertEqual(module.plugin, plugin)
        self.assertEqual(module.addon, plugin.addon)
        self.assertEqual(module.added_items, plugin.added_items)

        # no request registered yet
        self.assertRaises(Exception, getattr, module, 'handle')
        self.assertRaises(Exception, getattr, module, 'request')
        self.assertEqual(module.url_prefix, 'module/')



class TestRoute(TestCase):
    #def setUp(self):
        #self.module = Module('my.module.namespace')
        #sys.argv = ['./addon.py']
        #self.plugin = Plugin('Hello XBMC', 'plugin.video.helloxbmc', __file__, TEST_STRINGS_FN)

    def test_route(self):
        plugin, module = create_plugin_module()
        @module.route('/')
        @module.route('/videos', 'show_videos', {'video_id': 42})
        @module.route('/video/<video_id>', name='show_video')
        def view(video_id=None):
            pass
        plugin.register_module(module, '/module')
        self.assertEqual(plugin.url_for('namespace.view'), 'plugin://plugin.video.helloxbmc/module/')
        self.assertEqual(module.url_for('namespace.view'), 'plugin://plugin.video.helloxbmc/module/')
        self.assertEqual(module.url_for('view'), 'plugin://plugin.video.helloxbmc/module/')
        self.assertRaises(NotFoundException, module.url_for, 'view', explicit=True)
        self.assertRaises(NotFoundException, plugin.url_for, 'view')

        self.assertEqual(plugin.url_for('namespace.show_videos'), 'plugin://plugin.video.helloxbmc/module/videos')
        self.assertEqual(module.url_for('namespace.show_videos'), 'plugin://plugin.video.helloxbmc/module/videos')
        self.assertEqual(module.url_for('show_videos'), 'plugin://plugin.video.helloxbmc/module/videos')
        self.assertRaises(NotFoundException, module.url_for, 'show_videos', explicit=True)
        self.assertRaises(NotFoundException, plugin.url_for, 'show_videos')

        self.assertRaises(KeyError, plugin.url_for, 'namespace.show_video')
        self.assertEqual(plugin.url_for('namespace.show_video', video_id='42'),
            'plugin://plugin.video.helloxbmc/module/video/42')

    def test_named_routes(self):
        plugin, module = create_plugin_module()
        @module.route('/foo', 'foo')
        @module.route('/bar', 'bar')
        def view(video_id=None):
            pass
        plugin.register_module(module, '/module')

        self.assertRaises(NotFoundException, module.url_for, 'view', explicit=True)
        self.assertRaises(NotFoundException, plugin.url_for, 'view')

########NEW FILE########
__FILENAME__ = test_plugin
import os
import sys
import shutil
import pickle
from unittest import TestCase

from mock import Mock, patch

from xbmcswift2.mockxbmc.xbmc import TEMP_DIR
from xbmcswift2 import Plugin
import xbmcswift2

from utils import preserve_cli_mode, preserve_cwd

# Ensure we are starting clean by removing old test folders
try:
    shutil.rmtree(TEMP_DIR)
except OSError:
    # doesn't exist, just pass
    pass




class TestInit(TestCase):

    def test_init_cli_mode(self):
        name = 'Hello XBMC'
        plugin_id = 'plugin.video.helloxbmc'
        path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
        with preserve_cwd(os.path.dirname(path)):
            plugin = Plugin(name, plugin_id, path)

        self.assertEqual(plugin_id, plugin.id)
        self.assertEqual(plugin.name, name)
        self.assertEqual(plugin.info_type, 'video')
        self.assertTrue(os.path.isdir(plugin.storage_path))
        self.assertEqual(plugin.added_items, [])
        self.assertRaises(Exception, getattr, plugin, 'handle')
        self.assertRaises(Exception, getattr, plugin, 'request')

    def test_init_cli_mode_default_args(self):
        name = 'Hello XBMC'
        with preserve_cwd(os.path.join(os.path.dirname(__file__), 'data', 'plugin')):
            plugin = Plugin()

        self.assertEqual('plugin.video.academicearth', plugin.id)
        self.assertEqual(plugin.name, 'Academic Earth')
        self.assertTrue(os.path.isdir(plugin.storage_path))
        self.assertEqual(plugin.added_items, [])
        self.assertRaises(Exception, getattr, plugin, 'handle')
        self.assertRaises(Exception, getattr, plugin, 'request')

    def test_init_not_cli_mode(self):
        name = 'Hello XBMC'
        plugin_id = 'plugin.video.helloxbmc'
        path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
        with preserve_cwd(os.path.dirname(path)):
            with preserve_cli_mode(cli_mode=False):
                plugin = Plugin(name, plugin_id, path)

        self.assertEqual(plugin_id, plugin.id)
        self.assertEqual(plugin.name, name)
        self.assertTrue(os.path.isdir(plugin.storage_path))
        self.assertEqual(plugin.added_items, [])
        self.assertRaises(Exception, getattr, plugin, 'handle')
        self.assertRaises(Exception, getattr, plugin, 'request')

    def test_init_not_cli_mode_default_args(self):
        name = 'Hello XBMC'
        path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
        with preserve_cli_mode(cli_mode=False):
            with preserve_cwd(os.path.join(os.path.dirname(__file__), 'data', 'plugin')):
                plugin = Plugin()

        self.assertEqual('plugin.video.academicearth', plugin.id)
        self.assertEqual(plugin.name, 'Academic Earth')
        self.assertTrue(os.path.isdir(plugin.storage_path))
        self.assertEqual(plugin.added_items, [])
        self.assertRaises(Exception, getattr, plugin, 'handle')
        self.assertRaises(Exception, getattr, plugin, 'request')

    def test_info_types(self):
        name = 'Hello XBMC'
        path = __file__

        # can't parse from id, default to video
        with preserve_cli_mode(cli_mode=False):
            with preserve_cwd(os.path.join(os.path.dirname(__file__), 'data', 'plugin')):
                plugin = Plugin(name, 'script.module.test', path)
                self.assertEqual(plugin.info_type, 'video')

                # parse from ID
                plugin = Plugin(name, 'plugin.audio.test')
                self.assertEqual(plugin.info_type, 'music')

                plugin = Plugin(name, 'plugin.video.test')
                self.assertEqual(plugin.info_type, 'video')

                plugin = Plugin(name, 'plugin.image.test')
                self.assertEqual(plugin.info_type, 'pictures')

                # info_type param should override value parsed from id
                plugin = Plugin(name, 'plugin.video.test', info_type='music')
                self.assertEqual(plugin.info_type, 'music')


class TestParseRequest(TestCase):

    def setUp(self):
        name = 'Hello XBMC'
        plugin_id = 'plugin.video.helloxbmc'
        path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
        with preserve_cwd(os.path.dirname(path)):
            self.plugin = Plugin(name, plugin_id, path)

    def test_parse_request(self):
        with patch('xbmcswift2.plugin.Request') as MockRequest:
            sys.argv = ['plugin://plugin.video.helloxbmc', '0', '?']
            self.plugin._parse_request()
            MockRequest.assert_called_with('plugin://plugin.video.helloxbmc?', '0')

    def test_parse_request_no_qs(self):
        with patch('xbmcswift2.plugin.Request') as MockRequest:
            sys.argv = ['plugin://plugin.video.helloxbmc', '0']
            self.plugin._parse_request()
            MockRequest.assert_called_with('plugin://plugin.video.helloxbmc', '0')

    def test_parse_request_path_in_arg0(self):
        # Older versions of xbmc sometimes pass path in arg0
        with patch('xbmcswift2.plugin.Request') as MockRequest:
            sys.argv = ['plugin://plugin.video.helloxbmc/videos/', '0', '?foo=bar']
            self.plugin._parse_request()
            MockRequest.assert_called_with('plugin://plugin.video.helloxbmc/videos/?foo=bar', '0')

    def test_parse_request_path_in_arg2(self):
        # Older versions of xbmc sometimes pass path in arg2
        with patch('xbmcswift2.plugin.Request') as MockRequest:
            sys.argv = ['plugin://plugin.video.helloxbmc', '0', '/videos/?foo=bar']
            self.plugin._parse_request()
            MockRequest.assert_called_with('plugin://plugin.video.helloxbmc/videos/?foo=bar', '0')


def NewPlugin():
    name = 'Hello XBMC'
    plugin_id = 'plugin.video.helloxbmc'
    path = os.path.join(os.path.dirname(__file__), 'data', 'plugin', 'addon.py')
    with preserve_cwd(os.path.dirname(path)):
        return Plugin(name, plugin_id, path)

def _TestPluginRunner(plugin):
    def run(relative_url, handle=0, qs='?'):
        url = 'plugin://%s%s' % (plugin.id, relative_url)
        sys.argv = [url, handle, qs]
        items =  plugin.run(test=True)
        plugin._end_of_directory = False
        plugin.clear_added_items()
        return items
    return run


class TestBasicRouting(TestCase):

    def test_url_for_func(self):
        plugin = NewPlugin()
        @plugin.route('/', name='another_name')
        def main_menu():
            return [{'label': 'Hello XBMC'}]
        self.assertEqual(plugin.url_for(main_menu), 'plugin://plugin.video.helloxbmc/')
        self.assertEqual(plugin.url_for(main_menu, foo='bar'), 'plugin://plugin.video.helloxbmc/?foo=bar')
        self.assertEqual(plugin.url_for(main_menu, foo=3), 'plugin://plugin.video.helloxbmc/?foo=3')

    def test_url_for(self):
        plugin = NewPlugin()
        @plugin.route('/')
        def main_menu():
            return [{'label': 'Hello XBMC'}]
        self.assertEqual(plugin.url_for('main_menu'), 'plugin://plugin.video.helloxbmc/')
        self.assertEqual(plugin.url_for('main_menu', foo='bar'), 'plugin://plugin.video.helloxbmc/?foo=bar')
        self.assertEqual(plugin.url_for('main_menu', foo=3), 'plugin://plugin.video.helloxbmc/?foo=3')

    def test_url_for_multiple_routes(self):
        plugin = NewPlugin()
        @plugin.route('/')
        @plugin.route('/videos/', name='videos')
        def main_menu():
            return [{'label': 'Hello XBMC'}]
        self.assertEqual(plugin.url_for('main_menu'), 'plugin://plugin.video.helloxbmc/')
        self.assertEqual(plugin.url_for('main_menu', foo='bar'), 'plugin://plugin.video.helloxbmc/?foo=bar')
        self.assertEqual(plugin.url_for('main_menu', foo=3), 'plugin://plugin.video.helloxbmc/?foo=3')
        self.assertEqual(plugin.url_for('videos'), 'plugin://plugin.video.helloxbmc/videos/')

    def test_options(self):
        plugin = NewPlugin()
        @plugin.route('/person/<name>/', options={'name': 'dave'})
        def person(name):
            return [{'label': 'Hello %s' % name}]
        self.assertEqual(plugin.url_for('person', name='jon'), 'plugin://plugin.video.helloxbmc/person/jon/')
        self.assertEqual(plugin.url_for('person'), 'plugin://plugin.video.helloxbmc/person/dave/')

    def test_basic_routing(self):
        plugin = NewPlugin()
        @plugin.route('/')
        def main_menu():
            return [{'label': 'Hello XBMC'}]
        with preserve_cli_mode(cli_mode=False):
            test_run = _TestPluginRunner(plugin)
            resp = test_run('/')
            self.assertEqual('Hello XBMC', resp[0].get_label())

    def test_options_routing(self):
        plugin = NewPlugin()
        @plugin.route('/person/<name>/')
        @plugin.route('/')
        @plugin.route('/dave/', options={'name': 'dave'})
        def person(name='chris'):
            return [{'label': 'Hello %s' % name}]
        with preserve_cli_mode(cli_mode=False):
            test_run = _TestPluginRunner(plugin)
            resp = test_run('/person/jon/')
            print plugin.request.url
            self.assertEqual('Hello jon', resp[0].get_label())
            resp = test_run('/dave/')
            self.assertEqual('Hello dave', resp[0].get_label())
            resp = test_run('/')
            self.assertEqual('Hello chris', resp[0].get_label())

    #def test_route_conflict(self):
        # TODO this should raise an error
        #plugin = NewPlugin()
        #@plugin.route('/')
        #def jon():
            #return 'Hello jon'
        #@plugin.route('/')
        #def dave():
            #return 'Hello dave'
        #with preserve_cli_mode(cli_mode=False):
            #test_run = _TestPluginRunner(plugin)
            #resp = test_run('/')
            #self.assertEqual('Hello jon', resp)
            #self.assertEqual('Hello dave', resp)

    def test_redirect(self):
        plugin = NewPlugin()
        @plugin.route('/')
        def main_menu():
            url = plugin.url_for('videos')
            return plugin.redirect(url)
        @plugin.route('/videos/')
        def videos():
            return [{'label': 'Hello Videos'}]
        with preserve_cli_mode(cli_mode=False):
            test_run = _TestPluginRunner(plugin)
            resp = test_run('/')
            self.assertEqual('Hello Videos', resp[0].get_label())

class TestRegisterModule():
    pass


class TestUnsyncedCaches(TestCase):

    def test_unsyced_caches(self):

        plugin = NewPlugin()
        @plugin.route('/')
        def route_that_doesnt_call_finish():
            ppl = plugin.get_storage('people')
            ppl['foo'] = 'bar'
        sys.argv = ['plugin://plugin.video.helloxbmc/', '1', '?']
        plugin.run()

        # ensure the cache is persisted to disk
        fn = os.path.join(plugin.storage_path, 'people')
        synced = pickle.load(open(fn, 'rb'))
        self.assertEqual(synced.keys(), ['foo'])

        # Since storages store the timestamp as well, we just check our actual
        # value since we can't guess the timestamp
        self.assertEqual(synced['foo'][0], 'bar')

########NEW FILE########
__FILENAME__ = test_request
from unittest import TestCase
from xbmcswift2 import Request

class TestRequest(TestCase):
    def test_init(self):
        request = Request('plugin://my.plugin.id/home/?foo=bar&biz=buzz', '0')
        self.assertEqual(request.url, 'plugin://my.plugin.id/home/?foo=bar&biz=buzz')
        self.assertEqual(request.handle, 0)
        self.assertEqual(request.query_string, 'foo=bar&biz=buzz')
        self.assertEqual(request.args, {'foo': ['bar'], 'biz': ['buzz']})
        self.assertEqual(request.scheme, 'plugin')
        self.assertEqual(request.netloc, 'my.plugin.id')
        self.assertEqual(request.path, '/home/')

    def test_init2(self):
        '''Bug in urlparse for the following url. The netloc is '' and
        the path is incorrectly reported as 'my.plugin.id'
        '''
        request = Request('plugin://my.plugin.id/?foo=bar&biz=buzz', '0')
        self.assertEqual(request.url, 'plugin://my.plugin.id/?foo=bar&biz=buzz')
        self.assertEqual(request.handle, 0)
        self.assertEqual(request.query_string, 'foo=bar&biz=buzz')
        self.assertEqual(request.args, {'foo': ['bar'], 'biz': ['buzz']})
        self.assertEqual(request.scheme, 'plugin')
        self.assertEqual(request.netloc, 'my.plugin.id')
        self.assertEqual(request.path, '/')

    def test_pickled_qs_args(self):
        request = Request('plugin://plugin.video.helloxbmc/?foo=I3%0A.&_pickled=foo', '0')
        self.assertEqual(request.url, 'plugin://plugin.video.helloxbmc/?foo=I3%0A.&_pickled=foo')
        self.assertEqual(request.handle, 0)
        self.assertEqual(request.query_string, 'foo=I3%0A.&_pickled=foo')
        self.assertEqual(request.args, {'foo': [3]})
        self.assertEqual(request.scheme, 'plugin')
        self.assertEqual(request.netloc, 'plugin.video.helloxbmc')
        self.assertEqual(request.path, '/')

########NEW FILE########
__FILENAME__ = test_storage
import os
import pickle
from xbmcswift2.storage import _Storage, TimedStorage
from unittest import TestCase
from datetime import timedelta
import time


def remove(filename):
    try:
        os.remove(filename)
    except OSError:
        pass


class TestCache(TestCase):

    def test_pickle(self):
        filename = '/tmp/testdict.pickle'
        remove(filename)
        storage = _Storage(filename, file_format='pickle')

        storage['name'] = 'jon'
        storage.update({'answer': 42})
        storage.close()

        storage2 = _Storage(filename, file_format='pickle')
        self.assertEqual(storage, storage2)
        self.assertEqual(2, len(storage2.items()))
        self.assertTrue('name' in storage2.keys())
        self.assertTrue('answer' in storage2.keys())
        self.assertEqual('jon', storage2.pop('name'))
        self.assertEqual(42, storage2['answer'])

        remove(filename)

    def test_csv(self):
        filename = '/tmp/testdict.csv'
        remove(filename)
        storage = _Storage(filename, file_format='csv')

        storage['name'] = 'jon'
        storage.update({'answer': '42'})
        storage.close()

        storage2 = _Storage(filename, file_format='csv')
        self.assertEqual(sorted(storage.items()), sorted(storage2.items()))
        self.assertEqual(2, len(storage2.items()))
        self.assertTrue('name' in storage2.keys())
        self.assertTrue('answer' in storage2.keys())
        self.assertEqual('jon', storage2.pop('name'))
        self.assertEqual('42', storage2['answer'])

        remove(filename)

    def test_json(self):
        filename = '/tmp/testdict.json'
        remove(filename)
        storage = _Storage(filename, file_format='json')

        storage['name'] = 'jon'
        storage.update({'answer': '42'})
        storage.close()

        storage2 = _Storage(filename, file_format='json')
        self.assertEqual(sorted(storage.items()), sorted(storage2.items()))
        self.assertEqual(2, len(storage2.items()))
        self.assertTrue('name' in storage2.keys())
        self.assertTrue('answer' in storage2.keys())
        self.assertEqual('jon', storage2.pop('name'))
        self.assertEqual('42', storage2['answer'])

        remove(filename)


class TestTimedStorage(TestCase):

    def test_pickle(self):
        filename = '/tmp/testdict.pickle'
        remove(filename)
        storage = TimedStorage(filename, file_format='pickle', TTL=timedelta(hours=1))
        storage['name'] = 'jon'
        storage.update({'answer': 42})
        storage.close()

        # Reopen
        storage2 = TimedStorage(filename, file_format='pickle', TTL=timedelta(hours=1))
        self.assertEqual(sorted(storage.items()), sorted(storage2.items()))

        # Reopen again but with a one second TTL which will be expired
        time.sleep(2)
        storage3 = TimedStorage(filename, file_format='pickle', TTL=timedelta(seconds=1))
        self.assertEqual([], sorted(storage3.items()))
        storage3.close()

        # Ensure the expired dict was synced
        storage4 = TimedStorage(filename, file_format='pickle', TTL=timedelta(hours=1))
        self.assertEqual(sorted(storage3.items()), sorted(storage4.items()))


class Test_Storage(TestCase):

    def test_clear(self):
        filename = '/tmp/testclear.json'
        storage = _Storage(filename, file_format='json')
        storage['name'] = 'jon'
        storage.sync()

        # dict with single value is now saved to disk
        with open(filename) as inp:
            self.assertEqual(inp.read(), '{"name":"jon"}')

        # now clear the dict, it should sync to disk.
        storage.clear()
        with open(filename) as inp:
            self.assertEqual(inp.read(), '{}')

########NEW FILE########
__FILENAME__ = test_urls
import unittest
from xbmcswift2 import UrlRule


class TestUrls(unittest.TestCase):

    def test_make_path_qs(self):
        def view(video_id):
            pass

        rule = UrlRule('/videos/<video_id>', view, view.__name__, {})

        path_qs = rule.make_path_qs({'video_id': '24'})
        self.assertEqual(path_qs, '/videos/24')

        # allow ints
        path_qs = rule.make_path_qs({'video_id': 24})
        self.assertEqual(path_qs, '/videos/24')

    def test_make_qs(self):
        def view(video_id):
            pass

        rule = UrlRule('/videos', view, view.__name__, {})

        path_qs = rule.make_path_qs({'video_id': '24'})
        self.assertEqual(path_qs, '/videos?video_id=24')

        # allow ints
        path_qs = rule.make_path_qs({'video_id': 24})
        self.assertEqual(path_qs, '/videos?video_id=24')

class TestUrlRule(unittest.TestCase):

    def test_match_without_trailing_slash(self):
        def view():
            pass
        rule = UrlRule('/videos/', view, view.__name__, {})
        self.assertEqual((view, {}), rule.match('/videos'))

    def test_match_with_trailing_slash(self):
        def view():
            pass
        rule = UrlRule('/videos', view, view.__name__, {})
        self.assertEqual((view, {}), rule.match('/videos/'))



########NEW FILE########
__FILENAME__ = test_xbmcmixin
import os
import tempfile
import xbmcswift2
from unittest import TestCase
from mock import Mock, patch, call
from nose.plugins.skip import SkipTest
from xbmcswift2.xbmcmixin import XBMCMixin
from xbmcswift2 import xbmc
from xbmcswift2.plugin import Plugin
from xbmcswift2.common import Modes
from xbmcswift2.listitem import ListItem
from xbmcswift2.mockxbmc.xbmcaddon import Addon
from xbmcswift2 import SortMethod


TEST_STRINGS_FN = os.path.join(os.path.dirname(__file__), 'data', 'strings.xml')


class TestMixedIn(XBMCMixin):
    storage_path = '/tmp/cache'
    if not os.path.isdir(storage_path):
       os.mkdir(storage_path)
    # TODO: use a mock with return values here
    #addon = Addon('plugin.video.helloxbmc')
    addon = Mock()
    added_items = []
    handle = 0
    _end_of_directory = False

class MixedIn(XBMCMixin):

    storage_path = '/tmp'

    def __init__(self, **kwargs):
        for attr_name, attr_value in kwargs.items():
            setattr(self, attr_name, attr_value)


class TestXBMCMixin(TestCase):

    def setUp(self):
        self.m = TestMixedIn()

    def test_temp_fn(self):
        # TODO: This test relies on hardcoded paths, fix to limit test coverage
        # TODO: This test relies on hardcoded paths which are not the same across different OS
        #self.assertEqual('/tmp/xbmcswift2_debug/temp/temp_file', self.m.temp_fn('temp_file'))
        raise SkipTest('Test not implemented.')

    def test_get_storage(self):
        cache = self.m.get_storage('animals')
        cache['dog'] = 'woof'
        cache.close()
        cache = self.m.get_storage('animals')
        self.assertEqual(cache['dog'], 'woof')

    def test_get_string(self):
        self.m.addon.getLocalizedString.return_value = 'Hello XBMC'
        self.assertEqual('Hello XBMC', self.m.get_string('30000'))
        # check if the string comes from cache
        self.m.addon.getLocalizedString.return_value = ''
        self.assertEqual('Hello XBMC', self.m.get_string('30000'))
        # check if retrieval by int and str returns same (and comes from cache)
        self.assertEqual('Hello XBMC', self.m.get_string(30000))

    @patch('xbmcswift2.xbmcplugin')
    def test_set_content(self, mock_xbmcplugin):
        self.m.set_content('movies')
        assert mock_xbmcplugin.setContent.called_with(0, 'movies')

    def test_get_setting(self):
        self.m.get_setting('username')
        assert self.m.addon.getSetting.called_with(id='username')
        # Test int
        self.m.addon.getSetting.return_value = '3'
        self.assertEqual(self.m.get_setting('int'), '3')
        self.assertEqual(self.m.get_setting('int', int), 3)
        # Test bool
        self.m.addon.getSetting.return_value = 'true'
        self.assertEqual(self.m.get_setting('bool'), 'true')
        self.assertEqual(self.m.get_setting('bool', bool), True)
        self.m.addon.getSetting.return_value = 'false'
        self.assertEqual(self.m.get_setting('bool'), 'false')
        self.assertEqual(self.m.get_setting('bool', bool), False)
        # Test unicode
        self.m.addon.getSetting.return_value = 'd\xc3\xb6ner'
        self.assertEqual(self.m.get_setting('unicode'), 'd\xc3\xb6ner')
        self.assertEqual(self.m.get_setting('unicode', unicode), u'd\xf6ner')
        # Test list
        self.m.addon.getSetting.return_value = '2'
        lst = ('1', 2, True, False)
        self.assertEqual(self.m.get_setting('list'), '2')
        self.assertEqual(self.m.get_setting('list', choices=lst), lst[2])

    def test_set_setting(self):
        self.m.set_setting('username', 'xbmc')
        assert self.m.addon.setSetting.called_with(id='username', value='xbmc')

    def test_open_settings(self):
        self.m.open_settings()
        assert self.m.addon.openSettings.called

    def test_set_resolved_url(self):
        url = 'http://www.example.com/video.mp4'
        ret = self.m.set_resolved_url(url)
        item = ret[0]
        self.assertIsInstance(item, xbmcswift2.ListItem)
        self.assertTrue(item.get_played())

    def test_set_resolved_url2(self):
        item = {'path': 'http://www.example.com/video.mp4'}
        ret = self.m.set_resolved_url(item=item)
        item = ret[0]
        self.assertIsInstance(item, xbmcswift2.ListItem)
        self.assertTrue(item.get_played())


    @patch.object(xbmc, 'Player')
    @patch('xbmcswift2.ListItem', wraps=xbmcswift2.ListItem)
    def test_play_video_dict(self, WrappedListItem, MockPlayer):
        plugin = MixedIn(storage_path=tempfile.mkdtemp(),
                         addon=Mock(),
                         added_items=[],
                         request=Mock(),
                         info_type='pictures',
                         handle=0,
                         )

        item = {'label': 'The Ultimate Showdown', 'path': 'http://example.com/video.mp4'}
        returned = plugin.play_video(item)
        returned_item = returned[0]
        self.assertTrue(returned_item.get_played())

        WrappedListItem.from_dict.assert_called_with(
            label='The Ultimate Showdown',
            info_type='video',
            path='http://example.com/video.mp4')
        self.assertTrue(MockPlayer().play.called)

        # Check that the second arg to play was an instance of xbmc listitem
        # and not xbmcswift2.ListItem
        item_arg = MockPlayer().play.call_args[0][1]
        self.assertTrue(isinstance(item_arg, xbmcswift2.xbmcgui.ListItem))

        # TODO: Implement ListItem.__eq__
        #MockPlayer().play.assert_called_with('http://example.com/video.mp4', ListItem.from_dict(**item))

    def test_play_video_listitem(self):
        pass

    def test_end_of_directory(self):
        raise SkipTest('Test not implemented.')

    @patch('xbmcswift2.xbmcplugin.addSortMethod')
    def test_add_sort_method(self, addSortMethod):
        plugin = TestMixedIn()

        known_values = [
            # can specify by string
            ( ('title', None), (0, 9) ),
            ( ('TiTLe', None), (0, 9) ),
            # can specify as an attr on the SortMethod class
            ( (SortMethod.TITLE, None), (0, 9) ),
            ( ('date', '%D'), (0, 3, '%D') ),
            # can specify with the actual int value
            ( (3, '%D'), (0, 3, '%D') ),
        ]

        for args, call_args_to_verify in known_values:
            plugin.add_sort_method(*args)
            addSortMethod.assert_called_with(*call_args_to_verify)

    @patch('xbmcswift2.xbmcplugin.addSortMethod')
    def test_finish(self, mockAddSortMethod):
        # TODO: Add more asserts to this test
        items = [
            {'label': 'Foo', 'path': 'http://example.com/foo'},
            {'label': 'Bar', 'path': 'http://example.com/bar'},
        ]
        plugin = TestMixedIn()
        resp = plugin.finish(items, sort_methods=['title', ('dAte', '%D'), 'label', 'mpaa_rating', SortMethod.SIZE])
        calls = [
            call(0, 9),
            call(0, 3, '%D'),
            call(0, 1),
            call(0, 28),
            call(0, 4),
        ]
        mockAddSortMethod.assert_has_calls(calls)


    @patch('xbmcswift2.xbmc.executebuiltin')
    def test_notify_defalt_name(self, mockExecutebuiltin):
        plugin = TestMixedIn()
        with patch.object(plugin.addon, 'getAddonInfo', return_value='Academic Earth') as mockGetAddonInfo:
            plugin.notify('Hello World!')
        mockExecutebuiltin.assert_called_with(
            'XBMC.Notification("Hello World!", "Academic Earth", "5000", "")'
        )

    @patch('xbmcswift2.xbmc.executebuiltin')
    def test_notify(self, mockExecutebuiltin):
        plugin = TestMixedIn()
        with patch.object(plugin.addon, 'getAddonInfo', return_value='Academic Earth') as mockGetAddonInfo:
            plugin.notify('Hello World!', 'My Title', 3000, 'http://example.com/image.png')
        mockExecutebuiltin.assert_called_with(
                'XBMC.Notification("Hello World!", "My Title", "3000", "http://example.com/image.png")'
        )

    @patch('xbmcswift2.xbmc.Keyboard')
    def test_keyboard(self, mockKeyboard):
        plugin = TestMixedIn()
        with patch.object(plugin.addon, 'getAddonInfo', return_value='Academic Earth') as mockGetAddonInfo:
            plugin.keyboard()
        mockKeyboard.assert_called_with('', 'Academic Earth', False)


    def test_clear_function_cache(self):
        plugin = MixedIn(storage_path=tempfile.mkdtemp(),
                         addon=Mock(),
                         added_items=[],
                         request=Mock(),
                         info_type='pictures',
                         handle=0,
                         )
        @plugin.cached()
        def echo(msg):
            return msg
        echo('hello')

        # cache should now contain 1 item
        storage = plugin.get_storage('.functions')
        self.assertEqual(len(storage.items()), 1)
        plugin.clear_function_cache()
        self.assertEqual(len(storage.items()), 0)


class TestAddItems(TestCase):

    @patch('xbmcswift2.ListItem.from_dict')
    @patch('xbmcswift2.xbmcplugin.addDirectoryItems')
    def test_add_items(self, addDirectoryItems, fromDict):
        plugin = MixedIn(storage_path=tempfile.mkdtemp(),
                         addon=Mock(),
                         added_items=[],
                         request=Mock(),
                         info_type='pictures',
                         handle=0,
                         )
        items = [
            {'label': 'Course 1', 'path': 'plugin.image.test/foo'},
            {'label': 'Course 2', 'path': 'plugin.image.test/bar'},
        ]
        returned = plugin.add_items(items)

        # TODO: Assert actual arguments passed to the addDirectoryItems call
        assert addDirectoryItems.called
        calls = [
            call(label='Course 1', path='plugin.image.test/foo', info_type='pictures'),
            call(label='Course 2', path='plugin.image.test/bar', info_type='pictures'),
        ]
        fromDict.assert_has_calls(calls)

        # TODO: Currently ListItems don't implement __eq__
        #list_items = [ListItem.from_dict(**item) for item in items]
        #self.assertEqual(returned, list_items)

    @patch('xbmcswift2.ListItem.from_dict')
    @patch('xbmcswift2.xbmcplugin.addDirectoryItems')
    def test_add_items_no_info_type(self, addDirectoryItems, fromDict):
        plugin = MixedIn(storage_path=tempfile.mkdtemp(),
                         addon=Mock(),
                         added_items=[],
                         request=Mock(),
                         handle=0,
                         )
        items = [
            {'label': 'Course 1', 'path': 'plugin.image.test/foo'}
        ]
        returned = plugin.add_items(items)

        # TODO: Assert actual arguments passed to the addDirectoryItems call
        assert addDirectoryItems.called
        calls = [
            call(label='Course 1', path='plugin.image.test/foo', info_type='video'),
        ]
        fromDict.assert_has_calls(calls)

        # TODO: Currently ListItems don't implement __eq__
        #list_items = [ListItem.from_dict(**item) for item in items]
        #self.assertEqual(returned, list_items)

    @patch('xbmcswift2.ListItem.from_dict')
    @patch('xbmcswift2.xbmcplugin.addDirectoryItems')
    def test_add_items_item_specific_info_type(self, addDirectoryItems, fromDict):
        plugin = MixedIn(storage_path=tempfile.mkdtemp(),
                         addon=Mock(),
                         added_items=[],
                         request=Mock(),
                         handle=0,
                         info_type='pictures',
                         )
        items = [
            {'label': 'Course 1', 'path': 'plugin.image.test/foo', 'info_type': 'music'}
        ]
        returned = plugin.add_items(items)

        # TODO: Assert actual arguments passed to the addDirectoryItems call
        assert addDirectoryItems.called
        calls = [
            call(label='Course 1', path='plugin.image.test/foo', info_type='music'),
        ]
        fromDict.assert_has_calls(calls)

        # TODO: Currently ListItems don't implement __eq__
        #list_items = [ListItem.from_dict(**item) for item in items]
        #self.assertEqual(returned, list_items)



class TestAddToPlaylist(TestCase):
    @patch('xbmcswift2.xbmc.Playlist')
    def setUp(self, mock_Playlist):
        self.m = TestMixedIn()

        # Mock some things so we can verify what was called
        mock_playlist = Mock()
        mock_Playlist.return_value = mock_playlist
        self.mock_Playlist = mock_Playlist
        self.mock_playlist = mock_playlist

    def test_args(self):
        # Verify playlists
        self.assertRaises(AssertionError, self.m.add_to_playlist, [], 'invalid_playlist')

        # Verify video and music work
        self.m.add_to_playlist([])
        self.m.add_to_playlist([], 'video')
        self.m.add_to_playlist([], 'music')

    @patch('xbmcswift2.ListItem', wraps=ListItem)
    def test_return_values(self, MockListItem):
        # Verify dicts are transformed into listitems
        dict_items = [
            {'label': 'Grape Stomp'},
            {'label': 'Boom Goes the Dynamite'},
        ]
        items = self.m.add_to_playlist(dict_items)

        # Verify from_dict was called properly, defaults to info_type=video
        calls = [
            call(label='Grape Stomp', info_type='video'),
            call(label='Boom Goes the Dynamite', info_type='video'),
        ]
        self.assertEqual(MockListItem.from_dict.call_args_list, calls)


        ## Verify with playlist=music
        MockListItem.from_dict.reset_mock()

        dict_items = [
            {'label': 'Grape Stomp'},
            {'label': 'Boom Goes the Dynamite'},
        ]
        items = self.m.add_to_playlist(dict_items, 'music')

        # Verify from_dict was called properly, defaults to info_type=video
        calls = [
            call(label='Grape Stomp', info_type='music'),
            call(label='Boom Goes the Dynamite', info_type='music'),
        ]
        self.assertEqual(MockListItem.from_dict.call_args_list, calls)

        ## Verify an item's info_dict key is not used
        MockListItem.from_dict.reset_mock()

        dict_items = [
            {'label': 'Grape Stomp', 'info_type': 'music'},
            {'label': 'Boom Goes the Dynamite', 'info_type': 'music'},
        ]
        items = self.m.add_to_playlist(dict_items, 'video')

        # Verify from_dict was called properly, defaults to info_type=video
        calls = [
            call(label='Grape Stomp', info_type='video'),
            call(label='Boom Goes the Dynamite', info_type='video'),
        ]
        self.assertEqual(MockListItem.from_dict.call_args_list, calls)

        # verify ListItems were created correctly
        for item, returned_item in zip(dict_items, items):
            assert isinstance(returned_item, ListItem)
            self.assertEqual(item['label'], returned_item.get_label())

        # Verify listitems are unchanged
        MockListItem.from_dict.reset_mock()

        listitems = [
            ListItem('Grape Stomp'),
            ListItem('Boom Goes the Dyanmite'),
        ]
        items = self.m.add_to_playlist(listitems)

        self.assertFalse(MockListItem.from_dict.called)
        for item, returned_item in zip(listitems, items):
            self.assertEqual(item, returned_item)

        # Verify mixed lists
        # Verify listitems are unchange
        listitems = [
            ListItem('Grape Stomp'),
            {'label': 'Boom Goes the Dynamite'},
        ]
        items = self.m.add_to_playlist(listitems)
        for item, returned_item in zip(listitems, items):
            assert isinstance(returned_item, ListItem)


    def test_added_to_playlist(self):
        # TODO: not working... check mocks
        listitems = [
            ListItem('Grape Stomp'),
            ListItem('Boom Goes the Dyanmite'),
        ]
        items = self.m.add_to_playlist(listitems)
        print items
        print self.mock_playlist.add.call_args_list
        for item, call_args in zip(items, self.mock_playlist.add.call_args_list):
            self.assertEqual((item.get_path(), item.as_xbmc_listitem(), 0), call_args)

    @patch('xbmcswift2.xbmcmixin.xbmc')
    def test_get_view_mode_id(self, _xbmc):
        _xbmc.getSkinDir.return_value = 'skin.confluence'
        self.assertEqual(self.m.get_view_mode_id('thumbnail'), 500)
        self.assertEqual(self.m.get_view_mode_id('THUMBNail'), 500)
        self.assertEqual(self.m.get_view_mode_id('unknown'), None)
        _xbmc.getSkinDir.return_value = 'skin.unknown'
        self.assertEqual(self.m.get_view_mode_id('thumbnail'), None)
        self.assertEqual(self.m.get_view_mode_id('unknown'), None)

    @patch('xbmcswift2.xbmcmixin.xbmc')
    def test_set_view_mode(self, _xbmc):
        self.m.set_view_mode(500)
        _xbmc.executebuiltin.assertCalledWith('Container.SetViewMode(500)')

########NEW FILE########
__FILENAME__ = utils
import os
from contextlib import contextmanager
import xbmcswift2


@contextmanager
def preserve_cwd(cwd):
    existing = os.getcwd()
    os.chdir(cwd)
    yield
    os.chdir(existing)


@contextmanager
def preserve_cli_mode(cli_mode):
    existing = xbmcswift2.CLI_MODE
    xbmcswift2.CLI_MODE = cli_mode
    yield
    xbmcswift2.CLI_MODE = existing

########NEW FILE########
__FILENAME__ = actions
'''
    xbmcswift2.actions
    ------------------

    This module contains wrapper functions for XBMC built-in functions.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''


def background(url):
    '''This action will run an addon in the background for the provided URL.

    See 'XBMC.RunPlugin()' at
    http://wiki.xbmc.org/index.php?title=List_of_built-in_functions.
    '''
    return 'XBMC.RunPlugin(%s)' % url


def update_view(url):
    '''This action will update the current container view with provided url.

    See 'XBMC.Container.Update()' at
    http://wiki.xbmc.org/index.php?title=List_of_built-in_functions.
    '''
    return 'XBMC.Container.Update(%s)' % url

########NEW FILE########
__FILENAME__ = app
'''
    xbmcswift2.cli.app
    ----------------

    This package contains the code which runs plugins from the command line.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import os
import sys
import logging
from xml.etree import ElementTree as ET

from xbmcswift2 import Plugin, ListItem, logger
from xbmcswift2.common import Modes
from xbmcswift2.cli import Option
from xbmcswift2.cli.console import (display_listitems, continue_or_quit,
    get_user_choice)


class RunCommand(object):
    '''A CLI command to run a plugin.'''

    command = 'run'
    usage = ('%prog run [once|interactive|crawl] [url]')
    option_list = (
        Option('-q', '--quiet', action='store_true',
               help='set logging level to quiet'),
        Option('-v', '--verbose', action='store_true',
               help='set logging level to verbose'),
    )

    @staticmethod
    def run(opts, args):
        '''The run method for the 'run' command. Executes a plugin from the
        command line.
        '''
        setup_options(opts)

        mode = Modes.ONCE
        if len(args) > 0 and hasattr(Modes, args[0].upper()):
            _mode = args.pop(0).upper()
            mode = getattr(Modes, _mode)

        url = None
        if len(args) > 0:
            # A url was specified
            url = args.pop(0)

        plugin_mgr = PluginManager.load_plugin_from_addonxml(mode, url)
        plugin_mgr.run()


def setup_options(opts):
    '''Takes any actions necessary based on command line options'''
    if opts.quiet:
        logger.log.setLevel(logging.WARNING)
        logger.GLOBAL_LOG_LEVEL = logging.WARNING

    if opts.verbose:
        logger.log.setLevel(logging.DEBUG)
        logger.GLOBAL_LOG_LEVEL = logging.DEBUG


def get_addon_module_name(addonxml_filename):
    '''Attempts to extract a module name for the given addon's addon.xml file.
    Looks for the 'xbmc.python.pluginsource' extension node and returns the
    addon's filename without the .py suffix.
    '''
    try:
        xml = ET.parse(addonxml_filename).getroot()
    except IOError:
        sys.exit('Cannot find an addon.xml file in the current working '
                 'directory. Please run this command from the root directory '
                 'of an addon.')

    try:
        plugin_source = (ext for ext in xml.findall('extension') if
                         ext.get('point') == 'xbmc.python.pluginsource').next()
    except StopIteration:
        sys.exit('ERROR, no pluginsource in addonxml')

    return plugin_source.get('library').split('.')[0]


class PluginManager(object):
    '''A class to handle running a plugin in CLI mode. Handles setup state
    before calling plugin.run().
    '''

    @classmethod
    def load_plugin_from_addonxml(cls, mode, url):
        '''Attempts to import a plugin's source code and find an instance of
        :class:`~xbmcswif2.Plugin`. Returns an instance of PluginManager if
        succesful.
        '''
        cwd = os.getcwd()
        sys.path.insert(0, cwd)
        module_name = get_addon_module_name(os.path.join(cwd, 'addon.xml'))
        addon = __import__(module_name)

        # Find the first instance of xbmcswift2.Plugin
        try:
            plugin = (attr_value for attr_value in vars(addon).values()
                      if isinstance(attr_value, Plugin)).next()
        except StopIteration:
            sys.exit('Could\'t find a Plugin instance in %s.py' % module_name)

        return cls(plugin, mode, url)

    def __init__(self, plugin, mode, url):
        self.plugin = plugin
        self.mode = mode
        self.url = url

    def run(self):
        '''This method runs the the plugin in the appropriate mode parsed from
        the command line options.
        '''
        handle = 0
        handlers = {
           Modes.ONCE: once,
           Modes.CRAWL: crawl,
           Modes.INTERACTIVE: interactive,
        }
        handler = handlers[self.mode]
        patch_sysargv(self.url or 'plugin://%s/' % self.plugin.id, handle)
        return handler(self.plugin)


def patch_sysargv(*args):
    '''Patches sys.argv with the provided args'''
    sys.argv = args[:]


def patch_plugin(plugin, path, handle=None):
    '''Patches a few attributes of a plugin instance to enable a new call to
    plugin.run()
    '''
    if handle is None:
        handle = plugin.request.handle
    patch_sysargv(path, handle)
    plugin._end_of_directory = False


def once(plugin, parent_stack=None):
    '''A run mode for the CLI that runs the plugin once and exits.'''
    plugin.clear_added_items()
    items = plugin.run()

    # if update_listing=True, we need to remove the last url from the parent
    # stack
    if parent_stack and plugin._update_listing:
        del parent_stack[-1]

    # if we have parent items, include the most recent in the display
    if parent_stack:
        items.insert(0, parent_stack[-1])

    display_listitems(items, plugin.request.url)
    return items


def interactive(plugin):
    '''A run mode for the CLI that runs the plugin in a loop based on user
    input.
    '''
    items = [item for item in once(plugin) if not item.get_played()]
    parent_stack = []  # Keep track of parents so we can have a '..' option

    selected_item = get_user_choice(items)
    while selected_item is not None:
        if parent_stack and selected_item == parent_stack[-1]:
            # User selected the parent item, remove from list
            parent_stack.pop()
        else:
            # User selected non parent item, add current url to parent stack
            parent_stack.append(ListItem.from_dict(label='..',
                                                   path=plugin.request.url))
        patch_plugin(plugin, selected_item.get_path())

        items = [item for item in once(plugin, parent_stack=parent_stack)
                 if not item.get_played()]
        selected_item = get_user_choice(items)


def crawl(plugin):
    '''Performs a breadth-first crawl of all possible routes from the
    starting path. Will only visit a URL once, even if it is referenced
    multiple times in a plugin. Requires user interaction in between each
    fetch.
    '''
    # TODO: use OrderedSet?
    paths_visited = set()
    paths_to_visit = set(item.get_path() for item in once(plugin))

    while paths_to_visit and continue_or_quit():
        path = paths_to_visit.pop()
        paths_visited.add(path)

        # Run the new listitem
        patch_plugin(plugin, path)
        new_paths = set(item.get_path() for item in once(plugin))

        # Filter new items by checking against urls_visited and
        # urls_tovisit
        paths_to_visit.update(path for path in new_paths
                              if path not in paths_visited)

########NEW FILE########
__FILENAME__ = cli
'''
    xbmcswift2.cli.cli
    ------------------

    The main entry point for the xbmcswift2 console script. CLI commands can be
    registered in this module.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import sys
from optparse import OptionParser

from xbmcswift2.cli.app import RunCommand
from xbmcswift2.cli.create import CreateCommand


# TODO: Make an ABC for Command
COMMANDS = {
    RunCommand.command: RunCommand,
    CreateCommand.command: CreateCommand,
}


# TODO: Make this usage dynamic based on COMMANDS dict
USAGE = '''%prog <command>

Commands:
    create
        Create a new plugin project.

    run
        Run an xbmcswift2 plugin from the command line.

Help:
    To see options for a command, run `xbmcswift2 <command> -h`
'''


def main():
    '''The entry point for the console script xbmcswift2.

    The 'xbcmswift2' script is command bassed, so the second argument is always
    the command to execute. Each command has its own parser options and usages.
    If no command is provided or the -h flag is used without any other
    commands, the general help message is shown.
    '''
    parser = OptionParser()
    if len(sys.argv) == 1:
        parser.set_usage(USAGE)
        parser.error('At least one command is required.')

    # spy sys.argv[1] in order to use correct opts/args
    command = sys.argv[1]

    if command == '-h':
        parser.set_usage(USAGE)
        opts, args = parser.parse_args()

    if command not in COMMANDS.keys():
        parser.error('Invalid command')

    # We have a proper command, set the usage and options list according to the
    # specific command
    manager = COMMANDS[command]
    if hasattr(manager, 'option_list'):
        for args, kwargs in manager.option_list:
            parser.add_option(*args, **kwargs)
    if hasattr(manager, 'usage'):
        parser.set_usage(manager.usage)

    opts, args = parser.parse_args()

    # Since we are calling a specific comamnd's manager, we no longer need the
    # actual command in sys.argv so we slice from position 1
    manager.run(opts, args[1:])

########NEW FILE########
__FILENAME__ = console
'''
    xbmcswift2.cli.console
    ----------------------

    This module contains code to handle CLI interaction.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''


def get_max_len(items):
    '''Returns the max of the lengths for the provided items'''
    try:
        return max(len(item) for item in items)
    except ValueError:
        return 0


def display_listitems(items, url):
    '''Displays a list of items along with the index to enable a user
    to select an item.
    '''
    if (len(items) == 2 and items[0].get_label() == '..'
        and items[1].get_played()):
        display_video(items)
    else:
        label_width = get_max_len(item.get_label() for item in items)
        num_width = len(str(len(items)))
        output = []
        for i, item in enumerate(items):
            output.append('[%s] %s (%s)' % (
                str(i).rjust(num_width),
                item.get_label().ljust(label_width),
                item.get_path()))

        line_width = get_max_len(output)
        output.append('-' * line_width)

        header = [
            '',
            '=' * line_width,
            'Current URL: %s' % url,
            '-' * line_width,
            '%s %s Path' % ('#'.center(num_width + 2),
                            'Label'.ljust(label_width)),
            '-' * line_width,
        ]
        print '\n'.join(header + output)


def display_video(items):
    '''Prints a message for a playing video and displays the parent
    listitem.
    '''
    parent_item, played_item = items

    title_line = 'Playing Media %s (%s)' % (played_item.get_label(),
                                            played_item.get_path())
    parent_line = '[0] %s (%s)' % (parent_item.get_label(),
                                   parent_item.get_path())
    line_width = get_max_len([title_line, parent_line])

    output = [
        '-' * line_width,
        title_line,
        '-' * line_width,
        parent_line,
    ]
    print '\n'.join(output)


def get_user_choice(items):
    '''Returns the selected item from provided items or None if 'q' was
    entered for quit.
    '''
    choice = raw_input('Choose an item or "q" to quit: ')
    while choice != 'q':
        try:
            item = items[int(choice)]
            print  # Blank line for readability between interactive views
            return item
        except ValueError:
            # Passed something that cound't be converted with int()
            choice = raw_input('You entered a non-integer. Choice must be an'
                               ' integer or "q": ')
        except IndexError:
            # Passed an integer that was out of range of the list of urls
            choice = raw_input('You entered an invalid integer. Choice must be'
                               ' from above url list or "q": ')
    return None


def continue_or_quit():
    '''Prints an exit message and returns False if the user wants to
    quit.
    '''
    return raw_input('Enter to continue or "q" to quit') != 'q'

########NEW FILE########
__FILENAME__ = create
'''
    xbmcswift2.cli.create
    ---------------------

    This module contains the code to initialize a new XBMC addon project.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import os
import string
import readline
from os import getcwd
from xml.sax import saxutils
from optparse import OptionParser
from shutil import copytree, ignore_patterns
from getpass import getpass


class CreateCommand(object):
    '''A CLI command to initialize a new XBMC addon project.'''

    command = 'create'
    usage = '%prog create'

    @staticmethod
    def run(opts, args):
        '''Required run function for the 'create' CLI command.'''
        create_new_project()


# Path to skeleton file templates dir
SKEL = os.path.join(os.path.dirname(__file__), 'data')


def error_msg(msg):
    '''A decorator that sets the error_message attribute of the decorated
    function to the provided value.
    '''
    def decorator(func):
        '''Sets the error_message attribute on the provided function'''
        func.error_message = msg
        return func
    return decorator


def parse_cli():
    '''Currently only one positional arg, create.'''
    parser = OptionParser()
    return parser.parse_args()


@error_msg('** Value must be non-blank.')
def validate_nonblank(value):
    '''A callable that retunrs the value passed'''
    return value


@error_msg('** Value must contain only letters or underscores.')
def validate_pluginid(value):
    '''Returns True if the provided value is a valid pluglin id'''
    valid = string.ascii_letters + string.digits + '.'
    return all(c in valid for c in value)


@error_msg('** The provided path must be an existing folder.')
def validate_isfolder(value):
    '''Returns true if the provided path is an existing directory'''
    return os.path.isdir(value)


def get_valid_value(prompt, validator, default=None):
    '''Displays the provided prompt and gets input from the user. This behavior
    loops indefinitely until the provided validator returns True for the user
    input. If a default value is provided, it will be used only if the user
    hits Enter and does not provide a value.

    If the validator callable has an error_message attribute, it will be
    displayed for an invalid value, otherwise a generic message is used.
    '''
    ans = get_value(prompt, default)
    while not validator(ans):
        try:
            print validator.error_message
        except AttributeError:
            print 'Invalid value.'
        ans = get_value(prompt, default)

    return ans


def get_value(prompt, default=None, hidden=False):
    '''Displays the provided prompt and returns the input from the user. If the
    user hits Enter and there is a default value provided, the default is
    returned.
    '''
    _prompt = '%s : ' % prompt
    if default:
        _prompt = '%s [%s]: ' % (prompt, default)

    if hidden:
        ans = getpass(_prompt)
    else:
        ans = raw_input(_prompt)

    # If user hit Enter and there is a default value
    if not ans and default:
        ans = default
    return ans


def update_file(filename, items):
    '''Edits the given file in place, replacing any instances of {key} with the
    appropriate value from the provided items dict. If the given filename ends
    with ".xml" values will be quoted and escaped for XML.
    '''
    # TODO: Implement something in the templates to denote whether the value
    # being replaced is an XML attribute or a value. Perhaps move to dyanmic
    # XML tree building rather than string replacement.
    should_escape = filename.endswith('addon.xml')

    with open(filename, 'r') as inp:
        text = inp.read()

    for key, val in items.items():
        if should_escape:
            val = saxutils.quoteattr(val)
        text = text.replace('{%s}' % key, val)
    output = text

    with open(filename, 'w') as out:
        out.write(output)


def create_new_project():
    '''Creates a new XBMC Addon directory based on user input'''
    readline.parse_and_bind('tab: complete')

    print \
'''
    xbmcswift2 - A micro-framework for creating XBMC plugins.
    xbmc@jonathanbeluch.com
    --
'''
    print 'I\'m going to ask you a few questions to get this project' \
        ' started.'

    opts = {}

    # Plugin Name
    opts['plugin_name'] = get_valid_value(
        'What is your plugin name?',
        validate_nonblank
    )

    # Plugin ID
    opts['plugin_id'] = get_valid_value(
        'Enter your plugin id.',
        validate_pluginid,
        'plugin.video.%s' % (opts['plugin_name'].lower().replace(' ', ''))
    )

    # Parent Directory
    opts['parent_dir'] = get_valid_value(
        'Enter parent folder (where to create project)',
        validate_isfolder,
        getcwd()
    )
    opts['plugin_dir'] = os.path.join(opts['parent_dir'], opts['plugin_id'])
    assert not os.path.isdir(opts['plugin_dir']), \
        'A folder named %s already exists in %s.' % (opts['plugin_id'],
                                                     opts['parent_dir'])

    # Provider
    opts['provider_name'] = get_valid_value(
        'Enter provider name',
        validate_nonblank,
    )

    # Create the project folder by copying over skel
    copytree(SKEL, opts['plugin_dir'], ignore=ignore_patterns('*.pyc'))

    # Walk through all the new files and fill in with out options
    for root, dirs, files in os.walk(opts['plugin_dir']):
        for filename in files:
            update_file(os.path.join(root, filename), opts)

    print 'Projects successfully created in %s.' % opts['plugin_dir']
    print 'Done.'

########NEW FILE########
__FILENAME__ = addon
from xbmcswift2 import Plugin


plugin = Plugin()


@plugin.route('/')
def index():
    item = {
        'label': 'Hello XBMC!',
        'path': 'http://s3.amazonaws.com/KA-youtube-converted/JwO_25S_eWE.mp4/JwO_25S_eWE.mp4',
        'is_playable': True
    }
    return [item]


if __name__ == '__main__':
    plugin.run()

########NEW FILE########
__FILENAME__ = common
'''
    xbmcswift2.common
    -----------------

    This module contains some common helpful functions.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import urllib
import urllib2
try:
    import cPickle as pickle
except ImportError:
    import pickle


def xbmc_url(url, **options):
    '''Appends key/val pairs to the end of a URL. Useful for passing arbitrary
    HTTP headers to XBMC to be used when fetching a media resource, e.g.
    cookies.
    '''
    optionstring = urllib.urlencode(options)
    if optionstring:
        return url + '|' + optionstring
    return url


def enum(*args, **kwargs):
    '''An enum class to mirror XBMC constatns. All args and kwargs.keys are
    added as atrrs on the returned object.

    >>> States = enum('NEW_JERSEY', NY='NEW_YORK')
    >>> States.NY
    'NEW_YORK'
    >>> States.NEW_JERSEY
    'NEW_JERSEY'
    >>> States._fields
    ['NY', 'NEW_JERSEY']
    '''
    kwargs.update((arg, arg) for arg in args)
    kwargs['_fields'] = kwargs.keys()
    return type('Enum', (), kwargs)


Modes = enum('XBMC', 'ONCE', 'CRAWL', 'INTERACTIVE')
DEBUG_MODES = [Modes.ONCE, Modes.CRAWL, Modes.INTERACTIVE]


def clean_dict(dct):
    '''Returns a dict where items with a None value are removed'''
    return dict((key, val) for key, val in dct.items() if val is not None)


def pickle_dict(items):
    '''Returns a new dictionary where values which aren't instances of
    basestring are pickled. Also, a new key '_pickled' contains a comma
    separated list of keys corresponding to the pickled values.
    '''
    ret = {}
    pickled_keys = []
    for key, val in items.items():
        if isinstance(val, basestring):
            ret[key] = val
        else:
            pickled_keys.append(key)
            ret[key] = pickle.dumps(val)
    if pickled_keys:
        ret['_pickled'] = ','.join(pickled_keys)
    return ret


def unpickle_args(items):
    '''Takes a dict and unpickles values whose keys are found in
    '_pickled' key.

    >>> unpickle_args({'_pickled': ['foo']. 'foo': ['I3%0A.']})
    {'foo': 3}
    '''
    # Technically there can be more than one _pickled value. At this point
    # we'll just use the first one
    pickled= items.pop('_pickled', None)
    if pickled is None:
        return items

    pickled_keys = pickled[0].split(',')
    ret = {}
    for key, vals in items.items():
        if key in pickled_keys:
            ret[key] = [pickle.loads(val) for val in vals]
        else:
            ret[key] = vals
    return ret

def unpickle_dict(items):
    '''Returns a dict pickled with pickle_dict'''
    pickled_keys = items.pop('_pickled', '').split(',')
    ret = {}
    for key, val in items.items():
        if key in pickled_keys:
            ret[key] = pickle.loads(val)
        else:
            ret[key] = val
    return ret


def download_page(url, data=None):
    '''Returns the response for the given url. The optional data argument is
    passed directly to urlopen.'''
    conn = urllib2.urlopen(url, data)
    resp = conn.read()
    conn.close()
    return resp


_hextochr = dict(('%02x' % i, chr(i)) for i in range(256))
_hextochr.update(('%02X' % i, chr(i)) for i in range(256))


def unhex(inp):
    '''unquote(r'abc\x20def') -> 'abc def'.'''
    res = inp.split(r'\x')
    for i in xrange(1, len(res)):
        item = res[i]
        try:
            res[i] = _hextochr[item[:2]] + item[2:]
        except KeyError:
            res[i] = '%' + item
        except UnicodeDecodeError:
            res[i] = unichr(int(item[:2], 16)) + item[2:]
    return ''.join(res)

########NEW FILE########
__FILENAME__ = constants
'''
    xbmcswift2.constants
    --------------------

    This module contains some helpful constants which ease interaction
    with XBMC.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
from xbmcswift2 import xbmcplugin


class SortMethod(object):
    '''Static class to hold all of the available sort methods. The
    sort methods are dynamically imported from xbmcplugin and added as 
    attributes on this class. The prefix of 'SORT_METHOD_' is
    automatically stripped.

    e.g. SORT_METHOD_TITLE becomes SortMethod.TITLE
    '''

    @classmethod
    def from_string(cls, sort_method):
        '''Returns the sort method specified. sort_method is case insensitive.
        Will raise an AttributeError if the provided sort_method does not
        exist.

        >>> SortMethod.from_string('title')
        '''
        return getattr(cls, sort_method.upper())


PREFIX = 'SORT_METHOD_'
for attr_name, attr_value in xbmcplugin.__dict__.items():
    if attr_name.startswith(PREFIX):
        setattr(SortMethod, attr_name[len(PREFIX):], attr_value)


# View mode ids pulled from skins
VIEW_MODES = {
    'thumbnail': {
        'skin.confluence': 500,
        'skin.aeon.nox': 551,
        'skin.confluence-vertical': 500,
        'skin.jx720': 52,
        'skin.pm3-hd': 53,
        'skin.rapier': 50,
        'skin.simplicity': 500,
        'skin.slik': 53,
        'skin.touched': 500,
        'skin.transparency': 53,
        'skin.xeebo': 55,
    },
}

########NEW FILE########
__FILENAME__ = playlist
from xbmcswift import Module

playlist = Module(__name__)

@playlist.route('/add/')
def add_to_playlist():
    items = [playlist.qs_args]
    return playlist._plugin.add_to_playlist(items)

########NEW FILE########
__FILENAME__ = listitem
'''
    xbmcswift2.listitem
    ------------------

    This module contains the ListItem class, which acts as a wrapper
    for xbmcgui.ListItem.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
from xbmcswift2 import xbmcgui


class ListItem(object):
    '''A wrapper for the xbmcgui.ListItem class. The class keeps track
    of any set properties that xbmcgui doesn't expose getters for.
    '''
    def __init__(self, label=None, label2=None, icon=None, thumbnail=None,
                 path=None):
        '''Defaults are an emtpy string since xbmcgui.ListItem will not
        accept None.
        '''
        kwargs = {
            'label': label,
            'label2': label2,
            'iconImage': icon,
            'thumbnailImage': thumbnail,
            'path': path,
        }
        #kwargs = dict((key, val) for key, val in locals().items() if val is
        #not None and key != 'self')
        kwargs = dict((key, val) for key, val in kwargs.items()
                      if val is not None)
        self._listitem = xbmcgui.ListItem(**kwargs)

        # xbmc doesn't make getters available for these properties so we'll
        # keep track on our own
        self._icon = icon
        self._path = path
        self._thumbnail = thumbnail
        self._context_menu_items = []
        self.is_folder = True
        self._played = False

    def __repr__(self):
        return ("<ListItem '%s'>" % self.label).encode('utf-8')

    def __str__(self):
        return ('%s (%s)' % (self.label, self.path)).encode('utf-8')

    def get_context_menu_items(self):
        '''Returns the list of currently set context_menu items.'''
        return self._context_menu_items

    def add_context_menu_items(self, items, replace_items=False):
        '''Adds context menu items. If replace_items is True all
        previous context menu items will be removed.
        '''
        for label, action in items:
            assert isinstance(label, basestring)
            assert isinstance(action, basestring)
        if replace_items:
            self._context_menu_items = []
        self._context_menu_items.extend(items)
        self._listitem.addContextMenuItems(items, replace_items)

    def get_label(self):
        '''Sets the listitem's label'''
        return self._listitem.getLabel()

    def set_label(self, label):
        '''Returns the listitem's label'''
        return self._listitem.setLabel(label)

    label = property(get_label, set_label)

    def get_label2(self):
        '''Returns the listitem's label2'''
        return self._listitem.getLabel2()

    def set_label2(self, label):
        '''Sets the listitem's label2'''
        return self._listitem.setLabel2(label)

    label2 = property(get_label2, set_label2)

    def is_selected(self):
        '''Returns True if the listitem is selected.'''
        return self._listitem.isSelected()

    def select(self, selected_status=True):
        '''Sets the listitems selected status to the provided value.
        Defaults to True.
        '''
        return self._listitem.select(selected_status)

    selected = property(is_selected, select)

    def set_info(self, type, info_labels):
        '''Sets the listitems info'''
        return self._listitem.setInfo(type, info_labels)

    def get_property(self, key):
        '''Returns the property associated with the given key'''
        return self._listitem.getProperty(key)

    def set_property(self, key, value):
        '''Sets a property for the given key and value'''
        return self._listitem.setProperty(key, value)

    def add_stream_info(self, stream_type, stream_values):
        '''Adds stream details'''
        return self._listitem.addStreamInfo(stream_type, stream_values)

    def get_icon(self):
        '''Returns the listitem's icon image'''
        return self._icon

    def set_icon(self, icon):
        '''Sets the listitem's icon image'''
        self._icon = icon
        return self._listitem.setIconImage(icon)

    icon = property(get_icon, set_icon)

    def get_thumbnail(self):
        '''Returns the listitem's thumbnail image'''
        return self._thumbnail

    def set_thumbnail(self, thumbnail):
        '''Sets the listitem's thumbnail image'''
        self._thumbnail = thumbnail
        return self._listitem.setThumbnailImage(thumbnail)

    thumbnail = property(get_thumbnail, set_thumbnail)

    def get_path(self):
        '''Returns the listitem's path'''
        return self._path

    def set_path(self, path):
        '''Sets the listitem's path'''
        self._path = path
        return self._listitem.setPath(path)

    path = property(get_path, set_path)

    def get_is_playable(self):
        '''Returns True if the listitem is playable, False if it is a
        directory
        '''
        return not self.is_folder

    def set_is_playable(self, is_playable):
        '''Sets the listitem's playable flag'''
        value = 'false'
        if is_playable:
            value = 'true'
        self.set_property('isPlayable', value)
        self.is_folder = not is_playable

    playable = property(get_is_playable, set_is_playable)

    def set_played(self, was_played):
        '''Sets the played status of the listitem. Used to
        differentiate between a resolved video versus a playable item.
        Has no effect on XBMC, it is strictly used for xbmcswift2.
        '''
        self._played = was_played

    def get_played(self):
        '''Returns True if the video was played.'''
        return self._played

    def as_tuple(self):
        '''Returns a tuple of list item properties:
            (path, the wrapped xbmcgui.ListItem, is_folder)
        '''
        return self.path, self._listitem, self.is_folder

    def as_xbmc_listitem(self):
        '''Returns the wrapped xbmcgui.ListItem'''
        return self._listitem

    @classmethod
    def from_dict(cls, label=None, label2=None, icon=None, thumbnail=None,
                  path=None, selected=None, info=None, properties=None,
                  context_menu=None, replace_context_menu=False,
                  is_playable=None, info_type='video', stream_info=None):
        '''A ListItem constructor for setting a lot of properties not
        available in the regular __init__ method. Useful to collect all
        the properties in a dict and then use the **dct to call this
        method.
        '''
        listitem = cls(label, label2, icon, thumbnail, path)

        if selected is not None:
            listitem.select(selected)

        if info:
            listitem.set_info(info_type, info)

        if is_playable:
            listitem.set_is_playable(True)

        if properties:
            # Need to support existing tuples, but prefer to have a dict for
            # properties.
            if hasattr(properties, 'items'):
                properties = properties.items()
            for key, val in properties:
                listitem.set_property(key, val)

        if stream_info:
            for stream_type, stream_values in stream_info.items():
                listitem.add_stream_info(stream_type, stream_values)

        if context_menu:
            listitem.add_context_menu_items(context_menu, replace_context_menu)

        return listitem

########NEW FILE########
__FILENAME__ = logger
'''
    xbmcswift2.log
    --------------

    This module contains the xbmcswift2 logger as well as a convenience
    method for creating new loggers.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import logging
from xbmcswift2 import CLI_MODE


# TODO: Add logging to a file as well when on CLI with lowest threshold
#       possible
#fh = logging.FileHandler('log_filename.txt')
#fh.setLevel(logging.DEBUG)
#fh.setFormatter(formatter)
#log.addHandler(fh)
# TODO: Allow a global flag to set logging level when dealing with XBMC
# TODO: Add -q and -v flags to CLI to quiet or enabel more verbose logging


class XBMCFilter(object):
    '''A logging filter that streams to STDOUT or to the xbmc log if
    running inside XBMC.
    '''
    python_to_xbmc = {
        'DEBUG': 'LOGDEBUG',
        'INFO': 'LOGNOTICE',
        'WARNING': 'LOGWARNING',
        'ERROR': 'LOGERROR',
        'CRITICAL': 'LOGSEVERE',
    }

    xbmc_levels = {
        'LOGDEBUG': 0,
        'LOGINFO': 1,
        'LOGNOTICE': 2,
        'LOGWARNING': 3,
        'LOGERROR': 4,
        'LOGSEVERE': 5,
        'LOGFATAL': 6,
        'LOGNONE': 7,
    }

    def __init__(self, prefix):
        self.prefix = prefix

    def filter(self, record):
        '''Returns True for all records if running in the CLI, else returns
        True.

        When running inside XBMC it calls the xbmc.log() method and prevents
        the message from being double printed to STDOUT.
        '''

        # When running in XBMC, any logged statements will be double printed
        # since we are calling xbmc.log() explicitly. Therefore we return False
        # so every log message is filtered out and not printed again.
        if CLI_MODE:
            return True
        else:
            # Must not be imported until here because of import order issues
            # when running in CLI
            from xbmcswift2 import xbmc
            xbmc_level = XBMCFilter.xbmc_levels.get(
                XBMCFilter.python_to_xbmc.get(record.levelname))
            xbmc.log('%s%s' % (self.prefix, record.getMessage()), xbmc_level)
            return False


if CLI_MODE:
    GLOBAL_LOG_LEVEL = logging.INFO
else:
    GLOBAL_LOG_LEVEL = logging.DEBUG


def setup_log(name):
    '''Returns a logging instance for the provided name. The returned
    object is an instance of logging.Logger. Logged messages will be
    printed to stderr when running in the CLI, or forwarded to XBMC's
    log when running in XBMC mode.
    '''
    _log = logging.getLogger(name)
    _log.setLevel(GLOBAL_LOG_LEVEL)
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
    handler.setFormatter(formatter)
    _log.addHandler(handler)
    _log.addFilter(XBMCFilter('[%s] ' % name))
    return _log


# The xbmcswift2 log
# Plugin writers should use plugin.log instead.
log = setup_log('xbmcswift2')

########NEW FILE########
__FILENAME__ = utils
from xml.dom.minidom import parse


def load_addon_strings(addon, filename):
    '''This is not an official XBMC method, it is here to faciliate
    mocking up the other methods when running outside of XBMC.'''
    def get_strings(fn):
        xml = parse(fn)
        strings = dict((tag.getAttribute('id'), tag.firstChild.data) for tag in xml.getElementsByTagName('string'))
        #strings = {}
        #for tag in xml.getElementsByTagName('string'):
            #strings[tag.getAttribute('id')] = tag.firstChild.data
        return strings
    addon._strings = get_strings(filename)


def get_addon_id(addonxml):
    '''Parses an addon id from the given addon.xml filename.'''
    xml = parse(addonxml)
    addon_node = xml.getElementsByTagName('addon')[0]
    return addon_node.getAttribute('id')


def get_addon_name(addonxml):
    '''Parses an addon name from the given addon.xml filename.'''
    xml = parse(addonxml)
    addon_node = xml.getElementsByTagName('addon')[0]
    return addon_node.getAttribute('name')

########NEW FILE########
__FILENAME__ = xbmc
import tempfile
import os, errno
from xbmcswift2 import log
from xbmcswift2.cli.create import get_value


TEMP_DIR = os.path.join(tempfile.gettempdir(), 'xbmcswift2_debug')
log.info('Using temp directory %s', TEMP_DIR)


def _create_dir(path):
    '''Creates necessary directories for the given path or does nothing
    if the directories already exist.
    '''
    try:
        os.makedirs(path)
    except OSError, exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise


def log(msg, level=0):
    levels = [
        'LOGDEBUG',
        'LOGINFO',
        'LOGNOTICE',
        'LOGWARNING',
        'LOGERROR',
        'LOGSEVERE',
        'LOGFATAL',
        'LOGNONE',
    ]
    #print '%s - %s' % (levels[level], msg)

def translatePath(path):
    '''Creates folders in the OS's temp directory. Doesn't touch any
    possible XBMC installation on the machine. Attempting to do as
    little work as possible to enable this function to work seamlessly.
    '''
    valid_dirs = ['xbmc', 'home', 'temp', 'masterprofile', 'profile',
        'subtitles', 'userdata', 'database', 'thumbnails', 'recordings',
        'screenshots', 'musicplaylists', 'videoplaylists', 'cdrips', 'skin',
    ]

    assert path.startswith('special://'), 'Not a valid special:// path.'
    parts = path.split('/')[2:]
    assert len(parts) > 1, 'Need at least a single root directory'
    assert parts[0] in valid_dirs, '%s is not a valid root dir.' % parts[0]

    # We don't want to swallow any potential IOErrors here, so only makedir for
    # the root dir, the user is responsible for making any further child dirs
    _create_dir(os.path.join(TEMP_DIR, parts[0]))

    return os.path.join(TEMP_DIR, *parts)

class Keyboard(object):
    def __init__(self, default='', heading='', hidden=False):
        self._heading = heading
        self._default = default
        self._hidden = hidden
        self._confirmed = False
        self._input = None
        
    def setDefault(self, default):
        self._default = default

    def setHeading(self, heading):
        self._heading = heading

    def setHiddenInput(self, hidden):
        self._hidden = hidden

    def doModal(self):
        self._confirmed = False
        try:
            self._input = get_value(self._heading, self._default, hidden=self._hidden)
            self._confirmed = True
        except (KeyboardInterrupt, EOFError):
            pass

    def isConfirmed(self):
        return self._confirmed

    def getText(self):
        return self._input

########NEW FILE########
__FILENAME__ = xbmcaddon
import os
from xbmcswift2.logger import log
from xbmcswift2.mockxbmc import utils


def _get_env_setting(name):
    return os.getenv('XBMCSWIFT2_%s' % name.upper())


class Addon(object):

    def __init__(self, id=None):
        # In CLI mode, xbmcswift2 must be run from the root of the addon
        # directory, so we can rely on getcwd() being correct.
        addonxml = os.path.join(os.getcwd(), 'addon.xml')
        self._info = {
            'id': id or utils.get_addon_id(addonxml),
            'name': utils.get_addon_name(addonxml),
        }
        self._strings = {}
        self._settings = {}

    def getAddonInfo(self, id):
        properties = ['author', 'changelog', 'description', 'disclaimer',
            'fanart', 'icon', 'id', 'name', 'path', 'profile', 'stars', 'summary',
            'type', 'version']
        assert id in properties, '%s is not a valid property.' % id
        return self._info.get(id, 'Unavailable')

    def getLocalizedString(self, id):
        key = str(id)
        assert key in self._strings, 'id not found in English/strings.xml.'
        return self._strings[key]

    def getSetting(self, id):
        log.warning('xbmcaddon.Addon.getSetting() has not been implemented in '
                    'CLI mode.')
        try:
            value = self._settings[id]
        except KeyError:
            # see if we have an env var
            value = _get_env_setting(id)
            if _get_env_setting(id) is None:
                value = raw_input('* Please enter a temporary value for %s: ' %
                                  id)
            self._settings[id] = value
        return value

    def setSetting(self, id, value):
        self._settings[id] = value

    def openSettings(self):
        pass

########NEW FILE########
__FILENAME__ = xbmcgui
class ListItem(object):
    def __init__(self, label=None, label2=None, iconImage=None, thumbnailImage=None, path=None):
        self.label = label
        self.label2 = label2
        self.iconImage = iconImage
        self.thumbnailImage = thumbnailImage
        self.path = path
        self.properties = {}
        self.stream_info = {}
        self.selected = False
        self.infolabels = {}

    def addContextMenuItems(self, items, replaceItems=False):
        self.context_menu_items = items
    
    def getLabel(self):
        return self.label

    def getLabel2(self):
        return self.label2

    def getProperty(self, key):
        return self.properties[key.lower()]

    def isSelected(self):
        return self.selected

    def select(self, selected):
        self.selected = selected

    def setIconImage(self, icon):
        self.iconImage = icon

    def setInfo(self, type, infoLabels):
        assert type in ['video', 'music', 'pictures']
        self.infolabels.update(infoLabels)

    def setLabel(self, label):
        self.label = label

    def setLabel2(self, label2):
        self.label2 = label2

    def setPath(self, path):
        self.path = path

    def setProperty(self, key, value):
        self.properties[key.lower()] = value

    def addStreamInfo(self, stream_type, stream_values):
        self.stream_info.update({stream_type: stream_values})

    def setThumbnailImage(self, thumb):
        self.thumbnailImage = thumb
        



########NEW FILE########
__FILENAME__ = xbmcplugin
SORT_METHOD_ALBUM = 13
SORT_METHOD_ALBUM_IGNORE_THE = 14
SORT_METHOD_ARTIST = 11
SORT_METHOD_ARTIST_IGNORE_THE = 12
SORT_METHOD_BITRATE = 38
SORT_METHOD_DATE = 3
SORT_METHOD_DRIVE_TYPE = 6
SORT_METHOD_DURATION = 8
SORT_METHOD_EPISODE = 22
SORT_METHOD_FILE = 5
SORT_METHOD_GENRE = 15
SORT_METHOD_LABEL = 1
SORT_METHOD_LABEL_IGNORE_THE = 2
SORT_METHOD_LISTENERS = 36
SORT_METHOD_MPAA_RATING = 28
SORT_METHOD_NONE = 0
SORT_METHOD_PLAYLIST_ORDER = 21
SORT_METHOD_PRODUCTIONCODE = 26
SORT_METHOD_PROGRAM_COUNT = 20
SORT_METHOD_SIZE = 4
SORT_METHOD_SONG_RATING = 27
SORT_METHOD_STUDIO = 30
SORT_METHOD_STUDIO_IGNORE_THE = 31
SORT_METHOD_TITLE = 9
SORT_METHOD_TITLE_IGNORE_THE = 10
SORT_METHOD_TRACKNUM = 7
SORT_METHOD_UNSORTED = 37
SORT_METHOD_VIDEO_RATING = 18
SORT_METHOD_VIDEO_RUNTIME = 29
SORT_METHOD_VIDEO_TITLE = 23
SORT_METHOD_VIDEO_YEAR = 17

########NEW FILE########
__FILENAME__ = xbmcvfs

########NEW FILE########
__FILENAME__ = module
'''
    xbmcswift2.module
    -----------------

    This module contains the Module Class.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
from xbmcmixin import XBMCMixin
from xbmcswift2 import setup_log


class Module(XBMCMixin):
    '''Modules are basically mini plugins except they don't have any
    functionality until they are registered with a Plugin.
    '''

    def __init__(self, namespace):
        # Get rid of package prefixes
        self._namespace = namespace.split('.')[-1]
        self._view_functions = {}
        self._routes = []
        self._register_funcs = []
        self._plugin = None
        self._url_prefix = None
        # TODO: Think of a better log name
        self._log = setup_log(namespace)

    # TODO: add setter for plugin during registration
    @property
    def plugin(self):
        '''Returns the plugin this module is registered to, or raises a
        RuntimeError if not registered.
        '''
        if self._plugin is None:
            # TODO: print called method in the error message
            raise RuntimeError('Module must be registered in order to call'
                               'this method.')
        return self._plugin

    @property
    def cache_path(self):
        '''Returns the module's cache_path.'''
        return self.plugin.cache_path

    @property
    def addon(self):
        '''Returns the module's addon'''
        return self.plugin.addon

    @property
    def added_items(self):
        '''Returns this module's added_items'''
        return self.plugin.added_items

    @property
    def handle(self):
        '''Returns this module's handle'''
        return self.plugin.handle

    @property
    def request(self):
        '''Returns the current request'''
        return self.plugin.request

    @property
    def log(self):
        '''Returns the registered plugin's log.'''
        return self._log

    @property
    def url_prefix(self):
        '''Sets or gets the url prefix of the module.

        Raises an Exception if this module is not registered with a
        Plugin.
        '''
        if self._url_prefix is None:
            # TODO: print called method in the error message
            raise RuntimeError('Module must be registered in order to call'
                               'this method.')
        return self._url_prefix

    def route(self, url_rule, name=None, options=None):
        '''A decorator to add a route to a view. name is used to
        differentiate when there are multiple routes for a given view.'''
        def decorator(func):
            '''Adds a url rule for the provided function'''
            view_name = name or func.__name__
            self.add_url_rule(url_rule, func, name=view_name, options=options)
            return func
        return decorator

    def url_for(self, endpoint, explicit=False, **items):
        '''Returns a valid XBMC plugin URL for the given endpoint name.
        endpoint can be the literal name of a function, or it can
        correspond to the name keyword arguments passed to the route
        decorator.

        Currently, view names must be unique across all plugins and
        modules. There are not namespace prefixes for modules.
        '''
        # TODO: Enable items to be passed with keywords of other var names
        #       such as endpoing and explicit
        # TODO: Figure out how to handle the case where a module wants to
        # call a parent plugin view.
        if not explicit and not endpoint.startswith(self._namespace):
            endpoint = '%s.%s' % (self._namespace, endpoint)
        return self._plugin.url_for(endpoint, **items)

    def add_url_rule(self, url_rule, view_func, name, options=None):
        '''This method adds a URL rule for routing purposes. The
        provided name can be different from the view function name if
        desired. The provided name is what is used in url_for to build
        a URL.

        The route decorator provides the same functionality.
        '''
        name = '%s.%s' % (self._namespace, name)

        def register_rule(plugin, url_prefix):
            '''Registers a url rule for the provided plugin and
            url_prefix.
            '''
            full_url_rule = url_prefix + url_rule
            plugin.add_url_rule(full_url_rule, view_func, name, options)

        # Delay actual registration of the url rule until this module is
        # registered with a plugin
        self._register_funcs.append(register_rule)

    def redirect(self, url):
        '''Used when you need to redirect to another view, and you only
        have the final plugin:// url.'''
        return self._plugin._fake_run(url)

########NEW FILE########
__FILENAME__ = plugin
'''
    xbmcswift2.plugin
    -----------------

    This module contains the Plugin class. This class handles all of the url
    routing and interaction with XBMC for a plugin.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import os
import sys
import pickle
import xbmcswift2
from urllib import urlencode
from functools import wraps
from optparse import OptionParser
try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs

from listitem import ListItem
from logger import log, setup_log
from common import enum
from common import clean_dict
from urls import UrlRule, NotFoundException, AmbiguousUrlException
from xbmcswift2 import (xbmc, xbmcgui, xbmcplugin, xbmcaddon, Request,)

from xbmcmixin import XBMCMixin
from common import Modes, DEBUG_MODES


class Plugin(XBMCMixin):
    '''The Plugin objects encapsulates all the properties and methods necessary
    for running an XBMC plugin. The plugin instance is a central place for
    registering view functions and keeping track of plugin state.

    Usually the plugin instance is created in the main addon.py file for the
    plugin. Typical creation looks like this::

        from xbmcswift2 import Plugin
        plugin = Plugin('Hello XBMC')


    .. versionchanged:: 0.2
        The *addon_id* and *filepath* parameters are now optional. They will
        now default to the correct values.

    :param name: The name of the plugin, e.g. 'Academic Earth'.

    :param addon_id: The XBMC addon ID for the plugin, e.g.
                     'plugin.video.academicearth'. This parameter is now
                     optional and is really only useful for testing purposes.
                     If it is not provided, the correct value will be parsed
                     from the addon.xml file.

    :param filepath: Optional parameter. If provided, it should be the path to
                     the addon.py file in the root of the addon directoy. This
                     only has an effect when xbmcswift2 is running on the
                     command line. Will default to the current working
                     directory since xbmcswift2 requires execution in the root
                     addon directoy anyway. The parameter still exists to ease
                     testing.
    '''

    def __init__(self, name=None, addon_id=None, filepath=None, info_type=None):
        self._name = name
        self._routes = []
        self._view_functions = {}

        # addon_id is no longer required as it can be parsed from addon.xml
        if addon_id:
            self._addon = xbmcaddon.Addon(id=addon_id)
        else:
            self._addon = xbmcaddon.Addon()

        self._addon_id = addon_id or self._addon.getAddonInfo('id')
        self._name = name or self._addon.getAddonInfo('name')

        self._info_type = info_type
        if not self._info_type:
            types = {
                'video': 'video',
                'audio': 'music',
                'image': 'pictures',
            }
            self._info_type = types.get(self._addon_id.split('.')[1], 'video')

        # Keeps track of the added list items
        self._current_items = []

        # Gets initialized when self.run() is called
        self._request = None

        # A flag to keep track of a call to xbmcplugin.endOfDirectory()
        self._end_of_directory = False

        # Keep track of the update_listing flag passed to
        # xbmcplugin.endOfDirectory()
        self._update_listing = False

        # The plugin's named logger
        self._log = setup_log(self._addon_id)

        # The path to the storage directory for the addon
        self._storage_path = xbmc.translatePath(
            'special://profile/addon_data/%s/.storage/' % self._addon_id)
        if not os.path.isdir(self._storage_path):
            os.makedirs(self._storage_path)

        # If we are runing in CLI, we need to load the strings.xml manually
        # Since xbmcswift2 currently relies on execution from an addon's root
        # directly, we can rely on cwd for now...
        if xbmcswift2.CLI_MODE:
            from xbmcswift2.mockxbmc import utils
            if filepath:
                addon_dir = os.path.dirname(filepath)
            else:
                addon_dir = os.getcwd()
            strings_fn = os.path.join(addon_dir, 'resources', 'language',
                                      'English', 'strings.xml')
            utils.load_addon_strings(self._addon, strings_fn)

    @property
    def info_type(self):
        return self._info_type

    @property
    def log(self):
        '''The log instance for the plugin. Returns an instance of the
        stdlib's ``logging.Logger``. This log will print to STDOUT when running
        in CLI mode and will forward messages to XBMC's log when running in
        XBMC. Some examples::

            plugin.log.debug('Debug message')
            plugin.log.warning('Warning message')
            plugin.log.error('Error message')
        '''
        return self._log

    @property
    def id(self):
        '''The id for the addon instance.'''
        return self._addon_id

    @property
    def storage_path(self):
        '''A full path to the storage folder for this plugin's addon data.'''
        return self._storage_path

    @property
    def addon(self):
        '''This plugin's wrapped instance of xbmcaddon.Addon.'''
        return self._addon

    @property
    def added_items(self):
        '''The list of currently added items.

        Even after repeated calls to :meth:`~xbmcswift2.Plugin.add_items`, this
        property will contain the complete list of added items.
        '''
        return self._current_items

    def clear_added_items(self):
        # TODO: This shouldn't be exposed probably...
        self._current_items = []

    @property
    def handle(self):
        '''The current plugin's handle. Equal to ``plugin.request.handle``.'''
        return self.request.handle

    @property
    def request(self):
        '''The current :class:`~xbmcswift2.Request`.

        Raises an Exception if the request hasn't been initialized yet via
        :meth:`~xbmcswift2.Plugin.run()`.
        '''
        if self._request is None:
            raise Exception('It seems the current request has not been '
                            'initialized yet. Please ensure that '
                            '`plugin.run()` has been called before attempting '
                            'to access the current request.')
        return self._request

    @property
    def name(self):
        '''The addon's name'''
        return self._name

    def _parse_request(self, url=None, handle=None):
        '''Handles setup of the plugin state, including request
        arguments, handle, mode.

        This method never needs to be called directly. For testing, see
        plugin.test()
        '''
        # To accomdate self.redirect, we need to be able to parse a full url as
        # well
        if url is None:
            url = sys.argv[0]
            if len(sys.argv) == 3:
                url += sys.argv[2]
        if handle is None:
            handle = sys.argv[1]
        return Request(url, handle)

    def register_module(self, module, url_prefix):
        '''Registers a module with a plugin. Requires a url_prefix that
        will then enable calls to url_for.

        :param module: Should be an instance `xbmcswift2.Module`.
        :param url_prefix: A url prefix to use for all module urls,
                           e.g. '/mymodule'
        '''
        module._plugin = self
        module._url_prefix = url_prefix
        for func in module._register_funcs:
            func(self, url_prefix)

    def cached_route(self, url_rule, name=None, options=None, TTL=None):
        '''A decorator to add a route to a view and also apply caching. The
        url_rule, name and options arguments are the same arguments for the
        route function. The TTL argument if given will passed along to the
        caching decorator.
        '''
        route_decorator = self.route(url_rule, name=name, options=options)
        if TTL:
            cache_decorator = self.cached(TTL)
        else:
            cache_decorator = self.cached()

        def new_decorator(func):
            return route_decorator(cache_decorator(func))
        return new_decorator

    def route(self, url_rule, name=None, options=None):
        '''A decorator to add a route to a view. name is used to
        differentiate when there are multiple routes for a given view.'''
        # TODO: change options kwarg to defaults
        def decorator(f):
            view_name = name or f.__name__
            self.add_url_rule(url_rule, f, name=view_name, options=options)
            return f
        return decorator

    def add_url_rule(self, url_rule, view_func, name, options=None):
        '''This method adds a URL rule for routing purposes. The
        provided name can be different from the view function name if
        desired. The provided name is what is used in url_for to build
        a URL.

        The route decorator provides the same functionality.
        '''
        rule = UrlRule(url_rule, view_func, name, options)
        if name in self._view_functions.keys():
            # TODO: Raise exception for ambiguous views during registration
            log.warning('Cannot add url rule "%s" with name "%s". There is '
                        'already a view with that name', url_rule, name)
            self._view_functions[name] = None
        else:
            log.debug('Adding url rule "%s" named "%s" pointing to function '
                      '"%s"', url_rule, name, view_func.__name__)
            self._view_functions[name] = rule
        self._routes.append(rule)

    def url_for(self, endpoint, **items):
        '''Returns a valid XBMC plugin URL for the given endpoint name.
        endpoint can be the literal name of a function, or it can
        correspond to the name keyword arguments passed to the route
        decorator.

        Raises AmbiguousUrlException if there is more than one possible
        view for the given endpoint name.
        '''
        try:
            rule = self._view_functions[endpoint]
        except KeyError:
            try:
                rule = (rule for rule in self._view_functions.values() if rule.view_func == endpoint).next()
            except StopIteration:
                raise NotFoundException(
                    '%s doesn\'t match any known patterns.' % endpoint)

        # rule can be None since values of None are allowed in the
        # _view_functions dict. This signifies more than one view function is
        # tied to the same name.
        if not rule:
            # TODO: Make this a regular exception
            raise AmbiguousUrlException

        pathqs = rule.make_path_qs(items)
        return 'plugin://%s%s' % (self._addon_id, pathqs)

    def _dispatch(self, path):
        for rule in self._routes:
            try:
                view_func, items = rule.match(path)
            except NotFoundException:
                continue
            log.info('Request for "%s" matches rule for function "%s"',
                     path, view_func.__name__)
            listitems = view_func(**items)

            # Only call self.finish() for UI container listing calls to plugin
            # (handle will be >= 0). Do not call self.finish() when called via
            # RunPlugin() (handle will be -1).
            if not self._end_of_directory and self.handle >= 0:
                if listitems is None:
                    self.finish(succeeded=False)
                else:
                    listitems = self.finish(listitems)

            return listitems
        raise NotFoundException, 'No matching view found for %s' % path

    def redirect(self, url):
        '''Used when you need to redirect to another view, and you only
        have the final plugin:// url.'''
        # TODO: Should we be overriding self.request with the new request?
        new_request = self._parse_request(url=url, handle=self.request.handle)
        log.debug('Redirecting %s to %s', self.request.path, new_request.path)
        return self._dispatch(new_request.path)

    def run(self, test=False):
        '''The main entry point for a plugin.'''
        self._request = self._parse_request()
        log.debug('Handling incoming request for %s', self.request.path)
        items = self._dispatch(self.request.path)

        # Close any open storages which will persist them to disk
        if hasattr(self, '_unsynced_storages'):
            for storage in self._unsynced_storages.values():
                log.debug('Saving a %s storage to disk at "%s"',
                          storage.file_format, storage.filename)
                storage.close()

        return items

########NEW FILE########
__FILENAME__ = request
'''
    xbmcswift2.request
    ------------------

    This module contains the Request class. This class represents an incoming
    request from XBMC.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
from xbmcswift2.common import unpickle_args
import urlparse
try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs


class Request(object):
    '''The request objects contains all the arguments passed to the plugin via
    the command line.

    :param url: The complete plugin URL being requested. Since XBMC typically
                passes the URL query string in a separate argument from the
                base URL, they must be joined into a single string before being
                provided.
    :param handle: The handle associated with the current request.
    '''

    def __init__(self, url, handle):
        #: The entire request url.
        self.url = url

        #: The current request's handle, an integer.
        self.handle = int(handle)

        # urlparse doesn't like the 'plugin' scheme, so pass a protocol
        # relative url, e.g. //plugin.video.helloxbmc/path
        self.scheme, remainder = url.split(':', 1)
        parts = urlparse.urlparse(remainder)
        self.netloc, self.path, self.query_string = (
            parts[1], parts[2], parts[4])
        self.args = unpickle_args(parse_qs(self.query_string))

########NEW FILE########
__FILENAME__ = storage
'''
    xbmcswift2.storage
    ~~~~~~~~~~~~~~~~~~

    This module contains persistent storage classes.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import os
import csv
import json
import time
try:
    import cPickle as pickle
except ImportError:
    import pickle
import shutil
import collections
from datetime import datetime
from xbmcswift2.logger import log


class _PersistentDictMixin(object):
    ''' Persistent dictionary with an API compatible with shelve and anydbm.

    The dict is kept in memory, so the dictionary operations run as fast as
    a regular dictionary.

    Write to disk is delayed until close or sync (similar to gdbm's fast mode).

    Input file format is automatically discovered.
    Output file format is selectable between pickle, json, and csv.
    All three serialization formats are backed by fast C implementations.
    '''

    def __init__(self, filename, flag='c', mode=None, file_format='pickle'):
        self.flag = flag                    # r=readonly, c=create, or n=new
        self.mode = mode                    # None or an octal triple like 0644
        self.file_format = file_format      # 'csv', 'json', or 'pickle'
        self.filename = filename
        if flag != 'n' and os.access(filename, os.R_OK):
            log.debug('Reading %s storage from disk at "%s"',
                      self.file_format, self.filename)
            fileobj = open(filename, 'rb' if file_format == 'pickle' else 'r')
            with fileobj:
                self.load(fileobj)

    def sync(self):
        '''Write the dict to disk'''
        if self.flag == 'r':
            return
        filename = self.filename
        tempname = filename + '.tmp'
        fileobj = open(tempname, 'wb' if self.file_format == 'pickle' else 'w')
        try:
            self.dump(fileobj)
        except Exception:
            os.remove(tempname)
            raise
        finally:
            fileobj.close()
        shutil.move(tempname, self.filename)    # atomic commit
        if self.mode is not None:
            os.chmod(self.filename, self.mode)

    def close(self):
        '''Calls sync'''
        self.sync()

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.close()

    def dump(self, fileobj):
        '''Handles the writing of the dict to the file object'''
        if self.file_format == 'csv':
            csv.writer(fileobj).writerows(self.raw_dict().items())
        elif self.file_format == 'json':
            json.dump(self.raw_dict(), fileobj, separators=(',', ':'))
        elif self.file_format == 'pickle':
            pickle.dump(dict(self.raw_dict()), fileobj, 2)
        else:
            raise NotImplementedError('Unknown format: ' +
                                      repr(self.file_format))

    def load(self, fileobj):
        '''Load the dict from the file object'''
        # try formats from most restrictive to least restrictive
        for loader in (pickle.load, json.load, csv.reader):
            fileobj.seek(0)
            try:
                return self.initial_update(loader(fileobj))
            except Exception as e:
                pass
        raise ValueError('File not in a supported format')

    def raw_dict(self):
        '''Returns the underlying dict'''
        raise NotImplementedError


class _Storage(collections.MutableMapping, _PersistentDictMixin):
    '''Storage that acts like a dict but also can persist to disk.

    :param filename: An absolute filepath to reprsent the storage on disk. The
                     storage will loaded from this file if it already exists,
                     otherwise the file will be created.
    :param file_format: 'pickle', 'json' or 'csv'. pickle is the default. Be
                        aware that json and csv have limited support for python
                        objets.

    .. warning:: Currently there are no limitations on the size of the storage.
                 Please be sure to call :meth:`~xbmcswift2._Storage.clear`
                 periodically.
    '''

    def __init__(self, filename, file_format='pickle'):
        '''Acceptable formats are 'csv', 'json' and 'pickle'.'''
        self._items = {}
        _PersistentDictMixin.__init__(self, filename, file_format=file_format)

    def __setitem__(self, key, val):
        self._items.__setitem__(key, val)

    def __getitem__(self, key):
        return self._items.__getitem__(key)

    def __delitem__(self, key):
        self._items.__delitem__(key)

    def __iter__(self):
        return iter(self._items)

    def __len__(self):
        return self._items.__len__

    def raw_dict(self):
        '''Returns the wrapped dict'''
        return self._items

    initial_update = collections.MutableMapping.update

    def clear(self):
        super(_Storage, self).clear()
        self.sync()


class TimedStorage(_Storage):
    '''A dict with the ability to persist to disk and TTL for items.'''

    def __init__(self, filename, file_format='pickle', TTL=None):
        '''TTL if provided should be a datetime.timedelta. Any entries
        older than the provided TTL will be removed upon load and upon item
        access.
        '''
        self.TTL = TTL
        _Storage.__init__(self, filename, file_format=file_format)

    def __setitem__(self, key, val, raw=False):
        if raw:
            self._items[key] = val
        else:
            self._items[key] = (val, time.time())

    def __getitem__(self, key):
        val, timestamp = self._items[key]
        if self.TTL and (datetime.utcnow() -
            datetime.utcfromtimestamp(timestamp) > self.TTL):
            del self._items[key]
            return self._items[key][0]  # Will raise KeyError
        return val

    def initial_update(self, mapping):
        '''Initially fills the underlying dictionary with keys, values and
        timestamps.
        '''
        for key, val in mapping.items():
            _, timestamp = val
            if not self.TTL or (datetime.utcnow() -
                datetime.utcfromtimestamp(timestamp) < self.TTL):
                self.__setitem__(key, val, raw=True)

########NEW FILE########
__FILENAME__ = urls
'''
    xbmcswift2.urls
    ---------------

    This module contains URLRule class for dealing with url patterns.

    :copyright: (c) 2012 by Jonathan Beluch
    :license: GPLv3, see LICENSE for more details.
'''
import re
from urllib import urlencode, unquote_plus, quote_plus
from xbmcswift2.common import pickle_dict, unpickle_dict


# TODO: Use regular Exceptions
class AmbiguousUrlException(Exception):
    pass


class NotFoundException(Exception):
    pass


class UrlRule(object):
    '''This object stores the various properties related to a routing URL rule.
    It also provides a few methods to create URLs from the rule or to match a
    given URL against a rule.

    :param url_rule: The relative url pattern for the rule. It may include
                     <var_name> to denote where dynamic variables should be
                     matched.
    :param view_func: The function that should be bound to this rule. This
                      should be an actual function object.

                      .. warning:: The function signature should match any
                                   variable names in the provided url_rule.
    :param name: The name of the url rule. This is used in the reverse process
                 of creating urls for a given rule.
    :param options: A dict containing any default values for the url rule.
    '''

    def __init__(self, url_rule, view_func, name, options):
        self._name = name
        self._url_rule = url_rule
        self._view_func = view_func
        self._options = options or {}
        self._keywords = re.findall(r'\<(.+?)\>', url_rule)

        #change <> to {} for use with str.format()
        self._url_format = self._url_rule.replace('<', '{').replace('>', '}')

        # Make a regex pattern for matching incoming URLs
        rule = self._url_rule
        if rule != '/':
            # Except for a path of '/', the trailing slash is optional.
            rule = self._url_rule.rstrip('/') + '/?'
        p = rule.replace('<', '(?P<').replace('>', '>[^/]+?)')

        try:
            self._regex = re.compile('^' + p + '$')
        except re.error, e:
            raise ValueError, ('There was a problem creating this URL rule. '
                               'Ensure you do not have any unpaired angle '
                               'brackets: "<" or ">"')

    def __eq__(self, other):
        return (
            (self._name, self._url_rule, self._view_func, self._options) ==
            (other._name, other._url_rule, other._view_func, other._options)
        )

    def __ne__(self, other):
        return not self.__eq__(other)

    def match(self, path):
        '''Attempts to match a url to the given path. If successful, a tuple is
        returned. The first item is the matchd function and the second item is
        a dictionary containing items to be passed to the function parsed from
        the provided path.

        If the provided path does not match this url rule then a
        NotFoundException is raised.
        '''
        m = self._regex.search(path)
        if not m:
            raise NotFoundException

        # urlunencode the values
        items = dict((key, unquote_plus(val))
                     for key, val in m.groupdict().items())

        # unpickle any items if present
        items = unpickle_dict(items)

        # We need to update our dictionary with default values provided in
        # options if the keys don't already exist.
        [items.setdefault(key, val) for key, val in self._options.items()]
        return self._view_func, items

    def _make_path(self, items):
        '''Returns a relative path for the given dictionary of items.

        Uses this url rule's url pattern and replaces instances of <var_name>
        with the appropriate value from the items dict.
        '''
        for key, val in items.items():
            if not isinstance(val, basestring):
                raise TypeError, ('Value "%s" for key "%s" must be an instance'
                                  ' of basestring' % (val, key))
            items[key] = quote_plus(val)

        try:
            path = self._url_format.format(**items)
        except AttributeError:
            # Old version of python
            path = self._url_format
            for key, val in items.items():
                path = path.replace('{%s}' % key, val)
        return path

    def _make_qs(self, items):
        '''Returns a query string for the given dictionary of items. All keys
        and values in the provided items will be urlencoded. If necessary, any
        python objects will be pickled before being urlencoded.
        '''
        return urlencode(pickle_dict(items))

    def make_path_qs(self, items):
        '''Returns a relative path complete with query string for the given
        dictionary of items.

        Any items with keys matching this rule's url pattern will be inserted
        into the path. Any remaining items will be appended as query string
        parameters.

        All items will be urlencoded. Any items which are not instances of
        basestring, or int/long will be pickled before being urlencoded.

        .. warning:: The pickling of items only works for key/value pairs which
                     will be in the query string. This behavior should only be
                     used for the simplest of python objects. It causes the
                     URL to get very lengthy (and unreadable) and XBMC has a
                     hard limit on URL length. See the caching section if you
                     need to persist a large amount of data between requests.
        '''
        # Convert any ints and longs to strings
        for key, val in items.items():
            if isinstance(val, (int, long)):
                items[key] = str(val)

        # First use our defaults passed when registering the rule
        url_items = dict((key, val) for key, val in self._options.items()
                         if key in self._keywords)

        # Now update with any items explicitly passed to url_for
        url_items.update((key, val) for key, val in items.items()
                         if key in self._keywords)

        # Create the path
        path = self._make_path(url_items)

        # Extra arguments get tacked on to the query string
        qs_items = dict((key, val) for key, val in items.items()
                        if key not in self._keywords)
        qs = self._make_qs(qs_items)

        if qs:
            return '?'.join([path, qs])
        return path

    @property
    def regex(self):
        '''The regex for matching paths against this url rule.'''
        return self._regex

    @property
    def view_func(self):
        '''The bound function'''
        return self._view_func

    @property
    def url_format(self):
        '''The url pattern'''
        return self._url_format

    @property
    def name(self):
        '''The name of this url rule.'''
        return self._name

    @property
    def keywords(self):
        '''The list of path keywords for this url rule.'''
        return self._keywords

########NEW FILE########
__FILENAME__ = xbmcmixin
import os
import sys
import time
import shelve
import urllib
from datetime import timedelta
from functools import wraps

import xbmcswift2
from xbmcswift2 import xbmc, xbmcaddon, xbmcplugin, xbmcgui
from xbmcswift2.storage import TimedStorage
from xbmcswift2.logger import log
from xbmcswift2.constants import VIEW_MODES, SortMethod
from common import Modes, DEBUG_MODES
from request import Request




class XBMCMixin(object):
    '''A mixin to add XBMC helper methods. In order to use this mixin,
    the child class must implement the following methods and
    properties:

        # Also, the child class is responsible for ensuring that this path
        # exists.
        self.storage_path

        self.added_items

        self.request

        self.addon

        _end_of_directory = False

        _update_listing

        self.handle

    # optional
    self.info_type: should be in ['video', 'music', 'pictures']
    _memoized_storage = None
    _unsynced_storages = None
    # TODO: Ensure above is implemented
    '''

    _function_cache_name = '.functions'

    def cached(self, TTL=60 * 24):
        '''A decorator that will cache the output of the wrapped function. The
        key used for the cache is the function name as well as the `*args` and
        `**kwargs` passed to the function.

        :param TTL: time to live in minutes

        .. note:: For route caching, you should use
                  :meth:`xbmcswift2.Plugin.cached_route`.
        '''
        def decorating_function(function):
            # TODO test this method
            storage = self.get_storage(self._function_cache_name, file_format='pickle',
                                       TTL=TTL)
            kwd_mark = 'f35c2d973e1bbbc61ca60fc6d7ae4eb3'

            @wraps(function)
            def wrapper(*args, **kwargs):
                key = (function.__name__, kwd_mark,) + args
                if kwargs:
                    key += (kwd_mark,) + tuple(sorted(kwargs.items()))

                try:
                    result = storage[key]
                    log.debug('Storage hit for function "%s" with args "%s" '
                              'and kwargs "%s"', function.__name__, args,
                              kwargs)
                except KeyError:
                    log.debug('Storage miss for function "%s" with args "%s" '
                              'and kwargs "%s"', function.__name__, args,
                              kwargs)
                    result = function(*args, **kwargs)
                    storage[key] = result
                    storage.sync()
                return result
            return wrapper
        return decorating_function

    def clear_function_cache(self):
        '''Clears the storage that caches results when using
        :meth:`xbmcswift2.Plugin.cached_route` or
        :meth:`xbmcswift2.Plugin.cached`.
        '''
        self.get_storage(self._function_cache_name).clear()

    def list_storages(self):
        '''Returns a list of existing stores. The returned names can then be
        used to call get_storage().
        '''
        # Filter out any storages used by xbmcswift2 so caller doesn't corrupt
        # them.
        return [name for name in os.listdir(self.storage_path)
                if not name.startswith('.')]

    def get_storage(self, name='main', file_format='pickle', TTL=None):
        '''Returns a storage for the given name. The returned storage is a
        fully functioning python dictionary and is designed to be used that
        way. It is usually not necessary for the caller to load or save the
        storage manually. If the storage does not already exist, it will be
        created.

        .. seealso:: :class:`xbmcswift2.TimedStorage` for more details.

        :param name: The name  of the storage to retrieve.
        :param file_format: Choices are 'pickle', 'csv', and 'json'. Pickle is
                            recommended as it supports python objects.

                            .. note:: If a storage already exists for the given
                                      name, the file_format parameter is
                                      ignored. The format will be determined by
                                      the existing storage file.
        :param TTL: The time to live for storage items specified in minutes or None
                    for no expiration. Since storage items aren't expired until a
                    storage is loaded form disk, it is possible to call
                    get_storage() with a different TTL than when the storage was
                    created. The currently specified TTL is always honored.
        '''

        if not hasattr(self, '_unsynced_storages'):
            self._unsynced_storages = {}
        filename = os.path.join(self.storage_path, name)
        try:
            storage = self._unsynced_storages[filename]
            log.debug('Loaded storage "%s" from memory', name)
        except KeyError:
            if TTL:
                TTL = timedelta(minutes=TTL)

            try:
                storage = TimedStorage(filename, file_format, TTL)
            except ValueError:
                # Thrown when the storage file is corrupted and can't be read.
                # Prompt user to delete storage.
                choices = ['Clear storage', 'Cancel']
                ret = xbmcgui.Dialog().select('A storage file is corrupted. It'
                                              ' is recommended to clear it.',
                                              choices)
                if ret == 0:
                    os.remove(filename)
                    storage = TimedStorage(filename, file_format, TTL)
                else:
                    raise Exception('Corrupted storage file at %s' % filename)

            self._unsynced_storages[filename] = storage
            log.debug('Loaded storage "%s" from disk', name)
        return storage

    def temp_fn(self, path):
        return os.path.join(xbmc.translatePath('special://temp/'), path)

    def get_string(self, stringid):
        '''Returns the localized string from strings.xml for the given
        stringid.
        '''
        stringid = int(stringid)
        if not hasattr(self, '_strings'):
            self._strings = {}
        if not stringid in self._strings:
            self._strings[stringid] = self.addon.getLocalizedString(stringid)
        return self._strings[stringid]

    def set_content(self, content):
        '''Sets the content type for the plugin.'''
        # TODO: Change to a warning instead of an assert. Otherwise will have
        # to keep this list in sync with
        #       any XBMC changes.
        #contents = ['files', 'songs', 'artists', 'albums', 'movies',
        #'tvshows', 'episodes', 'musicvideos']
        #assert content in contents, 'Content type "%s" is not valid' % content
        xbmcplugin.setContent(self.handle, content)

    def get_setting(self, key, converter=None, choices=None):
        '''Returns the settings value for the provided key.
        If converter is str, unicode, bool or int the settings value will be
        returned converted to the provided type.
        If choices is an instance of list or tuple its item at position of the
        settings value be returned.
        .. note:: It is suggested to always use unicode for text-settings
                  because else xbmc returns utf-8 encoded strings.

        :param key: The id of the setting defined in settings.xml.
        :param converter: (Optional) Choices are str, unicode, bool and int.
        :param converter: (Optional) Choices are instances of list or tuple.

        Examples:
            * ``plugin.get_setting('per_page', int)``
            * ``plugin.get_setting('password', unicode)``
            * ``plugin.get_setting('force_viewmode', bool)``
            * ``plugin.get_setting('content', choices=('videos', 'movies'))``
        '''
        #TODO: allow pickling of settings items?
        # TODO: STUB THIS OUT ON CLI
        value = self.addon.getSetting(id=key)
        if converter is str:
            return value
        elif converter is unicode:
            return value.decode('utf-8')
        elif converter is bool:
            return value == 'true'
        elif converter is int:
            return int(value)
        elif isinstance(choices, (list, tuple)):
            return choices[int(value)]
        elif converter is None:
            log.warning('No converter provided, unicode should be used, '
                        'but returning str value')
            return value
        else:
            raise TypeError('Acceptable converters are str, unicode, bool and '
                            'int. Acceptable choices are instances of list '
                            ' or tuple.')

    def set_setting(self, key, val):
        # TODO: STUB THIS OUT ON CLI
        return self.addon.setSetting(id=key, value=val)

    def open_settings(self):
        '''Opens the settings dialog within XBMC'''
        self.addon.openSettings()

    def add_to_playlist(self, items, playlist='video'):
        '''Adds the provided list of items to the specified playlist.
        Available playlists include *video* and *music*.
        '''
        playlists = {'music': 0, 'video': 1}
        assert playlist in playlists.keys(), ('Playlist "%s" is invalid.' %
                                              playlist)
        selected_playlist = xbmc.PlayList(playlists[playlist])

        _items = []
        for item in items:
            if not hasattr(item, 'as_xbmc_listitem'):
                if 'info_type' in item.keys():
                    log.warning('info_type key has no affect for playlist '
                                'items as the info_type is inferred from the '
                                'playlist type.')
                # info_type has to be same as the playlist type
                item['info_type'] = playlist
                item = xbmcswift2.ListItem.from_dict(**item)
            _items.append(item)
            selected_playlist.add(item.get_path(), item.as_xbmc_listitem())
        return _items

    def get_view_mode_id(self, view_mode):
        '''Attempts to return a view_mode_id for a given view_mode
        taking into account the current skin. If not view_mode_id can
        be found, None is returned. 'thumbnail' is currently the only
        suppported view_mode.
        '''
        view_mode_ids = VIEW_MODES.get(view_mode.lower())
        if view_mode_ids:
            return view_mode_ids.get(xbmc.getSkinDir())
        return None

    def set_view_mode(self, view_mode_id):
        '''Calls XBMC's Container.SetViewMode. Requires an integer
        view_mode_id'''
        xbmc.executebuiltin('Container.SetViewMode(%d)' % view_mode_id)

    def keyboard(self, default=None, heading=None, hidden=False):
        '''Displays the keyboard input window to the user. If the user does not
        cancel the modal, the value entered by the user will be returned.

        :param default: The placeholder text used to prepopulate the input field.
        :param heading: The heading for the window. Defaults to the current
                        addon's name. If you require a blank heading, pass an
                        empty string.
        :param hidden: Whether or not the input field should be masked with
                       stars, e.g. a password field.
        '''
        if heading is None:
            heading = self.addon.getAddonInfo('name')
        if default is None:
            default = ''
        keyboard = xbmc.Keyboard(default, heading, hidden)
        keyboard.doModal()
        if keyboard.isConfirmed():
            return keyboard.getText()

    def notify(self, msg='', title=None, delay=5000, image=''):
        '''Displays a temporary notification message to the user. If
        title is not provided, the plugin name will be used. To have a
        blank title, pass '' for the title argument. The delay argument
        is in milliseconds.
        '''
        if not msg:
            log.warning('Empty message for notification dialog')
        if title is None:
            title = self.addon.getAddonInfo('name')
        xbmc.executebuiltin('XBMC.Notification("%s", "%s", "%s", "%s")' %
                            (msg, title, delay, image))

    def _listitemify(self, item):
        '''Creates an xbmcswift2.ListItem if the provided value for item is a
        dict. If item is already a valid xbmcswift2.ListItem, the item is
        returned unmodified.
        '''
        info_type = self.info_type if hasattr(self, 'info_type') else 'video'

        # Create ListItems for anything that is not already an instance of
        # ListItem
        if not hasattr(item, 'as_tuple'):
            if 'info_type' not in item.keys():
                item['info_type'] = info_type
            item = xbmcswift2.ListItem.from_dict(**item)
        return item

    def _add_subtitles(self, subtitles):
        '''Adds subtitles to playing video.

        :param subtitles: A URL to a remote subtitles file or a local filename
                          for a subtitles file.

        .. warning:: You must start playing a video before calling this method
                     or it will loop for an indefinite length.
        '''
        # This method is named with an underscore to suggest that callers pass
        # the subtitles argument to set_resolved_url instead of calling this
        # method directly. This is to ensure a video is played before calling
        # this method.
        player = xbmc.Player()
        for _ in xrange(30):
            if player.isPlaying():
                break
            time.sleep(1)
        else:
            raise Exception('No video playing. Aborted after 30 seconds.')

        player.setSubtitles(subtitles)

    def set_resolved_url(self, item=None, subtitles=None):
        '''Takes a url or a listitem to be played. Used in conjunction with a
        playable list item with a path that calls back into your addon.

        :param item: A playable list item or url. Pass None to alert XBMC of a
                     failure to resolve the item.

                     .. warning:: When using set_resolved_url you should ensure
                                  the initial playable item (which calls back
                                  into your addon) doesn't have a trailing
                                  slash in the URL. Otherwise it won't work
                                  reliably with XBMC's PlayMedia().
        :param subtitles: A URL to a remote subtitles file or a local filename
                          for a subtitles file to be played along with the
                          item.
        '''
        if self._end_of_directory:
            raise Exception('Current XBMC handle has been removed. Either '
                            'set_resolved_url(), end_of_directory(), or '
                            'finish() has already been called.')
        self._end_of_directory = True

        succeeded = True
        if item is None:
            # None item indicates the resolve url failed.
            item = {}
            succeeded = False

        if isinstance(item, basestring):
            # caller is passing a url instead of an item dict
            item = {'path': item}

        item = self._listitemify(item)
        item.set_played(True)
        xbmcplugin.setResolvedUrl(self.handle, succeeded,
                                  item.as_xbmc_listitem())

        # call to _add_subtitles must be after setResolvedUrl
        if subtitles:
            self._add_subtitles(subtitles)
        return [item]

    def play_video(self, item, player=None):
        try:
            # videos are always type video
            item['info_type'] = 'video'
        except TypeError:
            pass  # not a dict

        item = self._listitemify(item)
        item.set_played(True)
        if player:
            _player = xbmc.Player(player)
        else:
            _player = xbmc.Player()
        _player.play(item.get_path(), item.as_xbmc_listitem())
        return [item]

    def add_items(self, items):
        '''Adds ListItems to the XBMC interface. Each item in the
        provided list should either be instances of xbmcswift2.ListItem,
        or regular dictionaries that will be passed to
        xbmcswift2.ListItem.from_dict. Returns the list of ListItems.

        :param items: An iterable of items where each item is either a
                      dictionary with keys/values suitable for passing to
                      :meth:`xbmcswift2.ListItem.from_dict` or an instance of
                      :class:`xbmcswift2.ListItem`.
        '''
        _items = [self._listitemify(item) for item in items]
        tuples = [item.as_tuple() for item in _items]
        xbmcplugin.addDirectoryItems(self.handle, tuples, len(tuples))

        # We need to keep track internally of added items so we can return them
        # all at the end for testing purposes
        self.added_items.extend(_items)

        # Possibly need an if statement if only for debug mode
        return _items

    def end_of_directory(self, succeeded=True, update_listing=False,
                         cache_to_disc=True):
        '''Wrapper for xbmcplugin.endOfDirectory. Records state in
        self._end_of_directory.

        Typically it is not necessary to call this method directly, as
        calling :meth:`~xbmcswift2.Plugin.finish` will call this method.
        '''
        self._update_listing = update_listing
        if not self._end_of_directory:
            self._end_of_directory = True
            # Finalize the directory items
            return xbmcplugin.endOfDirectory(self.handle, succeeded,
                                             update_listing, cache_to_disc)
        assert False, 'Already called endOfDirectory.'

    def add_sort_method(self, sort_method, label2_mask=None):
        '''A wrapper for `xbmcplugin.addSortMethod()
        <http://mirrors.xbmc.org/docs/python-docs/xbmcplugin.html#-addSortMethod>`_.
        You can use ``dir(xbmcswift2.SortMethod)`` to list all available sort
        methods.

        :param sort_method: A valid sort method. You can provided the constant
                            from xbmcplugin, an attribute of SortMethod, or a
                            string name. For instance, the following method
                            calls are all equivalent:

                            * ``plugin.add_sort_method(xbmcplugin.SORT_METHOD_TITLE)``
                            * ``plugin.add_sort_metohd(SortMethod.TITLE)``
                            * ``plugin.add_sort_method('title')``
        :param label2_mask: A mask pattern for label2. See the `XBMC
                            documentation
                            <http://mirrors.xbmc.org/docs/python-docs/xbmcplugin.html#-addSortMethod>`_
                            for more information.
        '''
        try:
            # Assume it's a string and we need to get the actual int value
            sort_method = SortMethod.from_string(sort_method)
        except AttributeError:
            # sort_method was already an int (or a bad value)
            pass

        if label2_mask:
            xbmcplugin.addSortMethod(self.handle, sort_method, label2_mask)
        else:
            xbmcplugin.addSortMethod(self.handle, sort_method)

    def finish(self, items=None, sort_methods=None, succeeded=True,
               update_listing=False, cache_to_disc=True, view_mode=None):
        '''Adds the provided items to the XBMC interface.

        :param items: an iterable of items where each item is either a
            dictionary with keys/values suitable for passing to
            :meth:`xbmcswift2.ListItem.from_dict` or an instance of
            :class:`xbmcswift2.ListItem`.
        :param sort_methods: a list of valid XBMC sort_methods. Each item in
                             the list can either be a sort method or a tuple of
                             ``sort_method, label2_mask``. See
                             :meth:`add_sort_method` for
                             more detail concerning valid sort_methods.

                             Example call with sort_methods::

                                sort_methods = ['label', 'title', ('date', '%D')]
                                plugin.finish(items, sort_methods=sort_methods)

        :param view_mode: can either be an integer (or parseable integer
            string) corresponding to a view_mode or the name of a type of view.
            Currrently the only view type supported is 'thumbnail'.
        :returns: a list of all ListItems added to the XBMC interface.
        '''
        # If we have any items, add them. Items are optional here.
        if items:
            self.add_items(items)
        if sort_methods:
            for sort_method in sort_methods:
                if not isinstance(sort_method, basestring) and hasattr(sort_method, '__len__'):
                    self.add_sort_method(*sort_method)
                else:
                    self.add_sort_method(sort_method)

        # Attempt to set a view_mode if given
        if view_mode is not None:
            # First check if we were given an integer or parseable integer
            try:
                view_mode_id = int(view_mode)
            except ValueError:
                # Attempt to lookup a view mode
                view_mode_id = self.get_view_mode_id(view_mode)

            if view_mode_id is not None:
                self.set_view_mode(view_mode_id)

        # Finalize the directory items
        self.end_of_directory(succeeded, update_listing, cache_to_disc)

        # Return the cached list of all the list items that were added
        return self.added_items

########NEW FILE########
