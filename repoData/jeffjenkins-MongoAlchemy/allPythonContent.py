__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# MongoAlchemy documentation build configuration file, created by
# sphinx-quickstart on Sat Oct  2 08:50:52 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 
    # 'sphinx.ext.viewcode'
    ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'MongoAlchemy'
copyright = u'2010-2012, Jeffrey Jenkins'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.14'
# The full version, including alpha/beta/rc tags.
release = '0.14'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['build', '_static', '_templates']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


autoclass_content = 'both'
autodoc_member_order = 'bysource'
autodoc_default_flags = ['members', 'inherited-members', 'undoc-members']

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'MongoAlchemydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'MongoAlchemy.tex', u'MongoAlchemy Documentation',
   u'Jeffrey Jenkins', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'mongoalchemy', u'MongoAlchemy Documentation',
     [u'Jeffrey Jenkins'], 1)
]

bad_names = ['schema_json', 'has_autoload', 'set_parent_on_subtypes', 
                'subfields', 'has_subfields', 'valid_modifiers',
                'set_value', 'update_ops', 'db_field', 'no_real_attributes',
                'default', 'localize', 'auto', 'dirty_ops', 'validate_wrap',
                'is_valid_unwrap', 'is_valid_wrap', 'unwrap', 
                'validate_unwrap', 'wrap', 'wrap_value', 'PrimitiveField',
                'NumberField', 'SequenceField', 'child_type',
                'type', 'sub_type', 'compute_value', 'in_transaction',
                'autoflush', 'cache_write', 'cache_read', 'transaction_id',
                'execute_update', 'execute_remove', 'execute_find_and_modify']

bad_exc = ['message', 'args']

def skip_common(app, what, name, obj, skip, options):
    print what, name, obj
    if what == 'exception' and name in bad_exc:
        return True
    if name in bad_names:
        return True
    return skip


def setup(app):
    app.connect('autodoc-skip-member', skip_common)



########NEW FILE########
__FILENAME__ = advanced_modeling
'''
This page is going to go through some more advanced modeling techniques 
using forward and self-references

'''


from mongoalchemy.document import Document
from mongoalchemy.fields import *
from datetime import datetime
from pprint import pprint
class Event(Document):
    name = StringField()
    children = ListField(DocumentField('Event'))
    begin = DateTimeField()
    end = DateTimeField()
    
    def __init__(self, name, parent=None):
        Document.__init__(self, name=name)
        self.children = []
        if parent is not None:
            parent.children.append(self)
    def __enter__(self):
        self.begin = datetime.utcnow()
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = datetime.utcnow()

with Event('request') as root:
    with Event('main_func', root) as br:
        with Event('setup', br):
            pass
        with Event('handle', br):
            pass
        with Event('teardown', br):
            pass
    with Event('cleanup', root):
        pass

pprint(root.wrap())

########NEW FILE########
__FILENAME__ = examples
# The MIT License
# 
# Copyright (c) 2010 Jeffrey Jenkins
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from pprint import pprint
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index
from mongoalchemy.fields import *

def main():
    class Address(Document):
        street_address = StringField()
        city = StringField()
        state_province = StringField()
        country = StringField()
    
    class User(Document):
        
        name_index = Index().ascending('name').unique()
        
        name = StringField()
        email = StringField()
        
        address = DocumentField(Address)
        
        def __str__(self):
            return '%s (%s)' % (self.name, self.email)

    
    with Session.connect('mongoalchemy') as s:
        def print_all():
            for u in s.query(User).filter(User.address.country == 'USA' ):
                print u

        s.clear_collection(User)
    
        a = Address(street_address='123 4th ave', city='NY', state_province='NY', country='USA')
        u = User(name='jeff', email='jeff@qcircles.net', address=a)
        s.insert(u)
        print u.mongo_id
    
        query = User.address.country == 'USA'
    
        print_all()
    
        update = s.query(User).filter(User.name > 'ivan', User.name < 'katie' ).set(User.email, 'jeff2@qcircles.net')
        update.execute()
        print_all()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = hash_field
from mongoalchemy.document import Document
from mongoalchemy.fields import *
from datetime import datetime
from pprint import pprint

class HashField(StringField):
    def set_value(self, instance, value, from_db=False):
        if from_db:
            super(HashField, self).set_value(instance, value)
        else:
            super(HashField, self).set_value(instance, str(hash(value)))

class User(Document):
    password = HashField()
    
from mongoalchemy.session import Session
session = Session.connect('mongoalchemy-tutorial')
session.clear_collection(User)

user = User(password='pw')
print user.password
user.password = 'newpw'
print user.password

session.insert(user)

loaded_user = session.query(User).one()

print loaded_user.password
print loaded_user.password
########NEW FILE########
__FILENAME__ = json
from mongoalchemy.document import Document
from mongoalchemy.fields import StringField

class A(Document):
    b = StringField()
    c = StringField()

a = A.unwrap({'b' : 'some val 1', 'c' : 'some val 2'})
print a.b, a.c
########NEW FILE########
__FILENAME__ = tutorial

# Create a mapping class
from mongoalchemy.document import Document
from mongoalchemy.fields import *

class BloodDonor(Document):
    first_name = StringField()
    last_name = StringField()
    age = IntField(min_value=0)
    
    gender = EnumField(StringField(), 'male', 'female')
    blood_type = EnumField(StringField(), 'O+','A+','B+','AB+','O-','A-','B-','AB-')
    def __str__(self):
        return '%s %s (%s; Age: %d; Type: %s)' % (self.first_name, self.last_name, 
            self.gender, self.age, self.blood_type)


# Create A session, insert an object
from mongoalchemy.session import Session
session = Session.connect('mongoalchemy-tutorial')
session.clear_collection(BloodDonor)

donor = BloodDonor(first_name='Jeff', last_name='Jenkins', 
            age=28, blood_type='O+', gender='male')
session.insert(donor)

# Add some more objects for the querying section

session.insert(BloodDonor(first_name='Jeff', last_name='Winger', age=38, blood_type='O+', gender='male'))
session.insert(BloodDonor(first_name='Britta', last_name='Perry', age=27, blood_type='A+', gender='female'))
session.insert(BloodDonor(first_name='Abed', last_name='Nadir', age=29, blood_type='O+', gender='male'))
session.insert(BloodDonor(first_name='Shirley', last_name='Bennett', age=39, blood_type='O-', gender='female'))

# Querying

for donor in session.query(BloodDonor).filter(BloodDonor.first_name == 'Jeff'):
    print donor

for donor in session.query(BloodDonor).filter(
    BloodDonor.first_name == 'Jeff', 
    BloodDonor.age < 30):
   print donor

for donor in session.query(BloodDonor).filter(
    BloodDonor.first_name == 'Jeff').filter( 
    BloodDonor.age < 30):
   print donor

query = session.query(BloodDonor).filter(BloodDonor.first_name == 'Jeff', BloodDonor.last_name == 'Jenkins')
query.inc(BloodDonor.age, 1).set(BloodDonor.blood_type, 'O-').execute()
print query.one()



########NEW FILE########
__FILENAME__ = document
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
'''

A `mongoalchemy` document is used to define a mapping between a python object
and a document in a Mongo Database.  Mappings are defined by creating a
subclass of :class:`Document` with attributes to define
what maps to what.  The two main types of attributes are :class:`~mongoalchemy.fields.Field`
and :class:`Index`

A :class:`~mongoalchemy.fields.Field` is used to define the type of a field in
mongo document, any constraints on the values, and to provide methods for
transforming a value from a python object into something Mongo understands and
vice-versa.

A :class:`~Index` is used to define an index on the underlying collection
programmatically.  A document can have multiple indexes by adding extra
:class:`~Index` attributes


'''

from __future__ import print_function
from mongoalchemy.py3compat import *

import pymongo
from bson import DBRef
from pymongo import GEO2D
from collections import defaultdict
from mongoalchemy.util import classproperty, UNSET
from mongoalchemy.query_expression import QueryField
from mongoalchemy.fields import (ObjectIdField, Field, BadValueException,
                                 SCALAR_MODIFIERS, DocumentField)
from mongoalchemy.exceptions import DocumentException, MissingValueException, ExtraValueException, FieldNotRetrieved, BadFieldSpecification
from mongoalchemy.util import resolve_name, FieldNotFoundException

document_type_registry = defaultdict(dict)
collection_registry = defaultdict(dict)

class DocumentMeta(type):
    def __new__(mcs, classname, bases, class_dict):
        # Validate Config Options
        # print '-' * 20, classname, '-' * 20

        # Create Class
        class_dict['_subclasses'] = {}
        new_class = type.__new__(mcs, classname, bases, class_dict)

        if new_class.config_extra_fields not in ['error', 'ignore']:
            raise DocumentException("config_extra_fields must be one of: 'error', 'ignore'")

        # 1. Set up links between fields and the document class
        new_id = False
        for name, value in class_dict.items():
            if not isinstance(value, Field):
                continue
            if value.is_id and name != 'mongo_id':
                new_id = True
            value._set_name(name)
            value._set_parent(new_class)

        if new_id:
            new_class.mongo_id = None

        # 2. create a dict of fields to set on the object
        new_class._fields = {}
        for b in bases:
            # print b
            if not hasattr(b, 'get_fields'):
                continue
            for name, field in b.get_fields().items():
                new_class._fields[name] = field

        for name, maybefield in class_dict.items():
            if not isinstance(maybefield, Field):
                continue
            new_class._fields[name] = maybefield

        # 3.  Add subclasses
        for b in bases:
            if 'Document' in globals() and issubclass(b, Document):
                b.add_subclass(new_class)
            if not hasattr(b, 'config_polymorphic_collection'):
                continue
            if b.config_polymorphic_collection and 'config_collection_name' not in class_dict:
                new_class.config_collection_name = b.get_collection_name()

        # 4. register type
        if new_class.config_namespace is not None:
            name = new_class.config_full_name
            if name is None:
                name = new_class.__name__

            ns = new_class.config_namespace
            document_type_registry[ns][name] = new_class

            # if the new class uses a polymorphic collection we should only
            # set up the collection name to refer to the base class
            # TODO: if non-polymorphic classes use the collection registry they
            # will just overwrite for now.
            collection = new_class.get_collection_name()
            current = collection_registry[ns].get(collection)
            if current is None or issubclass(current, new_class):
                collection_registry[ns][collection] = new_class



        return new_class

@add_metaclass(DocumentMeta)
class Document(object):
    # __metaclass__ = DocumentMeta

    mongo_id = ObjectIdField(required=False, db_field='_id', on_update='ignore')
    ''' Default field for the mongo object ID (``_id`` in the database). This field
        is automatically set on objects when they are saved into the database.
        This field can be overridden in subclasses if the default ID is not
        acceptable '''

    config_namespace = 'global'
    ''' The namespace is used to determine how string class names should be
        looked up.  If an instance of DocumentField is created using a string,
        it will be looked up using the value of this variable and the string.
        To have more than one namespace create a subclass of Document
        overriding this class variable.  To turn off caching all together,
        create a subclass where namespace is set to None.  Doing this will
        disable using strings to look up document names, which will make
        creating self-referencing documents impossible.  The default value is
        "global"
    '''

    config_polymorphic = None
    ''' The variable to use when determining which class to instantiate a
        database object with.  It is the name of an attribute which
        will be used to decide the type of the object.  If you want more
        control over which class is selected, you can override
        ``get_subclass``.
    '''

    config_polymorphic_collection = False
    ''' Use the base class collection name for the subclasses.  Default: False
    '''

    config_polymorphic_identity = None
    ''' When using a string value with ``config_polymorphic_on`` in a parent
        class, this is the value that the attribute is compared to when
        determining
    '''

    config_full_name = None
    ''' If namespaces are being used, the key for a class is normally
        the class name.  In some cases the same class name may be used in
        different modules.  This field allows a longer unambiguous name
        to be given.  It may also be used in error messages or string
        representations of the class
    '''

    config_default_sort = None
    ''' The default sort to use when querying.  If set, this sort will be
        applied to any query which a sort isn't used on. The format is the
        same as pymongo.  Example ``[('foo', 1), ('bar', -1)]``.
    '''

    config_extra_fields = 'error'
    ''' Controls the method to use when dealing with fields passed in to the
        document constructor.  Possible values are 'error' and 'ignore'. Any
        fields which couldn't be mapped can be retrieved (and edited) using
        :func:`~Document.get_extra_fields` '''

    def __init__(self, retrieved_fields=None, loading_from_db=False, **kwargs):
        ''' :param retrieved_fields: The names of the fields returned when loading \
                a partial object.  This argument should not be explicitly set \
                by subclasses
            :param \*\*kwargs:  The values for all of the fields in the document. \
                Any additional fields will raise a :class:`~mongoalchemy.document.ExtraValueException` and \
                any missing (but required) fields will raise a :class:`~mongoalchemy.document.MissingValueException`. \
                Both types of exceptions are subclasses of :class:`~mongoalchemy.document.DocumentException`.
        '''
        self.partial = retrieved_fields is not None
        self.retrieved_fields = self.__normalize(retrieved_fields)

        # Mapping from attribute names to values.
        self._values = {}
        self.__extra_fields = {}

        cls = self.__class__

        # Process the fields on the object
        fields = self.get_fields()
        for name, field in fields.items():
            # print name
            if self.partial and field.db_field not in self.retrieved_fields:
                self._values[name] = Value(field, self, retrieved=False)
            elif name in kwargs:
                field = getattr(cls, name)
                value = kwargs[name]
                self._values[name] = Value(field, self,
                                           from_db=loading_from_db)
                getattr(cls, name).set_value(self, kwargs[name])
            elif field.auto:
                self._values[name] = Value(field, self, from_db=False)
            else:
                self._values[name] = Value(field, self, from_db=False)

        # Process any extra fields
        for k in kwargs:
            if k not in fields:
                if self.config_extra_fields == 'ignore':
                    self.__extra_fields[k] = kwargs[k]
                else:
                    raise ExtraValueException(k)

        self.__extra_fields_orig = dict(self.__extra_fields)

        # Validate defult sort
        if self.config_default_sort:
            for (name, direction) in self.config_default_sort:
                try:
                    resolve_name(type(self), name)
                    dirs = (1, -1, pymongo.ASCENDING, pymongo.DESCENDING)
                    if direction not in dirs:
                        m = 'Bad sort direction on %s: %s' % (name, direction)
                        raise BadFieldSpecification(m)
                except FieldNotFoundException:
                    raise BadFieldSpecification("Could not resolve field %s in"
                            " config_default_sort" % name)


    @classmethod
    def schema_json(cls):
        ret = dict(fields={},
                   config_namespace=cls.config_namespace,
                   config_polymorphic=cls.config_polymorphic,
                   config_polymorphic_collection=cls.config_polymorphic_collection,
                   config_polymorphic_identity=cls.config_polymorphic_identity,
                   config_full_name=cls.config_full_name,
                   config_extra_fields=cls.config_extra_fields)
        for f in cls.get_fields():
            ret['fields'][f] = getattr(cls, f).schema_json()
        return ret

    def __deepcopy__(self, memo):
        return type(self).unwrap(self.wrap(), session=self._get_session())

    @classmethod
    def add_subclass(cls, subclass):
        ''' Register a subclass of this class.  Maps the subclass to the
            value of subclass.config_polymorphic_identity if available.
        '''
        # if not polymorphic, stop
        if hasattr(subclass, 'config_polymorphic_identity'):
            attr = subclass.config_polymorphic_identity
            cls._subclasses[attr] = subclass


    @classmethod
    def get_subclass(cls, obj):
        ''' Get the subclass to use when instantiating a polymorphic object.
            The default implementation looks at ``cls.config_polymorphic``
            to get the name of an attribute.  Subclasses automatically
            register their value for that attribute on creation via their
            ``config_polymorphic_identity`` field.  This process is then
            repeated recursively until None is returned (indicating that the
            current class is the correct one)

            This method can be overridden to allow any method you would like
            to use to select subclasses. It should return either the subclass
            to use or None, if the original class should be used.
        '''
        if cls.config_polymorphic is None:
            return

        value = obj.get(cls.config_polymorphic)
        value = cls._subclasses.get(value)
        if value == cls or value is None:
            return None

        sub_value = value.get_subclass(obj)
        if sub_value is None:
            return value
        return sub_value
    def __eq__(self, other):
        try:
            return self.mongo_id == other.mongo_id
        except:
            return False
    def __ne__(self, other):
        return not self.__eq__(other)

    def get_dirty_ops(self, with_required=False):
        ''' Returns a dict with the update operations necessary to make the
            changes to this object to the database version.  It is mainly used
            internally for :func:`~mongoalchemy.session.Session.update` but
            may be useful for diagnostic purposes as well.

            :param with_required: Also include any field which is required.  This \
                is useful if the method is being called for the purposes of \
                an upsert where all required fields must always be sent.
        '''
        update_expression = {}
        for name, field in self.get_fields().items():
            if field.db_field == '_id':
                continue
            dirty_ops = field.dirty_ops(self)
            if not dirty_ops and with_required and field.required:
                dirty_ops = field.update_ops(self, force=True)
                if not dirty_ops:
                    raise MissingValueException(name)

            for op, values in dirty_ops.items():
                update_expression.setdefault(op, {})
                for key, value in values.items():
                    update_expression[op][key] = value

        if self.config_extra_fields == 'ignore':
            old_extrakeys = set(self.__extra_fields_orig.keys())
            cur_extrakeys = set(self.__extra_fields.keys())

            new_extrakeys = cur_extrakeys - old_extrakeys
            rem_extrakeys = old_extrakeys - cur_extrakeys
            same_extrakeys = cur_extrakeys & old_extrakeys

            update_expression.setdefault('$unset', {})
            for key in rem_extrakeys:
                update_expression['$unset'][key] = True

            update_expression.setdefault('$set', {})
            for key in new_extrakeys:
                update_expression['$set'][key] = self.__extra_fields[key]

            for key in same_extrakeys:
                if self.__extra_fields[key] != self.__extra_fields_orig[key]:
                    update_expression['$set'][key] = self.__extra_fields[key]

        return update_expression

    def get_extra_fields(self):
        ''' if :attr:`Document.config_extra_fields` is set to 'ignore', this method will return
            a dictionary of the fields which couldn't be mapped to the document.
        '''
        return self.__extra_fields

    @classmethod
    def get_fields(cls):
        ''' Returns a dict mapping the names of the fields in a document
            or subclass to the associated :class:`~mongoalchemy.fields.Field`
        '''
        return cls._fields

    @classmethod
    def class_name(cls):
        ''' Returns the name of the class. The name of the class is also the
            default collection name.

            .. seealso:: :func:`~Document.get_collection_name`
        '''
        return cls.__name__

    @classmethod
    def get_collection_name(cls):
        ''' Returns the collection name used by the class.  If the ``config_collection_name``
            attribute is set it is used, otherwise the name of the class is used.'''
        if not hasattr(cls, 'config_collection_name'):
            return cls.__name__
        return cls.config_collection_name

    @classmethod
    def get_indexes(cls):
        ''' Returns all of the :class:`~mongoalchemy.document.Index` instances
            for the current class.'''
        ret = []
        for name in dir(cls):
            field = getattr(cls, name)
            if isinstance(field, Index):
                ret.append(field)
        return ret
    @classmethod
    def transform_incoming(self, obj, session):
        """ Tranform the SON object into one which will be able to be
            unwrapped by this document class.

            This method is designed for schema migration systems.
        """
        return obj


    @classmethod
    def __normalize(cls, fields):
        if not fields:
            return fields
        ret = {}
        for f in fields:
            strf = str(f)
            if '.' in strf:
                first, _, second = strf.partition('.')
                ret.setdefault(first, []).append(second)
            else:
                ret[strf] = None
        return ret

    def has_id(self):
        try:
            getattr(self, 'mongo_id')
        except AttributeError:
            return False
        return True
    def to_ref(self, db=None):
        return DBRef(id=self.mongo_id,
                     collection=self.get_collection_name(),
                     database=db)
    def wrap(self):
        ''' Returns a transformation of this document into a form suitable to
            be saved into a mongo database.  This is done by using the ``wrap()``
            methods of the underlying fields to set values.'''
        res = {}
        for k, v in self.__extra_fields.items():
            res[k] = v
        cls = self.__class__
        for name in self.get_fields():
            field = getattr(cls, name)
            try:
                value = getattr(self, name)
                res[field.db_field] = field.wrap(value)
            except AttributeError as e:
                if field.required:
                    raise MissingValueException(name)
            except FieldNotRetrieved as fne:
                if field.required:
                    raise
        return res

    @classmethod
    def unwrap(cls, obj, fields=None, session=None):
        ''' Returns an instance of this document class based on the mongo object
            ``obj``.  This is done by using the ``unwrap()`` methods of the
            underlying fields to set values.

            :param obj: a ``SON`` object returned from a mongo database
            :param fields: A list of :class:`mongoalchemy.query.QueryField` objects \
                    for the fields to load.  If ``None`` is passed all fields  \
                    are loaded
            '''

        subclass = cls.get_subclass(obj)
        if subclass and subclass != cls:
            unwrapped = subclass.unwrap(obj, fields=fields, session=session)
            unwrapped._session = session
            return unwrapped
        # Get reverse name mapping
        name_reverse = {}
        for name, field in cls.get_fields().items():
            name_reverse[field.db_field] = name
        # Unwrap
        params = {}
        for k, v in obj.items():
            k = name_reverse.get(k, k)
            if not hasattr(cls, k) and cls.config_extra_fields:
                params[str(k)] = v
                continue

            field = getattr(cls, k)
            field_is_doc = fields is not None and isinstance(field.get_type(), DocumentField)

            extra_unwrap = {}
            if field.has_autoload:
                extra_unwrap['session'] = session
            if field_is_doc:
                normalized_fields = cls.__normalize(fields)
                unwrapped = field.unwrap(v, fields=normalized_fields.get(k), **extra_unwrap)
            else:
                unwrapped = field.unwrap(v, **extra_unwrap)
            unwrapped = field.localize(session, unwrapped)
            params[str(k)] = unwrapped

        if fields is not None:
            params['retrieved_fields'] = fields
        obj = cls(loading_from_db=True, **params)
        obj._mark_clean()
        obj._session = session
        return obj

    _session = None
    def _get_session(self):
        return self._session
    def _set_session(self, session):
        self._session = session

    def _mark_clean(self):
        for k, v in self._values.items():
            v.clear_dirty()


class DictDoc(object):
    ''' Adds a mapping interface to a document.  Supports ``__getitem__`` and
        ``__contains__``.  Both methods will only retrieve values assigned to
        a field, not methods or other attributes.
    '''
    def __getitem__(self, name):
        ''' Gets the field ``name`` from the document '''
        # fields = self.get_fields()
        if name in self._values:
            return getattr(self, name)
        raise KeyError(name)

    def __setitem__(self, name, value):
        ''' Sets the field ``name`` on the document '''
        setattr(self, name, value)

    def setdefault(self, name, value):
        ''' if the ``name`` is set, return its value.  Otherwse set ``name`` to
            ``value`` and return ``value``'''
        if name in self:
            return self[name]
        self[name] = value
        return self[name]

    def __contains__(self, name):
        ''' Return whether a field is present.  Fails if ``name`` is not a
            field or ``name`` is not set on the document or if ``name`` was
            not a field retrieved from the database
        '''
        try:
            self[name]
        except FieldNotRetrieved:
            return False
        except AttributeError:
            return False
        except KeyError:
            return False
        return True


class BadIndexException(Exception):
    pass

class Index(object):
    ''' This class is  used in the class definition of a :class:`~Document` to
        specify a single, possibly compound, index.  ``pymongo``'s ``ensure_index``
        will be called on each index before a database operation is executed
        on the owner document class.

        **Example**

            >>> class Donor(Document):
            ...     name = StringField()
            ...     age = IntField(min_value=0)
            ...     blood_type = StringField()
            ...
            ...     i_name = Index().ascending('name')
            ...     type_age = Index().ascending('blood_type').descending('age')
    '''
    ASCENDING = pymongo.ASCENDING
    DESCENDING = pymongo.DESCENDING

    def __init__(self):
        self.components = []
        self.__unique = False
        self.__drop_dups = False

        self.__min = None
        self.__max = None
        self.__bucket_size = None

        self.__expire_after = None

    def expire(self, after):
        '''Add an expire after option to the index

           :param: after: Number of second before expiration

        '''
        self.__expire_after = after
        return self


    def ascending(self, name):
        ''' Add a descending index for ``name`` to this index.

            :param name: Name to be used in the index
        '''
        self.components.append((name, Index.ASCENDING))
        return self

    def descending(self, name):
        ''' Add a descending index for ``name`` to this index.

            :param name: Name to be used in the index
        '''
        self.components.append((name, Index.DESCENDING))
        return self

    def geo2d(self, name, min=None, max=None):
        """ Create a 2d index.  See:
            http://www.mongodb.org/display/DOCS/Geospatial+Indexing

            :param name: Name of the indexed column
            :param min: minimum value for the index
            :param max: minimum value for the index
        """
        self.components.append((name, GEO2D))
        self.__min = min
        self.__max = max
        return self

    def geo_haystack(self, name, bucket_size):
        """ Create a Haystack index.  See:
            http://www.mongodb.org/display/DOCS/Geospatial+Haystack+Indexing

            :param name: Name of the indexed column
            :param bucket_size: Size of the haystack buckets (see mongo docs)
        """
        self.components.append((name, 'geoHaystack'))
        self.__bucket_size = bucket_size
        return self

    def unique(self, drop_dups=False):
        ''' Make this index unique, optionally dropping duplicate entries.

            :param drop_dups: Drop duplicate objects while creating the unique \
                index?  Default to ``False``
        '''
        self.__unique = True
        self.__drop_dups = drop_dups
        return self

    def ensure(self, collection):
        ''' Call the pymongo method ``ensure_index`` on the passed collection.

            :param collection: the ``pymongo`` collection to ensure this index \
                    is on
        '''
        extras = {}
        if self.__min is not None:
            extras['min'] = self.__min
        if self.__max is not None:
            extras['max'] = self.__max
        if self.__bucket_size is not None:
            extras['bucket_size'] = self.__bucket_size
        if self.__expire_after is not None:
            extras['expireAfterSeconds'] = self.__expire_after
        collection.ensure_index(self.components, unique=self.__unique,
            drop_dups=self.__drop_dups, **extras)
        return self

class Value(object):
    def __init__(self, field, document, from_db=False, extra=False,
                 retrieved=True):
        # Stuff
        self.field = field
        self.doc = document
        self.value = None

        # Flags
        self.from_db = from_db
        self.set = False
        self.extra = extra
        self.dirty = False
        self.retrieved = retrieved
        self.update_op = None
    def clear_dirty(self):
        self.dirty = False
        self.update_op = None

    def delete(self):
        self.value = None
        self.set = False
        self.dirty = True
        self.from_db = False
        self.update_op = '$unset'


########NEW FILE########
__FILENAME__ = exceptions
from __future__ import print_function
from mongoalchemy.py3compat import *

class BadValueException(Exception):
    ''' An exception which is raised when there is something wrong with a
        value'''
    def __init__(self, name, value, reason, cause=None):
        self.name = name
        self.value = value
        self.cause = cause
        message = 'Bad value for field of type "%s".  Reason: "%s".' % (name, reason)
        if cause is not None:
            message = '%s Cause: %s' % (message, cause)
        Exception.__init__(self, message)

class BadReferenceException(Exception):
    pass

class InvalidConfigException(Exception):
    ''' Raised when a bad value is passed in for a configuration that expects
        its values to obey certain constraints.'''
    pass

class DocumentException(Exception):
    ''' Base for all document-related exceptions'''
    pass

class MissingValueException(DocumentException):
    ''' Raised when a required field isn't set '''
    pass

class ExtraValueException(DocumentException):
    ''' Raised when a value is passed in with no corresponding field '''
    pass

class FieldNotRetrieved(DocumentException):
    ''' If a partial document is loaded from the database and a field which
        wasn't retrieved is accessed this exception is raised'''
    pass


class BadFieldSpecification(Exception):
    ''' An exception that is raised when there is an error in creating a
        field'''
    pass


class TransactionException(Exception):
    """ Exception which occurs when an invalid operation is called during a
        transaction """

class SessionCacheException(Exception):
    """ Exception when an error has occured with the MA caching mechanism """


########NEW FILE########
__FILENAME__ = base
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
'''

:class:`Field` objects transform python objects into objects which can
be stored as a value in a MongoDB document.  They control the conversions and
validation of the data.

If you want to define your own type of :class:`Field` there are four methods
a subclass must implement:

* :func:`Field.wrap` --- Takes a value and returns an object composed entirely \
    of types that MongoDB understands (dicts, lists, numbers, strings, datetimes, etc.)
* :func:`Field.unwrap` --- Takes a value in the format produced by :func:`~Field.wrap` and
    returns a python object.

:func:`~Field.wrap` and :func:`~Field.unwrap` should be inverse operations.
In particular, ``field.unwrap(field.wrap(obj))`` == obj should always be true.

* :func:`Field.validate_wrap` --- Raises a :class:`BadValueException` if calling :func:`~Field.wrap` will \
    fail.  This function should be fast, as it will be called whenever a value
    is set on a document for this type of field.
* :func:`Field.validate_unwrap` --- Raises a :class:`BadValueException` if calling :func:`~Field.unwrap` will \
    fail.

To just check whether something is valid for wrapping or unwrapping, each field has a
:func:`Field.is_valid_wrap` and an :func:`Field.is_valid_unwrap` function which call
their respective validation function, returning True if a
:class:`BadValueException` is not raised.


The documentation for each :class:`Field` class will largely just be giving the input and
output types for :func:`~Field.wrap` and :func:`~Field.unwrap`.

'''

from __future__ import print_function
from mongoalchemy.py3compat import *
import itertools
from datetime import datetime
from bson.objectid import ObjectId
from bson.binary import Binary
from bson.dbref import DBRef
import functools
from copy import deepcopy

from mongoalchemy.util import UNSET
from mongoalchemy.query_expression import QueryField
from mongoalchemy.exceptions import BadValueException, FieldNotRetrieved, InvalidConfigException, BadFieldSpecification, MissingValueException

SCALAR_MODIFIERS = set(['$set', '$unset'])
NUMBER_MODIFIERS = SCALAR_MODIFIERS | set(['$inc'])
LIST_MODIFIERS = SCALAR_MODIFIERS | set(['$push', '$addToSet', '$pull', '$pushAll', '$pullAll', '$pop'])
ANY_MODIFIER = LIST_MODIFIERS | NUMBER_MODIFIERS

class FieldMeta(type):
    def __new__(mcs, classname, bases, class_dict):

        def wrap_unwrap_wrapper(fun):
            def wrapped(self, value, *args, **kwds):
                if self._allow_none and value is None:
                    return None
                return fun(self, value, *args, **kwds)
            functools.update_wrapper(wrapped, fun, ('__name__', '__doc__'))
            return wrapped

        def validation_wrapper(fun, kind):
            def wrapped(self, value, *args, **kwds):
                # Handle None
                if self._allow_none and value is None:
                    return
                # Standard Field validation
                fun(self, value, *args, **kwds)

                # Universal user-supplied validator
                if self.validator:
                    if self.validator(value) == False:
                        self._fail_validation(value, 'user-supplied validator failed')

                if kind == 'unwrap' and self.unwrap_validator:
                    if self.unwrap_validator(value) == False:
                        self._fail_validation(value, 'user-supplied unwrap_validator failed')

                elif kind == 'wrap' and self.wrap_validator:
                    if self.wrap_validator(value) == False:
                        self._fail_validation(value, 'user-supplied wrap_validator failed')

            functools.update_wrapper(wrapped, fun, ('__name__', '__doc__'))
            return wrapped

        if 'wrap' in class_dict:
            class_dict['wrap'] = wrap_unwrap_wrapper(class_dict['wrap'])
        if 'unwrap' in class_dict:
            class_dict['unwrap'] = wrap_unwrap_wrapper(class_dict['unwrap'])

        if 'validate_wrap' in class_dict:
            class_dict['validate_wrap'] = validation_wrapper(class_dict['validate_wrap'], 'wrap')

        if 'validate_unwrap' in class_dict:
            class_dict['validate_unwrap'] = validation_wrapper(class_dict['validate_unwrap'], 'unwrap')

        # Create Class
        return type.__new__(mcs, classname, bases, class_dict)

@add_metaclass(FieldMeta)
class Field(object):
    auto = False

    #: If this kind of field can have sub-fields, this attribute should be True
    has_subfields = False

    #: If this kind of field can do extra requests, this attribute should be True
    has_autoload = False

    #: Is this a sequence?  used by elemMatch
    is_sequence_field = False

    no_real_attributes = False  # used for free-form queries.

    __metaclass__ = FieldMeta

    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, required=True, default=UNSET, default_f=None,
                 db_field=None, allow_none=False, on_update='$set',
                 validator=None, unwrap_validator=None, wrap_validator=None,
                 _id=False, proxy=None, iproxy=None, ignore_missing=False):
        '''
            :param required: The field must be passed when constructing a document (optional. default: ``True``)
            :param default:  Default value to use if one is not given (optional.)
            :param db_field: name to use when saving or loading this field from the database \
                (optional.  default is the name the field is assigned to on a documet)
            :param allow_none: allow ``None`` as a value (optional. default: False)
            :param validator: a callable which will be called on objects when wrapping/unwrapping
            :param unwrap_validator: a callable which will be called on objects when unwrapping
            :param wrap_validator: a callable which will be called on objects when wrapping
            :param _id: Set the db_field to _id.  If a field has this the "mongo_id" field will \
                also be removed from the document the field is on.

            The general validator is called after the field's validator, but before
            either of the wrap/unwrap versions.  The validator should raise a BadValueException
            if it fails, but if it returns False the field will raise an exception with
            a generic message.

        '''

        if _id and db_field is not None:
            raise InvalidConfigException('Cannot set db_field and _id on the same Field')
        if _id:
            self.__db_field = '_id'
        else:
            self.__db_field = db_field
        self.is_id = self.__db_field == '_id'
        self.__value = UNSET
        self.__update_op = UNSET

        self.proxy = proxy
        self.iproxy = iproxy
        self.ignore_missing = ignore_missing

        self.validator = validator
        self.unwrap_validator = unwrap_validator
        self.wrap_validator = wrap_validator

        self._allow_none = allow_none

        self.required = required
        self._default = default
        self._default_f = default_f
        if self._default_f and self._default != UNSET:
            raise InvalidConfigException('Only one of default and default_f '
                                         'is allowed')

        if default is None:
            self._allow_none = True
        self._owner = None

        if on_update not in self.valid_modifiers and on_update != 'ignore':
            raise InvalidConfigException('Unsupported update operation: %s'
                                         % on_update)
        self.on_update = on_update

        self._name =  'Unbound_%s' % self.__class__.__name__

    @property
    def default(self):
        if self._default_f:
            return self._default_f()
        return self._default

    def schema_json(self):
        schema = dict(
            type=type(self).__name__,
            required=self.required,
            db_field=self.__db_field,
            allow_none=self._allow_none,
            on_update=self.on_update,
            validator_set=self.validator is not None,
            unwrap_validator=self.unwrap_validator is not None,
            wrap_validator=self.wrap_validator is not None,
            ignore_missing=self.ignore_missing,
        )
        if self._default == UNSET and self._default_f is None:
            schema['default_unset'] = True
        elif self._default_f:
            schema['default_f'] = repr(self._default_f)
        else:
            schema['default'] = self.wrap(self._default)
        return schema


    def __get__(self, instance, owner):
        if instance is None:
            return QueryField(self)
        obj_value = instance._values[self._name]

        # if the value is set, just return it
        if obj_value.set:
            return instance._values[self._name].value

        # if not, try the default
        if self._default_f:
            self.set_value(instance, self._default_f())
            return instance._values[self._name].value
        elif self._default is not UNSET:
            self.set_value(instance, self._default)
            return instance._values[self._name].value

        # If this value wasn't retrieved, raise a specific exception
        if not obj_value.retrieved:
            raise FieldNotRetrieved(self._name)

        raise AttributeError(self._name)


    def __set__(self, instance, value):
        self.set_value(instance, value)

    def set_value(self, instance, value):
        self.validate_wrap(value)
        obj_value = instance._values[self._name]
        obj_value.value = value
        obj_value.dirty = True
        obj_value.set = True
        obj_value.from_db = False
        if self.on_update != 'ignore':
            obj_value.update_op = self.on_update

    def dirty_ops(self, instance):
        obj_value = instance._values[self._name]
        # op = instance._dirty.get(self._name)
        if obj_value.update_op == '$unset':
            return { '$unset' : { self._name : True } }
        if obj_value.update_op is None:
            return {}
        return {
            obj_value.update_op : {
                self.db_field : self.wrap(obj_value.value)
            }
        }

    def __delete__(self, instance):
        obj_value = instance._values[self._name]
        if not obj_value.set:
            raise AttributeError(self._name)
        obj_value.delete()
        # if self._name not in instance._field_values:
        #     raise AttributeError(self._name)
        # del instance._field_values[self._name]
        # instance._dirty[self._name] = '$unset'

    def update_ops(self, instance, force=False):
        obj_value = instance._values[self._name]
        if obj_value.set and (obj_value.dirty or force):
            return {
                self.on_update : {
                    self._name : self.wrap(obj_value.value)
                }
            }
        return {}

    def localize(self, session, value):
        return value

    @property
    def db_field(self):
        ''' The name to use when setting this field on a document.  If
            ``db_field`` is passed to the constructor, that is returned.  Otherwise
            the value is the name which this field was assigned to on the owning
            document.
        '''
        if self.__db_field is not None:
            return self.__db_field
        return self._name

    def wrap_value(self, value):
        ''' Wrap ``value`` for use as the value in a Mongo query, for example
            in $in'''
        return self.wrap(value)

    def _set_name(self, name):
        self._name = name

    def _set_parent(self, parent):
        self.parent = parent
        self.set_parent_on_subtypes(parent)

    def set_parent_on_subtypes(self, parent):
        ''' This function sets the parent on any sub-Fields of this field. It
            should be overridden by SequenceField and field which has subtypes
            (such as SequenceField and DictField).
        '''
        pass

    def wrap(self, value):
        ''' Returns an object suitable for setting as a value on a MongoDB object.
            Raises ``NotImplementedError`` in the base class.

            :param value: The value to convert.
        '''
        raise NotImplementedError()

    def unwrap(self, value, session=None):
        ''' Returns an object suitable for setting as a value on a subclass of
            :class:`~mongoalchemy.document.Document`.
            Raises ``NotImplementedError`` in the base class.

            :param value: The value to convert.
            '''
        raise NotImplementedError()

    def validate_wrap(self, value):
        ''' Called before wrapping.  Calls :func:`~Field.is_valid_wrap` and
            raises a :class:`BadValueException` if validation fails

            :param value: The value to validate
        '''
        raise NotImplementedError()

    def validate_unwrap(self, value):
        ''' Called before unwrapping.  Calls :func:`~Field.is_valid_unwrap` and raises
            a :class:`BadValueException` if validation fails

            .. note::
                ``is_valid_unwrap`` calls ``is_valid_wrap``, so any class without
                a is_valid_unwrap function is inheriting that behaviour.

            :param value: The value to check
        '''

        self.validate_wrap(value)

    def _fail_validation(self, value, reason='', cause=None):
        raise BadValueException(self._name, value, reason, cause=cause)

    def _fail_validation_type(self, value, *type):
        types = '\n'.join([str(t) for t in type])
        got = value.__class__.__name__
        raise BadValueException(self._name, value, 'Value is not an instance of %s (got: %s)' % (types, got))

    def is_valid_wrap(self, value):
        ''' Returns whether ``value`` is a valid value to wrap.
            Raises ``NotImplementedError`` in the base class.

            :param value: The value to check
        '''
        try:
            self.validate_wrap(value)
        except BadValueException:
            return False
        return True

    def is_valid_unwrap(self, value):
        ''' Returns whether ``value`` is a valid value to unwrap.
            Raises ``NotImplementedError`` in the base class.

            :param value: The value to check
        '''
        try:
            self.validate_unwrap(value)
        except BadValueException:
            return False
        return True


########NEW FILE########
__FILENAME__ = document_field
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.fields.base import *

class DocumentField(Field):
    ''' A field which wraps a :class:`Document`'''

    has_subfields = True
    has_autoload = True

    def __init__(self, document_class, **kwargs):
        super(DocumentField, self).__init__(**kwargs)
        self.__type = document_class

    def schema_json(self):
        super_schema = super(DocumentField, self).schema_json()
        subtype = str(self.type.__name__)
        namespace = self.type.config_namespace
        type = u'%s:%s' % (namespace, subtype)
        return dict(subtype=type, **super_schema)

    @property
    def type(self):
        from mongoalchemy.document import Document, document_type_registry
        if not isinstance(self.__type, basestring) and issubclass(self.__type, Document):
            return self.__type
        if self.parent and self.parent.config_namespace is None:
            raise BadFieldSpecification('Document namespace is None.  Strings are not allowed for DocumentFields')
        type = document_type_registry[self.parent.config_namespace].get(self.__type)
        if type is None or not issubclass(type, Document):
            raise BadFieldSpecification('No type found for %s.  Maybe it has not been imported yet and is not registered?' % self.__type)
        return type

    def dirty_ops(self, instance):
        ''' Returns a dict of the operations needed to update this object.
            See :func:`Document.get_dirty_ops` for more details.'''
        obj_value = instance._values[self._name]
        if not obj_value.set:
            return {}

        if not obj_value.dirty and self.__type.config_extra_fields != 'ignore':
            return {}

        ops = obj_value.value.get_dirty_ops()

        ret = {}
        for op, values in ops.items():
            ret[op] = {}
            for key, value in values.items():
                name = '%s.%s' % (self._name, key)
                ret[op][name] = value
        return ret

    def subfields(self):
        ''' Returns the fields that can be retrieved from the enclosed
            document.  This function is mainly used internally'''
        return self.type.get_fields()

    def sub_type(self):
        return self.type

    def is_valid_unwrap(self, value, fields=None):
        ''' Always True.  Document-level validation errors will
            be handled during unwrappingself.

            :param value: The value to validate
            :param fields: The fields being returned if this is a partial \
                document. They will be ignored when validating the fields \
                of ``value``
        '''
        return True

    def wrap(self, value):
        ''' Validate ``value`` and then use the document's class to wrap the
            value'''
        self.validate_wrap(value)
        return self.type.wrap(value)

    def unwrap(self, value, fields=None, session=None):
        ''' Validate ``value`` and then use the document's class to unwrap the
            value'''
        self.validate_unwrap(value, fields=fields, session=session)
        return self.type.unwrap(value, fields=fields, session=session)

    def validate_wrap(self, value):
        ''' Checks that ``value`` is an instance of ``DocumentField.type``.
            if it is, then validation on its fields has already been done and
            no further validation is needed.
        '''
        if not isinstance(value, self.type):
            self._fail_validation_type(value, self.type)

    def validate_unwrap(self, value, fields=None, session=None):
        ''' Validates every field in the underlying document type.  If ``fields``
            is not ``None``, only the fields in ``fields`` will be checked.
        '''
        return

########NEW FILE########
__FILENAME__ = fields
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.fields.base import *


class PrimitiveField(Field):
    ''' Primitive fields are fields where a single constructor can be used
        for wrapping and unwrapping an object.'''

    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, constructor, **kwargs):
        super(PrimitiveField, self).__init__(**kwargs)
        self.constructor = constructor

    def wrap(self, value):
        self.validate_wrap(value)
        return self.constructor(value)
    def unwrap(self, value, session=None):
        self.validate_unwrap(value)
        return self.constructor(value)

class StringField(PrimitiveField):
    ''' Unicode Strings.  ``unicode`` is used to wrap and unwrap values,
        and any subclass of basestring is an acceptable input'''
    def __init__(self, max_length=None, min_length=None, **kwargs):
        ''' :param max_length: maximum string length
            :param min_length: minimum string length
            :param kwargs: arguments for :class:`Field`
        '''
        self.max = max_length
        self.min = min_length
        super(StringField, self).__init__(constructor=unicode, **kwargs)

    def validate_wrap(self, value):
        ''' Validates the type and length of ``value`` '''
        if not isinstance(value, basestring):
            self._fail_validation_type(value, basestring)
        if self.max is not None and len(value) > self.max:
            self._fail_validation(value, 'Value too long (%d)' % len(value))
        if self.min is not None and len(value) < self.min:
            self._fail_validation(value, 'Value too short (%d)' % len(value))

class RegExStringField(PrimitiveField):
    ''' Unicode Strings.  ``unicode`` is used to wrap and unwrap values,
        and any subclass of basestring is an acceptable input, as long as
        it matches the provided regex.'''
    def __init__(self, regex, **kwargs):
        ''' :param regex: instance of :class: `RegexObject` to match against
            :param kwargs: arguments for :class:`Field`
        '''
        self.regex = regex
        super(RegExStringField, self).__init__(constructor=unicode, **kwargs)

    def validate_wrap(self, value):
        ''' Validates the type and length of ``value`` '''
        if not isinstance(value, basestring):
            self._fail_validation_type(value, basestring)
        if self.regex.match(value) is None:
            self._fail_validation(value, 'Value does not match regular expression')

class BinaryField(PrimitiveField):
    def __init__(self, **kwargs):
        super(BinaryField, self).__init__(constructor=Binary, **kwargs)

    def validate_wrap(self, value):
        if not isinstance(value, bytes) and not isinstance(value, Binary):
            self._fail_validation_type(value, str, Binary)

class BoolField(PrimitiveField):
    ''' ``True`` or ``False``.'''
    def __init__(self, **kwargs):
        super(BoolField, self).__init__(constructor=bool, **kwargs)
    def validate_wrap(self, value):
        if not isinstance(value, bool):
            self._fail_validation_type(value, bool)

class NumberField(PrimitiveField):
    ''' Base class for numeric fields '''

    valid_modifiers = NUMBER_MODIFIERS

    def __init__(self, constructor, min_value=None, max_value=None, **kwargs):
        ''' :param max_value: maximum value
            :param min_value: minimum value
            :param kwargs: arguments for :class:`Field`
        '''
        super(NumberField, self).__init__(constructor=constructor, **kwargs)
        self.min = min_value
        self.max = max_value

    def schema_json(self):
        super_schema = super(NumberField, self).schema_json()
        return dict(min_value=self.min,
                    max_value=self.max, **super_schema)

    def validate_wrap(self, value, *types):
        ''' Validates the type and value of ``value`` '''
        for type in types:
            if isinstance(value, type):
                break
        else:
            self._fail_validation_type(value, *types)

        if self.min is not None and value < self.min:
            self._fail_validation(value, 'Value too small')
        if self.max is not None and value > self.max:
            self._fail_validation(value, 'Value too large')

class IntField(NumberField):
    ''' Subclass of :class:`~NumberField` for ``int``'''
    def __init__(self, **kwargs):
        ''' :param max_length: maximum value
            :param min_length: minimum value
            :param kwargs: arguments for :class:`Field`
        '''
        super(IntField, self).__init__(constructor=int, **kwargs)
    def validate_wrap(self, value):
        ''' Validates the type and value of ``value`` '''
        NumberField.validate_wrap(self, value, int, long)

class FloatField(NumberField):
    ''' Subclass of :class:`~NumberField` for ``float`` '''
    def __init__(self, **kwargs):
        ''' :param max_value: maximum value
            :param min_value: minimum value
            :param kwargs: arguments for :class:`Field`
        '''
        super(FloatField, self).__init__(constructor=float, **kwargs)
    def validate_wrap(self, value):
        ''' Validates the type and value of ``value`` '''
        return NumberField.validate_wrap(self, value, float, int)

class DateTimeField(PrimitiveField):
    ''' Field for datetime objects. '''

    has_autoload = True

    def __init__(self, min_date=None, max_date=None, use_tz=False, **kwargs):
        ''' :param max_date: maximum date
            :param min_date: minimum date
            :param use_tz: Require a timezone-aware datetime (via pytz).
                Values are converted to UTC before saving.  min and max dates
                are currently ignored when use_tz is on.  You MUST pass a
                timezone into the session
            :param kwargs: arguments for :class:`Field`
        '''
        super(DateTimeField, self).__init__(lambda dt : dt, **kwargs)
        self.min = min_date
        self.max = max_date
        self.use_tz = use_tz
        if self.use_tz:
            import pytz
            self.utc = pytz.utc
            assert self.min is None and self.max is None
    def schema_json(self):
        super_schema = super(DateTimeField, self).schema_json()
        return dict(min_date=self.min,
                    max_date=self.max,
                    use_tz=self.use_tz, **super_schema)

    def wrap(self, value):
        self.validate_wrap(value)
        value = self.constructor(value)
        if self.use_tz:
            return value
        return value
    def unwrap(self, value, session=None):
        self.validate_unwrap(value)
        value = self.constructor(value)
        if value.tzinfo is not None:
            import pytz
            value = value.replace(tzinfo=pytz.utc)
            if session and session.timezone:
                value = value.astimezone(session.timezone)
        return value

    def localize(self, session, value):
        if not self.use_tz:
            return value
        return value.astimezone(session.timezone)

    def validate_wrap(self, value):
        ''' Validates the value's type as well as it being in the valid
            date range'''
        if not isinstance(value, datetime):
            self._fail_validation_type(value, datetime)

        if self.use_tz and value.tzinfo is None:
            self._fail_validation(value, '''datetime is not timezone aware and use_tz is on.  make sure timezone is set on the session''')

        # if using timezone support it isn't clear how min and max should work,
        # so the problem is being punted on for now.
        if self.use_tz:
            return

        # min/max
        if self.min is not None and value < self.min:
            self._fail_validation(value, 'DateTime too old')
        if self.max is not None and value > self.max:
            self._fail_validation(value, 'DateTime too new')

class TupleField(Field):
    ''' Represents a field which is a tuple of a fixed size with specific
        types for each element in the field.

        **Examples** ``TupleField(IntField(), BoolField())`` would accept
        ``[19, False]`` as a value for both wrapping and unwrapping. '''

    # uses scalar modifiers since it is not variable length
    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, *item_types, **kwargs):
        ''' :param item_types: instances of :class:`Field`, in the order they \
                    will appear in the tuples.
            :param kwargs: arguments for :class:`Field`
        '''
        super(TupleField, self).__init__(**kwargs)
        self.size = len(item_types)
        self.types = item_types

    def schema_json(self):
        super_schema = super(TupleField, self).schema_json()
        types = [t.schema_json() for t in self.types]
        return dict(types=types, **super_schema)

    def set_parent_on_subtypes(self, parent):
        for type in self.types:
            type._set_parent(parent)

    def validate_wrap(self, value):
        ''' Checks that the correct number of elements are in ``value`` and that
            each element validates agains the associated Field class
        '''
        if not isinstance(value, list) and not isinstance(value, tuple):
            self._fail_validation_type(value, tuple, list)

        for field, value in izip(self.types, list(value)):
            field.validate_wrap(value)

    def validate_unwrap(self, value):
        ''' Checks that the correct number of elements are in ``value`` and that
            each element validates agains the associated Field class
        '''
        if not isinstance(value, list) and not isinstance(value, tuple):
            self._fail_validation_type(value, tuple, list)

        for field, value in izip(self.types, value):
            field.validate_unwrap(value)

    def wrap(self, value):
        ''' Validate and then wrap ``value`` for insertion.

            :param value: the tuple (or list) to wrap
        '''
        self.validate_wrap(value)
        ret = []
        for field, value in izip(self.types, value):
            ret.append(field.wrap(value))
        return ret

    def unwrap(self, value, session=None):
        ''' Validate and then unwrap ``value`` for object creation.

            :param value: list returned from the database.
        '''
        self.validate_unwrap(value)
        ret = []
        for field, value in izip(self.types, value):
            ret.append(field.unwrap(value, session=session))
        return tuple(ret)

class GeoField(TupleField):
    def __init__(self, **kwargs):
        ''' :param item_types: instances of :class:`Field`, in the order they \
                    will appear in the tuples.
            :param kwargs: arguments for :class:`Field`
        '''
        super(GeoField, self).__init__(FloatField(), FloatField(), **kwargs)
    def schema_json(self):
        super_schema = super(GeoField, self).schema_json()
        return dict(**super_schema)


class EnumField(Field):
    ''' Represents a single value out of a list of possible values, all
        of the same type. == is used for comparison

        **Example**: ``EnumField(IntField(), 4, 6, 7)`` would accept anything
        in ``(4, 6, 7)`` as a value.  It would not accept ``5``.
        '''

    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, item_type, *values, **kwargs):
        ''' :param item_type: Instance of :class:`Field` to use for validation, and (un)wrapping
            :param values: Possible values.  ``item_type.is_valid_wrap(value)`` should be ``True``
        '''
        super(EnumField, self).__init__(**kwargs)
        self.item_type = item_type
        self.values = values
        # Jan 22, 2011: Commenting this out.  We already check that the value
        # is the right type, and that it is equal to one of the enum values.
        # If those are true, the enum values are the right type.  If we do it
        # now it causes validation issues in some cases with the
        # string-reference document fields
        #
        # for value in values:
        #     self.item_type.validate_wrap(value)
    def schema_json(self):
        super_schema = super(EnumField, self).schema_json()
        return dict(item_type=self.item_type.schema_json(),
                    values=[self.item_type.wrap(v) for v in self.values],
                    **super_schema)

    def set_parent_on_subtypes(self, parent):
        self.item_type._set_parent(parent)

    def validate_wrap(self, value):
        ''' Checks that value is valid for `EnumField.item_type` and that
            value is one of the values specified when the EnumField was
            constructed '''
        self.item_type.validate_wrap(value)

        if value not in self.values:
            self._fail_validation(value, 'Value was not in the enum values')

    def validate_unwrap(self, value):
        ''' Checks that value is valid for `EnumField.item_type`.

            .. note ::
                Since checking the value itself is not possible until is is
                actually unwrapped, that check is done in :func:`EnumField.unwrap`'''
        self.item_type.validate_unwrap(value)

    def wrap(self, value):
        ''' Validate and wrap value using the wrapping function from
            ``EnumField.item_type``
        '''
        self.validate_wrap(value)
        return self.item_type.wrap(value)

    def unwrap(self, value, session=None):
        ''' Unwrap value using the unwrap function from ``EnumField.item_type``.
            Since unwrap validation could not happen in is_valid_wrap, it
            happens in this function.'''
        self.validate_unwrap(value)
        value = self.item_type.unwrap(value, session=session)
        for val in self.values:
            if val == value:
                return val
        self._fail_validation(value, 'Value was not in the enum values')


class AnythingField(Field):
    ''' A field that passes through whatever is set with no validation.  Useful
        for free-form objects '''

    valid_modifiers = ANY_MODIFIER
    def schema_json(self):
        return super(AnythingField, self).schema_json()

    def wrap(self, value):
        ''' Always returns the value passed in'''
        return value

    def unwrap(self, value, session=None):
        ''' Always returns the value passed in'''
        return value

    def validate_unwrap(self, value):
        ''' Always passes'''
        pass
    def validate_wrap(self, value):
        ''' Always passes'''
        pass

class ObjectIdField(Field):
    ''' pymongo Object ID object.  Currently this is probably too strict.  A
        string version of an ObjectId should also be acceptable'''

    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, session=None, auto=False, **kwargs):
        if auto:
            kwargs['default_f'] = lambda : ObjectId()
        super(ObjectIdField, self).__init__(**kwargs)
    def schema_json(self):
        super_schema = super(ObjectIdField, self).schema_json()
        return dict(auth=self.auto, **super_schema)

    # def set_default(self, value):
    #     super(ObjectIdField, self).set_default(value)
    # def get_default(self):
    #     if self.auto:
    #         self.set_default(ObjectId())
    #     return super(ObjectIdField, self).get_default()
    # default = property(get_default, set_default)

    def gen(self):
        """ Helper method to create a new ObjectId """
        return ObjectId()

    def validate_wrap(self, value):
        ''' Checks that ``value`` is a pymongo ``ObjectId`` or a string
            representation of one'''
        if (not isinstance(value, ObjectId)
                and not isinstance(value, basestring)
                and not isinstance(value, bytes)
            ):
            self._fail_validation_type(value, ObjectId)
        if isinstance(value, ObjectId):
            return
        #: bytes
        if len(value) == 12:
            return
        # hex
        if len(value) != 24:
            self._fail_validation(value, 'hex object ID is the wrong length')

    def wrap(self, value, session=None):
        ''' Validates that ``value`` is an ObjectId (or hex representation
            of one), then returns it '''
        self.validate_wrap(value)
        if isinstance(value, bytes) or isinstance(value, basestring):
            return ObjectId(value)
        return value

    def unwrap(self, value, session=None):
        ''' Validates that ``value`` is an ObjectId, then returns it '''
        self.validate_unwrap(value)
        return value

class ComputedField(Field):
    ''' A computed field is generated based on an object's other values.  It
        will generally be created with the @computed_field decorator, but
        can be passed an arbitrary function.

        The function should take a dict which will contains keys with the names
        of the dependencies mapped to their values.

        The computed value is recalculated every the field is accessed unless
        the one_time field is set to True.

        Example::

            >>> class SomeDoc(Document):
            ...     @computed_field
            ...     def last_modified(obj):
            ...         return datetime.datetime.utcnow()


        .. warning::
            The computed field interacts in an undefined way with partially loaded
            documents right now.  If using this class watch out for strange behaviour.
    '''

    valid_modifiers = SCALAR_MODIFIERS

    auto = True
    def __init__(self, computed_type, fun, one_time=False, deps=None, **kwargs):
        ''' :param fun: the function to compute the value of the computed field
            :param computed_type: the type to use when wrapping the computed field
            :param deps: the names of fields on the current object which should be \
                passed in to compute the value
        '''
        super(ComputedField, self).__init__(**kwargs)
        self.computed_type = computed_type
        if deps is None:
            deps = set()
        self.deps = set(deps)
        self.fun = fun
        self.one_time = one_time
        self.__cached_value = UNSET

    def schema_json(self):
        super_schema = super(ComputedField, self).schema_json()
        return dict(computed_type=self.computed_type.schema_json(),
                    one_time=self.one_time,
                    deps=list(self.deps), **super_schema)


    def __get__(self, instance, owner):
        # class method
        if instance is None:
            return QueryField(self)

        obj_value = instance._values[self._name]
        if obj_value.set and self.one_time:
            return obj_value.value
        computed_value = self.compute_value(instance)
        if self.one_time:
            self.set_value(instance, computed_value)
        return computed_value

    def __set__(self, instance, value):
        obj_value = instance._values[self._name]
        if obj_value.set and self.one_time:
            raise BadValueException(self._name, value, 'Cannot set a one-time field once it has been set')
        super(ComputedField, self).__set__(instance, value)

    def set_parent_on_subtypes(self, parent):
        self.computed_type._set_parent(parent)

    def dirty_ops(self, instance):
        dirty = False
        for dep in self.deps:
            dep_value = instance._values[dep._name]
            if dep_value.dirty:
                dirty = True
                break
        else:
            if len(self.deps) > 0:
                return {}

        return {
            self.on_update : {
                self._name : self.wrap(getattr(instance, self._name))
            }
        }

    def compute_value(self, doc):
        args = {}
        for dep in self.deps:
            args[dep._name] = getattr(doc, dep._name)
        value = self.fun(args)
        try:
            self.computed_type.validate_wrap(value)
        except BadValueException as bve:
            self._fail_validation(value, 'Computed Function return a bad value', cause=bve)
        return value

    def wrap_value(self, value):
        ''' A function used to wrap a value used in a comparison.  It will
            first try to wrap as the sequence's sub-type, and then as the
            sequence itself'''
        return self.computed_type.wrap_value(value)

    def validate_wrap(self, value):
        ''' Check that ``value`` is valid for unwrapping with ``ComputedField.computed_type``'''
        try:
            self.computed_type.validate_wrap(value)
        except BadValueException as bve:
            self._fail_validation(value, 'Bad value for computed field', cause=bve)

    def validate_unwrap(self, value):
        ''' Check that ``value`` is valid for unwrapping with ``ComputedField.computed_type``'''
        try:
            self.computed_type.validate_unwrap(value)
        except BadValueException as bve:
            self._fail_validation(value, 'Bad value for computed field', cause=bve)

    def wrap(self, value):
        ''' Validates ``value`` and wraps it with ``ComputedField.computed_type``'''
        self.validate_wrap(value)
        return self.computed_type.wrap(value)

    def unwrap(self, value, session=None):
        ''' Validates ``value`` and unwraps it with ``ComputedField.computed_type``'''
        self.validate_unwrap(value)
        return self.computed_type.unwrap(value, session=session)

class computed_field(object):
    def __init__(self, computed_type, deps=None, **kwargs):
        self.computed_type = computed_type
        self.deps = deps
        self.kwargs = kwargs

    def __call__(self, fun):
        return ComputedField(self.computed_type, fun, deps=self.deps, **self.kwargs)

def CreatedField(name='created', tz_aware=False):
    ''' A shortcut field for creation time.  It sets the current date and time
        when it enters the database and then doesn't update on further saves.

        If you've used the Django ORM, this is the equivalent of auto_now_add

        :param tz_aware: If this is True, the value will be returned in the
                         local time of the session.  It is always saved in UTC
    '''
    @computed_field(DateTimeField(), one_time=True)
    def created(obj):
        if tz_aware:
            import pytz
            return pytz.utc.localize(datetime.utcnow())
        return datetime.utcnow()
    created.__name__ = name
    return created

def ModifiedField(name='modified', tz_aware=False):
    ''' A shortcut field for modified time.  It sets the current date and time
        when it enters the database and then updates when the document is
        saved or updated

        If you've used the Django ORM, this is the equivalent of auto_now

        :param tz_aware: If this is True, the value will be returned in the
                         local time of the session.  It is always saved in UTC
    '''
    @computed_field(DateTimeField())
    def modified(obj):
        if tz_aware:
            import pytz
            return pytz.utc.localize(datetime.utcnow())
        return datetime.utcnow()
    modified.__name__ = name
    return modified


########NEW FILE########
__FILENAME__ = mapping
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.fields.base import *


class DictField(Field):
    ''' Stores String to ``value_type`` Dictionaries.  For non-string keys use
        :class:`KVField`.  Strings also must obey the mongo key rules
        (no ``.`` or ``$``)
        '''

    valid_modifiers = SCALAR_MODIFIERS

    def __init__(self, value_type, default_empty=False, **kwargs):
        ''' :param value_type: the Field type to use for the values
        '''
        if default_empty:
            kwargs['default_f'] = dict
        super(DictField, self).__init__(**kwargs)
        self.value_type = value_type
        self.default_empty = default_empty

        if not isinstance(value_type, Field):
            raise BadFieldSpecification("DictField value type is not a field!")
    # def set_default(self, value):
    #     return super(DictField, self).set_default(value)
    # def get_default(self):
    #     if self.default_empty:
    #         return {}
    #     return super(DictField, self).get_default()
    # default = property(get_default, set_default)
    def schema_json(self):
        super_schema = super(DictField, self).schema_json()
        return dict(value_type=self.value_type.schema_json(),
                    default_empty=self.default_empty,
                    **super_schema)

    @property
    def has_autoload(self):
        return self.value_type.has_autoload

    def set_parent_on_subtypes(self, parent):
        self.value_type._set_parent(parent)

    def _validate_key_wrap(self, key):
        if not isinstance(key, basestring):
            self._fail_validation(key, 'DictField keys must be of type basestring')
        if  '.' in key or '$' in key:
            self._fail_validation(key, 'DictField keys cannot contains "." or "$".  You may want a KVField instead')

    def _validate_key_unwrap(self, key):
        self._validate_key_wrap(key)


    def validate_unwrap(self, value):
        ''' Checks that value is a ``dict``, that every key is a valid MongoDB
            key, and that every value validates based on DictField.value_type
        '''
        if not isinstance(value, dict):
            self._fail_validation_type(value, dict)
        for k, v in value.items():
            self._validate_key_unwrap(k)
            try:
                self.value_type.validate_unwrap(v)
            except BadValueException as bve:
                self._fail_validation(value, 'Bad value for key %s' % k, cause=bve)

    def validate_wrap(self, value):
        ''' Checks that value is a ``dict``, that every key is a valid MongoDB
            key, and that every value validates based on DictField.value_type
        '''
        if not isinstance(value, dict):
            self._fail_validation_type(value, dict)
        for k, v in value.items():
            self._validate_key_wrap(k)
            try:
                self.value_type.validate_wrap(v)
            except BadValueException as bve:
                self._fail_validation(value, 'Bad value for key %s' % k, cause=bve)

    def wrap(self, value):
        ''' Validates ``value`` and then returns a dictionary with each key in
            ``value`` mapped to its value wrapped with ``DictField.value_type``
        '''
        self.validate_wrap(value)
        ret = {}
        for k, v in value.items():
            ret[k] = self.value_type.wrap(v)
        return ret

    def unwrap(self, value, session=None):
        ''' Validates ``value`` and then returns a dictionary with each key in
            ``value`` mapped to its value unwrapped using ``DictField.value_type``
        '''
        self.validate_unwrap(value)
        ret = {}
        for k, v in value.items():
            ret[k] = self.value_type.unwrap(v, session=session)
        return ret

class KVField(DictField):
    ''' Like a DictField, except it allows arbitrary keys.  The DB Format for
        a ``KVField`` is ``[ { 'k' : key, 'v' : value }, ...]``.  Queries on
        keys and values. can be done with ``.k`` and ``.v`` '''
    #: If this kind of field can have sub-fields, this attribute should be True
    has_subfields = True

    def __init__(self, key_type, value_type, default_empty=False, **kwargs):
        ''' :param key_type: the Field type to use for the keys
            :param value_type: the Field type to use for the values
        '''
        if default_empty:
            kwargs['default_f'] = dict
        super(KVField, self).__init__(value_type, **kwargs)
        self.default_empty = default_empty

        if not isinstance(key_type, Field):
            raise BadFieldSpecification("KVField key type is not a field!")
        # This is covered by DictField
        # if not isinstance(value_type, Field):
        #     raise BadFieldSpecification("KVField value type is not a field!")
        self.key_type = key_type
        self.key_type._name = 'k'

        self.value_type = value_type
        self.value_type._name = 'v'
    def schema_json(self):
        super_schema = super(KVField, self).schema_json()
        return dict(key_type=self.key_type.schema_json(), **super_schema)

    def set_parent_on_subtypes(self, parent):
        self.value_type._set_parent(parent)
        self.key_type._set_parent(parent)
    @property
    def has_autoload(self):
        return self.value_type.has_autoload or self.key_type.has_autoload

    def subfields(self):
        ''' Returns the k and v subfields, which can be accessed to do queries
            based on either of them
        '''
        return {
            'k' : self.key_type,
            'v' : self.value_type,
        }

    def _validate_key_wrap(self, key):
        try:
            self.key_type.validate_wrap(key)
        except BadValueException as bve:
            self._fail_validation(key, 'Bad value for key', cause=bve)

    def validate_unwrap(self, value):
        ''' Expects a list of dictionaries with ``k`` and ``v`` set to the
            keys and values that will be unwrapped into the output python
            dictionary should have
        '''

        if not isinstance(value, list):
            self._fail_validation_type(value, list)
        for value_dict in value:
            if not isinstance(value_dict, dict):
                cause = BadValueException('', value_dict, 'Values in a KVField list must be dicts')
                self._fail_validation(value, 'Values in a KVField list must be dicts', cause=cause)
            k = value_dict.get('k')
            v = value_dict.get('v')
            if k is None:
                self._fail_validation(value, 'Value had None for a key')
            try:
                self.key_type.validate_unwrap(k)
            except BadValueException as bve:
                self._fail_validation(value, 'Bad value for KVField key %s' % k, cause=bve)

            try:
                self.value_type.validate_unwrap(v)
            except BadValueException as bve:
                self._fail_validation(value, 'Bad value for KFVield value %s' % k, cause=bve)
        return True

    def wrap(self, value):
        ''' Expects a dictionary with the keys being instances of ``KVField.key_type``
            and the values being instances of ``KVField.value_type``.  After validation,
            the dictionary is transformed into a list of dictionaries with ``k`` and ``v``
            fields set to the keys and values from the original dictionary.
        '''
        self.validate_wrap(value)
        ret = []
        for k, v in value.items():
            k = self.key_type.wrap(k)
            v = self.value_type.wrap(v)
            ret.append( { 'k' : k, 'v' : v })
        return ret

    def unwrap(self, value, session=None):
        ''' Expects a list of dictionaries with ``k`` and ``v`` set to the
            keys and values that will be unwrapped into the output python
            dictionary should have.  Validates the input and then constructs the
            dictionary from the list.
        '''
        self.validate_unwrap(value)
        ret = {}
        for value_dict in value:
            k = value_dict['k']
            v = value_dict['v']
            ret[self.key_type.unwrap(k, session=session)] = self.value_type.unwrap(v, session=session)
        return ret


########NEW FILE########
__FILENAME__ = ref
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.fields.base import *
from bson import DBRef

class RefBase(Field):
    def rel(self, allow_none=False):
        """ Used to create an attribute which will auto-dereference
            a RefField or SRefField.

            **Example**::

                employer_ref = SRefField(Employer)
                employer = employer_ref.rel()

        """
        return Proxy(self, allow_none=allow_none)

class SRefField(RefBase):
    ''' A Simple RefField (SRefField) looks like an ObjectIdField in the
        database, but acts like a mongo DBRef.  It uses the passed in type to
        determine where to look for the object (and assumes the current
        database).
    '''
    has_subfields = True
    has_autoload = True
    def __init__(self, type, db=None, **kwargs):
        from mongoalchemy.fields import DocumentField

        super(SRefField, self).__init__(**kwargs)

        self.type = type
        if not isinstance(type, DocumentField):
            self.type = DocumentField(type)
        self.db = db
    def schema_json(self):
        super_schema = super(SRefField, self).schema_json()
        return dict(subtype=self.type.schema_json(),
                    db=self.db, **super_schema)
    def _to_ref(self, doc):
        return doc.mongo_id
    def dereference(self, session, ref, allow_none=False):
        """ Dereference an ObjectID to this field's underlying type """
        ref = DBRef(id=ref, collection=self.type.type.get_collection_name(),
                    database=self.db)
        ref.type = self.type.type
        return session.dereference(ref, allow_none=allow_none)
    def set_parent_on_subtypes(self, parent):
        self.type.parent = parent
    def wrap(self, value):
        self.validate_wrap(value)
        return value
    def unwrap(self, value, fields=None, session=None):
        self.validate_unwrap(value)
        return value
    def validate_unwrap(self, value, session=None):
        if not isinstance(value, ObjectId):
            self._fail_validation_type(value, ObjectId)
    validate_wrap = validate_unwrap


class RefField(RefBase):
    ''' A ref field wraps a mongo DBReference.  It DOES NOT currently handle
        saving the referenced object or updates to it, but it can handle
        auto-loading.
    '''
    #: If this kind of field can have sub-fields, this attribute should be True
    has_subfields = True
    has_autoload = True

    def __init__(self, type=None, db=None, db_required=False, namespace='global', **kwargs):
        ''' :param type: (optional) the Field type to use for the values.  It
                must be a DocumentField.  If you want to save refs to raw mongo
                objects, you can leave this field out
            :param db: (optional) The database to load the object from.
                Defaults to the same database as the object this field is
                bound to.
            :param namespace: If using the namespace system and using a
                collection name instead of a type, selects which namespace to
                use
        '''
        from mongoalchemy.fields import DocumentField
        if type and not isinstance(type, DocumentField):
            type = DocumentField(type)

        super(RefField, self).__init__(**kwargs)
        self.db_required = db_required
        self.type = type
        self.namespace = namespace
        self.db = db
        self.parent = None

    def schema_json(self):
        super_schema = super(RefField, self).schema_json()
        subtype = self.type
        if subtype is not None:
            subtype = subtype.schema_json()
        return dict(db_required=self.db_required,
                    subtype=subtype,
                    namespace=self.namespace,
                    db=self.db, **super_schema)

    def wrap(self, value):
        ''' Validate ``value`` and then use the value_type to wrap the
            value'''

        self.validate_wrap(value)
        value.type = self.type
        return value

    def _to_ref(self, doc):
        return doc.to_ref(db=self.db)

    def unwrap(self, value, fields=None, session=None):
        ''' If ``autoload`` is False, return a DBRef object.  Otherwise load
            the object.
        '''
        self.validate_unwrap(value)
        value.type = self.type
        return value

    def dereference(self, session, ref, allow_none=False):
        """ Dereference a pymongo "DBRef" to this field's underlying type """
        from mongoalchemy.document import collection_registry
        # TODO: namespace support
        ref.type = collection_registry['global'][ref.collection]
        obj = session.dereference(ref, allow_none=allow_none)
        return obj
    def set_parent_on_subtypes(self, parent):
        if self.type:
            self.type.parent = parent

    def validate_unwrap(self, value, session=None):
        ''' Validates that the DBRef is valid as well as can be done without
            retrieving it.
        '''
        if not isinstance(value, DBRef):
            self._fail_validation_type(value, DBRef)
        if self.type:
            expected = self.type.type.get_collection_name()
            got = value.collection
            if expected != got:
                self._fail_validation(value, '''Wrong collection for reference: '''
                                      '''got "%s" instead of "%s" ''' % (got, expected))
        if self.db_required and not value.database:
            self._fail_validation(value, 'db_required=True, but not database specified')
        if self.db and value.database and self.db != value.database:
            self._fail_validation(value, '''Wrong database for reference: '''
                                  ''' got "%s" instead of "%s" ''' % (value.database, self.db) )
    validate_wrap = validate_unwrap

class Proxy(object):
    def __init__(self, field, allow_none=False):
        self.allow_none = allow_none
        self.field = field
    def __get__(self, instance, owner):
        if instance is None:
            return self.field
        session = instance._get_session()
        ref = getattr(instance, self.field._name)
        if ref is None:
            return None
        return self.field.dereference(session, ref, allow_none=self.allow_none)
    def __set__(self, instance, value):
        assert instance is not None
        setattr(instance, self.field._name, self.field._to_ref(value))



########NEW FILE########
__FILENAME__ = sequence
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.fields.base import *


class SequenceField(Field):
    ''' Base class for Fields which are an iterable collection of objects in which
        every child element is of the same type'''

    is_sequence_field = True
    valid_modifiers = LIST_MODIFIERS

    def __init__(self, item_type, min_capacity=None, max_capacity=None,
            default_empty=False, **kwargs):
        ''' :param item_type: :class:`Field` instance used for validation and (un)wrapping
            :param min_capacity: minimum number of items contained in values
            :param max_capacity: maximum number of items contained in values
            :param default_empty: the default is an empty sequence.
        '''
        super(SequenceField, self).__init__(**kwargs)
        self.item_type = item_type
        self.min = min_capacity
        self.max = max_capacity
        self.default_empty = default_empty
        if not isinstance(item_type, Field):
            raise BadFieldSpecification("List item_type is not a field!")
    def schema_json(self):
        super_schema = super(SequenceField, self).schema_json()
        return dict(item_type=self.item_type.schema_json(),
                    min_capacity=self.min,
                    max_capacity=self.max,
                    default_empty=self.default_empty, **super_schema)

    @property
    def has_subfields(self):
        ''' Returns True if the sequence's value type has subfields. '''
        return self.item_type.has_subfields

    @property
    def has_autoload(self):
        return self.item_type.has_autoload

    def set_parent_on_subtypes(self, parent):
        self.item_type._set_parent(parent)

    def subfields(self):
        ''' Returns the names of the value type's sub-fields'''
        return self.item_type.subfields()

    def _dereference(self, session, ref, allow_none=False):
        return self.item_type.dereference(session, ref, allow_none=allow_none)

    def wrap_value(self, value):
        ''' A function used to wrap a value used in a comparison.  It will
            first try to wrap as the sequence's sub-type, and then as the
            sequence itself'''
        try:
            return self.item_type.wrap_value(value)
        except BadValueException:
            pass
        try:
            return self.wrap(value)
        except BadValueException:
            pass
        self._fail_validation(value, 'Could not wrap value as the correct type.  Tried %s and %s' % (self.item_type, self))

    def child_type(self):
        ''' Returns the :class:`Field` instance used for items in the sequence'''
        return self.item_type

    def _validate_child_wrap(self, value):
        self.item_type.validate_wrap(value)

    def _validate_child_unwrap(self, value, session=None):
        if self.has_autoload:
            self.item_type.validate_unwrap(value, session=session)
        else:
            self.item_type.validate_unwrap(value)

    def _length_valid(self, value):
        if self.min is not None and len(value) < self.min:
            self._fail_validation(value, 'Value has too few elements')
        if self.max is not None and len(value) > self.max:
            self._fail_validation(value, 'Value has too many elements')

    def validate_wrap(self, value):
        ''' Checks that the type of ``value`` is correct as well as validating
            the elements of value'''
        self._validate_wrap_type(value)
        self._length_valid(value)
        for v in value:
            self._validate_child_wrap(v)

    def validate_unwrap(self, value, session=None):
        ''' Checks that the type of ``value`` is correct as well as validating
            the elements of value'''
        self._validate_unwrap_type(value)
        self._length_valid(value)
        for v in value:
            if self.has_autoload:
                self._validate_child_unwrap(v, session=session)
            else:
                self._validate_child_unwrap(v)


    def set_value(self, instance, value):
        super(SequenceField, self).set_value(instance, value)
        # TODO:2012
        # value_obj = instance._values[self._name]
        # if from_db:
        #     # loaded from db, stash it
        #     if 'orig_values' not in instance.__dict__:
        #         instance.__dict__['orig_values'] = {}
        #     instance.__dict__['orig_values'][self._name] = deepcopy(value)

    def dirty_ops(self, instance):
        obj_value = instance._values[self._name]
        ops = super(SequenceField, self).dirty_ops(instance)
        if len(ops) == 0 and obj_value.set:
            ops = {'$set': {
                self.db_field : self.wrap(obj_value.value)
            }}
        return ops


class ListField(SequenceField):
    ''' Field representing a python list.
    '''
    def __init__(self, item_type, **kwargs):
        ''' :param item_type: :class:`Field` instance used for validation and (un)wrapping
            :param min_capacity: minimum number of items contained in values
            :param max_capacity: maximum number of items contained in values
            :param default_empty: the default is an empty sequence.
        '''
        if kwargs.get('default_empty'):
            kwargs['default_f'] = list
        super(ListField, self).__init__(item_type, **kwargs)
    # def set_default(self, value):
    #     return super(ListField, self).set_default(value)
    # def get_default(self):
    #     if self.default_empty:
    #         return []
    #     return super(ListField, self).get_default()
    # default = property(get_default, set_default)

    def rel(self, ignore_missing=False):
        from mongoalchemy.fields import RefBase
        assert isinstance(self.item_type, RefBase)
        return ListProxy(self, ignore_missing=ignore_missing)

    def _validate_wrap_type(self, value):
        import types
        if not any([isinstance(value, list), isinstance(value, tuple),
            isinstance(value, types.GeneratorType)]):
            self._fail_validation_type(value, list, tuple)
    _validate_unwrap_type = _validate_wrap_type

    def wrap(self, value):
        ''' Wraps the elements of ``value`` using ``ListField.item_type`` and
            returns them in a list'''
        self.validate_wrap(value)
        return [self.item_type.wrap(v) for v in value]
    def unwrap(self, value, session=None):
        ''' Unwraps the elements of ``value`` using ``ListField.item_type`` and
            returns them in a list'''
        kwargs = {}
        if self.has_autoload:
            kwargs['session'] = session
        self.validate_unwrap(value, **kwargs)
        return [ self.item_type.unwrap(v, **kwargs) for v in value]


class SetField(SequenceField):
    ''' Field representing a python set.
    '''
    def __init__(self, item_type, **kwargs):
        ''' :param item_type: :class:`Field` instance used for validation and (un)wrapping
            :param min_capacity: minimum number of items contained in values
            :param max_capacity: maximum number of items contained in values
            :param default_empty: the default is an empty sequence.
        '''
        if kwargs.get('default_empty'):
            kwargs['default_f'] = set
        super(SetField, self).__init__(item_type, **kwargs)

    # def set_default(self, value):
    #     return super(SetField, self).set_default(value)
    # def get_default(self):
    #     if self.default_empty:
    #         return set()
    #     return super(SetField, self).get_default()
    # default = property(get_default, set_default)

    def rel(self, ignore_missing=False):
        return ListProxy(self, ignore_missing=ignore_missing)

    def _validate_wrap_type(self, value):
        if not isinstance(value, set):
            self._fail_validation_type(value, set)

    def _validate_unwrap_type(self, value):
        if not isinstance(value, list):
            self._fail_validation_type(value, list)

    def wrap(self, value):
        ''' Unwraps the elements of ``value`` using ``SetField.item_type`` and
            returns them in a set
            '''
        self.validate_wrap(value)
        return [self.item_type.wrap(v) for v in value]

    def unwrap(self, value, session=None):
        ''' Unwraps the elements of ``value`` using ``SetField.item_type`` and
            returns them in a set'''
        self.validate_unwrap(value)
        return set([self.item_type.unwrap(v, session=session) for v in value])

class ListProxy(object):
    def __init__(self, field, ignore_missing=False):
        self.field = field
        self.ignore_missing = ignore_missing
    def __get__(self, instance, owner):
        if instance is None:
            return getattr(owner, self.field._name)
        session = instance._get_session()
        def iterator():
            for v in getattr(instance, self.field._name):
                if v is None:
                    yield v
                    continue
                value = self.field._dereference(session, v,
                                               allow_none=self.ignore_missing)
                if value is None and self.ignore_missing:
                    continue
                yield value
        return iterator()


########NEW FILE########
__FILENAME__ = ops
from __future__ import print_function
from mongoalchemy.py3compat import *

from itertools import chain
from bson.objectid import ObjectId
from abc import ABCMeta, abstractmethod

@add_metaclass(ABCMeta)
class Operation(object):
    __metaclass__ = ABCMeta

    execute = abstractmethod(lambda self : None)

    def update_cache(self): pass

    @property
    def collection(self):
        return self.session.db[self.type.get_collection_name()]

    def ensure_indexes(self):
        self.session.auto_ensure_indexes(self.type)

class ClearCollectionOp(Operation):
    def __init__(self, trans_id, session, kind):
        self.trans_id = trans_id
        self.session = session
        self.type = kind
    def execute(self):
        self.collection.remove()

class UpdateDocumentOp(Operation):
    def __init__(self, trans_id, session, document, safe, id_expression=None, upsert=False, update_ops={}, **kwargs):
        from mongoalchemy.query import Query
        self.session = session
        self.trans_id = trans_id
        self.type = type(document)
        self.safe = safe
        self.upsert = upsert

        if id_expression:
            self.db_key = Query(self.type, session).filter(id_expression).query
        else:
            self.db_key = {'_id' : document.mongo_id}

        self.dirty_ops = document.get_dirty_ops(with_required=upsert)
        for key, op in chain(update_ops.items(), kwargs.items()):
            key = str(key)
            for current_op, keys in list(self.dirty_ops.items()):
                if key not in keys:
                    continue
                self.dirty_ops.setdefault(op,{})[key] = keys[key]
                del self.dirty_ops[current_op][key]
                if len(self.dirty_ops[current_op]) == 0:
                    del self.dirty_ops[current_op]
        document._mark_clean()

    def execute(self):
        self.ensure_indexes()
        return self.collection.update(self.db_key, self.dirty_ops, upsert=self.upsert, safe=self.safe)

class UpdateOp(Operation):
    def __init__(self, trans_id, session, kind, safe, update_obj):
        self.session = session
        self.trans_id = trans_id
        self.type = kind
        self.safe = safe
        self.query = update_obj.query.query
        self.update_data = update_obj.update_data
        self.upsert = update_obj._get_upsert()
        self.multi = update_obj._get_multi()

    def execute(self):
        return self.collection.update(self.query, self.update_data, multi=self.multi,
                               upsert=self.upsert, safe=self.safe)


class SaveOp(Operation):
    def __init__(self, trans_id, session, document, safe):
        self.session = session
        self.trans_id = trans_id
        self.data = document.wrap()
        self.type = type(document)
        self.safe = safe
        # Deal with _id
        if '_id' not in self.data:
            self.data['_id'] = ObjectId()
            document.mongo_id = self.data['_id']
        document._mark_clean()

    def execute(self):
        self.ensure_indexes()
        return self.collection.save(self.data, safe=self.safe)

class RemoveOp(Operation):
    def __init__(self, trans_id, session, kind, safe, query):
        self.session = session
        self.trans_id = trans_id
        self.query = query.query
        self.safe = safe
        self.type = kind

    def execute(self):
        self.ensure_indexes()
        return self.collection.remove(self.query, safe=self.safe)


class RemoveDocumentOp(Operation):
    def __init__(self, trans_id, session, obj, safe):
        self.trans_id = trans_id
        self.session = session
        self.type = type(obj)
        self.safe = safe
        self.id = None
        if obj.has_id():
            self.id = obj.mongo_id

    def execute(self):
        if self.id is None:
            return
        db = self.session.db
        self.ensure_indexes()

        collection = db[self.type.get_collection_name()]
        return collection.remove(self.id, safe=self.safe)

########NEW FILE########
__FILENAME__ = py3compat
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
# Copyright (c) 2010-2013 Benjamin Peterson (functions from the "six" module)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import itertools
import sys

PYTHON_3 = sys.version_info[0] == 3

if PYTHON_3: # pragma: no cover
    unicode = str
    basestring = str
    long = int

def izip(*its): # pragma: no cover
    if 'izip' in dir(itertools):
        return itertools.izip(*its)
    return zip(*its)

def next(it): # pragma: no cover
    if hasattr(it, '__next__'):
        return it.__next__()
    return it.next()

def add_metaclass(metaclass): # pragma: no cover
    """ Class decorator for creating a class with a metaclass.

        Copied from six
    """
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        for slots_var in orig_vars.get('__slots__', ()):
            orig_vars.pop(slots_var)
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper
########NEW FILE########
__FILENAME__ = query
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from functools import wraps
from pymongo import ASCENDING, DESCENDING
from copy import copy, deepcopy

from mongoalchemy.exceptions import BadValueException
from mongoalchemy.query_expression import QueryExpression, BadQueryException, flatten
from mongoalchemy.update_expression import UpdateExpression, FindAndModifyExpression
from mongoalchemy.util import resolve_name

class BadResultException(Exception):
    ''' Only raised right now when .one() finds more than one object '''
    pass

class Query(object):
    ''' A query object has all of the methods necessary to programmatically
        generate a mongo query as well as methods to retrieve results of the
        query or do an update based on it.

        In general a query object should be created via ``Session.query``,
        not directly.
    '''
    def __init__(self, type, session):
        ''' :param type: A subclass of class:`mongoalchemy.document.Document`
            :param db: The :class:`~mongoalchemy.session.Session` which this query is associated with.
        '''
        self.session = session
        self.type = type
        self.__query = {}
        self._sort = []
        self._fields = None
        self.hints = []
        self._limit = None
        self._skip = None
        self._raw_output = False

    def __iter__(self):
        return self.__get_query_result()

    @property
    def query(self):
        """ The mongo query object which would be executed if this Query
            object were used """
        return flatten(self.__query)

    def __get_query_result(self):
        return self.session.execute_query(self, self.session)

    def raw_output(self):
        """ Turns on raw output, meaning that the MongoAlchemy ORM layer is
            skipped and the results from pymongo are returned.  Useful if you
            want to use the query functionality without getting python objects
            back
        """
        self._raw_output = True
        return self

    def _get_fields(self):
        return self._fields

    def _get_limit(self):
        return self._limit

    def _get_skip(self):
        return self._skip

    def limit(self, limit):
        ''' Sets the limit on the number of documents returned

            :param limit: the number of documents to return
        '''
        self._limit = limit
        return self

    def skip(self, skip):
        ''' Sets the number of documents to skip in the result

            :param skip: the number of documents to skip
        '''
        self._skip = skip
        return self

    def clone(self):
        ''' Creates a clone of the current query and all settings.  Further
            updates to the cloned object or the original object will not
            affect each other
        '''
        qclone = Query(self.type, self.session)
        qclone.__query = deepcopy(self.__query)
        qclone._sort = deepcopy(self._sort)
        qclone._fields = deepcopy(self._fields)
        qclone._hints = deepcopy(self.hints)
        qclone._limit = deepcopy(self._limit)
        qclone._skip = deepcopy(self._skip)
        qclone._raw_output = deepcopy(self._raw_output)
        return qclone

    def one(self):
        ''' Execute the query and return one result.  If more than one result
            is returned, raises a ``BadResultException``
        '''
        count = -1
        for count, result in enumerate(self):
            if count > 0:
                raise BadResultException('Too many results for .one()')
        if count == -1:
            raise BadResultException('Too few results for .one()')
        return result

    def first(self):
        ''' Execute the query and return the first result.  Unlike ``one``, if
            there are multiple documents it simply returns the first one.  If
            there are no documents, first returns ``None``
        '''
        for doc in iter(self):
            return doc
        return None

    def __getitem__(self, index):
        return self.__get_query_result().__getitem__(index)

    def hint_asc(self, qfield):
        ''' Applies a hint for the query that it should use a
            (``qfield``, ASCENDING) index when performing the query.

            :param qfield: the instance of :class:`mongoalchemy.QueryField` to use as the key.
        '''
        return self.__hint(qfield, ASCENDING)

    def hint_desc(self, qfield):
        ''' Applies a hint for the query that it should use a
            (``qfield``, DESCENDING) index when performing the query.

            :param qfield: the instance of :class:`mongoalchemy.QueryField` to use as the key.
        '''
        return self.__hint(qfield, DESCENDING)

    def __hint(self, qfield, direction):
        qfield = resolve_name(self.type, qfield)
        name = str(qfield)
        for n, _ in self.hints:
            if n == name:
                raise BadQueryException('Already gave hint for %s' % name)
        self.hints.append((name, direction))
        return self

    def explain(self):
        ''' Executes an explain operation on the database for the current
            query and returns the raw explain object returned.
        '''
        return self.__get_query_result().cursor.explain()

    def all(self):
        ''' Return all of the results of a query in a list'''
        return [obj for obj in iter(self)]

    def distinct(self, key):
        ''' Execute this query and return all of the unique values
            of ``key``.

            :param key: the instance of :class:`mongoalchemy.QueryField` to use as the distinct key.
        '''
        return self.__get_query_result().cursor.distinct(str(key))

    def filter(self, *query_expressions):
        ''' Apply the given query expressions to this query object

            **Example**: ``s.query(SomeObj).filter(SomeObj.age > 10, SomeObj.blood_type == 'O')``

            :param query_expressions: Instances of :class:`mongoalchemy.query_expression.QueryExpression`

            .. seealso:: :class:`~mongoalchemy.query_expression.QueryExpression` class
        '''
        for qe in query_expressions:
            if isinstance(qe, dict):
                self._apply_dict(qe)
            else:
                self._apply(qe)
        return self

    def filter_by(self, **filters):
        ''' Filter for the names in ``filters`` being equal to the associated
            values.  Cannot be used for sub-objects since keys must be strings'''
        for name, value in filters.items():
            self.filter(resolve_name(self.type, name) == value)
        return self

    def count(self, with_limit_and_skip=False):
        ''' Execute a count on the number of results this query would return.

            :param with_limit_and_skip: Include ``.limit()`` and ``.skip()`` arguments in the count?
        '''
        return self.__get_query_result().cursor.count(with_limit_and_skip=with_limit_and_skip)

    def fields(self, *fields):
        ''' Only return the specified fields from the object.  Accessing a \
            field that was not specified in ``fields`` will result in a \
            :class:``mongoalchemy.document.FieldNotRetrieved`` exception being \
            raised

            :param fields: Instances of :class:``mongoalchemy.query.QueryField`` specifying \
                which fields to return
        '''
        if self._fields is None:
            self._fields = set()
        for f in fields:
            f = resolve_name(self.type, f)
            self._fields.add(f)
        self._fields.add(self.type.mongo_id)
        return self

    def _fields_expression(self):
        fields = {}
        for f in self._get_fields():
            fields[f.get_absolute_name()] = f.fields_expression
        return fields


    def _apply(self, qe):
        ''' Apply a raw mongo query to the current raw query object'''
        self._apply_dict(qe.obj)

    def _apply_dict(self, qe_dict):
        ''' Apply a query expression, updating the query object '''
        for k, v in qe_dict.items():
            k = resolve_name(self.type, k)
            if not k in self.__query:
                self.__query[k] = v
                continue
            if not isinstance(self.__query[k], dict) or not isinstance(v, dict):
                raise BadQueryException('Multiple assignments to a field must all be dicts.')
            self.__query[k].update(**v)


    def ascending(self, qfield):
        ''' Sort the result based on ``qfield`` in ascending order.  These calls
            can be chained to sort by multiple fields.

            :param qfield: Instance of :class:``mongoalchemy.query.QueryField`` \
                specifying which field to sort by.
        '''
        return self.__sort(qfield, ASCENDING)

    def descending(self, qfield):
        ''' Sort the result based on ``qfield`` in ascending order.  These calls
            can be chained to sort by multiple fields.

            :param qfield: Instance of :class:``mongoalchemy.query.QueryField`` \
                specifying which field to sort by.
        '''
        return self.__sort(qfield, DESCENDING)

    def sort(self, *sort_tuples):
        ''' pymongo-style sorting.  Accepts a list of tuples.

            :param sort_tuples: varargs of sort tuples.
        '''
        query = self
        for name, direction in sort_tuples:
            field = resolve_name(self.type, name)
            if direction in (ASCENDING, 1):
                query = query.ascending(field)
            elif direction in (DESCENDING, -1):
                query = query.descending(field)
            else:
                raise BadQueryException('Bad sort direction: %s' % direction)
        return query

    def __sort(self, qfield, direction):
        qfield = resolve_name(self.type, qfield)
        name = str(qfield)
        for n, _ in self._sort:
            if n == name:
                raise BadQueryException('Already sorting by %s' % name)
        self._sort.append((name, direction))
        return self

    def not_(self, *query_expressions):
        ''' Add a $not expression to the query, negating the query expressions
            given.

            **Examples**: ``query.not_(SomeDocClass.age <= 18)`` becomes ``{'age' : { '$not' : { '$gt' : 18 } }}``

            :param query_expressions: Instances of :class:`mongoalchemy.query_expression.QueryExpression`
            '''
        for qe in query_expressions:
            self.filter(qe.not_())
        return self

    def or_(self, first_qe, *qes):
        ''' Add a $not expression to the query, negating the query expressions
            given.  The ``| operator`` on query expressions does the same thing

            **Examples**: ``query.or_(SomeDocClass.age == 18, SomeDocClass.age == 17)`` becomes ``{'$or' : [{ 'age' : 18 }, { 'age' : 17 }]}``

            :param query_expressions: Instances of :class:`mongoalchemy.query_expression.QueryExpression`
        '''
        res = first_qe
        for qe in qes:
            res = (res | qe)
        self.filter(res)
        return self

    def in_(self, qfield, *values):
        ''' Check to see that the value of ``qfield`` is one of ``values``

            :param qfield: Instances of :class:`mongoalchemy.query_expression.QueryExpression`
            :param values: Values should be python values which ``qfield`` \
                understands
        '''
        # TODO: make sure that this field represents a list
        qfield = resolve_name(self.type, qfield)
        self.filter(QueryExpression({ qfield : { '$in' : [qfield.wrap_value(value) for value in values]}}))
        return self

    def nin(self, qfield, *values):
        ''' Check to see that the value of ``qfield`` is not one of ``values``

            :param qfield: Instances of :class:`mongoalchemy.query_expression.QueryExpression`
            :param values: Values should be python values which ``qfield`` \
                understands
        '''
        # TODO: make sure that this field represents a list
        qfield = resolve_name(self.type, qfield)
        self.filter(QueryExpression({ qfield : { '$nin' : [qfield.wrap_value(value) for value in values]}}))
        return self

    def find_and_modify(self, new=False, remove=False):
        ''' The mongo "find and modify" command.  Behaves like an update expression
            in that "execute" must be called to do the update and return the
            results.

            :param new: Whether to return the new object or old (default: False)
            :param remove: Whether to remove the object before returning it
        '''
        return FindAndModifyExpression(self, new=new, remove=remove)


    def set(self, *args, **kwargs):
        ''' Refer to: :func:`~mongoalchemy.update_expression.UpdateExpression.set`'''
        return UpdateExpression(self).set(*args, **kwargs)

    def unset(self, qfield):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.unset`'''
        return UpdateExpression(self).unset(qfield)

    def inc(self, *args, **kwargs):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.inc`'''
        return UpdateExpression(self).inc(*args, **kwargs)

    def append(self, qfield, value):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.append`'''
        return UpdateExpression(self).append(qfield, value)

    def extend(self, qfield, *value):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.extend`'''
        return UpdateExpression(self).extend(qfield, *value)

    def remove(self, qfield, value):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.remove`'''
        return UpdateExpression(self).remove(qfield, value)

    def remove_all(self, qfield, *value):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.remove_all`'''
        return UpdateExpression(self).remove_all(qfield, *value)

    def add_to_set(self, qfield, value):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.add_to_set`'''
        return UpdateExpression(self).add_to_set(qfield, value)

    def pop_first(self, qfield):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.pop_first`'''
        return UpdateExpression(self).pop_first(qfield)

    def pop_last(self, qfield):
        ''' Refer to:  :func:`~mongoalchemy.update_expression.UpdateExpression.pop_last`'''
        return UpdateExpression(self).pop_last(qfield)

class QueryResult(object):
    def __init__(self, session, cursor, type, raw_output=False, fields=None):
        self.cursor = cursor
        self.type = type
        self.fields = fields
        self.raw_output = raw_output
        self.session = session

    def next(self):
        return self._next_internal()
    __next__ = next

    def _next_internal(self):
        value = next(self.cursor)
        if not self.raw_output:
            db = self.cursor.collection.database
            conn = db.connection
            obj = self.session.cache_read(value['_id'])
            if obj:
                return obj
            value = self.session._unwrap(self.type, value, fields=self.fields)
            if not isinstance(value, dict):
                self.session.cache_write(value)
        return value

    def __getitem__(self, index):
        value = self.cursor.__getitem__(index)
        if not self.raw_output:
            db = self.cursor.collection.database
            conn = db.connection
            obj = self.session.cache_read(value['_id'])
            if obj:
                return obj
            value = self.session._unwrap(self.type, value)
            self.session.cache_write(value)
            # value = self.session.localize(session, value)
        return value

    def rewind(self):
        return self.cursor.rewind()

    def clone(self):
        return QueryResult(self.session, self.cursor.clone(), self.type,
            raw_output=self.raw_output, fields=self.fields)

    def __iter__(self):
        return self


class RemoveQuery(object):
    def __init__(self, type, session):
        ''' Execute a remove query to remove the matched objects from the database

            :param type: A subclass of class:`mongoalchemy.document.Document`
            :param db: The :class:`~mongoalchemy.session.Session` which this query is associated with.
        '''
        self.session = session
        self.type = type
        self.safe = None
        self.get_last_args = {}
        self.__query_obj = Query(type, session)

    @property
    def query(self):
        return self.__query_obj.query

    def set_safe(self, is_safe, **kwargs):
        ''' Set this remove to be safe.  It will call getLastError after the
            remove to make sure it was successful.  ``**kwargs`` are parameters to
            MongoDB's getLastError command (as in pymongo's remove).
        '''
        self.safe = is_safe
        self.get_last_args.update(**kwargs)
        return self

    def execute(self):
        ''' Run the remove command on the session.  Return the result of
            ``getLastError`` if ``safe`` is ``True``'''
        return self.session.execute_remove(self)

    def filter(self, *query_expressions):
        ''' Filter the remove expression with ``*query_expressions``, as in
            the ``Query`` filter method.'''
        self.__query_obj.filter(*query_expressions)
        return self

    def filter_by(self, **filters):
        ''' Filter for the names in ``filters`` being equal to the associated
            values.  Cannot be used for sub-objects since keys must be strings'''
        self.__query_obj.filter_by(**filters)
        return self

    # def not_(self, *query_expressions):
    #     self.__query_obj.not_(*query_expressions)
    #     self.query = self.__query_obj.query
    #     return self

    def or_(self, first_qe, *qes):
        ''' Works the same as the query expression method ``or_``
        '''
        self.__query_obj.or_(first_qe, *qes)
        return self

    def in_(self, qfield, *values):
        ''' Works the same as the query expression method ``in_``
        '''

        self.__query_obj.in_(qfield, *values)
        return self

    def nin(self, qfield, *values):
        ''' Works the same as the query expression method ``nin_``
        '''
        self.__query_obj.nin(qfield, *values)
        return self


########NEW FILE########
__FILENAME__ = query_expression
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.exceptions import BadValueException

class BadQueryException(Exception):
    ''' Raised when a method would result in a query which is not well-formed.
    '''
    pass

class FreeFormField(object):
    has_subfields = True
    no_real_attributes = True

    def __init__(self, name=None):
        self.__name = name
        self.db_field = name
    def __getattr__(self, name):
        return FreeFormField(name=name)
    def __getitem__(self, name):
        return getattr(self, name)
    @classmethod
    def wrap_value(self, value):
        return value
    def subfields(self):
        return FreeFormField(name=None)
    def is_valid_wrap(*args):
        return True
    is_valid_unwrap = is_valid_wrap
    __contains__ = is_valid_wrap

class FreeFormDoc(object):
    config_default_sort = None
    def __init__(self, name):
        self.__name = name
    def __getattr__(self, name):
        return QueryField(FreeFormField(name))
    @classmethod
    def unwrap(cls, value, *args, **kwargs):
        return value
    def get_collection_name(self):
        return self.__name
    def transform_incoming(self, obj, session):
        return obj
    def get_indexes(self):
        return []
    mongo_id = FreeFormField(name='_id')

Q = FreeFormDoc('')

class QueryField(object):
    def __init__(self, type, parent=None):
        self.__type = type
        self.__parent = parent
        self.__cached_id_value = None
        self.__matched_index = False
        self.__fields_expr = True

    @property
    def fields_expression(self):
        return flatten(self.__fields_expr)

    @property
    def __cached_id(self):
        if self.__cached_id_value is None:
            self.__cached_id_value = str(self)
        return self.__cached_id_value

    def _get_parent(self):
        return self.__parent

    def get_type(self):
        ''' Returns the underlying :class:`mongoalchemy.fields.Field` '''
        return self.__type

    def matched_index(self):
        ''' Represents the matched array index on a query with objects inside
            of a list.  In the MongoDB docs, this is the ``$`` operator '''
        self.__matched_index = True
        return self

    def __getattr__(self, name):
        if not self.__type.no_real_attributes and hasattr(self.__type, name):
            return getattr(self.__type, name)

        if not self.__type.has_subfields:
            raise AttributeError(name)

        fields = self.__type.subfields()
        if name not in fields:
            raise BadQueryException('%s is not a field in %s' % (name, self.__type.sub_type()))
        return QueryField(fields[name], parent=self)

    def get_absolute_name(self):
        """ Returns the full dotted name of this field """
        res = []
        current = self

        while type(current) != type(None):
            if current.__matched_index:
                res.append('$')
            res.append(current.get_type().db_field)
            current = current._get_parent()
        return '.'.join(reversed(res))

    def near(self, x, y, max_distance=None):
        """ Return documents near the given point
        """
        expr = {
            self : {'$near' : [x, y]}
        }
        if max_distance is not None:
            expr[self]['$maxDistance'] = max_distance
        # if bucket_size is not None:
        #     expr['$bucketSize'] = max_distance
        return QueryExpression(expr)

    def near_sphere(self, x, y, max_distance=None):
        """ Return documents near the given point using sphere distances
        """
        expr = {
            self : {'$nearSphere' : [x, y]}
        }
        if max_distance is not None:
            expr[self]['$maxDistance'] = max_distance
        return QueryExpression(expr)

    def within_box(self, corner1, corner2):
        """
            Adapted from the Mongo docs::

                session.query(Places).filter(Places.loc.within_box(cornerA, cornerB)
        """
        return QueryExpression({
            self : {'$within' : {
                    '$box' : [corner1, corner2],
                }}
            })
    def within_radius(self, x, y, radius):
        """
            Adapted from the Mongo docs::

                session.query(Places).filter(Places.loc.within_radius(1, 2, 50)
        """
        return QueryExpression({
            self : {'$within' : {
                    '$center' : [[x, y], radius],
                }}
            })
    def within_radius_sphere(self, x, y, radius):
        """
            Adapted from the Mongo docs::

                session.query(Places).filter(Places.loc.within_radius_sphere(1, 2, 50)
        """
        return QueryExpression({
            self : {'$within' : {
                    '$centerSphere' : [[x, y], radius],
                }}
            })
    def within_polygon(self, polygon):
        """
            Adapted from the Mongo docs::

                polygonA = [ [ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ] ]
                polygonB = { a : { x : 10, y : 20 }, b : { x : 15, y : 25 }, c : { x : 20, y : 20 } }
                session.query(Places).filter(Places.loc.within_polygon(polygonA)
                session.query(Places).filter(Places.loc.within_polygon(polygonB)
        """
        return QueryExpression({
            self : {'$within' : {
                    '$polygon' : polygon,
                }}
            })

    def in_(self, *values):
        ''' A query to check if this query field is one of the values
            in ``values``.  Produces a MongoDB ``$in`` expression.
        '''
        return QueryExpression({
            self : { '$in' : [self.get_type().wrap_value(value) for value in values] }
        })

    def nin(self, *values):
        ''' A query to check if this query field is not one of the values
            in ``values``.  Produces a MongoDB ``$nin`` expression.
        '''
        return QueryExpression({
            self : { '$nin' : [self.get_type().wrap_value(value) for value in values] }
        })

    def exists(self, exists=True):
        ''' Create a MongoDB query to check if a field exists on a Document.
        '''
        return QueryExpression({self: {'$exists': exists}})

    def __str__(self):
        return self.get_absolute_name()

    def __repr__(self):
        return 'QueryField(%s)' % str(self)

    def __hash__(self):
        return hash(self.__cached_id)

    def __eq__(self, value):
        return self.eq_(value)
    def eq_(self, value):
        ''' Creates a query expression where ``this field == value``

            .. note:: The prefered usage is via an operator: ``User.name == value``
        '''
        if isinstance(value, QueryField):
            return self.__cached_id == value.__cached_id
        return QueryExpression({ self : self.get_type().wrap_value(value) })

    def __lt__(self, value):
        return self.lt_(value)
    def lt_(self, value):
        ''' Creates a query expression where ``this field < value``

            .. note:: The prefered usage is via an operator: ``User.name < value``
        '''
        return self.__comparator('$lt', value)

    def __le__(self, value):
        return self.le_(value)
    def le_(self, value):
        ''' Creates a query expression where ``this field <= value``

            .. note:: The prefered usage is via an operator: ``User.name <= value``
        '''
        return self.__comparator('$lte', value)

    def __ne__(self, value):
        return self.ne_(value)
    def ne_(self, value):
        ''' Creates a query expression where ``this field != value``

            .. note:: The prefered usage is via an operator: ``User.name != value``
        '''
        if isinstance(value, QueryField):
            return self.__cached_id != value.__cached_id
        return self.__comparator('$ne', value)

    def __gt__(self, value):
        return self.gt_(value)
    def gt_(self, value):
        ''' Creates a query expression where ``this field > value``

            .. note:: The prefered usage is via an operator: ``User.name > value``
        '''
        return self.__comparator('$gt', value)

    def __ge__(self, value):
        return self.ge_(value)
    def ge_(self, value):
        ''' Creates a query expression where ``this field >= value``

            .. note:: The prefered usage is via an operator: ``User.name >= value``
        '''
        return self.__comparator('$gte', value)

    def elem_match(self, value):
        ''' This method does two things depending on the context:

            1. In the context of a query expression it:

            Creates a query expression to do an $elemMatch on the selected
            field.  If the type of this field is a DocumentField the value
            can be either a QueryExpression using that Document's fields OR
            you can use a dict for raw mongo.

            See the mongo documentation for thorough treatment of
            elemMatch:
            http://docs.mongodb.org/manual/reference/operator/elemMatch/

            2. In the context of choosing fields in a query.fields() expr:

            Sets the field to use elemMatch, so only the matching elements
            of a list are used. See the mongo docs for more details:
            http://docs.mongodb.org/manual/reference/projection/elemMatch/
        '''
        self.__is_elem_match = True
        if not self.__type.is_sequence_field:
            raise BadQueryException('elem_match called on a non-sequence '
                                    'field: ' + str(self))
        if isinstance(value, dict):
            self.__fields_expr = { '$elemMatch' : value}
            return ElemMatchQueryExpression(self, {self : self.__fields_expr })
        elif isinstance(value, QueryExpression):
            self.__fields_expr = { '$elemMatch' : value.obj }
            e = ElemMatchQueryExpression(self, {
                       self : self.__fields_expr
                })
            return e
        raise BadQueryException('elem_match requires a QueryExpression '
                                '(to be typesafe) or a dict (which is '
                                'not type safe)')

    def exclude(self):
        ''' Use in a query.fields() expression to say this field should be
            excluded.  The default of fields() is to include only
            fields which are specified. This allows retrieving of "every field
            except 'foo'".
        '''
        self.__fields_expr = False
        return self

    def __comparator(self, op, value):
        return QueryExpression({
            self : {
                op : self.get_type().wrap(value)
            }
        })


class QueryExpression(object):
    ''' A QueryExpression wraps a dictionary representing a query to perform
        on a mongo collection.  The

        .. note:: There is no ``and_`` expression because multiple expressions
            can be specified to a single call of :func:`Query.filter`
    '''
    def __init__(self, obj):
        self.obj = obj
    def not_(self):
        ''' Negates this instance's query expression using MongoDB's ``$not``
            operator

            **Example**: ``(User.name == 'Jeff').not_()``

            .. note:: Another usage is via an operator, but parens are needed
                to get past precedence issues: ``~ (User.name == 'Jeff')``
            '''
        ret_obj = {}
        for k, v in self.obj.items():
            if not isinstance(v, dict):
                ret_obj[k] = {'$ne' : v }
                continue
            num_ops = len([x for x in v if x[0] == '$'])
            if num_ops != len(v) and num_ops != 0:
                raise BadQueryException('$ operator used in field name')

            if num_ops == 0:
                ret_obj[k] = {'$ne' : v }
                continue

            for op, value in v.items():
                k_dict = ret_obj.setdefault(k, {})
                not_dict = k_dict.setdefault('$not', {})
                not_dict[op] = value


        return QueryExpression(ret_obj)

    def __invert__(self):
        return self.not_()

    def __or__(self, expression):
        return self.or_(expression)

    def or_(self, expression):
        ''' Adds the given expression to this instance's MongoDB ``$or``
            expression, starting a new one if one does not exst

            **Example**: ``(User.name == 'Jeff').or_(User.name == 'Jack')``

            .. note:: The prefered usageis via an operator: ``User.name == 'Jeff' | User.name == 'Jack'``

            '''

        if '$or' in self.obj:
            self.obj['$or'].append(expression.obj)
            return self
        self.obj = {
            '$or' : [self.obj, expression.obj]
        }
        return self

class ElemMatchQueryExpression(QueryExpression):
    ''' Special QueryExpression subclass which can also be used
        in a query.fields() expression. Shouldn't be used directly.
    '''
    def __init__(self, field, obj):
        QueryExpression.__init__(self, obj)
        self._field = field
    def __str__(self):
        return str(self._field)
    def get_absolute_name(self):
        return self._field.get_absolute_name()
    @property
    def fields_expression(self):
        return self._field.fields_expression


def flatten(obj):
    if not isinstance(obj, dict):
        return obj
    ret = {}
    for k, v in obj.items():
        if not isinstance(k, basestring):
            k = str(k)
        if isinstance(v, dict):
            v = flatten(v)
        if isinstance(v, list):
            v = [flatten(x) for x in v]
        ret[k] = v
    return ret

########NEW FILE########
__FILENAME__ = session
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

''' Session objects handles the actual queueing of database operations.
    The primary methods on a session are query, insert, and flush.

    The session also responsible for ordering operations and knowing when
    operations need to be flushed, although it does not currently do
    anything intelligent for ordering.
'''

from __future__ import print_function
from mongoalchemy.py3compat import *

from uuid import uuid4
import pymongo
if hasattr(pymongo, 'mongo_client'):
    from pymongo.mongo_client import MongoClient
else: # pragma: no cover
    from pymongo.connection import Connection as MongoClient
from bson import DBRef, ObjectId
from mongoalchemy.query import Query, QueryResult, RemoveQuery
from mongoalchemy.document import (FieldNotRetrieved, Document,
                                    collection_registry)
from mongoalchemy.query_expression import FreeFormDoc
from mongoalchemy.exceptions import (TransactionException,
                                     BadReferenceException,
                                     SessionCacheException)
from mongoalchemy.ops import *

class Session(object):

    def __init__(self, database, tz_aware=False, timezone=None, safe=False,
                 cache_size=0, auto_ensure=True):
        '''
        Create a session connecting to `database`.

        :param database: the database to connect to.  Should be an instance of \
            :class:`pymongo.database.Database`
        :param safe: Whether the "safe" option should be used on mongo writes, \
            blocking to make sure there are no errors.
        :param auto_ensure: Whether to implicitly call ensure_indexes on all write \
            operations.

        **Fields**:
            * db: the underlying pymongo database object
            * queue: the queue of unflushed database commands (currently useless \
                since there aren't any operations which defer flushing)
            * cache_size: The size of the identity map to keep.  When objects \
                            are pulled from the DB they are checked against this \
                            map and if present, the existing object is used.  \
                            Defaults to 0, use None to only clear at session end.

        '''
        self.db = database
        self.queue = []
        self.safe = safe
        self.timezone = timezone
        self.tz_aware = bool(tz_aware or timezone)
        self.auto_ensure = auto_ensure

        self.cache_size = cache_size
        self.cache = {}
        self.transactions = []
    @property
    def autoflush(self):
        return not self.in_transaction
    @property
    def in_transaction(self):
        return len(self.transactions) > 0

    @classmethod
    def connect(self, database, timezone=None, cache_size=0, auto_ensure=True, *args, **kwds):
        ''' `connect` is a thin wrapper around __init__ which creates the
            database connection that the session will use.

            :param database: the database name to use.  Should be an instance of \
                    :class:`basestring`
            :param safe: The value for the "safe" parameter of the Session \
                init function
            :param auto_ensure: Whether to implicitly call ensure_indexes on all write \
                operations.
            :param args: arguments for :class:`pymongo.mongo_client.MongoClient`
            :param kwds: keyword arguments for :class:`pymongo.mongo_client.MongoClient`
        '''
        safe = kwds.get('safe', False)
        if 'safe' in kwds:
            del kwds['safe']
        if timezone is not None:
            kwds['tz_aware'] = True
        conn = MongoClient(*args, **kwds)
        db = conn[database]
        return Session(db, timezone=timezone, safe=safe, cache_size=cache_size, auto_ensure=auto_ensure)

    def cache_write(self, obj, mongo_id=None):
        if mongo_id is None:
            mongo_id = obj.mongo_id

        if self.cache_size == 0:
            return
        if mongo_id in self.cache:
            return
        if self.cache_size is not None and len(self.cache) >= self.cache_size:
            for key in self.cache:
                break
            del self.cache[key]
        assert isinstance(mongo_id, ObjectId), 'Currently, cached objects must use mongo_id as an ObjectId.  Got: %s' % type(mongo_id)
        self.cache[mongo_id] = obj

    def cache_read(self, id):
        if self.cache_size == 0:
            return
        assert isinstance(id, ObjectId), 'Currently, cached objects must use mongo_id as an ObjectId'
        # if not isinstance(id, ObjectId):
        #     id = ObjectId(id)
        if id in self.cache:
            return self.cache[id]
        return None

    def end(self):
        ''' End the session.  Flush all pending operations and ending the
            *pymongo* request'''
        self.cache = {}
        if self.transactions:
            raise TransactionException('Tried to end session with an open '
                                       'transaction')
        self.db.connection.end_request()

    def insert(self, item, safe=None):
        ''' Insert an item into the work queue and flushes.'''
        self.add(item, safe=safe)

    def add(self, item, safe=None):
        ''' Add an item into the queue of things to be inserted.  Does not flush.'''
        item._set_session(self)
        if safe is None:
            safe = self.safe
        self.queue.append(SaveOp(self.transaction_id, self, item, safe))
        # after the save op is recorded, the document has an _id and can be
        # cached
        self.cache_write(item)
        if self.autoflush:
            return self.flush()

    def update(self, item, id_expression=None, upsert=False, update_ops={}, safe=None, **kwargs):
        ''' Update an item in the database.  Uses the on_update keyword to each
            field to decide which operations to do, or.

            :param item: An instance of a :class:`~mongoalchemy.document.Document` \
                subclass
            :param id_expression: A query expression that uniquely picks out \
                the item which should be updated.  If id_expression is not \
                passed, update uses item.mongo_id.
            :param upsert: Whether the update operation should be an upsert. \
                If the item may not be in the database yet this should be True
            :param update_ops: By default the operation used to update a field \
                is specified with the on_update argument to its constructor. \
                To override that value, use this dictionary, with  \
                :class:`~mongoalchemy.document.QueryField` objects as the keys \
                and the mongo operation to use as the values.
            :param kwargs: The kwargs are merged into update_ops dict to \
                decide which fields to update the operation for.  These can \
                only be for the top-level document since the keys \
                are just strings.

            .. warning::

                This operation is **experimental** and **not fully tested**,
                although it does have code coverage.
            '''
        if safe is None:
            safe = self.safe
        self.queue.append(UpdateDocumentOp(self.transaction_id, self, item, safe, id_expression=id_expression,
                          upsert=upsert, update_ops=update_ops, **kwargs))
        if self.autoflush:
            return self.flush()

    def query(self, type):
        ''' Begin a query on the database's collection for `type`.  If `type`
            is an instance of basesting, the query will be in raw query mode
            which will not check field values or transform returned results
            into python objects.

         .. seealso:: :class:`~mongoalchemy.query.Query` class'''
        # This really should be adding a query operation to the
        # queue which is then forced to execute when the results are being
        # read
        if isinstance(type, basestring):
            type = FreeFormDoc(type)
        return Query(type, self)

    def add_to_session(self, obj):
        obj._set_session(self)

    def execute_query(self, query, session):
        ''' Get the results of ``query``.  This method does flush in a
            transaction, so any objects retrieved which are not in the cache
            which would be updated when the transaction finishes will be
            stale '''
        self.auto_ensure_indexes(query.type)

        kwargs = dict()
        if query._get_fields():
            kwargs['fields'] = query._fields_expression()

        collection = self.db[query.type.get_collection_name()]
        cursor = collection.find(query.query, **kwargs)

        if query._sort:
            cursor.sort(query._sort)
        elif query.type.config_default_sort:
            cursor.sort(query.type.config_default_sort)
        if query.hints:
            cursor.hint(query.hints)
        if query._get_limit() is not None:
            cursor.limit(query._get_limit())
        if query._get_skip() is not None:
            cursor.skip(query._get_skip())
        return QueryResult(session, cursor, query.type, raw_output=query._raw_output, fields=query._get_fields())

    def remove_query(self, type):
        ''' Begin a remove query on the database's collection for `type`.

           .. seealso:: :class:`~mongoalchemy.update_expression.RemoveQuery` class'''
        return RemoveQuery(type, self)

    def remove(self, obj, safe=None):
        '''
            Remove a particular object from the database.  If the object has
            no mongo ID set, the method just returns.  If this is a partial
            document without the mongo ID field retrieved a ``FieldNotRetrieved``
            will be raised

            :param obj: the object to save
            :param safe: whether to wait for the operation to complete.  Defaults \
                to the session's ``safe`` value.
        '''
        if safe is None:
            safe = self.safe
        remove = RemoveDocumentOp(self.transaction_id, self, obj, safe)
        self.queue.append(remove)
        if self.autoflush:
            return self.flush()

    def execute_remove(self, remove):
        ''' Execute a remove expression.  Should generally only be called implicitly.
        '''

        safe = self.safe
        if remove.safe is not None:
            safe = remove.safe

        self.queue.append(RemoveOp(self.transaction_id, self, remove.type, safe, remove))
        if self.autoflush:
            return self.flush()

    def execute_update(self, update, safe=False):
        ''' Execute an update expression.  Should generally only be called implicitly.
        '''

        # safe = self.safe
        # if update.safe is not None:
        #     safe = remove.safe

        assert len(update.update_data) > 0
        self.queue.append(UpdateOp(self.transaction_id, self, update.query.type, safe, update))
        if self.autoflush:
            return self.flush()


    def execute_find_and_modify(self, fm_exp):
        if self.in_transaction:
            raise TransactionException('Cannot find and modify in a transaction.')
        self.flush()
        self.auto_ensure_indexes(fm_exp.query.type)
        # assert len(fm_exp.update_data) > 0
        collection = self.db[fm_exp.query.type.get_collection_name()]
        kwargs = {
            'query' : fm_exp.query.query,
            'update' : fm_exp.update_data,
            'upsert' : fm_exp._get_upsert(),
        }

        if fm_exp.query._get_fields():
            kwargs['fields'] = fm_exp.query._fields_expression()
        if fm_exp.query._sort:
            kwargs['sort'] = fm_exp.query._sort
        if fm_exp._get_new():
            kwargs['new'] = fm_exp._get_new()
        if fm_exp._get_remove():
            kwargs['remove'] = fm_exp._get_remove()

        value = collection.find_and_modify(**kwargs)

        if value is None:
            return None

        # Found this uncommitted.  not sure what it's from? Leaving it
        # until I remember -jeff
        # if kwargs['upsert'] and not kwargs.get('new') and len(value) == 0:
        #     return value

        # No cache in find and modify, right?
        # this is an update operation
        # obj = self.cache_read(value['_id'])
        # if obj is not None:
        #     return obj
        obj = self._unwrap(fm_exp.query.type, value,
                           fields=fm_exp.query._get_fields())
        if not fm_exp.query._get_fields():
            self.cache_write(obj)
        return obj

    def _unwrap(self, type, obj, **kwargs):
        obj = type.transform_incoming(obj, session=self)
        return type.unwrap(obj, session=self, **kwargs)

    @property
    def transaction_id(self):
        if not self.transactions:
            return None
        return self.transactions[-1]

    def get_indexes(self, cls):
        ''' Get the index information for the collection associated with
        `cls`.  Index information is returned in the same format as *pymongo*.
        '''
        return self.db[cls.get_collection_name()].index_information()

    def ensure_indexes(self, cls):
        collection = self.db[cls.get_collection_name()]
        for index in cls.get_indexes():
            index.ensure(collection)

    def auto_ensure_indexes(self, cls):
        if self.auto_ensure:
            self.ensure_indexes(cls)

    def clear_queue(self, trans_id=None):
        ''' Clear the queue of database operations without executing any of
             the pending operations'''
        if not self.queue:
            return
        if trans_id is None:
            self.queue = []
            return

        for index, op in enumerate(self.queue):
            if op.trans_id == trans_id:
                break
        self.queue = self.queue[:index]

    def clear_cache(self):
        self.cache = {}

    def clear_collection(self, *classes):
        ''' Clear all objects from the collections associated with the
            objects in `*cls`. **use with caution!**'''
        for c in classes:
            self.queue.append(ClearCollectionOp(self.transaction_id, self, c))
        if self.autoflush:
            self.flush()

    def flush(self, safe=None):
        ''' Perform all database operations currently in the queue'''
        result = None
        for index, op in enumerate(self.queue):
            try:
                result = op.execute()
            except:
                self.clear_queue()
                self.clear_cache()
                raise
        self.clear_queue()
        return result

    def dereference(self, ref, allow_none=False):
        if isinstance(ref, Document):
            return ref
        if not hasattr(ref, 'type'):
            if ref.collection in collection_registry['global']:
                ref.type = collection_registry['global'][ref.collection]
        assert hasattr(ref, 'type')

        obj = self.cache_read(ref.id)
        if obj is not None:
            return obj
        if ref.database and self.db.name != ref.database:
            db = self.db.connection[ref.database]
        else:
            db = self.db
        value = db.dereference(ref)
        if value is None and allow_none:
            obj = None
            self.cache_write(obj, mongo_id=ref.id)
        elif value is None:
            raise BadReferenceException('Bad reference: %r' % ref)
        else:
            obj = self._unwrap(ref.type, value)
            self.cache_write(obj)
        return obj

    def refresh(self, document):
        """ Load a new copy of a document from the database.  does not
            replace the old one """
        try:
            old_cache_size = self.cache_size
            self.cache_size = 0
            obj = self.query(type(document)).filter_by(mongo_id=document.mongo_id).one()
        finally:
            self.cache_size = old_cache_size
        self.cache_write(obj)
        return obj

    def clone(self, document):
        ''' Serialize a document, remove its _id, and deserialize as a new
            object '''

        wrapped = document.wrap()
        if '_id' in wrapped:
            del wrapped['_id']
        return type(document).unwrap(wrapped, session=self)

    def begin_trans(self):
        self.transactions.append(uuid4())
        return self

    def __enter__(self):
        return self.begin_trans()

    def __exit__(self, exc_type, exc_val, exc_tb):
        return self.end_trans(exc_type, exc_val, exc_tb)

    def end_trans(self, exc_type=None, exc_val=None, exc_tb=None):
        # Pop this level of transaction from the stack
        id = self.transactions.pop()

        # If exception, set us as being in an error state
        if exc_type:
            self.clear_queue(trans_id=id)

        # If we aren't at the top level, return
        if self.transactions:
            return False

        if not exc_type:
            self.flush()
            self.end()
        else:
            self.clear_queue()
            self.clear_cache()
        return False


########NEW FILE########
__FILENAME__ = update_expression
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

from functools import wraps
from pymongo import ASCENDING, DESCENDING
from copy import copy, deepcopy

from mongoalchemy.exceptions import BadValueException
from mongoalchemy.query_expression import QueryExpression, BadQueryException, flatten
from mongoalchemy.util import resolve_name

class UpdateExpression(object):
    def __init__(self, query):
        self.query = query
        self.session = query.session
        self.update_data = {}
        self.__upsert = False
        self.__multi = False
        self.__safe = False

    def upsert(self):
        ''' If a document matching the query doesn't exist, create one '''
        self.__upsert = True
        return self

    def multi(self):
        ''' Update multiple documents.  The Mongo default is to only update
            the first matching document '''
        self.__multi = True
        return self

    def safe(self, safe=True):
        """ Mark the query as a "safe" query with pymongo.

            :param safe: Defaults to True. Force "safe" on or off
        """
        self.__safe = safe
        return self

    def set(self, *args, **kwargs):
        ''' Usage is either:

            set(self, qfield, value): Atomically set ``qfield`` to ``value``

            OR

            set(key1=value1, key2=value2): Atomically set the named arguments
            on the current object to the values given.  This form cannot
            update a sub-document
            '''
        if len(args) == 2:
            qfield, value = args
            return self._atomic_op('$set', qfield, value)
        elif len(kwargs) != 0:
            ret = self
            for key, value in kwargs.items():
                ret = ret._atomic_op('$set', key, value)
            return ret
        else:
            raise UpdateException('Invalid arguments for set.  Requires either two positional arguments or at least one keyword argument')

    def unset(self, qfield):
        ''' Atomically delete the field ``qfield``
             .. note:: Requires server version **>= 1.3.0+**.
        '''
        # TODO: assert server version is >1.3.0
        return self._atomic_generic_op('$unset', qfield, True)

    def inc(self, *args, **kwargs):
        ''' Atomically increment ``qfield`` by ``value`` '''
        pairs = []
        if len(args) == 1:
            pairs.append((args[0], 1))
        elif len(args) == 2:
            pairs.append(args)
        elif len(kwargs) != 0:
            pairs.extend([(k, v) for k, v in kwargs.items()])
        else:
            raise UpdateException('Invalid arguments for set.  Requires either two positional arguments or at least one keyword argument')

        ret = self
        for qfield, value in pairs:
            ret = self._atomic_op('$inc', qfield, value)
        return ret

    def append(self, qfield, value):
        ''' Atomically append ``value`` to ``qfield``.  The operation will
            if the field is not a list field'''
        return self._atomic_list_op('$push', qfield, value)

    def extend(self, qfield, *value):
        ''' Atomically append each value in ``value`` to the field ``qfield`` '''
        return self._atomic_list_op_multivalue('$pushAll', qfield, *value)

    def remove(self, qfield, value):
        ''' Atomically remove ``value`` from ``qfield``'''
        if isinstance(value, QueryExpression):
            return self._atomic_expression_op('$pull', qfield, value)
        return self._atomic_list_op('$pull', qfield, value)

    def remove_all(self, qfield, *value):
        ''' Atomically remove each value in ``value`` from ``qfield``'''
        return self._atomic_list_op_multivalue('$pullAll', qfield, *value)

    def add_to_set(self, qfield, value):
        ''' Atomically add ``value`` to ``qfield``.  The field represented by
            ``qfield`` must be a set

            .. note:: Requires server version **1.3.0+**.
        '''
        # TODO: check version > 1.3.3
        return self._atomic_list_op('$addToSet', qfield, value)

    def pop_last(self, qfield):
        ''' Atomically pop the last item in ``qfield.``
            .. note:: Requires version **1.1+**'''
        return self._atomic_generic_op('$pop', qfield, 1)

    def pop_first(self, qfield):
        ''' Atomically pop the first item in ``qfield.``
            .. note:: Requires version **1.1+**'''
        return self._atomic_generic_op('$pop', qfield, -1)

    def _atomic_list_op_multivalue(self, op, qfield, *value):
        qfield = resolve_name(self.query.type, qfield)
        if op not in qfield.valid_modifiers:
            raise InvalidModifierException(qfield, op)
        wrapped = []
        for v in value:
            wrapped.append(qfield.get_type().item_type.wrap(v))
        if op not in self.update_data:
            self.update_data[op] = {}
        self.update_data[op][qfield.get_absolute_name()] = value
        return self

    def _atomic_list_op(self, op, qfield, value):
        qfield = resolve_name(self.query.type, qfield)
        if op not in qfield.valid_modifiers:
            raise InvalidModifierException(qfield, op)

        if op not in self.update_data:
            self.update_data[op] = {}
        self.update_data[op][qfield.get_absolute_name()] = qfield.child_type().wrap(value)
        return self

    def _atomic_expression_op(self, op, qfield, value):
        qfield = resolve_name(self.query.type, qfield)
        if op not in qfield.valid_modifiers:
            raise InvalidModifierException(qfield, op)

        if op not in self.update_data:
            self.update_data[op] = {}
        self.update_data[op][qfield.get_absolute_name()] = flatten(value.obj)
        return self

    def _atomic_op(self, op, qfield, value):
        qfield = resolve_name(self.query.type, qfield)
        if op not in qfield.valid_modifiers:
            raise InvalidModifierException(qfield, op)

        if op not in self.update_data:
            self.update_data[op] = {}
        self.update_data[op][qfield.get_absolute_name()] = qfield.wrap(value)
        return self

    def _atomic_generic_op(self, op, qfield, value):
        qfield = resolve_name(self.query.type, qfield)
        if op not in qfield.valid_modifiers:
            raise InvalidModifierException(qfield, op)

        if op not in self.update_data:
            self.update_data[op] = {}
        self.update_data[op][qfield.get_absolute_name()] = value
        return self

    def _get_upsert(self):
        return self.__upsert

    def _get_multi(self):
        return self.__multi

    def execute(self):
        ''' Execute the update expression on the database '''
        self.session.execute_update(self, safe=self.__safe)

class FindAndModifyExpression(UpdateExpression):
    def __init__(self, query, new, remove):
        self.__new = new
        self.__remove = remove
        UpdateExpression.__init__(self, query)

    def _get_remove(self):
        return self.__remove

    def _get_new(self):
        return self.__new

    def execute(self):
        ''' Execute the find and modify expression on the database '''
        return self.session.execute_find_and_modify(self)


class UpdateException(Exception):
    ''' Base class for exceptions related to updates '''
    pass

class InvalidModifierException(UpdateException):
    ''' Exception raised if a modifier was used which isn't valid for a field '''
    def __init__(self, field, op):
        UpdateException.__init__(self, 'Invalid modifier for %s field: %s' % (field.__class__.__name__, op))

class ConflictingModifierException(UpdateException):
    ''' Exception raised if conflicting modifiers are being used in the
        update expression '''
    pass


########NEW FILE########
__FILENAME__ = util
# The MIT License
#
# Copyright (c) 2010 Jeffrey Jenkins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import print_function
from mongoalchemy.py3compat import *

def classproperty(fun):
    class Descriptor(property):
        def __get__(self, instance, owner):
            return fun(owner)
    return Descriptor()

class UNSET(object):
    def __repr__(self):
        return 'UNSET'
    def __eq__(self, other):
        return other.__class__ == self.__class__
UNSET = UNSET()

class FieldNotFoundException(Exception):
    pass

def resolve_name(type, name):
    if not isinstance(name, basestring) or name[0] == '$':
        return name
    ret = type
    for part in name.split('.'):
        try:
            ret = getattr(ret, part)
        except AttributeError:
            raise FieldNotFoundException("Field not found %s (in %s)" %
                                         (part, name))

    return ret


########NEW FILE########
__FILENAME__ = test_computed_fields
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.fields import *
from test.util import known_failure
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index
from mongoalchemy.query import Query

def get_session():
    return Session.connect('unit-testing')

# Computed Field
def computed_field_db_test():

    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(IntField(), deps=[a,b])
        def a_plus_b(obj):
            return obj['a'] + obj['b']

    s = get_session()
    s.clear_collection(TestDoc2)
    obj = TestDoc2(a=1, b=2)
    assert obj.a_plus_b == 3, 'Got: %s' % obj.a_plus_b

    s.insert(obj)
    for td in s.query(TestDoc2):
        break
    assert td.a_plus_b == obj.a_plus_b

def computed_field_db_test_2():
    class Doc1(Document):
        c = IntField()
    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(DocumentField(Doc1), deps=[a,b])
        def a_plus_b(obj):
            return obj['a'] + obj['b']
    s = get_session()
    s.clear_collection(Doc1)
    s.clear_collection(TestDoc2)


def test_created_modified():
    class TestDoc2(Document):
        created = CreatedField()
        modified = ModifiedField()
    d = TestDoc2()
    w1 = d.wrap()
    import time
    time.sleep(0.01)
    w2 = d.unwrap(w1).wrap()
    assert w1['created'] == w2['created']
    assert w1['modified'] != w2['modified']

def test_no_deps_computed_field():
    class TestDoc2(Document):
        @computed_field(IntField())
        def c(obj):
            return 1322
    TestDoc2().c == 1322

def computed_field_value_test():
    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(IntField(), deps=[a,b])
        def c(obj):
            return 6
    TestDoc2.c.unwrap(6)

def computed_value_update_test():
    # No deps
    class UpDoc(Document):
        @computed_field(IntField())
        def c(obj):
            return 3
    assert UpDoc().get_dirty_ops() == { '$set' : { 'c' : 3 } }, UpDoc().get_dirty_ops()

    # Deps, updated
    class UpDoc2(Document):
        i = IntField(required=False)
        @computed_field(IntField(), deps=[i])
        def d(obj):
            return obj['i']+1
    ud2 = UpDoc2(i=3)
    assert ud2.get_dirty_ops() == { '$set' : { 'd' : 4, 'i' : 3 } }, ud2.get_dirty_ops()

    ud3 = UpDoc2()
    assert ud3.get_dirty_ops() == {}, ud3.get_dirty_ops()

@raises(BadValueException)
def computed_field_unwrap_test():


    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(IntField(), deps=[a,b])
        def c(obj):
            return 'some-bad-value'
    TestDoc2.c.unwrap('bad-value')

def computed_field_wrap_value_func_test():
    class TestDoc2(Document):
        @computed_field(StringField())
        def c(obj):
            return 'foo'
    Query(TestDoc2, None).in_(TestDoc2.c, 'bar').query == {'c' : { '$in' : 'bar' }}


@raises(BadValueException)
def computed_field_wrap_test():

    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(IntField(), deps=[a,b])
        def c(obj):
            return 'some-bad-value'

    obj = TestDoc2(a=1, b=2)
    TestDoc2.wrap(obj)

def computed_field_wrap_value_test():

    class TestDoc2(Document):
        @computed_field(IntField())
        def c(obj):
            return 4

    obj = TestDoc2()
    wrapped = TestDoc2.wrap(obj)
    assert wrapped == { 'c' : 4 }, wrapped


@raises(BadValueException)
def computed_field_wrap_test_wrong_type():

    class TestDoc2(Document):
        a = IntField()
        b = IntField()
        @computed_field(IntField(), deps=[a,b])
        def c(obj):
            return 'some-bad-value'

    TestDoc2.c.wrap('bad-value')

# Caching Values and one-time fields

def computed_field_cached_value_test():
    from datetime import datetime, timedelta
    class CDoc(Document):
        offset = 0
        @computed_field(DateTimeField(), one_time=True)
        def created(obj):
            return datetime(2010, 11, 1) + timedelta(minutes=CDoc.offset)

        @computed_field(DateTimeField())
        def modified(obj):
            return datetime(2010, 11, 1) + timedelta(minutes=CDoc.offset)

    c = CDoc()
    created_before = c.created
    modified_before = c.modified
    CDoc.offset = 10
    created_after = c.created
    modified_after = c.modified

    assert created_before == created_after
    assert modified_before != modified_after

    c.modified = datetime(1970, 10, 10)
    assert c.modified == modified_after

@raises(BadValueException)
def computed_field_one_time_assignment_test():
    class CDoc(Document):
        @computed_field(IntField(), one_time=True)
        def created(obj):
            return 1

    c = CDoc()
    assert c.created == 1
    c.created = 2



########NEW FILE########
__FILENAME__ = test_documents
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import *
from mongoalchemy.fields import *
from test.util import known_failure

# Document Types used in some tests
class TestDoc(Document):
    int1 = IntField()
    def __repr__(self):
        return 'TestDoc(int1=%d)' % self.int1

# Document Types used in some tests
class TestDoc2(Document):
    sfield = StringField()
    def __repr__(self):
        return 'TestDoc(int1=%s)' % self.sfield

class T(Document, DictDoc):
    config_default_sort = [('i', 1)]
    i = IntField()
    j = IntField(required=False)
    s = StringField(required=False)
    l = ListField(IntField(), required=False)
    a = IntField(required=False, db_field='aa')
    index = Index().ascending('i')


class DocA(Document):
    test_doc = DocumentField(TestDoc, required=False)
    test_doc2 = DocumentField(TestDoc2, required=False)
    def __eq__(self, other):
        if self.__class__ != other.__class__:
            return False
        return self.test_doc.int1 == other.test_doc.int1
    def __repr__(self):
        return 'DocA()'

# Tests


def test_setup():
    document_type_registry.clear()

def get_session():
    return Session.connect('unit-testing')

def test_default_config():
    s = get_session()
    s.clear_collection(T)
    t = T(i=4)
    s.insert(t)
    for x in s.query(T).filter(T.i == 4):
        pass


@raises(BadFieldSpecification)
def test_default_sort_bad_name():
    class Foo(Document):
        config_default_sort = [('a', 1)]
    try:
        f = Foo()
    except BadFieldSpecification as e:
        assert 'resolve field' in str(e)
        raise

@raises(BadFieldSpecification)
def test_default_sort_bad_dir():
    class Foo(Document):
        a = IntField()
        config_default_sort = [('a', 3)]
    try:
        f = Foo()
    except BadFieldSpecification as e:
        assert 'sort direction' in str(e)
        raise
    assert False


def test_basic():
    class Doc(Document):
        count = IntField()
    s = get_session()
    d = Doc(count=0)
    s.insert(d)
    assert d.mongo_id

def test_basic2():
    class Doc(Document):
        config_collection_name = 'DocCol'
        count = IntField()

    assert Doc.class_name() == 'Doc', Doc.class_name()
    assert Doc.get_collection_name() == 'DocCol'

def test_mongo_id():
    class Doc(Document):
        i = IntField(_id=True)
    assert Doc.mongo_id is None

def test_update_ops():
    td = TestDoc(int1=1)
    doca = DocA(test_doc=td)
    assert doca.get_dirty_ops() == {
        '$set' : { 'test_doc.int1' : 1 }
    }, doca.get_dirty_ops()

    class DocB(Document):
        a = DocumentField(DocA)
        b = IntField()
    assert DocB(a=DocA()).get_dirty_ops() == {}

def test_delete_field():
    class Doc(Document):
        a = IntField()
        b = IntField()

    d = Doc()
    d.a = 5
    assert d.a == 5
    del d.a
    try:
        b = d.a
        assert False, 'delete attribute a failed'
    except AttributeError:
        pass

    try:
        del d.b
        assert False, 'delete attribute b failed'
    except AttributeError:
        pass


def test_inheritance():
    # classes
    class InA(Document):
        config_extra_fields = 'ignore'
        config_polymorphic = 'type'
        config_polymorphic_collection = True
        a = IntField()
        type = StringField()
    class InB(InA):
        # config_collection_name = 'InA'
        config_polymorphic_identity = 'foo'
        config_polymorphic = 'type2'
        b = IntField()
        type = StringField(default=config_polymorphic_identity)
    class InC(InB):
        # config_collection_name = 'InA'
        config_polymorphic_identity = 'bar'
        c = IntField()
        type2 = StringField(default=config_polymorphic_identity)

    # clear old data
    s = get_session()
    s.clear_collection(InA)

    b = InC(a=5, b=1, c=0)
    bb = InC(a=4, b=3, c=12)
    s.insert(b)
    s.insert(bb)
    for obj in s.query(InA).all():
        assert type(obj) == InC, type(obj)


@raises(DocumentException)
def bad_extra_fields_param_test():
    class BadDoc(Document):
        config_extra_fields = 'blah'

def extra_fields_test():
    class BadDoc(Document):
        config_extra_fields = 'ignore'
    doc_with_extra = {'foo' : [1]}

    unwrapped = BadDoc.unwrap(doc_with_extra)
    assert unwrapped.get_extra_fields() == doc_with_extra

    assert BadDoc.wrap(unwrapped) == doc_with_extra


@raises(MissingValueException)
def test_required_fields():
    class Doc(Document):
        i = IntField()
    Doc().wrap()

@raises(AttributeError)
def test_missing_fields():
    class Doc(Document):
        i = IntField(required=False)
    Doc().i

def test_non_existant_field():
    class Doc(Document):
        i = IntField(required=False)
    Doc().j = 5


def test_default_value():
    class Doc(Document):
        i = IntField(required=False, default=1)
    assert Doc().i == 1

@raises(Exception)
def bad_field_test():
    s = get_session()
    s.clear_collection(TestDoc)
    t = TestDoc(int1=1, str4='sdasa')

def loading_test():
    s = get_session()
    s.clear_collection(TestDoc)
    t = TestDoc(int1=123431)
    s.insert(t)
    for td in s.query(TestDoc):
        break
    assert td.int1 == t.int1

def docfield_not_dirty_test():
    class SuperDoc(Document):
        int1 = IntField()
        sub = DocumentField(TestDoc)
    s = get_session()
    s.clear_collection(TestDoc, SuperDoc)
    doc = TestDoc(int1=3)
    sup = SuperDoc(int1=4, sub=doc)
    s.insert(sup)
    s.update(sup)



def docfield_test():
    class SuperDoc(Document):
        int1 = IntField()
        sub = DocumentField(TestDoc)

    s = get_session()
    s.clear_collection(TestDoc, SuperDoc)

    doc = TestDoc(int1=3)
    sup = SuperDoc(int1=4, sub=doc)

    s.insert(sup)

    for sd in s.query(SuperDoc):
        break

    assert sd.int1 == sup.int1
    assert sd.sub.int1 == doc.int1

def test_non_ma_property_attribute_error():
    ''' At the time of writing, it was possble for a normal class field to be
        treated as a MA one.  If the instance's field raised an attribute
        error we would try to access the "required" attribute of the class
        level field.  This attribute only exists on MA Field instances,
        though '''
    class Doc(Document):
        i = IntField()

        @property
        def foo(self):
            raise AttributeError()

    x = Doc(i=2)
    assert Doc.unwrap(x.wrap()).i == x.i

def test_doc_field_with_alternate_name():
    class Doc(Document):
        i = IntField(db_field='ii')
        def __eq__(self, other):
            return self.i == other.i
    d = Doc(i=3)
    wrapped = d.wrap()
    assert wrapped == {'ii' : 3}
    assert d == Doc.unwrap({'ii' : 3})

def test_doc_field():

    sd = TestDoc(int1=0)
    doca = DocA(test_doc=sd)
    wrapped = doca.wrap()
    unwrapped = DocA.unwrap(wrapped)
    assert unwrapped == doca
    assert DocA.test_doc.is_valid_unwrap(wrapped)


@raises(BadValueException)
def wrong_wrap_type_test():
    doc1 = TestDoc(int1=0)
    doc2 = TestDoc2(sfield='a')
    doca = DocA(test_doc=doc2)
    doca.wrap()

@raises(BadValueException)
def wrong_wrap_type_test2():
    doc2 = TestDoc2(sfield=1) # this is an invalid value
    doca = DocA(test_doc2=doc2)
    doca.wrap()

# def is_valid_unwrap_test_true():
#     assert DocA.test_doc.is_valid_unwrap({ 'int1' : 1 }) == True

# def is_valid_unwrap_test_false():
#     assert DocA.test_doc2.is_valid_unwrap({ 'int1' : 1 }) == False

@raises(ExtraValueException)
def wrong_unwrap_type_test():
    DocA.unwrap({ 'test_doc2' : { 'int1' : 1 }, 'testdoc' : {'int1' : 1 } })

@raises(MissingValueException)
def test_upsert_with_required():
    class D(Document):
        a = IntField()
        c = IntField()
        b = IntField(required=False)

    s = get_session()
    s.clear_collection(D)
    s.update(D(b=4, c=4), id_expression=D.b == 4, upsert=True)

def test_upsert_with_no_changes():
    class D(Document):
        a = IntField()
        c = IntField()
        b = IntField(required=False)

    s = get_session()
    s.clear_collection(D)
    s.update(D(a=1, b=4, c=4), id_expression=D.b == 4, upsert=True)
    d = s.query(D).one()
    s.update(d, upsert=True)

def test_deepcopy():
    import copy
    a = TestDoc(int1=4)
    b = copy.deepcopy(a)
    assert id(a) != id(b)
    assert a.int1 == b.int1

def test_default_eq():
    a = TestDoc(int1=4)
    b = TestDoc(int1=4)
    assert not (a == b)
    a.mongo_id = ObjectId()
    b.mongo_id = ObjectId()
    assert a != b
    b.mongo_id = a.mongo_id
    assert a == b

def test_unwrapped_is_not_dirty():
    class D(Document):
        a = IntField()
    s = get_session()
    s.clear_collection(D)
    s.insert(D(a=1))
    d = s.query(D).one()
    assert len(d.get_dirty_ops()) == 0, d.get_dirty_ops()

def test_update_with_unset():
    class D(Document, DictDoc):
        a = IntField()
        c = IntField()
        b = IntField(required=False)

    s = get_session()
    s.clear_collection(D)
    d = D(a=1, b=4, c=4)
    s.update(d, id_expression=D.b == 4, upsert=True)
    d = s.query(D).one()
    del d.c
    s.update(d)
    d = s.query(D).one()
    assert 'c' not in d

@with_setup(test_setup)
def test_self_reference():
    class D(Document):
        d = DocumentField('D', required=False)
        a = IntField()
    d = D(d=D(a=5), a=4)
    assert d.wrap() == { 'd' : { 'a' : 5 }, 'a' : 4 }
    s = get_session()
    s.clear_collection(D)
    s.insert(d)
    d_from_db = s.query(D).one()
    assert d_from_db.d.a == d.d.a

@with_setup(test_setup)
def test_config_full_name():
    class E(Document):
        d = DocumentField('ma.D')
    class D(Document):
        config_full_name = 'ma.D'
        a = IntField()
    e = E(d=D(a=4))
    assert e.d.a == 4

@with_setup(test_setup)
def test_config_in_list():
    class E(Document):
        d = ListField(ListField(DocumentField('ma.D')))
    class D(Document):
        config_full_name = 'ma.D'
        a = IntField()
    e = E(d=[[D(a=4)]])
    assert e.wrap() == { 'd' : [[{'a':4}]] }

@with_setup(test_setup)
@raises(BadFieldSpecification)
def test_bad_string_doc():
    class D(Document):
        e = DocumentField('E')
    D(e=5).wrap()

@with_setup(test_setup)
@raises(BadFieldSpecification)
def test_namespaces_disabled():
    class D(Document):
        config_namespace = None
        e = DocumentField('E')
    D(e=5).wrap()

@with_setup(test_setup)
def test_set_parent_on_subtypes():
    class D(Document):
        a = IntField()

    class ParentDoc(Document):
        t = TupleField(DocumentField('D'))
        e = EnumField(DocumentField('D'), D(a=1))
        d = DictField(DocumentField('D'))

# test DictDoc

def test_dictdoc_contains():
    t = T(i=1, retrieved_fields=[T.i, T.j])
    assert 'i' in t
    assert 'j' not in t
    assert 's' not in t
    assert 'noexist' not in t
    assert t['i'] == 1

def test_dictdoc_set():
    t = T(i=1, retrieved_fields=[T.i, T.j])
    assert 'i' in t
    t['i'] = 4
    assert t.i == 4

def test_dictdoc_setdefault():
    t = T(i=1, retrieved_fields=[T.i, T.j])

    assert t.setdefault('i', 4) == 1
    assert t.setdefault('j', 3) == 3


def test_set_dict_field():
    class TestDict(Document):
        data = DictField(AnythingField())
    s = Session.connect('mongoalchemy-unit-testing')
    s.clear_collection(TestDict)

    td = TestDict()

    td.data = {"foo": "bar", "baz": "qux"}
    s.insert(td)

    td = s.query(TestDict).one()

    td.data = {"foo": "bar"}
    s.insert(td)

    td = s.query(TestDict).one()

    assert td.data == {'foo':'bar'}, td.data


########NEW FILE########
__FILENAME__ = test_fields
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.fields import *
from test.util import known_failure
from datetime import datetime
from bson.binary import Binary
import re

# Field Tests

@raises(NotImplementedError)
def test_unimplemented_wrap():
    Field().wrap({})

@raises(NotImplementedError)
def test_unimplemented_unwrap():
    Field().unwrap({})

@raises(NotImplementedError)
def test_unimplemented_is_valid_wrap():
    Field().is_valid_wrap({})

@raises(NotImplementedError)
def test_unimplemented_is_valid_unwrap():
    Field().is_valid_unwrap({})

def test_is_valid_unwrap():
    assert IntField().is_valid_unwrap('') == False
    assert IntField().is_valid_unwrap(1) == True

def test_allow_none():
    assert IntField(allow_none=True).is_valid_unwrap(None) == True
    assert IntField(allow_none=True).is_valid_wrap(None) == True
    assert IntField().is_valid_unwrap(None) == False
    assert IntField().is_valid_wrap(None) == False
    assert IntField(allow_none=True).wrap(None) is None
    assert IntField(allow_none=True).unwrap(None) is None
    assert IntField(default=None).unwrap(None) is None

def test_id_attr():
    assert IntField().is_id == False
    assert IntField(db_field='_id').is_id == True
    assert IntField(_id=True).is_id == True

@raises(InvalidConfigException)
def test_double_default():
    IntField(default=1, default_f=lambda: 1)

@raises(InvalidConfigException)
def test_bad_id_attr():
    IntField(db_field='foo', _id=True)

@raises(InvalidConfigException)
def test_bad_on_update_value():
    IntField(on_update='set')

@raises(BadValueException)
def test_validate_unwrap_fail():
    StringField().unwrap(4)

def test_custom_validator():
    def validator(x):
        print ('>>>>', x)
        return x == 0
    field = IntField(validator=validator)
    assert field.is_valid_wrap(0) == True
    assert field.is_valid_wrap(2) == False
    assert field.is_valid_unwrap(0) == True
    assert field.is_valid_unwrap(2) == False

    field = IntField(wrap_validator=lambda x : x == 0)
    assert field.is_valid_wrap(0) == True
    assert field.is_valid_wrap(2) == False

    field = IntField(unwrap_validator=lambda x : x == 0)
    assert field.is_valid_unwrap(0) == True
    assert field.is_valid_unwrap(2) == False

# String Tests
@raises(BadValueException)
def string_wrong_type_test():
    StringField().wrap(4)

@raises(BadValueException)
def string_too_long_test():
    StringField(max_length=4).wrap('12345')

@raises(BadValueException)
def string_too_short_test():
    StringField(min_length=4).wrap('123')

def string_value_test():
    s = StringField()
    assert s.wrap('foo') == 'foo'
    assert s.unwrap('bar') == 'bar'

# RegEx String Tests
IP_ADDR_RE = re.compile(r"^" + r"\.".join([r"([01]?\d\d?|2[0-4]\d|25[0-5])"]*4) + r"$")
@raises(BadValueException)
def regex_wrong_type_test():
    RegExStringField(IP_ADDR_RE).wrap(4)

@raises(BadValueException)
def regex_no_match_test():
    RegExStringField(IP_ADDR_RE).wrap('192.168.1.260')

def regex_value_test():
    s = RegExStringField(IP_ADDR_RE)
    assert s.wrap('192.168.1.127') == '192.168.1.127'
    assert s.unwrap('192.168.1.127') == '192.168.1.127'

# Bool Field
@raises(BadValueException)
def bool_wrong_type_test():
    BoolField().wrap(4)

def bool_value_test():
    b = BoolField()
    assert b.wrap(True) == True
    assert b.unwrap(False) == False

# Number Fields
@raises(BadValueException)
def int_wrong_type_test():
    IntField().wrap('4')

@raises(BadValueException)
def int_too_high_test():
    IntField(max_value=4).wrap(5)

@raises(BadValueException)
def int_too_low_test():
    IntField(min_value=4).wrap(3)

def int_value_test():
    s = IntField()
    assert s.wrap(1) == 1
    assert s.unwrap(1564684654) == 1564684654

@raises(BadValueException)
def float_wrong_type_test():
    FloatField().wrap('1')

# Date/time field
@raises(BadValueException)
def datetime_wrong_type_test():
    DateTimeField().wrap(4)

@raises(BadValueException)
def datetime_too_new_test():
    DateTimeField(max_date=datetime(2009, 7, 9)).wrap(datetime(2009, 7, 10))

@raises(BadValueException)
def datetime_too_old_test():
    DateTimeField(min_date=datetime(2009, 7, 9)).wrap(datetime(2009, 7, 8))

def datetime_value_test():
    s = DateTimeField()
    assert s.wrap(datetime(2009, 7, 9)) == datetime(2009, 7, 9)
    assert s.unwrap(datetime(2009, 7, 9)) == datetime(2009, 7, 9), (s.unwrap(datetime(2009, 7, 9)),)

@raises(BadValueException)
def test_tz_unaware():
    s = DateTimeField(use_tz=True)
    s.wrap(datetime.now())

def test_tz_aware():
    import pytz
    from mongoalchemy.session import Session
    from mongoalchemy.document import Document
    # doc
    class DocTZ(Document):
        time = DateTimeField(use_tz=True)
    class DocNoTZ(Document):
        time = DateTimeField(use_tz=False)

    # timezone -- choose one where the author doesn't live
    eastern = pytz.timezone('Australia/Melbourne')
    utc = pytz.utc
    # session
    s = Session.connect('unit-testing', timezone=eastern)
    s.clear_collection(DocTZ)
    s.clear_collection(DocNoTZ)
    # time
    local = eastern.localize(datetime.now())
    local = local.replace(microsecond=0)
    doc = DocTZ(time=local)
    s.insert(doc)

    doc = s.query(DocTZ).one()
    assert doc.time == local, (doc.time, local)

    # do the no timezone case for code coverage
    s.insert(DocNoTZ(time=datetime(2012, 1, 1)))
    obj = s.query(DocNoTZ).one()




# Anything Field
def test_anything():
    a = AnythingField()
    foo = {'23423423' : [23423432], 'fvfvf' : { 'a' : [] }}
    assert a.is_valid_wrap(foo)
    assert a.is_valid_unwrap(foo)
    assert a.unwrap(a.wrap(foo)) == foo

#ObjectID Field
@raises(BadValueException)
def objectid_wrong_type_test():
    from bson.objectid import ObjectId
    ObjectIdField().wrap(1)

@raises(BadValueException)
def objectid_wrong_type_unwrap_test():
    from bson.objectid import ObjectId
    ObjectIdField().unwrap(1)

def test_object_id_auto():
    from mongoalchemy.document import Document
    class A(Document):
        idf = ObjectIdField(auto=True, required=False)
    assert 'idf' in A().wrap()

#ObjectID Field
@raises(BadValueException)
def objectid_wrong_hex_length_test():
    from bson.objectid import ObjectId
    ObjectIdField().wrap('c9e2587eae7dd6064000000')

def objectid_value_test():
    from bson.objectid import ObjectId
    o = ObjectIdField()
    oid = ObjectId('4c9e2587eae7dd6064000000')
    assert o.unwrap(o.wrap(oid)) == oid

    oid2 = '4c9e2587eae7dd6064000000'
    assert o.unwrap(o.wrap(oid2)) == oid

    assert o.wrap(o.unwrap(oid.binary)) == oid

    assert isinstance(o.gen(), ObjectId)


# TupleField
@raises(BadValueException)
def tuple_wrong_type_test_wrap():
    TupleField(IntField()).wrap(4)

@raises(BadValueException)
def tuple_wrong_type_test_unwrap():
    TupleField(IntField()).unwrap(4)

@raises(BadValueException)
def first_type_wrong_test():
    TupleField(IntField(), IntField(), IntField()).wrap(('1', 2, 3))

@raises(BadValueException)
def third_type_wrong_test():
    TupleField(IntField(), IntField(), IntField()).wrap((1, 2, '3'))

@raises(BadValueException)
def first_type_wrong_test_unwrap():
    TupleField(IntField(), IntField(), IntField()).unwrap(['1', 2, 3])

@raises(BadValueException)
def third_type_wrong_test_unwrap():
    TupleField(IntField(), IntField(), IntField()).unwrap([1, 2, '3'])

def tuple_value_test():
    s = TupleField(IntField(), StringField(), ListField(IntField()))
    before = (1, '2', [3,3,3])
    after = [1, '2', [3,3,3]]
    assert s.wrap(before) == after, s.wrap(before)
    assert s.unwrap(after) == before, s.unwrap(after)

# EnumField
@raises(BadValueException)
def enum_wrong_type_test_wrap():
    EnumField(StringField(), '1', '2', '3', '4').wrap(4)

@raises(BadValueException)
def enum_wrong_type_test_unwrap():
    EnumField(StringField(), '1', '2', '3', '4').unwrap(4)

@raises(BadValueException)
def enum_wrong_value_test_wrap():
    EnumField(IntField(), 1, 3).wrap(2)

@raises(BadValueException)
def enum_wrong_value_test_unwrap():
    EnumField(IntField(), 1, 3).unwrap(2)

def enum_value_test():
    s = EnumField(ListField(IntField()), [1,2], [3,4])
    assert s.wrap([1,2]) == [1,2]
    assert s.unwrap([3,4]) == [3,4]


# Binary Field

@raises(BadValueException)
def binary_wrong_type_test_wrap():
    BinaryField().wrap(4)

@raises(BadValueException)
def binary_wrong_type_test_unwrap():
    BinaryField().unwrap(4)

def binary_value_test():
    s = BinaryField()
    assert s.wrap(Binary(bytes('foo'.encode('ascii')))) == Binary(bytes('foo'.encode('ascii')))
    assert s.wrap(bytes('foo'.encode('ascii'))) == Binary(bytes('foo'.encode('ascii')))
    assert s.unwrap(Binary(bytes('foo'.encode('ascii')))) == Binary(bytes('foo'.encode('ascii')))


########NEW FILE########
__FILENAME__ = test_index
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index
from mongoalchemy.fields import *
from datetime import datetime
from test.util import known_failure
from time import sleep

def get_session():
    return Session.connect('unit-testing')

class TestDoc(Document):

    int1 = IntField()
    str1 = StringField()
    str2 = StringField()
    str3 = StringField()

    index_1 = Index().ascending('int1').descending('str3')
    index_2 = Index().descending('str3')
    index_3 = Index().descending('str2').unique()
    index_4 = Index().descending('str1').unique(drop_dups=True)

def test_indexes():
    s = get_session()
    s.clear_collection(TestDoc)
    t = TestDoc(int1=1, str1='a', str2='b', str3='c')
    s.insert(t)

    try:
        import json
    except:
        import simplejson as json

    desired = '''{"_id_": {"key": [["_id", 1]], "v": 1}, "int1_1_str3_-1": {"dropDups": false, "key": [["int1", 1], ["str3", -1]], "v": 1}, "str1_-1": {"dropDups": true, "key": [["str1", -1]], "unique": true, "v": 1}, "str2_-1": {"dropDups": false, "key": [["str2", -1]], "unique": true, "v": 1}, "str3_-1": {"dropDups": false, "key": [["str3", -1]], "v": 1}}'''
    got = s.get_indexes(TestDoc)
    got = json.dumps(got, sort_keys=True)
    assert got == desired, '\nG: %s\nD: %s' % (got, desired)

def expire_index_test():
    class TestDoc3(TestDoc):
        date = DateTimeField()

        index_exire = Index().ascending('date').expire(30)
    t = TestDoc3(int1=123456, str1='abcd', str2='b', str3='c', date=datetime.utcnow())
    s = get_session()
    s.insert(t)

    # Check that the document is indeed inserted
    assert len(s.query('TestDoc3').filter({'int1': 123456}).all()) > 0

    # The document will be deleted within a minute from its expiration
    # datetime
    sleep(62)

    # Check that the document is no longer there
    assert len(s.query('TestDoc3').filter({'int1': 123456}).all()) == 0


@known_failure
@raises(Exception)
def no_field_index_test():
    class TestDoc2(TestDoc):
        index_1 = Index().ascending('noexists')
    s.get_session()
    s.clear_collection(TestDoc)
    s.insert(t)

########NEW FILE########
__FILENAME__ = test_mapping_fields
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.fields import *
from test.util import known_failure

# DictField
@raises(BadValueException)
def dict_wrong_type_test_wrap():
    DictField(IntField()).wrap(4)

@raises(BadValueException)
def dict_bad_type_test_unwrap():
    DictField(IntField()).unwrap(4)

@raises(BadValueException)
def dict_wrong_value_type_test_wrap():
    DictField(StringField()).wrap({ 'a' : 4})

@raises(BadValueException)
def dict_wrong_value_type_test_unwrap():
    DictField(StringField()).unwrap({ 'a' : 4})

@raises(BadFieldSpecification)
def dict_bad_value_type_test_wrap():
    DictField(int).wrap({'a' : 4})

def dict_value_test():
    s = DictField(StringField())
    foo = {'a' : 'b'}
    assert s.unwrap(s.wrap(foo)) == foo

@raises(BadValueException)
def bad_key_integer_wrap_test():
    DictField(StringField()).wrap({1 : 'b'})


@raises(BadValueException)
def bad_key_dot_wrap_test():
    DictField(StringField()).wrap({'a.b' : 'b'})

@raises(BadValueException)
def bad_key_dollar_wrap_test():
    DictField(StringField()).wrap({'a$b' : 'b'})

@raises(BadValueException)
def bad_key_dot_unwrap_test():
    DictField(StringField()).unwrap({'a.b' : 'b'})

@raises(BadValueException)
def bad_key_dollar_unwrap_test():
    DictField(StringField()).unwrap({'a$b' : 'b'})

def dict_default_test():
    s = DictField(StringField(), default_empty=True)
    assert s.default == {}


# KVField

def kv_test_autoload():
    s = KVField(IntField(), RefField(), default_empty=True)
    assert s.has_autoload
    # assert s.default == {}

def kv_default_test():
    s = KVField(StringField(), StringField(), default_empty=True)
    assert s.default == {}
    s = KVField(StringField(), StringField(), default={'a':1})
    assert s.default == {'a':1}

@raises(BadValueException)
def kv_wrong_type_test_wrap():
    KVField(IntField(), IntField()).wrap(4)

@raises(BadValueException)
def kv_bad_type_test_unwrap():
    KVField(IntField(), IntField()).unwrap(4)



@raises(BadValueException)
def kv_wrong_value_type_test_wrap():
    KVField(StringField(), StringField()).wrap({ 'a' : 4 })

@raises(BadValueException)
def kv_wrong_key_type_test_wrap():
    KVField(StringField(), StringField()).wrap({ 4 : 'a'})

@raises(BadValueException)
def kv_wrong_value_type_test_unwrap():
    KVField(StringField(), StringField()).unwrap([{'k':'a', 'v':4}])

@raises(BadValueException)
def kv_wrong_key_type_test_unwrap():
    KVField(StringField(), StringField()).unwrap([{'k' : 4, 'v' : 'a'}])



@raises(BadFieldSpecification)
def kv_bad_key_type_test():
    KVField(int, IntField())

@raises(BadFieldSpecification)
def kv_bad_key_type_test2():
    KVField(IntField(), int)

@raises(BadValueException)
def kv_bad_key_value_none_test():
    KVField(IntField(), IntField()).unwrap([{'k' : None, 'v' : 1}])


@raises(BadFieldSpecification)
def kv_bad_value_type_test():
    KVField(IntField(), int)



def kv_value_test():
    s = KVField(StringField(), IntField())
    foo = {'a' : 4, 'v' : 9}
    assert s.unwrap(s.wrap(foo)) == foo



@raises(BadValueException)
def kv_broken_kv_obj_test():
    s = KVField(StringField(), IntField())
    s.unwrap([{'k' : 'a', 'value' : 5}])

@raises(BadValueException)
def kv_broken_kv_obj_test2():
    s = KVField(StringField(), IntField())
    s.unwrap([('a', 5)])

########NEW FILE########
__FILENAME__ = test_query
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index, FieldNotRetrieved
from mongoalchemy.fields import *
from mongoalchemy.query import BadQueryException, Query, BadResultException
from test.util import known_failure

class T(Document):
    i = IntField()
    j = IntField(required=False)
    l = ListField(IntField(), required=False)
    a = IntField(required=False, db_field='aa')
    index = Index().ascending('i')

class T2(Document):
    t = DocumentField(T)

class T3(Document):
    t_list = ListField(DocumentField(T))

def get_session():
    s = Session.connect('unit-testing')
    s.clear_collection(T, T2, T3)
    return s

def test_elem_match_field():
    s = get_session()
    match = T3.t_list.elem_match({'i':1})
    q = s.query(T3).fields(match)
    expr = q._fields_expression()
    expected = {
        't_list' : {
            '$elemMatch' : {'i': 1}
        },
        '_id' : True,
    }
    assert expr == expected, q._fields_expression()
    assert str(match) == 't_list'

def test_fields_exclude():
    s = get_session()
    q = s.query(T3).fields(T3.mongo_id.exclude())
    expr = q._fields_expression()
    expected = {
        '_id' : False,
    }
    assert expr == expected, q._fields_expression()

def test_update():
    s = get_session()

    obj = T(i=3)

    s.insert(obj)

    for o in s.query(T):
        assert o.i == 3

    s.query(T).filter(T.i==3).set(T.i, 4).execute()

    for o in s.query(T):
        assert o.i == 4

def test_field_filter():
    s = get_session()
    s.clear_collection(T, T2)

    # Simple Object
    obj = T(i=3)
    s.insert(obj)
    for t in s.query(T).fields(T.i):
        break
    assert t.i == 3
    # Nested Object
    obj2 = T2(t=obj)
    s.insert(obj2)
    for t2 in s.query(T2).fields(T2.t.i):
        break
    assert t2.t.i == 3

def test_raw_output():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    value = s.query(T).raw_output().one()
    assert isinstance(value, dict)

def test_limit():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    s.insert(T(i=5))
    for count, item in enumerate(s.query(T).limit(2)):
        pass
    assert count == 1

def test_skip():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    s.insert(T(i=5))
    for count, item in enumerate(s.query(T).skip(2)):
        pass
    assert count == 0

def test_hint():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    for item in s.query(T).hint_asc(T.i):
        pass

@raises(BadQueryException)
def test_hint_validation():
    s = get_session()
    s.query(T).hint_asc(T.i).hint_desc(T.i)

@raises(BadResultException) # too many values to unpack
def test_one_fail():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    s.query(T).one()

@raises(BadResultException) # too few values to unpack
def test_one_fail_too_few():
    s = get_session()
    s.clear_collection(T)
    s.query(T).one()


def test_one():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    assert s.query(T).one().i == 3

def test_first():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    assert s.query(T).descending(T.i).first().i == 4
    assert s.query(T).ascending(T.i).first().i == 3

def test_first_empty():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    assert s.query(T).filter(T.i > 5).first() is None

def test_all():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    for count, item in enumerate(s.query(T).all()):
        pass
    assert count == 1

def test_distinct():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3, j=4))
    s.insert(T(i=3, j=5))
    s.insert(T(i=3, j=6))
    for count, item in enumerate(s.query(T).distinct(T.i)):
        pass
    assert count == 0, count

def test_count():
    s = get_session()
    s.clear_collection(T)
    assert s.query(T).count() == 0
    s.insert(T(i=3, j=4))
    s.insert(T(i=3, j=5))
    s.insert(T(i=3, j=6))
    assert s.query(T).count() == 3

def test_explain():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    assert 'allPlans' in s.query(T).filter(T.i > 5).explain()


def test_clone():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    q = s.query(T)
    q2 = q.clone()
    q.skip(2)
    for count, item in enumerate(q2):
        pass
    assert count == 1

def test_raw_query():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    assert s.query(T).filter({'i':3}).one().i == 3

@raises(FieldNotRetrieved)
def test_field_filter_non_retrieved_field():
    s = get_session()
    s.clear_collection(T)
    obj = T(i=3, j=2)
    s.insert(obj)
    for t in s.query(T).fields(T.i):
        break
    assert t.j == 2

@raises(FieldNotRetrieved)
def test_field_filter_non_retrieved_subdocument_field():
    s = get_session()
    s.clear_collection(T, T2)
    obj = T(i=3, j=2)
    obj2 = T2(t=obj)
    s.insert(obj2)
    for t2 in s.query(T2).fields(T2.t.i):
        break
    assert t2.t.j == 2

@raises(FieldNotRetrieved)
def test_save_partial_subdocument_fail():
    class Foo(Document):
        a = DocumentField('Bar')
    class Bar(Document):
        b = IntField()
        c = IntField()
    s = get_session()
    s.clear_collection(Foo)
    s.clear_collection(Bar)
    bar = Bar(b=1432, c=1112)
    s.insert(bar)
    bar = s.query(Bar).filter_by(b=1432, c=1112).fields('c').one()
    s.insert(Foo(a=bar))
    s.query(Foo).filter(Foo.a.c==1112).one()


def test_save_partial_subdocument():
    class Foo(Document):
        a = DocumentField('Bar')
    class Bar(Document):
        b = IntField(required=False)
        c = IntField()
    s = get_session()
    s.clear_collection(Foo)
    s.clear_collection(Bar)
    bar = Bar(b=1432, c=1112)
    s.insert(bar)
    bar = s.query(Bar).filter_by(b=1432, c=1112).fields('c').one()
    s.insert(Foo(a=bar))
    s.query(Foo).filter(Foo.a.c==1112).one()


@raises(Exception)
def repeated_field_query_test():
    s = get_session()
    s.clear_collection(T)
    s.query(T).filter(T.i==3).filter(T.i==3)

@raises(Exception)
def repeated_field_query_test2():
    s = get_session()
    s.clear_collection(T)
    s.query(T).filter(T.i==3, T.i==3)

def nested_field_query_test():
    s = get_session()
    s.clear_collection(T, T2)
    assert s.query(T2).filter(T2.t.i==3, T2.t.j==2).query == {'t.i':3, 't.j':2}

@known_failure
@raises(Exception)
def repeated_field_update_test():
    s = get_session()
    s.clear_collection(T)
    s.query(T).filter(T.i==3).set(T.i, 4).set(T.i, 5)

def test_comparators():
    # once filters have more sanity checking, this test will need to be broken up
    s = get_session()
    query_obj = s.query(T).filter(T.i < 2,
        T.i > 3,
        T.i != 4,
        T.i <= 5,
        T.i >= 6).query

    assert query_obj == {'i': {'$ne': 4, '$gte': 6, '$lte': 5, '$gt': 3, '$lt': 2}}

    s.query(T).filter(T.i == 1).query == { 'i' : 1}


@raises(BadQueryException)
def invalid_combination_test():
    s = get_session()
    s.query(T).filter(T.i < 2, T.i == 4)


def test_sort():
    from pymongo import ASCENDING, DESCENDING
    s = get_session()
    sorted_query = s.query(T).ascending(T.i).descending(T.j)
    assert sorted_query._sort == [('i', ASCENDING),('j', DESCENDING)], sorted_query._sort
    for obj in sorted_query:
        pass

def test_sort2():
    from pymongo import ASCENDING, DESCENDING
    s = get_session()
    sorted_query = s.query(T).sort((T.i, ASCENDING), ('j', DESCENDING))
    assert sorted_query._sort == [('i', ASCENDING),('j', DESCENDING)], sorted_query._sort

@raises(BadQueryException)
def test_sort_bad_dir():
    from pymongo import ASCENDING, DESCENDING
    s = get_session()
    sorted_query = s.query(T).sort((T.i, ASCENDING), ('j', 4))
    assert sorted_query._sort == [('i', ASCENDING),('j', DESCENDING)], sorted_query._sort

@raises(BadQueryException)
def test_sort_by_same_key():
    s = get_session()
    sorted_query = s.query(T).ascending(T.i).descending(T.i)


#
#   QueryResult tests
#

def qr_test_misc():
    s = get_session()
    cursor = iter(s.query(T))
    assert cursor.__iter__() == cursor

def qr_test_getitem():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    assert s.query(T).descending(T.i)[0].i == 4

def qr_test_rewind():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    it = iter(s.query(T))
    next(it)
    next(it)
    it.rewind()
    next(it)
    next(it)
    try:
        next(it)
    except StopIteration:
        pass

def qr_test_clone():
    s = get_session()
    s.clear_collection(T)
    s.insert(T(i=3))
    s.insert(T(i=4))
    it = iter(s.query(T))
    next(it)
    next(it)
    it2 = it.clone()
    next(it2)
    next(it2)
    try:
        next(it2)
    except StopIteration:
        pass

def test_resolve_fields():
    class Resolver(Document):
        i = IntField(db_field='j')
        k = IntField()
    s = get_session()
    s.clear_collection(Resolver)

    q = s.query(Resolver).filter(Resolver.i.in_(6))
    q = s.query(Resolver).set(Resolver.i, 6)


########NEW FILE########
__FILENAME__ = test_query_expressions
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index, FieldNotRetrieved
from mongoalchemy.fields import *
from mongoalchemy.query import BadQueryException, Query, BadResultException
from mongoalchemy.query_expression import Q
from test.util import known_failure


# TODO: Test al operators to make sure wrap is called on their values

class T(Document):
    i = IntField()
    j = IntField(required=False)
    l = ListField(IntField(), required=False)
    a = IntField(required=False, db_field='aa')
    index = Index().ascending('i')

class T2(Document):
    t = DocumentField(T)

class T3(Document):
    t_list = ListField(DocumentField(T))

class NestedChild(Document):
    i = IntField()
class NestedParent(Document):
    l = ListField(DocumentField(NestedChild))


def get_session():
    s = Session.connect('unit-testing')
    s.clear_collection(T, T2, T3)
    return s
#
#   Test Query Fields
#

@raises(BadQueryException)
def test_sort_by_same_key():
    s = get_session()
    sorted_query = s.query(T).ascending(T.i).descending(T.i)

def test_name_generation():
    s = get_session()
    assert str(T.i) == 'i'

def test_ne():
    assert (T.i != T.j) == True
    assert (T.i != T.i) == False

def query_field_repr_test():
    assert repr(T.i) == 'QueryField(i)'

def test_nested_matching():
    assert str(NestedParent.l.i) == 'l.i'

#
#   Test elem_match ($elemMatch)
#
def test_elem_match_simple():
    s = get_session()
    q = s.query(T3).filter(T3.t_list.elem_match({'i': 1}))
    assert q.query == {'t_list': {'$elemMatch': {'i': 1}}}

    q = s.query(T3).filter(T3.t_list.elem_match(T.i == 1))
    assert q.query == {'t_list': {'$elemMatch': {'i': 1}}}, q.query

@raises(BadQueryException)
def test_non_seq_elem_match():
    s = get_session()
    s.query(T).filter(T.i.elem_match({'i':1}))

@raises(BadQueryException)
def test_bad_val():
    s = get_session()
    s.query(T3).filter(T3.t_list.elem_match(None))




#
# QueryField Tests
#
@raises(AttributeError)
def test_bad_query_field_name():
    T.q

@raises(AttributeError)
def test_subitem_of_no_subitem():
    T.i.i

def qf_parent_test():
    assert str(T2.t.i._get_parent()) == 't'

@raises(BadQueryException)
def qf_bad_subfield_test():
    assert str(T2.t.q) == 't.q'

def qf_db_name_test():
    assert str(T.a) == 'aa', str(T.a)

#
# Value Encoding Type tests
#
def test_value_type_wrapping():
    class User(Document):
        bio = SetField(StringField())
    s = get_session()
    s.clear_collection(User)

    q = s.query(User).in_(User.bio, 'MongoAlchemy').query
    assert q == { 'bio' : { '$in' : ['MongoAlchemy'] } }, q

    q = s.query(User).in_(User.bio, set(['MongoAlchemy'])).query
    assert q == { 'bio' : { '$in' : [['MongoAlchemy']] } }, q

def test_value_type_wrapping_2():
    class User(Document):
        bio = KVField(StringField(), IntField())
    s = get_session()
    s.clear_collection(User)
    q = s.query(User).in_(User.bio.k, 'MongoAlchemy').query
    assert q == { 'bio.k' : { '$in' : ['MongoAlchemy'] } }, q

    q = s.query(User).in_(User.bio, { 'MongoAlchemy' : 5}).query
    assert q == { 'bio' : { '$in' : [[{'k': 'MongoAlchemy', 'v': 5}]] } }, q

@raises(BadValueException)
def test_value_type_wrapping_wrong_twice():
    class User(Document):
        bio = SetField(StringField())
    s = get_session()
    s.query(User).in_(User.bio, 1).query == { 'bio' : { '$in' : ['MongoAlchemy'] } }

def list_in_operator_test():
    class User(Document):
        ints = ListField(IntField())
    s = get_session()
    s.clear_collection(User)

    q = s.query(User).filter_by(ints=3).query
    assert q == { 'ints' : 3 }, q

    q = s.query(User).filter(User.ints == 3).query
    assert q == { 'ints' : 3 }, q

    q = s.query(User).filter(User.ints == [3]).query
    assert q == { 'ints' : [3] }, q

#
#   Geo Tests
#
def test_geo():
    class Place(Document):
        config_collection_name = 'places4'
        loc = GeoField()
        val = IntField()
        index = Index().geo2d('loc', min=-100, max=100)
    s = Session.connect('unit-testing')
    s.clear_collection(Place)
    s.insert(Place(loc=(1,1), val=2))
    s.insert(Place(loc=(5,5), val=4))
    s.insert(Place(loc=(30,30 ), val=5))
    x = s.query(Place).filter(Place.loc.near(0, 1))
    assert x.first().val == 2, x.query

    xs = s.query(Place).filter(Place.loc.near(1, 1, max_distance=2)).all()
    assert len(xs) == 1, xs

    xs = s.query(Place).filter(Place.loc.near_sphere(1, 1, max_distance=50)).all()
    assert len(xs) == 3

    q = s.query(Place).filter(Place.loc.within_box([-2, -2], [2, 2]))
    assert len(q.all()) == 1, q.query

    q = s.query(Place).filter(Place.loc.within_radius(0, 0, 2))
    assert len(q.all()) == 1, q.query

    q = s.query(Place).filter(Place.loc.within_polygon(
        [[-2, 0], [2, 0], [0, 2], [0, -2]]
    ))
    assert len(q.all()) == 1, q.query

    q = s.query(Place).filter(Place.loc.within_radius_sphere(30, 30, 0.0001))
    assert len(q.all()) == 1, q.all()


def test_geo_haystack():
    class Place(Document):
        config_collection_name = 'places'
        loc = GeoField()
        val = IntField()
        index = Index().geo_haystack('loc', bucket_size=100).descending('val')
    s = Session.connect('unit-testing')
    s.clear_collection(Place)
    s.insert(Place(loc=(1,1), val=2))
    s.insert(Place(loc=(5,5), val=4))




#
#  Comparator Tests
#
@raises(BadValueException)
def qf_bad_value_equals_test():
    T2.t.i == '3'

@raises(BadValueException)
def qf_bad_value_compare_test():
    T2.t.i < '3'

def qf_dot_f_test():

    class T3(Document):
        i = IntField()
        j = IntField(required=False)
        l = ListField(IntField(), required=False)
        a = IntField(required=False, db_field='aa')
        index = Index().ascending('i')

    class T4(Document):
        t = DocumentField(T3)

    assert str(T4.t.i) == 't.i'

def test_not():
    not_q = Query(T, None).filter( ~(T.i == 3) ).query
    assert not_q == { 'i' : {'$ne' : 3} }, not_q

    not_q = Query(T, None).not_(T.i > 4).query
    assert not_q == { 'i' : {'$not': { '$gt': 4}} }, not_q

@raises(BadQueryException)
def test_not_with_malformed_field():
    class Any(DocumentField):
        i = AnythingField()
    not_q = Query(Any, None).not_(Any.i == { '$gt' : 4, 'garbage' : 5})

def test_not_assign_dict_malformed_field():
    class Any(Document):
        i = AnythingField()
    not_q = Query(Any, None).not_(Any.i == { 'a' : 4, 'b' : 5}).query
    assert not_q == { 'i' : { '$ne' : { 'a' : 4, 'b' : 5 } } }, not_q

def test_not_db_test():
    s = get_session()
    s.insert(T(i=5))
    assert s.query(T).not_(T.i == 5).first() is None
    assert s.query(T).not_(T.i > 6).one().i == 5

def test_or():
    q = Query(T, None)

    want = { '$or' : [{'i' : 3}, {'i' : 4}, {'i' : 5}] }
    assert q.filter((T.i == 3) | (T.i == 4) | (T.i == 5)).query == want

    assert Query(T, None).or_(T.i == 3, T.i == 4, T.i == 5).query == want

def test_in():
    q = Query(T, None)
    assert q.in_(T.i, 1, 2, 3).query == {'i' : {'$in' : [1,2,3]}}, q.in_(T.i, 1, 2, 3).query
    assert q.filter(T.i.in_(1, 2, 3)).query == {'i' : {'$in' : [1,2,3]}}

def test_nin():
    q = Query(T, None)
    assert q.nin(T.i, 1, 2, 3).query == {'i' : {'$nin' : [1,2,3]}}, q.nin(T.i, 1, 2, 3).query
    assert q.filter(T.i.nin(1, 2, 3)).query == {'i' : {'$nin' : [1,2,3]}}

def test_exists():
    q = Query(T, None)
    assert q.filter(T.i.exists(False)).query == {'i': {'$exists': False}}
    assert q.filter(T.i.exists(True)).query == {'i': {'$exists': True}}


# free-form queries

def test_ffq():
    s = get_session()
    q = s.query('T')
    assert q.filter(Q.name == 3).query == {'name' : 3}

    q = s.query('T').filter(Q.name.first == 'jeff').query
    assert q == {'name.first' : 'jeff'}, q

    s.insert(T(i=4))
    assert s.query('T').count() == 1

    assert s.query('T').filter(Q.i == 4).one()['i'] == 4

# Array Index Operator
def test_array_index_operator():
    assert str(NestedParent.l.matched_index().i) == 'l.$.i', NestedParent.l.matched_index().i


########NEW FILE########
__FILENAME__ = test_ref_field
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.fields import *

from mongoalchemy.exceptions import DocumentException, MissingValueException, \
        ExtraValueException, FieldNotRetrieved, BadFieldSpecification, \
        BadReferenceException
from mongoalchemy.document import Document, document_type_registry
from mongoalchemy.session import Session
from test.util import known_failure
from datetime import datetime
from bson.dbref import DBRef
from bson import ObjectId

def get_session(cache_size=0):
    s = Session.connect('unit-testing', cache_size=cache_size)
    s.clear_collection(A)
    s.clear_collection(C)
    return s

def test_setup():
    document_type_registry.clear()

class A(Document):
    x = IntField()
class AA(Document):
    x = IntField()
class B(Document):
    y = RefField(DocumentField(A))
class C(Document):
    y = RefField(DocumentField(A))

# Field Tests

def test_simple_dereference():
    class ASD(Document):
        x = IntField()
    class BSD(Document):
        y_id = SRefField(DocumentField(ASD))
        y = y_id.rel()

    s = get_session()
    s.clear_collection(ASD)
    s.clear_collection(BSD)
    a = ASD(x=4)
    s.insert(a)

    b = BSD()
    b.y = a
    s.add_to_session(b)
    assert b.y.x == 4

def test_poly_ref():
    class PRef(Document):
        config_polymorphic_collection = True
        x = IntField()

    class PRef2(PRef):
        y = IntField()
    r2 = PRef2()
    r2.mongo_id = ObjectId()
    assert RefField()._to_ref(r2).collection == 'PRef'


def test_proxy():
    class TPB(Document):
        b = IntField(default=3)
    class TPA(Document):
        x_ids = ListField(RefField(TPB, allow_none=True), default_empty=True, allow_none=True)
        xs = x_ids.rel()
        x_id = RefField(TPB, allow_none=True)
        x = x_id.rel()

    s = get_session()
    s.clear_collection(TPA)
    s.clear_collection(TPB)

    a = TPA()
    for i in range(0, 3):
        b = TPB(b=i)
        s.insert(b)
        a.x_id = b.to_ref()
        a.x_ids.append(b.to_ref())

    s.insert(a)
    aa = s.query(TPA).one()
    assert aa.x.b == 2, aa.x.b
    assert [z.b for z in aa.xs] == list(range(0, 3))

    a_none = TPA(x_id=None, x_ids=[None])
    a_none._set_session(s)
    assert a_none.x is None
    assert list(a_none.xs) == [None]

    a_set = TPA()
    a_set.x = b

def test_proxy_ignore_missing():
    class TPIMB(Document):
        b = IntField(default=3)
    class TPIMA(Document):
        x_ids = ListField(RefField(TPIMB), default_empty=True)
        xs = x_ids.rel(ignore_missing=True)
        x_id = RefField(TPIMB)
        x = x_id.rel()

    s = get_session()
    s.clear_collection(TPIMA)
    s.clear_collection(TPIMB)

    a = TPIMA()
    for i in range(0, 3):
        b = TPIMB(b=i)
        b.mongo_id = ObjectId()
        if i > 0:
            s.insert(b)

        a.x_id = b.to_ref()
        a.x_ids.append(b.to_ref())

    s.insert(a)
    aa = s.query(TPIMA).one()

    assert len(list(aa.xs)) == 2, len(list(aa.xs))

def test_dereference():
    class A(Document):
        x = IntField()
    class B(Document):
        y = RefField(DocumentField(A))

    a = A(x=5)
    s = get_session(cache_size=10)
    s.insert(a)
    aref = {'$id':a.mongo_id, '$ref':'A'}
    dbref = DBRef(collection='A', id=a.mongo_id)

    assert s.dereference(a).x == 5

def test_ref_with_cache():
    class A(Document):
        x = IntField()
    class B(Document):
        y = RefField(A, proxy='yyy')

    s = get_session(cache_size=10)
    a = A(x=5)
    s.insert(a)
    b = B(y=a.to_ref())
    s.insert(b)

    s2 = get_session(cache_size=10)
    b2 = s2.query(B).filter_by(mongo_id=b.mongo_id).one()
    assert id(s.dereference(b2.y)) == id(a)


def test_unwrap():
    class A(Document):
        x = IntField()
    s = get_session()

    a = A(x=5)
    s.insert(a)

    aref = {'$id':a.mongo_id, '$ref':'A'}
    dbaref = DBRef(db='unit-testing', collection='A', id=a.mongo_id)

    ret = RefField(DocumentField(A)).unwrap(dbaref)
    assert isinstance(ret, DBRef), ret

    ret = SRefField(A).unwrap(a.mongo_id)
    assert isinstance(ret, ObjectId), ret

@raises(BadValueException)
def test_unwrap_bad_type():
    class A(Document):
        x = IntField()
    s = get_session()

    a = A(x=5)
    s.insert(a)

    aref = {'$id':a.mongo_id, '$ref':'A'}
    dbaref = DBRef(db='unit-testing', collection='A', id=a.mongo_id)

    ret = RefField(DocumentField(A)).unwrap(5)

@raises(BadValueException)
def test_unwrap_missing_db():
    class A(Document):
        x = IntField()
    s = get_session()

    a = A(x=5)
    s.insert(a)

    aref = {'$id':a.mongo_id, '$ref':'A'}
    dbaref = DBRef(collection='A', id=a.mongo_id)

    ret = RefField(DocumentField(A), db_required=True).unwrap(dbaref)

def test_dereference_doc():
    class A(Document):
        x = IntField()

    s = Session.connect('unit-testing', cache_size=0)
    s.clear_collection(A)

    a = A(x=5)
    s.insert(a)
    dbaref = DBRef(collection='A', id=a.mongo_id, database='unit-testing')
    s2 = Session.connect('unit-testing2', cache_size=0)
    assert s2.dereference(a).x == 5

def test_dereference():
    class A(Document):
        x = IntField()

    s = Session.connect('unit-testing', cache_size=0)
    s.clear_collection(A)

    a = A(x=5)
    s.insert(a)
    dbaref = DBRef(collection='A', id=a.mongo_id, database='unit-testing')
    s2 = Session.connect('unit-testing2', cache_size=0)
    assert s2.dereference(dbaref).x == 5

@raises(BadReferenceException)
def test_bad_dereference():
    class A(Document):
        x = IntField()

    s = Session.connect('unit-testing', cache_size=0)
    s.clear_collection(A)
    dbaref = DBRef(collection='A', id=ObjectId(), database='unit-testing')
    s.dereference(dbaref)


def test_simple():
    class A(Document):
        x = IntField()
    a = A(x=5)
    s = get_session()
    s.insert(a)

    id = ObjectId()
    assert SRefField(A).wrap(id) == id

@raises(BadValueException)
def test_bad_collection():
    a = RefField(A)
    a.validate_unwrap(DBRef(id=ObjectId(), collection='B'))

@raises(BadValueException)
def test_bad_db():
    a = RefField(A, db='blah')
    a.validate_unwrap(DBRef(id=ObjectId(), collection='A', database='blah2'))


@raises(BadValueException)
def test_validate():
    SRefField(A).validate_unwrap(3)

########NEW FILE########
__FILENAME__ = test_schema_tools
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index, FieldNotRetrieved
from mongoalchemy.fields import *
from mongoalchemy.query import BadQueryException, Query, BadResultException
from test.util import known_failure

class BaseDoc(Document):
    pass


class SchemaTestDoc(BaseDoc):
    intfield = IntField()
    strfield = StringField()
    dtfield = DateTimeField()
    tuplefield = TupleField(AnythingField(), IntField())
    geo = GeoField()
    enum = EnumField(AnythingField(), "a")
    anyf = AnythingField()
    default_field = IntField(default=2)
    defaultf_field = IntField(default_f=lambda : 3)
    modified = ModifiedField()
    dict_field = DictField(AnythingField())
    list_field = ListField(AnythingField())
    set_field = SetField(AnythingField())
    kv_field = KVField(AnythingField(), AnythingField())

class DocFieldDoc(Document):
    docfield = DocumentField(SchemaTestDoc)
    sref = SRefField(SchemaTestDoc)
    ref = RefField(SchemaTestDoc)

def contains(value, wanted):
    for k, v in wanted.items():
        assert value[k] == v, (k, k in value, value.get(k))

def test_schema():
    schema = SchemaTestDoc.schema_json()

    assert schema['config_full_name'] is None
    assert schema['config_polymorphic'] is None
    assert schema['config_namespace'] == 'global'
    assert schema['config_polymorphic_identity'] is None
    assert schema['config_extra_fields'] == 'error'

    fields = schema['fields']

    contains(fields['mongo_id'], {'db_field': '_id', 'auth': False, 'type': 'ObjectIdField'})
    contains(fields['intfield'], {'default_unset': True, 'db_field': None, 'unwrap_validator': False, 'max_value': None, 'min_value': None, 'required': True, 'wrap_validator': False, 'allow_none': False, 'validator_set': False, 'ignore_missing': False, 'type': 'IntField'})
    contains(fields['strfield'], {'type': 'StringField'})
    contains(fields['dtfield'] , {'min_date': None, 'max_date': None, 'type': 'DateTimeField', 'use_tz': False})
    # Tuple
    contains(fields['tuplefield'], {'type': 'TupleField'})
    contains(fields['tuplefield']['types'][0], {'type': 'AnythingField'})
    contains(fields['tuplefield']['types'][1], {'type': 'IntField'})
    # Geo
    contains(fields['geo']['types'][0], {'type': 'FloatField'})
    contains(fields['geo']['types'][1], {'type': 'FloatField'})
    contains(fields['geo'], {'type': 'GeoField'})

    # contains(fields['enum'][], {'type': 'AnythingField'})
    contains(fields['enum'], {'values': [u'a']})
    assert fields['enum']['item_type']['type'] == 'AnythingField', fields['enum']['item_type']
    contains(fields['enum'], {'type':'EnumField'})

    contains(fields['anyf'],  {'type': 'AnythingField'})
    # assert False,

    contains(fields['default_field'], {'default' : 2})
    'function' in fields['defaultf_field'].get('default_f', '')

    # Computed Field
    mod = fields['modified']
    contains(mod, {'type': 'ComputedField', 'one_time': False, 'deps':[]})
    contains(mod['computed_type'], {'type': 'DateTimeField'})

    # Mapping Fields
    assert fields['dict_field']['value_type']['type'] == 'AnythingField'
    contains(fields['dict_field'], {'type':'DictField'})

    assert fields['kv_field']['value_type']['type'] == 'AnythingField'
    assert fields['kv_field']['key_type']['type'] == 'AnythingField'
    contains(fields['kv_field'], {'type':'KVField'})

    assert fields['list_field']['item_type']['type'] == 'AnythingField'
    contains(fields['list_field'], {'type':'ListField'})

    assert fields['set_field']['item_type']['type'] == 'AnythingField'
    contains(fields['set_field'], {'type':'SetField'})

def test_docfield():
    schema = DocFieldDoc.schema_json()
    fields = schema['fields']
    contains(fields['docfield'], {'type': 'DocumentField', 'subtype': 'global:SchemaTestDoc'})

    print(fields['ref'])
    assert fields['ref']['subtype']['subtype'] == 'global:SchemaTestDoc'
    assert fields['sref']['subtype']['subtype'] == 'global:SchemaTestDoc'
    # assert False, fields['ref']



########NEW FILE########
__FILENAME__ = test_sequence_fields
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.fields import *
from test.util import known_failure

# List Field
@raises(BadValueException)
def list_wrong_type_test():
    ListField(IntField()).wrap(4)

@raises(BadValueException)
def list_bad_type_test_unwrap():
    ListField(IntField()).unwrap(4)

@raises(BadValueException)
def list_wrong_child_type_test():
    ListField(StringField()).wrap([4])

@raises(Exception)
def list_bad_child_type_test_wrap():
    ListField(int).wrap([4])


@raises(Exception)
def list_bad_child_test_unwrap():
    ListField(IntField()).unwrap(['4'])

@raises(BadValueException)
def list_too_long_test():
    ListField(StringField(), max_capacity=4).unwrap([x for x in '12345'])

@raises(BadValueException)
def list_too_short_test():
    ListField(StringField(), min_capacity=4).wrap([x for x in '123'])

def list_just_right_test():
    ListField(StringField(), min_capacity=3, max_capacity=3).wrap([x for x in '123'])

def list_value_test():
    s = ListField(StringField())
    foo = [x for x in '12345']
    assert s.unwrap(s.wrap(foo)) == foo

def list_default_test():
    s = ListField(StringField(), default_empty=True)
    assert s.default == []

# Set Field
@raises(BadValueException)
def set_wrong_type_test_wrap():
    SetField(IntField()).wrap([4])

@raises(BadValueException)
def set_wrong_type_test_unwrap():
    SetField(IntField()).unwrap((4,))


@raises(BadValueException)
def set_wrong_child_type_test():
    SetField(StringField()).wrap(set([4]))

def set_no_rel_test():
    SetField(StringField()).rel()


@raises(Exception)
def set_bad_child_type_test():
    SetField(int).wrap(set([4]))

@raises(BadValueException)
def set_too_long_test():
    SetField(StringField(), max_capacity=4).wrap(set([x for x in '12345']))

@raises(BadValueException)
def set_too_short_test():
    SetField(StringField(), min_capacity=4).wrap(set([x for x in '123']))

def set_just_right_test():
    SetField(StringField(), min_capacity=3, max_capacity=3).wrap(set([x for x in '123']))

def set_value_test():
    s = SetField(StringField())
    foo = set([x for x in '12345'])
    assert s.unwrap(s.wrap(foo)) == foo

def set_default_test():
    assert SetField(StringField(), default_empty=True).default == set()
    assert SetField(StringField(), default=set([3])).default == set([3])


########NEW FILE########
__FILENAME__ = test_session
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index
from mongoalchemy.fields import *
from mongoalchemy.exceptions import *
from test.util import known_failure
from pymongo.errors import DuplicateKeyError

class T(Document):
    i = IntField()
    l = ListField(IntField(), required=False, on_update='$pushAll')

class TUnique(Document):
    i = IntField()
    main_index = Index().ascending('i').unique()

class TExtra(Document):
    i = IntField()
    config_extra_fields = 'ignore'

class TExtraDocField(Document):
    doc = DocumentField(TExtra)

class TExtraDocFieldList(Document):
    doclist = ListField(DocumentField(TExtra))

class TIntListDoc(Document):
    intlist = ListField(IntField())

def test_tz():
    import pytz
    from datetime import datetime
    class DT(Document):
        dt = DateTimeField()
        created = CreatedField(tz_aware=True)
        modified = ModifiedField(tz_aware=True)
        created1 = CreatedField(tz_aware=False)
        modified1 = ModifiedField(tz_aware=False)

    session = Session.connect('unit-testing', timezone=pytz.utc)
    assert session.tz_aware
    session.clear_collection(DT)
    d = DT(dt=pytz.utc.localize(datetime(2012, 1, 1)))
    assert d.created1.tzinfo is None
    assert d.modified1.tzinfo is None

    session.insert(d)
    for x in session.query(DT):
        assert x.dt.tzinfo is not None
        assert x.created.tzinfo is not None
        assert x.modified.tzinfo is not None

@raises(TransactionException)
def test_find_and_modify_in_session():
    s = Session.connect('unit-testing')
    with s:
        s.execute_find_and_modify({})

@raises(TransactionException)
def test_end_in_transaction():
    s = Session.connect('unit-testing')
    with s:
        s.end()


def test_session():
    s = Session.connect('unit-testing')
    s.clear_collection(T)
    s.insert(T(i=1))
    s.clear_queue()
    s.end()

def test_context_manager():
    with Session.connect('unit-testing') as s:
        s.clear_collection(T)
        t = T(i=5)

def test_safe():
    s = Session.connect('unit-testing', safe=True)
    assert s.safe == True
    s = Session.connect('unit-testing', safe=False)
    assert s.safe == False

def test_cache():
    s = Session.connect('unit-testing', cache_size=10)
    t = TExtra(i=4)
    s.insert(t)
    s.insert(t)
    t2 = s.query(TExtra).filter_by(mongo_id=t.mongo_id).one()
    assert id(t) == id(t2)
    assert id(s.refresh(t)) != t2

def test_cache2():
    s = Session.connect('unit-testing', cache_size=10)
    t = TExtra(i=4)
    s.insert(t)
    s.insert(t)
    for t2 in s.query(TExtra).filter_by(mongo_id=t.mongo_id):
        assert id(t) == id(t2)
        assert id(s.refresh(t)) != t2
        break
def test_cache3():
    s = Session.connect('unit-testing', cache_size=10)
    t = TExtra(i=4)
    s.insert(t)
    s.insert(t)
    t2 = s.query(TExtra).filter_by(mongo_id=t.mongo_id)[0]
    assert id(t) == id(t2)
    assert id(s.refresh(t)) != t2

# def test_cache2():
#     class SimpleDoc(Document):
#         i = IntField()

#     class CacheList(Document):
#         l_ids = ListField(RefField(SimpleDoc)
#     s = Session.connect('unit-testing', cache_size=10)



#     t2 = s.query(TExtra).filter_by(mongo_id=t.mongo_id).one()
#     assert id(t) == id(t2)
#     assert id(s.refresh(t)) != t2


def test_clone():
    s = Session.connect('unit-testing', cache_size=10)
    t = TExtra(i=4)
    s.insert(t)

    t2 = s.clone(t)
    s.insert(t2)

    assert t2.mongo_id != t.mongo_id


def test_cache_miss():
    s_nocache = Session.connect('unit-testing', cache_size=10)
    t = TExtra(i=4)
    s_nocache.insert(t)

    s = Session.connect('unit-testing', cache_size=10)
    s.add_to_session(t)
    t2 = s.query(TExtra).filter_by(mongo_id=t.mongo_id).one()
    # assert id(t) == id(t2)

def test_transactions():
    class Doc(Document):
        i = IntField()
    s = Session.connect('unit-testing')
    s.clear_collection(Doc)
    assert s.query(Doc).count() == 0
    with s:
        assert s.query(Doc).count() == 0
        s.add(Doc(i=4))
        assert s.query(Doc).count() == 0
        with s:
            assert s.query(Doc).count() == 0
            s.add(Doc(i=2))
            assert s.query(Doc).count() == 0
        assert s.query(Doc).count() == 0, s.query(Doc).count()
    assert s.query(Doc).count() == 2

def test_transactions2():
    class Doc(Document):
        i = IntField()
    s = Session.connect('unit-testing')
    s.clear_collection(Doc)
    assert s.query(Doc).count() == 0
    try:
        with s:
            assert s.query(Doc).count() == 0
            s.add(Doc(i=4))
            assert s.query(Doc).count() == 0
            with s:
                assert s.query(Doc).count() == 0
                s.add(Doc(i=2))
                assert s.query(Doc).count() == 0
                raise Exception()
            assert s.query(Doc).count() == 0, s.query(Doc).count()
    except:
        assert s.query(Doc).count() == 0, s.query(Doc).count()

def test_transactions3():
    class Doc(Document):
        i = IntField()
    s = Session.connect('unit-testing')
    s.clear_collection(Doc)
    assert s.query(Doc).count() == 0
    with s:
        s.add(Doc(i=4))
        try:

            with s:
                s.add(Doc(i=2))
                raise Exception()
        except:
            assert s.query(Doc).count() == 0, s.query(Doc).count()
    assert s.query(Doc).count() == 1, s.query(Doc).count()


def test_cache_max():
    # not a great test, but gets coverage
    s = Session.connect('unit-testing', cache_size=3)
    for i in range(0, 10):
        t = TExtra(i=4)
        s.insert(t)
    assert len(s.cache) == 3

def test_cache2():
    s = Session.connect('unit-testing')
    t = TExtra(i=4)
    s.insert(t)
    t2 = s.query(TExtra).filter_by(mongo_id=t.mongo_id).one()
    assert id(t) != id(t2)

def test_safe_with_error():
    s = Session.connect('unit-testing')
    s.clear_collection(TUnique)
    s.insert(TUnique(i=1))
    try:
        s.insert(TUnique(i=1), safe=True)
        assert False, 'No error raised on safe insert for second unique item'
    except DuplicateKeyError:
        assert len(s.queue) == 0


def test_update():
    s = Session.connect('unit-testing')
    s.clear_collection(T)
    t = T(i=6)
    s.insert(t)
    assert s.query(T).one().i == 6

    t.i = 7
    s.update(t)
    assert s.query(T).one().i == 7


def test_update_change_ops():
    s = Session.connect('unit-testing')
    s.clear_collection(T)
    t = T(i=6, l=[8])
    s.insert(t)
    assert s.query(T).one().i == 6

    t.i = 7
    t.l = [8]
    s.update(t, update_ops={T.l:'$pullAll'}, i='$inc')
    t = s.query(T).one()
    assert t.i == 13, t.i
    assert t.l == [], t.l

def test_update_push():
    s = Session.connect('unit-testing')
    s.clear_collection(T)
    # Create object
    t = T(i=6, l=[3])
    s.insert(t)
    t = s.query(T).one()
    assert t.i == 6 and t.l == [3]

    t = s.query(T).fields(T.i).one()
    t.i = 7
    t.l = [4]
    s.update(t, id_expression=T.i == 6)

    t = s.query(T).one()
    assert s.query(T).one().i == 7 and t.l == [3, 4]

def test_update_ignore_extras():
    s = Session.connect('unit-testing')
    s.clear_collection(TExtra)
    # Create Object
    t = TExtra(i=1, j='test', k='test2')
    s.insert(t)
    # Retrieve Object
    t = s.query(TExtra).one()
    assert t.i == 1
    assert t.get_extra_fields()['j'] == 'test'
    assert t.get_extra_fields()['k'] == 'test2'
    # Update Object
    t.i = 5
    del t.get_extra_fields()['j'] # delete an extra field
    t.get_extra_fields()['k'] = 'changed' # change an extra field
    t.get_extra_fields()['l'] = 'added' # new extra field
    s.update(t)

    # Retrieve Object
    t_new = s.query(TExtra).one()

    assert 'j' not in t_new.get_extra_fields()
    assert t_new.get_extra_fields()['k'] == 'changed'
    assert t_new.get_extra_fields()['l'] == 'added'
    assert t_new.i == 5


def test_update_docfield_extras():
    s = Session.connect('unit-testing')
    s.clear_collection(TExtraDocField)
    # Create Object
    t = TExtra(i=1, j='test')
    t2 = TExtraDocField(doc=t)
    s.insert(t2)
    # Retrieve Object
    t2 = s.query(TExtraDocField).one()
    assert t2.doc.i == 1
    assert t2.doc.get_extra_fields()['j'] == 'test'
    # Update Object's extra fields
    t2.doc.get_extra_fields()['t'] = 'added'

    s.update(t2)

    # Retrieve Object
    t2_new = s.query(TExtraDocField).one()
    assert t2_new.doc.i == 1
    assert t2_new.doc.get_extra_fields()['j'] == 'test'
    assert t2_new.doc.get_extra_fields()['t'] == 'added'

def test_update_docfield_list_extras():
    s = Session.connect('unit-testing')
    s.clear_collection(TExtraDocFieldList)

    # Create Objects
    t = TExtra(i=1, j='test')
    t2 = TExtra(i=2, j='test2')
    tListDoc = TExtraDocFieldList(doclist=[t, t2])

    s.insert(tListDoc)
    # Retrieve Object
    tListDoc = s.query(TExtraDocFieldList).one()
    assert len(tListDoc.doclist) == 2
    for doc in tListDoc.doclist:
        if doc.i == 1:
            assert doc.get_extra_fields()['j'] == 'test'
            # go ahead and update j now
            doc.get_extra_fields()['j'] = 'testChanged'
        elif doc.i == 2:
            assert doc.get_extra_fields()['j'] == 'test2'
        else:
            assert False

    # update the parent document
    s.update(tListDoc)

    # re-fetch and verify
    tListDoc = s.query(TExtraDocFieldList).one()

    for doc in tListDoc.doclist:
        if doc.i == 1:
            assert doc.get_extra_fields()['j'] == 'testChanged'
        elif doc.i == 2:
            assert doc.get_extra_fields()['j'] == 'test2'
        else:
            assert False

def test_update_list():
    s = Session.connect('unit-testing')
    s.clear_collection(TIntListDoc)

    tIntList = TIntListDoc(intlist=[1,2])
    s.insert(tIntList)

    # pull out of db
    tFetched = s.query(TIntListDoc).one()

    assert sorted([1,2]) == sorted(tFetched.intlist)

    # append to list, update
    l = tFetched.intlist
    l.append(3)
    s.update(tFetched)

    # pull out of db
    tFetched = s.query(TIntListDoc).one()

    assert sorted([1,2,3]) == sorted(tFetched.intlist)

    tFetched.intlist.remove(1)
    s.update(tFetched)

    tFetched = s.query(TIntListDoc).one()

    assert sorted([2,3]) == sorted(tFetched.intlist)

def test_ensure_indexes():
    s = Session.connect('unit-testing', auto_ensure=False)
    s.db.drop_collection(TUnique.get_collection_name())

    s.insert(TUnique(i=1))

    indexes = s.get_indexes(TUnique)
    assert len(indexes) == 1
    assert "_id_" in indexes

    s.ensure_indexes(TUnique)

    indexes = s.get_indexes(TUnique)
    assert len(indexes) == 2
    assert "_id_" in indexes
    assert "i_1" in indexes

def test_auto_ensure_indexes():
    s = Session.connect('unit-testing', auto_ensure=True)
    s.db.drop_collection(TUnique.get_collection_name())

    s.insert(TUnique(i=1))

    indexes = s.get_indexes(TUnique)

    assert len(indexes) == 2
    assert "_id_" in indexes
    assert "i_1" in indexes


########NEW FILE########
__FILENAME__ = test_update_expressions
from __future__ import print_function
from mongoalchemy.py3compat import *

from nose.tools import *
from mongoalchemy.session import Session
from mongoalchemy.document import Document, Index, FieldNotRetrieved
from mongoalchemy.fields import *
from mongoalchemy.update_expression import InvalidModifierException, UpdateException
from mongoalchemy.query import BadQueryException, Query, BadResultException, RemoveQuery
from test.util import known_failure
from pymongo.errors import DuplicateKeyError

class T(Document):
    i = IntField()
    j = IntField(required=False)
    s = StringField(required=False)
    l = ListField(IntField(), required=False)
    a = IntField(required=False, db_field='aa')
    index = Index().ascending('i')

class T2(Document):
    t = DocumentField(T)

class TUnique(Document):
    i = IntField()
    j = IntField(required=False)
    main_index = Index().ascending('i').unique()


def get_session():
    return Session.connect('unit-testing')

#
#   Update Operation Tests
#

def update_test_setup():
    s = get_session()
    s.clear_collection(T)
    return s.query(T)

# Find and Modify
def test_find_and_modify():
    s = get_session()
    s.clear_collection(T, T2)
    # insert
    value = s.query(T).filter_by(i=12341).find_and_modify().set(i=12341).upsert().execute()
    assert value is None or value == {}, value # Mongo 2.2 now returns None instead of an empty document
    assert s.query(T).one().i == 12341

    # update
    value = s.query(T).filter_by(i=12341).ascending(T.i).find_and_modify().set(i=9999).execute()
    assert value.i == 12341
    assert s.query(T).one().i == 9999

    # return new
    value = s.query(T).filter_by(i=9999).fields(T.i).find_and_modify(new=True).set(i=8888).execute()
    assert value.i == 8888, value.i
    assert s.query(T).one().i == 8888

    # remove
    value = s.query(T).filter_by(i=8888).find_and_modify(remove=True).execute()
    assert value.i == 8888, value.i
    assert s.query(T).first() is None

    # update
    value = s.query(T).filter_by(i=1000).ascending(T.i).find_and_modify(new=True).set(i=0).execute()
    assert value is None, value


# General Update tests

def test_multi():
    q = update_test_setup()
    q.set(T.i, 5).set(T.j, 6).upsert().execute()
    q.set(T.i, 5).set(T.j, 7).upsert().execute()
    q.set(T.i, 5).set(T.j, 8).upsert().execute()
    q.set(T.j, 9).multi().execute()
    for t in q:
        assert t.j == 9

# Test Nested object
def nested_field_set_test():
    s = get_session()
    s.clear_collection(T, T2)
    s.query(T2).set('t.i', 3).upsert().execute()
    assert s.query(T2).one().t.i == 3


def test_update_safe():
    s = get_session()
    s.clear_collection(TUnique)
    s.query(TUnique).filter_by(i=1).set(i=1, j=2).upsert().execute()
    # default safe=false -- ignore error
    s.query(TUnique).filter_by(i=1).set(i=1, j=2).upsert().execute()
    # explicit safe=false
    s.query(TUnique).filter_by(i=1).set(i=1, j=2).safe().safe(safe=False).upsert().execute()

    # safe=true, exception
    # TODO: doesn't produce a real exception.  should investigate why, but I checked
    # and I am sending safe=True
    #
    # try:
    #     s.query(TUnique).filter_by(i=1).set(i=1, j=2).safe().upsert().execute()
    #     assert False, 'No error raised on safe insert for second unique item'
    # except DuplicateKeyError:
    #     pass


# Test Remove

def test_remove():
    # setup
    s = get_session()
    s.clear_collection(T)
    for i in range(0, 15):
        s.insert(T(i=i))
    assert s.query(T).count() == 15

    def getall():
        return [t.i for t in s.query(T).ascending(T.i).all()]

    s.remove_query(T).filter(T.i > 8).execute()
    assert s.query(T).count() == 9

    # TODO: to /really/ test this I need to cause an error.
    remove_result = s.remove_query(T).filter(T.i > 7).set_safe(True).execute()
    assert remove_result['ok'] == 1
    assert s.query(T).count() == 8

    s.remove_query(T).or_(T.i == 7, T.i == 6).execute()
    remaining = [0, 1, 2, 3, 4, 5]
    assert remaining == getall(), getall()

    s.remove_query(T).in_(T.i, 0, 1).execute()
    remaining.remove(1)
    remaining.remove(0)
    assert remaining == getall(), getall()

    s.remove_query(T).nin(T.i, 2, 3, 4).execute()
    remaining.remove(5)
    assert remaining == getall(), getall()

    s.remove_query(T).filter_by(i=2).execute()
    remaining.remove(2)
    assert remaining == getall(), getall()


def test_remove_obj():
    s = get_session()
    s.clear_collection(T)
    t = T(i=4)
    s.insert(t)
    assert s.query(T).count() == 1
    s.remove(t)
    assert s.query(T).count() == 0
    t2 = T(i=3)
    s.remove(t2)

def test_remove_expression():
    class Page(Document):
        text = StringField()
        page_num = IntField()

    class Book(Document):
        isbn = StringField()
        pages = ListField(DocumentField(Page))

    session = get_session()
    session.clear_collection(Book)

    ISBN = '3462784290890'
    book = Book(isbn=ISBN, pages=[])
    for i in range(0,10):
        book.pages.append(Page(text='p%d' % i, page_num = i))

    session.insert(book)

    query = session.query(Book).filter(Book.isbn == ISBN, Book.pages.page_num > 5)
    query.remove(Book.pages, Page.page_num == 8).execute()
    book = session.query(Book).filter(Book.isbn == ISBN).one()
    assert len(book.pages) == 9

@raises(InvalidModifierException)
def test_remove_expression_error():
    class Page(Document):
        text = StringField()
        page_num = IntField()

    class Book(Document):
        isbn = StringField()
        pages = ListField(DocumentField(Page))
    session = get_session()
    session.query(Book).remove(Book.isbn, Page.page_num == 8)


# SET

def set_test():
    q = update_test_setup()
    assert q.set(T.i, 5).set(T.j, 7).update_data == {
        '$set' : { 'i' : 5, 'j' : 7 }
    }

def set_test_kwargs():
    q = update_test_setup()
    assert q.set(i=5, j=7).update_data == {
        '$set' : { 'i' : 5, 'j' : 7 }
    }

def set_db_test():
    q = update_test_setup()

    q.set(T.i, 5).set(T.j, 6).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.j == 6

    q.filter(T.i == 5).set(T.j, 7).execute()
    t = q.one()
    assert t.i == 5 and t.j == 7


def set_db_test_kwargs():
    q = update_test_setup()

    q.set(i=5, j=6).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.j == 6

    q.filter_by(i=5).set(j=7).execute()
    t = q.one()
    assert t.i == 5 and t.j == 7

@raises(UpdateException)
def set_bad_args_test_1():
    q = update_test_setup()
    q.set()

@raises(UpdateException)
def set_bad_args_test_2():
    q = update_test_setup()
    q.set(1, 2, 3)


# UNSET

def unset_test():
    q = update_test_setup()
    assert q.unset(T.i).update_data == {
        '$unset' : { 'i' : True }
    }

def unset_db_test():
    q = update_test_setup()

    q.set(T.i, 5).set(T.j, 6).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.j == 6

    ue = q.filter(T.i == 5).unset(T.j).execute()
    t = q.one()
    assert t.i == 5 and not hasattr(t, 'j'), getattr(t, 'j')


# INC

def inc_test():
    q = update_test_setup()
    assert q.inc(T.i, 4).update_data == {
        '$inc' : { 'i' : 4 }
    }
    assert q.inc(T.i).inc(T.j).update_data == {
        '$inc' : { 'i' : 1, 'j' : 1 }
    }
    assert q.inc(i=1, j=1).update_data == {
        '$inc' : { 'i' : 1, 'j' : 1 }
    }

@raises(UpdateException)
def test_inc_bad_value():
    update_test_setup().inc().update_data

@raises(InvalidModifierException)
def inc_invalid_test():
    q = update_test_setup()
    q.inc(T.s, 1)

def inc_db_test():
    q = update_test_setup()

    q.inc(T.i, 5).inc(T.j, 6).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.j == 6
    q.inc(T.j, 6).inc(T.i, 5).execute()
    t = q.one()
    assert t.i == 10 and t.j == 12

# APPEND

def append_test():
    q = update_test_setup()
    assert q.append(T.l, 1).update_data == {
        '$push' : { 'l' : 1 }
    }

@raises(InvalidModifierException)
def append_invalid_test():
    q = update_test_setup()
    q.append(T.s, 1)

def append_db_test():
    q = update_test_setup()

    q.set(T.i, 5).append(T.l, 6).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6]

    q.append(T.l, 5).execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5]


# EXTEND

def extend_test():
    q = update_test_setup()
    assert q.extend(T.l, *(1, 2, 3)).update_data == {
        '$pushAll' : { 'l' : (1, 2, 3) }
    }

def extend_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5]

    q.extend('l', 4, 3).execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

@raises(InvalidModifierException)
def extend_invalid_test():
    q = update_test_setup()
    q.extend(T.s, [1])

# REMOVE

def remove_test():
    q = update_test_setup()
    assert q.remove(T.l, 1).update_data == {
        '$pull' : { 'l' : 1 }
    }

@raises(InvalidModifierException)
def remove_invalid_test():
    q = update_test_setup()
    q.remove(T.s, 1)

def remove_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5, 4, 3).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

    q.remove(T.l, 4).execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 3]


# REMOVE ALL

def remove_all_test():
    q = update_test_setup()
    assert q.remove_all(T.l, *(1, 2, 3)).update_data == {
        '$pullAll' : { 'l' : (1, 2, 3) }
    }

@raises(InvalidModifierException)
def remove_all_invalid_test():
    q = update_test_setup()
    q.remove_all(T.s, 1, 2, 3)

def remove_all_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5, 4, 3).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

    q.remove_all(T.l, 6, 5, 4).execute()
    t = q.one()
    assert t.i == 5 and t.l == [3]


# ADD TO SET

def add_to_set_test():
    q = update_test_setup()
    assert q.add_to_set(T.l, 1).update_data == {
        '$addToSet' : { 'l' : 1 }
    }

def add_to_set_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5, 4, 3).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

    q.add_to_set(T.l, 6).add_to_set(T.l, 2).execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3, 2]

@raises(InvalidModifierException)
def add_to_set_invalid_test():
    q = update_test_setup()
    q.add_to_set(T.s, 1)

# POP FIRST

def pop_first_test():
    q = update_test_setup()
    assert q.pop_first(T.l).update_data == {
        '$pop' : { 'l' : -1 }
    }

@raises(InvalidModifierException)
def pop_first_invalid_test():
    q = update_test_setup()
    q.pop_last(T.s)

def pop_first_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5, 4, 3).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

    q.pop_first(T.l).execute()
    t = q.one()
    assert t.i == 5 and t.l == [5, 4, 3]


# POP LAST

def pop_last_test():
    q = update_test_setup()
    assert q.pop_last(T.l).update_data == {
        '$pop' : { 'l' : 1 }
    }


@raises(InvalidModifierException)
def pop_last_invalid_test():
    q = update_test_setup()
    q.pop_first(T.s)

def pop_last_db_test():
    q = update_test_setup()

    q.set(T.i, 5).extend(T.l, 6, 5, 4, 3).upsert().execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4, 3]

    q.pop_last(T.l).execute()
    t = q.one()
    assert t.i == 5 and t.l == [6, 5, 4]

def test_update_obeys_db_field():
    '''Updating a document should update the db_field in the \
    database'''
    s = get_session()

    s.db.Foo.remove()
    class Foo(Document):
        mongo_id = IntField(db_field='_id')
        bar = StringField(db_field='baz')

    a = Foo(mongo_id=2, bar="Hello")
    s.update(a, upsert=True, safe=True)

    a_from_db = s.db.Foo.find_one()
    assert a_from_db is not None
    assert 'mongo_id' not in a_from_db
    assert 'bar' not in a_from_db
    assert a_from_db['_id'] == 2
    assert a_from_db['baz'] == u'Hello'

    s.db.Foo.remove()


########NEW FILE########
__FILENAME__ = test_util
from __future__ import print_function
from mongoalchemy.py3compat import *

from mongoalchemy.util import classproperty, UNSET

def test_class_properties():
    class A(object):
        a = 1
        b = 2
        @classproperty
        def c(cls):
            return cls.a+cls.b
    assert A.c == 3

def test_UNSET():
    # for coverage
    r = repr(UNSET)
    assert UNSET == UNSET
    assert UNSET is not None



########NEW FILE########
__FILENAME__ = util
from __future__ import print_function
from mongoalchemy.py3compat import *

from functools import wraps

def known_failure(fun):
    @wraps(fun)
    def wrapper(*args, **kwds):
        try:
            fun(*args, **kwds)
            raise Exception('Known failure passed! %s' % fun.__name__)
        except:
            pass
    return wrapper

########NEW FILE########
