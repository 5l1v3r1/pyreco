__FILENAME__ = customer
from decimal import Decimal
import urllib
from datetime import datetime

from suds import WebFault
from suds.client import Client
from authorize.data import Address, CreditCard

from authorize.apis.transaction import parse_response
from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeError, AuthorizeResponseError, AuthorizeInvalidError

PROD_URL = 'https://api.authorize.net/soap/v1/Service.asmx?WSDL'
TEST_URL = 'https://apitest.authorize.net/soap/v1/Service.asmx?WSDL'

class CustomerAPI(object):
    def __init__(self, login_id, transaction_key, debug=True, test=False):
        self.url = TEST_URL if debug else PROD_URL
        self.login_id = login_id
        self.transaction_key = transaction_key
        self.transaction_options = urllib.urlencode({
            'x_version': '3.1',
            'x_test_request': 'Y' if test else 'F',
            'x_delim_data': 'TRUE',
            'x_delim_char': ';',
        })

    @property
    def client(self):
        # Lazy instantiation of SOAP client, which hits the WSDL url
        if not hasattr(self, '_client'):
            self._client = Client(self.url)
        return self._client

    @property
    def client_auth(self):
        if not hasattr(self, '_client_auth'):
            self._client_auth = self.client.factory.create(
                'MerchantAuthenticationType')
            self._client_auth.name = self.login_id
            self._client_auth.transactionKey = self.transaction_key
        return self._client_auth

    def _make_call(self, service, *args):
        # Provides standard API call error handling
        method = getattr(self.client.service, service)
        try:
            response = method(self.client_auth, *args)
        except WebFault as e:
            raise AuthorizeConnectionError('Error contacting SOAP API.')
        if response.resultCode != 'Ok':
            error = response.messages[0][0]
            e = AuthorizeResponseError('%s: %s' % (error.code, error.text))
            e.full_response = {
                'response_code': error.code,
                'response_text': error.text,
            }
            raise e
        return response

    def create_saved_profile(self, internal_id, payments=None, email=None):
        """
        Creates a user profile to which you can attach saved payments.
        Requires an internal_id to uniquely identify this user. If a list of
        saved payments is provided, as generated by create_saved_payment,
        these will be automatically added to the user profile. Returns the
        user profile id.
        """
        profile = self.client.factory.create('CustomerProfileType')
        profile.merchantCustomerId = internal_id
        profile.email = email
        if payments:
            payment_array = self.client.factory.create(
                'ArrayOfCustomerPaymentProfileType')
            payment_array.CustomerPaymentProfileType = payments
            profile.paymentProfiles = payment_array
        response = self._make_call('CreateCustomerProfile', profile, 'none')
        profile_id = response.customerProfileId
        payment_ids = None
        if payments:
            payment_ids = response.customerPaymentProfileIdList[0]
        return profile_id, payment_ids

    @staticmethod
    def _address_to_profile(address, payment_profile):
        if address and address.street:
            payment_profile.billTo.address = address.street
        if address and address.city:
            payment_profile.billTo.city = address.city
        if address and address.state:
            payment_profile.billTo.state = address.state
        if address and address.zip_code:
            payment_profile.billTo.zip = address.zip_code
        if address and address.country:
            payment_profile.billTo.country = address.country
        return payment_profile

    def create_saved_payment(self, credit_card, address=None, profile_id=None):
        """
        Creates a payment profile. If profile_id is provided, this payment
        profile will be created in Authorize.net attached to that profile.
        If it is not provided, the payment profile will be returned and can
        be provided in a list to the create_profile call.
        """
        # Create the basic payment profile with credit card details
        payment_profile = self.client.factory.create(
            'CustomerPaymentProfileType')
        customer_type_enum = self.client.factory.create('CustomerTypeEnum')
        payment_profile.customerType = customer_type_enum.individual
        payment_type = self.client.factory.create('PaymentType')
        credit_card_type = self.client.factory.create('CreditCardType')
        credit_card_type.cardNumber = credit_card.card_number
        credit_card_type.expirationDate = '{0.exp_year}-{0.exp_month:0>2}' \
            .format(credit_card)
        credit_card_type.cardCode = credit_card.cvv
        payment_type.creditCard = credit_card_type
        payment_profile.payment = payment_type

        # Customer billing name and address are optional fields
        if credit_card.first_name:
            payment_profile.billTo.firstName = credit_card.first_name
        if credit_card.last_name:
            payment_profile.billTo.lastName = credit_card.last_name
        payment_profile = self._address_to_profile(address, payment_profile)

        # If a profile id is provided, create saved payment on that profile
        # Otherwise, return an object for a later call to create_saved_profile
        if profile_id:
            response = self._make_call('CreateCustomerPaymentProfile',
                profile_id, payment_profile, 'none')
            return response.customerPaymentProfileId
        else:
            return payment_profile

    def retrieve_saved_payment(self, profile_id, payment_id):
        payment_id = int(payment_id)
        profile = self._make_call(
            'GetCustomerProfile', profile_id).profile
        payment_info = {}
        email = None
        if hasattr(profile, 'email'):
            email = unicode(profile.email)
        payment_info['email'] = email
        saved_payment = None
        for payment in profile.paymentProfiles[0]:
            if payment.customerPaymentProfileId == payment_id:
                saved_payment = payment
                break
        if not saved_payment:
            raise AuthorizeError("Payment ID does not exist for this profile.")
        payment_info['number'] = unicode(
            saved_payment.payment.creditCard.cardNumber)
        data = saved_payment.billTo
        payment_info['first_name'] = unicode(getattr(data, 'firstName', ''))
        payment_info['last_name'] = unicode(getattr(data, 'lastName', ''))
        kwargs = {
            'street': getattr(data, 'address', None),
            'city': getattr(data, 'city', None),
            'state': getattr(data, 'state', None),
            'zip_code': getattr(data, 'zip', None),
            'country': getattr(data, 'country', None)}
        kwargs = {
            key: unicode(value) for key, value in kwargs.items() if value}
        payment_info['address'] = Address(**kwargs)
        return payment_info

    def update_saved_payment(self, profile_id, payment_id, **kwargs):
        payment_profile = self.client.factory.create(
            'CustomerPaymentProfileExType')
        customer_type_enum = self.client.factory.create('CustomerTypeEnum')
        payment_profile.customerType = customer_type_enum.individual
        payment_simple_type = self.client.factory.create('PaymentType')
        card_simple_type = self.client.factory.create('CreditCardSimpleType')
        number = kwargs['number']
        # Authorize.net uses this constant to indicate that we want to keep
        # the existing expiration date.
        date = 'XXXX'
        card_simple_type.cardNumber = number
        if kwargs['exp_month'] and kwargs['exp_year']:
            exp = CreditCard.exp_time(kwargs['exp_month'], kwargs['exp_year'])
            if exp <= datetime.now():
                raise AuthorizeInvalidError('This credit card has expired.')
            card_simple_type.expirationDate =\
                '{0}-{1:0>2}'.format(kwargs['exp_year'], kwargs['exp_month'])
        else:
            card_simple_type.expirationDate = date
        payment_simple_type.creditCard = card_simple_type
        payment_profile.payment = payment_simple_type
        payment_profile.payment.creditCard = card_simple_type
        payment_profile.customerPaymentProfileId = payment_id

        if kwargs['first_name']:
            payment_profile.billTo.firstName = kwargs['first_name']
        if kwargs['last_name']:
            payment_profile.billTo.lastName = kwargs['last_name']
        payment_profile = self._address_to_profile(
            kwargs['address'], payment_profile)

        self._make_call(
            'UpdateCustomerPaymentProfile', profile_id,
            payment_profile, 'none')

        if not kwargs['email']:
            return
        profile = self.client.factory.create('CustomerProfileExType')
        profile.email = kwargs['email']
        profile.customerProfileId = profile_id
        self._make_call('UpdateCustomerProfile', profile)

    def delete_saved_profile(self, profile_id):
        self._make_call('DeleteCustomerProfile', profile_id)

    def delete_saved_payment(self, profile_id, payment_id):
        self._make_call('DeleteCustomerPaymentProfile',
            profile_id, payment_id)

    def auth(self, profile_id, payment_id, amount):
        transaction = self.client.factory.create('ProfileTransactionType')
        auth = self.client.factory.create('ProfileTransAuthOnlyType')
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        auth.amount = str(amount)
        auth.customerProfileId = profile_id
        auth.customerPaymentProfileId = payment_id
        transaction.profileTransAuthOnly = auth
        response = self._make_call('CreateCustomerProfileTransaction',
            transaction, self.transaction_options)
        return parse_response(response.directResponse)

    def capture(self, profile_id, payment_id, amount):
        transaction = self.client.factory.create('ProfileTransactionType')
        capture = self.client.factory.create('ProfileTransAuthCaptureType')
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        capture.amount = str(amount)
        capture.customerProfileId = profile_id
        capture.customerPaymentProfileId = payment_id
        transaction.profileTransAuthCapture = capture
        response = self._make_call('CreateCustomerProfileTransaction',
            transaction, self.transaction_options)
        return parse_response(response.directResponse)

    def credit(self, profile_id, payment_id, amount):
        # Creates an "unlinked credit" (as opposed to refunding a previous transaction)
        transaction = self.client.factory.create('ProfileTransactionType')
        credit = self.client.factory.create('ProfileTransRefundType')
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        credit.amount = str(amount)
        credit.customerProfileId = profile_id
        credit.customerPaymentProfileId = payment_id
        transaction.profileTransRefund = credit
        response = self._make_call('CreateCustomerProfileTransaction',
            transaction, self.transaction_options)
        return parse_response(response.directResponse)

########NEW FILE########
__FILENAME__ = recurring
from datetime import date
from decimal import Decimal

from suds import WebFault
from suds.client import Client

from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeInvalidError, AuthorizeResponseError


PROD_URL = 'https://api.authorize.net/soap/v1/Service.asmx?WSDL'
TEST_URL = 'https://apitest.authorize.net/soap/v1/Service.asmx?WSDL'

class RecurringAPI(object):
    def __init__(self, login_id, transaction_key, debug=True, test=False):
        self.url = TEST_URL if debug else PROD_URL
        self.login_id = login_id
        self.transaction_key = transaction_key

    @property
    def client(self):
        # Lazy instantiation of SOAP client, which hits the WSDL url
        if not hasattr(self, '_client'):
            self._client = Client(self.url)
        return self._client

    @property
    def client_auth(self):
        if not hasattr(self, '_client_auth'):
            self._client_auth = self.client.factory.create(
                'MerchantAuthenticationType')
            self._client_auth.name = self.login_id
            self._client_auth.transactionKey = self.transaction_key
        return self._client_auth

    def _make_call(self, service, *args):
        # Provides standard API call error handling
        method = getattr(self.client.service, service)
        try:
            response = method(self.client_auth, *args)
        except WebFault as e:
            raise AuthorizeConnectionError(e)
        if response.resultCode != 'Ok':
            error = response.messages[0][0]
            raise AuthorizeResponseError('%s: %s' % (error.code, error.text))
        return response

    def create_subscription(self, credit_card, amount, start,
            days=None, months=None, occurrences=None, trial_amount=None,
            trial_occurrences=None):
        """
        Creates a recurring subscription payment on the CreditCard provided.
        
        ``credit_card``
            The CreditCard instance to create the subscription for.
            Subscriptions require that you provide a first and last name with
            the credit card.
        
        ``amount``
            The amount to charge every occurrence, either as an int, float,
            or Decimal.
        
        ``start``
            The date to start the subscription, as a date object.
        
        ``days``
            Provide either the days or the months argument to indicate the
            interval at which the subscription should recur.

        ``months``
            Provide either the days or the months argument to indicate the
            interval at which the subscription should recur.
        
        ``occurrences``
            If provided, this is the number of times to charge the credit card
            before ending. If not provided, will last until canceled.
        
        ``trial_amount``
            If you want to have a trial period at a lower amount for this
            subscription, provide the amount. (Either both trial arguments
            should be provided, or neither.)
        
        ``trial_occurrences``
            If you want to have a trial period at a lower amount for this
            subscription, provide the number of occurences the trial period
            should last for. (Either both trial arguments should be provided,
            or neither.)
        """
        subscription = self.client.factory.create('ARBSubscriptionType')

        # Add the basic amount and payment fields
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        subscription.amount = str(amount)
        payment_type = self.client.factory.create('PaymentType')
        credit_card_type = self.client.factory.create('CreditCardType')
        credit_card_type.cardNumber = credit_card.card_number
        credit_card_type.expirationDate = '{0}-{1:0>2}'.format(
            credit_card.exp_year, credit_card.exp_month)
        credit_card_type.cardCode = credit_card.cvv
        payment_type.creditCard = credit_card_type
        subscription.payment = payment_type
        if not (credit_card.first_name and credit_card.last_name):
            raise AuthorizeInvalidError('Subscriptions require first name '
                'and last name to be provided with the credit card.')
        subscription.billTo.firstName = credit_card.first_name
        subscription.billTo.lastName = credit_card.last_name

        # Add the fields for the payment schedule
        if (days and months) or not (days or months):
            raise AuthorizeInvalidError('Please provide either the months or '
                'days argument to define the subscription interval.')
        if days:
            try:
                days = int(days)
                assert days >= 7 and days <= 365
            except (AssertionError, ValueError):
                raise AuthorizeInvalidError('The interval days must be an '
                    'integer value between 7 and 365.')
            subscription.paymentSchedule.interval.unit = \
                self.client.factory.create('ARBSubscriptionUnitEnum').days
            subscription.paymentSchedule.interval.length = days
        elif months:
            try:
                months = int(months)
                assert months >= 1 and months <= 12
            except (AssertionError, ValueError):
                raise AuthorizeInvalidError('The interval months must be an '
                    'integer value between 1 and 12.')
            subscription.paymentSchedule.interval.unit = \
                self.client.factory.create('ARBSubscriptionUnitEnum').months
            subscription.paymentSchedule.interval.length = months
        if start < date.today():
            raise AuthorizeInvalidError('The start date for the subscription '
                'may not be in the past.')
        subscription.paymentSchedule.startDate = start.strftime('%Y-%m-%d')
        if occurrences is None:
            occurrences = 9999 # That's what they say to do in the docs
        subscription.paymentSchedule.totalOccurrences = occurrences

        # If a trial period has been specified, add those fields
        if trial_amount and trial_occurrences:
            subscription.paymentSchedule.trialOccurrences = trial_occurrences
            trial_amount = Decimal(str(trial_amount))
            trial_amount = trial_amount.quantize(Decimal('0.01'))
            subscription.trialAmount = str(trial_amount)
        elif trial_amount or trial_occurrences:
            raise AuthorizeInvalidError('To indicate a trial period, you '
                'must provide both a trial amount and occurrences.')

        # Make the API call to create the subscription
        response = self._make_call('ARBCreateSubscription', subscription)
        return response.subscriptionId

    def update_subscription(self, subscription_id, amount=None, start=None,
            occurrences=None, trial_amount=None, trial_occurrences=None):
        """
        Updates an existing recurring subscription payment. All fields to
        update are optional, and only the provided fields will be udpated.
        Many of the fields have particular restrictions that must be followed,
        as noted below.
        
        ``subscription_id``
            The subscription ID returned from the original create_subscription
            call for the subscription you want to update.
        
        ``amount``
            The updated amount to charge every occurrence, either as an int,
            float, or Decimal.
        
        ``start``
            The updated date to start the subscription, as a date object. This
            may only be udpated if no successful payments have been completed.
        
        ``occurrences``
            This updates the number of times to charge the credit card before
            ending.
        
        ``trial_amount``
            Updates the amount charged during the trial period. This may only
            be updated if you have not begun charging at the regular price.
        
        ``trial_occurrences``
            Updates the number of occurrences for the trial period. This may
            only be updated if you have not begun charging at the regular
            price.
        """
        subscription = self.client.factory.create('ARBSubscriptionType')

        # Add the basic subscription updates
        if amount:
            amount = Decimal(str(amount)).quantize(Decimal('0.01'))
            subscription.amount = str(amount)
        if start and start < date.today():
            raise AuthorizeInvalidError('The start date for the subscription '
                'may not be in the past.')
        if start:
            subscription.paymentSchedule.startDate = start.strftime('%Y-%m-%d')
        if occurrences:
            subscription.paymentSchedule.totalOccurrences = occurrences
        if trial_amount:
            trial_amount = Decimal(str(trial_amount))
            trial_amount = trial_amount.quantize(Decimal('0.01'))
            subscription.trialAmount = str(trial_amount)
        if trial_occurrences:
            subscription.paymentSchedule.trialOccurrences = trial_occurrences

        # Make the API call to update the subscription
        self._make_call('ARBUpdateSubscription', subscription_id,
            subscription)

    def delete_subscription(self, subscription_id):
        """
        Deletes an existing recurring subscription payment.
        
        ``subscription_id``
            The subscription ID returned from the original create_subscription
            call for the subscription you want to delete.
        """
        self._make_call('ARBCancelSubscription', subscription_id)

########NEW FILE########
__FILENAME__ = transaction
from decimal import Decimal
import urllib

from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeResponseError


PROD_URL = 'https://secure.authorize.net/gateway/transact.dll'
TEST_URL = 'https://test.authorize.net/gateway/transact.dll'
RESPONSE_FIELDS = {
    0: 'response_code',
    2: 'response_reason_code',
    3: 'response_reason_text',
    4: 'authorization_code',
    5: 'avs_response',
    6: 'transaction_id',
    9: 'amount',
    11: 'transaction_type',
    38: 'cvv_response',
}

def parse_response(response):
    response = response.split(';')
    fields = {}
    for index, name in RESPONSE_FIELDS.items():
        fields[name] = response[index]
    return fields

def safe_unicode_to_str(string):
    try:
        return str(string)
    except UnicodeEncodeError:
        return string.encode('utf-8')

def convert_params_to_byte_str(params):
    converted_params = {}
    for key,value in params.items():
        if isinstance(key, unicode):
            key = safe_unicode_to_str(key)
        if isinstance(value, unicode):
            value = safe_unicode_to_str(value)
        converted_params[key] = value
    return converted_params


class TransactionAPI(object):
    def __init__(self, login_id, transaction_key, debug=True, test=False):
        self.url = TEST_URL if debug else PROD_URL
        self.base_params = {
            'x_login': login_id,
            'x_tran_key': transaction_key,
            'x_version': '3.1',
            'x_test_request': 'TRUE' if test else 'FALSE',
            'x_delim_data': 'TRUE',
            'x_delim_char': ';',
        }

    def _make_call(self, params):
        params = convert_params_to_byte_str(params)
        params = urllib.urlencode(params)
        url = '{0}?{1}'.format(self.url, params)
        try:
            response = urllib.urlopen(url).read()
        except IOError as e:
            raise AuthorizeConnectionError(e)
        fields = parse_response(response)
        if fields['response_code'] != '1':
            e = AuthorizeResponseError('%s full_response=%r' %
                (fields['response_reason_text'], fields))
            e.full_response = fields
            raise e
        return fields

    def _add_params(self, params, credit_card=None, address=None, email=None):
        if credit_card:
            params.update({
                'x_card_num': credit_card.card_number,
                'x_exp_date': credit_card.expiration.strftime('%m-%Y'),
                'x_card_code': credit_card.cvv,
                'x_first_name': credit_card.first_name,
                'x_last_name': credit_card.last_name,
            })

        if email:
            params['x_email'] = email

        if address:
            params.update({
                'x_address': address.street,
                'x_city': address.city,
                'x_state': address.state,
                'x_zip': address.zip_code,
                'x_country': address.country,
            })
        for key, value in params.items():
            if value is None:
                del params[key]
        return params

    def auth(self, amount, credit_card, address=None, email=None):
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        params = self.base_params.copy()
        params = self._add_params(params, credit_card, address, email)
        params['x_type'] = 'AUTH_ONLY'
        params['x_amount'] = str(amount)
        return self._make_call(params)

    def capture(self, amount, credit_card, address=None, email=None):
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        params = self.base_params.copy()
        params = self._add_params(params, credit_card, address, email)
        params['x_type'] = 'AUTH_CAPTURE'
        params['x_amount'] = str(amount)
        return self._make_call(params)

    def settle(self, transaction_id, amount=None):
        # Amount is not required -- if provided, settles for a lower amount
        # than the original auth; if not, settles the full amount authed.
        params = self.base_params.copy()
        params['x_type'] = 'PRIOR_AUTH_CAPTURE'
        params['x_trans_id'] = transaction_id
        if amount:
            amount = Decimal(str(amount)).quantize(Decimal('0.01'))
            params['x_amount'] = str(amount)
        return self._make_call(params)

    def credit(self, card_num, transaction_id, amount):
        # Authorize.net can do unlinked credits (not tied to a previous
        # transaction) but we do not (at least for now).
        # Provide the last four digits for the card number, as well as the
        # transaction id and the amount to credit back.
        # The following restrictions apply:
        # - The transaction id must reference an existing, settled charge.
        #   (Note that in production, settlement happens once daily.)
        # - The amount of the credit (and the sum of all credits against this
        #   original transaction) must be less than or equal to the original
        #   charge amount.
        # - The credit must be submitted within 120 days of the original
        #   transaction being settled.
        params = self.base_params.copy()
        params['x_type'] = 'CREDIT'
        params['x_trans_id'] = transaction_id
        params['x_card_num'] = str(card_num)
        amount = Decimal(str(amount)).quantize(Decimal('0.01'))
        params['x_amount'] = str(amount)
        return self._make_call(params)

    def void(self, transaction_id):
        params = self.base_params.copy()
        params['x_type'] = 'VOID'
        params['x_trans_id'] = transaction_id
        return self._make_call(params)

########NEW FILE########
__FILENAME__ = client
"""
This is your main interface to the Authorize.net API, where you feed in your
credentials and then interact to create transactions and so forth. You will
need to sign up for your own developer account and credentials at
Authorize.net_.

.. warning::

    To use the saved card and recurring billing functionality, you must have
    either or both set up in your Authorize.net account. You must sign up your
    account for the CIM (Customer Information Manager) service and/or the ARB
    (Automated Recurring Billing) service, each of which is an additional
    monthly charge. See the :ref:`authorize-net-documentation` for additional
    information.

.. _Authorize.net: http://developer.authorize.net/

"""
from uuid import uuid4

from authorize.apis.customer import CustomerAPI
from authorize.apis.recurring import RecurringAPI
from authorize.apis.transaction import TransactionAPI

class AuthorizeClient(object):
    """
    Instantiate the client with your login ID and transaction key from
    Authorize.net.
    
    The ``debug`` option determines whether to use debug mode
    for the APIs. This should be ``True`` in development and staging, and
    should be ``False`` in production when you want to actually process credit
    cards. You will need to pass in the appropriate login credentials
    depending on debug mode. The ``test`` option determines whether to run
    the standard API in test mode, which should generally be left ``False``,
    even in development and staging environments.
    """
    def __init__(self, login_id, transaction_key, debug=True, test=False):
        self.login_id = login_id
        self.transaction_key = transaction_key
        self.debug = debug
        self.test = test
        self._transaction = TransactionAPI(login_id, transaction_key,
            debug, test)
        self._recurring = RecurringAPI(login_id, transaction_key, debug, test)
        self._customer = CustomerAPI(login_id, transaction_key, debug, test)

    def card(self, credit_card, address=None, email=None):
        """
        To work with a credit card, pass in a
        :class:`CreditCard <authorize.data.CreditCard>` instance, and
        optionally an :class:`Address <authorize.data.Address>` instance. This
        will return an
        :class:`AuthorizeCreditCard <authorize.client.AuthorizeCreditCard>`
        instance you can then use to execute transactions.
        ``email`` is only required for those using European payment processors.
        """
        return AuthorizeCreditCard(self, credit_card, address=address,
                                   email=email)

    def transaction(self, uid):
        """
        To perform an action on a previous transaction, pass in the ``uid`` of
        that transaction as a string. This will return an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance you can then use to settle, credit or void that transaction.
        """
        return AuthorizeTransaction(self, uid)

    def saved_card(self, uid):
        """
        To create a new transaction from a saved card, pass in the ``uid`` of
        the saved card as a string. This will return an
        :class:`AuthorizeSavedCard <authorize.client.AuthorizeSavedCard>`
        instance you can then use to auth, capture, or create a credit.
        """
        return AuthorizeSavedCard(self, uid)

    def recurring(self, uid):
        """
        To update or cancel an existing recurring payment, pass in the ``uid``
        of the recurring payment as a string. This will return an
        :class:`AuthorizeRecurring <authorize.client.AuthorizeRecurring>`
        instance you can then use to udpate or cancel the payments.
        """
        return AuthorizeRecurring(self, uid)


class AuthorizeCreditCard(object):
    """
    This is the interface for working with a credit card. You use this to
    authorize or charge a credit card, as well as saving the credit card and
    creating recurring payments.
    
    Any operation performed on this instance returns another instance you can
    work with, such as a transaction, saved card, or recurring payment.
    """
    def __init__(self, client, credit_card, address=None, email=None):
        self._client = client
        self.credit_card = credit_card
        self.address = address
        self.email = email

    def __repr__(self):
        return '<AuthorizeCreditCard {0.credit_card.card_type} ' \
            '{0.credit_card.safe_number}>'.format(self)

    def auth(self, amount):
        """
        Authorize a transaction against this card for the specified amount.
        This verifies the amount is available on the card and reserves it.
        Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the transaction.
        """
        response = self._client._transaction.auth(
            amount, self.credit_card, self.address, self.email)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def capture(self, amount):
        """
        Capture a transaction immediately on this card for the specified
        amount. Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the transaction.
        """
        response = self._client._transaction.capture(
            amount, self.credit_card, self.address, self.email)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def save(self):
        """
        Saves the credit card on Authorize.net's servers so you can create
        transactions at a later date. Returns an
        :class:`AuthorizeSavedCard <authorize.client.AuthorizeSavedCard>`
        instance that you can save or use.
        """
        unique_id = uuid4().hex[:20]
        payment = self._client._customer.create_saved_payment(
            self.credit_card, address=self.address)
        profile_id, payment_ids = self._client._customer \
            .create_saved_profile(unique_id, [payment], email=self.email)
        uid = '{0}|{1}'.format(profile_id, payment_ids[0])
        return self._client.saved_card(uid)

    def recurring(self, amount, start, days=None, months=None,
            occurrences=None, trial_amount=None, trial_occurrences=None):
        """
        Creates a recurring payment with this credit card. Pass in the
        following arguments to set it up:
        
        ``amount``
            The amount to charge at each interval.
        
        ``start``
            The ``date`` or ``datetime`` at which to begin the recurring
            charges.
        
        ``days``
            The number of days in the billing cycle. You must provide either
            the ``days`` argument or the ``months`` argument.
        
        ``months``
            The number of months in the billing cycle. You must provide either
            the ``days`` argument or the ``months`` argument.
        
        ``occurrences`` *(optional)*
            The number of times the card should be billed before stopping. If
            not specified, it will continue indefinitely.
        
        ``trial_amount`` *(optional)*
            If you want to charge a lower amount for an introductory period,
            specify the amount.
        
        ``trial_occurrences`` *(optional)*
            If you want to charge a lower amount for an introductory period,
            specify the number of occurrences that period should last.

        Returns an
        :class:`AuthorizeRecurring <authorize.client.AuthorizeRecurring>`
        instance that you can save, update or delete.
        """
        uid = self._client._recurring.create_subscription(
            self.credit_card, amount, start, days=days, months=months,
            occurrences=occurrences, trial_amount=trial_amount,
            trial_occurrences=trial_occurrences)
        return self._client.recurring(uid)


class AuthorizeTransaction(object):
    """
    This is the interface for working with a previous transaction. It is
    returned by many other operations, or you can save the transaction's
    ``uid`` and reinstantiate it later.
    
    You can then use this transaction to settle a previous authorization,
    credit back a previous transaction, or void a previous authorization. Any
    such operation returns another transaction instance you can work with.
    
    Additionally, if you need to access the full raw result of the transaction
    it is stored in the ``full_response`` attribute on the class.
    """
    def __init__(self, client, uid):
        self._client = client
        self.uid = uid

    def __repr__(self):
        return '<AuthorizeTransaction {0.uid}>'.format(self)

    def settle(self, amount=None):
        """
        Settles this transaction if it is a previous authorization. If no
        ``amount`` is specified, the full amount will be settled; if a lower
        ``amount`` is provided, the lower amount will be settled; if a higher
        ``amount`` is given, it will result in an error. Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the settlement transaction.
        """
        response = self._client._transaction.settle(self.uid, amount=amount)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def credit(self, card_number, amount):
        """
        Creates a credit (refund) back on the original transaction. The
        ``card_number`` should be the last four digits of the credit card
        and the ``amount`` is the amount to credit the card. Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the credit transaction.
        
        Credit transactions are bound by a number of restrictions:
        
        * The original transaction must be an existing, settled charge. (Note
          that this is different than merely calling the
          :meth:`AuthorizeTransaction.settle <authorize.client.AuthorizeTransaction.settle>`
          method, which submits a payment for settlement. In production,
          Authorize.net actually settles charges once daily. Until a charge is
          settled, you should use
          :meth:`AuthorizeTransaction.void <authorize.client.AuthorizeTransaction.void>`
          instead.)
        * The amount of the credit (as well as the sum of all credits against
          this original transaction) must be less than or equal to the
          original amount charged.
        * The credit transaction must be submitted within 120 days of the date
          the original transaction was settled.
        """
        response = self._client._transaction.credit(
            card_number, self.uid, amount)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def void(self):
        """
        Voids a previous authorization that has not yet been settled. Returns
        an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the void transaction.
        """
        response = self._client._transaction.void(self.uid)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction


class AuthorizeSavedCard(object):
    """
    This is the interface for working with a saved credit card. It is returned
    by the
    :meth:`AuthorizeCreditCard.save <authorize.client.AuthorizeCreditCard.save>`
    method, or you can save a saved card's ``uid`` and reinstantiate it later.
    
    You can then use this saved card to create new authorizations, captures,
    and credits. Or you can delete this card from the Authorize.net database.
    The first three operations will all return a transaction instance to work
    with.

    You can also retrieve payment information with the
    :meth:`AuthorizeSavedCard.get_payment_info <authorize.client.AuthorizeSavedCard.get_payment_info`
    method.

    You can update this information by setting it and running the
    :meth:`AuthorizeSavedCard.update <authorize.client.AuthorizeSavedCard.update>`
    method.
    """

    def __init__(self, client, uid):
        self._client = client
        self.uid = uid
        self._profile_id, self._payment_id = uid.split('|')

    def __repr__(self):
        return '<AuthorizeSavedCard {0.uid}>'.format(self)

    def auth(self, amount):
        """
        Authorize a transaction against this card for the specified amount.
        This verifies the amount is available on the card and reserves it.
        Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the transaction.
        """
        response = self._client._customer.auth(
            self._profile_id, self._payment_id, amount)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def capture(self, amount):
        """
        Capture a transaction immediately on this card for the specified
        amount. Returns an
        :class:`AuthorizeTransaction <authorize.client.AuthorizeTransaction>`
        instance representing the transaction.
        """
        response = self._client._customer.capture(
            self._profile_id, self._payment_id, amount)
        transaction = self._client.transaction(response['transaction_id'])
        transaction.full_response = response
        return transaction

    def update(self, **kwargs):
        """
        Updates information about a saved card. You can use this to change the
        address associated with the card, or the name, or the user's email
        address. You may even update the expiration date.

        ``number`` *(optional)*
            An updated number for the card. In most cases, you should create a
            new card instead of using this.

        ``first_name`` *(optional)*
            The first name on the card.

        ``last_name`` *(optional)*
            The last name on the card

        ``address`` *(optional)*
            An :class:`Address <authorize.data.Address>` object that holds new
            billing address information for the card.

        ``email`` *(optional)*
            Updates the email associated with the card. Note that emails are
            actually stored on the customer profile. If you have multiple cards
            (payments) with the same profile, this will update the email for
            all of them.

        ``exp_month`` *(conditional)*
            If this option is specified, ``exp_year`` must also be specified,
            or it will be ignored.

            An integer representing the month of the card's expiration date.

        ``exp_year`` *(conditional)*
            If this option is specified, ``exp_month`` must also be specified,
            or it will be ignored.

            An integer representing the year of the card's expiration date.
        """
        settings = {'exp_month': None, 'exp_year': None}
        old_settings = self.get_payment_info()
        settings.update(old_settings)
        settings.update(**kwargs)
        self._client._customer.update_saved_payment(
            self._profile_id, self._payment_id, **settings)

    def get_payment_info(self):
        """
        Retrieves information about a card. It will return a dictionary
        containing the ``first_name`` and ``last_name`` on the card, as well
        as an ``address`` (a :class:`Address <authorize.data.Address>`
        instance), and the user's ``email``. These can be used, for instance,
        to populate a form which the user can fill to update their payment
        information.

        Note that the expiration date fields are masked by Authorize.net, and
        so are not returned by this function. Neither is the card number
        itself.
        """
        return self._client._customer.retrieve_saved_payment(
            self._profile_id, self._payment_id)

    def delete(self):
        """
        Removes this saved card from the Authorize.net database.
        """
        self._client._customer.delete_saved_payment(
            self._profile_id, self._payment_id)


class AuthorizeRecurring(object):
    """
    This is the interface for working with a recurring charge. It is returned
    by the
    :meth:`AuthorizeCreditCard.recurring <authorize.client.AuthorizeCreditCard.recurring>`
    method, or you can save a recurring payment's ``uid`` and reinstantiate it
    later.
    
    The recurring payment will continue charging automatically, but if you
    want to make changes to an existing recurring payment or to cancel a
    recurring payment, this provides the interface.
    """
    def __init__(self, client, uid):
        self._client = client
        self.uid = uid

    def __repr__(self):
        return '<AuthorizeRecurring {0.uid}>'.format(self)

    def update(self, amount=None, start=None, occurrences=None,
            trial_amount=None, trial_occurrences=None):
        """
        Updates the amount or status of the recurring payment. You may provide
        any or all fields and they will be updated appropriately, so long as
        none conflict. Fields work as described under the

        ``amount`` *(optional)*
            The amount to charge at each interval. Will only be applied to
            future charges.
        
        ``start`` *(optional)*
            The ``date`` or ``datetime`` at which to begin the recurring
            charges. You may only specify this option if the recurring charge
            has not yet begun.
        
        ``occurrences`` *(optional)*
            The number of times the card should be billed before stopping. If
            not specified, it will continue indefinitely.
        
        ``trial_amount`` *(optional)*
            If you want to charge a lower amount for an introductory period,
            specify the amount. You may specify this option only if there have
            not yet been any non-trial payments.
        
        ``trial_occurrences`` *(optional)*
            If you want to charge a lower amount for an introductory period,
            specify the number of occurrences that period should last. You may
            specify this option only if there have not yet been any non-trial
            payments.
        """
        self._client._recurring.update_subscription(self.uid,
            amount=amount, start=start, occurrences=occurrences,
            trial_amount=trial_amount, trial_occurrences=trial_occurrences)

    def delete(self):
        """
        Cancels any future charges from this recurring payment.
        """
        self._client._recurring.delete_subscription(self.uid)

########NEW FILE########
__FILENAME__ = data
"""
This module provides the data structures for describing credit cards and
addresses for use in executing charges.
"""

import calendar
from datetime import datetime
import re

from authorize.exceptions import AuthorizeInvalidError


CARD_TYPES = {
    'visa': r'4\d{12}(\d{3})?$',
    'amex': r'37\d{13}$',
    'mc': r'5[1-5]\d{14}$',
    'discover': r'6011\d{12}',
    'diners': r'(30[0-5]\d{11}|(36|38)\d{12})$'
}

class CreditCard(object):
    """
    Represents a credit card that can be charged.
    
    Pass in the credit card number, expiration date, CVV code, and optionally
    a first name and last name. The card will be validated upon instatiation
    and will raise an
    :class:`AuthorizeInvalidError <authorize.exceptions.AuthorizeInvalidError>`
    for invalid credit card numbers, past expiration dates, etc.
    """
    def __init__(self, card_number=None, exp_year=None, exp_month=None,
            cvv=None, first_name=None, last_name=None):
        self.card_number = re.sub(r'\D', '', str(card_number))
        self.exp_year = str(exp_year)
        self.exp_month = str(exp_month)
        self.cvv = str(cvv)
        self.first_name = first_name
        self.last_name = last_name
        self.validate()

    def __repr__(self):
        return '<CreditCard {0.card_type} {0.safe_number}>'.format(self)

    def validate(self):
        """
        Validates the credit card data and raises an
        :class:`AuthorizeInvalidError <authorize.exceptions.AuthorizeInvalidError>`
        if anything doesn't check out. You shouldn't have to call this
        yourself.
        """
        try:
            num = map(int, self.card_number)
        except ValueError:
            raise AuthorizeInvalidError('Credit card number is not valid.')
        if sum(num[::-2] + map(lambda d: sum(divmod(d * 2, 10)), num[-2::-2])) % 10:
            raise AuthorizeInvalidError('Credit card number is not valid.')
        if datetime.now() > self.expiration:
            raise AuthorizeInvalidError('Credit card is expired.')
        if not re.match(r'^[\d+]{3,4}$', self.cvv):
            raise AuthorizeInvalidError('Credit card CVV is invalid format.')
        if not self.card_type:
            raise AuthorizeInvalidError('Credit card number is not valid.')

    @staticmethod
    def exp_time(exp_month, exp_year):
        exp_year, exp_month = int(exp_year), int(exp_month)
        return datetime(exp_year, exp_month,
            calendar.monthrange(exp_year, exp_month)[1],
            23, 59, 59)

    @property
    def expiration(self):
        """
        The credit card expiration date as a ``datetime`` object.
        """
        return self.exp_time(self.exp_month, self.exp_year)

    @property
    def safe_number(self):
        """
        The credit card number with all but the last four digits masked. This
        is useful for storing a representation of the card without keeping
        sensitive data.
        """
        mask = '*' * (len(self.card_number) - 4)
        return '{0}{1}'.format(mask, self.card_number[-4:])

    @property
    def card_type(self):
        """
        The credit card issuer, such as Visa or American Express, which is
        determined from the credit card number. Recognizes Visa, American
        Express, MasterCard, Discover, and Diners Club.
        """
        for card_type, card_type_re in CARD_TYPES.items():
            if re.match(card_type_re, self.card_number):
                return card_type


class Address(object):
    """
    Represents a billing address for a charge. Pass in the street, city, state
    and zip code, and optionally country for the address.
    """
    def __init__(self, street=None, city=None, state=None, zip_code=None,
            country='US'):
        self.street = street
        self.city = city
        self.state = state
        self.zip_code = zip_code
        self.country = country

    def __repr__(self):
        return '<Address {0.street}, {0.city}, {0.state} {0.zip_code}>' \
            .format(self)

########NEW FILE########
__FILENAME__ = exceptions
class AuthorizeError(Exception):
    """Base class for all errors."""

class AuthorizeConnectionError(AuthorizeError):
    """Error communicating with the Authorize.net API."""

class AuthorizeResponseError(AuthorizeError):
    """Error response code returned from API."""

class AuthorizeInvalidError(AuthorizeError):
    """Invalid information provided."""

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Authorize Sauce documentation build configuration file, created by
# sphinx-quickstart on Sat May 12 17:09:32 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Authorize Sauce'
copyright = u'2012, Jeff Schenck'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'AuthorizeSaucedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'AuthorizeSauce.tex', u'Authorize Sauce Documentation',
   u'Jeff Schenck', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'authorizesauce', u'Authorize Sauce Documentation',
     [u'Jeff Schenck'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'AuthorizeSauce', u'Authorize Sauce Documentation',
   u'Jeff Schenck', 'AuthorizeSauce', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
import os
import sys
from unittest2 import TestLoader, TextTestRunner


if __name__ == '__main__':
    tests_dir = os.path.dirname(os.path.abspath(__file__))
    authorize_dir = os.path.join(tests_dir, os.path.pardir)
    sys.path.append(authorize_dir)
    suite = TestLoader().discover(tests_dir)
    runner = TextTestRunner(verbosity=1)
    runner.run(suite)

########NEW FILE########
__FILENAME__ = test_api_customer
from datetime import date

import mock
from suds import WebFault
from unittest2 import TestCase

from authorize.apis.customer import CustomerAPI, PROD_URL, TEST_URL
from authorize.data import Address, CreditCard
from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeResponseError


class AttrDict(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.__dict__ = self

OPTIONS = 'x_delim_data=TRUE&x_version=3.1&x_delim_char=%3B&x_test_request=F'
RESPONSE = (
    '1;1;1;This transaction has been approved.;IKRAGJ;Y;2171062816;;;20.00;CC'
    ';auth_only;;Jeffrey;Schenck;;45 Rose Ave;Venice;CA;90291;USA;;;;;;;;;;;;'
    ';;;;;375DD9293D7605E20DF0B437EE2A7B92;P;2;;;;;;;;;;;XXXX1111;Visa;;;;;;;'
    ';;;;;;;;;;Y')

BILL_TO = AttrDict({
    'firstName': 'Jeff',
    'lastName': 'Schenck',
    'address': '45 Rose Ave',
    'city': 'Venice',
    'state': 'CA',
    'zip': '90291',
    'country': 'US',
})

PARSED_RESPONSE = {
    'cvv_response': 'P',
    'authorization_code': 'IKRAGJ',
    'response_code': '1',
    'amount': '20.00',
    'transaction_type': 'auth_only',
    'avs_response': 'Y',
    'response_reason_code': '1',
    'response_reason_text': 'This transaction has been approved.',
    'transaction_id': '2171062816',
}

SUCCESS = AttrDict({
    'resultCode': 'Ok',
    'customerProfileId': '123456',
    'customerPaymentProfileIdList': [['123457']],
    'customerPaymentProfileId': '123458',
    'directResponse': RESPONSE,
})

ERROR = AttrDict({
    'resultCode': 'Error',
    'messages': [[AttrDict({
        'code': 'E00016',
        'text': 'The field type is invalid.',
    })]],
})

PAYMENT = AttrDict({
    'creditCard': AttrDict({
        'cardNumber': 'XXXX1111',
        'expirationDate': 'XXXX',
    })
})

PROFILE = AttrDict({
    'payment': PAYMENT,
    'customerType': 'individual',
    'billTo': BILL_TO,
    'customerPaymentProfileId': 123458,
})

PROFILES_WRAPPER = AttrDict({
    'customerProfileId': '123456',
    'email': 'example@example.com',
    'paymentProfiles': [[PROFILE]]
})

PROFILE_RESPONSE = AttrDict({
    'resultCode': 'Ok',
    'profile': PROFILES_WRAPPER
})


class CustomerAPITests(TestCase):
    def setUp(self):
        self.patcher = mock.patch(
            'authorize.apis.customer.Client')
        self.Client = self.patcher.start()
        self.api = CustomerAPI('123', '456')

        # Make the factory creator return mocks that know what kind they are
        def create(kind):
            created = mock.Mock()
            created._kind = kind
            return created
        self.api.client.factory.create.side_effect = create

    def tearDown(self):
        self.patcher.stop()

    def test_basic_api(self):
        api = CustomerAPI('123', '456')
        self.assertEqual(api.url, TEST_URL)
        api = CustomerAPI('123', '456', debug=False)
        self.assertEqual(api.url, PROD_URL)

    def test_client_and_auth(self):
        self.Client.reset_mock()
        api = CustomerAPI('123', '456')
        self.assertEqual(self.Client.call_args, None)
        client_ = api.client
        self.assertEqual(self.Client.call_args[0][0], TEST_URL)
        client_auth = api.client_auth
        self.assertEqual(client_auth.name, '123')
        self.assertEqual(client_auth.transactionKey, '456')

    def test_make_call(self):
        self.api.client.service.TestService.return_value = SUCCESS
        result = self.api._make_call('TestService', 'foo')
        self.assertEqual(result, SUCCESS)
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_make_call_connection_error(self):
        self.api.client.service.TestService.side_effect = WebFault('a', 'b')
        self.assertRaises(AuthorizeConnectionError, self.api._make_call,
            'TestService', 'foo')
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_make_call_response_error(self):
        self.api.client.service.TestService.return_value = ERROR
        try:
            self.api._make_call('TestService', 'foo')
        except AuthorizeResponseError as e:
            self.assertEqual(str(e), 'E00016: The field type is invalid.')
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_create_saved_profile(self):
        service = self.api.client.service.CreateCustomerProfile
        service.return_value = SUCCESS
        email = 'example@example.com'

        # Without payments
        profile_id, payment_ids = self.api.create_saved_profile(
            123, email=email)
        profile = service.call_args[0][1]
        self.assertEqual(profile._kind, 'CustomerProfileType')
        self.assertEqual(profile.merchantCustomerId, 123)
        self.assertNotEqual(profile.paymentProfiles._kind,
            'ArrayOfCustomerPaymentProfileType')
        self.assertEqual(profile_id, '123456')
        self.assertEqual(payment_ids, None)
        self.assertEqual(profile.email, email)

        # With payments
        payment = mock.Mock()
        profile_id, payment_ids = self.api.create_saved_profile(
            123, [payment])
        profile = service.call_args[0][1]
        self.assertEqual(profile._kind, 'CustomerProfileType')
        self.assertEqual(profile.merchantCustomerId, 123)
        self.assertEqual(profile.paymentProfiles._kind,
            'ArrayOfCustomerPaymentProfileType')
        self.assertEqual(profile.paymentProfiles.CustomerPaymentProfileType,
            [payment])
        self.assertEqual(profile_id, '123456')
        self.assertEqual(payment_ids, ['123457'])

    def test_create_saved_payment(self):
        service = self.api.client.service.CreateCustomerPaymentProfile
        service.return_value = SUCCESS
        year = date.today().year + 10
        credit_card = CreditCard('4111111111111111', year, 1, '911',
            'Jeff', 'Schenck')
        address = Address('45 Rose Ave', 'Venice', 'CA', '90291')

        # Without profile id should return object
        payment_profile = self.api.create_saved_payment(credit_card, address)
        self.assertEqual(service.call_args, None)
        self.assertEqual(payment_profile._kind, 'CustomerPaymentProfileType')
        self.assertEqual(payment_profile.payment._kind, 'PaymentType')
        self.assertEqual(payment_profile.payment.creditCard._kind,
            'CreditCardType')
        self.assertEqual(payment_profile.payment.creditCard.cardNumber,
            '4111111111111111')
        self.assertEqual(payment_profile.payment.creditCard.expirationDate,
            '{0}-01'.format(year))
        self.assertEqual(payment_profile.payment.creditCard.cardCode, '911')
        self.assertEqual(payment_profile.billTo.firstName, 'Jeff')
        self.assertEqual(payment_profile.billTo.lastName, 'Schenck')
        self.assertEqual(payment_profile.billTo.address, '45 Rose Ave')
        self.assertEqual(payment_profile.billTo.city, 'Venice')
        self.assertEqual(payment_profile.billTo.state, 'CA')
        self.assertEqual(payment_profile.billTo.zip, '90291')
        self.assertEqual(payment_profile.billTo.country, 'US')

        # With profile id should make call to API
        payment_profile_id = self.api.create_saved_payment(credit_card,
            profile_id='1')
        self.assertEqual(payment_profile_id, '123458')
        self.assertEqual(service.call_args[0][1], '1')
        payment_profile = service.call_args[0][2]
        self.assertEqual(payment_profile._kind, 'CustomerPaymentProfileType')
        self.assertEqual(payment_profile.payment._kind, 'PaymentType')
        self.assertEqual(payment_profile.payment.creditCard._kind,
            'CreditCardType')
        self.assertEqual(payment_profile.payment.creditCard.cardNumber,
            '4111111111111111')
        self.assertEqual(payment_profile.payment.creditCard.expirationDate,
            '{0}-01'.format(year))
        self.assertEqual(payment_profile.payment.creditCard.cardCode, '911')
        self.assertEqual(payment_profile.billTo.firstName, 'Jeff')
        self.assertEqual(payment_profile.billTo.lastName, 'Schenck')
        self.assertNotEqual(payment_profile.billTo.address, '45 Rose Ave')
        self.assertNotEqual(payment_profile.billTo.city, 'Venice')
        self.assertNotEqual(payment_profile.billTo.state, 'CA')
        self.assertNotEqual(payment_profile.billTo.zip, '90291')
        self.assertNotEqual(payment_profile.billTo.country, 'US')

    def test_retrieve_saved_payment(self):
        service = self.api.client.service.GetCustomerProfile
        service.return_value = PROFILE_RESPONSE

        address = Address(street='45 Rose Ave', city='Venice', state='CA',
                          zip_code='90291', country='USA')

        payment = self.api.retrieve_saved_payment('123456', '123458')
        self.assertEqual(payment['first_name'], 'Jeff')
        self.assertEqual(payment['last_name'], 'Schenck')
        self.assertEqual(payment['address'].street, address.street)
        self.assertEqual(payment['address'].city, address.city)
        self.assertEqual(payment['address'].state, address.state)
        self.assertEqual(payment['address'].zip_code, address.zip_code)
        self.assertEqual(payment['number'], 'XXXX1111')
        self.assertEqual(payment['email'], 'example@example.com')

    def test_update_saved_payment(self):
        service_payment = self.api.client.service.UpdateCustomerPaymentProfile
        service_payment.return_value = SUCCESS
        service_customer = self.api.client.service.UpdateCustomerProfile
        service_customer.return_value = SUCCESS

        address = Address(street='45 Rose Ave', city='Venice', state='CA',
                          zip_code='90291', country='US')
        kwargs = {
            'first_name': 'Jeff', 'last_name': 'Schenck', 'address': address,
            'email': 'example@example.com', 'exp_month': '10',
            'exp_year': int(date.today().year + 10), 'number': 'XXXX1111'}
        self.api.update_saved_payment(
            '123456', '123458', **kwargs)

        self.assertEqual(service_payment.call_args[0][1], '123456')
        profile_request = service_payment.call_args[0][2]
        self.assertEqual(profile_request.customerPaymentProfileId, '123458')
        self.assertEqual(
            profile_request.billTo.firstName, kwargs['first_name'])
        self.assertEqual(
            profile_request.billTo.lastName, kwargs['last_name'])
        self.assertEqual(profile_request.billTo.address, address.street)
        self.assertEqual(profile_request.billTo.state, address.state)
        self.assertEqual(profile_request.billTo.zip, address.zip_code)
        self.assertEqual(
            profile_request.payment.creditCard.cardNumber, 'XXXX1111')
        exp_date = '{0}-{1:0>2}'.format(
            kwargs['exp_year'], kwargs['exp_month'])
        self.assertEqual(
            profile_request.payment.creditCard.expirationDate, exp_date)

        customer_profile = service_customer.call_args[0][1]
        self.assertEqual(customer_profile.customerProfileId, '123456')
        self.assertEqual(customer_profile.email, kwargs['email'])

    def test_delete_saved_profile(self):
        service = self.api.client.service.DeleteCustomerProfile
        service.return_value = SUCCESS
        self.api.delete_saved_profile('1')
        self.assertEqual(service.call_args[0][1], '1')

    def test_delete_saved_payment(self):
        service = self.api.client.service.DeleteCustomerPaymentProfile
        service.return_value = SUCCESS
        self.api.delete_saved_payment('1', '2')
        self.assertEqual(service.call_args[0][1:], ('1', '2'))

    def test_auth(self):
        service = self.api.client.service.CreateCustomerProfileTransaction
        service.return_value = SUCCESS
        result = self.api.auth('1', '2', 20)
        transaction, options = service.call_args[0][1:]
        self.assertEqual(transaction._kind, 'ProfileTransactionType')
        self.assertEqual(transaction.profileTransAuthOnly._kind,
            'ProfileTransAuthOnlyType')
        self.assertEqual(transaction.profileTransAuthOnly.amount, '20.00')
        self.assertEqual(
            transaction.profileTransAuthOnly.customerProfileId, '1')
        self.assertEqual(
            transaction.profileTransAuthOnly.customerPaymentProfileId, '2')
        self.assertEqual(options, OPTIONS)
        self.assertEqual(result, PARSED_RESPONSE)

    def test_capture(self):
        service = self.api.client.service.CreateCustomerProfileTransaction
        service.return_value = SUCCESS
        result = self.api.capture('1', '2', 20)
        transaction, options = service.call_args[0][1:]
        self.assertEqual(transaction._kind, 'ProfileTransactionType')
        self.assertEqual(transaction.profileTransAuthCapture._kind,
            'ProfileTransAuthCaptureType')
        self.assertEqual(transaction.profileTransAuthCapture.amount, '20.00')
        self.assertEqual(
            transaction.profileTransAuthCapture.customerProfileId, '1')
        self.assertEqual(
            transaction.profileTransAuthCapture.customerPaymentProfileId, '2')
        self.assertEqual(options, OPTIONS)
        self.assertEqual(result, PARSED_RESPONSE)

########NEW FILE########
__FILENAME__ = test_api_recurring
from datetime import date, timedelta

import mock
from suds import WebFault
from unittest2 import TestCase

from authorize.apis.recurring import PROD_URL, RecurringAPI, TEST_URL
from authorize.data import CreditCard
from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeInvalidError, AuthorizeResponseError


class AttrDict(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.__dict__ = self

SUCCESS = AttrDict({
    'resultCode': 'Ok',
    'subscriptionId': '123',
})
ERROR = AttrDict({
    'resultCode': 'Error',
    'messages': [[AttrDict({
        'code': 'E00016',
        'text': 'The field type is invalid.',
    })]],
})

class RecurringAPITests(TestCase):
    def setUp(self):
        self.patcher = mock.patch(
            'authorize.apis.recurring.Client')
        self.Client = self.patcher.start()
        self.api = RecurringAPI('123', '456')

        # Make the factory creator return mocks that know what kind they are
        def create(kind):
            created = mock.Mock()
            created._kind = kind
            return created
        self.api.client.factory.create.side_effect = create

    def tearDown(self):
        self.patcher.stop()

    def test_basic_api(self):
        api = RecurringAPI('123', '456')
        self.assertEqual(api.url, TEST_URL)
        api = RecurringAPI('123', '456', debug=False)
        self.assertEqual(api.url, PROD_URL)

    def test_client_and_auth(self):
        self.Client.reset_mock()
        api = RecurringAPI('123', '456')
        self.assertEqual(self.Client.call_args, None)
        client_ = api.client
        self.assertEqual(self.Client.call_args[0][0], TEST_URL)
        client_auth = api.client_auth
        self.assertEqual(client_auth.name, '123')
        self.assertEqual(client_auth.transactionKey, '456')

    def test_make_call(self):
        self.api.client.service.TestService.return_value = SUCCESS
        result = self.api._make_call('TestService', 'foo')
        self.assertEqual(result, SUCCESS)
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_make_call_connection_error(self):
        self.api.client.service.TestService.side_effect = WebFault('a', 'b')
        self.assertRaises(AuthorizeConnectionError, self.api._make_call,
            'TestService', 'foo')
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_make_call_response_error(self):
        self.api.client.service.TestService.return_value = ERROR
        try:
            self.api._make_call('TestService', 'foo')
        except AuthorizeResponseError as e:
            self.assertEqual(str(e), 'E00016: The field type is invalid.')
        self.assertEqual(self.api.client.service.TestService.call_args[0],
            (self.api.client_auth, 'foo'))

    def test_create_subscription(self):
        service = self.api.client.service.ARBCreateSubscription
        service.return_value = SUCCESS
        year = date.today().year + 10
        credit_card = CreditCard('4111111111111111', year, 1, '911',
            'Jeff', 'Schenck')
        nameless_credit_card = CreditCard('4111111111111111', year, 1, '911')
        start = date.today() + timedelta(days=7)

        # Test missing credit card name
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            nameless_credit_card, 10, start, months=1, occurrences=10)

        # Test both or neither of days and months arguments
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, occurrences=10)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, days=30, months=1, occurrences=10)

        # Test validation of months and of days arguments
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, days=1, occurrences=10)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, days=400, occurrences=10)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, months=0, occurrences=10)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, months=13, occurrences=10)

        # Test start date in the past
        past_start = date.today() - timedelta(days=1)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, past_start, months=1, occurrences=10)

        # Test providing only one of trial_amount and trial_occurrences
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, months=1, occurrences=10,
            trial_amount=5)
        self.assertRaises(AuthorizeInvalidError, self.api.create_subscription,
            credit_card, 10, start, months=1, occurrences=10,
            trial_occurrences=3)

        # Test basic successful subscription
        subscription_id = self.api.create_subscription(credit_card, 10, start,
            months=1, occurrences=10)
        self.assertEqual(subscription_id, '123')
        subscription = service.call_args[0][1]
        self.assertEqual(subscription._kind, 'ARBSubscriptionType')
        self.assertEqual(subscription.amount, '10.00')
        self.assertEqual(subscription.payment._kind, 'PaymentType')
        self.assertEqual(subscription.payment.creditCard._kind,
            'CreditCardType')
        self.assertEqual(subscription.payment.creditCard.cardNumber,
            '4111111111111111')
        self.assertEqual(subscription.payment.creditCard.expirationDate,
            '{0}-01'.format(year))
        self.assertEqual(subscription.payment.creditCard.cardCode, '911')
        self.assertEqual(subscription.billTo.firstName, 'Jeff')
        self.assertEqual(subscription.billTo.lastName, 'Schenck')
        self.assertEqual(subscription.paymentSchedule.interval.length, 1)
        self.assertEqual(subscription.paymentSchedule.startDate,
            start.strftime('%Y-%m-%d'))
        self.assertEqual(subscription.paymentSchedule.totalOccurrences, 10)

        # Test with days interval
        self.api.create_subscription(credit_card, 10, start, days=14,
            occurrences=10)
        subscription = service.call_args[0][1]
        self.assertEqual(subscription.paymentSchedule.interval.length, 14)

        # Test with infinite occurrences
        self.api.create_subscription(credit_card, 10, start, months=1)
        subscription = service.call_args[0][1]
        self.assertEqual(subscription.paymentSchedule.totalOccurrences, 9999)

        # Test with trial period
        self.api.create_subscription(credit_card, 10, start, months=1,
            occurrences=10, trial_amount=5, trial_occurrences=3)
        subscription = service.call_args[0][1]
        self.assertEqual(subscription.paymentSchedule.trialOccurrences, 3)
        self.assertEqual(subscription.trialAmount, '5.00')

    def test_update_subscription(self):
        service = self.api.client.service.ARBUpdateSubscription
        service.return_value = SUCCESS
        start = date.today() + timedelta(days=7)

        # Test start date in the past
        past_start = date.today() - timedelta(days=1)
        self.assertRaises(AuthorizeInvalidError, self.api.update_subscription,
            '1', start=past_start)

        # Test successful update with one argument
        self.api.update_subscription('1', start=start)
        subscription_id, subscription = service.call_args[0][1:]
        self.assertEqual(subscription_id, '1')
        self.assertEqual(subscription._kind, 'ARBSubscriptionType')
        self.assertEqual(subscription.paymentSchedule.startDate,
            start.strftime('%Y-%m-%d'))
        self.assertTrue(isinstance(subscription.amount, mock.Mock))
        self.assertTrue(isinstance(
            subscription.paymentSchedule.totalOccurrences, mock.Mock))
        self.assertTrue(isinstance(subscription.trialAmount, mock.Mock))
        self.assertTrue(isinstance(
            subscription.paymentSchedule.trialOccurrences, mock.Mock))

        # Test successful update with all arguments
        self.api.update_subscription('1', amount=25, start=start,
            occurrences=21, trial_amount=24, trial_occurrences=1)
        subscription_id, subscription = service.call_args[0][1:]
        self.assertEqual(subscription_id, '1')
        self.assertEqual(subscription._kind, 'ARBSubscriptionType')
        self.assertTrue(subscription.amount, '25.00')
        self.assertEqual(subscription.paymentSchedule.startDate,
            start.strftime('%Y-%m-%d'))
        self.assertTrue(subscription.paymentSchedule.totalOccurrences, 21)
        self.assertTrue(subscription.trialAmount, '24.00')
        self.assertTrue(subscription.paymentSchedule.trialOccurrences, 1)

    def test_delete_subscription(self):
        service = self.api.client.service.ARBCancelSubscription
        service.return_value = SUCCESS
        self.api.delete_subscription('1')
        self.assertEqual(service.call_args[0][1], '1')

########NEW FILE########
__FILENAME__ = test_api_transaction
from cStringIO import StringIO
from datetime import date

import mock
from unittest2 import TestCase
from urlparse import urlparse, parse_qsl
from urllib import unquote_plus

from authorize.apis.transaction import PROD_URL, TEST_URL, TransactionAPI
from authorize.data import Address, CreditCard
from authorize.exceptions import AuthorizeConnectionError, \
    AuthorizeResponseError


SUCCESS = StringIO(
    '1;1;1;This transaction has been approved.;IKRAGJ;Y;2171062816;;;20.00;CC'
    ';auth_only;;Jeffrey;Schenck;;45 Rose Ave;Venice;CA;90291;USA;;;;;;;;;;;;'
    ';;;;;375DD9293D7605E20DF0B437EE2A7B92;P;2;;;;;;;;;;;XXXX1111;Visa;;;;;;;'
    ';;;;;;;;;;Y')
PARSED_SUCCESS = {
    'cvv_response': 'P',
    'authorization_code': 'IKRAGJ',
    'response_code': '1',
    'amount': '20.00',
    'transaction_type': 'auth_only',
    'avs_response': 'Y',
    'response_reason_code': '1',
    'response_reason_text': 'This transaction has been approved.',
    'transaction_id': '2171062816',
}
ERROR = StringIO(
    '2;1;2;This transaction has been declined.;000000;N;2171062816;;;20.00;CC'
    ';auth_only;;Jeffrey;Schenck;;45 Rose Ave;Venice;CA;90291;USA;;;;;;;;;;;;'
    ';;;;;375DD9293D7605E20DF0B437EE2A7B92;N;1;;;;;;;;;;;XXXX1111;Visa;;;;;;;'
    ';;;;;;;;;;Y')
PARSED_ERROR = {
    'cvv_response': 'N',
    'authorization_code': '000000',
    'response_code': '2',
    'amount': '20.00',
    'transaction_type': 'auth_only',
    'avs_response': 'N',
    'response_reason_code': '2',
    'response_reason_text': 'This transaction has been declined.',
    'transaction_id': '2171062816',
}

class URL(object):
    """
    a class to enable comparing of two urls regardless of order of parameters
    see http://stackoverflow.com/questions/5371992/comparing-two-urls-in-python 
    """
    def __init__(self, url):
        parts = urlparse(url)
        _query = frozenset(parse_qsl(parts.query))
        _path = unquote_plus(parts.path)
        parts = parts._replace(query=_query, path=_path)
        self.parts = parts

    def __eq__(self, other):
        return self.parts == other.parts

    def __hash__(self, other):
        return hash(self.parts)

class TransactionAPITests(TestCase):
    def setUp(self):
        self.api = TransactionAPI('123', '456')
        self.success = lambda *args, **kwargs: SUCCESS.reset() or SUCCESS
        self.error = lambda *args, **kwargs: ERROR.reset() or ERROR
        self.year = date.today().year + 10
        self.credit_card = CreditCard('4111111111111111', self.year, 1, '911')
        self.address = Address('45 Rose Ave', 'Venice', 'CA', '90291')

    def test_basic_api(self):
        api = TransactionAPI('123', '456')
        self.assertEqual(api.url, TEST_URL)
        api = TransactionAPI('123', '456', debug=False)
        self.assertEqual(api.url, PROD_URL)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_make_call(self, urlopen):
        urlopen.side_effect = self.success
        result = self.api._make_call({'a': '1', 'b': '2'})
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('{0}?a=1&b=2'.format(TEST_URL)))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_make_call_with_unicode(self, urlopen):
        urlopen.side_effect = self.success
        result = self.api._make_call({u'\xe3': '1', 'b': u'\xe3'})
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('{0}?%C3%A3=1&b=%C3%A3'.format(TEST_URL)))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_make_call_connection_error(self, urlopen):
        urlopen.side_effect = IOError('Borked')
        self.assertRaises(AuthorizeConnectionError, self.api._make_call,
            {'a': '1', 'b': '2'})

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_make_call_response_error(self, urlopen):
        urlopen.side_effect = self.error
        try:
            self.api._make_call({'a': '1', 'b': '2'})
        except AuthorizeResponseError as e:
            self.assertTrue(str(e).startswith('This transaction has been declined.'))
            self.assertEqual(e.full_response, PARSED_ERROR)

    def test_add_params(self):
        self.assertEqual(self.api._add_params({}), {})
        params = self.api._add_params({}, credit_card=self.credit_card)
        self.assertEqual(params, {
            'x_card_num': '4111111111111111',
            'x_exp_date': '01-{0}'.format(self.year),
            'x_card_code': '911',
        })
        params = self.api._add_params({}, address=self.address)
        self.assertEqual(params, {
            'x_address': '45 Rose Ave',
            'x_city': 'Venice',
            'x_state': 'CA',
            'x_zip': '90291',
            'x_country': 'US',
        })
        params = self.api._add_params({},
            credit_card=self.credit_card, address=self.address)
        self.assertEqual(params, {
            'x_card_num': '4111111111111111',
            'x_exp_date': '01-{0}'.format(self.year),
            'x_card_code': '911',
            'x_address': '45 Rose Ave',
            'x_city': 'Venice',
            'x_state': 'CA',
            'x_zip': '90291',
            'x_country': 'US',
        })

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_auth(self, urlopen):
        urlopen.side_effect = self.success
        result = self.api.auth(20, self.credit_card, self.address)
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_zip=90291&x_card_num=4111111111111111&x_amount=20.00'
            '&x_tran_key=456&x_city=Venice&x_country=US&x_version=3.1'
            '&x_state=CA&x_delim_char=%3B&x_address=45+Rose+Ave'
            '&x_exp_date=01-{0}&x_test_request=FALSE&x_card_code=911'
            '&x_type=AUTH_ONLY&x_delim_data=TRUE'.format(str(self.year))))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_capture(self, urlopen):
        urlopen.side_effect = self.success
        result = self.api.capture(20, self.credit_card, self.address)
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_zip=90291&x_card_num=4111111111111111&x_amount=20.00'
            '&x_tran_key=456&x_city=Venice&x_country=US&x_version=3.1'
            '&x_state=CA&x_delim_char=%3B&x_address=45+Rose+Ave'
            '&x_exp_date=01-{0}&x_test_request=FALSE&x_card_code=911'
            '&x_type=AUTH_CAPTURE&x_delim_data=TRUE'.format(str(self.year))))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_settle(self, urlopen):
        urlopen.side_effect = self.success

        # Test without specified amount
        result = self.api.settle('123456')
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_trans_id=123456&x_version=3.1&x_delim_char=%3B'
            '&x_type=PRIOR_AUTH_CAPTURE&x_delim_data=TRUE&x_tran_key=456'
            '&x_test_request=FALSE'))
        self.assertEqual(result, PARSED_SUCCESS)

        # Test with specified amount
        result = self.api.settle('123456', amount=10)
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_trans_id=123456&x_version=3.1&x_delim_char=%3B'
            '&x_type=PRIOR_AUTH_CAPTURE&x_amount=10.00&x_delim_data=TRUE'
            '&x_tran_key=456&x_test_request=FALSE'))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_credit(self, urlopen):
        urlopen.side_effect = self.success

        # Test with transaction_id, amount
        result = self.api.credit('1111', '123456', 10)
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_trans_id=123456&x_version=3.1&x_amount=10.00&x_delim_char=%3B'
            '&x_type=CREDIT&x_card_num=1111&x_delim_data=TRUE&x_tran_key=456'
            '&x_test_request=FALSE'))
        self.assertEqual(result, PARSED_SUCCESS)

    @mock.patch('authorize.apis.transaction.urllib.urlopen')
    def test_void(self, urlopen):
        urlopen.side_effect = self.success
        result = self.api.void('123456')
        self.assertEqual(URL(urlopen.call_args[0][0]),
            URL('https://test.authorize.net/gateway/transact.dll?x_login=123'
            '&x_trans_id=123456&x_version=3.1&x_delim_char=%3B&x_type=VOID'
            '&x_delim_data=TRUE&x_tran_key=456&x_test_request=FALSE'))
        self.assertEqual(result, PARSED_SUCCESS)

########NEW FILE########
__FILENAME__ = test_client
from datetime import date

import mock
from unittest2 import TestCase

from authorize import Address, AuthorizeClient, CreditCard
from authorize.client import AuthorizeCreditCard, AuthorizeRecurring, \
    AuthorizeSavedCard, AuthorizeTransaction
from test_api_customer import PROFILE


TRANSACTION_RESULT = {
    'cvv_response': 'P',
    'authorization_code': 'IKRAGJ',
    'response_code': '1',
    'amount': '20.00',
    'transaction_type': 'auth_only',
    'avs_response': 'Y',
    'response_reason_code': '1',
    'response_reason_text': 'This transaction has been approved.',
    'transaction_id': '2171062816',
}

class ClientTests(TestCase):
    def setUp(self):
        self.transaction_api_patcher = mock.patch(
            'authorize.client.TransactionAPI')
        self.transaction_api = self.transaction_api_patcher.start()
        self.customer_api_patcher = mock.patch(
            'authorize.client.CustomerAPI')
        self.customer_api = self.customer_api_patcher.start()
        self.recurring_api_patcher = mock.patch(
            'authorize.client.RecurringAPI')
        self.recurring_api = self.recurring_api_patcher.start()
        self.client = AuthorizeClient('123', '456')
        self.year = date.today().year + 10
        self.credit_card = CreditCard('4111111111111111', self.year, 1, '911',
            'Jeff', 'Schenck')
        self.address = Address('45 Rose Ave', 'Venice', 'CA', '90291')

    def tearDown(self):
        self.transaction_api_patcher.stop()
        self.customer_api_patcher.stop()
        self.recurring_api_patcher.stop()

    def test_basic_authorize_client(self):
        self.transaction_api.reset_mock()
        self.customer_api.reset_mock()
        self.recurring_api.reset_mock()
        self.assertEqual(self.transaction_api.call_args, None)
        self.assertEqual(self.customer_api.call_args, None)
        self.assertEqual(self.recurring_api.call_args, None)
        client = AuthorizeClient('123', '456', False, False)
        self.assertEqual(self.transaction_api.call_args,
            (('123', '456', False, False), {}))
        self.assertEqual(self.customer_api.call_args,
            (('123', '456', False, False), {}))
        self.assertEqual(self.recurring_api.call_args,
            (('123', '456', False, False), {}))

    def test_authorize_client_payment_creators(self):
        self.assertTrue(isinstance(
            self.client.card(self.credit_card), AuthorizeCreditCard))
        self.assertTrue(isinstance(
            self.client.card(self.credit_card, self.address),
            AuthorizeCreditCard))
        self.assertTrue(isinstance(
            self.client.transaction('123'), AuthorizeTransaction))
        self.assertTrue(isinstance(
            self.client.saved_card('123|456'), AuthorizeSavedCard))
        self.assertTrue(isinstance(
            self.client.recurring('123'), AuthorizeRecurring))

    def test_authorize_credit_card_basic(self):
        card = AuthorizeCreditCard(self.client, self.credit_card)
        card = AuthorizeCreditCard(self.client, self.credit_card,
            self.address)
        repr(card)

    def test_authorize_credit_card_auth(self):
        self.client._transaction.auth.return_value = TRANSACTION_RESULT
        card = AuthorizeCreditCard(self.client, self.credit_card)
        result = card.auth(10)
        self.assertEqual(self.client._transaction.auth.call_args,
            ((10, self.credit_card, None, None), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')
        self.assertEqual(result.full_response, TRANSACTION_RESULT)

    def test_authorize_credit_card_capture(self):
        self.client._transaction.capture.return_value = TRANSACTION_RESULT
        card = AuthorizeCreditCard(self.client, self.credit_card)
        result = card.capture(10)
        self.assertEqual(self.client._transaction.capture.call_args,
            ((10, self.credit_card, None, None), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')
        self.assertEqual(result.full_response, TRANSACTION_RESULT)

    def test_authorize_credit_card_save(self):
        self.client._customer.create_saved_profile.return_value = ('1', '2')
        card = AuthorizeCreditCard(self.client, self.credit_card)
        result = card.save()
        self.assertEqual(self.client._customer.create_saved_payment.call_args,
            ((self.credit_card,), {'address': None}))
        self.assertTrue(isinstance(
            self.client._customer.create_saved_profile.call_args[0][0], str))
        self.assertTrue(isinstance(
            self.client._customer.create_saved_profile.call_args[0][1], list))
        self.assertTrue(isinstance(result, AuthorizeSavedCard))
        self.assertEqual(result.uid, '1|2')

    def test_authorize_credit_card_recurring(self):
        self.client._recurring.create_subscription.return_value = '1'
        card = AuthorizeCreditCard(self.client, self.credit_card)
        today = date.today()
        result = card.recurring(10, today, months=1)
        self.assertEqual(self.client._recurring.create_subscription.call_args,
            ((self.credit_card, 10, today), {'days': None, 'months': 1,
            'occurrences': None, 'trial_amount': None,
            'trial_occurrences': None}))
        self.assertTrue(isinstance(result, AuthorizeRecurring))
        self.assertEqual(result.uid, '1')

    def test_authorize_transaction_basic(self):
        transaction = AuthorizeTransaction(self.client, '123')
        repr(transaction)

    def test_authorize_transaction_settle(self):
        self.client._transaction.settle.return_value = TRANSACTION_RESULT
        transaction = AuthorizeTransaction(self.client, '123')

        # Test without amount
        result = transaction.settle()
        self.assertEqual(self.client._transaction.settle.call_args,
            (('123',), {'amount': None}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

        # Test with amount
        result = transaction.settle(10)
        self.assertEqual(self.client._transaction.settle.call_args,
            (('123',), {'amount': 10}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

    def test_authorize_transaction_credit(self):
        self.client._transaction.credit.return_value = TRANSACTION_RESULT
        transaction = AuthorizeTransaction(self.client, '123')

        # Test with amount
        result = transaction.credit('1111', 10)
        self.assertEqual(self.client._transaction.credit.call_args,
            (('1111', '123', 10), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

    def test_authorize_transaction_void(self):
        self.client._transaction.void.return_value = TRANSACTION_RESULT
        transaction = AuthorizeTransaction(self.client, '123')
        result = transaction.void()
        self.assertEqual(self.client._transaction.void.call_args,
            (('123',), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

    def test_authorize_saved_card_basic(self):
        saved = AuthorizeSavedCard(self.client, '1|2')
        repr(saved)

    def test_authorize_saved_card_auth(self):
        self.client._customer.auth.return_value = TRANSACTION_RESULT
        saved = AuthorizeSavedCard(self.client, '1|2')
        result = saved.auth(10)
        self.assertEqual(self.client._customer.auth.call_args,
            (('1', '2', 10), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

    def test_authorize_saved_card_capture(self):
        self.client._customer.capture.return_value = TRANSACTION_RESULT
        saved = AuthorizeSavedCard(self.client, '1|2')
        result = saved.capture(10)
        self.assertEqual(self.client._customer.capture.call_args,
            (('1', '2', 10), {}))
        self.assertTrue(isinstance(result, AuthorizeTransaction))
        self.assertEqual(result.uid, '2171062816')

    def test_authorize_saved_card_get_payment_info(self):
        address = Address('45 Rose Ave', 'Venice', 'CA', '90291')
        result_dict = {
            'first_name': 'Jeff', 'last_name': 'Shenck', 'address': address,
            'payment': PROFILE}
        self.client._customer.retrieve_saved_payment.return_value = result_dict
        saved = AuthorizeSavedCard(self.client, '1|2')
        result = saved.get_payment_info()

        self.assertEqual(result['first_name'], result_dict['first_name'])
        self.assertEqual(result['last_name'], result_dict['last_name'])
        self.assertEqual(
            result['address'].street, result_dict['address'].street)

    def test_authorized_saved_card_update(self):
        address = Address('45 Rose Ave', 'Venice', 'CA', '90291')
        result_dict = {
            'first_name': 'Jeff', 'last_name': 'Shenck', 'address': address,
            'payment': PROFILE}
        self.client._customer.retrieve_saved_payment.return_value = result_dict
        self.client._customer.update_saved_payment.return_value = None
        saved = AuthorizeSavedCard(self.client, '1|2')
        saved.update(address=address)

    def test_authorize_saved_card_delete(self):
        saved = AuthorizeSavedCard(self.client, '1|2')
        result = saved.delete()
        self.assertEqual(self.client._customer.delete_saved_payment.call_args,
            (('1', '2'), {}))

    def test_authorize_recurring_basic(self):
        recurring = AuthorizeRecurring(self.client, '123')
        repr(recurring)

    def test_authorize_recurring_update(self):
        recurring = AuthorizeRecurring(self.client, '123')
        recurring.update(occurrences=20)
        self.assertEqual(self.client._recurring.update_subscription.call_args,
            (('123',), {'amount': None, 'start': None, 'occurrences': 20,
            'trial_amount': None, 'trial_occurrences': None}))

    def test_authorize_recurring_delete(self):
        recurring = AuthorizeRecurring(self.client, '123')
        recurring.delete()
        self.assertEqual(self.client._recurring.delete_subscription.call_args,
            (('123',), {}))

########NEW FILE########
__FILENAME__ = test_data
from datetime import date, datetime, timedelta

from unittest2 import TestCase

from authorize.data import Address, CreditCard
from authorize.exceptions import AuthorizeInvalidError


TEST_CARD_NUMBERS = [
    ('amex', '370000000000002'),
    ('mc', '5555555555554444'),
    ('mc', '5105105105105100'),
    ('discover', '6011000000000012'),
    ('visa', '4007000000027'),
    ('visa', '4012888818888'),
    ('diners', '38000000000006'),
]

class CreditCardTests(TestCase):
    def setUp(self):
        self.YEAR = date.today().year + 10

    def test_basic_credit_card(self):
        credit_card = CreditCard('4111-1111-1111-1111', self.YEAR, 1, '911')
        repr(credit_card)

    def test_credit_card_validation(self):
        # Expiration in the past fails
        expired = date.today() - timedelta(days=31)
        self.assertRaises(AuthorizeInvalidError, CreditCard,
            '4111111111111111', expired.year, expired.month, '911')

        # CVV in wrong format fails
        self.assertRaises(AuthorizeInvalidError, CreditCard,
            '4111111111111111', self.YEAR, 1, 'incorrect')

        # Invalid credit card number fails
        self.assertRaises(AuthorizeInvalidError, CreditCard,
            '4111111111111112', self.YEAR, 1, '911')

        # Test standard test credit card numbers that should validate
        for card_type, card_number in TEST_CARD_NUMBERS:
            CreditCard(card_number, self.YEAR, 1, '911')

    def test_credit_card_type_detection(self):
        for card_type, card_number in TEST_CARD_NUMBERS:
            credit_card = CreditCard(card_number, self.YEAR, 1, '911')
            self.assertEqual(credit_card.card_type, card_type)

    def test_credit_card_expiration(self):
        credit_card = CreditCard('4111111111111111', self.YEAR, 1, '911')
        self.assertEqual(credit_card.expiration,
            datetime(self.YEAR, 1, 31, 23, 59, 59))

    def test_credit_card_safe_number(self):
        credit_card = CreditCard('4111111111111111', self.YEAR, 1, '911')
        self.assertEqual(credit_card.safe_number, '************1111')


class AddressTests(TestCase):
    def test_basic_address(self):
        address = Address('45 Rose Ave', 'Venice', 'CA', '90291')
        repr(address)

########NEW FILE########
__FILENAME__ = test_live
"""
Tests against the sandbox Authorize.net API. Slow, requires internet.
"""

from datetime import date, timedelta
import os
import random

from unittest2 import skipUnless, TestCase

from authorize import Address, AuthorizeClient, CreditCard
from authorize.exceptions import AuthorizeResponseError


# Authorize.net developer login for test (https://test.authorize.net)
# user: authorizepy0
# pass: LZ5MMGpr
# gateway id: 355553

SKIP_MESSAGE = 'Live tests only run if the AUTHORIZE_LIVE_TESTS ' \
    'environment variable is true.'
TEST_LOGIN_ID = '285tUPuS'
TEST_TRANSACTION_KEY = '58JKJ4T95uee75wd'

@skipUnless(os.environ.get('AUTHORIZE_LIVE_TESTS'), SKIP_MESSAGE)
class AuthorizeLiveTests(TestCase):
    def setUp(self):
        # Random in testing feels gross, otherwise running the same test
        # suite in quick succession produces failures because Authorize.net
        # thinks the transactions are duplicates and rejects them
        self.amount1 = random.randrange(100, 100000) / 100.0
        self.amount2 = random.randrange(100, 100000) / 100.0
        self.client = AuthorizeClient(TEST_LOGIN_ID, TEST_TRANSACTION_KEY)
        self.year = date.today().year + 10
        self.credit_card = CreditCard('4111111111111111', self.year, 1, '911',
            'Jeff', 'Schenck')
        self.address = Address('45 Rose Ave', 'Venice', 'CA', '90291')

    def test_credit_card(self):
        card = self.client.card(self.credit_card, self.address)
        transaction = card.auth(self.amount1)
        transaction.void()
        self.assertRaises(AuthorizeResponseError, transaction.settle)

    def test_saved_card(self):
        card = self.client.card(self.credit_card, self.address)
        saved = card.save()
        saved.auth(self.amount1).settle()
        saved.capture(self.amount1)
        saved_from_id = self.client.saved_card(saved.uid)
        saved_from_id.delete()

    def test_get_saved_card_info(self):
        card = self.client.card(self.credit_card, self.address)
        saved = card.save()
        results = saved.get_payment_info()
        self.assertEqual(results['address'].street, self.address.street)
        self.assertEqual(results['first_name'], self.credit_card.first_name)
        saved.delete()

    def test_update_card_info(self):
        card = self.client.card(self.credit_card, self.address)
        saved = card.save()
        saved.update(first_name='NotJeff')
        info = saved.get_payment_info()
        self.assertEqual(info['first_name'], 'NotJeff')
        self.assertEqual(info['last_name'], 'Schenck')
        saved.delete()

    def test_recurring(self):
        card = self.client.card(self.credit_card, self.address)
        start = date.today() + timedelta(days=7)
        recurring = card.recurring(self.amount1, start, months=1, occurrences=10)
        recurring.update(amount=self.amount2, trial_amount=self.amount2 - 0.5, trial_occurrences=3)
        recurring_from_id = self.client.recurring(recurring.uid)
        recurring_from_id.delete()

########NEW FILE########
