__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Restless documentation build configuration file, created by
# sphinx-quickstart on Fri Mar  2 00:35:49 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']
extensions += ['sphinxcontrib.httpdomain']
extensions += ['sphinxcontrib.issuetracker']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Restless'
copyright = u'2012 Jeffrey Finkelstein'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
#version = '0.3'
# The full version, including alpha/beta/rc tags.
#release = '0.3-dev'
import pkg_resources
try:
    release = pkg_resources.get_distribution('Flask-Restless').version
except pkg_resources.DistributionNotFound:
    print 'To build the documentation, the distribution information of'
    print 'Flask-Restless has to be available.  Either install the package'
    print 'into your development environment or run "setup.py develop"'
    print 'to setup the metadata.  A virtualenv is recommended!'
    sys.exit(1)
del pkg_resources

if 'dev' in release:
    release = release.split('dev')[0] + 'dev'
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'
pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'default'
html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'index_logo':       'flask-restless.png'
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
                 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Restlessdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Restless.tex', u'Flask-Restless Documentation',
   u'Jeffrey Finkelstein', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
latex_domain_indices = False

# If false, no module index is generated.
latex_use_modindex = False

latex_elements = {
    'fontpkg':      r'\usepackage{mathpazo}',
    'papersize':    'a4paper',
    'pointsize':    '12pt',
    'preamble':     r'\usepackage{flaskstyle}'
}
latex_use_parts = True

latex_additional_files = ['flaskstyle.sty', 'logo.png']


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-restless', u'Flask-Restless Documentation',
     [u'Jeffrey Finkelstein'], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'python': ('http://docs.python.org/', None),
                       'flask': ('http://flask.pocoo.org/docs', None),
                       'sqlalchemy': ('http://sqlalchemy.org/docs', None),
                       'flasksqlalchemy':
                           ('http://packages.python.org/Flask-SQLAlchemy',
                            None),
                       'flasklogin':
                           ('https://flask-login.readthedocs.org/en/latest',
                            None)}

# fall back if theme is not there
try:
    __import__('flask_theme_support')
except ImportError, e:
    print '-' * 74
    print 'Warning: Flask themes unavailable.  Building with default theme'
    print 'If you want the Flask themes, run this command and build again:'
    print
    print '  git submodule update --init'
    print '-' * 74

    pygments_style = 'tango'
    html_theme = 'default'
    html_theme_options = {}

# Configuration for issuetracker extension.
issuetracker = 'github'
issuetracker_project = 'jfinkels/flask-restless'

########NEW FILE########
__FILENAME__ = __main__
"""
    Using Flask-Restless with jQuery
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This provides a simple example of using Flask-Restless on the server to
    create ReSTful API endpoints and [jQuery][0] on the client to make API
    requests.

    This requires the following Python libraries to be installed:

    * Flask
    * Flask-Restless
    * Flask-SQLAlchemy

    To install them using ``pip``, do::

        pip install Flask Flask-SQLAlchemy Flask-Restless

    To use this example, run this package from the command-line. If you are
    using Python 2.7 or later::

        python -m jquery

    If you are using Python 2.6 or earlier::

        python -m jquery.__main__

    To view the example in action, direct your web browser to
    ``http://localhost:5000``. You must have JavaScript enabled in your web
    browser for this example to work.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import os
import os.path

from flask import Flask, render_template
from flask.ext.restless import APIManager
from flask.ext.sqlalchemy import SQLAlchemy

# Step 0: the database in this example is at './test.sqlite'.
DATABASE = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                        'test.sqlite')
if os.path.exists(DATABASE):
    os.unlink(DATABASE)

# Step 1: setup the Flask application.
app = Flask(__name__)
app.config['DEBUG'] = True
app.config['TESTING'] = True
app.config['SECRET_KEY'] = os.urandom(24)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///%s' % DATABASE

# Step 2: initialize extensions.
db = SQLAlchemy(app)
api_manager = APIManager(app, flask_sqlalchemy_db=db)


# Step 3: create the database model.
class Person(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode)


# Step 4: create the database and add some test people.
db.create_all()
for i in range(1, 10):
    person = Person(name=u'person' + unicode(i))
    db.session.add(person)
db.session.commit()
print Person.query.all()

# Step 5: create endpoints for the application.
@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

# Step 6: create the API endpoints.
api_manager.create_api(Person, methods=['GET'])

# Step 7: run the application.
app.run()

########NEW FILE########
__FILENAME__ = requests_client
"""
    Using Flask-Restless with the "requests" library
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This provides an example of using Flask-Restless on the server side to
    provide a ReSTful API and the Python `requests
    <http://docs.python-requests.org/en/latest/>`_ library on the client side
    to make HTTP requests to the server.

    To install the requests library::

        pip install "requests>1.0.3"

    (If you have ``requests`` version less then 1.0.3, just change the code
    below from ``requests.json()`` to ``requests.json``).

    Before executing the code in this module, you must first run the quickstart
    server example from this directory (that is, the ``examples/`` directory)::

        PYTHONPATH=.. python quickstart.py

    Now run this script from this directory to see some example requests using
    the ``requests`` library::

        python requests_client.py

    Remember, the client must specify the ``application/json`` MIME type when
    sending requests.

    :copyright: 2013 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import json
import requests

url = 'http://127.0.0.1:5000/api/person'
headers = {'Content-Type': 'application/json'}

# Make a POST request to create an object in the database.
data = dict(name='Jeffrey', birth_date='1-2-1923')
response = requests.post(url, data=json.dumps(data), headers=headers)
assert response.status_code == 201

# Make a GET request for the entire collection.
response = requests.get(url, headers=headers)
assert response.status_code == 200
print(response.json())

# Make a GET request for an individual instance of the model.
response = requests.get(url + '/1', headers=headers)
assert response.status_code == 200
print(response.json())

# Use query parameters to make a search. Make sure to convert the value of `q`
# to a string.
filters = [dict(name='name', op='like', val='%y%')]
params = dict(q=json.dumps(dict(filters=filters)))
response = requests.get(url, params=params, headers=headers)
assert response.status_code == 200
print(response.json())

########NEW FILE########
__FILENAME__ = quickstart
import flask
import flask.ext.sqlalchemy
import flask.ext.restless

# Create the Flask application and the Flask-SQLAlchemy object.
app = flask.Flask(__name__)
app.config['DEBUG'] = True
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'
db = flask.ext.sqlalchemy.SQLAlchemy(app)

# Create your Flask-SQLALchemy models as usual but with the following two
# (reasonable) restrictions:
#   1. They must have a primary key column of type sqlalchemy.Integer or
#      type sqlalchemy.Unicode.
#   2. They must have an __init__ method which accepts keyword arguments for
#      all columns (the constructor in flask.ext.sqlalchemy.SQLAlchemy.Model
#      supplies such a method, so you don't need to declare a new one).
class Person(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode, unique=True)
    birth_date = db.Column(db.Date)


class Computer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode, unique=True)
    vendor = db.Column(db.Unicode)
    purchase_time = db.Column(db.DateTime)
    owner_id = db.Column(db.Integer, db.ForeignKey('person.id'))
    owner = db.relationship('Person', backref=db.backref('computers',
                                                         lazy='dynamic'))


# Create the database tables.
db.create_all()

# Create the Flask-Restless API manager.
manager = flask.ext.restless.APIManager(app, flask_sqlalchemy_db=db)

# Create API endpoints, which will be available at /api/<tablename> by
# default. Allowed HTTP methods can be specified as well.
manager.create_api(Person, methods=['GET', 'POST', 'DELETE'])
manager.create_api(Computer, methods=['GET'])

# start the flask loop
app.run()

########NEW FILE########
__FILENAME__ = __main__
"""
    Authentication example using Flask-Login
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This provides a simple example of using Flask-Login as the authentication
    framework which can guard access to certain API endpoints.

    This requires the following Python libraries to be installed:

    * Flask
    * Flask-Login
    * Flask-Restless
    * Flask-SQLAlchemy
    * Flask-WTF

    To install them using ``pip``, do::

        pip install Flask Flask-SQLAlchemy Flask-Restless Flask-Login Flask-WTF

    To use this example, run this package from the command-line. If you are
    using Python 2.7 or later::

        python -m authentication

    If you are using Python 2.6 or earlier::

        python -m authentication.__main__

    Attempts to access the URL of the API for the :class:`User` class at
    ``http://localhost:5000/api/user`` will fail with an :http:statuscode:`401`
    because you have not yet logged in. To log in, visit
    ``http://localhost:5000/login`` and login with username ``example`` and
    password ``example``. Once you have successfully logged in, you may now
    make :http:get:`http://localhost:5000/api/user` requests.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import os
import os.path

from flask import Flask, render_template, redirect, url_for
from flask.ext.login import current_user, login_user, LoginManager, UserMixin
from flask.ext.restless import APIManager, ProcessingException, NO_CHANGE
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.wtf import PasswordField, SubmitField, TextField, Form

# Step 0: the database in this example is at './test.sqlite'.
DATABASE = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                        'test.sqlite')
if os.path.exists(DATABASE):
    os.unlink(DATABASE)

# Step 1: setup the Flask application.
app = Flask(__name__)
app.config['DEBUG'] = True
app.config['TESTING'] = True
app.config['SECRET_KEY'] = os.urandom(24)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///%s' % DATABASE

# Step 2: initialize extensions.
db = SQLAlchemy(app)
api_manager = APIManager(app, flask_sqlalchemy_db=db)
login_manager = LoginManager()
login_manager.setup_app(app)


# Step 3: create the user database model.
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.Unicode)
    password = db.Column(db.Unicode)


# Step 4: create the database and add a test user.
db.create_all()
user1 = User(username=u'example', password=u'example')
db.session.add(user1)
db.session.commit()


# Step 5: this is required for Flask-Login.
@login_manager.user_loader
def load_user(userid):
    return User.query.get(userid)


# Step 6: create the login form.
class LoginForm(Form):
    username = TextField('username')
    password = PasswordField('password')
    submit = SubmitField('Login')


# Step 7: create endpoints for the application, one for index and one for login
@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        #
        # you would check username and password here...
        #
        username, password = form.username.data, form.password.data
        matches = User.query.filter_by(username=username,
                                       password=password).all()
        if len(matches) > 0:
            login_user(matches[0])
            return redirect(url_for('index'))
        flash('Username and password pair not found')
    return render_template('login.html', form=form)


# Step 8: create the API for User with the authentication guard.
def auth_func(**kw):
    if not current_user.is_authenticated():
        raise ProcessingException(description='Not Authorized', code=401)


api_manager.create_api(User, preprocessors=dict(GET_SINGLE=[auth_func],
                                                GET_MANY=[auth_func]))

# Step 9: configure and run the application
app.run()

# Step 10: visit http://localhost:5000/api/user in a Web browser. You will
# receive a "Not Authorized" response.
#
# Step 11: visit http://localhost:5000/login and enter username "example" and
# password "example". You will then be logged in.
#
# Step 12: visit http://localhost:5000/api/user again. This time you will get a
# response showing the objects in the User table of the database.

########NEW FILE########
__FILENAME__ = separate_endpoints
"""
    Separate URLs example
    ~~~~~~~~~~~~~~~~~~~~~

    This provides an example of creating separate API endpoints for different
    HTTP methods.

    You can read from the database by making a
    :http:get:`http://localhost:5000/get/person` request, add a new person
    using :http:get:`http://localhost:5000/add/person`, etc.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import flask
import flask.ext.sqlalchemy
import flask.ext.restless

# Create the Flask application and the Flask-SQLAlchemy object.
app = flask.Flask(__name__)
app.config['DEBUG'] = True
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db'
db = flask.ext.sqlalchemy.SQLAlchemy(app)

# Create your Flask-SQLALchemy models as usual but with the following two
# (reasonable) restrictions:
#   1. They must have a primary key column of type sqlalchemy.Integer or
#      type sqlalchemy.Unicode.
#   2. They must have an __init__ method which accepts keyword arguments for
#      all columns (the constructor in flask.ext.sqlalchemy.SQLAlchemy.Model
#      supplies such a method, so you don't need to declare a new one).
class Person(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode, unique=True)
    birth_date = db.Column(db.Date)


class Computer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Unicode, unique=True)
    vendor = db.Column(db.Unicode)
    purchase_time = db.Column(db.DateTime)
    owner_id = db.Column(db.Integer, db.ForeignKey('person.id'))
    owner = db.relationship('Person', backref=db.backref('computers',
                                                         lazy='dynamic'))


# Create the database tables.
db.create_all()

# Create the Flask-Restless API manager.
manager = flask.ext.restless.APIManager(app, flask_sqlalchemy_db=db)

# Create API endpoints, each at a different URL and with different allowed HTTP
# methods, but which all affect the Person model.
manager.create_api(Person, methods=['GET'], url_prefix='/get')
manager.create_api(Person, methods=['POST'], url_prefix='/add')
manager.create_api(Person, methods=['PATCH'], url_prefix='/update')
manager.create_api(Person, methods=['DELETE'], url_prefix='/remove')

# start the flask loop
app.run()

########NEW FILE########
__FILENAME__ = helpers
"""
    flask.ext.restless.helpers
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Helper functions for Flask-Restless.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import datetime
import inspect
import uuid

from dateutil.parser import parse as parse_datetime
from sqlalchemy import Date
from sqlalchemy import DateTime
from sqlalchemy import Interval
from sqlalchemy.exc import NoInspectionAvailable
from sqlalchemy.exc import OperationalError
from sqlalchemy.ext.associationproxy import AssociationProxy
from sqlalchemy.ext import hybrid
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import ColumnProperty
from sqlalchemy.orm import RelationshipProperty as RelProperty
from sqlalchemy.orm.attributes import InstrumentedAttribute
from sqlalchemy.orm.attributes import QueryableAttribute
from sqlalchemy.orm.query import Query
from sqlalchemy.sql import func
from sqlalchemy.sql.expression import _BinaryExpression
from sqlalchemy.sql.expression import ColumnElement
from sqlalchemy.inspection import inspect as sqlalchemy_inspect

#: Names of attributes which should definitely not be considered relations when
#: dynamically computing a list of relations of a SQLAlchemy model.
RELATION_BLACKLIST = ('query', 'query_class', '_sa_class_manager',
                      '_decl_class_registry')


#: Names of columns which should definitely not be considered user columns to
#: be included in a dictionary representation of a model.
COLUMN_BLACKLIST = ('_sa_polymorphic_on', )

#: Types which should be considered columns of a model when iterating over all
#: attributes of a model class.
COLUMN_TYPES = (InstrumentedAttribute, hybrid_property)

#: Strings which, when received by the server as the value of a date or time
#: field, indicate that the server should use the current time when setting the
#: value of the field.
CURRENT_TIME_MARKERS = ('CURRENT_TIMESTAMP', 'CURRENT_DATE', 'LOCALTIMESTAMP')


def partition(l, condition):
    """Returns a pair of lists, the left one containing all elements of `l` for
    which `condition` is ``True`` and the right one containing all elements of
    `l` for which `condition` is ``False``.

    `condition` is a function that takes a single argument (each individual
    element of the list `l`) and returns either ``True`` or ``False``.

    """
    return [x for x in l if condition(x)], [x for x in l if not condition(x)]


def session_query(session, model):
    """Returns a SQLAlchemy query object for the specified `model`.

    If `model` has a ``query`` attribute already, ``model.query`` will be
    returned. If the ``query`` attribute is callable ``model.query()`` will be
    returned instead.

    If `model` has no such attribute, a query based on `session` will be
    created and returned.

    """
    if hasattr(model, 'query'):
        if callable(model.query):
            return model.query()
        return model.query
    return session.query(model)


def upper_keys(d):
    """Returns a new dictionary with the keys of `d` converted to upper case
    and the values left unchanged.

    """
    return dict(zip((k.upper() for k in d.keys()), d.values()))


def get_columns(model):
    """Returns a dictionary-like object containing all the columns of the
    specified `model` class.

    This includes `hybrid attributes`_.

    .. _hybrid attributes: http://docs.sqlalchemy.org/en/latest/orm/extensions/hybrid.html

    """
    columns = {}
    for superclass in model.__mro__:
        for name, column in superclass.__dict__.items():
            if isinstance(column, COLUMN_TYPES):
                columns[name] = column
    return columns


def get_relations(model):
    """Returns a list of relation names of `model` (as a list of strings)."""
    return [k for k in dir(model)
            if not (k.startswith('__') or k in RELATION_BLACKLIST)
            and get_related_model(model, k)]


def get_related_model(model, relationname):
    """Gets the class of the model to which `model` is related by the attribute
    whose name is `relationname`.

    """
    cols = model._sa_class_manager
    attr = getattr(model, relationname)
    if relationname in cols and isinstance(attr.property, RelProperty):
        return cols[relationname].property.mapper.class_
    if isinstance(attr, AssociationProxy):
        return get_related_association_proxy_model(attr)
    return None


def get_related_association_proxy_model(attr):
    """Returns the model class specified by the given SQLAlchemy relation
    attribute, or ``None`` if no such class can be inferred.

    `attr` must be a relation attribute corresponding to an association proxy.

    """
    prop = attr.remote_attr.property
    for attribute in ('mapper', 'parent'):
        if hasattr(prop, attribute):
            return getattr(prop, attribute).class_
    return None


def has_field(model, fieldname):
    """Returns ``True`` if the `model` has the specified field, and it is not
    a hybrid property.

    """
    return (hasattr(model, fieldname) and
            not isinstance(getattr(model, fieldname), _BinaryExpression))


def get_field_type(model, fieldname):
    """Helper which returns the SQLAlchemy type of the field.
    """
    field = getattr(model, fieldname)
    if isinstance(field, ColumnElement):
        fieldtype = field.type
    else:
        if isinstance(field, AssociationProxy):
            field = field.remote_attr
        if hasattr(field, 'property'):
            prop = field.property
            if isinstance(prop, RelProperty):
                return None
            fieldtype = prop.columns[0].type
        else:
            return None
    return fieldtype


def is_date_field(model, fieldname):
    """Returns ``True`` if and only if the field of `model` with the specified
    name corresponds to either a :class:`datetime.date` object or a
    :class:`datetime.datetime` object.
    """
    fieldtype = get_field_type(model, fieldname)
    return isinstance(fieldtype, Date) or isinstance(fieldtype, DateTime)


def is_interval_field(model, fieldname):
    """Returns ``True`` if and only if the field of `model` with the specified
    name corresponds to a :class:`datetime.timedelta` object.
    """
    fieldtype = get_field_type(model, fieldname)
    return isinstance(fieldtype, Interval)


def assign_attributes(model, **kwargs):
    """Assign all attributes from the supplied `kwargs` dictionary to the
    model. This does the same thing as the default declarative constructor,
    when provided a dictionary of attributes and values.

    """
    cls = type(model)
    for field, value in kwargs.items():
        if not hasattr(cls, field):
            msg = '{0} has no field named "{1!r}"'.format(cls.__name__, field)
            raise TypeError(msg)
        setattr(model, field, value)


def primary_key_names(model):
    """Returns all the primary keys for a model."""
    return [key for key, field in inspect.getmembers(model)
            if isinstance(field, QueryableAttribute)
            and isinstance(field.property, ColumnProperty)
            and field.property.columns[0].primary_key]


def primary_key_name(model_or_instance):
    """Returns the name of the primary key of the specified model or instance
    of a model, as a string.

    If `model_or_instance` specifies multiple primary keys and ``'id'`` is one
    of them, ``'id'`` is returned. If `model_or_instance` specifies multiple
    primary keys and ``'id'`` is not one of them, only the name of the first
    one in the list of primary keys is returned.

    """
    its_a_model = isinstance(model_or_instance, type)
    model = model_or_instance if its_a_model else model_or_instance.__class__
    pk_names = primary_key_names(model)
    return 'id' if 'id' in pk_names else pk_names[0]


def is_like_list(instance, relation):
    """Returns ``True`` if and only if the relation of `instance` whose name is
    `relation` is list-like.

    A relation may be like a list if, for example, it is a non-lazy one-to-many
    relation, or it is a dynamically loaded one-to-many.

    """
    if relation in instance._sa_class_manager:
        return instance._sa_class_manager[relation].property.uselist
    related_value = getattr(type(instance), relation, None)
    if isinstance(related_value, AssociationProxy):
        local_prop = related_value.local_attr.prop
        if isinstance(local_prop, RelProperty):
            return local_prop.uselist
    return False


def is_mapped_class(cls):
    try:
        sqlalchemy_inspect(cls)
        return True
    except:
        return False


# This code was adapted from :meth:`elixir.entity.Entity.to_dict` and
# http://stackoverflow.com/q/1958219/108197.
def to_dict(instance, deep=None, exclude=None, include=None,
            exclude_relations=None, include_relations=None,
            include_methods=None):
    """Returns a dictionary representing the fields of the specified `instance`
    of a SQLAlchemy model.

    The returned dictionary is suitable as an argument to
    :func:`flask.jsonify`; :class:`datetime.date` and :class:`uuid.UUID`
    objects are converted to string representations, so no special JSON encoder
    behavior is required.

    `deep` is a dictionary containing a mapping from a relation name (for a
    relation of `instance`) to either a list or a dictionary. This is a
    recursive structure which represents the `deep` argument when calling
    :func:`!_to_dict` on related instances. When an empty list is encountered,
    :func:`!_to_dict` returns a list of the string representations of the
    related instances.

    If either `include` or `exclude` is not ``None``, exactly one of them must
    be specified. If both are not ``None``, then this function will raise a
    :exc:`ValueError`. `exclude` must be a list of strings specifying the
    columns which will *not* be present in the returned dictionary
    representation of the object (in other words, it is a
    blacklist). Similarly, `include` specifies the only columns which will be
    present in the returned dictionary (in other words, it is a whitelist).

    .. note::

       If `include` is an iterable of length zero (like the empty tuple or the
       empty list), then the returned dictionary will be empty. If `include` is
       ``None``, then the returned dictionary will include all columns not
       excluded by `exclude`.

    `include_relations` is a dictionary mapping strings representing relation
    fields on the specified `instance` to a list of strings representing the
    names of fields on the related model which should be included in the
    returned dictionary; `exclude_relations` is similar.

    `include_methods` is a list mapping strings to method names which will
    be called and their return values added to the returned dictionary.

    """
    if (exclude is not None or exclude_relations is not None) and \
            (include is not None or include_relations is not None):
        raise ValueError('Cannot specify both include and exclude.')
    # create a list of names of columns, including hybrid properties
    instance_type = type(instance)
    columns = []
    try:
        inspected_instance = sqlalchemy_inspect(instance_type)
        column_attrs = inspected_instance.column_attrs.keys()
        descriptors = inspected_instance.all_orm_descriptors.items()
        hybrid_columns = [k for k, d in descriptors
                          if d.extension_type == hybrid.HYBRID_PROPERTY]
        columns = column_attrs + hybrid_columns
    except NoInspectionAvailable:
        return instance
    # filter the columns based on exclude and include values
    if exclude is not None:
        columns = (c for c in columns if c not in exclude)
    elif include is not None:
        columns = (c for c in columns if c in include)
    # create a dictionary mapping column name to value
    result = dict((col, getattr(instance, col)) for col in columns
                  if not (col.startswith('__') or col in COLUMN_BLACKLIST))
    # add any included methods
    if include_methods is not None:
        result.update(dict((method, getattr(instance, method)())
                           for method in include_methods
                           if not '.' in method))
    # Check for objects in the dictionary that may not be serializable by
    # default. Convert datetime objects to ISO 8601 format, convert UUID
    # objects to hexadecimal strings, etc.
    for key, value in result.items():
        if isinstance(value, (datetime.date, datetime.time)):
            result[key] = value.isoformat()
        elif isinstance(value, uuid.UUID):
            result[key] = str(value)
        elif key not in column_attrs and is_mapped_class(type(value)):
            result[key] = to_dict(value)
    # recursively call _to_dict on each of the `deep` relations
    deep = deep or {}
    for relation, rdeep in deep.items():
        # Get the related value so we can see if it is None, a list, a query
        # (as specified by a dynamic relationship loader), or an actual
        # instance of a model.
        relatedvalue = getattr(instance, relation)
        if relatedvalue is None:
            result[relation] = None
            continue
        # Determine the included and excluded fields for the related model.
        newexclude = None
        newinclude = None
        if exclude_relations is not None and relation in exclude_relations:
            newexclude = exclude_relations[relation]
        elif (include_relations is not None and
              relation in include_relations):
            newinclude = include_relations[relation]
        # Determine the included methods for the related model.
        newmethods = None
        if include_methods is not None:
            newmethods = [method.split('.', 1)[1] for method in include_methods
                          if method.split('.', 1)[0] == relation]
        if is_like_list(instance, relation):
            result[relation] = [to_dict(inst, rdeep, exclude=newexclude,
                                        include=newinclude,
                                        include_methods=newmethods)
                                for inst in relatedvalue]
            continue
        # If the related value is dynamically loaded, resolve the query to get
        # the single instance.
        if isinstance(relatedvalue, Query):
            relatedvalue = relatedvalue.one()
        result[relation] = to_dict(relatedvalue, rdeep, exclude=newexclude,
                                   include=newinclude,
                                   include_methods=newmethods)
    return result


def evaluate_functions(session, model, functions):
    """Executes each of the SQLAlchemy functions specified in ``functions``, a
    list of dictionaries of the form described below, on the given model and
    returns a dictionary mapping function name (slightly modified, see below)
    to result of evaluation of that function.

    `session` is the SQLAlchemy session in which all database transactions will
    be performed.

    `model` is the SQLAlchemy model class on which the specified functions will
    be evaluated.

    ``functions`` is a list of dictionaries of the form::

        {'name': 'avg', 'field': 'amount'}

    For example, if you want the sum and the average of the field named
    "amount"::

        >>> # assume instances of Person exist in the database...
        >>> f1 = dict(name='sum', field='amount')
        >>> f2 = dict(name='avg', field='amount')
        >>> evaluate_functions(Person, [f1, f2])
        {'avg__amount': 456, 'sum__amount': 123}

    The return value is a dictionary mapping ``'<funcname>__<fieldname>'`` to
    the result of evaluating that function on that field. If `model` is
    ``None`` or `functions` is empty, this function returns the empty
    dictionary.

    If a field does not exist on a given model, :exc:`AttributeError` is
    raised. If a function does not exist,
    :exc:`sqlalchemy.exc.OperationalError` is raised. The former exception will
    have a ``field`` attribute which is the name of the field which does not
    exist. The latter exception will have a ``function`` attribute which is the
    name of the function with does not exist.

    """
    if not model or not functions:
        return {}
    processed = []
    funcnames = []
    for function in functions:
        funcname, fieldname = function['name'], function['field']
        # We retrieve the function by name from the SQLAlchemy ``func``
        # module and the field by name from the model class.
        #
        # If the specified field doesn't exist, this raises AttributeError.
        funcobj = getattr(func, funcname)
        try:
            field = getattr(model, fieldname)
        except AttributeError as exception:
            exception.field = fieldname
            raise exception
        # Time to store things to be executed. The processed list stores
        # functions that will be executed in the database and funcnames
        # contains names of the entries that will be returned to the
        # caller.
        funcnames.append('{0}__{1}'.format(funcname, fieldname))
        processed.append(funcobj(field))
    # Evaluate all the functions at once and get an iterable of results.
    try:
        evaluated = session.query(*processed).one()
    except OperationalError as exception:
        # HACK original error message is of the form:
        #
        #    '(OperationalError) no such function: bogusfuncname'
        original_error_msg = exception.args[0]
        bad_function = original_error_msg[37:]
        exception.function = bad_function
        raise exception
    return dict(zip(funcnames, evaluated))


def query_by_primary_key(session, model, primary_key_value, primary_key=None):
    """Returns a SQLAlchemy query object containing the result of querying
    `model` for instances whose primary key has the value `primary_key_value`.

    If `primary_key` is specified, the column specified by that string is used
    as the primary key column. Otherwise, the column named ``id`` is used.

    Presumably, the returned query should have at most one element.

    """
    pk_name = primary_key or primary_key_name(model)
    query = session_query(session, model)
    return query.filter(getattr(model, pk_name) == primary_key_value)


def get_by(session, model, primary_key_value, primary_key=None):
    """Returns the first instance of `model` whose primary key has the value
    `primary_key_value`, or ``None`` if no such instance exists.

    If `primary_key` is specified, the column specified by that string is used
    as the primary key column. Otherwise, the column named ``id`` is used.

    """
    result = query_by_primary_key(session, model, primary_key_value,
                                  primary_key)
    return result.first()


def get_or_create(session, model, attrs):
    """Returns the single instance of `model` whose primary key has the
    value found in `attrs`, or initializes a new instance if no primary key
    is specified.

    Before returning the new or existing instance, its attributes are
    assigned to the values supplied in the `attrs` dictionary.

    This method does not commit the changes made to the session; the
    calling function has that responsibility.

    """
    # Not a full relation, probably just an association proxy to a scalar
    # attribute on the remote model.
    if not isinstance(attrs, dict):
        return attrs
    # Recurse into nested relationships
    for rel in get_relations(model):
        if rel not in attrs:
            continue
        if isinstance(attrs[rel], list):
            attrs[rel] = [get_or_create(session, get_related_model(model, rel),
                                        r) for r in attrs[rel]]
        else:
            attrs[rel] = get_or_create(session, get_related_model(model, rel),
                                       attrs[rel])
    # Find private key names
    pk_names = primary_key_names(model)
    attrs = strings_to_dates(model, attrs)
    # If all of the primary keys were included in `attrs`, try to update
    # an existing row.
    if all(k in attrs for k in pk_names):
        # Determine the sub-dictionary of `attrs` which contains the mappings
        # for the primary keys.
        pk_values = dict((k, v) for (k, v) in attrs.items()
                         if k in pk_names)
        # query for an existing row which matches all the specified
        # primary key values.
        instance = session_query(session, model).filter_by(**pk_values).first()
        if instance is not None:
            assign_attributes(instance, **attrs)
            return instance
    # If some of the primary keys were missing, or the row wasn't found,
    # create a new row.
    return model(**attrs)


def strings_to_dates(model, dictionary):
    """Returns a new dictionary with all the mappings of `dictionary` but
    with date strings and intervals mapped to :class:`datetime.datetime` or
    :class:`datetime.timedelta` objects.

    The keys of `dictionary` are names of fields in the model specified in the
    constructor of this class. The values are values to set on these fields. If
    a field name corresponds to a field in the model which is a
    :class:`sqlalchemy.types.Date`, :class:`sqlalchemy.types.DateTime`, or
    :class:`sqlalchemy.Interval`, then the returned dictionary will have the
    corresponding :class:`datetime.datetime` or :class:`datetime.timedelta`
    Python object as the value of that mapping in place of the string.

    This function outputs a new dictionary; it does not modify the argument.

    """
    result = {}
    for fieldname, value in dictionary.items():
        if is_date_field(model, fieldname) and value is not None:
            if value.strip() == '':
                result[fieldname] = None
            elif value in CURRENT_TIME_MARKERS:
                result[fieldname] = getattr(func, value.lower())()
            else:
                result[fieldname] = parse_datetime(value)
        elif (is_interval_field(model, fieldname) and value is not None
              and isinstance(value, int)):
            result[fieldname] = datetime.timedelta(seconds=value)
        else:
            result[fieldname] = value
    return result


def count(session, query):
    """Returns the count of the specified `query`.

    This function employs an optimization that bypasses the
    :meth:`sqlalchemy.orm.Query.count` method, which can be very slow for large
    queries.

    """
    num_results = None
    if len(query.statement._froms) == 1:
        counts = query.statement.with_only_columns([func.count()])
        num_results = session.execute(counts.order_by(None)).scalar()
    return query.count() if num_results is None else num_results

########NEW FILE########
__FILENAME__ = manager
"""
    flask.ext.restless.manager
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Provides :class:`flask.ext.restless.manager.APIManager`, the class which
    users of Flask-Restless must instantiate to create ReSTful APIs for their
    database models.

    :copyright:2011 by Lincoln de Sousa <lincoln@comum.org>
    :copyright:2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from collections import defaultdict

from flask import Blueprint

from .views import API
from .views import FunctionAPI

#: The set of methods which are allowed by default when creating an API
READONLY_METHODS = frozenset(('GET', ))


class IllegalArgumentError(Exception):
    """This exception is raised when a calling function has provided illegal
    arguments to a function or method.

    """
    pass


class APIManager(object):
    """Provides a method for creating a public ReSTful JSON API with respect to
    a given :class:`~flask.Flask` application object.

    The :class:`~flask.Flask` object can be specified in the constructor, or
    after instantiation time by calling the :meth:`init_app` method. In any
    case, the application object must be specified before calling the
    :meth:`create_api` method.

    `app` is the :class:`flask.Flask` object containing the user's Flask
    application.

    `session` is the :class:`sqlalchemy.orm.session.Session` object in which
    changes to the database will be made.

    `flask_sqlalchemy_db` is the :class:`flask.ext.sqlalchemy.SQLAlchemy`
    object with which `app` has been registered and which contains the
    database models for which API endpoints will be created.

    If `flask_sqlalchemy_db` is not ``None``, `session` will be ignored.

    For example, to use this class with models defined in pure SQLAlchemy::

        from flask import Flask
        from flask.ext.restless import APIManager
        from sqlalchemy import create_engine
        from sqlalchemy.orm.session import sessionmaker

        engine = create_engine('sqlite:////tmp/mydb.sqlite')
        Session = sessionmaker(bind=engine)
        mysession = Session()
        app = Flask(__name__)
        apimanager = APIManager(app, session=mysession)

    and with models defined with Flask-SQLAlchemy::

        from flask import Flask
        from flask.ext.restless import APIManager
        from flask.ext.sqlalchemy import SQLAlchemy

        app = Flask(__name__)
        db = SQLALchemy(app)
        apimanager = APIManager(app, flask_sqlalchemy_db=db)

    """

    #: The format of the name of the API view for a given model.
    #:
    #: This format string expects the name of a model to be provided when
    #: formatting.
    APINAME_FORMAT = '{0}api'

    #: The format of the name of the blueprint containing the API view for a
    #: given model.
    #:
    #: This format string expects the following to be provided when formatting:
    #:
    #: 1. name of the API view of a specific model
    #: 2. a number representing the number of times a blueprint with that name
    #:    has been registered.
    BLUEPRINTNAME_FORMAT = '{0}{1}'

    def __init__(self, app=None, session=None, flask_sqlalchemy_db=None,
                 preprocessors=None, postprocessors=None):
        self.init_app(app, session, flask_sqlalchemy_db, preprocessors,
                      postprocessors)

    def _next_blueprint_name(self, basename):
        """Returns the next name for a blueprint with the specified base name.

        This method returns a string of the form ``'{0}{1}'.format(basename,
        number)``, where ``number`` is the next non-negative integer not
        already used in the name of an existing blueprint.

        For example, if `basename` is ``'personapi'`` and blueprints already
        exist with names ``'personapi0'``, ``'personapi1'``, and
        ``'personapi2'``, then this function would return ``'personapi3'``. We
        expect that code which calls this function will subsequently register a
        blueprint with that name, but that is not necessary.

        """
        # blueprints is a dict whose keys are the names of the blueprints
        blueprints = self.app.blueprints
        existing = [name for name in blueprints if name.startswith(basename)]
        # if this is the first one...
        if not existing:
            next_number = 0
        else:
            # for brevity
            b = basename
            existing_numbers = [int(n.partition(b)[-1]) for n in existing]
            next_number = max(existing_numbers) + 1
        return APIManager.BLUEPRINTNAME_FORMAT.format(basename, next_number)

    def init_app(self, app, session=None, flask_sqlalchemy_db=None,
                 preprocessors=None, postprocessors=None):
        """Stores the specified :class:`flask.Flask` application object on
        which API endpoints will be registered and the
        :class:`sqlalchemy.orm.session.Session` object in which all database
        changes will be made.

        `session` is the :class:`sqlalchemy.orm.session.Session` object in
        which changes to the database will be made.

        `flask_sqlalchemy_db` is the :class:`flask.ext.sqlalchemy.SQLAlchemy`
        object with which `app` has been registered and which contains the
        database models for which API endpoints will be created.

        If `flask_sqlalchemy_db` is not ``None``, `session` will be ignored.

        This is for use in the situation in which this class must be
        instantiated before the :class:`~flask.Flask` application has been
        created.

        To use this method with pure SQLAlchemy, for example::

            from flask import Flask
            from flask.ext.restless import APIManager
            from sqlalchemy import create_engine
            from sqlalchemy.orm.session import sessionmaker

            apimanager = APIManager()

            # later...

            engine = create_engine('sqlite:////tmp/mydb.sqlite')
            Session = sessionmaker(bind=engine)
            mysession = Session()
            app = Flask(__name__)
            apimanager.init_app(app, session=mysession)

        and with models defined with Flask-SQLAlchemy::

            from flask import Flask
            from flask.ext.restless import APIManager
            from flask.ext.sqlalchemy import SQLAlchemy

            apimanager = APIManager()

            # later...

            app = Flask(__name__)
            db = SQLALchemy(app)
            apimanager.init_app(app, flask_sqlalchemy_db=db)

        `postprocessors` and `preprocessors` must be dictionaries as described
        in the section :ref:`processors`. These preprocessors and
        postprocessors will be applied to all requests to and responses from
        APIs created using this APIManager object. The preprocessors and
        postprocessors given in these keyword arguments will be prepended to
        the list of processors given for each individual model when using the
        :meth:`create_api_blueprint` method (more specifically, the functions
        listed here will be executed before any functions specified in the
        :meth:`create_api_blueprint` method). For more information on using
        preprocessors and postprocessors, see :ref:`processors`.

        .. versionadded:: 0.13.0
           Added the `preprocessors` and `postprocessors` keyword arguments.

        """
        self.app = app
        self.session = session or getattr(flask_sqlalchemy_db, 'session', None)
        self.universal_preprocessors = preprocessors or {}
        self.universal_postprocessors = postprocessors or {}

    def create_api_blueprint(self, model, methods=READONLY_METHODS,
                             url_prefix='/api', collection_name=None,
                             allow_patch_many=False, allow_functions=False,
                             exclude_columns=None, include_columns=None,
                             include_methods=None, validation_exceptions=None,
                             results_per_page=10, max_results_per_page=100,
                             post_form_preprocessor=None,
                             preprocessors=None, postprocessors=None,
                             primary_key=None):
        """Creates an returns a ReSTful API interface as a blueprint, but does
        not register it on any :class:`flask.Flask` application.

        The endpoints for the API for ``model`` will be available at
        ``<url_prefix>/<collection_name>``. If `collection_name` is ``None``,
        the lowercase name of the provided model class will be used instead, as
        accessed by ``model.__name__``. (If any black magic was performed on
        ``model.__name__``, this will be reflected in the endpoint URL.)

        This function must be called at most once for each model for which you
        wish to create a ReSTful API. Its behavior (for now) is undefined if
        called more than once.

        This function returns the :class:`flask.Blueprint` object which handles
        the endpoints for the model. The returned :class:`~flask.Blueprint` has
        already been registered with the :class:`~flask.Flask` application
        object specified in the constructor of this class, so you do *not* need
        to register it yourself.

        `model` is the SQLAlchemy model class for which a ReSTful interface
        will be created. Note this must be a class, not an instance of a class.

        `methods` specify the HTTP methods which will be made available on the
        ReSTful API for the specified model, subject to the following caveats:

        * If :http:method:`get` is in this list, the API will allow getting a
          single instance of the model, getting all instances of the model, and
          searching the model using search parameters.
        * If :http:method:`patch` is in this list, the API will allow updating
          a single instance of the model, updating all instances of the model,
          and updating a subset of all instances of the model specified using
          search parameters.
        * If :http:method:`delete` is in this list, the API will allow deletion
          of a single instance of the model per request.
        * If :http:method:`post` is in this list, the API will allow posting a
          new instance of the model per request.

        The default set of methods provides a read-only interface (that is,
        only :http:method:`get` requests are allowed).

        `collection_name` is the name of the collection specified by the given
        model class to be used in the URL for the ReSTful API created. If this
        is not specified, the lowercase name of the model will be used.

        `url_prefix` the URL prefix at which this API will be accessible.

        If `allow_patch_many` is ``True``, then requests to
        :http:patch:`/api/<collection_name>?q=<searchjson>` will attempt to
        patch the attributes on each of the instances of the model which match
        the specified search query. This is ``False`` by default. For
        information on the search query parameter ``q``, see
        :ref:`searchformat`.

        `validation_exceptions` is the tuple of possible exceptions raised by
        validation of your database models. If this is specified, validation
        errors will be captured and forwarded to the client in JSON format. For
        more information on how to use validation, see :ref:`validation`.

        If `allow_functions` is ``True``, then requests to
        :http:get:`/api/eval/<collection_name>` will return the result of
        evaluating SQL functions specified in the body of the request. For
        information on the request format, see :ref:`functionevaluation`. This
        if ``False`` by default. Warning: you must not create an API for a
        model whose name is ``'eval'`` if you set this argument to ``True``.

        If either `include_columns` or `exclude_columns` is not ``None``,
        exactly one of them must be specified. If both are not ``None``, then
        this function will raise a :exc:`IllegalArgumentError`.
        `exclude_columns` must be an iterable of strings specifying the columns
        of `model` which will *not* be present in the JSON representation of
        the model provided in response to :http:method:`get` requests.
        Similarly, `include_columns` specifies the *only* columns which will be
        present in the returned dictionary. In other words, `exclude_columns`
        is a blacklist and `include_columns` is a whitelist; you can only use
        one of them per API endpoint. If either `include_columns` or
        `exclude_columns` contains a string which does not name a column in
        `model`, it will be ignored.

        If `include_columns` is an iterable of length zero (like the empty
        tuple or the empty list), then the returned dictionary will be
        empty. If `include_columns` is ``None``, then the returned dictionary
        will include all columns not excluded by `exclude_columns`.

        If `include_methods` is an iterable of strings, the methods with names
        corresponding to those in this list will be called and their output
        included in the response.

        See :ref:`includes` for information on specifying included or excluded
        columns on fields of related models.

        `results_per_page` is a positive integer which represents the default
        number of results which are returned per page. Requests made by clients
        may override this default by specifying ``results_per_page`` as a query
        argument. `max_results_per_page` is a positive integer which represents
        the maximum number of results which are returned per page. This is a
        "hard" upper bound in the sense that even if a client specifies that
        greater than `max_results_per_page` should be returned, only
        `max_results_per_page` results will be returned. For more information,
        see :ref:`serverpagination`.

        .. deprecated:: 0.9.2
           The `post_form_preprocessor` keyword argument is deprecated in
           version 0.9.2. It will be removed in version 1.0. Replace code that
           looks like this::

               manager.create_api(Person, post_form_preprocessor=foo)

           with code that looks like this::

               manager.create_api(Person, preprocessors=dict(POST=[foo]))

           See :ref:`processors` for more information and examples.

        `post_form_preprocessor` is a callback function which takes
        POST input parameters loaded from JSON and enhances them with other
        key/value pairs. The example use of this is when your ``model``
        requires to store user identity and for security reasons the identity
        is not read from the post parameters (where malicious user can tamper
        with them) but from the session.

        `preprocessors` is a dictionary mapping strings to lists of
        functions. Each key is the name of an HTTP method (for example,
        ``'GET'`` or ``'POST'``). Each value is a list of functions, each of
        which will be called before any other code is executed when this API
        receives the corresponding HTTP request. The functions will be called
        in the order given here. The `postprocessors` keyword argument is
        essentially the same, except the given functions are called after all
        other code. For more information on preprocessors and postprocessors,
        see :ref:`processors`.

        `primary_key` is a string specifying the name of the column of `model`
        to use as the primary key for the purposes of creating URLs. If the
        `model` has exactly one primary key, there is no need to provide a
        value for this. If `model` has two or more primary keys, you must
        specify which one to use.

        .. versionadded:: 0.13.0
           Added the `primary_key` keyword argument.

        .. versionadded:: 0.10.2
           Added the `include_methods` keyword argument.

        .. versionchanged:: 0.10.0
           Removed `authentication_required_for` and `authentication_function`
           keyword arguments.

           Use the `preprocesors` and `postprocessors` keyword arguments
           instead. For more information, see :ref:`authentication`.

        .. versionadded:: 0.9.2
           Added the `preprocessors` and `postprocessors` keyword arguments.

        .. versionadded:: 0.9.0
           Added the `max_results_per_page` keyword argument.

        .. versionadded:: 0.7
           Added the `exclude_columns` keyword argument.

        .. versionadded:: 0.6
           This functionality was formerly in :meth:`create_api`, but the
           blueprint creation and registration have now been separated.

        .. versionadded:: 0.6
           Added the `results_per_page` keyword argument.

        .. versionadded:: 0.5
           Added the `include_columns` and `validation_exceptions` keyword
           argument.

        .. versionadded:: 0.4
           Added the `allow_functions`, `allow_patch_many`,
           `authentication_required_for`, `authentication_function`, and
           `collection_name` keyword arguments.

        .. versionadded:: 0.4
           Force the model name in the URL to lowercase.

        """
        if exclude_columns is not None and include_columns is not None:
            msg = ('Cannot simultaneously specify both include columns and'
                   ' exclude columns.')
            raise IllegalArgumentError(msg)
        if collection_name is None:
            collection_name = model.__tablename__
        # convert all method names to upper case
        methods = frozenset((m.upper() for m in methods))
        # sets of methods used for different types of endpoints
        no_instance_methods = methods & frozenset(('POST', ))
        if allow_patch_many:
            possibly_empty_instance_methods = \
                methods & frozenset(('GET', 'PATCH', 'PUT'))
        else:
            possibly_empty_instance_methods = methods & frozenset(('GET', ))
        instance_methods = \
            methods & frozenset(('GET', 'PATCH', 'DELETE', 'PUT'))
        # the base URL of the endpoints on which requests will be made
        collection_endpoint = '/{0}'.format(collection_name)
        # the name of the API, for use in creating the view and the blueprint
        apiname = APIManager.APINAME_FORMAT.format(collection_name)
        # Prepend the universal preprocessors and postprocessors specified in
        # the constructor of this class.
        preprocessors_ = defaultdict(list)
        postprocessors_ = defaultdict(list)
        preprocessors_.update(preprocessors or {})
        postprocessors_.update(postprocessors or {})
        for key, value in self.universal_preprocessors.items():
            preprocessors_[key] = value + preprocessors_[key]
        for key, value in self.universal_postprocessors.items():
            postprocessors_[key] = value + postprocessors_[key]
        # the view function for the API for this model
        api_view = API.as_view(apiname, self.session, model, exclude_columns,
                               include_columns, include_methods,
                               validation_exceptions, results_per_page,
                               max_results_per_page, post_form_preprocessor,
                               preprocessors_, postprocessors_, primary_key)
        # suffix an integer to apiname according to already existing blueprints
        blueprintname = self._next_blueprint_name(apiname)
        # add the URL rules to the blueprint: the first is for methods on the
        # collection only, the second is for methods which may or may not
        # specify an instance, the third is for methods which must specify an
        # instance
        # TODO what should the second argument here be?
        # TODO should the url_prefix be specified here or in register_blueprint
        blueprint = Blueprint(blueprintname, __name__, url_prefix=url_prefix)
        # For example, /api/person.
        blueprint.add_url_rule(collection_endpoint,
                               methods=no_instance_methods, view_func=api_view)
        # For example, /api/person/1.
        blueprint.add_url_rule(collection_endpoint,
                               defaults={'instid': None, 'relationname': None,
                                         'relationinstid': None},
                               methods=possibly_empty_instance_methods,
                               view_func=api_view)
        # the per-instance endpoints will allow both integer and string primary
        # key accesses
        instance_endpoint = '{0}/<instid>'.format(collection_endpoint)
        # For example, /api/person/1.
        blueprint.add_url_rule(instance_endpoint, methods=instance_methods,
                               defaults={'relationname': None,
                                         'relationinstid': None},
                               view_func=api_view)
        # add endpoints which expose related models
        relation_endpoint = '{0}/<relationname>'.format(instance_endpoint)
        relation_instance_endpoint = \
            '{0}/<relationinstid>'.format(relation_endpoint)
        # For example, /api/person/1/computers.
        blueprint.add_url_rule(relation_endpoint,
                               methods=possibly_empty_instance_methods,
                               defaults={'relationinstid': None},
                               view_func=api_view)
        # For example, /api/person/1/computers/2.
        blueprint.add_url_rule(relation_instance_endpoint,
                               methods=instance_methods,
                               view_func=api_view)
        # if function evaluation is allowed, add an endpoint at /api/eval/...
        # which responds only to GET requests and responds with the result of
        # evaluating functions on all instances of the specified model
        if allow_functions:
            eval_api_name = apiname + 'eval'
            eval_api_view = FunctionAPI.as_view(eval_api_name, self.session,
                                                model)
            eval_endpoint = '/eval' + collection_endpoint
            blueprint.add_url_rule(eval_endpoint, methods=['GET'],
                                   view_func=eval_api_view)
        return blueprint

    def create_api(self, *args, **kw):
        """Creates and registers a ReSTful API blueprint on the
        :class:`flask.Flask` application specified in the constructor of this
        class.

        The positional and keyword arguments are passed directly to the
        :meth:`create_api_blueprint` method, so see the documentation there.

        This is a convenience method for the following code::

            blueprint = apimanager.create_api_blueprint(*args, **kw)
            app.register_blueprint(blueprint)

        .. versionchanged:: 0.6
           The blueprint creation has been moved to
           :meth:`create_api_blueprint`; the registration remains here.

        """
        blueprint = self.create_api_blueprint(*args, **kw)
        self.app.register_blueprint(blueprint)

########NEW FILE########
__FILENAME__ = search
"""
    flask.ext.restless.search
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Provides querying, searching, and function evaluation on SQLAlchemy models.

    The most important functions in this module are the :func:`create_query`
    and :func:`search` functions, which create a SQLAlchemy query object and
    execute that query on a given model, respectively.

    :copyright: 2011 by Lincoln de Sousa <lincoln@comum.org>
    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import inspect

from sqlalchemy import and_ as AND
from sqlalchemy import or_ as OR
from sqlalchemy.ext.associationproxy import AssociationProxy
from sqlalchemy.orm.attributes import InstrumentedAttribute

from .helpers import session_query
from .helpers import get_related_association_proxy_model
from .helpers import primary_key_names


def _sub_operator(model, argument, fieldname):
    """Recursively calls :func:`QueryBuilder._create_operation` when argument
    is a dictionary of the form specified in :ref:`search`.

    This function is for use with the ``has`` and ``any`` search operations.

    """
    if isinstance(model, InstrumentedAttribute):
        submodel = model.property.mapper.class_
    elif isinstance(model, AssociationProxy):
        submodel = get_related_association_proxy_model(model)
    else:  # TODO what to do here?
        pass
    if isinstance(argument, dict):
        fieldname = argument['name']
        operator = argument['op']
        argument = argument['val']
        relation = None
        if '__' in fieldname:
            fieldname, relation = fieldname.split('__')
        return QueryBuilder._create_operation(submodel, fieldname, operator,
                                              argument, relation)
    # Support legacy has/any with implicit eq operator
    return getattr(submodel, fieldname) == argument


#: The mapping from operator name (as accepted by the search method) to a
#: function which returns the SQLAlchemy expression corresponding to that
#: operator.
#:
#: Each of these functions accepts either one, two, or three arguments. The
#: first argument is the field object on which to apply the operator. The
#: second argument, where it exists, is either the second argument to the
#: operator or a dictionary as described below. The third argument, where it
#: exists, is the name of the field.
#:
#: For functions that accept three arguments, the second argument may be a
#: dictionary containing ``'name'``, ``'op'``, and ``'val'`` mappings so that
#: :func:`QueryBuilder._create_operation` may be applied recursively. For more
#: information and examples, see :ref:`search`.
#:
#: Some operations have multiple names. For example, the equality operation can
#: be described by the strings ``'=='``, ``'eq'``, ``'equals'``, etc.
OPERATORS = {
    # Operators which accept a single argument.
    'is_null': lambda f: f == None,
    'is_not_null': lambda f: f != None,
    # TODO what are these?
    'desc': lambda f: f.desc,
    'asc': lambda f: f.asc,
    # Operators which accept two arguments.
    '==': lambda f, a: f == a,
    'eq': lambda f, a: f == a,
    'equals': lambda f, a: f == a,
    'equal_to': lambda f, a: f == a,
    '!=': lambda f, a: f != a,
    'ne': lambda f, a: f != a,
    'neq': lambda f, a: f != a,
    'not_equal_to': lambda f, a: f != a,
    'does_not_equal': lambda f, a: f != a,
    '>': lambda f, a: f > a,
    'gt': lambda f, a: f > a,
    '<': lambda f, a: f < a,
    'lt': lambda f, a: f < a,
    '>=': lambda f, a: f >= a,
    'ge': lambda f, a: f >= a,
    'gte': lambda f, a: f >= a,
    'geq': lambda f, a: f >= a,
    '<=': lambda f, a: f <= a,
    'le': lambda f, a: f <= a,
    'lte': lambda f, a: f <= a,
    'leq': lambda f, a: f <= a,
    'ilike': lambda f, a: f.ilike(a),
    'like': lambda f, a: f.like(a),
    'in': lambda f, a: f.in_(a),
    'not_in': lambda f, a: ~f.in_(a),
    # Operators which accept three arguments.
    'has': lambda f, a, fn: f.has(_sub_operator(f, a, fn)),
    'any': lambda f, a, fn: f.any(_sub_operator(f, a, fn)),
}


class OrderBy(object):
    """Represents an "order by" in a SQL query expression."""

    def __init__(self, field, direction='asc'):
        """Instantiates this object with the specified attributes.

        `field` is the name of the field by which to order the result set.

        `direction` is either ``'asc'`` or ``'desc'``, for "ascending" and
        "descending", respectively.

        """
        self.field = field
        self.direction = direction

    def __repr__(self):
        """Returns a string representation of this object."""
        return '<OrderBy {0}, {1}>'.format(self.field, self.direction)


class Filter(object):
    """Represents a filter to apply to a SQL query.

    A filter can be, for example, a comparison operator applied to a field of a
    model and a value or a comparison applied to two fields of the same
    model. For more information on possible filters, see :ref:`search`.

    """

    def __init__(self, fieldname, operator, argument=None, otherfield=None):
        """Instantiates this object with the specified attributes.

        `fieldname` is the name of the field of a model which will be on the
        left side of the operator.

        `operator` is the string representation of an operator to apply. The
        full list of recognized operators can be found at :ref:`search`.

        If `argument` is specified, it is the value to place on the right side
        of the operator. If `otherfield` is specified, that field on the model
        will be placed on the right side of the operator.

        .. admonition:: About `argument` and `otherfield`

           Some operators don't need either argument and some need exactly one.
           However, this constructor will not raise any errors or otherwise
           inform you of which situation you are in; it is basically just a
           named tuple. Calling code must handle errors caused by missing
           required arguments.

        """
        self.fieldname = fieldname
        self.operator = operator
        self.argument = argument
        self.otherfield = otherfield

    def __repr__(self):
        """Returns a string representation of this object."""
        return '<Filter {0} {1} {2}>'.format(self.fieldname, self.operator,
                                             self.argument or self.otherfield)

    @staticmethod
    def from_dictionary(dictionary):
        """Returns a new :class:`Filter` object with arguments parsed from
        `dictionary`.

        `dictionary` is a dictionary of the form::

            {'name': 'age', 'op': 'lt', 'val': 20}

        or::

            {'name': 'age', 'op': 'lt', 'other': height}

        where ``dictionary['name']`` is the name of the field of the model on
        which to apply the operator, ``dictionary['op']`` is the name of the
        operator to apply, ``dictionary['val']`` is the value on the right to
        which the operator will be applied, and ``dictionary['other']`` is the
        name of the other field of the model to which the operator will be
        applied.

        """
        fieldname = dictionary.get('name')
        operator = dictionary.get('op')
        argument = dictionary.get('val')
        otherfield = dictionary.get('field')
        return Filter(fieldname, operator, argument, otherfield)


class SearchParameters(object):
    """Aggregates the parameters for a search, including filters, search type,
    limit, offset, and order by directives.

    """

    def __init__(self, filters=None, limit=None, offset=None, order_by=None,
                 junction=None):
        """Instantiates this object with the specified attributes.

        `filters` is a list of :class:`Filter` objects, representing filters to
        be applied during the search.

        `limit`, if not ``None``, specifies the maximum number of results to
        return in the search.

        `offset`, if not ``None``, specifies the number of initial results to
        skip in the result set.

        `order_by` is a list of :class:`OrderBy` objects, representing the
        ordering directives to apply to the result set which matches the
        search.

        `junction` is either :func:`sqlalchemy.or_` or :func:`sqlalchemy.and_`
        (if ``None``, this will default to :func:`sqlalchemy.and_`), specifying
        how the filters should be interpreted (that is, as a disjunction or a
        conjunction).

        """
        self.filters = filters or []
        self.limit = limit
        self.offset = offset
        self.order_by = order_by or []
        self.junction = junction or AND

    def __repr__(self):
        """Returns a string representation of the search parameters."""
        template = ('<SearchParameters filters={0}, order_by={1}, limit={2},'
                    ' offset={3}, junction={4}>')
        return template.format(self.filters, self.order_by, self.limit,
                               self.offset, self.junction.__name__)

    @staticmethod
    def from_dictionary(dictionary):
        """Returns a new :class:`SearchParameters` object with arguments parsed
        from `dictionary`.

        `dictionary` is a dictionary of the form::

            {
              'filters': [{'name': 'age', 'op': 'lt', 'val': 20}, ...],
              'order_by': [{'field': 'age', 'direction': 'desc'}, ...]
              'limit': 10,
              'offset': 3,
              'disjunction': True
            }

        where ``dictionary['filters']`` is the list of :class:`Filter` objects
        (in dictionary form), ``dictionary['order_by']`` is the list of
        :class:`OrderBy` objects (in dictionary form), ``dictionary['limit']``
        is the maximum number of matching entries to return,
        ``dictionary['offset']`` is the number of initial entries to skip in
        the matching result set, and ``dictionary['disjunction']`` is whether
        the filters should be joined as a disjunction or conjunction.

        The provided dictionary may have other key/value pairs, but they are
        ignored.

        """
        # for the sake of brevity...
        from_dict = Filter.from_dictionary
        filters = [from_dict(f) for f in dictionary.get('filters', [])]
        order_by_list = dictionary.get('order_by', [])
        order_by = [OrderBy(**o) for o in order_by_list]
        limit = dictionary.get('limit')
        offset = dictionary.get('offset')
        disjunction = dictionary.get('disjunction')
        junction = OR if disjunction else AND
        return SearchParameters(filters=filters, limit=limit, offset=offset,
                                order_by=order_by, junction=junction)


class QueryBuilder(object):
    """Provides a static function for building a SQLAlchemy query object based
    on a :class:`SearchParameters` instance.

    Use the static :meth:`create_query` method to create a SQLAlchemy query on
    a given model.

    """

    @staticmethod
    def _create_operation(model, fieldname, operator, argument, relation=None):
        """Translates an operation described as a string to a valid SQLAlchemy
        query parameter using a field or relation of the specified model.

        More specifically, this translates the string representation of an
        operation, for example ``'gt'``, to an expression corresponding to a
        SQLAlchemy expression, ``field > argument``. The recognized operators
        are given by the keys of :data:`OPERATORS`. For more information on
        recognized search operators, see :ref:`search`.

        If `relation` is not ``None``, the returned search parameter will
        correspond to a search on the field named `fieldname` on the entity
        related to `model` whose name, as a string, is `relation`.

        `model` is an instance of a SQLAlchemy declarative model being
        searched.

        `fieldname` is the name of the field of `model` to which the operation
        will be applied as part of the search. If `relation` is specified, the
        operation will be applied to the field with name `fieldname` on the
        entity related to `model` whose name, as a string, is `relation`.

        `operation` is a string representating the operation which will be
         executed between the field and the argument received. For example,
         ``'gt'``, ``'lt'``, ``'like'``, ``'in'`` etc.

        `argument` is the argument to which to apply the `operator`.

        `relation` is the name of the relationship attribute of `model` to
        which the operation will be applied as part of the search, or ``None``
        if this function should not use a related entity in the search.

        This function raises the following errors:
        * :exc:`KeyError` if the `operator` is unknown (that is, not in
          :data:`OPERATORS`)
        * :exc:`TypeError` if an incorrect number of arguments are provided for
          the operation (for example, if `operation` is `'=='` but no
          `argument` is provided)
        * :exc:`AttributeError` if no column with name `fieldname` or
          `relation` exists on `model`

        """
        # raises KeyError if operator not in OPERATORS
        opfunc = OPERATORS[operator]
        argspec = inspect.getargspec(opfunc)
        # in Python 2.6 or later, this should be `argspec.args`
        numargs = len(argspec[0])
        # raises AttributeError if `fieldname` or `relation` does not exist
        field = getattr(model, relation or fieldname)
        # each of these will raise a TypeError if the wrong number of argments
        # is supplied to `opfunc`.
        if numargs == 1:
            return opfunc(field)
        if argument is None:
            raise TypeError
        if numargs == 2:
            return opfunc(field, argument)
        return opfunc(field, argument, fieldname)

    @staticmethod
    def _create_filters(model, search_params):
        """Returns the list of operations on `model` specified in the
        :attr:`filters` attribute on the `search_params` object.

        `search-params` is an instance of the :class:`SearchParameters` class
        whose fields represent the parameters of the search.

        Raises one of :exc:`AttributeError`, :exc:`KeyError`, or
        :exc:`TypeError` if there is a problem creating the query. See the
        documentation for :func:`_create_operation` for more information.

        Pre-condition: the ``search_params.filters`` is a (possibly empty)
        iterable.

        """
        filters = []
        for filt in search_params.filters:
            fname = filt.fieldname
            val = filt.argument
            # get the relationship from the field name, if it exists
            relation = None
            if '__' in fname:
                relation, fname = fname.split('__')
            # get the other field to which to compare, if it exists
            if filt.otherfield:
                val = getattr(model, filt.otherfield)
            # for the sake of brevity...
            create_op = QueryBuilder._create_operation
            param = create_op(model, fname, filt.operator, val, relation)
            filters.append(param)
        return filters

    @staticmethod
    def create_query(session, model, search_params):
        """Builds an SQLAlchemy query instance based on the search parameters
        present in ``search_params``, an instance of :class:`SearchParameters`.

        This method returns a SQLAlchemy query in which all matched instances
        meet the requirements specified in ``search_params``.

        `model` is SQLAlchemy declarative model on which to create a query.

        `search_params` is an instance of :class:`SearchParameters` which
        specify the filters, order, limit, offset, etc. of the query.

        Building the query proceeds in this order:
        1. filtering the query
        2. ordering the query
        3. limiting the query
        4. offsetting the query

        Raises one of :exc:`AttributeError`, :exc:`KeyError`, or
        :exc:`TypeError` if there is a problem creating the query. See the
        documentation for :func:`_create_operation` for more information.

        """
        # Adding field filters
        query = session_query(session, model)
        # may raise exception here
        filters = QueryBuilder._create_filters(model, search_params)
        query = query.filter(search_params.junction(*filters))

        # Order the search. If no order field is specified in the search
        # parameters, order by primary key.
        if search_params.order_by:
            for val in search_params.order_by:
                field = getattr(model, val.field)
                direction = getattr(field, val.direction)
                query = query.order_by(direction())
        else:
            pks = primary_key_names(model)
            pk_order = (getattr(model, field).asc() for field in pks)
            query = query.order_by(*pk_order)

        # Limit it
        if search_params.limit:
            query = query.limit(search_params.limit)
        if search_params.offset:
            query = query.offset(search_params.offset)
        return query


def create_query(session, model, searchparams):
    """Returns a SQLAlchemy query object on the given `model` where the search
    for the query is defined by `searchparams`.

    The returned query matches the set of all instances of `model` which meet
    the parameters of the search given by `searchparams`. For more information
    on search parameters, see :ref:`search`.

    `model` is a SQLAlchemy declarative model representing the database model
    to query.

    `searchparams` is either a dictionary (as parsed from a JSON request from
    the client, for example) or a :class:`SearchParameters` instance defining
    the parameters of the query (as returned by
    :func:`SearchParameters.from_dictionary`, for example).

    """
    if isinstance(searchparams, dict):
        searchparams = SearchParameters.from_dictionary(searchparams)
    return QueryBuilder.create_query(session, model, searchparams)


def search(session, model, search_params):
    """Performs the search specified by the given parameters on the model
    specified in the constructor of this class.

    This function essentially calls :func:`create_query` to create a query
    which matches the set of all instances of ``model`` which meet the search
    parameters defined in ``search_params``, then returns all results (or just
    one if ``search_params['single'] == True``).

    This function returns a single instance of the model matching the search
    parameters if ``search_params['single']`` is ``True``, or a list of all
    such instances otherwise. If ``search_params['single']`` is ``True``, then
    this method will raise :exc:`sqlalchemy.orm.exc.NoResultFound` if no
    results are found and :exc:`sqlalchemy.orm.exc.MultipleResultsFound` if
    multiple results are found.

    `model` is a SQLAlchemy declarative model class representing the database
    model to query.

    `search_params` is a dictionary containing all available search
    parameters. For more information on available search parameters, see
    :ref:`search`. Implementation note: this dictionary will be converted to a
    :class:`SearchParameters` object when the :func:`create_query` function is
    called.

    """
    # `is_single` is True when 'single' is a key in ``search_params`` and its
    # corresponding value is anything except those values which evaluate to
    # False (False, 0, the empty string, the empty list, etc.).
    is_single = search_params.get('single')
    query = create_query(session, model, search_params)
    if is_single:
        # may raise NoResultFound or MultipleResultsFound
        return query.one()
    return query

########NEW FILE########
__FILENAME__ = views
"""
    flask.ext.restless.views
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Provides the following view classes, subclasses of
    :class:`flask.MethodView` which provide generic endpoints for interacting
    with an entity of the database:

    :class:`flask.ext.restless.views.API`
      Provides the endpoints for each of the basic HTTP methods. This is the
      main class used by the
      :meth:`flask.ext.restless.manager.APIManager.create_api` method to create
      endpoints.

    :class:`flask.ext.restless.views.FunctionAPI`
      Provides a :http:method:`get` endpoint which returns the result of
      evaluating some function on the entire collection of a given model.

    :copyright: 2011 by Lincoln de Sousa <lincoln@comum.org>
    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from __future__ import division

from collections import defaultdict
from functools import wraps
import math
import warnings

from flask import current_app
from flask import json
from flask import jsonify as _jsonify
from flask import request
from flask.views import MethodView
from mimerender import FlaskMimeRender
from sqlalchemy.exc import DataError
from sqlalchemy.exc import IntegrityError
from sqlalchemy.exc import OperationalError
from sqlalchemy.exc import ProgrammingError
from sqlalchemy.orm.exc import MultipleResultsFound
from sqlalchemy.orm.exc import NoResultFound
from sqlalchemy.orm.query import Query
from werkzeug.exceptions import HTTPException

from .helpers import count
from .helpers import evaluate_functions
from .helpers import get_by
from .helpers import get_columns
from .helpers import get_or_create
from .helpers import get_related_model
from .helpers import get_relations
from .helpers import has_field
from .helpers import is_like_list
from .helpers import partition
from .helpers import primary_key_name
from .helpers import query_by_primary_key
from .helpers import session_query
from .helpers import strings_to_dates
from .helpers import to_dict
from .helpers import upper_keys
from werkzeug.exceptions import BadRequest

from .search import create_query
from .search import search


#: Format string for creating Link headers in paginated responses.
LINKTEMPLATE = '<{0}?page={1}&results_per_page={2}>; rel="{3}"'

#: String used internally as a dictionary key for passing header information
#: from view functions to the :func:`jsonpify` function.
_HEADERS = '__restless_headers'

#: String used internally as a dictionary key for passing status code
#: information from view functions to the :func:`jsonpify` function.
_STATUS = '__restless_status_code'


class ProcessingException(HTTPException):
    """Raised when a preprocessor or postprocessor encounters a problem.

    This exception should be raised by functions supplied in the
    ``preprocessors`` and ``postprocessors`` keyword arguments to
    :class:`APIManager.create_api`. When this exception is raised, all
    preprocessing or postprocessing halts, so any processors appearing later in
    the list will not be invoked.

    `status_code` is the HTTP status code of the response supplied to the
    client in the case that this exception is raised. `message` is an error
    message describing the cause of this exception. This message will appear in
    the JSON object in the body of the response to the client.

    """
    def __init__(self, description='', code=400, *args, **kwargs):
        super(ProcessingException, self).__init__(*args, **kwargs)
        self.code = code
        self.description = description


def _is_msie8or9():
    """Returns ``True`` if and only if the user agent of the client making the
    request indicates that it is Microsoft Internet Explorer 8 or 9.

    """
    if request.user_agent is None or request.user_agent.version is None:
        return False
    ua = request.user_agent
    # request.user_agent.version comes as a string, so we have to parse it
    ua_version = tuple(int(d) for d in ua.version.split('.'))
    return ua.browser == 'msie' and (8, 0) <= ua_version < (10, 0)


def create_link_string(page, last_page, per_page):
    """Returns a string representing the value of the ``Link`` header.

    `page` is the number of the current page, `last_page` is the last page in
    the pagination, and `per_page` is the number of results per page.

    """
    linkstring = ''
    if page < last_page:
        next_page = page + 1
        linkstring = LINKTEMPLATE.format(request.base_url, next_page,
                                         per_page, 'next') + ', '
    linkstring += LINKTEMPLATE.format(request.base_url, last_page,
                                      per_page, 'last')
    return linkstring


def catch_processing_exceptions(func):
    """Decorator that catches :exc:`ProcessingException`s and subsequently
    returns a JSON-ified error response.

    """
    @wraps(func)
    def decorator(*args, **kw):
        try:
            return func(*args, **kw)
        except ProcessingException as exception:
            current_app.logger.exception(str(exception))
            status, message = exception.code, exception.description or str(exception)
            return jsonify(message=message), status
    return decorator


def set_headers(response, headers):
    """Sets the specified headers on the specified response.

    `response` is a Flask response object, and `headers` is a dictionary of
    headers to set on the specified response. Any existing headers that
    conflict with `headers` will be overwritten.

    """
    for key, value in headers.items():
        response.headers[key] = value


def jsonify(*args, **kw):
    """Same as :func:`flask.jsonify`, but sets response headers.

    If ``headers`` is a keyword argument, this function will construct the JSON
    response via :func:`flask.jsonify`, then set the specified ``headers`` on
    the response. ``headers`` must be a dictionary mapping strings to strings.

    """
    response = _jsonify(*args, **kw)
    if 'headers' in kw:
        set_headers(response, kw['headers'])
    return response


# This code is (lightly) adapted from the ``requests`` library, in the
# ``requests.utils`` module. See <http://python-requests.org> for more
# information.
def _link_to_json(value):
    """Returns a list representation of the specified HTTP Link header
    information.

    `value` is a string containing the link header information. If the link
    header information (the part of after ``Link:``) looked like this::

        <url1>; rel="next", <url2>; rel="foo"; bar="baz"

    then this function returns a list that looks like this::

        [{"url": "url1", "rel": "next"},
         {"url": "url2", "rel": "foo", "bar": "baz"}]

    This example is adapted from the documentation of GitHub's API.

    """
    links = []
    replace_chars = " '\""
    for val in value.split(","):
        try:
            url, params = val.split(";", 1)
        except ValueError:
            url, params = val, ''
        link = {}
        link["url"] = url.strip("<> '\"")
        for param in params.split(";"):
            try:
                key, value = param.split("=")
            except ValueError:
                break
            link[key.strip(replace_chars)] = value.strip(replace_chars)
        links.append(link)
    return links


def _headers_to_json(headers):
    """Returns a dictionary representation of the specified dictionary of HTTP
    headers ready for use as a JSON object.

    Pre-condition: headers is not ``None``.

    """
    link = headers.pop('Link', None)
    # Shallow copy is fine here because the `headers` dictionary maps strings
    # to strings to strings.
    result = headers.copy()
    if link:
        result['Link'] = _link_to_json(link)
    return result


def jsonpify(*args, **kw):
    """Passes the specified arguments directly to :func:`jsonify` with a status
    code of 200, then wraps the response with the name of a JSON-P callback
    function specified as a query parameter called ``'callback'`` (or does
    nothing if no such callback function is specified in the request).

    If the keyword arguments include the string specified by :data:`_HEADERS`,
    its value must be a dictionary specifying headers to set before sending the
    JSONified response to the client. Headers on the response will be
    overwritten by headers specified in this dictionary.

    If the keyword arguments include the string specified by :data:`_STATUS`,
    its value must be an integer representing the status code of the response.
    Otherwise, the status code of the response will be :http:status:`200`.

    """
    # HACK In order to make the headers and status code available in the
    # content of the response, we need to send it from the view function to
    # this jsonpify function via its keyword arguments. This is a limitation of
    # the mimerender library: it has no way of making the headers and status
    # code known to the rendering functions.
    headers = kw.pop(_HEADERS, {})
    status_code = kw.pop(_STATUS, 200)
    response = jsonify(*args, **kw)
    callback = request.args.get('callback', False)
    if callback:
        # Reload the data from the constructed JSON string so we can wrap it in
        # a JSONP function.
        data = json.loads(response.data)
        # Force the 'Content-Type' header to be 'application/javascript'.
        #
        # Note that this is different from the mimetype used in Flask for JSON
        # responses; Flask uses 'application/json'. We use
        # 'application/javascript' because a JSONP response is valid
        # Javascript, but not valid JSON.
        headers['Content-Type'] = 'application/javascript'
        # Add the headers and status code as metadata to the JSONP response.
        meta = _headers_to_json(headers) if headers is not None else {}
        meta['status'] = status_code
        inner = json.dumps(dict(meta=meta, data=data))
        content = '{0}({1})'.format(callback, inner)
        # Note that this is different from the mimetype used in Flask for JSON
        # responses; Flask uses 'application/json'. We use
        # 'application/javascript' because a JSONP response is not valid JSON.
        mimetype = 'application/javascript'
        response = current_app.response_class(content, mimetype=mimetype)
    # Set the headers on the HTTP response as well.
    if headers:
        set_headers(response, headers)
    response.status_code = status_code
    return response


def _parse_includes(column_names):
    """Returns a pair, consisting of a list of column names to include on the
    left and a dictionary mapping relation name to a list containing the names
    of fields on the related model which should be included.

    `column_names` is either ``None`` or a list of strings. If it is ``None``,
    the returned pair will be ``(None, None)``.

    If the name of a relation appears as a key in the dictionary, then it will
    not appear in the list.

    """
    if column_names is None:
        return None, None
    dotted_names, columns = partition(column_names, lambda name: '.' in name)
    # Create a dictionary mapping relation names to fields on the related
    # model.
    relations = defaultdict(list)
    for name in dotted_names:
        relation, field = name.split('.', 1)
        # Only add the relation if it's column has been specified.
        if relation in columns:
            relations[relation].append(field)
    # Included relations need only be in the relations dictionary, not the
    # columns list.
    for relation in relations:
        if relation in columns:
            columns.remove(relation)
    return columns, relations


def _parse_excludes(column_names):
    """Returns a pair, consisting of a list of column names to exclude on the
    left and a dictionary mapping relation name to a list containing the names
    of fields on the related model which should be excluded.

    `column_names` is either ``None`` or a list of strings. If it is ``None``,
    the returned pair will be ``(None, None)``.

    If the name of a relation appears in the list then it will not appear in
    the dictionary.

    """
    if column_names is None:
        return None, None
    dotted_names, columns = partition(column_names, lambda name: '.' in name)
    # Create a dictionary mapping relation names to fields on the related
    # model.
    relations = defaultdict(list)
    for name in dotted_names:
        relation, field = name.split('.', 1)
        # Only add the relation if it's column has not been specified.
        if relation not in columns:
            relations[relation].append(field)
    # Relations which are to be excluded entirely need only be in the columns
    # list, not the relations dictionary.
    for column in columns:
        if column in relations:
            del relations[column]
    return columns, relations

#: Creates the mimerender object necessary for decorating responses with a
#: function that automatically formats the dictionary in the appropriate format
#: based on the ``Accept`` header.
#:
#: Technical details: the first pair of parantheses instantiates the
#: :class:`mimerender.FlaskMimeRender` class. The second pair of parentheses
#: creates the decorator, so that we can simply use the variable ``mimerender``
#: as a decorator.
# TODO fill in xml renderer
mimerender = FlaskMimeRender()(default='json', json=jsonpify)


class ModelView(MethodView):
    """Base class for :class:`flask.MethodView` classes which represent a view
    of a SQLAlchemy model.

    The model class for this view can be accessed from the :attr:`model`
    attribute, and the session in which all database transactions will be
    performed when dealing with this model can be accessed from the
    :attr:`session` attribute.

    When subclasses wish to make queries to the database model specified in the
    constructor, they should access the ``self.query`` function, which
    delegates to the appropriate SQLAlchemy query object or Flask-SQLAlchemy
    query object, depending on how the model has been defined.

    """

    #: List of decorators applied to every method of this class.
    decorators = [mimerender]

    def __init__(self, session, model, *args, **kw):
        """Calls the constructor of the superclass and specifies the model for
        which this class provides a ReSTful API.

        `session` is the SQLAlchemy session in which all database transactions
        will be performed.

        `model` is the SQLALchemy declarative model class of the database model
        for which this instance of the class is an API.

        """
        super(ModelView, self).__init__(*args, **kw)
        self.session = session
        self.model = model

    def query(self, model=None):
        """Returns either a SQLAlchemy query or Flask-SQLAlchemy query object
        (depending on the type of the model) on the specified `model`, or if
        `model` is ``None``, the model specified in the constructor of this
        class.

        """
        return session_query(self.session, model or self.model)


class FunctionAPI(ModelView):
    """Provides method-based dispatching for :http:method:`get` requests which
    wish to apply SQL functions to all instances of a model.

    .. versionadded:: 0.4

    """

    def get(self):
        """Returns the result of evaluating the SQL functions specified in the
        body of the request.

        For a description of the request and response formats, see
        :ref:`functionevaluation`.

        """
        if 'q' not in request.args or not request.args.get('q'):
            return dict(message='Empty query parameter'), 400
        # if parsing JSON fails, return a 400 error in JSON format
        try:
            data = json.loads(str(request.args.get('q'))) or {}
        except (TypeError, ValueError, OverflowError) as exception:
            current_app.logger.exception(str(exception))
            return dict(message='Unable to decode data'), 400
        try:
            result = evaluate_functions(self.session, self.model,
                                        data.get('functions', []))
            if not result:
                return {}, 204
            return result
        except AttributeError as exception:
            current_app.logger.exception(str(exception))
            message = 'No such field "{0}"'.format(exception.field)
            return dict(message=message), 400
        except OperationalError as exception:
            current_app.logger.exception(str(exception))
            message = 'No such function "{0}"'.format(exception.function)
            return dict(message=message), 400


class API(ModelView):
    """Provides method-based dispatching for :http:method:`get`,
    :http:method:`post`, :http:method:`patch`, :http:method:`put`, and
    :http:method:`delete` requests, for both collections of models and
    individual models.

    """

    #: List of decorators applied to every method of this class.
    decorators = ModelView.decorators + [catch_processing_exceptions]

    def __init__(self, session, model, exclude_columns=None,
                 include_columns=None, include_methods=None,
                 validation_exceptions=None, results_per_page=10,
                 max_results_per_page=100, post_form_preprocessor=None,
                 preprocessors=None, postprocessors=None, primary_key=None,
                 *args, **kw):
        """Instantiates this view with the specified attributes.

        `session` is the SQLAlchemy session in which all database transactions
        will be performed.

        `model` is the SQLAlchemy model class for which this instance of the
        class is an API. This model should live in `database`.

        `validation_exceptions` is the tuple of exceptions raised by backend
        validation (if any exist). If exceptions are specified here, any
        exceptions which are caught when writing to the database. Will be
        returned to the client as a :http:statuscode:`400` response with a
        message specifying the validation error which occurred. For more
        information, see :ref:`validation`.

        If either `include_columns` or `exclude_columns` is not ``None``,
        exactly one of them must be specified. If both are not ``None``, then
        the behavior of this function is undefined. `exclude_columns` must be
        an iterable of strings specifying the columns of `model` which will
        *not* be present in the JSON representation of the model provided in
        response to :http:method:`get` requests.  Similarly, `include_columns`
        specifies the *only* columns which will be present in the returned
        dictionary. In other words, `exclude_columns` is a blacklist and
        `include_columns` is a whitelist; you can only use one of them per API
        endpoint. If either `include_columns` or `exclude_columns` contains a
        string which does not name a column in `model`, it will be ignored.

        If `include_columns` is an iterable of length zero (like the empty
        tuple or the empty list), then the returned dictionary will be
        empty. If `include_columns` is ``None``, then the returned dictionary
        will include all columns not excluded by `exclude_columns`.

        If `include_methods` is an iterable of strings, the methods with names
        corresponding to those in this list will be called and their output
        included in the response.

        See :ref:`includes` for information on specifying included or excluded
        columns on fields of related models.

        `results_per_page` is a positive integer which represents the default
        number of results which are returned per page. Requests made by clients
        may override this default by specifying ``results_per_page`` as a query
        argument. `max_results_per_page` is a positive integer which represents
        the maximum number of results which are returned per page. This is a
        "hard" upper bound in the sense that even if a client specifies that
        greater than `max_results_per_page` should be returned, only
        `max_results_per_page` results will be returned. For more information,
        see :ref:`serverpagination`.

        .. deprecated:: 0.9.2
           The `post_form_preprocessor` keyword argument is deprecated in
           version 0.9.2. It will be removed in version 1.0. Replace code that
           looks like this::

               manager.create_api(Person, post_form_preprocessor=foo)

           with code that looks like this::

               manager.create_api(Person, preprocessors=dict(POST=[foo]))

           See :ref:`processors` for more information and examples.

        `post_form_preprocessor` is a callback function which takes
        POST input parameters loaded from JSON and enhances them with other
        key/value pairs. The example use of this is when your ``model``
        requires to store user identity and for security reasons the identity
        is not read from the post parameters (where malicious user can tamper
        with them) but from the session.

        `preprocessors` is a dictionary mapping strings to lists of
        functions. Each key is the name of an HTTP method (for example,
        ``'GET'`` or ``'POST'``). Each value is a list of functions, each of
        which will be called before any other code is executed when this API
        receives the corresponding HTTP request. The functions will be called
        in the order given here. The `postprocessors` keyword argument is
        essentially the same, except the given functions are called after all
        other code. For more information on preprocessors and postprocessors,
        see :ref:`processors`.

        `primary_key` is a string specifying the name of the column of `model`
        to use as the primary key for the purposes of creating URLs. If the
        `model` has exactly one primary key, there is no need to provide a
        value for this. If `model` has two or more primary keys, you must
        specify which one to use.

        .. versionadded:: 0.13.0
           Added the `primary_key` keyword argument.

        .. versionadded:: 0.10.2
           Added the `include_methods` keyword argument.

        .. versionchanged:: 0.10.0
           Removed `authentication_required_for` and `authentication_function`
           keyword arguments.

           Use the `preprocesors` and `postprocessors` keyword arguments
           instead. For more information, see :ref:`authentication`.

        .. versionadded:: 0.9.2
           Added the `preprocessors` and `postprocessors` keyword arguments.

        .. versionadded:: 0.9.0
           Added the `max_results_per_page` keyword argument.

        .. versionadded:: 0.7
           Added the `exclude_columns` keyword argument.

        .. versionadded:: 0.6
           Added the `results_per_page` keyword argument.

        .. versionadded:: 0.5
           Added the `include_columns`, and `validation_exceptions` keyword
           arguments.

        .. versionadded:: 0.4
           Added the `authentication_required_for` and
           `authentication_function` keyword arguments.

        """
        super(API, self).__init__(session, model, *args, **kw)
        self.exclude_columns, self.exclude_relations = \
            _parse_excludes(exclude_columns)
        self.include_columns, self.include_relations = \
            _parse_includes(include_columns)
        self.include_methods = include_methods
        self.validation_exceptions = tuple(validation_exceptions or ())
        self.results_per_page = results_per_page
        self.max_results_per_page = max_results_per_page
        self.primary_key = primary_key
        self.postprocessors = defaultdict(list)
        self.preprocessors = defaultdict(list)
        self.postprocessors.update(upper_keys(postprocessors or {}))
        self.preprocessors.update(upper_keys(preprocessors or {}))
        # move post_form_preprocessor to preprocessors['POST'] for backward
        # compatibility
        if post_form_preprocessor:
            msg = ('post_form_preprocessor is deprecated and will be removed'
                   ' in version 1.0; use preprocessors instead.')
            warnings.warn(msg, DeprecationWarning)
            self.preprocessors['POST'].append(post_form_preprocessor)
        # postprocessors for PUT are applied to PATCH because PUT is just a
        # redirect to PATCH
        for postprocessor in self.postprocessors['PUT_SINGLE']:
            self.postprocessors['PATCH_SINGLE'].append(postprocessor)
        for preprocessor in self.preprocessors['PUT_SINGLE']:
            self.preprocessors['PATCH_SINGLE'].append(preprocessor)
        for postprocessor in self.postprocessors['PUT_MANY']:
            self.postprocessors['PATCH_MANY'].append(postprocessor)
        for preprocessor in self.preprocessors['PUT_MANY']:
            self.preprocessors['PATCH_MANY'].append(preprocessor)

    def _add_to_relation(self, query, relationname, toadd=None):
        """Adds a new or existing related model to each model specified by
        `query`.

        This function does not commit the changes made to the database. The
        calling function has that responsibility.

        `query` is a SQLAlchemy query instance that evaluates to all instances
        of the model specified in the constructor of this class that should be
        updated.

        `relationname` is the name of a one-to-many relationship which exists
        on each model specified in `query`.

        `toadd` is a list of dictionaries, each representing the attributes of
        an existing or new related model to add. If a dictionary contains the
        key ``'id'``, that instance of the related model will be
        added. Otherwise, the :func:`helpers.get_or_create` class method will
        be used to get or create a model to add.

        """
        submodel = get_related_model(self.model, relationname)
        if isinstance(toadd, dict):
            toadd = [toadd]
        for dictionary in toadd or []:
            subinst = get_or_create(self.session, submodel, dictionary)
            try:
                for instance in query:
                    getattr(instance, relationname).append(subinst)
            except AttributeError as exception:
                current_app.logger.exception(str(exception))
                setattr(instance, relationname, subinst)

    def _remove_from_relation(self, query, relationname, toremove=None):
        """Removes a related model from each model specified by `query`.

        This function does not commit the changes made to the database. The
        calling function has that responsibility.

        `query` is a SQLAlchemy query instance that evaluates to all instances
        of the model specified in the constructor of this class that should be
        updated.

        `relationname` is the name of a one-to-many relationship which exists
        on each model specified in `query`.

        `toremove` is a list of dictionaries, each representing the attributes
        of an existing model to remove. If a dictionary contains the key
        ``'id'``, that instance of the related model will be
        removed. Otherwise, the instance to remove will be retrieved using the
        other attributes specified in the dictionary. If multiple instances
        match the specified attributes, only the first instance will be
        removed.

        If one of the dictionaries contains a mapping from ``'__delete__'`` to
        ``True``, then the removed object will be deleted after being removed
        from each instance of the model in the specified query.

        """
        submodel = get_related_model(self.model, relationname)
        for dictionary in toremove or []:
            remove = dictionary.pop('__delete__', False)
            if 'id' in dictionary:
                subinst = get_by(self.session, submodel, dictionary['id'])
            else:
                subinst = self.query(submodel).filter_by(**dictionary).first()
            for instance in query:
                getattr(instance, relationname).remove(subinst)
            if remove:
                self.session.delete(subinst)

    def _set_on_relation(self, query, relationname, toset=None):
        """Sets the value of the relation specified by `relationname` on each
        instance specified by `query` to have the new or existing related
        models specified by `toset`.

        This function does not commit the changes made to the database. The
        calling function has that responsibility.

        `query` is a SQLAlchemy query instance that evaluates to all instances
        of the model specified in the constructor of this class that should be
        updated.

        `relationname` is the name of a one-to-many relationship which exists
        on each model specified in `query`.

        `toset` is either a dictionary or a list of dictionaries, each
        representing the attributes of an existing or new related model to
        set. If a dictionary contains the key ``'id'``, that instance of the
        related model will be added. Otherwise, the
        :func:`helpers.get_or_create` method will be used to get or create a
        model to set.

        """
        submodel = get_related_model(self.model, relationname)
        if isinstance(toset, list):
            value = [get_or_create(self.session, submodel, d) for d in toset]
        else:
            value = get_or_create(self.session, submodel, toset)
        for instance in query:
            setattr(instance, relationname, value)

    # TODO change this to have more sensible arguments
    def _update_relations(self, query, params):
        """Adds, removes, or sets models which are related to the model
        specified in the constructor of this class.

        This function does not commit the changes made to the database. The
        calling function has that responsibility.

        This method returns a :class:`frozenset` of strings representing the
        names of relations which were modified.

        `query` is a SQLAlchemy query instance that evaluates to all instances
        of the model specified in the constructor of this class that should be
        updated.

        `params` is a dictionary containing a mapping from name of the relation
        to modify (as a string) to either a list or another dictionary. In the
        former case, the relation will be assigned the instances specified by
        the elements of the list, which are dictionaries as described below.
        In the latter case, the inner dictionary contains at most two mappings,
        one with the key ``'add'`` and one with the key ``'remove'``. Each of
        these is a mapping to a list of dictionaries which represent the
        attributes of the object to add to or remove from the relation.

        If one of the dictionaries specified in ``add`` or ``remove`` (or the
        list to be assigned) includes an ``id`` key, the object with that
        ``id`` will be attempt to be added or removed. Otherwise, an existing
        object with the specified attribute values will be attempted to be
        added or removed. If adding, a new object will be created if a matching
        object could not be found in the database.

        If a dictionary in one of the ``'remove'`` lists contains a mapping
        from ``'__delete__'`` to ``True``, then the removed object will be
        deleted after being removed from each instance of the model in the
        specified query.

        """
        relations = get_relations(self.model)
        tochange = frozenset(relations) & frozenset(params)
        for columnname in tochange:
            # Check if 'add' or 'remove' is being used
            if (isinstance(params[columnname], dict)
                and any(k in params[columnname] for k in ['add', 'remove'])):

                toadd = params[columnname].get('add', [])
                toremove = params[columnname].get('remove', [])
                self._add_to_relation(query, columnname, toadd=toadd)
                self._remove_from_relation(query, columnname,
                                           toremove=toremove)
            else:
                toset = params[columnname]
                self._set_on_relation(query, columnname, toset=toset)

        return tochange

    def _handle_validation_exception(self, exception):
        """Rolls back the session, extracts validation error messages, and
        returns a :func:`flask.jsonify` response with :http:statuscode:`400`
        containing the extracted validation error messages.

        Again, *this method calls
        :meth:`sqlalchemy.orm.session.Session.rollback`*.

        """
        self.session.rollback()
        errors = self._extract_error_messages(exception) or \
            'Could not determine specific validation errors'
        return dict(validation_errors=errors), 400

    def _extract_error_messages(self, exception):
        """Tries to extract a dictionary mapping field name to validation error
        messages from `exception`, which is a validation exception as provided
        in the ``validation_exceptions`` keyword argument in the constructor of
        this class.

        Since the type of the exception is provided by the user in the
        constructor of this class, we don't know for sure where the validation
        error messages live inside `exception`. Therefore this method simply
        attempts to access a few likely attributes and returns the first one it
        finds (or ``None`` if no error messages dictionary can be extracted).

        """
        # 'errors' comes from sqlalchemy_elixir_validations
        if hasattr(exception, 'errors'):
            return exception.errors
        # 'message' comes from savalidation
        if hasattr(exception, 'message'):
            # TODO this works only if there is one validation error
            try:
                left, right = str(exception).rsplit(':', 1)
                left_bracket = left.rindex('[')
                right_bracket = right.rindex(']')
            except ValueError as exception:
                current_app.logger.exception(str(exception))
                # could not parse the string; we're not trying too hard here...
                return None
            msg = right[:right_bracket].strip(' "')
            fieldname = left[left_bracket + 1:].strip()
            return {fieldname: msg}
        return None

    def _compute_results_per_page(self):
        """Helper function which returns the number of results per page based
        on the request argument ``results_per_page`` and the server
        configuration parameters :attr:`results_per_page` and
        :attr:`max_results_per_page`.

        """
        try:
            results_per_page = int(request.args.get('results_per_page'))
        except:
            results_per_page = self.results_per_page
        if results_per_page <= 0:
            results_per_page = self.results_per_page
        return min(results_per_page, self.max_results_per_page)

    # TODO it is ugly to have `deep` as an arg here; can we remove it?
    def _paginated(self, instances, deep):
        """Returns a paginated JSONified response from the specified list of
        model instances.

        `instances` is either a Python list of model instances or a
        :class:`~sqlalchemy.orm.Query`.

        `deep` is the dictionary which defines the depth of submodels to output
        in the JSON format of the model instances in `instances`; it is passed
        directly to :func:`helpers.to_dict`.

        The response data is JSON of the form:

        .. sourcecode:: javascript

           {
             "page": 2,
             "total_pages": 3,
             "num_results": 8,
             "objects": [{"id": 1, "name": "Jeffrey", "age": 24}, ...]
           }

        """
        if isinstance(instances, list):
            num_results = len(instances)
        else:
            num_results = count(self.session, instances)
        results_per_page = self._compute_results_per_page()
        if results_per_page > 0:
            # get the page number (first page is page 1)
            page_num = int(request.args.get('page', 1))
            start = (page_num - 1) * results_per_page
            end = min(num_results, start + results_per_page)
            total_pages = int(math.ceil(num_results / results_per_page))
        else:
            page_num = 1
            start = 0
            end = num_results
            total_pages = 1
        objects = [to_dict(x, deep, exclude=self.exclude_columns,
                           exclude_relations=self.exclude_relations,
                           include=self.include_columns,
                           include_relations=self.include_relations,
                           include_methods=self.include_methods)
                   for x in instances[start:end]]
        return dict(page=page_num, objects=objects, total_pages=total_pages,
                    num_results=num_results)

    def _inst_to_dict(self, inst):
        """Returns the dictionary representation of the specified instance.

        This method respects the include and exclude columns specified in the
        constructor of this class.

        """
        # create a placeholder for the relations of the returned models
        relations = frozenset(get_relations(self.model))
        # do not follow relations that will not be included in the response
        if self.include_columns is not None:
            cols = frozenset(self.include_columns)
            rels = frozenset(self.include_relations)
            relations &= (cols | rels)
        elif self.exclude_columns is not None:
            relations -= frozenset(self.exclude_columns)
        deep = dict((r, {}) for r in relations)
        return to_dict(inst, deep, exclude=self.exclude_columns,
                       exclude_relations=self.exclude_relations,
                       include=self.include_columns,
                       include_relations=self.include_relations,
                       include_methods=self.include_methods)

    def _instid_to_dict(self, instid):
        """Returns the dictionary representation of the instance specified by
        `instid`.

        If no such instance of the model exists, this method aborts with a
        :http:statuscode:`404`.

        """
        inst = get_by(self.session, self.model, instid, self.primary_key)
        if inst is None:
            return {_STATUS: 404}, 404
        return self._inst_to_dict(inst)

    def _search(self):
        """Defines a generic search function for the database model.

        If the query string is empty, or if the specified query is invalid for
        some reason (for example, searching for all person instances with), the
        response will be the JSON string ``{"objects": []}``.

        To search for entities meeting some criteria, the client makes a
        request to :http:get:`/api/<modelname>` with a query string containing
        the parameters of the search. The parameters of the search can involve
        filters. In a filter, the client specifies the name of the field by
        which to filter, the operation to perform on the field, and the value
        which is the argument to that operation. In a function, the client
        specifies the name of a SQL function which is executed on the search
        results; the result of executing the function is returned to the
        client.

        The parameters of the search must be provided in JSON form as the value
        of the ``q`` request query parameter. For example, in a database of
        people, to search for all people with a name containing a "y", the
        client would make a :http:method:`get` request to ``/api/person`` with
        query parameter as follows::

            q={"filters": [{"name": "name", "op": "like", "val": "%y%"}]}

        If multiple objects meet the criteria of the search, the response has
        :http:status:`200` and content of the form::

        .. sourcecode:: javascript

           {"objects": [{"name": "Mary"}, {"name": "Byron"}, ...]}

        If the result of the search is a single instance of the model, the JSON
        representation of that instance would be the top-level object in the
        content of the response::

        .. sourcecode:: javascript

           {"name": "Mary", ...}

        For more information SQLAlchemy operators for use in filters, see the
        `SQLAlchemy SQL expression tutorial
        <http://docs.sqlalchemy.org/en/latest/core/tutorial.html>`_.

        The general structure of request data as a JSON string is as follows::

        .. sourcecode:: javascript

           {
             "single": true,
             "order_by": [{"field": "age", "direction": "asc"}],
             "limit": 2,
             "offset": 1,
             "disjunction": true,
             "filters":
               [
                 {"name": "name", "val": "%y%", "op": "like"},
                 {"name": "age", "val": [18, 19, 20, 21], "op": "in"},
                 {"name": "age", "op": "gt", "field": "height"},
                 ...
               ]
           }

        For a complete description of all possible search parameters and
        responses, see :ref:`searchformat`.

        """
        # try to get search query from the request query parameters
        try:
            search_params = json.loads(request.args.get('q', '{}'))
        except (TypeError, ValueError, OverflowError) as exception:
            current_app.logger.exception(str(exception))
            return dict(message='Unable to decode data'), 400

        for preprocessor in self.preprocessors['GET_MANY']:
            preprocessor(search_params=search_params)

        # perform a filtered search
        try:
            result = search(self.session, self.model, search_params)
        except NoResultFound:
            return dict(message='No result found'), 404
        except MultipleResultsFound:
            return dict(message='Multiple results found'), 400
        except Exception as exception:
            current_app.logger.exception(str(exception))
            return dict(message='Unable to construct query'), 400

        # create a placeholder for the relations of the returned models
        relations = frozenset(get_relations(self.model))
        # do not follow relations that will not be included in the response
        if self.include_columns is not None:
            cols = frozenset(self.include_columns)
            rels = frozenset(self.include_relations)
            relations &= (cols | rels)
        elif self.exclude_columns is not None:
            relations -= frozenset(self.exclude_columns)
        deep = dict((r, {}) for r in relations)

        # for security purposes, don't transmit list as top-level JSON
        if isinstance(result, Query):
            result = self._paginated(result, deep)
            # Create the Link header.
            #
            # TODO We are already calling self._compute_results_per_page() once
            # in _paginated(); don't compute it again here.
            page, last_page = result['page'], result['total_pages']
            linkstring = create_link_string(page, last_page,
                                            self._compute_results_per_page())
            headers = dict(Link=linkstring)
        else:
            primary_key = primary_key_name(result)
            result = to_dict(result, deep, exclude=self.exclude_columns,
                             exclude_relations=self.exclude_relations,
                             include=self.include_columns,
                             include_relations=self.include_relations,
                             include_methods=self.include_methods)
            # The URL at which a client can access the instance matching this
            # search query.
            url = '{0}/{1}'.format(request.base_url, result[primary_key])
            headers = dict(Location=url)

        for postprocessor in self.postprocessors['GET_MANY']:
            postprocessor(result=result, search_params=search_params)

        # HACK Provide the headers directly in the result dictionary, so that
        # the :func:`jsonpify` function has access to them. See the note there
        # for more information.
        result[_HEADERS] = headers
        return result, 200, headers

    def get(self, instid, relationname, relationinstid):
        """Returns a JSON representation of an instance of model with the
        specified name.

        If ``instid`` is ``None``, this method returns the result of a search
        with parameters specified in the query string of the request. If no
        search parameters are specified, this method returns all instances of
        the specified model.

        If ``instid`` is an integer, this method returns the instance of the
        model with that identifying integer. If no such instance exists, this
        method responds with :http:status:`404`.

        """
        if instid is None:
            return self._search()
        for preprocessor in self.preprocessors['GET_SINGLE']:
            preprocessor(instance_id=instid)
        # get the instance of the "main" model whose ID is instid
        instance = get_by(self.session, self.model, instid, self.primary_key)
        if instance is None:
            return {_STATUS: 404}, 404
        # If no relation is requested, just return the instance. Otherwise,
        # get the value of the relation specified by `relationname`.
        if relationname is None:
            result = self._inst_to_dict(instance)
        else:
            related_value = getattr(instance, relationname)
            # create a placeholder for the relations of the returned models
            related_model = get_related_model(self.model, relationname)
            relations = frozenset(get_relations(related_model))
            deep = dict((r, {}) for r in relations)
            if relationinstid is not None:
                related_value_instance = get_by(self.session, related_model,
                                                relationinstid)
                if related_value_instance is None:
                    return {_STATUS: 404}, 404
                result = to_dict(related_value_instance, deep)
            else:
                # for security purposes, don't transmit list as top-level JSON
                if is_like_list(instance, relationname):
                    result = self._paginated(list(related_value), deep)
                else:
                    result = to_dict(related_value, deep)
        if result is None:
            return {_STATUS: 404}, 404
        for postprocessor in self.postprocessors['GET_SINGLE']:
            postprocessor(result=result)
        return result

    def delete(self, instid, relationname, relationinstid):
        """Removes the specified instance of the model with the specified name
        from the database.

        Since :http:method:`delete` is an idempotent method according to the
        :rfc:`2616`, this method responds with :http:status:`204` regardless of
        whether an object was deleted.

        If `relationname

        .. versionadded:: 0.12.0
           Added the `relationinstid` keyword argument.

        .. versionadded:: 0.10.0
           Added the `relationname` keyword argument.

        """
        is_deleted = False
        for preprocessor in self.preprocessors['DELETE']:
            preprocessor(instance_id=instid, relation_name=relationname,
                         relation_instance_id=relationinstid)
        inst = get_by(self.session, self.model, instid, self.primary_key)
        if relationname:
            # If the request is ``DELETE /api/person/1/computers``, error 400.
            if not relationinstid:
                msg = ('Cannot DELETE entire "{0}"'
                       ' relation').format(relationname)
                return dict(message=msg), 400
            # Otherwise, get the related instance to delete.
            relation = getattr(inst, relationname)
            related_model = get_related_model(self.model, relationname)
            relation_instance = get_by(self.session, related_model,
                                       relationinstid)
            # Removes an object from the relation list.
            relation.remove(relation_instance)
        elif inst is not None:
            self.session.delete(inst)
            self.session.commit()
            is_deleted = True
        for postprocessor in self.postprocessors['DELETE']:
            postprocessor(is_deleted=is_deleted)
        return {}, 204

    def post(self):
        """Creates a new instance of a given model based on request data.

        This function parses the string contained in
        :attr:`flask.request.data`` as a JSON object and then validates it with
        a validator specified in the constructor of this class.

        The :attr:`flask.request.data` attribute will be parsed as a JSON
        object containing the mapping from field name to value to which to
        initialize the created instance of the model.

        After that, it separates all columns that defines relationships with
        other entities, creates a model with the simple columns and then
        creates instances of these submodels and associates them with the
        related fields. This happens only at the first level of nesting.

        Currently, this method can only handle instantiating a model with a
        single level of relationship data.

        """
        content_type = request.headers.get('Content-Type', None)
        content_is_json = content_type.startswith('application/json')
        is_msie = _is_msie8or9()
        # Request must have the Content-Type: application/json header, unless
        # the User-Agent string indicates that the client is Microsoft Internet
        # Explorer 8 or 9 (which has a fixed Content-Type of 'text/html'; see
        # issue #267).
        if not is_msie and not content_is_json:
            msg = 'Request must have "Content-Type: application/json" header'
            return dict(message=msg), 415

        # try to read the parameters for the model from the body of the request
        try:
            # HACK Requests made from Internet Explorer 8 or 9 don't have the
            # correct content type, so request.get_json() doesn't work.
            if is_msie:
                params = json.loads(request.get_data()) or {}
            else:
                params = request.get_json() or {}
        except (BadRequest, TypeError, ValueError, OverflowError) as exception:
            current_app.logger.exception(str(exception))
            return dict(message='Unable to decode data'), 400

        # apply any preprocessors to the POST arguments
        for preprocessor in self.preprocessors['POST']:
            preprocessor(data=params)

        # Check for any request parameter naming a column which does not exist
        # on the current model.
        for field in params:
            if not has_field(self.model, field):
                msg = "Model does not have field '{0}'".format(field)
                return dict(message=msg), 400

        # Getting the list of relations that will be added later
        cols = get_columns(self.model)
        relations = get_relations(self.model)

        # Looking for what we're going to set on the model right now
        colkeys = cols.keys()
        paramkeys = params.keys()
        props = set(colkeys).intersection(paramkeys).difference(relations)

        # Special case: if there are any dates, convert the string form of the
        # date into an instance of the Python ``datetime`` object.
        params = strings_to_dates(self.model, params)

        try:
            # Instantiate the model with the parameters.
            modelargs = dict([(i, params[i]) for i in props])
            instance = self.model(**modelargs)

            # Handling relations, a single level is allowed
            for col in set(relations).intersection(paramkeys):
                submodel = get_related_model(self.model, col)

                if type(params[col]) == list:
                    # model has several related objects
                    for subparams in params[col]:
                        subinst = get_or_create(self.session, submodel,
                                                subparams)
                        try:
                            getattr(instance, col).append(subinst)
                        except AttributeError:
                            attribute = getattr(instance, col)
                            attribute[subinst.key] = subinst.value
                else:
                    # model has single related object
                    subinst = get_or_create(self.session, submodel,
                                            params[col])
                    setattr(instance, col, subinst)

            # add the created model to the session
            self.session.add(instance)
            self.session.commit()
            result = self._inst_to_dict(instance)

            primary_key = str(result[primary_key_name(instance)])

            # The URL at which a client can access the newly created instance
            # of the model.

            url = '{0}/{1}'.format(request.base_url, primary_key)
            # Provide that URL in the Location header in the response.
            headers = dict(Location=url)

            for postprocessor in self.postprocessors['POST']:
                postprocessor(result=result)

            return result, 201, headers
        except self.validation_exceptions as exception:
            return self._handle_validation_exception(exception)
        except (DataError, IntegrityError, ProgrammingError) as exception:
            self.session.rollback()
            current_app.logger.exception(str(exception))
            return dict(message=str(exception)), 400

    def patch(self, instid, relationname, relationinstid):
        """Updates the instance specified by ``instid`` of the named model, or
        updates multiple instances if ``instid`` is ``None``.

        The :attr:`flask.request.data` attribute will be parsed as a JSON
        object containing the mapping from field name to value to which to
        update the specified instance or instances.

        If ``instid`` is ``None``, the query string will be used to search for
        instances (using the :func:`_search` method), and all matching
        instances will be updated according to the content of the request data.
        See the :func:`_search` documentation on more information about search
        parameters for restricting the set of instances on which updates will
        be made in this case.

        This function ignores the `relationname` and `relationinstid` keyword
        arguments.

        .. versionadded:: 0.12.0
           Added the `relationinstid` keyword argument.

        .. versionadded:: 0.10.0
           Added the `relationname` keyword argument.

        """
        content_type = request.headers.get('Content-Type', None)
        content_is_json = content_type.startswith('application/json')
        is_msie = _is_msie8or9()
        # Request must have the Content-Type: application/json header, unless
        # the User-Agent string indicates that the client is Microsoft Internet
        # Explorer 8 or 9 (which has a fixed Content-Type of 'text/html'; see
        # issue #267).
        if not is_msie and not content_is_json:
            msg = 'Request must have "Content-Type: application/json" header'
            return dict(message=msg), 415

        # try to load the fields/values to update from the body of the request
        try:
            # HACK Requests made from Internet Explorer 8 or 9 don't have the
            # correct content type, so request.get_json() doesn't work.
            if is_msie:
                data = json.loads(request.get_data()) or {}
            else:
                data = request.get_json() or {}
        except (BadRequest, TypeError, ValueError, OverflowError) as exception:
            # this also happens when request.data is empty
            current_app.logger.exception(str(exception))
            return dict(message='Unable to decode data'), 400

        # Check if the request is to patch many instances of the current model.
        patchmany = instid is None
        # Perform any necessary preprocessing.
        if patchmany:
            # Get the search parameters; all other keys in the `data`
            # dictionary indicate a change in the model's field.
            search_params = data.pop('q', {})
            for preprocessor in self.preprocessors['PATCH_MANY']:
                preprocessor(search_params=search_params, data=data)
        else:
            for preprocessor in self.preprocessors['PATCH_SINGLE']:
                preprocessor(instance_id=instid, data=data)

        # Check for any request parameter naming a column which does not exist
        # on the current model.
        for field in data:
            if not has_field(self.model, field):
                msg = "Model does not have field '{0}'".format(field)
                return dict(message=msg), 400

        if patchmany:
            try:
                # create a SQLALchemy Query from the query parameter `q`
                query = create_query(self.session, self.model, search_params)
            except Exception as exception:
                current_app.logger.exception(str(exception))
                return dict(message='Unable to construct query'), 400
        else:
            # create a SQLAlchemy Query which has exactly the specified row
            query = query_by_primary_key(self.session, self.model, instid)
            if query.count() == 0:
                return {_STATUS: 404}, 404
            assert query.count() == 1, 'Multiple rows with same ID'

        relations = self._update_relations(query, data)
        field_list = frozenset(data) ^ relations
        data = dict((field, data[field]) for field in field_list)

        # Special case: if there are any dates, convert the string form of the
        # date into an instance of the Python ``datetime`` object.
        data = strings_to_dates(self.model, data)

        try:
            # Let's update all instances present in the query
            num_modified = 0
            if data:
                for item in query.all():
                    for field, value in data.items():
                        setattr(item, field, value)
                    num_modified += 1
            self.session.commit()
        except self.validation_exceptions as exception:
            current_app.logger.exception(str(exception))
            return self._handle_validation_exception(exception)
        except (DataError, IntegrityError, ProgrammingError) as exception:
            current_app.logger.exception(str(exception))
            return dict(message=str(exception)), 400

        # Perform any necessary postprocessing.
        if patchmany:
            result = dict(num_modified=num_modified)
            for postprocessor in self.postprocessors['PATCH_MANY']:
                postprocessor(query=query, result=result,
                              search_params=search_params)
        else:
            result = self._instid_to_dict(instid)
            for postprocessor in self.postprocessors['PATCH_SINGLE']:
                postprocessor(result=result)

        return result

    def put(self, *args, **kw):
        """Alias for :meth:`patch`."""
        return self.patch(*args, **kw)

########NEW FILE########
__FILENAME__ = make-release
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    make-release
    ~~~~~~~~~~~~

    Helper script that performs a release.  Does pretty much everything
    automatically for us.

    :copyright: (c) 2011 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""
import sys
import os
import re
from datetime import datetime, date
from subprocess import Popen, PIPE

_date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')


def add_new_changelog_section(current_version, next_version):
    version_string = 'Version {}'.format(current_version)
    with open('CHANGES') as f:
        all_lines = f.readlines()
    stripped_lines = [l.strip() for l in all_lines]
    try:
        # get the index of the first occurrence of `version_string`
        line_num = stripped_lines.index(version_string)
    except:
        fail('Could not find "{}" in {}.'.format(version_string, 'CHANGES'))
    new_header = 'Version {}'.format(next_version)
    horizontal_rule = '-' * len(new_header)
    new_lines = [new_header + '\n', horizontal_rule + '\n', '\n',
                 'Not yet released.' + '\n', '\n']
    # insert the new lines into the list of all lines read from CHANGES
    all_lines[line_num:line_num] = new_lines
    # write the changes back to...CHANGES
    with open('CHANGES', 'w') as f:
        f.writelines(all_lines)


def parse_changelog():
    with open('CHANGES') as f:
        lineiter = iter(f)
        for line in lineiter:
            match = re.search('^Version\s+(.*)', line.strip())
            if match is None:
                continue
            #length = len(match.group(1))
            version = match.group(1).strip()
            if lineiter.next().count('-') != len(match.group(0)):
                continue
            while 1:
                change_info = lineiter.next().strip()
                if change_info:
                    break

            match = re.search(r'Released on (\w+\s+\d+,\s+\d+)',
                              change_info)
            if match is None:
                continue

            datestr = match.groups()[0]
            return version, parse_date(datestr)


def bump_version(version):
    try:
        parts = map(int, version.split('.'))
    except ValueError:
        fail('Current version is not numeric')
    if sys.argv[1] == 'major':
        parts = [parts[0] + 1, 0, 0]
    elif sys.argv[1] == 'minor':
        parts = [parts[0], parts[1] + 1, 0]
    else:
        parts[-1] += 1
    return '.'.join(map(str, parts))


def parse_date(string):
    string = _date_clean_re.sub(r'\1', string)
    return datetime.strptime(string, '%B %d, %Y')


def set_filename_version(filename, version_number, pattern):
    changed = []
    def inject_version(match):
        before, old, after = match.groups()
        changed.append(True)
        return before + version_number + after
    with open(filename) as f:
        contents = re.sub(r"^(\s*%s\s*=\s*')(.+?)(')(?sm)" % pattern,
                          inject_version, f.read())

    if not changed:
        fail('Could not find %s in %s', pattern, filename)

    with open(filename, 'w') as f:
        f.write(contents)


def set_init_version(version):
    info('Setting __init__.py version to %s', version)
    set_filename_version('flask_restless/__init__.py', version, '__version__')


def set_setup_version(version):
    info('Setting setup.py version to %s', version)
    set_filename_version('setup.py', version, 'version')


def build_and_upload():
    Popen([sys.executable, 'setup.py', 'release', 'sdist', 'upload', '--sign']).wait()


def fail(message, *args):
    print >> sys.stderr, 'Error:', message % args
    sys.exit(1)


def info(message, *args):
    print >> sys.stderr, message % args


def get_git_tags():
    process = Popen(['git', 'tag'], stdout=PIPE)
    return set(process.communicate()[0].splitlines())


def git_is_clean():
    return Popen(['git', 'diff', '--quiet']).wait() == 0


def make_git_commit(message, *args):
    message = message % args
    Popen(['git', 'commit', '-am', message]).wait()


def make_git_tag(tag):
    info('Tagging "%s"', tag)
    msg = '"Released version {}"'.format(tag)
    Popen(['git', 'tag', '-s', '-m', msg, tag]).wait()


def main():
    os.chdir(os.path.join(os.path.dirname(__file__), '..'))

    rv = parse_changelog()
    if rv is None:
        fail('Could not parse changelog')

    version, release_date = rv
    dev_version = bump_version(version) + '-dev'

    info('Releasing %s (release date %s)',
         version, release_date.strftime('%d/%m/%Y'))
    tags = get_git_tags()

    if version in tags:
        fail('Version "%s" is already tagged', version)
    if release_date.date() != date.today():
        fail('Release date is not today (%s != %s)')

    if not git_is_clean():
        fail('You have uncommitted changes in git')

    set_init_version(version)
    set_setup_version(version)
    make_git_commit('Bump version number to %s', version)
    make_git_tag(version)
    build_and_upload()
    set_init_version(dev_version)
    set_setup_version(dev_version)
    add_new_changelog_section(version, dev_version)
    make_git_commit('Set development version number to %s', dev_version)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = set-version
def set_filename_version(filename, version_number, pattern):
    changed = []
    def inject_version(match):
        before, old, after = match.groups()
        changed.append(True)
        return before + version_number + after
    with open(filename) as f:
        contents = re.sub(r"^(\s*%s\s*=\s*')(.+?)(')(?sm)" % pattern,
                          inject_version, f.read())

    if not changed:
        fail('Could not find %s in %s', pattern, filename)

    with open(filename, 'w') as f:
        f.write(contents)


def set_changelog_version(version):
    info('Setting CHANGES version to %s', version)
    # TODO this won't work...
    set_filename_version('CHANGES', version, 'Version')

def set_init_version(version):
    info('Setting __init__.py version to %s', version)
    set_filename_version('flask_restless/__init__.py', version, '__version__')


def set_setup_version(version):
    info('Setting setup.py version to %s', version)
    set_filename_version('setup.py', version, 'version')

########NEW FILE########
__FILENAME__ = helpers
"""
    tests.helpers
    ~~~~~~~~~~~~~

    Provides helper functions for unit tests in this package.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import datetime
import uuid

from flask import Flask
from nose import SkipTest
from sqlalchemy import Boolean
from sqlalchemy import Column
from sqlalchemy import create_engine
from sqlalchemy import Date
from sqlalchemy import DateTime
from sqlalchemy import Float
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import Interval
from sqlalchemy import Time
from sqlalchemy import Unicode
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import backref
from sqlalchemy.orm import relationship
from sqlalchemy.orm import scoped_session
from sqlalchemy.orm import sessionmaker
from sqlalchemy.types import CHAR
from sqlalchemy.types import TypeDecorator
from sqlalchemy.ext.associationproxy import association_proxy


from flask.ext.restless import APIManager


def skip_unless(condition, reason=None):
    """Decorator that skips `test` unless `condition` is ``True``.

    This is a replacement for :func:`unittest.skipUnless` that works with
    ``nose``. The argument ``reason`` is a string describing why the test was
    skipped.

    """
    def skip(test):
        message = 'Skipped {0}: {1}'.format(test.__name__, reason)

        # TODO Since we don't check the case in which `test` is a class, the
        # result of running the tests will be a single skipped test, although
        # it should show one skip for each test method within the class.
        def inner(*args, **kw):
            if not condition:
                raise SkipTest(message)
            return test(*args, **kw)
        inner.__name__ = test.__name__
        return inner
    return skip


# This code adapted from
# http://docs.sqlalchemy.org/en/rel_0_8/core/types.html#backend-agnostic-guid-type
class GUID(TypeDecorator):
    """Platform-independent GUID type.

    Uses Postgresql's UUID type, otherwise uses CHAR(32), storing as
    stringified hex values.

    """
    impl = CHAR

    def load_dialect_impl(self, dialect):
        descriptor = UUID() if dialect.name == 'postgresql' else CHAR(32)
        return dialect.type_descriptor(descriptor)

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        if dialect.name == 'postgresql':
            return str(value)
        if not isinstance(value, uuid.UUID):
            return '{0:.32x}'.format(uuid.UUID(value))
        # hexstring
        return '{0:.32x}'.format(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return uuid.UUID(value)


class FlaskTestBase(object):
    """Base class for tests which use a Flask application.

    The Flask test client can be accessed at ``self.app``. The Flask
    application itself is accessible at ``self.flaskapp``.

    """

    def setUp(self):
        """Creates the Flask application and the APIManager."""
        # create the Flask application
        app = Flask(__name__)
        app.config['DEBUG'] = True
        app.config['TESTING'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
        app.logger.disabled = True
        self.flaskapp = app

        # create the test client
        self.app = app.test_client()

        # Ensure that all requests have Content-Type set to "application/json"
        # unless otherwise specified.
        for methodname in ('get', 'put', 'patch', 'post', 'delete'):
            # Create a decorator for the test client request methods that adds
            # a JSON Content-Type by default if none is specified.
            def set_content_type(func):
                def new_func(*args, **kw):
                    if 'content_type' not in kw:
                        kw['content_type'] = 'application/json'
                    return func(*args, **kw)
                return new_func
            # Decorate the original test client request method.
            old_method = getattr(self.app, methodname)
            setattr(self.app, methodname, set_content_type(old_method))


class DatabaseTestBase(FlaskTestBase):
    """Base class for tests which use a database and have an
    :class:`flask_restless.APIManager`.

    The :meth:`setUp` method does the necessary SQLAlchemy initialization, and
    the subclasses should populate the database with models and then create the
    database (by calling ``self.Base.metadata.create_all()``).

    The :class:`flask_restless.APIManager` is accessible at ``self.manager``.

    """

    def setUp(self):
        """Initializes the components necessary for models in a SQLAlchemy
        database, as well as for Flask-Restless.

        """
        super(DatabaseTestBase, self).setUp()

        # initialize SQLAlchemy and Flask-Restless
        app = self.flaskapp
        engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'],
                               convert_unicode=True)
        self.Session = sessionmaker(autocommit=False, autoflush=False,
                                    bind=engine)
        self.session = scoped_session(self.Session)
        self.Base = declarative_base()
        self.Base.metadata.bind = engine
        #Base.query = self.session.query_property()
        self.manager = APIManager(app, self.session)


class TestSupport(DatabaseTestBase):
    """Base class for test cases which use a database with some basic models.

    """

    def setUp(self):
        """Creates some example models and creates the database tables.

        This class defines a whole bunch of models with various properties for
        use in testing, so look here first when writing new tests.

        """
        super(TestSupport, self).setUp()

        # declare the models
        class Program(self.Base):
            __tablename__ = 'program'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode, unique=True)

        class ComputerProgram(self.Base):
            __tablename__ = 'computer_program'
            computer_id = Column(Integer, ForeignKey('computer.id'),
                                 primary_key=True)
            program_id = Column(Integer, ForeignKey('program.id'),
                                primary_key=True)
            licensed = Column(Boolean, default=False)
            program = relationship('Program')

        class Computer(self.Base):
            __tablename__ = 'computer'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode, unique=True)
            vendor = Column(Unicode)
            buy_date = Column(DateTime)
            owner_id = Column(Integer, ForeignKey('person.id'))
            owner = relationship('Person')
            programs = relationship('ComputerProgram',
                                    cascade="all, delete-orphan")

            def speed(self):
                return 42

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode, unique=True)
            age = Column(Integer)
            other = Column(Float)
            birth_date = Column(Date)
            computers = relationship('Computer')

            @hybrid_property
            def is_minor(self):
                if getattr(self, 'age') is None:
                    return None
                return self.age < 18

            def name_and_age(self):
                return "{0} (aged {1:d})".format(self.name, self.age)

            def first_computer(self):
                return sorted(self.computers, key=lambda k: k.name)[0]

        class LazyComputer(self.Base):
            __tablename__ = 'lazycomputer'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)
            ownerid = Column(Integer, ForeignKey('lazyperson.id'))
            owner = relationship('LazyPerson',
                                 backref=backref('computers', lazy='dynamic'))

        class LazyPerson(self.Base):
            __tablename__ = 'lazyperson'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)

        class User(self.Base):
            __tablename__ = 'user'
            id = Column(Integer, primary_key=True)
            email = Column(Unicode, primary_key=True)
            wakeup = Column(Time)

        class Planet(self.Base):
            __tablename__ = 'planet'
            name = Column(Unicode, primary_key=True)

        class Satellite(self.Base):
            __tablename__ = 'satellite'
            name = Column(Unicode, primary_key=True)
            period = Column(Interval, nullable=True)

        class Star(self.Base):
            __tablename__ = 'star'
            id = Column("star_id", Integer, primary_key=True)
            inception_time = Column(DateTime, nullable=True)

        class Vehicle(self.Base):
            __tablename__ = 'vehicle'
            uuid = Column(GUID, primary_key=True)

        class CarModel(self.Base):
            __tablename__ = 'car_model'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)
            seats = Column(Integer)

            manufacturer_id = Column(Integer,
                                     ForeignKey('car_manufacturer.id'))
            manufacturer = relationship('CarManufacturer')

        class CarManufacturer(self.Base):
            __tablename__ = 'car_manufacturer'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)
            models = relationship('CarModel')

        class Project(self.Base):
            __tablename__ = 'project'
            id = Column(Integer, primary_key=True)
            person_id = Column(Integer, ForeignKey('person.id'))
            person = relationship('Person',
                                 backref=backref('projects', lazy='dynamic'))

        class Proof(self.Base):
            __tablename__ = 'proof'
            id = Column(Integer, primary_key=True)
            project = relationship('Project', backref=backref('proofs', lazy='dynamic'))
            project_id = Column(Integer, ForeignKey('project.id'))
            person = association_proxy('project', 'person')
            person_id = association_proxy('project', 'person_id')

        self.Person = Person
        self.Program = Program
        self.ComputerProgram = ComputerProgram
        self.LazyComputer = LazyComputer
        self.LazyPerson = LazyPerson
        self.User = User
        self.Computer = Computer
        self.Planet = Planet
        self.Satellite = Satellite
        self.Star = Star
        self.Vehicle = Vehicle
        self.CarManufacturer = CarManufacturer
        self.CarModel = CarModel
        self.Project = Project
        self.Proof = Proof

        # create all the tables required for the models
        self.Base.metadata.create_all()

    def tearDown(self):
        """Drops all tables from the temporary database."""
        #self.session.remove()
        self.Base.metadata.drop_all()


class TestSupportPrefilled(TestSupport):
    """Base class for tests which use a database and have an
    :class:`flask_restless.APIManager` with a :class:`flask.Flask` app object.

    The test client for the :class:`flask.Flask` application is accessible to
    test functions at ``self.app`` and the :class:`flask_restless.APIManager`
    is accessible at ``self.manager``.

    The database will be prepopulated with five ``Person`` objects. The list of
    these objects can be accessed at ``self.people``.

    """

    def setUp(self):
        """Creates the database, the Flask application, and the APIManager."""
        # create the database
        super(TestSupportPrefilled, self).setUp()
        # create some people in the database for testing
        lincoln = self.Person(name=u'Lincoln', age=23, other=22,
                              birth_date=datetime.date(1900, 1, 2))
        mary = self.Person(name=u'Mary', age=19, other=19)
        lucy = self.Person(name=u'Lucy', age=25, other=20)
        katy = self.Person(name=u'Katy', age=7, other=10)
        john = self.Person(name=u'John', age=28, other=10)
        self.people = [lincoln, mary, lucy, katy, john]
        self.session.add_all(self.people)
        self.session.commit()

########NEW FILE########
__FILENAME__ = test_helpers
"""
    tests.test_helpers
    ~~~~~~~~~~~~~~~~~~

    Provides unit tests for the :mod:`flask_restless.helpers` module.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from datetime import date
from datetime import datetime
import uuid

from nose.tools import assert_raises
from sqlalchemy import Column
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import relationship

from flask.ext.restless.helpers import evaluate_functions
from flask.ext.restless.helpers import get_columns
from flask.ext.restless.helpers import get_relations
from flask.ext.restless.helpers import partition
from flask.ext.restless.helpers import primary_key_name
from flask.ext.restless.helpers import to_dict
from flask.ext.restless.helpers import upper_keys
from flask.ext.restless.helpers import get_by
from flask.ext.restless.helpers import is_like_list

from .helpers import TestSupport
from .helpers import TestSupportPrefilled
from .helpers import DatabaseTestBase


class TestSessionQuery(DatabaseTestBase):
    """Unit test for the :func:`session_query` function."""

    def setUp(self):
        """Creates example tables to test the various behaviours of
        :func:`session_query`.

        """
        super(TestSessionQuery, self).setUp()

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            family_id = Column(Integer, ForeignKey('family.id'))
            family = relationship('Family')

            @classmethod
            def query(cls):
                person = self.session.query(Person)
                return person.join((Family, Person.family_id == Family.id))

        class Family(self.Base):
            __tablename__ = 'family'
            id = Column(Integer, primary_key=True)

        self.Person = Person
        self.Family = Family

        # create all the tables required for the models
        self.Base.metadata.create_all()

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.Base.metadata.drop_all()

    def test_callable_query(self):
        """Test for :func:`session_query` when the model has a callable
        ``query`` attribute.

        """
        family = self.Family()
        person1 = self.Person(family=family)
        person2 = self.Person(family=family)
        self.session.add(family)
        self.session.add(person1)
        self.session.add(person2)
        self.session.commit()

        person_test = get_by(self.session, self.Person, person1.id)
        assert person1 == person_test


class TestHelpers(object):
    """Unit tests for the helper functions."""

    def test_partition(self):
        """Test for partitioning a list into two lists based on a given
        condition.

        """
        l = range(10)
        left, right = partition(l, lambda x: x < 5)
        assert list(range(5)) == left
        assert list(range(5, 10)) == right

    def test_upper_keys(self):
        """Test for converting keys in a dictionary to upper case."""
        for k, v in upper_keys(dict(zip('abc', 'xyz'))).items():
            assert k.isupper()
            assert not v.isupper()


class TestModelHelpers(TestSupport):
    """Provides tests for helper functions which operate on pure SQLAlchemy
    models.

    """

    def test_date_serialization(self):
        """Tests that date objects in the database are correctly serialized in
        the :func:`flask.ext.restless.helpers.to_dict` function.

        """
        person = self.Person(birth_date=date(1986, 9, 15))
        self.session.commit()
        d = to_dict(person)
        assert 'birth_date' in d
        assert d['birth_date'] == person.birth_date.isoformat()

    def test_datetime_serialization(self):
        """Tests that datetime objects in the database are correctly serialized
        in the :func:`flask.ext.restless.helpers.to_dict` function.

        """
        computer = self.Computer(buy_date=datetime.now())
        self.session.commit()
        d = to_dict(computer)
        assert 'buy_date' in d
        assert d['buy_date'] == computer.buy_date.isoformat()

    def test_uuid(self):
        """Tests for correct serialization of UUID objects."""
        exampleuuid = uuid.uuid1()
        vehicle = self.Vehicle(uuid=exampleuuid)
        self.session.commit()
        d = to_dict(vehicle)
        assert 'uuid' in d
        assert str(exampleuuid) == d['uuid']

    def test_to_dict(self):
        """Test for serializing attributes of an instance of the model by the
        :func:`flask.ext.restless.helpers.to_dict` function.

        """
        me = self.Person(name=u'Lincoln', age=24, birth_date=date(1986, 9, 15))
        self.session.commit()

        me_dict = to_dict(me)
        expectedfields = sorted(['birth_date', 'age', 'id', 'name',
                                 'other', 'is_minor'])
        assert sorted(me_dict) == expectedfields
        assert me_dict['name'] == u'Lincoln'
        assert me_dict['age'] == 24
        assert me_dict['birth_date'] == me.birth_date.isoformat()

    def test_primary_key_name(self):
        """Test for determining the primary attribute of a model or instance.

        """
        me = self.Person(name=u'Lincoln', age=24, birth_date=date(1986, 9, 15))
        assert 'id' == primary_key_name(me)
        assert 'id' == primary_key_name(self.Person)
        assert 'id' == primary_key_name(self.Star)

    def test_to_dict_dynamic_relation(self):
        """Tests that a dynamically queried relation is resolved when getting
        the dictionary representation of an instance of a model.

        """
        person = self.LazyPerson(name=u'Lincoln')
        self.session.add(person)
        computer = self.LazyComputer(name=u'lixeiro')
        self.session.add(computer)
        person.computers.append(computer)
        self.session.commit()
        person_dict = to_dict(person, deep={'computers': []})
        computer_dict = to_dict(computer, deep={'owner': None})
        assert sorted(person_dict), ['computers', 'id' == 'name']
        assert not isinstance(computer_dict['owner'], list)
        assert sorted(computer_dict) == ['id', 'name', 'owner', 'ownerid']
        expected_person = to_dict(person)
        expected_computer = to_dict(computer)
        assert person_dict['computers'] == [expected_computer]
        assert computer_dict['owner'] == expected_person

    def test_to_dict_deep(self):
        """Tests that fields corresponding to related model instances are
        correctly serialized by the :func:`flask.ext.restless.helpers.to_dict`
        function.

        """
        now = datetime.now()
        someone = self.Person(name=u'John', age=25)
        computer = self.Computer(name=u'lixeiro', vendor=u'Lemote',
                                 buy_date=now)
        someone.computers.append(computer)
        self.session.commit()

        deep = {'computers': []}
        computers = to_dict(someone, deep)['computers']
        assert len(computers) == 1
        assert computers[0]['name'] == u'lixeiro'
        assert computers[0]['vendor'] == u'Lemote'
        assert computers[0]['buy_date'] == now.isoformat()
        assert computers[0]['owner_id'] == someone.id

    def test_to_dict_hybrid_property(self):
        """Tests that hybrid properties are correctly serialized."""
        young = self.Person(name=u'John', age=15)
        old = self.Person(name=u'Sally', age=25)
        self.session.commit()

        assert to_dict(young)['is_minor']
        assert not to_dict(old)['is_minor']

    def test_to_dict_nested_object(self):
        """Tests that nested objects are correctly serialized."""
        person = self.Person(name=u'Test', age=10, other=20)
        computer = self.Computer(name=u'foo')
        person.computers.append(computer)

        data = to_dict(person, include_methods=['first_computer'])

        assert 'first_computer' in data
        assert 'foo' == data['first_computer']['name']

    def test_get_columns(self):
        """Test for getting the names of columns as strings."""
        columns = get_columns(self.Person)
        assert sorted(columns.keys()) == sorted(['age', 'birth_date',
                                                 'computers',
                                                 'id',
                                                 'is_minor',
                                                 'name',
                                                 'other'])

    def test_get_relations(self):
        """Tests getting the names of the relations of a model as strings."""
        relations = get_relations(self.Person)
        assert relations == ['computers']

    def test_is_like_list(self):
        """Tests if the relation of `instance` whose name is `relation` is
        list-like.

        """
        person = self.Person(name=u'Frankie', age=29)
        project = self.Project(person=person)
        proof = self.Proof(project=project)

        self.session.add_all([person, project, proof])
        self.session.commit()

        assert is_like_list(proof, 'person') == False
        assert is_like_list(proof, 'person_id') == False


class TestFunctionEvaluation(TestSupportPrefilled):
    """Unit tests for the :func:`flask.ext.restless.helpers.evaluate_functions`
    function.

    """

    def test_basic_evaluation(self):
        """Tests for basic function evaluation."""
        # test for no model
        result = evaluate_functions(self.session, None, [])
        assert result == {}

        # test for no functions
        result = evaluate_functions(self.session, self.Person, [])
        assert result == {}

        # test for summing ages
        functions = [{'name': 'sum', 'field': 'age'}]
        result = evaluate_functions(self.session, self.Person, functions)
        assert 'sum__age' in result
        assert result['sum__age'] == 102.0

        # test for multiple functions
        functions = [{'name': 'sum', 'field': 'age'},
                     {'name': 'avg', 'field': 'other'}]
        result = evaluate_functions(self.session, self.Person, functions)
        assert 'sum__age' in result
        assert result['sum__age'] == 102.0
        assert 'avg__other' in result
        assert result['avg__other'] == 16.2

    def test_count(self):
        """Tests for counting the number of rows in a query."""
        functions = [{'name': 'count', 'field': 'id'}]
        result = evaluate_functions(self.session, self.Person, functions)
        assert 'count__id' in result
        assert result['count__id'] == 5

    def test_poorly_defined_functions(self):
        """Tests that poorly defined functions raise errors."""
        # test for unknown field
        functions = [{'name': 'sum', 'field': 'bogus'}]
        assert_raises(AttributeError, evaluate_functions, self.session,
                      self.Person, functions)

        # test for unknown function
        functions = [{'name': 'bogus', 'field': 'age'}]
        assert_raises(OperationalError, evaluate_functions, self.session,
                      self.Person, functions)

########NEW FILE########
__FILENAME__ = test_manager
"""
    tests.test_manager
    ~~~~~~~~~~~~~~~~~~

    Provides unit tests for the :mod:`flask_restless.manager` module.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import datetime
import math

from flask import json
try:
    from flask.ext.sqlalchemy import SQLAlchemy
except:
    has_flask_sqlalchemy = False
else:
    has_flask_sqlalchemy = True

from flask.ext.restless import APIManager
from flask.ext.restless.helpers import get_columns

from sqlalchemy import Column
from sqlalchemy import func
from sqlalchemy import Unicode
from sqlalchemy.ext.hybrid import hybrid_property

from .helpers import FlaskTestBase
from .helpers import skip_unless
from .helpers import TestSupport


dumps = json.dumps
loads = json.loads


class TestAPIManager(TestSupport):
    """Unit tests for the :class:`flask_restless.manager.APIManager` class.

    """

    def test_constructor(self):
        """Tests that no error occurs on instantiation without any arguments to
        the constructor.

        """
        APIManager()

    def test_init_app(self):
        """Tests for initializing the Flask application after instantiating the
        :class:`flask.ext.restless.APIManager` object.

        """
        # initialize the Flask application
        self.manager.init_app(self.flaskapp, self.session)

        # create an API
        self.manager.create_api(self.Person)

        # make a request on the API
        #client = app.test_client()
        response = self.app.get('/api/person')
        assert response.status_code == 200

    def test_create_api(self):
        """Tests that the :meth:`flask_restless.manager.APIManager.create_api`
        method creates endpoints which are accessible by the client, only allow
        specified HTTP methods, and which provide a correct API to a database.

        """
        # create three different APIs for the same model
        self.manager.create_api(self.Person, methods=['GET', 'POST'])
        self.manager.create_api(self.Person, methods=['PATCH'],
                                url_prefix='/api2')
        self.manager.create_api(self.Person, methods=['GET'],
                                url_prefix='/readonly')

        # test that specified endpoints exist
        response = self.app.post('/api/person', data=dumps(dict(name='foo')))
        assert response.status_code == 201
        assert loads(response.data)['id'] == 1
        response = self.app.get('/api/person')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        assert loads(response.data)['objects'][0]['id'] == 1

        # test that non-specified methods are not allowed
        response = self.app.delete('/api/person/1')
        assert response.status_code == 405
        response = self.app.patch('/api/person/1',
                                  data=dumps(dict(name='bar')))
        assert response.status_code == 405

        # test that specified endpoints exist
        response = self.app.patch('/api2/person/1',
                                  data=dumps(dict(name='bar')))
        assert response.status_code == 200
        assert loads(response.data)['id'] == 1
        assert loads(response.data)['name'] == 'bar'

        # test that non-specified methods are not allowed
        response = self.app.get('/api2/person/1')
        assert response.status_code == 405
        response = self.app.delete('/api2/person/1')
        assert response.status_code == 405
        response = self.app.post('/api2/person',
                                 data=dumps(dict(name='baz')))
        assert response.status_code == 405

        # test that the model is the same as before
        response = self.app.get('/readonly/person')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        assert loads(response.data)['objects'][0]['id'] == 1
        assert loads(response.data)['objects'][0]['name'] == 'bar'

    def test_multi_pk(self):
        """Test for specifying a primary key from a set of primary keys to use
        when registering routes.

        """
        self.manager.create_api(self.User, methods=['GET', 'POST'],
                                primary_key='email')
        data = dict(id=1, email='foo')
        response = self.app.post('/api/user', data=dumps(data))
        assert response.status_code == 201
        data = loads(response.data)
        assert data['email'] == 'foo'

        response = self.app.get('/api/user/foo')
        assert response.status_code == 200
        data = loads(response.data)
        assert data['email'] == 'foo'
        assert data['id'] == 1

        # user should not be accessible at this URL
        response = self.app.get('/api/user/1')
        assert response.status_code == 404

    def test_different_collection_name(self):
        """Tests that providing a different collection name exposes the API at
        the corresponding URL.

        """
        self.manager.create_api(self.Person, methods=['POST', 'GET'],
                                collection_name='people')

        response = self.app.post('/api/people', data=dumps(dict(name='foo')))
        assert response.status_code == 201
        assert loads(response.data)['id'] == 1

        response = self.app.get('/api/people')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        assert loads(response.data)['objects'][0]['id'] == 1

        response = self.app.get('/api/people/1')
        assert response.status_code == 200
        assert loads(response.data)['id'] == 1

    def test_allow_functions(self):
        """Tests that the ``allow_functions`` keyword argument makes a
        :http:get:`/api/eval/...` endpoint available.

        """
        self.manager.create_api(self.Person, allow_functions=True)
        response = self.app.get('/api/eval/person?q={}')
        assert response.status_code != 400
        assert response.status_code == 204

    def test_disallow_functions(self):
        """Tests that if the ``allow_functions`` keyword argument if ``False``,
        no endpoint will be made available at :http:get:`/api/eval/...`.

        """
        self.manager.create_api(self.Person, allow_functions=False)
        response = self.app.get('/api/eval/person')
        assert response.status_code != 200
        assert response.status_code == 404

    def test_include_related(self):
        """Test for specifying included columns on related models."""
        date = datetime.date(1999, 12, 31)
        person = self.Person(name=u'Test', age=10, other=20, birth_date=date)
        computer = self.Computer(name=u'foo', vendor=u'bar', buy_date=date)
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        include = frozenset(['name', 'age', 'computers', 'computers.id',
                             'computers.name'])
        self.manager.create_api(self.Person, include_columns=include)
        include = frozenset(['name', 'age', 'computers.id', 'computers.name'])
        self.manager.create_api(self.Person, url_prefix='/api2',
                                include_columns=include)

        response = self.app.get('/api/person/{0}'.format(person.id))
        person_dict = loads(response.data)
        for column in 'name', 'age', 'computers':
            assert column in person_dict
        for column in 'id', 'other', 'birth_date':
            assert column not in person_dict
        for column in 'id', 'name':
            assert column in person_dict['computers'][0]
        for column in 'vendor', 'owner_id', 'buy_date':
            assert column not in person_dict['computers'][0]

        response = self.app.get('/api2/person/{0}'.format(person.id))
        assert 'computers' not in loads(response.data)

    def test_exclude_related(self):
        """Test for specifying excluded columns on related models."""
        date = datetime.date(1999, 12, 31)
        person = self.Person(name=u'Test', age=10, other=20, birth_date=date)
        computer = self.Computer(name=u'foo', vendor=u'bar', buy_date=date)
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        exclude = frozenset(['name', 'age', 'computers', 'computers.id',
                             'computers.name'])
        self.manager.create_api(self.Person, exclude_columns=exclude)
        exclude = frozenset(['name', 'age', 'computers.id', 'computers.name'])
        self.manager.create_api(self.Person, url_prefix='/api2',
                                exclude_columns=exclude)

        response = self.app.get('/api/person/{0}'.format(person.id))
        person_dict = loads(response.data)
        for column in 'name', 'age', 'computers':
            assert column not in person_dict
        for column in 'id', 'other', 'birth_date':
            assert column in person_dict

        response = self.app.get('/api2/person/{0}'.format(person.id))
        person_dict = loads(response.data)
        assert 'computers' in person_dict
        for column in 'id', 'name':
            assert column not in person_dict['computers'][0]
        for column in 'vendor', 'owner_id', 'buy_date':
            assert column in person_dict['computers'][0]

    def test_include_columns(self):
        """Tests that the `include_columns` argument specifies which columns to
        return in the JSON representation of instances of the model.

        """
        all_columns = get_columns(self.Person)
        # allow all
        self.manager.create_api(self.Person, include_columns=None,
                                url_prefix='/all')
        self.manager.create_api(self.Person, include_columns=all_columns,
                                url_prefix='/all2')
        # allow some
        self.manager.create_api(self.Person, include_columns=('name', 'age'),
                                url_prefix='/some')
        # allow none
        self.manager.create_api(self.Person, include_columns=(),
                                url_prefix='/none')

        # create a test person
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/add')
        d = dict(name=u'Test', age=10, other=20,
                 birth_date=datetime.date(1999, 12, 31).isoformat())
        response = self.app.post('/add/person', data=dumps(d))
        assert response.status_code == 201
        personid = loads(response.data)['id']

        # get all
        response = self.app.get('/all/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column in loads(response.data)
        response = self.app.get('/all2/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column in loads(response.data)

        # get some
        response = self.app.get('/some/person/{0}'.format(personid))
        for column in 'name', 'age':
            assert column in loads(response.data)
        for column in 'other', 'birth_date', 'computers':
            assert column not in loads(response.data)

        # get none
        response = self.app.get('/none/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column not in loads(response.data)

    def test_include_methods(self):
        """Tests that the `include_methods` argument specifies which methods to
        return in the JSON representation of instances of the model.

        """
        # included
        self.manager.create_api(self.Person, url_prefix='/included',
                                include_methods=['name_and_age',
                                                 'computers.speed'])
        # not included
        self.manager.create_api(self.Person, url_prefix='/not_included')
        # related object
        self.manager.create_api(self.Computer, url_prefix='/included',
                                include_methods=['owner.name_and_age'])

        # create a test person
        date = datetime.date(1999, 12, 31)
        person = self.Person(name=u'Test', age=10, other=20, birth_date=date)
        computer = self.Computer(name=u'foo', vendor=u'bar', buy_date=date)
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        # get one with included method
        response = self.app.get('/included/person/{0}'.format(person.id))
        assert loads(response.data)['name_and_age'] == 'Test (aged 10)'

        # get one without included method
        response = self.app.get('/not_included/person/{0}'.format(person.id))
        assert 'name_and_age' not in loads(response.data)

        # get many with included method
        response = self.app.get('/included/person')
        response_data = loads(response.data)
        assert response_data['objects'][0]['name_and_age'] == 'Test (aged 10)'

        # get one through a related object
        response = self.app.get('/included/computer')
        response_data = loads(response.data)
        assert 'name_and_age' in response_data['objects'][0]['owner']

        # get many through a related object
        response = self.app.get('/included/person')
        response_data = loads(response.data)
        assert response_data['objects'][0]['computers'][0]['speed'] == 42

    def test_included_method_returns_object(self):
        """Tests that objects are serialized when returned from a method listed
        in the `include_methods` argument.

        """
        date = datetime.date(1999, 12, 31)
        person = self.Person(name=u'Test', age=10, other=20, birth_date=date)
        computer = self.Computer(name=u'foo', vendor=u'bar', buy_date=date)
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        self.manager.create_api(self.Person,
                                include_methods=['first_computer'])
        response = self.app.get('/api/person/1')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'first_computer' in data
        assert 'foo' == data['first_computer']['name']

    def test_exclude_columns(self):
        """Tests that the ``exclude_columns`` argument specifies which columns
        to exclude in the JSON representation of instances of the model.

        """
        all_columns = get_columns(self.Person)
        # allow all
        self.manager.create_api(self.Person, exclude_columns=None,
                                url_prefix='/all')
        self.manager.create_api(self.Person, exclude_columns=(),
                                url_prefix='/all2')
        # allow some
        exclude = ('other', 'birth_date', 'computers')
        self.manager.create_api(self.Person, exclude_columns=exclude,
                                url_prefix='/some')
        # allow none
        self.manager.create_api(self.Person, exclude_columns=all_columns,
                                url_prefix='/none')

        # create a test person
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/add')
        d = dict(name=u'Test', age=10, other=20,
                 birth_date=datetime.date(1999, 12, 31).isoformat())
        response = self.app.post('/add/person', data=dumps(d))
        assert response.status_code == 201
        personid = loads(response.data)['id']

        # get all
        response = self.app.get('/all/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column in loads(response.data)
        response = self.app.get('/all2/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column in loads(response.data)

        # get some
        response = self.app.get('/some/person/{0}'.format(personid))
        for column in 'name', 'age':
            assert column in loads(response.data)
        for column in 'other', 'birth_date', 'computers':
            assert column not in loads(response.data)

        # get none
        response = self.app.get('/none/person/{0}'.format(personid))
        for column in 'name', 'age', 'other', 'birth_date', 'computers':
            assert column not in loads(response.data)

    def test_different_urls(self):
        """Tests that establishing different URL endpoints for the same model
        affect the same database table.

        """
        methods = frozenset(('get', 'patch', 'post', 'delete'))
        # create a separate endpoint for each HTTP method
        for method in methods:
            url = '/{0}'.format(method)
            self.manager.create_api(self.Person, methods=[method.upper()],
                                    url_prefix=url)

        # test for correct requests
        response = self.app.get('/get/person')
        assert response.status_code == 200
        response = self.app.post('/post/person', data=dumps(dict(name='Test')))
        assert response.status_code == 201
        response = self.app.patch('/patch/person/1',
                                  data=dumps(dict(name='foo')))
        assert response.status_code == 200
        response = self.app.delete('/delete/person/1')
        assert response.status_code == 204

        # test for incorrect requests
        response = self.app.get('/post/person')
        assert response.status_code == 405
        response = self.app.get('/patch/person/1')
        assert response.status_code == 405
        response = self.app.get('/delete/person/1')
        assert response.status_code == 405

        response = self.app.post('/get/person')
        assert response.status_code == 405
        response = self.app.post('/patch/person/1')
        assert response.status_code == 405
        response = self.app.post('/delete/person/1')
        assert response.status_code == 405

        response = self.app.patch('/get/person')
        assert response.status_code == 405
        response = self.app.patch('/post/person')
        assert response.status_code == 405
        response = self.app.patch('/delete/person/1')
        assert response.status_code == 405

        response = self.app.delete('/get/person')
        assert response.status_code == 405
        response = self.app.delete('/post/person')
        assert response.status_code == 405
        response = self.app.delete('/patch/person/1')
        assert response.status_code == 405

        # test that the same model is updated on all URLs
        response = self.app.post('/post/person', data=dumps(dict(name='Test')))
        assert response.status_code == 201
        response = self.app.get('/get/person/1')
        assert response.status_code == 200
        assert loads(response.data)['name'] == 'Test'
        response = self.app.patch('/patch/person/1',
                                  data=dumps(dict(name='Foo')))
        assert response.status_code == 200
        response = self.app.get('/get/person/1')
        assert response.status_code == 200
        assert loads(response.data)['name'] == 'Foo'
        response = self.app.delete('/delete/person/1')
        assert response.status_code == 204
        response = self.app.get('/get/person/1')
        assert response.status_code == 404

    def test_max_results_per_page(self):
        """Test for specifying the ``max_results_per_page`` keyword argument.

        """
        self.manager.create_api(self.Person, methods=['GET', 'POST'],
                                max_results_per_page=15)
        for n in range(20):
            response = self.app.post('/api/person', data=dumps({}))
            assert 201 == response.status_code
        response = self.app.get('/api/person?results_per_page=20')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 15 == len(data['objects'])

    def test_expose_relations(self):
        """Tests that relations are exposed at a URL which is a child of the
        instance URL.

        """
        date = datetime.date(1999, 12, 31)
        person = self.Person(name=u'Test', age=10, other=20, birth_date=date)
        computer = self.Computer(name=u'foo', vendor=u'bar', buy_date=date)
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        self.manager.create_api(self.Person)
        response = self.app.get('/api/person/1/computers')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'objects' in data
        assert 1 == len(data['objects'])
        assert 'foo' == data['objects'][0]['name']

    def test_expose_lazy_relations(self):
        """Tests that lazy relations are exposed at a URL which is a child of
        the instance URL.

        """
        person = self.LazyPerson(name=u'Test')
        computer = self.LazyComputer(name=u'foo')
        self.session.add(person)
        person.computers.append(computer)
        self.session.commit()

        self.manager.create_api(self.LazyPerson)
        response = self.app.get('/api/lazyperson/1/computers')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'objects' in data
        assert 1 == len(data['objects'])
        assert 'foo' == data['objects'][0]['name']

    def test_set_hybrid_property(self):
        """Set a hybrid property"""

        class HybridPerson(self.Person):

            @hybrid_property
            def abs_other(self):
                return self.other is not None and abs(self.other) or 0

            @abs_other.expression
            def abs_other(self):
                return func.sum(HybridPerson.other)

            @abs_other.setter
            def abs_other(self, v):
                self.other = v

            @hybrid_property
            def sq_other(self):
                if not isinstance(self.other, float):
                    return None

                return self.other ** 2

            @sq_other.setter
            def sq_other(self, v):
                self.other = math.sqrt(v)

        self.manager.create_api(HybridPerson, methods=['POST', 'PATCH'])
        response = self.app.post('/api/person', data=dumps({'abs_other': 1}))
        assert 201 == response.status_code
        data = loads(response.data)
        assert 1 == data['other']
        assert 1 == data['abs_other']

        response = self.app.post('/api/person',
                                 data=dumps({'name': u'Rodriguez'}))
        assert 201 == response.status_code
        response = self.app.patch('/api/person/2', data=dumps({'sq_other': 4}))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == data['other']
        assert 4 == data['sq_other']

    def test_universal_preprocessor(self):
        """Tests universal preprocessor and postprocessor applied to all
        methods created with the API manager.

        """
        class Counter(object):
            def __init__(s): s.count = 0
            def increment(s): s.count += 1
            def __eq__(s, o):
                return s.count == o.count if isinstance(o, Counter) \
                    else s.count == o
        precount = Counter()
        postcount = Counter()
        def preget(**kw):
            precount.increment()
        def postget(**kw):
            postcount.increment()
        manager = APIManager(self.flaskapp, self.session,
                             preprocessors=dict(GET_MANY=[preget]),
                             postprocessors=dict(GET_MANY=[postget]))
        manager.create_api(self.Person)
        manager.create_api(self.Computer)
        self.app.get('/api/person')
        self.app.get('/api/computer')
        self.app.get('/api/person')
        assert precount == postcount == 3


@skip_unless(has_flask_sqlalchemy, 'Flask-SQLAlchemy not found.')
class TestFSA(FlaskTestBase):
    """Tests which use models defined using Flask-SQLAlchemy instead of pure
    SQLAlchemy.

    """

    def setUp(self):
        """Creates the Flask application, the APIManager, the database, and the
        Flask-SQLAlchemy models.

        """
        super(TestFSA, self).setUp()

        # initialize SQLAlchemy and Flask-Restless
        self.db = SQLAlchemy(self.flaskapp)
        self.manager = APIManager(self.flaskapp, flask_sqlalchemy_db=self.db)

        # for the sake of brevity...
        db = self.db

        # declare the models
        class Computer(db.Model):
            id = db.Column(db.Integer, primary_key=True)
            name = db.Column(db.Unicode, unique=True)
            vendor = db.Column(db.Unicode)
            buy_date = db.Column(db.DateTime)
            owner_id = db.Column(db.Integer, db.ForeignKey('person.id'))
            owner = db.relationship('Person',
                                    backref=db.backref('computers',
                                                       lazy='dynamic'))

        class Person(db.Model):
            id = db.Column(db.Integer, primary_key=True)
            name = db.Column(db.Unicode, unique=True)
            age = db.Column(db.Float)
            other = db.Column(db.Float)
            birth_date = db.Column(db.Date)

        self.Person = Person
        self.Computer = Computer

        # create all the tables required for the models
        self.db.create_all()

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.db.drop_all()

    def test_flask_sqlalchemy(self):
        """Tests that :class:`flask.ext.restless.APIManager` correctly exposes
        models defined using Flask-SQLAlchemy.

        """
        # create three different APIs for the same model
        self.manager.create_api(self.Person, methods=['GET', 'POST'])
        self.manager.create_api(self.Person, methods=['PATCH'],
                                url_prefix='/api2')
        self.manager.create_api(self.Person, methods=['GET'],
                                url_prefix='/readonly')

        # test that specified endpoints exist
        response = self.app.post('/api/person', data=dumps(dict(name='foo')))
        assert response.status_code == 201
        assert loads(response.data)['id'] == 1
        response = self.app.get('/api/person')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        assert loads(response.data)['objects'][0]['id'] == 1
        response = self.app.patch('/api2/person/1',
                                  data=dumps(dict(name='bar')))
        assert response.status_code == 200
        assert loads(response.data)['id'] == 1
        assert loads(response.data)['name'] == 'bar'

        # test that the model is the same as before
        response = self.app.get('/readonly/person')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        assert loads(response.data)['objects'][0]['id'] == 1
        assert loads(response.data)['objects'][0]['name'] == 'bar'

########NEW FILE########
__FILENAME__ = test_processors
"""
    tests.test_processors
    ~~~~~~~~~~~~~~~~~~~~~

    Provides unit tests for pre- and post-processors hooks.

    :copyright: 2013 "klinkin" <klinkin@gmail.com>
    :copyright: 2013 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from __future__ import with_statement

from datetime import date

from flask import json
from flask.ext.restless.views import ProcessingException
from .helpers import TestSupport


dumps = json.dumps
loads = json.loads


class TestProcessors(TestSupport):
    """Unit tests for preprocessors and postprocessors."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application.

        """
        # create the database
        super(TestProcessors, self).setUp()

        # to facilitate searching
        self.app.search = lambda url, q: self.app.get(url + '?q={0}'.format(q))

    def test_get_single_preprocessor(self):
        """Tests :http:method:`get` requests for a single object with
        a preprocessor function.

        """

        def check_permissions(**kw):
            raise ProcessingException(code=403,
                                      description='Permission denied')

        pre = dict(GET_SINGLE=[check_permissions])
        self.manager.create_api(self.Person, methods=['GET', 'POST'],
                                preprocessors=pre)
        response = self.app.post('/api/person', data=dumps({'name': u'test'}))
        assert 201 == response.status_code
        response = self.app.get('/api/person/1')
        assert response.status_code == 403

    def test_get_many_postprocessor(self):
        filt = dict(name='id', op='in', val=[1, 3])

        def foo(search_params=None, **kw):
            assert filt in search_params['filters']

        post = dict(GET_MANY=[foo])
        self.manager.create_api(self.Person, methods=['GET', 'POST'],
                                postprocessors=post)
        query = dict(filters=[filt])
        response = self.app.search('/api/person', dumps(query))
        assert response.status_code == 200

    def test_get_many_preprocessor(self):
        def check_permissions(search_params=None, **kw):
            filt = {u'name': u'id', u'op': u'in', u'val': [1, 3]}
            if 'filters' not in search_params:
                search_params['filters'] = [filt]
            else:
                search_params['filters'].append(filt)

        pre = dict(GET_MANY=[check_permissions])
        self.manager.create_api(self.Person, methods=['GET', 'POST'],
                                preprocessors=pre)

        self.app.post('/api/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        response = self.app.get('/api/person')
        objs = loads(response.data)['objects']
        ids = [obj['id'] for obj in objs]
        assert ids == [1, 3]
        assert response.status_code == 200

        search = dict(filters=[dict(name='name', val='Lincoln', op='equals')])
        response = self.app.search('/api/person', dumps(search))
        num_results = loads(response.data)['num_results']

        assert num_results == 1
        assert response.status_code == 200

    def test_post_preprocessor(self):
        """Tests :http:method:`post` requests with a preprocessor function."""
        def add_parameter(data=None, **kw):
            if data:
                data['other'] = 7

        def check_permissions(data=None, **kw):
            raise ProcessingException(code=403,
                                      description='Permission denied')

        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/api/v2',
                                preprocessors=dict(POST=[add_parameter]))
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/api/v3',
                                preprocessors=dict(POST=[check_permissions]))

        response = self.app.post('/api/v2/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 201

        personid = loads(response.data)['id']
        person = self.session.query(self.Person).filter_by(id=personid).first()
        assert person.other == 7

        response = self.app.post('/api/v3/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 403

    def test_delete_preprocessor(self):
        """Tests for using a preprocessor with :http:method:`delete` requests.

        """
        def check_permissions(**kw):
            raise ProcessingException(code=403,
                                      description='Permission denied')

        pre = dict(DELETE=[check_permissions])
        # recreate the api at /api/v1/person
        self.manager.create_api(self.Person,
                                methods=['POST', 'DELETE'],
                                preprocessors=pre)

        # Creating some people
        self.app.post('/api/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # Try deleting it
        response = self.app.delete('/api/person/1')
        assert response.status_code == 403

        # Making sure it has been not deleted
        people = self.session.query(self.Person).filter_by(id=1)
        assert people.count() == 1

    def test_patch_single_preprocessor(self):
        """Tests for using a preprocessor with :http:method:`patch` requests.

        """

        def check_permissions(**kw):
            raise ProcessingException(code=403,
                                      description='Permission denied')

        pre = dict(PATCH_SINGLE=[check_permissions])
        # recreate the api at /api/v1/person
        self.manager.create_api(self.Person,
                                methods=['PATCH', 'POST'],
                                preprocessors=pre)

        # Creating some test people
        self.app.post('/api/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # Try updating people with id=1
        response = self.app.patch('/api/person/1', data=dumps({'age': 27}))
        assert response.status_code == 403

    def test_patch_single_preprocessor2(self):
        """Tests for using a preprocessor with :http:method:`patch` requests.

        """

        def update_data(data=None, **kw):
            data['other'] = 27

        pre = dict(PATCH_SINGLE=[update_data])
        # recreate the api at /api/v1/person
        self.manager.create_api(self.Person,
                                methods=['GET', 'PATCH', 'POST'],
                                preprocessors=pre)

        # Creating some test people
        self.app.post('/api/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # Try updating people with id=1
        response = self.app.patch('/api/person/1', data=dumps({'age': 27}))
        assert response.status_code == 200

        resp = self.app.get('/api/person/1')
        assert resp.status_code == 200
        assert loads(resp.data)['age'] == 27
        assert loads(resp.data)['other'] == 27

    def test_patch_many_preprocessor(self):
        """Tests for using a preprocessor with :http:method:`patch` requests
        which request changes to many objects.

        """

        def update_data(data=None, **kw):
            data['other'] = 27

        pre = dict(PATCH_MANY=[update_data])
        # recreate the api at /api/v1/person
        self.manager.create_api(self.Person, methods=['GET', 'POST', 'PATCH'],
                                allow_patch_many=True,
                                preprocessors=pre)

        # Creating some people
        self.app.post('/api/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # Changing the birth date field of the entire collection
        day, month, year = 15, 9, 1986
        birth_date = date(year, month, day).strftime('%d/%m/%Y')  # iso8601
        form = {'birth_date': birth_date}
        response = self.app.patch('/api/person', data=dumps(form))

        # Finally, testing if the change was made
        response = self.app.get('/api/person')
        loaded = loads(response.data)['objects']
        for i in loaded:
            expected = '{0:4d}-{1:02d}-{2:02d}'.format(year, month, day)
            assert i['birth_date'] == expected
            assert i['other'] == 27

    def test_processor_no_change(self):
        """Tests :http:method:`post` requests with a preprocessor function.
        that makes no change to the data"""
        def no_change(**kw):
            pass

        self.manager.create_api(self.Person, methods=['GET', 'POST'],
                                url_prefix='/api/v2',
                                preprocessors=dict(POST=[no_change],
                                                   GET_SINGLE=[no_change],
                                                   GET_MANY=[no_change]))

        response = self.app.post('/api/v2/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 201

        personid = loads(response.data)['id']
        person = self.session.query(self.Person).filter_by(id=personid).first()
        assert person.name == u'Lincoln'
        assert person.age == 23

        # Test for GET_SINGLE
        response = self.app.get('/api/v2/person/{0:d}'.format(personid))
        assert response.status_code == 200

        person_response = loads(response.data)
        assert person_response['name'] == person.name
        assert person_response['age'] == person.age

        # Test for GET_MANY
        response = self.app.get('/api/v2/person')
        assert response.status_code == 200

        person_response = loads(response.data)["objects"][0]
        assert person_response['name'] == person.name
        assert person_response['age'] == person.age

    def test_add_filters(self):
        """Test for adding a filter to a :http:method:`get` request for a
        collection where there was no query parameter before.

        """
        # Create some people in the database.
        person1 = self.Person(name=u'foo')
        person2 = self.Person(name=u'bar')
        person3 = self.Person(name=u'baz')
        self.session.add_all((person1, person2, person3))
        self.session.commit()
        # Create a preprocessor function that adds a filter.
        def add_filter(search_params=None, **kw):
            if search_params is None:
                return
            filt = dict(name='name', op='like', val=u'ba%')
            if 'filters' not in search_params:
                search_params['filters'] = []
            search_params['filters'].append(filt)

        # Create the API with the preprocessor.
        self.manager.create_api(self.Person,
                                preprocessors=dict(GET_MANY=[add_filter]))

        # Test that the filter is added on GET requests to the collection.
        response = self.app.get('/api/person')
        assert 200 == response.status_code
        data = loads(response.data)['objects']
        assert 2 == len(data)
        assert sorted(['bar', 'baz']) == sorted([person['name']
                                                 for person in data])

########NEW FILE########
__FILENAME__ = test_search
"""
    tests.test_search
    ~~~~~~~~~~~~~~~~~

    Provides unit tests for the :mod:`flask_restless.search` module.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from nose.tools import assert_raises
from sqlalchemy.orm.exc import MultipleResultsFound
from sqlalchemy.orm.exc import NoResultFound

from flask.ext.restless.search import create_query
from flask.ext.restless.search import search
from flask.ext.restless.search import SearchParameters

from .helpers import TestSupportPrefilled


class TestQueryCreation(TestSupportPrefilled):
    """Unit tests for the :func:`flask_restless.search.create_query`
    function.

    """

    def test_empty_search(self):
        """Tests that a query with no search parameters returns everything."""
        query = create_query(self.session, self.Person, {})
        assert query.all() == self.people

    def test_dict_same_as_search_params(self):
        """Tests that creating a query using a dictionary results in the same
        query as creating one using a
        :class:`flask_restless.search.SearchParameters` object.

        """
        d = {'filters': [{'name': 'name', 'val': u'%y%', 'op': 'like'}]}
        s = SearchParameters.from_dictionary(d)
        query_d = create_query(self.session, self.Person, d)
        query_s = create_query(self.session, self.Person, s)
        assert query_d.all() == query_s.all()

    def test_basic_query(self):
        """Tests for basic query correctness."""
        d = {'filters': [{'name': 'name', 'val': u'%y%', 'op': 'like'}]}
        query = create_query(self.session, self.Person, d)
        assert query.count() == 3  # Mary, Lucy and Katy

        d = {'filters': [{'name': 'name', 'val': u'Lincoln', 'op': 'equals'}]}
        query = create_query(self.session, self.Person, d)
        assert query.count() == 1
        assert query.one().name == 'Lincoln'

        d = {'filters': [{'name': 'name', 'val': u'Bogus', 'op': 'equals'}]}
        query = create_query(self.session, self.Person, d)
        assert query.count() == 0

        d = {'order_by': [{'field': 'age', 'direction': 'asc'}]}
        query = create_query(self.session, self.Person, d)
        ages = [p.age for p in query]
        assert ages, [7, 19, 23, 25 == 28]

        d = {'filters': [{'name': 'age', 'val': [7, 28], 'op': 'in'}]}
        query = create_query(self.session, self.Person, d)
        ages = [p.age for p in query]
        assert ages, [7 == 28]

    def test_query_related_field(self):
        """Test for making a query with respect to a related field."""
        # add a computer to person 1
        computer = self.Computer(name=u'turing', vendor=u'Dell')
        p1 = self.session.query(self.Person).filter_by(id=1).first()
        p1.computers.append(computer)
        self.session.commit()

        d = {'filters': [{'name': 'computers__name', 'val': u'turing',
                          'op': 'any'}]}
        query = create_query(self.session, self.Person, d)
        assert query.count() == 1
        assert query.one().computers[0].name == 'turing'

        d = {'filters': [{'name': 'age', 'op': 'lte', 'field': 'other'}],
             'order_by': [{'field': 'other'}]}
        query = create_query(self.session, self.Person, d)
        assert query.count() == 2
        results = query.all()
        assert results[0].other == 10
        assert results[1].other == 19


class TestOperators(TestSupportPrefilled):
    """Tests for each of the query operators defined in
    :data:`flask_restless.search.OPERATORS`.

    """

    def test_operators(self):
        """Tests for each of the individual operators in
        :data:`flask_restless.search.OPERATORS`.

        """
        for op in '==', 'eq', 'equals', 'equal_to':
            d = dict(filters=[dict(name='name', op=op, val=u'Lincoln')])
            result = search(self.session, self.Person, d)
            assert result.count() == 1
            assert result[0].name == u'Lincoln'
        for op in '!=', 'ne', 'neq', 'not_equal_to', 'does_not_equal':
            d = dict(filters=[dict(name='name', op=op, val=u'Lincoln')])
            result = search(self.session, self.Person, d)
            assert result.count() == len(self.people) - 1
            assert u'Lincoln' not in (p.name for p in result)
        for op in '>', 'gt':
            d = dict(filters=[dict(name='age', op=op, val=20)])
            result = search(self.session, self.Person, d)
            assert result.count() == 3
        for op in '<', 'lt':
            d = dict(filters=[dict(name='age', op=op, val=20)])
            result = search(self.session, self.Person, d)
            assert result.count() == 2
        for op in '>=', 'ge', 'gte', 'geq':
            d = dict(filters=[dict(name='age', op=op, val=23)])
            result = search(self.session, self.Person, d)
            assert result.count() == 3
        for op in '<=', 'le', 'lte', 'leq':
            d = dict(filters=[dict(name='age', op=op, val=23)])
            result = search(self.session, self.Person, d)
            assert result.count() == 3
        d = dict(filters=[dict(name='name', op='like', val=u'%y%')])
        result = search(self.session, self.Person, d)
        assert result.count() == 3
        d = dict(filters=[dict(name='name', op='ilike', val=u'%Y%')])
        result = search(self.session, self.Person, d)
        assert result.count() == 3
        d = dict(filters=[dict(name='age', op='in', val=[19, 21, 23])])
        result = search(self.session, self.Person, d)
        assert result.count() == 2
        d = dict(filters=[dict(name='age', op='not_in', val=[19, 21, 23])])
        result = search(self.session, self.Person, d)
        assert result.count() == 3
        d = dict(filters=[dict(name='birth_date', op='is_null')])
        result = search(self.session, self.Person, d)
        assert result.count() == 4
        d = dict(filters=[dict(name='birth_date', op='is_not_null')])
        result = search(self.session, self.Person, d)
        assert result.count() == 1

    def test_desc_and_asc(self):
        """Tests for the ``"desc"`` and ``"asc"`` operators."""
        # TODO Not yet implemented because I don't understand these operators.
        pass

    def test_has_and_any(self):
        """Tests for the ``"has"`` and ``"any"`` operators.

        The `any` operator returns all instances for which any related instance
        in a given collection has some property. The `has` operator returns all
        instances for which a related instance has a given property.

        """
        # create test computers
        computer1 = self.Computer(name=u'c1', vendor=u'foo')
        computer2 = self.Computer(name=u'c2', vendor=u'bar')
        computer3 = self.Computer(name=u'c3', vendor=u'bar')
        computer4 = self.Computer(name=u'c4', vendor=u'bar')
        computer5 = self.Computer(name=u'c5', vendor=u'foo')
        computer6 = self.Computer(name=u'c6', vendor=u'foo')
        self.session.add_all((computer1, computer2, computer3, computer4,
                              computer5, computer6))
        self.session.commit()
        # add the computers to three test people
        person1, person2, person3 = self.people[:3]
        person1.computers = [computer1, computer2, computer3]
        person2.computers = [computer4]
        person3.computers = [computer5, computer6]
        self.session.commit()
        # test 'any'
        d = dict(filters=[dict(name='computers__vendor', val=u'foo',
                               op='any')])
        result = search(self.session, self.Person, d)
        assert result.count() == 2
        # test 'has'
        d = dict(filters=[dict(name='owner__name', op='has', val=u'Lincoln')])
        result = search(self.session, self.Computer, d)
        assert result.count() == 3

    def test_has_and_any_suboperators(self):
        """Tests for the ``"has"`` and ``"any"`` operators with suboperators.

        The `any` operator returns all instances for which any related instance
        in a given collection has some property. The `has` operator returns all
        instances for which a related instance has a given property.

        """
        # create test computers
        computer1 = self.Computer(name=u'c1', vendor=u'foo')
        computer2 = self.Computer(name=u'c2', vendor=u'bar')
        computer3 = self.Computer(name=u'c3', vendor=u'bar')
        computer4 = self.Computer(name=u'c4', vendor=u'bar')
        computer5 = self.Computer(name=u'c5', vendor=u'foo')
        computer6 = self.Computer(name=u'c6', vendor=u'foo')
        self.session.add_all((computer1, computer2, computer3, computer4,
                              computer5, computer6))
        self.session.commit()
        # add the computers to three test people
        person1, person2, person3 = self.people[:3]
        person1.computers = [computer1, computer2, computer3]
        person2.computers = [computer4]
        person3.computers = [computer5, computer6]
        self.session.commit()
        # test 'any'
        val = dict(name='vendor', op='like', val=u'%o%')
        d = dict(filters=[dict(name='computers', op='any', val=val)])
        result = search(self.session, self.Person, d)
        assert result.count() == 2
        # test 'has'
        val = dict(name='name', op='like', val=u'%incol%')
        d = dict(filters=[dict(name='owner', op='has', val=val)])
        result = search(self.session, self.Computer, d)
        assert result.count() == 3

    def test_has_and_any_nested_suboperators(self):
        """Tests for the ``"has"`` and ``"any"`` operators with nested
        suboperators.

        The `any` operator returns all instances for which any related instance
        in a given collection has some property. The `has` operator returns all
        instances for which a related instance has a given property.

        """
        # create test computers
        computer1 = self.Computer(name=u'c1', vendor=u'foo')
        computer2 = self.Computer(name=u'c2', vendor=u'bar')
        computer3 = self.Computer(name=u'c3', vendor=u'bar')
        computer4 = self.Computer(name=u'c4', vendor=u'bar')
        computer5 = self.Computer(name=u'c5', vendor=u'foo')
        computer6 = self.Computer(name=u'c6', vendor=u'foo')
        self.session.add_all((computer1, computer2, computer3, computer4,
                              computer5, computer6))
        self.session.commit()
        # add the computers to three test people
        person1, person2, person3 = self.people[:3]
        person1.computers = [computer1, computer2, computer3]
        person2.computers = [computer4]
        person3.computers = [computer5, computer6]
        self.session.commit()
        # test 'any'
        innerval = dict(name='name', op='like', val=u'%incol%')
        val = dict(name='owner', op='has', val=innerval)
        d = dict(filters=[dict(name='computers', op='any', val=val)])
        result = search(self.session, self.Person, d)
        assert result.count() == 1
        # test 'has'
        innerval = dict(name='vendor', op='like', val=u'%o%')
        val = dict(name='computers', op='any', val=innerval)
        d = dict(filters=[dict(name='owner', op='has', val=val)])
        result = search(self.session, self.Computer, d)
        assert result.count() == 5


class TestSearch(TestSupportPrefilled):
    """Unit tests for the :func:`flask_restless.search.search` function.

    The :func:`~flask_restless.search.search` function is a essentially a
    wrapper around the :func:`~flask_restless.search.create_query` function
    which checks whether the parameters of the search indicate that a single
    result is expected.

    """

    def test_search(self):
        """Tests that asking for a single result raises an error unless the
        result of the query truly has only a single element.

        """
        # tests getting multiple results
        d = {'single': True,
             'filters': [{'name': 'name', 'val': u'%y%', 'op': 'like'}]}
        assert_raises(MultipleResultsFound, search, self.session, self.Person,
                      d)

        # tests getting no results
        d = {'single': True,
             'filters': [{'name': 'name', 'val': u'bogusname', 'op': '=='}]}
        assert_raises(NoResultFound, search, self.session, self.Person, d)

        # tests getting exactly one result
        d = {'single': True,
             'filters': [{'name': 'name', 'val': u'Lincoln', 'op': '=='}]}
        result = search(self.session, self.Person, d)
        assert result.name == u'Lincoln'

########NEW FILE########
__FILENAME__ = test_validation
"""
    tests.test_validation
    ~~~~~~~~~~~~~~~~~~~~~

    Provides unit tests for SQLAlchemy models which have some validation
    functionality and therefore raise validation errors when requests are made
    to write to the database.

    Validation is not provided by Flask-Restless itself, but it must capture
    validation errors and return them to the client.

    :copyright: 2012 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
import re
import sys

from flask import json
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import Unicode
from sqlalchemy.orm import validates

# for SAValidation package on pypi.python.org
try:
    import savalidation as _sav
    import savalidation.validators as sav
except:
    has_savalidation = False
else:
    sav_version = tuple(int(n) for n in _sav.VERSION.split('.'))
    has_savalidation = True

from .helpers import skip_unless
from .helpers import TestSupport


#: A regular expression for email addresses.
EMAIL_REGEX = re.compile("[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^"
                         "_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a"
                         "-z0-9](?:[a-z0-9-]*[a-z0-9])")

dumps = json.dumps
loads = json.loads


class TestSimpleValidation(TestSupport):
    """Tests for validation errors raised by the SQLAlchemy's simple built-in
    validation.

    For more information about this functionality, see the documentation for
    :func:`sqlalchemy.orm.validates`.

    """

    def setUp(self):
        """Create APIs for the validated models."""
        super(TestSimpleValidation, self).setUp()

        class CoolValidationError(Exception):
            pass

        # create the validated class
        # NOTE: don't name this `Person`, as in self.Person
        class Test(self.Base):
            __tablename__ = 'test'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode(30), nullable=False, index=True)
            email = Column(Unicode, nullable=False)
            age = Column(Integer, nullable=False)

            @validates('email')
            def validate_email(self, key, string):
                if len(EMAIL_REGEX.findall(string)) != 1:
                    exception = CoolValidationError()
                    exception.errors = dict(email=('Must be in valid email'
                                                   ' format'))
                    raise exception
                return string

            @validates('age')
            def validate_age(self, key, number):
                if not 0 <= number <= 150:
                    exception = CoolValidationError()
                    exception.errors = dict(age='Must be between 0 and 150')
                    raise exception
                return number

            @validates('name')
            def validate_name(self, key, string):
                if string is None:
                    exception = CoolValidationError()
                    exception.errors = dict(name='Must not be empty')
                    raise exception
                return string
        self.Base.metadata.create_all()
        self.manager.create_api(Test, methods=['GET', 'POST', 'PATCH'],
                                validation_exceptions=[CoolValidationError])

    def test_validations(self):
        """Test SQLAlchemy's built-in simple validations."""
        # test posting a person with a badly formatted email field
        person = dict(name='Jeffrey', email='bogus!!!email', age=1)
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 400
        data = loads(response.data)
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'email' in errors
        assert 'format' in errors['email'].lower()

        # posting a new person with valid email format should be fine
        person = dict(name='John', email='foo@example.com', age=1)
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 201
        personid = loads(response.data)['id']

        # test patching a person to with badly formatted data
        person = dict(name='Jeffrey', email='bogus!!!email', age=24)
        response = self.app.patch('/api/test/' + str(personid),
                                  data=dumps(person))
        data = loads(response.data)
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'email' in errors
        assert 'format' in errors['email'].lower()

        # patching a person with correctly formatted fields should be fine
        person = dict(email='foo@example.com')
        response = self.app.patch('/api/test/' + str(personid),
                                  data=dumps(person))
        data = loads(response.data)
        if 'validation_errors' in data and \
                'email' in data['validation_errors']:
            assert 'format' not in errors['email'].lower()


@skip_unless(has_savalidation and sav_version >= (0, 2) and
             sys.version < (3, 0, 0), 'savalidation not found.')
class TestSAV(TestSupport):
    """Tests for validation errors raised by the ``savalidation`` package. For
    more information about this package, see `its PyPI page
    <http://pypi.python.org/pypi/SAValidation>`_.

    """

    def setUp(self):
        """Create APIs for the validated models."""
        super(TestSAV, self).setUp()

        class Test(self.Base, _sav.ValidationMixin):
            __tablename__ = 'test'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode(30))
            email = Column(Unicode)
            age = Column(Integer)

            sav.validates_presence_of('name', 'email')
            sav.validates_email('email')

        self.Base.metadata.create_all()

        exceptions = [_sav.ValidationError]
        self.manager.create_api(Test, methods=['GET', 'POST', 'PATCH'],
                                validation_exceptions=exceptions)

    def test_format_validations(self):
        """Tests that errors from validators which check if fields match a
        format specified by a regular expression are correctly captured and
        returned to the client.

        """
        # test posting a person with a badly formatted email field
        person = dict(name='Jeffrey', email='bogus!!!email', age=1)
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 400
        data = loads(response.data)
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'email' in errors
        assert 'email address' in errors['email'].lower()

        # posting a new person with valid email format should be fine
        person = dict(name='John', email='foo@example.com', age=1)
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 201
        personid = loads(response.data)['id']

        # test patching a person to with badly formatted data
        person = dict(name='Jeffrey', email='bogus!!!email', age=24)
        response = self.app.patch('/api/test/' + str(personid),
                                  data=dumps(person))
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'email' in errors
        assert 'email address' in errors['email'].lower()

        # patching a person with correctly formatted fields should be fine
        person = dict(email='foo@example.com')
        response = self.app.patch('/api/test/' + str(personid),
                                  data=dumps(person))
        data = loads(response.data)
        if 'validation_errors' in data and \
                'email' in data['validation_errors']:
            assert 'email address' not in errors['email'].lower()

    def test_presence_validations(self):
        """Tests that errors from validators which check for presence are
        correctly captured and returned to the client.

        """
        # missing required name field
        person = dict(email='example@example.com')
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 400
        data = loads(response.data)
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'name' in errors
        assert 'enter a value' in errors['name'].lower()

        # missing required email field
        person = dict(name='Jeffrey')
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 400
        data = loads(response.data)
        assert 'validation_errors' in data
        errors = data['validation_errors']
        assert 'email' in errors
        assert 'enter a value' in errors['email'].lower()

        # everything required is now provided
        person = dict(name='Jeffrey', email='example@example.com', age=24)
        response = self.app.post('/api/test', data=dumps(person))
        assert response.status_code == 201
        personid = loads(response.data)['id']

        # check that the provided field values are in there
        response = self.app.get('/api/test/' + str(personid))
        assert response.status_code == 200
        data = loads(response.data)
        assert data['name'] == 'Jeffrey'
        assert data['email'] == 'example@example.com'

########NEW FILE########
__FILENAME__ = test_views
"""
    tests.test_views
    ~~~~~~~~~~~~~~~~

    Provides unit tests for the :mod:`flask_restless.views` module.

    :copyright: 2011 by Lincoln de Sousa <lincoln@comum.org>
    :copyright: 2012, 2013 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com>
    :license: GNU AGPLv3+ or BSD

"""
from datetime import date
from datetime import datetime
from datetime import timedelta

import dateutil
from flask import json
try:
    from flask.ext.sqlalchemy import SQLAlchemy
except:
    has_flask_sqlalchemy = False
else:
    has_flask_sqlalchemy = True
from sqlalchemy import Column
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import Unicode
from sqlalchemy.ext.associationproxy import association_proxy as prox
from sqlalchemy.orm import backref
from sqlalchemy.orm import relationship as rel
from sqlalchemy.orm.collections import column_mapped_collection as col_mapped

from flask.ext.restless.helpers import to_dict
from flask.ext.restless.manager import APIManager

from .helpers import DatabaseTestBase
from .helpers import FlaskTestBase
from .helpers import skip_unless
from .helpers import TestSupport
from .helpers import TestSupportPrefilled


dumps = json.dumps
loads = json.loads


#: The User-Agent string for Microsoft Internet Explorer 8.
#:
#: From <http://blogs.msdn.com/b/ie/archive/2008/02/21/the-internet-explorer-8-user-agent-string.aspx>.
MSIE8_UA = 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)'

#: The User-Agent string for Microsoft Internet Explorer 9.
#:
#: From <http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx>.
MSIE9_UA = 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'


@skip_unless(has_flask_sqlalchemy, 'Flask-SQLAlchemy not found.')
class TestFSAModel(FlaskTestBase):
    """Tests for functions which operate on Flask-SQLAlchemy models."""

    def setUp(self):
        """Creates the Flask-SQLAlchemy database and models."""
        super(TestFSAModel, self).setUp()

        db = SQLAlchemy(self.flaskapp)

        class User(db.Model):
            id = db.Column(db.Integer, primary_key=True)

        class Pet(db.Model):
            id = db.Column(db.Integer, primary_key=True)
            ownerid = db.Column(db.Integer, db.ForeignKey(User.id))
            owner = db.relationship(User, backref=db.backref('pets'))

        class LazyUser(db.Model):
            id = db.Column(db.Integer, primary_key=True)

        class LazyPet(db.Model):
            id = db.Column(db.Integer, primary_key=True)
            ownerid = db.Column(db.Integer, db.ForeignKey(LazyUser.id))
            owner = db.relationship(LazyUser,
                                    backref=db.backref('pets', lazy='dynamic'))

        self.User = User
        self.Pet = Pet
        self.LazyUser = LazyUser
        self.LazyPet = LazyPet

        self.db = db
        self.db.create_all()

        self.manager = APIManager(self.flaskapp, flask_sqlalchemy_db=self.db)

    def tearDown(self):
        """Drops all tables."""
        self.db.drop_all()

    def test_get(self):
        """Test for the :meth:`views.API.get` method with models defined using
        Flask-SQLAlchemy with both dynamically loaded and static relationships.

        """
        # create the API endpoint
        self.manager.create_api(self.User)
        self.manager.create_api(self.LazyUser)
        self.manager.create_api(self.Pet)
        self.manager.create_api(self.LazyPet)

        response = self.app.get('/api/user')
        assert 200 == response.status_code
        response = self.app.get('/api/lazy_user')
        assert 200 == response.status_code
        response = self.app.get('/api/pet')
        assert 200 == response.status_code
        response = self.app.get('/api/lazy_pet')
        assert 200 == response.status_code

        # create a user with two pets
        owner = self.User()
        pet1 = self.Pet()
        pet2 = self.Pet()
        pet3 = self.Pet()
        pet1.owner = owner
        pet2.owner = owner
        self.db.session.add_all([owner, pet1, pet2, pet3])
        self.db.session.commit()

        response = self.app.get('/api/user/{0:d}'.format(owner.id))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['pets'])
        for pet in data['pets']:
            assert owner.id == pet['ownerid']

        response = self.app.get('/api/pet/1')
        assert 200 == response.status_code
        data = loads(response.data)
        assert not isinstance(data['owner'], list)
        assert owner.id == data['ownerid']

        # create a lazy user with two lazy pets
        owner = self.LazyUser()
        pet1 = self.LazyPet()
        pet2 = self.LazyPet()
        pet1.owner = owner
        pet2.owner = owner
        self.db.session.add_all([owner, pet1, pet2])
        self.db.session.commit()

        response = self.app.get('/api/lazy_user/{0:d}'.format(owner.id))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['pets'])
        for pet in data['pets']:
            assert owner.id == pet['ownerid']

        response = self.app.get('/api/lazy_pet/1')
        assert 200 == response.status_code
        data = loads(response.data)
        assert not isinstance(data['owner'], list)
        assert owner.id == data['ownerid']

        # Check that it's possible to get owner if not null
        response = self.app.get('/api/pet/1/owner')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['pets'])
        # And that we get a 404 if owner is null
        response = self.app.get('/api/pet/3/owner')
        assert 404 == response.status_code


class TestFunctionAPI(TestSupportPrefilled):
    """Unit tests for the :class:`flask_restless.views.FunctionAPI` class."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`testapp.Person` and
        :class:`testapp.Computer` models.

        """
        super(TestFunctionAPI, self).setUp()
        self.manager.create_api(self.Person, allow_functions=True)

    def test_function_evaluation(self):
        """Test that the :http:get:`/api/eval/person` endpoint returns the
        result of evaluating functions.

        """
        functions = [{'name': 'sum', 'field': 'age'},
                     {'name': 'avg', 'field': 'other'},
                     {'name': 'count', 'field': 'id'}]
        query = dumps(dict(functions=functions))
        response = self.app.get('/api/eval/person?q={0}'.format(query))
        assert response.status_code == 200
        data = loads(response.data)
        assert 'sum__age' in data
        assert data['sum__age'] == 102.0
        assert 'avg__other' in data
        assert data['avg__other'] == 16.2
        assert 'count__id' in data
        assert data['count__id'] == 5

    def test_no_functions(self):
        """Tests that if no functions are defined, an empty response is
        returned.

        """
        # no data is invalid JSON
        response = self.app.get('/api/eval/person')
        assert response.status_code == 400
        # so is the empty string
        response = self.app.get('/api/eval/person?q=')
        assert response.status_code == 400

        # if we provide no functions, then we expect an empty response
        response = self.app.get('/api/eval/person?q={0}'.format(dumps(dict())))
        assert response.status_code == 204

    def test_poorly_defined_functions(self):
        """Tests that poorly defined requests for function evaluations cause an
        error message to be returned.

        """
        # test for bad field name
        search = {'functions': [{'name': 'sum', 'field': 'bogusfieldname'}]}
        resp = self.app.get('/api/eval/person?q={0}'.format(dumps(search)))
        assert resp.status_code == 400
        assert 'message' in loads(resp.data)
        assert 'bogusfieldname' in loads(resp.data)['message']

        # test for bad function name
        search = {'functions': [{'name': 'bogusfuncname', 'field': 'age'}]}
        resp = self.app.get('/api/eval/person?q={0}'.format(dumps(search)))
        assert resp.status_code == 400
        assert 'message' in loads(resp.data)
        assert 'bogusfuncname' in loads(resp.data)['message']

    def test_jsonp(self):
        """Test for JSON-P callbacks."""
        person1 = self.Person(age=10)
        person2 = self.Person(age=20)
        person3 = self.Person(age=35)
        self.session.add_all([person1, person2, person3])
        self.session.commit()
        functions = [{'name': 'sum', 'field': 'age'}]
        query = dumps(dict(functions=functions))
        # JSONP should work on function evaluation endpoints as well as on
        # normal GET endpoints.
        response = self.app.get('/api/eval/person?'
                                'q={0}&callback=baz'.format(query))
        assert response.status_code == 200
        assert response.mimetype == 'application/javascript'
        assert response.data.startswith(b'baz(')
        assert response.data.endswith(b')')

        # Add some more people so the result will be paginated.
        for n in range(20):
            self.session.add(self.Person(name=u'{0}'.format(n)))
        self.session.commit()
        response = self.app.get('/api/person?callback=baz')
        assert response.status_code == 200
        assert response.data.startswith(b'baz(')
        assert response.data.endswith(b')')
        # Get the dictionary representation of the JSON string inside the
        # 'baz()' part of the JSONP response.
        data = loads(response.data[4:-1])
        assert 'meta' in data
        assert 'data' in data
        # The meta should include a JSON representation of the HTTP status.
        assert 'status' in data['meta']
        assert data['meta']['status'] == 200
        # The metadata should include a JSON representation of the HTTP Link
        # header information.
        assert 'Link' in data['meta']
        assert len(data['meta']['Link']) == 2
        assert data['meta']['Link'][0]['rel'] == 'next'
        assert data['meta']['Link'][1]['rel'] == 'last'
        # TODO What other headers should the metadata include?


class TestAPI(TestSupport):
    """Unit tests for the :class:`flask_restless.views.API` class."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`testapp.Person` and
        :class:`testapp.Computer` models.

        """
        # create the database
        super(TestAPI, self).setUp()

        # setup the URLs for the Person and Computer API
        self.manager.create_api(self.Person,
                                methods=['GET', 'PATCH', 'POST', 'DELETE'])
        self.manager.create_api(self.Computer,
                                methods=['GET', 'POST', 'PATCH'])

        # setup the URLs for the Car manufacturer API
        self.manager.create_api(self.CarManufacturer,
                                methods=['GET', 'PATCH', 'POST', 'DELETE'])
        self.manager.create_api(self.CarModel,
                                methods=['GET', 'PATCH', 'POST', 'DELETE'])

        # to facilitate searching
        self.app.search = lambda url, q: self.app.get(url + '?q={0}'.format(q))

    def test_post(self):
        """Test for creating a new instance of the database model using the
        :http:method:`post` method.

        """
        # Invalid JSON in request data should respond with error.
        response = self.app.post('/api/person', data='Invalid JSON string')
        assert response.status_code == 400
        assert loads(response.data)['message'] == 'Unable to decode data'

        # Now, let's test the validation stuff
        # response = self.app.post('/api/person', data=dumps({'name': u'Test',
        #                                                      'age': 'oi'}))
        # assert loads(response.data)['message'] == 'Validation error'
        # assert loads(response.data)['error_list'].keys() == ['age']

        # Test the integrity exception by violating the unique 'name' field
        # of person
        response = self.app.post('/api/person',
                                 data=dumps({'name': u'George', 'age': 23}))
        assert response.status_code == 201

        # This errors as expected
        response = self.app.post('/api/person',
                                 data=dumps({'name': u'George', 'age': 23}))
        assert response.status_code == 400

        # For issue #158 we make sure that the previous failure is rolled back
        # so that we can add valid entries again
        response = self.app.post('/api/person',
                                 data=dumps({'name': u'Benjamin', 'age': 23}))
        assert response.status_code == 201

        response = self.app.post('/api/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 201
        assert 'id' in loads(response.data)

        response = self.app.get('/api/person/1')
        assert response.status_code == 200

        deep = {'computers': [], 'projects': []}
        person = self.session.query(self.Person).filter_by(id=1).first()
        inst = to_dict(person, deep)
        assert loads(response.data) == inst

    def test_post_m2m(self):
        """Test for creating a new instance of the database model that has a
        many to many relation that uses an association object to allow extra
        info to be stored on the helper table.

        For more info, see issue #166.

        """
        vim = self.Program(name=u'Vim')
        emacs = self.Program(name=u'Emacs')
        self.session.add_all([vim, emacs])
        self.session.commit()
        data = {
            'vendor': u'Apple',
            'name': u'iMac',
            'programs': [
                {
                    'program_id': 1,
                    'licensed': False
                },
                {
                    'program_id': 2,
                    'licensed': True
                }
            ]
        }
        response = self.app.post('/api/computer', data=dumps(data))
        assert response.status_code == 201
        assert 'id' in loads(response.data)
        response = self.app.get('/api/computer/1')
        assert response.status_code == 200

    def test_post_bad_parameter(self):
        """Tests that attempting to make a :http:method:`post` request with a
        form parameter which does not exist on the specified model responds
        with an error message.

        """
        response = self.app.post('/api/person', data=dumps(dict(bogus=0)))
        assert 400 == response.status_code

        response = self.app.post('/api/person',
                                 data=dumps(dict(is_minor=True)))
        assert 400 == response.status_code

    def test_post_nullable_date(self):
        """Tests the creation of a model with a nullable date field."""
        self.manager.create_api(self.Star, methods=['GET', 'POST'])
        data = dict(inception_time=None)
        response = self.app.post('/api/star', data=dumps(data))
        assert response.status_code == 201
        response = self.app.get('/api/star/1')
        assert response.status_code == 200
        assert loads(response.data)['inception_time'] is None

    def test_post_empty_date(self):
        """Tests that attempting to assign an empty date string to a date field
        actually assigns a value of ``None``.

        """
        self.manager.create_api(self.Star, methods=['GET', 'POST'])
        data = dict(inception_time='')
        response = self.app.post('/api/star', data=dumps(data))
        assert response.status_code == 201
        response = self.app.get('/api/star/1')
        assert response.status_code == 200
        assert loads(response.data)['inception_time'] is None

    def test_post_date_functions(self):
        """Tests that ``'CURRENT_TIMESTAMP'`` gets converted into a datetime
        object when making a request to set a date or time field.

        """
        self.manager.create_api(self.Star, methods=['GET', 'POST'])
        data = dict(inception_time='CURRENT_TIMESTAMP')
        response = self.app.post('/api/star', data=dumps(data))
        assert response.status_code == 201
        response = self.app.get('/api/star/1')
        assert response.status_code == 200
        inception_time = loads(response.data)['inception_time']
        assert inception_time is not None
        inception_time = dateutil.parser.parse(inception_time)
        diff = datetime.utcnow() - inception_time
        assert diff.days == 0
        assert (diff.seconds + diff.microseconds / 1000000.0) < 3600

    def test_serialize_time(self):
        """Test for getting the JSON representation of a time field."""
        self.manager.create_api(self.User, primary_key='id')
        now = datetime.now().time()
        user = self.User(id=1, email='foo', wakeup=now)
        self.session.add(user)
        self.session.commit()

        response = self.app.get('/api/user/1')
        assert response.status_code == 200
        data = loads(response.data)
        assert data['wakeup'] == now.isoformat()

    def test_post_interval_functions(self):
        oldJSONEncoder = self.flaskapp.json_encoder
        class IntervalJSONEncoder(oldJSONEncoder):
            def default(self, obj):
                if isinstance(obj, timedelta):
                    return int(obj.days * 86400 + obj.seconds)
                return oldJSONEncoder.default(self, obj)
        self.flaskapp.json_encoder = IntervalJSONEncoder

        self.manager.create_api(self.Satellite, methods=['GET', 'POST'])
        data = dict(name="Callufrax_Minor", period=300)
        response = self.app.post('/api/satellite', data=dumps(data))
        assert response.status_code == 201
        response = self.app.get('/api/satellite/Callufrax_Minor')
        assert response.status_code == 200
        assert loads(response.data)['period'] == 300
        satellite = self.session.query(self.Satellite).first()
        assert satellite.period == timedelta(0, 300)

    def test_post_with_submodels(self):
        """Tests the creation of a model with a related field."""
        data = {'name': u'John', 'age': 2041,
                'computers': [{'name': u'lixeiro', 'vendor': u'Lemote'}]}
        response = self.app.post('/api/person', data=dumps(data))
        assert response.status_code == 201
        assert 'id' in loads(response.data)

        response = self.app.get('/api/person')
        assert len(loads(response.data)['objects']) == 1

        # Test with nested objects
        data = dict(name='Rodriguez', age=70,
                    computers=[dict(name='iMac', vendor='Apple',
                                    programs=[dict(program=
                                                   dict(name='iPhoto'))])])
        response = self.app.post('/api/person', data=dumps(data))
        assert 201 == response.status_code
        response = self.app.get('/api/computer/2/programs')
        programs = loads(response.data)['objects']
        assert programs[0]['program']['name'] == 'iPhoto'

    def test_post_with_single_submodel(self):
        data = {'vendor': u'Apple',  'name': u'iMac',
                'owner': {'name': u'John', 'age': 2041}}
        response = self.app.post('/api/computer', data=dumps(data))
        assert response.status_code == 201
        assert 'id' in loads(response.data)
        # Test if owner was successfully created
        response = self.app.get('/api/person')
        assert len(loads(response.data)['objects']) == 1

    def test_patch_update_relations(self):
        """Test for posting a new model and simultaneously adding related
        instances *and* updating information on those instances.

        For more information see issue #164.

        """
        # First, create a new computer object with an empty `name` field and a
        # new person with no related computers.
        response = self.app.post('/api/computer', data=dumps({}))
        assert 201 == response.status_code
        response = self.app.post('/api/person', data=dumps({}))
        assert 201 == response.status_code
        # Second, patch the person by setting its list of related computer
        # instances to include the previously created computer, *and*
        # simultaneously update the `name` attribute of that computer.
        data = dict(computers=[dict(id=1, name='foo')])
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        # Check that the computer now has its `name` field set.
        response = self.app.get('/api/computer/1')
        assert 200 == response.status_code
        assert 'foo' == loads(response.data)['name']
        # Add a new computer by patching person
        data = dict(computers=[dict(id=1),
                               dict(name='iMac', vendor='Apple',
                                    programs=[dict(program=
                                                   dict(name='iPhoto'))])])
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        response = self.app.get('/api/computer/2/programs')
        programs = loads(response.data)['objects']
        assert programs[0]['program']['name'] == 'iPhoto'
        # Add a program to the computer through the person
        data = dict(computers=[dict(id=1),
                               dict(id=2,
                                    programs=[dict(program_id=1),
                                              dict(program=
                                                   dict(name='iMovie'))])])
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        response = self.app.get('/api/computer/2/programs')
        programs = loads(response.data)['objects']
        assert programs[1]['program']['name'] == 'iMovie'

    def test_patch_m2m(self):
        """Test for updating a model with a many to many relation that uses
        an association object to allow extra data to be stored in the helper
        table.

        For more info, see issue #166

        """
        response = self.app.post('/api/computer', data=dumps({}))
        assert 201 == response.status_code
        vim = self.Program(name=u'Vim')
        emacs = self.Program(name=u'Emacs')
        self.session.add_all([vim, emacs])
        self.session.commit()
        data = {
            'programs': {
                'add': [
                    {
                        'program_id': 1,
                        'licensed': False
                    }
                ]
            }
        }
        response = self.app.patch('/api/computer/1', data=dumps(data))
        computer = loads(response.data)
        assert 200 == response.status_code
        vim_relation = {
            'computer_id': 1,
            'program_id': 1,
            'licensed': False
        }
        assert vim_relation in computer['programs']
        data = {
            'programs': {
                'add': [
                    {
                        'program_id': 2,
                        'licensed': True
                    }
                ]
            }
        }
        response = self.app.patch('/api/computer/1', data=dumps(data))
        computer = loads(response.data)
        assert 200 == response.status_code
        emacs_relation = {
            'computer_id': 1,
            'program_id': 2,
            'licensed': True
        }
        assert emacs_relation in computer['programs']
        vim_relation = {
            'computer_id': 1,
            'program_id': 1,
            'licensed': False
        }
        assert vim_relation in computer['programs']

    def test_patch_remove_m2m(self):
        """Test for removing a relation on a model that uses an association
        object to allow extra data to be stored in the helper table.

        For more info, see issue #166

        """
        response = self.app.post('/api/computer', data=dumps({}))
        assert 201 == response.status_code
        vim = self.Program(name=u'Vim')
        emacs = self.Program(name=u'Emacs')
        self.session.add_all([vim, emacs])
        self.session.commit()
        data = {
            'programs': [
                {
                    'program_id': 1,
                    'licensed': False
                },
                {
                    'program_id': 2,
                    'licensed': True
                }
            ]
        }
        response = self.app.patch('/api/computer/1', data=dumps(data))
        computer = loads(response.data)
        assert 200 == response.status_code
        vim_relation = {
            'computer_id': 1,
            'program_id': 1,
            'licensed': False
        }
        emacs_relation = {
            'computer_id': 1,
            'program_id': 2,
            'licensed': True
        }
        assert vim_relation in computer['programs']
        assert emacs_relation in computer['programs']
        data = {
            'programs': {
                'remove': [{'program_id': 1}]
            }
        }
        response = self.app.patch('/api/computer/1', data=dumps(data))
        computer = loads(response.data)
        assert 200 == response.status_code
        assert vim_relation not in computer['programs']
        assert emacs_relation in computer['programs']

    def test_delete(self):
        """Test for deleting an instance of the database using the
        :http:method:`delete` method.

        """
        # Creating the person who's gonna be deleted
        response = self.app.post('/api/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 201
        assert 'id' in loads(response.data)

        # Making sure it has been created
        deep = {'computers': [], 'projects': []}
        person = self.session.query(self.Person).filter_by(id=1).first()
        inst = to_dict(person, deep)
        response = self.app.get('/api/person/1')
        assert loads(response.data) == inst

        # Deleting it
        response = self.app.delete('/api/person/1')
        assert response.status_code == 204

        # Making sure it has been deleted
        people = self.session.query(self.Person).filter_by(id=1)
        assert people.count() == 0

    def test_delete_absent_instance(self):
        """Test that deleting an instance of the model which does not exist
        fails.

        This should give us the same response as when there is an object there,
        since the :http:method:`delete` method is an idempotent method.

        """
        response = self.app.delete('/api/person/1')
        assert response.status_code == 204

    def test_disallow_patch_many(self):
        """Tests that disallowing "patch many" requests responds with a
        :http:statuscode:`405`.

        """
        response = self.app.patch('/api/person', data=dumps(dict(name='foo')))
        assert response.status_code == 405

    def test_put_same_as_patch(self):
        """Tests that :http:method:`put` requests are the same as
        :http:method:`patch` requests.

        """
        # recreate the api to allow patch many at /api/v2/person
        self.manager.create_api(self.Person, methods=['GET', 'POST', 'PUT'],
                                allow_patch_many=True, url_prefix='/api/v2')

        # Creating some people
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # change a single entry
        resp = self.app.put('/api/v2/person/1', data=dumps({'age': 24}))
        assert resp.status_code == 200

        resp = self.app.get('/api/v2/person/1')
        assert resp.status_code == 200
        assert loads(resp.data)['age'] == 24

        # Changing the birth date field of the entire collection
        day, month, year = 15, 9, 1986
        birth_date = date(year, month, day).strftime('%d/%m/%Y')  # iso8601
        form = {'birth_date': birth_date}
        self.app.put('/api/v2/person', data=dumps(form))

        # Finally, testing if the change was made
        response = self.app.get('/api/v2/person')
        loaded = loads(response.data)['objects']
        for i in loaded:
            expected = '{0:4d}-{1:02d}-{2:02d}'.format(year, month, day)
            assert i['birth_date'] == expected

    def test_patch_empty(self):
        """Test for making a :http:method:`patch` request with no data."""
        response = self.app.post('/api/person', data=dumps(dict(name='foo')))
        assert response.status_code == 201
        personid = loads(response.data)['id']
        # here we really send no data
        response = self.app.patch('/api/person/' + str(personid))
        assert response.status_code == 400
        # here we send the empty string (which is not valid JSON)
        response = self.app.patch('/api/person/' + str(personid), data='')
        assert response.status_code == 400

    def test_patch_bad_parameter(self):
        """Tests that attempting to make a :http:method:`patch` request with a
        form parameter which does not exist on the specified model responds
        with an error message.

        """
        response = self.app.post('/api/person', data=dumps({}))
        assert 201 == response.status_code
        response = self.app.patch('/api/person/1', data=dumps(dict(bogus=0)))
        assert 400 == response.status_code

    def test_patch_many(self):
        """Test for updating a collection of instances of the model using the
        :http:method:`patch` method.

        """
        # recreate the api to allow patch many at /api/v2/person
        self.manager.create_api(self.Person, methods=['GET', 'POST', 'PATCH'],
                                allow_patch_many=True, url_prefix='/api/v2')

        # Creating some people
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Mary', 'age': 25}))

        # Trying to pass invalid data to the update method
        resp = self.app.patch('/api/v2/person', data='Hello there')
        assert resp.status_code == 400
        assert loads(resp.data)['message'] == 'Unable to decode data'

        # Changing the birth date field of the entire collection
        day, month, year = 15, 9, 1986
        birth_date = date(year, month, day).strftime('%d/%m/%Y')  # iso8601
        form = {'birth_date': birth_date}
        self.app.patch('/api/v2/person', data=dumps(form))

        # Finally, testing if the change was made
        response = self.app.get('/api/v2/person')
        loaded = loads(response.data)['objects']
        for i in loaded:
            expected = '{0:4d}-{1:02d}-{2:02d}'.format(year, month, day)
            assert i['birth_date'] == expected

    def test_patch_many_with_filter(self):
        """Test for updating a collection of instances of the model using a
        :http:method:patch request with filters.

        """
        # recreate the api to allow patch many at /api/v2/person
        self.manager.create_api(self.Person, methods=['GET', 'POST', 'PATCH'],
                                allow_patch_many=True, url_prefix='/api/v2')
        # Creating some people
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lincoln', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Lucy', 'age': 23}))
        self.app.post('/api/v2/person',
                      data=dumps({'name': u'Mary', 'age': 25}))
        search = {'filters': [{'name': 'name', 'val': u'Lincoln',
                               'op': 'equals'}]}
        # Changing the birth date field for objects where name field equals
        # Lincoln
        day, month, year = 15, 9, 1986
        birth_date = date(year, month, day).strftime('%d/%m/%Y')  # iso8601
        form = {'birth_date': birth_date, 'q': search}
        response = self.app.patch('/api/v2/person', data=dumps(form))
        num_modified = loads(response.data)['num_modified']
        assert num_modified == 1

    def test_single_update(self):
        """Test for updating a single instance of the model using the
        :http:method:`patch` method.

        """
        resp = self.app.post('/api/person', data=dumps({'name': u'Lincoln',
                                                        'age': 10}))
        assert resp.status_code == 201
        assert 'id' in loads(resp.data)

        # Trying to pass invalid data to the update method
        resp = self.app.patch('/api/person/1', data='Invalid JSON string')
        assert resp.status_code == 400
        assert loads(resp.data)['message'] == 'Unable to decode data'

        resp = self.app.patch('/api/person/1', data=dumps({'age': 24}))
        assert resp.status_code == 200

        resp = self.app.get('/api/person/1')
        assert resp.status_code == 200
        assert loads(resp.data)['age'] == 24

    def test_patch_404(self):
        """Tests that making a :http:method:`patch` request to an instance
        which does not exist results in a :http:statuscode:`404`.

        """
        resp = self.app.patch('/api/person/1', data=dumps(dict(name='foo')))
        assert resp.status_code == 404

    def test_patch_with_single_submodel(self):
        # Create a new object with a single submodel
        data = {'vendor': u'Apple', 'name': u'iMac',
                'owner': {'name': u'John', 'age': 2041}}
        response = self.app.post('/api/computer', data=dumps(data))
        assert response.status_code == 201
        data = loads(response.data)
        assert 1 == data['owner']['id']
        assert u'John' == data['owner']['name']
        assert 2041 == data['owner']['age']

        # Update the submodel
        data = {'id': 1, 'owner': {'id': 1, 'age': 29}}
        response = self.app.patch('/api/computer/1', data=dumps(data))
        assert response.status_code == 200
        data = loads(response.data)

        assert u'John' == data['owner']['name']
        assert 29 == data['owner']['age']

    def test_patch_set_submodel(self):
        """Test for assigning a list to a relation of a model using
        :http:method:`patch`.

        """
        # create the person
        response = self.app.post('/api/person', data=dumps({}))
        assert response.status_code == 201

        # patch the person with some computers
        data = {'computers': [{'name': u'lixeiro', 'vendor': u'Lemote'},
                              {'name': u'foo', 'vendor': u'bar'}]}
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['computers'])
        assert u'lixeiro' == data['computers'][0]['name']
        assert u'Lemote' == data['computers'][0]['vendor']
        assert u'foo' == data['computers'][1]['name']
        assert u'bar' == data['computers'][1]['vendor']

        # change one of the computers
        data = {'computers': [{'id': data['computers'][0]['id']},
                              {'id': data['computers'][1]['id'],
                               'vendor': u'Apple'}]}
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['computers'])
        assert u'lixeiro' == data['computers'][0]['name']
        assert u'Lemote' == data['computers'][0]['vendor']
        assert u'foo' == data['computers'][1]['name']
        assert u'Apple' == data['computers'][1]['vendor']

        # patch the person with some new computers
        data = {'computers': [{'name': u'hey', 'vendor': u'you'},
                              {'name': u'big', 'vendor': u'money'},
                              {'name': u'milk', 'vendor': u'chocolate'}]}
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert 200 == response.status_code
        data = loads(response.data)
        assert 3 == len(data['computers'])
        assert u'hey' == data['computers'][0]['name']
        assert u'big' == data['computers'][1]['name']
        assert u'milk' == data['computers'][2]['name']

    def test_patch_duplicate(self):
        """Test for assigning a list containing duplicate items
        to a relation of a model using :http:method:`patch`.

        """
        # create the manufacturer with a duplicate car
        data = {'name': u'Ford', 'models': [{'name': u'Maverick', 'seats': 2},
                                            {'name': u'Mustang', 'seats': 4},
                                            {'name': u'Maverick', 'seats': 2}]}
        response = self.app.post('/api/car_manufacturer', data=dumps(data))
        assert response.status_code == 201
        responsedata = loads(response.data)
        assert 3 == len(data['models'])
        assert u'Maverick' == responsedata['models'][0]['name']
        assert u'Mustang' == responsedata['models'][1]['name']
        assert u'Maverick' == responsedata['models'][2]['name']

        # add another duplicate car
        data['models'].append({'name': u'Mustang', 'seats': 4})
        response = self.app.patch('/api/car_manufacturer/1', data=dumps(data))
        assert response.status_code == 200
        data = loads(response.data)
        assert 4 == len(data['models'])
        assert u'Maverick' == data['models'][0]['name']
        assert u'Mustang' == data['models'][1]['name']
        assert u'Maverick' == data['models'][2]['name']
        assert u'Mustang' == data['models'][3]['name']

    def test_patch_new_single(self):
        """Test for adding a single new object to a one-to-one relationship
        using :http:method:`patch`.

        """
        # create the person
        data = {'name': u'Lincoln', 'age': 23}
        response = self.app.post('/api/person', data=dumps(data))
        assert response.status_code == 201

        # patch the person with a new computer
        data = {'computers': {'add': {'name': u'lixeiro',
                                      'vendor': u'Lemote'}}}

        response = self.app.patch('/api/person/1', data=dumps(data))
        assert response.status_code == 200

        # Let's check it out
        response = self.app.get('/api/person/1')
        loaded = loads(response.data)

        assert len(loaded['computers']) == 1
        assert loaded['computers'][0]['name'] == \
            data['computers']['add']['name']
        assert loaded['computers'][0]['vendor'] == \
            data['computers']['add']['vendor']

        # test that this new computer was added to the database as well
        computer = self.session.query(self.Computer).filter_by(id=1).first()
        assert computer is not None
        assert data['computers']['add']['name'] == computer.name
        assert data['computers']['add']['vendor'] == computer.vendor

    def test_patch_existing_single(self):
        """Test for adding a single existing object to a one-to-one
        relationship using :http:method:`patch`.

        """
        # create the person
        data = {'name': u'Lincoln', 'age': 23}
        response = self.app.post('/api/person', data=dumps(data))
        assert response.status_code == 201

        # create the computer
        data = {'name': u'lixeiro', 'vendor': u'Lemote'}
        response = self.app.post('/api/computer', data=dumps(data))
        assert response.status_code == 201

        # patch the person with the created computer
        data = {'computers': {'add': {'id': 1}}}
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert response.status_code == 200

        # Let's check it out
        response = self.app.get('/api/person/1')
        loaded = loads(response.data)

        assert len(loaded['computers']) == 1
        assert loaded['computers'][0]['id'] == data['computers']['add']['id']

    def test_patch_add_submodels(self):
        """Test for updating a single instance of the model by adding a list of
        related models using the :http:method:`patch` method.

        """
        data = dict(name=u'Lincoln', age=23)
        response = self.app.post('/api/person', data=dumps(data))
        assert response.status_code == 201

        add1 = {'name': u'lixeiro', 'vendor': u'Lemote'}
        add2 = {'name': u'foo', 'vendor': u'bar'}
        data = {'computers': {'add': [add1, add2]}}
        response = self.app.patch('/api/person/1', data=dumps(data))
        assert response.status_code == 200
        response = self.app.get('/api/person/1')
        loaded = loads(response.data)

        assert len(loaded['computers']) == 2
        assert loaded['computers'][0]['name'] == u'lixeiro'
        assert loaded['computers'][0]['vendor'] == u'Lemote'
        assert loaded['computers'][1]['name'] == u'foo'
        assert loaded['computers'][1]['vendor'] == u'bar'

        # test that these new computers were added to the database as well
        computer = self.session.query(self.Computer).filter_by(id=1).first()
        assert computer is not None
        assert u'lixeiro' == computer.name
        assert u'Lemote' == computer.vendor
        computer = self.session.query(self.Computer).filter_by(id=2).first()
        assert computer is not None
        assert u'foo' == computer.name
        assert u'bar' == computer.vendor

    def test_patch_remove_submodel(self):
        """Test for updating a single instance of the model by removing a
        related model using the :http:method:`patch` method.

        """
        # Creating the row that will be updated
        data = {
            'name': u'Lincoln', 'age': 23,
            'computers': [
                {'name': u'lixeiro', 'vendor': u'Lemote'},
                {'name': u'pidinti', 'vendor': u'HP'},
            ],
        }
        self.app.post('/api/person', data=dumps(data))

        # Data for the update
        update_data = {
            'computers': {
                'remove': [{'name': u'pidinti'}],
            }
        }
        resp = self.app.patch('/api/person/1', data=dumps(update_data))
        assert resp.status_code == 200
        assert loads(resp.data)['id'] == 1

        # Let's check it out
        response = self.app.get('/api/person/1')
        loaded = loads(response.data)
        assert len(loaded['computers']) == 1

    def test_patch_autodelete_submodel(self):
        """Tests the automatic deletion of entries marked with the
        ``__delete__`` flag on an update operation.

        It also tests adding an already created instance as a related item.

        """
        # Creating all rows needed in our test
        person_data = {'name': u'Lincoln', 'age': 23}
        resp = self.app.post('/api/person', data=dumps(person_data))
        assert resp.status_code == 201
        comp_data = {'name': u'lixeiro', 'vendor': u'Lemote'}
        resp = self.app.post('/api/computer', data=dumps(comp_data))
        assert resp.status_code == 201

        # updating person to add the computer
        update_data = {'computers': {'add': [{'id': 1}]}}
        self.app.patch('/api/person/1', data=dumps(update_data))

        # Making sure that everything worked properly
        resp = self.app.get('/api/person/1')
        assert resp.status_code == 200
        loaded = loads(resp.data)
        assert len(loaded['computers']) == 1
        assert loaded['computers'][0]['name'] == u'lixeiro'

        # Now, let's remove it and delete it
        update2_data = {
            'computers': {
                'remove': [
                    {'id': 1, '__delete__': True},
                ],
            },
        }
        resp = self.app.patch('/api/person/1', data=dumps(update2_data))
        assert resp.status_code == 200

        # Testing to make sure it was removed from the related field
        resp = self.app.get('/api/person/1')
        assert resp.status_code == 200
        loaded = loads(resp.data)
        assert len(loaded['computers']) == 0

        # Making sure it was removed from the database
        resp = self.app.get('/api/computer/1')
        assert resp.status_code == 404

    def test_pagination(self):
        """Tests for pagination of long result sets."""
        self.manager.create_api(self.Person, url_prefix='/api/v2',
                                results_per_page=5)
        self.manager.create_api(self.Person, url_prefix='/api/v3',
                                results_per_page=0)
        for i in range(25):
            d = dict(name='person{0}'.format(i))
            response = self.app.post('/api/person', data=dumps(d))
            assert response.status_code == 201

        response = self.app.get('/api/person')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 1
        assert len(loads(response.data)['objects']) == 10
        assert loads(response.data)['total_pages'] == 3

        response = self.app.get('/api/person?page=1')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 1
        assert len(loads(response.data)['objects']) == 10
        assert loads(response.data)['total_pages'] == 3

        response = self.app.get('/api/person?page=2')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 2
        assert len(loads(response.data)['objects']) == 10
        assert loads(response.data)['total_pages'] == 3

        response = self.app.get('/api/person?page=3')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 3
        assert len(loads(response.data)['objects']) == 5
        assert loads(response.data)['total_pages'] == 3

        response = self.app.get('/api/v2/person?page=3')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 3
        assert len(loads(response.data)['objects']) == 5
        assert loads(response.data)['total_pages'] == 5

        response = self.app.get('/api/v3/person')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 1
        assert len(loads(response.data)['objects']) == 25
        assert loads(response.data)['total_pages'] == 1

        response = self.app.get('/api/v3/person?page=2')
        assert response.status_code == 200
        assert loads(response.data)['page'] == 1
        assert len(loads(response.data)['objects']) == 25
        assert loads(response.data)['total_pages'] == 1

    def test_num_results(self):
        """Tests that a request for (a subset of) all instances of a model
        includes the total number of results as part of the JSON response.

        """
        self.manager.create_api(self.Person)
        for i in range(15):
            d = dict(name='person{0}'.format(i))
            response = self.app.post('/api/person', data=dumps(d))
            assert response.status_code == 201
        response = self.app.get('/api/person')
        assert response.status_code == 200
        data = loads(response.data)
        assert 'num_results' in data
        assert data['num_results'] == 15

    def test_alternate_primary_key(self):
        """Tests that models with primary keys which are not ``id`` columns are
        accessible via their primary keys.

        """
        self.manager.create_api(self.Planet, methods=['GET', 'POST'])
        response = self.app.post('/api/planet', data=dumps(dict(name='Earth')))
        assert response.status_code == 201
        response = self.app.get('/api/planet/1')
        assert response.status_code == 404
        response = self.app.get('/api/planet')
        assert response.status_code == 200
        assert len(loads(response.data)['objects']) == 1
        response = self.app.get('/api/planet/Earth')
        assert response.status_code == 200
        assert loads(response.data) == dict(name='Earth')

    def test_post_form_preprocessor(self):
        """Tests POST method decoration using a custom function."""
        def decorator_function(data=None, **kw):
            if data:
                data['other'] = 7

        # test for function that decorates parameters with 'other' attribute
        self.manager.create_api(self.Person, methods=['POST'],
                                url_prefix='/api/v2',
                                post_form_preprocessor=decorator_function)

        response = self.app.post('/api/v2/person',
                                 data=dumps({'name': u'Lincoln', 'age': 23}))
        assert response.status_code == 201

        personid = loads(response.data)['id']
        person = self.session.query(self.Person).filter_by(id=personid).first()
        assert person.other == 7

    def test_results_per_page(self):
        """Tests that the client can correctly specify the number of results
        appearing per page, in addition to specifying which page of results to
        return.

        """
        self.manager.create_api(self.Person, methods=['POST', 'GET'])
        for n in range(25):
            response = self.app.post('/api/person', data=dumps({}))
            assert 201 == response.status_code
        response = self.app.get('/api/person?results_per_page=20')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 20 == len(data['objects'])
        # Fall back to default number of results per page on bad requests.
        response = self.app.get('/api/person?results_per_page=-1')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 10 == len(data['objects'])
        # Only return max number of results per page.
        response = self.app.get('/api/person?results_per_page=30')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 25 == len(data['objects'])

    def test_get_string_pk(self):
        """Tests for getting a row which has a string primary key, including
        the possibility of a string representation of a number.

        """
        # create a model and an instance of the model
        class StringID(self.Base):
            __tablename__ = 'stringid'
            name = Column(Unicode, primary_key=True)
        self.Base.metadata.create_all()
        self.manager.create_api(StringID)

        foo = StringID(name=u'1')
        self.session.add(foo)
        self.session.commit()
        response = self.app.get('/api/stringid/1')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'name' in data
        assert '1' == data['name']
        response = self.app.get('/api/stringid/01')
        assert 404 == response.status_code

        bar = StringID(name=u'01')
        self.session.add(bar)
        self.session.commit()
        response = self.app.get('/api/stringid/01')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'name' in data
        assert '01' == data['name']

        baz = StringID(name=u'hey')
        self.session.add(baz)
        self.session.commit()
        response = self.app.get('/api/stringid/hey')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 'name' in data
        assert 'hey' == data['name']

    def test_jsonp(self):
        """Test for JSON-P callbacks."""
        person1 = self.Person(name=u'foo')
        person2 = self.Person(name=u'bar')
        self.session.add_all([person1, person2])
        self.session.commit()
        # test for GET
        response = self.app.get('/api/person/1?callback=baz')
        assert 200 == response.status_code
        assert response.data.startswith(b'baz(')
        assert response.data.endswith(b')')
        # test for search
        response = self.app.get('/api/person?callback=baz')
        assert 200 == response.status_code
        assert response.data.startswith(b'baz(')
        assert response.data.endswith(b')')

    def test_duplicate_post(self):
        """Tests for making a :http:method:`post` request with data that
        already exists in the database.

        """
        data = dict(name='test')
        response = self.app.post('/api/person', data=dumps(data))
        assert 201 == response.status_code
        response = self.app.post('/api/person', data=dumps(data))
        assert 400 == response.status_code

    def test_delete_from_relation(self):
        """Tests that a :http:method:`delete` request to a related instance
        removes that related instance from the specified model.

        See issue #193.

        """
        person = self.Person()
        computer = self.Computer()
        person.computers.append(computer)
        self.session.add_all((person, computer))
        self.session.commit()
        # Delete the related computer.
        response = self.app.delete('/api/person/1/computers/1')
        assert response.status_code == 204
        # Check that it is actually gone from the relation.
        response = self.app.get('/api/person/1')
        assert response.status_code == 200
        assert len(loads(response.data)['computers']) == 0
        # Check that the related instance hasn't been deleted from the database
        # altogether.
        response = self.app.get('/api/computer/1')
        assert response.status_code == 200

        # # Add the computer back in to the relation and use the Delete-Orphan
        # # header to instruct the server to delete the orphaned computer
        # # instance.
        # person.computers.append(computer)
        # self.session.commit()
        # response = self.app.delete('/api/person/1/computers/1',
        #                            headers={'Delete-Orphan': 1})
        # assert response.status_code == 204
        # response = self.app.get('/api/person/1/computers')
        # assert response.status_code == 200
        # assert len(loads(response.data)['computers']) == 0
        # response = self.app.get('/api/computers')
        # assert response.status_code == 200
        # assert len(loads(response.data)['objects']) == 0

    def test_get_callable_query_attribute(self):
        """Tests that a callable model.query attribute is being used
        when available.

        """
        # create aliases for the sake of brevity
        CarModel, CarManufacturer = self.CarModel, self.CarManufacturer

        # create some example car manufacturers and models
        manufacturer_name = u'Super Cars Ltd.'
        cm1 = CarManufacturer(name=manufacturer_name)
        cm2 = CarManufacturer(name=u'Trash Cars Ltd.')
        self.session.add_all((cm1, cm2))

        car1 = CarModel(name=u'Luxory deluxe L', manufacturer=cm1)
        car2 = CarModel(name=u'Luxory deluxe XL', manufacturer=cm1)
        car3 = CarModel(name=u'Broken wheel', manufacturer=cm2)
        self.session.add_all((car1, car2, car3))
        self.session.commit()

        # create a custom query method for the CarModel class
        def query(cls):
            car_model = self.session.query(CarModel)
            return car_model.join(CarManufacturer).filter(
                CarManufacturer.name==manufacturer_name)
        CarModel.query = classmethod(query)

        response = self.app.get('/api/car_model')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['objects'])

        for car in data['objects']:
          assert car['manufacturer']['name'] == manufacturer_name

        for car in [car1, car2]:
          response = self.app.get('/api/car_model/{0}'.format(car.id))
          assert 200 == response.status_code
          data = loads(response.data)
          assert data['manufacturer_id'] == cm1.id
          assert data['name'] == car.name

        response = self.app.get('/api/car_model/{0}'.format(car3.id))
        assert 404 == response.status_code


class TestHeaders(TestSupportPrefilled):
    """Tests for correct HTTP headers in responses."""

    def setUp(self):
        super(TestHeaders, self).setUp()
        self.manager.create_api(self.Person, methods=['GET', 'POST', 'PATCH'])

    def test_post_location(self):
        """Tests that a :http:method:`post` request responds with the correct
        ``Location`` header.

        """
        response = self.app.post('/api/person', data=dumps({}))
        assert 201 == response.status_code
        assert 'Location' in response.headers
        # there are five existing people
        expected = 'http://localhost/api/person/6'
        actual = response.headers['Location']
        assert expected == actual

    def test_pagination_links(self):
        """Tests that a :http:method:`get` request that would respond with a
        paginated list of results returns the appropriate ``Link`` headers.

        """
        response = self.app.get('/api/person?page=2&results_per_page=1')
        assert 200 == response.status_code
        assert 'Link' in response.headers
        links = response.headers['Link']
        # next page
        assert 'page=3' in links
        assert 'rel="next"' in links
        # last page
        assert 'page=5' in links
        assert 'rel="last"' in links

    def test_content_type(self):
        """Tests that the server responds only to requests with a JSON
        Content-Type.

        """
        # A request that does not require a body without a Content-Type headers
        # should be OK either way.
        response = self.app.get('/api/person/1', content_type=None)
        assert 200 == response.status_code
        response = self.app.get('/api/person/1',
                                content_type='application/json')
        assert 200 == response.status_code
        # A request that requires a body but without a Content-Type header
        # should produce an error (specifically, error 415 Unsupported media
        # type).
        response = self.app.post('/api/person', data=dumps(dict(name='foo')),
                                 content_type=None)
        assert 415 == response.status_code
        response = self.app.post('/api/person', data=dumps(dict(name='foo')),
                                 content_type='application/json')
        assert 201 == response.status_code
        # A request without an Accept header should return JSON.
        assert 'Content-Type' in response.headers
        assert 'application/json' == response.headers['Content-Type']
        assert 'foo' == loads(response.data)['name']
        response = self.app.post('/api/person', data=dumps(dict(name='foo')),
                                 content_type=None)
        assert 415 == response.status_code
        # Same goes for a PATCH request.
        response = self.app.patch('/api/person/6', data=dumps(dict(name='x')),
                                  content_type=None)
        assert 415 == response.status_code
        response = self.app.patch('/api/person/6', data=dumps(dict(name='x')),
                                  content_type='application/json')
        assert 200 == response.status_code
        content_type = 'application/json; charset=UTF-8'
        response = self.app.patch('/api/person/6', data=dumps(dict(name='x')),
                                  content_type=content_type)
        assert 200 == response.status_code

        # A request without an Accept header should return JSON.
        assert 'Content-Type' in response.headers
        assert 'application/json' == response.headers['Content-Type']
        assert 'x' == loads(response.data)['name']

    def test_content_type_msie(self):
        """Tests for compatibility with Microsoft Internet Explorer 8 and 9.

        According to issue #267, making requests using JavaScript from these
        web browsers does not allow changing the content type of the request
        (it is always ``text/html``). Therefore :http:method:`post` and
        :http:method:`patch` should ignore the content type when a request is
        coming from these old browsers.

        """
        # Test for Microsoft Internet Explorer 8.
        headers = {'User-Agent': '{0}'.format(MSIE8_UA)}
        content_type = 'text/html'
        data = dict(name=u'foo')
        response = self.app.post('/api/person', data=dumps(data),
                                 headers=headers, content_type=content_type)
        assert response.status_code == 201
        person = loads(response.data)
        assert person['name'] == 'foo'
        personid = person['id']
        data = dict(name=u'bar')
        response = self.app.patch('/api/person/{0}'.format(personid),
                                  data=dumps(data), headers=headers,
                                  content_type=content_type)
        assert response.status_code == 200
        person = loads(response.data)
        assert person['name'] == 'bar'

        # Test for Microsoft Internet Explorer 9.
        headers = {'User-Agent': '{0}'.format(MSIE9_UA)}
        data = dict(name=u'foo2')
        response = self.app.post('/api/person', data=dumps(data),
                                 headers=headers, content_type=content_type)
        assert response.status_code == 201
        personid = loads(response.data)['id']
        data = dict(name=u'bar2')
        response = self.app.patch('/api/person/{0}'.format(personid),
                                  data=dumps(data), headers=headers,
                                  content_type=content_type)
        assert response.status_code == 200
        assert loads(response.data)['name'] == 'bar2'

    def test_accept(self):
        """Tests that the server responds to the ``Accept`` with a response of
        the correct content-type.

        """
        # A request without an Accept header should return JSON.
        headers = None
        response = self.app.get('/api/person/1', headers=headers)
        assert 200 == response.status_code
        assert 'Content-Type' in response.headers
        assert 'application/json' == response.headers['Content-Type']
        assert 1 == loads(response.data)['id']
        headers = dict(Accept='application/json')
        response = self.app.get('/api/person/1', headers=headers)
        assert 200 == response.status_code
        assert 'Content-Type' in response.headers
        assert 'application/json' == response.headers['Content-Type']
        assert 1 == loads(response.data)['id']
        # Check for accepting XML.
        # headers = dict(Accept='application/xml')
        # response = self.app.get('/api/person/1', headers=headers)
        # assert 200 == response.status_code
        # assert 'Content-Type' in response.headers
        # assert 'application/xml' == response.headers['Content-Type']
        # assert '<id>1</id>' in response.data


class TestSearch(TestSupportPrefilled):
    """Unit tests for the search query functionality."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`testapp.Person` and
        :class:`testapp.Computer` models.

        """
        super(TestSearch, self).setUp()
        self.manager.create_api(self.Person, methods=['GET', 'PATCH'])
        self.app.search = lambda url, q: self.app.get(url + '?q={0}'.format(q))

    def test_search(self):
        """Tests basic search using the :http:method:`get` method."""
        # Trying to pass invalid params to the search method
        resp = self.app.get('/api/person?q=Test')
        assert resp.status_code == 400
        assert loads(resp.data)['message'] == 'Unable to decode data'

        search = {'filters': [{'name': 'name', 'val': '%y%', 'op': 'like'}]}
        # Let's search for users with that above filter
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        loaded = loads(resp.data)
        assert len(loaded['objects']) == 3  # Mary, Lucy and Katy

        # Tests searching for a single row
        search = {
            'single': True,      # I'm sure we have only one row here
            'filters': [
                {'name': 'name', 'val': u'Lincoln', 'op': 'equals'}
            ],
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        assert loads(resp.data)['name'] == u'Lincoln'

        # Looking for something that does not exist on the database
        search['filters'][0]['val'] = 'Sammy'
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 404
        assert loads(resp.data)['message'] == 'No result found'

        # We have to receive an error if the user provides an invalid
        # data to the search, like this:
        search = {
            'filters': [
                {'name': 'age', 'val': 'It should not be a string', 'op': 'gt'}
            ]
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        #assert loads(resp.data)['error_list'][0] == \
        #    {'age': 'Please enter a number'}
        assert len(loads(resp.data)['objects']) == 0

        # Testing the order_by stuff
        search = {'order_by': [{'field': 'age', 'direction': 'asc'}]}
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        loaded = loads(resp.data)['objects']
        assert loaded[0][u'age'] == 7
        assert loaded[1][u'age'] == 19
        assert loaded[2][u'age'] == 23
        assert loaded[3][u'age'] == 25
        assert loaded[4][u'age'] == 28

        # Test the IN operation
        search = {
            'filters': [
                {'name': 'age', 'val': [7, 28], 'op': 'in'}
            ]
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        loaded = loads(resp.data)['objects']
        assert loaded[0][u'age'] == 7
        assert loaded[1][u'age'] == 28

        # Testing related search
        update = {
            'computers': {
                'add': [{'name': u'lixeiro', 'vendor': u'Lenovo'}]
            }
        }
        resp = self.app.patch('/api/person/1', data=dumps(update))
        assert resp.status_code == 200

        # TODO document this
        search = {
            'single': True,
            'filters': [
                {'name': 'computers__name',
                 'val': u'lixeiro',
                 'op': 'any'}
            ]
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        assert loads(resp.data)['computers'][0]['name'] == 'lixeiro'

        # Testing the comparation for two fields. We want to compare
        # `age' and `other' fields. If the first one is lower than or
        # equals to the second one, we want the object
        search = {
            'filters': [
                {'name': 'age', 'op': 'lte', 'field': 'other'}
            ],
            'order_by': [
                {'field': 'other'}
            ]
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        loaded = loads(resp.data)['objects']
        assert len(loaded) == 2
        assert loaded[0]['other'] == 10
        assert loaded[1]['other'] == 19

    def test_search2(self):
        """Testing more search functionality."""
        # Let's test the search using an id
        search = {
            'single': True,
            'filters': [{'name': 'id', 'op': 'equal_to', 'val': 1}]
        }
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        assert loads(resp.data)['name'] == u'Lincoln'

        # Testing limit and offset
        search = {'limit': 1, 'offset': 1}
        resp = self.app.search('/api/person', dumps(search))
        assert resp.status_code == 200
        assert 1 == len(loads(resp.data)['objects'])
        assert loads(resp.data)['objects'][0]['name'] == u'Mary'

        # Testing multiple results when calling .one()
        resp = self.app.search('/api/person', dumps({'single': True}))
        assert resp.status_code == 400
        assert loads(resp.data)['message'] == 'Multiple results found'

    def test_search_disjunction(self):
        """Tests for search with disjunctive filters."""
        data = dict(filters=[dict(name='age', op='le', val=10),
                             dict(name='age', op='ge', val=25)],
                    disjunction=True)
        response = self.app.search('/api/person', dumps(data))
        assert 200 == response.status_code
        data = loads(response.data)['objects']
        assert 3 == len(data)
        assert set(['Lucy', 'Katy', 'John']) == \
            set([person['name'] for person in data])

    def test_search_bad_arguments(self):
        """Tests that search requests with bad parameters respond with an error
        message.

        """
        # missing argument
        d = dict(filters=[dict(name='name', op='==')])
        resp = self.app.search('/api/person', dumps(d))
        assert resp.status_code == 400

        # missing operator
        d = dict(filters=[dict(name='name', val='Test')])
        resp = self.app.search('/api/person', dumps(d))
        assert resp.status_code == 400

        # missing fieldname
        d = dict(filters=[dict(op='==', val='Test')])
        resp = self.app.search('/api/person', dumps(d))
        assert resp.status_code == 400


class TestAssociationProxy(DatabaseTestBase):
    """Unit tests for models which have a relationship involving an association
    proxy.

    """

    def setUp(self):
        """Creates example models which are related by an association proxy
        table.

        """
        super(TestAssociationProxy, self).setUp()

        tag_product = Table('tag_product', self.Base.metadata,
                            Column('tag_id', Integer,
                                   ForeignKey('tag.id'),
                                   primary_key=True),
                            Column('product_id', Integer,
                                   ForeignKey('product.id'),
                                   primary_key=True))

        # Metadata is a key-value pair, used to test for association
        # proxies that use AssociationDict types
        # this is the association table for Image->metadata
        product_meta = Table('product_meta', self.Base.metadata,
                 Column('image_id', Integer, ForeignKey('image.id')),
                 Column('meta_id', Integer, ForeignKey('meta.id')))

        # For brevity, create this association proxy creator functions here.
        creator1 = lambda product: ChosenProductImage(product=product)
        creator2 = lambda image: ChosenProductImage(image=image)
        creator3 = lambda key, value: Metadata(key, value)
        class Metadata(self.Base):
            def __init__(self, key, value):
                super(Metadata, self).__init__()
                self.key = key
                self.value = value

            __tablename__ = 'meta'
            id = Column(Integer, primary_key=True)
            key = Column(String(256), nullable=False)
            value = Column(String(256))

        class Image(self.Base):
            __tablename__ = 'image'
            id = Column(Integer, primary_key=True)
            products = prox('chosen_product_images', 'product',
                            creator=creator1)

            meta_store = rel('Metadata',
                             cascade='all',
                             backref=backref(name='metadata'),
                             collection_class=col_mapped(
                                                    Metadata.__table__.c.key),
                             secondary=lambda: product_meta)
            meta = prox('meta_store', 'value', creator=creator3)

        class ChosenProductImage(self.Base):
            __tablename__ = 'chosen_product_image'
            product_id = Column(Integer, ForeignKey('product.id'),
                                primary_key=True)
            image_id = Column(Integer, ForeignKey('image.id'),
                              primary_key=True)
            image = rel('Image', backref=backref(name='chosen_product_images',
                                                 cascade="all, delete-orphan"),
                        enable_typechecks=False)
            name = Column(Unicode, default=lambda: u'default name')

        class Tag(self.Base):
            __tablename__ = 'tag'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode, nullable=False)

        class Product(self.Base):
            __tablename__ = 'product'
            id = Column(Integer, primary_key=True)
            chosen_product_images = rel(ChosenProductImage,
                                        backref=backref(name='product'),
                                        cascade="all, delete-orphan")
            chosen_images = prox('chosen_product_images', 'image',
                                 creator=creator2)
            image_names = prox('chosen_product_images', 'name')
            tags = rel(Tag, secondary=tag_product, lazy='joined',
                       backref=backref(name='products', lazy='dynamic'))
            tag_names = prox('tags', 'name',
                             creator=lambda tag_name: Tag(name=tag_name))

        self.Product = Product
        self.Image = Image
        self.ChosenProductImage = ChosenProductImage
        self.Tag = Tag

        # create all the tables required for the models
        self.Base.metadata.create_all()

        # create the API endpoints
        self.manager.create_api(self.Product, methods=['GET', 'PATCH', 'POST'],
                                url_prefix='/api')
        self.manager.create_api(self.Image, methods=['GET', 'PATCH', 'POST'],
                                url_prefix='/api')

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.Base.metadata.drop_all()

    def _check_relations(self):
        """Makes :http:method:`get` requests for the product with ID 1 and the
        image with ID 1, ensuring that each has a relationship with the other
        via the association proxy table.

        """
        response = self.app.get('/api/product/1')
        data = loads(response.data)
        assert 'chosen_images' in data
        assert {'id': 1} in data['chosen_images']

        response = self.app.get('/api/image/1')
        data = loads(response.data)
        assert 'products' in data
        assert {'id': 1} in data['products']

    def _check_meta_relation(self):
        response = self.app.get('/api/image/1')
        data = loads(response.data)
        assert 'meta_store' in data
        assert 'file type' in data['meta_store']

    def _check_relations_two(self):
        """Makes :http:method:`get` requests for the product with ID 1 and the
        images with ID 1 and 2, ensuring that the product has a relationship
        with each image, and each image has a relationship with the product.

        """
        response = self.app.get('/api/product/1')
        data = loads(response.data)
        assert 'chosen_images' in data

        expected_chosen_project_images = [
            {'image_id': 1, 'product_id': 1, 'name': 'default name'},
            {'image_id': 2, 'product_id': 1, 'name': 'default name'}
        ]

        assert data['chosen_images'], [{'id': 1} == {'id': 2}]
        assert data['chosen_product_images'] == expected_chosen_project_images

        response = self.app.get('/api/image/1')
        data = loads(response.data)
        assert 'products' in data
        assert {'id': 1} in data['products']

        response = self.app.get('/api/image/2')
        data = loads(response.data)
        assert 'products' in data
        assert {'id': 1} in data['products']

    def test_assoc_dict_put(self):
        data = {'products': [{'id': 1}],
                'meta':[{'key':'file type', 'value': 'png'}]
               }
        response = self.app.post('/api/image', data=dumps(data))
        assert response.status_code == 201

        self._check_meta_relation()

    def test_get_data(self):
        """Tests that a :http:method:`get` request exhibits the correct
        associations.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.add(self.ChosenProductImage(image_id=1, product_id=1))
        self.session.commit()

        self._check_relations()

    def test_post(self):
        """Tests that a :http:method:`post` request correctly adds an
        association.

        """
        self.session.add(self.Product())
        self.session.commit()

        data = {'products': [{'id': 1}]}
        response = self.app.post('/api/image', data=dumps(data))
        assert response.status_code == 201

        self._check_relations()

    def test_post_many(self):
        """Tests that a :http:method:`post` request correctly adds multiple
        associations.

        """
        self.session.add(self.Image())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': [{'id': 1}, {'id': 2}]}
        response = self.app.post('/api/product', data=dumps(data))
        assert response.status_code == 201

        self._check_relations_two()

    def test_patch(self):
        """Tests that a :http:method:`patch` request correctly sets the
        appropriate associations.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': [{'id': 1}]}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        self._check_relations()

    def test_patch_multiple(self):
        """Tests that a :http:method:`patch` request correctly adds multiple
        associations.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': [{'id': 1}, {'id': 2}]}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        self._check_relations_two()

    def test_patch_with_add(self):
        """Tests that a :http:method:`patch` request correctly adds an
        association.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': {'add': {'id': 1}}}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        self._check_relations()

    def test_patch_with_remove(self):
        """Tests that a :http:method:`patch` request correctly removes an
        association.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': {'add': {'id': 1}}}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        data = {'chosen_images': {'add': {'id': 2}}}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        data = {'chosen_images': {'remove': [{'id': 2}]}}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        self._check_relations()

    def test_any(self):
        """Tests that a search query correctly searches fields on an associated
        model.

        """
        self.session.add(self.Product())
        self.session.add(self.Image())
        self.session.add(self.Image())
        self.session.commit()

        data = {'chosen_images': [{'id': 1}, {'id': 2}]}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        filters = {'filters': [{'name': 'chosen_images__id', 'op': 'any',
                                'val': 1}]}
        response = self.app.get('/api/product?q=' + dumps(filters))
        assert response.status_code == 200
        data = loads(response.data)
        assert {'id': 1} in data['objects'][0]['chosen_images']

        data = {'chosen_images': {'remove': [{'id': 1}]}}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200

        filters = {'filters': [{'name': 'chosen_images__id', 'op': 'any',
                                'val': 1}]}
        response = self.app.get('/api/product?q=' + dumps(filters))
        assert response.status_code == 200
        data = loads(response.data)
        assert data['num_results'] == 0

        filters = {'filters': [{'name': 'chosen_images', 'op': 'any',
                                'val': {'name': 'id', 'op': 'eq', 'val': 1}}]}
        response = self.app.get('/api/product?q=' + dumps(filters))
        assert response.status_code == 200
        data = loads(response.data)
        assert data['num_results'] == 0

    def test_scalar(self):
        """Tests that association proxies to remote scalar attributes work
        correctly.

        This is also somewhat tested indirectly through the other tests here
        for the chosen product image names but this is a direct test with the
        Tags and a different type of relation

        """
        self.session.add(self.Product())
        self.session.commit()

        data = {'tag_names': ['tag1', 'tag2']}
        response = self.app.patch('/api/product/1', data=dumps(data))
        assert response.status_code == 200
        data = loads(response.data)

        assert sorted(data['tag_names']), sorted(['tag1' == 'tag2'])

    def test_num_results(self):
        self.session.add(self.Product(tag_names=['tag1', 'tag2']))
        self.session.commit()

        response = self.app.get('/api/product')
        assert response.status_code == 200
        data = loads(response.data)
        assert data['num_results'] == 1

########NEW FILE########
