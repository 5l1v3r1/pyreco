__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# GAE Testbed documentation build configuration file, created by
# sphinx-quickstart on Mon Sep 28 21:10:06 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, '/usr/local/google_appengine')
sys.path.insert(0, os.path.abspath(os.path.join('..', '..')))

from google.appengine.ext import db

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'GAE Testbed'
copyright = u'2009, JJ Geewax'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.12'
# The full version, including alpha/beta/rc tags.
release = '0.12'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'GAETestbeddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'GAETestbed.tex', u'GAE Testbed Documentation',
   u'JJ Geewax', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = base
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

class BaseTestCase(object):
    """
    BaseTestCase is the base mixin test case that holds common
    assert methods to be used across all test cases.
    """
    def assertLength(self, iterable, count):
        """
        Assert that an `iterable` is of a given length.
        
        This is useful when you don't care about the type of the iterable, 
        but just care that it is a certain length. If the item provided
        doesn't have the expected length, or the length cannot be determined,
        the test will fail.
        
        This will first try to call ``item.count()`` (assuming it's a ``QuerySet``)
        and then try ``len(item)``.
        
        Let's take a look at an example::
            
            class TestCase(BaseTestCase, unittest.TestCase):
                def test_length(self):
                    # This will call len('asdf')
                    self.assertLength('asdf', 4)
                    
                    # This will use .count()
                    self.assertLength(models.MyModel.all(), 0)
                    
                    # These will use len()
                    self.assertLength([0, 1, 2], 3)
                    self.assertLength((), 0)
                    
                    # This will fail
                    self.assertLength(7, 0)
        """
        length = None
        
        if length is None:
            try: length = iterable.count()
            except: pass
        
        if length is None:
            try: length = len(iterable)
            except: pass
        
        if length is None:
            self.fail("Unable to get length for object %s" % type(iterable))
        
        else:
            self.assertEqual(length, count)

########NEW FILE########
__FILENAME__ = datastore
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

from google.appengine.api import apiproxy_stub_map, datastore_file_stub
from google.appengine.ext import db

from base import BaseTestCase

__all__ = ['DataStoreTestCase']

class DataStoreTestCase(BaseTestCase):
    """
    The ``DataStoreTestCase`` is a base test case that provides helper
    methods for dealing with ``db.Model``'s.
    
    The main thing that this mixin does is ensure that the local Data Store
    is empty at the start of each test. This way you never have to worry about
    cleaning up after previous ran tests. This becomes especially important
    when you're unsure of the order in which the tests will run.
    
    For example::
    
        import unittest
        
        from gaetestbed import DataStoreTestCase
        
        class MyTestCase(DataStoreTestCase, unittest.TestCase):
            def test_empty(self):
                self.assertLength(models.MyModel.all(), 0)
                models.MyModel(field="value").put()
                self.assertLength(models.MyModel.all(), 1)
            
            def test_still_empty(self):
                self.assertLength(models.MyModel.all(), 0)
                models.MyModel(field="value").put()
                self.assertLength(models.MyModel.all(), 1)
    
    If the Data Store wasn't emptied out between tests, one of these two 
    would fail. When you inherit from the ``DataStoreTestCase``, each test
    is run inside its own little sandbox.
    
    Keep in mind that this test case uses the ``setUp()`` method to ensure
    the Data Store is empty between tests. So if you override that in your
    test case, make sure to call super::

        import unittest
        
        from gaetestbed import DataStoreTestCase
        
        class MyTestCase(DataStoreTestCase, unittest.TestCase):
            def setUp(self):
                # Note that you're calling super on MyTestCase, not
                # on DataStoreTestCase!
                super(MyTestCase, self).setUp()
                # Do anything else you want here
            
            def test_sample(self):
                self.assertLength(models.MyModel.all(), 0)
                models.MyModel(field="value").put()
                self.assertLength(models.MyModel.all(), 1)
    """
    def setUp(self):
        """
        This method is called at the start of each test case.
        
        As noted above, if your test case needs to call ``setUp``, make
        sure to call ``super()``! Otherwise the Data Store might not be
        set up correctly.
        """
        super(DataStoreTestCase, self).setUp()
        self.clear_datastore()
    
    def _get_datastore_stub(self):
        return apiproxy_stub_map.apiproxy._APIProxyStubMap__stub_map['datastore_v3']
        
    def clear_datastore(self):
        """
        Clear the Data Store of all its data.
        
        This method can be used inside your tests to clear the Data Store mid-test.
        
        For example::
        
            import unittest
            
            from gaetestbed import DataStoreTestCase
            
            class MyTestCase(DataStoreTestCase, unittest.TestCase):
                def test_clear_datastore(self):
                    # Add something to the Data Store
                    models.MyModel(field="value").put()
                    self.assertLength(models.MyModel.all(), 1)
                    
                    # And then empty the Data Store
                    self.clear_datastore()
                    self.assertLength(models.MyModel.all(), 0)
        """
        self._get_datastore_stub().Clear()
    
    def max_queries(self, max_queries):
        """
        Provides a context manager to ensure only a certain number of queries
        are run for a given block of code.
        
        Perhaps this is best illustrated with an example::
        
            from __future__ import with_statement
            
            import unittest
            
            from gaetestbed import DataStoreTestCase
            
            class MyTestCase(DataStoreTestCase, unittest.TestCase):
                def test_clear_datastore(self):
                    with self.max_queries(2):
                        models.MyModel(field="value").put()
                        self.assertLength(models.MyModel.all(), 1)
                    
                    with self.max_queries(5):
                        # Something that might take up to five queries
                        pass
        
        In this example, if the code block inside the ``with`` statement executes
        greater that 2 (or 5 in the second block) queries, the test will fail.
        
        This can be incredibly useful for making sure that you don't accidentally tweak
        a method call and suddenly it consumes resources far beyond what you'd expected.
        
        If you only care that a certain number of queries is run throughout the entire
        test, you could add ``self.assertTrue(self.query_count < 10)`` at the end of
        your test.
        """
        return self._QueryCounter(self, max_queries)
    
    class _QueryCounter(object):
        def __init__(self, test_case, maximum_queries=None):
            self.test_case = test_case
            self.maximum_queries = maximum_queries
        
        def __enter__(self):
            self.starting_queries = self.test_case.query_count
        
        def __exit__(self, *args, **kwargs):
            num_queries_run = self.test_case.query_count - self.starting_queries
            if num_queries_run > self.maximum_queries:
                self.test_case.fail("Too many queries run: expected %d (max) got %d." % (self.maximum_queries, num_queries_run))
    
    @property
    def query_count(self):
        """
        The number of queries executed so far in the test.
        
        This method will keep track of the number of queries on a per-test
        basis. Since the Data Store is cleared out after each test, the number
        of queries resets to zero after each test.
        
        If you care how many queries a certain block of code executes, take a look
        at how to use ``max_queries()`` along with the ``with`` statement.
        
        Example::
        
            import unittest
            
            from gaetestbed import DataStoreTestCase
            
            class MyTestCase(DataStoreTestCase, unittest.TestCase):
                def test_clear_datastore(self):
                    # No queries have been run yet
                    self.assertEqual(self.query_count, 0)
                    
                    # Run one query to count the number of models
                    self.assertLength(models.MyModel.all(), 1)
                    
                    # Check that one query was run
                    self.assertEqual(self.query_count, 1)
        """
        count = 0
        queries = self._get_datastore_stub().QueryHistory()
        for n in queries.itervalues():
            count += n
        return count

########NEW FILE########
__FILENAME__ = functional
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

from unit import UnitTestCase
from web import WebTestCase

__all__ = ['FunctionalTestCase']

class FunctionalTestCase(UnitTestCase, WebTestCase):
    pass

########NEW FILE########
__FILENAME__ = mail
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

from google.appengine.api import apiproxy_stub_map, mail_stub

from base import BaseTestCase

__all__ = ['MailTestCase']

class MailTestCase(BaseTestCase):
    """
    The ``MailTestCase`` is a base test case that provides helper methods
    for dealing with App Engine's Mail API.
    
    The main feature of this test case is the ability to assert that an e-mail
    message would be sent using the Mail API calls.
    
    The following example sends an e-mail with App Engine's Mail API and then 
    tests that the e-mail was actually sent::
    
        import unittest
        
        from gaetestbed import MailTestCase
        
        from google.appengine.api import mail
        
        class MyTestCase(MailTestCase, unittest.TestCase):
            def test_email_sent(self):
                mail.send_mail(
                    to = 'test@example.org',
                    subject = 'Test E-mail',
                    sender = 'me@example.org',
                    body = 'This is a test e-mail',
                )
                
                # This will fail if an e-mail wasn't sent.
                self.assertEmailSent()
    
    Keep in mind that this isn't actually going to send an e-mail message
    to that recipient. This just checks that the call was made to App Engine's
    API stub without mocking out a call to send_mail.
    
    That is, you can send an e-mail using the ``mail.EmailMessage`` object::
    
        import unittest
        
        from gaetestbed import MailTestCase
        
        from google.appengine.api import mail
        
        class MyTestCase(MailTestCase, unittest.TestCase):
            def test_email_sent(self):
                mail.EmailMessage(
                    to = 'test@example.org',
                    subject = 'Test E-mail',
                    sender = 'me@example.org',
                    body = 'This is a test e-mail',
                ).send()
                
                self.assertEmailSent()
    """
    def setUp(self):
        """
        This method is called at the start of each test case.
        
        If you need to use this method for your own test set up, make sure
        that you call ``super()``. If not, the mail hook will not get configured
        correctly and the mail assertions will fail when they shouldn't.
        
        Here is an example of how to properly override the ``setUp`` method::
        
            import unittest
            
            from gaetestbed import MailTestCase
            
            class MyTestCase(MailTestCase, unittest.TestCase):
                def setUp(self):
                    super(MyTestCase, self).setUp()
                    # Do anything else you need here
        """
        super(MailTestCase, self).setUp()
        self._set_mail_stub()
        self.clear_sent_messages()
    
    def _set_mail_stub(self):
        """
        Updates the mail stub with a hook that intercepts messages as they're being
        logged.
        
        This grabs the mail stub from the App Engine API proxy and overwrites the
        ``_GenerateLog`` method. It simply grabs the message that would've been logged
        as sent, and adds it to the list of sent messages. You can retrieve the sent
        messages that are intercepted with the ``get_sent_messages`` helper method.
        """
        test_case = self
        class MailStub(mail_stub.MailServiceStub):
            def _GenerateLog(self, method, message, log, *args, **kwargs):
                test_case._sent_messages.append(message)
                return super(MailStub, self)._GenerateLog(method, message, log, *args, **kwargs)
        
        if 'mail' in apiproxy_stub_map.apiproxy._APIProxyStubMap__stub_map:
            del apiproxy_stub_map.apiproxy._APIProxyStubMap__stub_map['mail']
        
        apiproxy_stub_map.apiproxy.RegisterStub('mail', MailStub())
    
    def clear_sent_messages(self):
        """
        Clears the list of messages sent so far in the test case.
        
        This method is called at the start of every test in order to ensure that
        each test is fully sandboxed, though you are free to call it elsewhere in
        your tests::
        
            import unittest
        
            from gaetestbed import MailTestCase
            
            from google.appengine.api import mail
            
            class MyTestCase(MailTestCase, unittest.TestCase):
                def test_email_sent(self):
                    mail.EmailMessage(
                        to = 'test@example.org',
                        subject = 'Test E-mail',
                        sender = 'me@example.org',
                        body = 'This is a test e-mail',
                    ).send()
                    
                    # assertLength is defined in the BaseTestCase
                    self.assertLength(self.get_sent_messages(), 1)
                    
                    # Clear the sent messages
                    self.clear_sent_messages()
                    
                    # Check that the list is cleared
                    self.assertLength(self.get_sent_messages(), 0)
        """
        self._sent_messages = []
    
    def get_sent_messages(self, to=None, sender=None, subject=None, body=None, html=None):
        """
        Returns a list of ``mail.EmailMessage`` that would've been sent via App
        Engine's Mail API.
        
        As part of the sandboxing of this test case, any messages are stored only
        on a per-test basis. That is, the following assert at the start of each 
        test should always pass::
        
            self.assertEqual(self.get_sent_messages(), [])
        
        This gives you back a list of messages that would've been sent inside your
        test. Each item is a ``mail.EmailMessage`` meaning you can check the various
        fields as part of your testing::
        
            import unittest
        
            from gaetestbed import MailTestCase
            
            from google.appengine.api import mail
            
            class MyTestCase(MailTestCase, unittest.TestCase):
                def test_email_sent(self):
                    mail.EmailMessage(
                        to = 'test@example.org',
                        subject = 'Test E-mail',
                        sender = 'me@example.org',
                        body = 'This is a test e-mail',
                    ).send()
                    
                    # assertLength is defined in the BaseTestCase
                    self.assertLength(self.get_sent_messages(), 1)
                    
                    # Grab a particular message
                    message = self.get_sent_messages()[0]
                    
                    # Check that the to field is set appropriately
                    self.assertEqual(message.to, 'test@example.org')
        
        You can also use the same arguments available for ``assertEmailSent()`` in order
        to filter the messages returned. That is, if you specify a ``to`` parameter, the
        only messages returned would be those that match that recipient::
        
            import unittest
            
            from gaetestbed import MailTestCase
            
            from google.appengine.api import mail
            
            class MyTestCase(MailTestCase, unittest.TestCase): 
                def test_get_emails(self):
                    mail.EmailMessage(
                        to = 'test@example.org',
                        subject = 'Test E-mail',
                        sender = 'me@example.org',
                        body = 'This is a test e-mail',
                    ).send()
                    
                    # Check that without any parameters, all the messages are returned unfiltered
                    self.assertLength(self.get_sent_messages(), 1)
                    
                    # Since the to address is different, this will return no messages
                    self.assertLength(self.get_sent_messages(to='other@example.org'), 0)
        
        As with the ``assertEmailSent()`` method, all the filters are anded together such that any
        message returned will match *ALL* of the parameters, not just a subset.
        """
        messages = self._sent_messages
        
        if to:
            messages = [m for m in messages if to in m.to_list()]
        
        if sender:
            messages = [m for m in messages if sender == m.sender()]
        
        if subject:
            messages = [m for m in messages if subject == m.subject()]
        
        if body:
            messages = [m for m in messages if body in m.textbody()]
        
        if html:
            messages = [m for m in messages if html in m.htmlbody()]
        
        return messages
    
    def assertEmailSent(self, to=None, sender=None, subject=None, body=None, html=None):
        """
        Asserts that an e-mail with various details would be sent by App Engine.
        
        With all parameters blank, this method will fail only if the sent messages
        list is completely empty. That is, without any parameters, this only asserts
        that some Email message was somehow sent via the Mail API.
        
        If any parameters are provided, they are *anded* together such that all the
        requirements must be met by a particular message in order for the assertion to 
        pass. That is, if you specify both a recipient (``to``) and a sender (``sender``),
        a single message must match those requirements. If you send one message with
        the correct recipient and a different sender, and another with the correct sender
        and incorrect recipient, this assertion will fail.
        
        For example, the following assertion would fail::
        
            import unittest
        
            from gaetestbed import MailTestCase
            
            from google.appengine.api import mail
            
            class MyTestCase(MailTestCase, unittest.TestCase):
                def test_email_sent(self):
                    mail.send_mail(
                        to      = 'correct_recipient@example.org',
                        sender  = 'wrong_sender@example.org',
                        subject = 'Test E-mail',
                        body    = 'This is a test e-mail',
                    )
                    
                    mail.send_mail(
                        to      = 'wrong_recipient@example.org',
                        sender  = 'correct_sender@example.org',
                        subject = 'Test E-mail',
                        body    = 'This is a test e-mail',
                    )
                    
                    # This will FAIL
                    self.assertEmailSent(
                        to     = 'correct_recipient@example.org',
                        sender = 'correct_sender@example.org',
                    )
        
        All of the fields are an exact match *except* the ``body`` and ``html``
        fields where the check is whether or not the body *contains* the body specified::
        
            import unittest
        
            from gaetestbed import MailTestCase
            
            from google.appengine.api import mail
            
            class MyTestCase(MailTestCase, unittest.TestCase):
                def test_email_sent(self):
                    mail.send_mail(
                        to      = 'receiver@example.org',
                        sender  = 'sender@example.org',
                        subject = 'Test E-mail',
                        body    = 'This is a test e-mail',
                    )
                    
                    self.assertEmailSent(to='receiver@example.org')
                    self.assertEmailSent(sender='sender@example.org')
                    self.assertEmailSent(subject='Test E-mail')
                    
                    # This will pass because the body contains the string 'test'
                    self.assertEmailSent(body='test')
        """
        messages = self.get_sent_messages(
            to = to,
            sender = sender,
            subject = subject,
            body = body,
            html = html,
        )
        
        if not messages:
            failure_message = "Expected e-mail message sent."
            
            details = self._get_email_detail_string(to, sender, subject, body, html)
            if details:
                failure_message += ' Arguments expected: %s' % details
            
            self.fail(failure_message)
    
    def assertEmailNotSent(self, to=None, sender=None, subject=None, body=None, html=None):
        """
        Asserts that an e-mail with various details was not sent.
        
        With all parameters blank, this method will fail if any messages were sent. This
        is roughly equivalent to::
        
            self.assertLength(self.get_sent_messages(), 0)
        
        In short, this method behaves as exactly the opposite of ``self.assertEmailSent()``.
        Any place that assertion would pass, this should fail.
        """
        messages = self.get_sent_messages(
            to = to,
            sender = sender,
            subject = subject,
            body = body,
            html = html,
        )
        
        if messages:
            failure_message = "Unexpected e-mail message sent."
            
            details = self._get_email_detail_string(to, sender, subject, body, html)
            if details:
                failure_message += ' Arguments expected: %s' % details
            
            self.fail(failure_message)
    
    def _get_email_detail_string(self, to=None, sender=None, subject=None, body=None, html=None):
        args = []
        if to: args.append('To: %s' % to)
        if sender: args.append('From: %s' % sender)
        if subject: args.append('Subject: %s' % subject)
        if body: args.append('Body (contains): %s' % body)
        if html: args.append('HTML Body (contains): %s' % html)
        
        if args:
            return ', '.join(args)


########NEW FILE########
__FILENAME__ = memcache
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

from google.appengine.api import memcache

from base import BaseTestCase

__all__ = ['MemcacheTestCase']

class MemcacheTestCase(BaseTestCase):
    """
    The ``MemcacheTestCase`` is a base test case that provides helper methods
    for dealing with App Engine's Memcache API.
    
    App Engine actually does most of the work for this by providing statistics
    through the Memcache API, as well as a simple method call to clear out the
    cache.
    
    The main feature of this is the ability to assert that items are in the
    cache, and to check the number of hits to the cache. More fine grained
    assertions are on the way, for now it's pretty general, only able to assert
    that things are in there and not which specific things.
    
    The following example illustrates a simple way of checking that Memcache is
    working as expected::
    
        import unittest
        
        from gaetestbed import MemcacheTestCase
        
        from google.appengine.api import memcache
        
        class MyTestCase(MemcacheTestCase, unittest.TestCase):
            def test_memcache(self):
                # Nothing has been put in the cache, or retrieved from the cache
                self.assertMemcacheItems(0)
                self.assertMemcacheHits(0)
                
                # Add something to the cache
                memcache.set(key='test_item', value='test_content')
                
                # One item added, no hits yet
                self.assertMemcacheItems(1)
                self.assertMemcacheHits(0)
                
                # Grab it from the cache:
                item = memcache.get('test_item')
                
                # One item, one hit
                self.assertMemcacheItems(1)
                self.assertMemcacheHits(1)
    
    Just like the other test cases, each test should be a sandbox, meaning that the
    following assertions should pass if they are run at the start of every test case::
    
        self.assertMemcacheItems(0)
        self.assertMemcacheHits(0)
    """
    def setUp(self):
        """
        This method is called at the start of each test case.
        
        If you need to use this method for your own test set up, make sure
        that you call ``super()``. If not, the cache may not be emptied
        properly and your tests might not be properly sandboxed.
        
        Here is an example of how to properly override the ``setUp`` method::
        
            import unittest
            
            from gaetestbed import MemcacheTestCase
            
            class MyTestCase(MemcacheTestCase, unittest.TestCase):
                def setUp(self):
                    super(MyTestCase, self).setUp()
                    # Do anything else you need here
        """
        super(MemcacheTestCase, self).setUp()
        self.clear_memcache()
    
    def clear_memcache(self):
        """
        Empties the cache of all its content.
        
        This method is called at the start of every test in order to ensure that
        each test is fully sandboxed from the others, though you're free to call
        it elsewhere in your tests as you need::
        
            import unittest
            
            from gaetestbed import MemcacheTestCase
            
            from google.appengine.api import memcache
            
            class MyTestCase(MemcacheTestCase, unittest.TestCase):
                def test_memcache(self):
                    # Check that the cache starts empty
                    self.assertMemcacheItems(0)
                    
                    # Add something to the cache, check that it was added
                    memcache.set(key='test_item', value='test_content')
                    self.assertMemcacheItems(1)
                    
                    # Clear the cache, check that it's now empty
                    self.clear_memcache()
                    self.assertMemcacheItems(0)
        """
        memcache.flush_all()
    
    def assertMemcacheHits(self, hits):
        """
        Asserts that the Memcache API has been hit exactly ``hits`` times.
        
        This method checks the statistics for the cache and asserts that the
        cache has had a certain number of successful hits. If a request is
        not in the cache (cache miss) the number of hits should not change.
        
        For example::
        
            import unittest
            
            from gaetestbed import MemcacheTestCase
            
            from google.appengine.api import memcache
            
            class MyTestCase(MemcacheTestCase, unittest.TestCase):
                def test_memcache(self):
                    # Nothing has retrieved from the cache
                    self.assertMemcacheHits(0)
                    
                    # Add something to the cache
                    memcache.set(key='test_item', value='test_content')
                    
                    # Test still no hits
                    self.assertMemcacheHits(0)
                    
                    # Grab it from the cache:
                    item = memcache.get('test_item')
                    
                    # Assert that there was a cache hit
                    self.assertMemcacheHits(1)
                    
                    # Grab something that doesn't exist
                    memcache.get('bad_key')
                    
                    # Assert that still one hit
                    self.assertMemcacheHits(1)
        """
        self.assertEqual(memcache.get_stats()['hits'], hits)
    
    def assertMemcacheItems(self, items):
        """
        Asserts that the Memcache API contains exactly ``items`` items.
        
        This method checks the statistics for the cache and asserts that the
        there are a certain number of items stored in the cache.
        
        For example::
        
            import unittest
            
            from gaetestbed import MemcacheTestCase
            
            from google.appengine.api import memcache
            
            class MyTestCase(MemcacheTestCase, unittest.TestCase):
                def test_memcache(self):
                    # Nothing has been added to the cache
                    self.assertMemcacheItems(0)
                    
                    # Add something to the cache
                    memcache.set(key='test_item', value='test_content')
                    
                    # Test that the item was added
                    self.assertMemcacheItems(1)
                    
                    # Remove that key
                    memcache.delete('test_item')
                    
                    # Test that the cache has zero items
                    self.assertMemcacheHits(0)
        """
        self.assertEqual(memcache.get_stats()['items'], items)

########NEW FILE########
__FILENAME__ = taskqueue
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

import base64

from google.appengine.api import apiproxy_stub_map

from base import BaseTestCase

__all__ = ['TaskQueueTestCase']

class TaskQueueTestCase(BaseTestCase):
    """
    """
    
    # This is the format usable with strftime/strptime for parsing the
    # ``eta`` field for a particular task
    TASK_ETA_FORMAT = "%Y/%m/%d %H:%M:%S"
    
    def setUp(self):
        """
        """
        super(TaskQueueTestCase, self).setUp()
        self.clear_task_queue()
    
    def assertTasksInQueue(self, n=None, url=None, name=None, queue_names=None):
        """
        """
        tasks = self.get_tasks(url=url, name=name, queue_names=queue_names)
        
        if n is None:
            self.assertNotEqual(len(tasks), 0)
        else:
            self.assertLength(tasks, n)
    
    def clear_task_queue(self):
        """
        """
        stub = self.get_task_queue_stub()
        for name in self.get_task_queue_names():
            stub.FlushQueue(name)
    
    def get_tasks(self, url=None, name=None, queue_names=None):
        """
        """
        tasks = []
        stub = self.get_task_queue_stub()
        
        for queue_name in queue_names or self.get_task_queue_names():
            tasks.extend(stub.GetTasks(queue_name))
        
        if url is not None:
            tasks = [t for t in tasks if t['url'] == url]
        
        if name is not None:
            tasks = [t for t in tasks if t['name'] == name]
        
        for task in tasks:
            params = {}
            decoded_body = base64.b64decode(task['body'])
            
            if decoded_body:
                # urlparse.parse_qs doesn't seem to be in Python 2.5...
                params = dict([item.split('=', 2) for item in decoded_body.split('&')])
            
            task.update({
                'decoded_body': decoded_body,
                'params': params,
            })
            
            # These lines have to remain commented out as (for some reason) the strptime() call
            # throws a SystemError: Parent module 'gaetestbed' not loaded
            # This looks to be an issue with NoseGAE's sandboxing (--without-sandbox doesn't throw the error)
            #
            #if task.get('eta'):
            #    task['eta_datetime'] = datetime.strptime(task['eta'], "%Y/%m/%d %H:%M:%S")
            #    task['eta_date'] = task['eta_datetime'].date()
            #    task['eta_time'] = task['eta_datetime'].time()
            #
            #else:
            #    task.update({
            #        'eta_datetime': None,
            #        'eta_date':     None,
            #        'eta_time':     None,
            #    })
        
        return tasks
    
    def get_task_queues(self):
        """
        """
        return self.get_task_queue_stub().GetQueues()
    
    def get_task_queue_names(self):
        """
        """
        return [q['name'] for q in self.get_task_queues()]
    
    def get_task_queue_stub(self):
        """
        """
        return apiproxy_stub_map.apiproxy._APIProxyStubMap__stub_map['taskqueue']
    

########NEW FILE########
__FILENAME__ = unit
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.

from datastore import DataStoreTestCase
from memcache import MemcacheTestCase
from mail import MailTestCase
from taskqueue import TaskQueueTestCase

__all__ = ['UnitTestCase']

class UnitTestCase(DataStoreTestCase, MemcacheTestCase, MailTestCase, TaskQueueTestCase):
    pass

########NEW FILE########
__FILENAME__ = web
# This file is part of GAE Testbed (http://github.com/jgeewax/gaetestbed).
# 
# Copyright (C) 2009 JJ Geewax http://geewax.org/
# All rights reserved.
# 
# This software is licensed as described in the file COPYING.txt,
# which you should have received as part of this distribution.
import webtest

from base import BaseTestCase

__all__ = ['WebTestCase']

class WebTestCase(BaseTestCase):
    APPLICATION = None
    
    def get_application(self):
        if not hasattr(self, '_app'):
            self._app = None
        
        if not self._app and self.APPLICATION:
            self._app = webtest.TestApp(self.APPLICATION)
        
        error = 'Missing class variable APPLICATION'
        self.assertTrue(self._app is not None, error)
        
        return self._app
    
    app = property(get_application)
    
    def assertRedirects(self, response, to=None):
        """
        Asserts that a response from the test web server (using `get` or `post)
        returns a 301 or 302 status. 
        
        This assertion would fail if you expect the page to redirect and instead
        the server tells the browser that there was a 500 error, or some other
        non-redirecting status code.
        
        For example::
        
            import unittest
            
            from gaetestbed import WebTestCase
            
            from my_handlers.some_handler import application
            
            class MyTestCase(WebTestCase, unittest.TestCase):
                APPLICATION = application
                
                def test_redirects(self):
                    response = self.get('/page_that_redirects/')
                    self.assertRedirects(response)
                
                def test_redirects_but_errors(self):
                    response = self.get('/page_with_exception/')
                    
                    # This would fail if the page throws an exception:
                    self.assertRedirects(response)
        """
        error = 'Response did not redirect (status code was %i).' % response.status_int
        self.assertTrue(response.status_int in (301, 302), error)
        if to is not None:
            error = 'Response redirected, but went to %s instead of %s' % (
                response.location, to
            )
            self.assertEqual(response.location, 'http://localhost%s' % to, error)
    
    def assertOK(self, response):
        """
        Asserts that a response from the test web server (using `get` or
        `post`) returns a 200 OK status code. 
        
        This assertion would fail if you expect a standard page to be returned
        and instead the server tells the browser to redirect elsewhere.
        
        For example::
        
            import unittest
            
            from gaetestbed import WebTestCase
            
            from my_handlers.some_handler import application
            
            class MyTestCase(WebTestCase, unittest.TestCase):
                APPLICATION = application
                
                def test_ok(self):
                    response = self.get('/')
                    self.assertOK(response)
                
                def test_ok_with_redirect(self):
                    response = self.get('/page_that_redirects/')
                    
                    # This would fail if the page redirects:
                    self.assertOK(response)
        """
        error = 'Response did not return a 200 OK (status code was %i)' % response.status_int
        return self.assertEqual(response.status_int, 200, error)
    
    def assertNotFound(self, response):
        error = 'Response was found (status code was %i)' % response.status_int
        return self.assertEqual(response.status_int, 404, error)
    
    def assertForbidden(self, response):
        error = 'Response was allowed (status code was %i)' % response.status_int
        return self.assertEqual(response.status_int, 403, error)
    
    def get(self, *args, **kwargs):
        if 'status' not in kwargs:
            kwargs['status'] = '*'
        return self.app.get(*args, **kwargs)
    
    def post(self, url, data, *args, **kwargs):
        data = self.url_encode(data)
        if 'status' not in kwargs:
            kwargs['status'] = '*'
        return self.app.post(url, data, *args, **kwargs)
    
    def delete(self, *args, **kwargs):
        if 'status' not in kwargs:
            kwargs['status'] = '*'
        return self.app.delete(*args, **kwargs)
    
    def put(self, *args, **kwargs):
        if 'status' not in kwargs:
            kwargs['status'] = '*'
        return self.app.put(*args, **kwargs)
    
    def url_encode(self, data):
        if isinstance(data, dict):
            items = []
            for k, v in data.copy().items():
                if isinstance(v, (list, tuple)):
                    for item in v:
                        items.append('%s=%s' % (k, item))
                else:
                    items.append('%s=%s' % (k, v))
            
            data = '&'.join(items)
        
        return data
    
    def get_cookie(self, key):
        return self.app.cookies.get(key)
    
    def set_cookie(self, key, value):
        self.app.cookies[key] = value

########NEW FILE########
