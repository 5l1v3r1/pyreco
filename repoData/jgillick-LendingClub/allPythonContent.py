__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Lending Club API documentation build configuration file, created by
# sphinx-quickstart on Mon Jul 29 21:51:21 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.abspath('..'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'numpydoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Lending Club API'
copyright = u'2013, Jeremy Gillick'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = open('../lendingclub/VERSION').read()
# The full version, including alpha/beta/rc tags.
release = open('../lendingclub/VERSION').read()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'LendingClubAPIdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'LendingClubAPI.tex', u'Lending Club API Documentation',
   u'Jeremy Gillick', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'lendingclubapi', u'Lending Club API Documentation',
     [u'Jeremy Gillick'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'LendingClubAPI', u'Lending Club API Documentation',
   u'Jeremy Gillick', 'LendingClubAPI', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = filters
#!/usr/bin/env python

"""
Filters are used to search lending club for loans to invest in. There are many filters you can use, here are some
examples with the main `Filter` class.

For example, to search for B grade loans,
you could create a filter like this:

    >>> filters = Filter()
    >>> filters['grades']['B'] = True

Or, another more complex example:

    >>> filters = Filter()
    >>> filters['grades']['B'] = True
    >>> filters['funding_progress'] = 90
    >>> filters['term']['Year5'] = False

This would search for B grade loans that are at least 90% funded and not 5 year loans.

Filters currently do not support all search criteria. To see what is supported, create one and print it:

    >>> filter = Filter()
    >>> print filter
    {'exclude_existing': True,
     'funding_progress': 0,
     'grades': {'A': False,
                'All': True,
                'B': False,
                'C': False,
                'D': False,
                'E': False,
                'F': False,
                'G': False},
     'term': {'Year3': True,
              'Year5': True}}

You can also set the values on instantiation:

    >>> filters = Filter({'grades': {'B': True, 'C': True, 'D': True, 'E': True}})
"""

"""
The MIT License (MIT)

Copyright (c) 2013 Jeremy Gillick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import os
import re
import json
from pybars import Compiler


class Filter(dict):
    """
    The default search filter that let's you refine your search based on a
    dictionary of search facets. Not all search options are supported yet.

    Parameters
    ----------
    filters : dict, optional
        This will override any of the search filters you want on instantiation.

    Examples
    --------
    See the default filters::

        >>> from lendingclub.filters import Filter
        >>> from pprint import pprint
        >>> filter = Filter()
        >>> pprint(filter)
        {'exclude_existing': True,
         'funding_progress': 0,
         'grades': {'A': False,
                    'All': True,
                    'B': False,
                    'C': False,
                    'D': False,
                    'E': False,
                    'F': False,
                    'G': False},
         'term': {'Year3': True,
                  'Year5': True}}

    Set filters on instantiation::

        >>> from lendingclub.filters import Filter
        >>> from pprint import pprint
        >>> filters = Filter({'grades': {'B': True, 'C': True, 'D': True, 'E': True}})
        >>> pprint(filters['grades'])
        {'All': False,
         'A': False,
         'B': True,
         'C': True,
         'D': True,
         'E': True,
         'F': False,
         'G': False}
    """

    tmpl_file = False
    __initialized = False
    __normalizing = False

    def __init__(self, filters=None):
        """
        Set the default search filter values
        """

        # Set filter values
        self['term'] = {
            'Year3': True,
            'Year5': True
        }
        self['exclude_existing'] = True
        self['funding_progress'] = 0
        self['grades'] = {
            'All': True,
            'A': False,
            'B': False,
            'C': False,
            'D': False,
            'E': False,
            'F': False,
            'G': False
        }

        # Merge in filter values
        if filters is not None:
            self.__merge_values(filters, self)

        # Set the template file path
        this_path = os.path.dirname(os.path.realpath(__file__))
        self.tmpl_file = os.path.join(this_path, 'filter.handlebars')

        self.__initialized = True
        self.__normalize()

    def __merge_values(self, from_dict, to_dict):
        """
        Merge dictionary objects recursively, by only updating keys existing in to_dict
        """
        for key, value in from_dict.iteritems():

            # Only if the key already exists
            if key in to_dict:

                # Make sure the values are the same datatype
                assert type(to_dict[key]) is type(from_dict[key]), 'Data type for {0} is incorrect: {1}, should be {2}'.format(key, type(from_dict[key]), type(to_dict[key]))

                # Recursively dive into the next dictionary
                if type(to_dict[key]) is dict:
                    to_dict[key] = self.__merge_values(from_dict[key], to_dict[key])

                # Replace value
                else:
                    to_dict[key] = from_dict[key]

        return to_dict

    def __getitem__(self, key):
        self.__normalize()
        return dict.__getitem__(self, key)

    def __setitem__(self, key, value):

        # If setting grades, merge dictionary instead of replace
        if key == 'grades' and self.__initialized is True:
            assert type(value) is dict, 'The grades filter must be a dictionary object'
            self.__merge_values(value, dict.__getitem__(self, 'grades'))
            value = self['grades']

        # Set value and normalize
        dict.__setitem__(self, key, value)
        self.__normalize()

    def __normalize_grades(self):
        """
        Adjust the grades list.
        If a grade has been set, set All to false
        """

        if 'grades' in self and self['grades']['All'] is True:
            for grade in self['grades']:
                if grade != 'All' and self['grades'][grade] is True:
                    self['grades']['All'] = False
                    break

    def __normalize_progress(self):
        """
        Adjust the funding progress filter to be a factor of 10
        """

        progress = self['funding_progress']
        if progress % 10 != 0:
            progress = round(float(progress) / 10)
            progress = int(progress) * 10

            self['funding_progress'] = progress

    def __normalize(self):
        """
        Adjusts the values of the filters to be correct.
        For example, if you set grade 'B' to True, then 'All'
        should be set to False
        """

        # Don't normalize if we're already normalizing or intializing
        if self.__normalizing is True or self.__initialized is False:
            return

        self.__normalizing = True
        self.__normalize_grades()
        self.__normalize_progress()
        self.__normalizing = False

    def validate(self, results):
        """
        Validate that the results indeed match the filters.
        It's a VERY good idea to run your search results through this, even though
        the filters were passed to LendingClub in your search. Since we're not using formal
        APIs for LendingClub, they could change the way their search works at anytime, which
        might break the filters.

        Parameters
        ----------
        results : list
            A list of loan note records returned from LendingClub

        Returns
        -------
        boolean
            True or raises FilterValidationError

        Raises
        ------
        FilterValidationError
            If a loan does not match the filter criteria
        """
        for loan in results:
            self.validate_one(loan)

        return True

    def validate_one(self, loan):
        """
        Validate a single result record to the filters

        Parameters
        ----------
        loan : dict
            A single loan note record

        Returns
        -------
        boolean
            True or raises FilterValidationError

        Raises
        ------
        FilterValidationError
            If the loan does not match the filter criteria
        """
        assert type(loan) is dict, 'loan parameter must be a dictionary object'

        # Map the loan value keys to the filter keys
        req = {
            'loanGUID': 'loan_id',
            'loanGrade': 'grade',
            'loanLength': 'term',
            'loanUnfundedAmount': 'progress',
            'loanAmountRequested': 'progress',
            'alreadyInvestedIn': 'exclude_existing',
            'purpose': 'loan_purpose',
        }

        # Throw an error if the loan does not contain one of the criteria keys that this filter has
        for key, criteria in req.iteritems():
            if criteria in self and key not in loan:
                raise FilterValidationError('Loan does not have a "{0}" value.'.format(key), loan, criteria)

        # Loan ID
        if 'loan_id' in self:
            loan_ids = str(self['loan_id']).split(',')
            if str(loan['loanGUID']) not in loan_ids:
                raise FilterValidationError('Did not meet filter criteria for loan ID. {0} does not match {1}'.format(loan['loanGUID'], self['loan_id']), loan=loan, criteria='loan ID')

        # Grade
        grade = loan['loanGrade'][0]  # Extract the letter portion of the loan
        if 'grades' in self and self['grades']['All'] is not True:
            if grade not in self['grades']:
                raise FilterValidationError('Loan grade "{0}" is unknown'.format(grade), loan, 'grade')
            elif self['grades'][grade] is False:
                raise FilterValidationError(loan=loan, criteria='grade')

        # Term
        if 'term' in self:
            if loan['loanLength'] == 36 and self['term']['Year3'] is False:
                raise FilterValidationError(loan=loan, criteria='loan term')
            elif loan['loanLength'] == 60 and self['term']['Year5'] is False:
                raise FilterValidationError(loan=loan, criteria='loan term')

        # Progress
        if 'funding_progress' in self:
            loan_progress = (1 - (loan['loanUnfundedAmount'] / loan['loanAmountRequested'])) * 100
            if self['funding_progress'] > loan_progress:
                raise FilterValidationError(loan=loan, criteria='funding progress')

        # Exclude existing
        if 'exclude_existing' in self:
            if self['exclude_existing'] is True and loan['alreadyInvestedIn'] is True:
                raise FilterValidationError(loan=loan, criteria='exclude loans you are invested in')

        # Loan purpose (either an array or single value)
        if 'loan_purpose' in self and loan['purpose'] is not False:
            purpose = self['loan_purpose']
            if type(purpose) is not dict:
                purpose = {purpose: True}

            if 'All' not in purpose or purpose['All'] is False:
                if loan['purpose'] not in purpose:
                    raise FilterValidationError(loan=loan, criteria='loan purpose')

        return True

    def search_string(self):
        """"
        Returns the JSON string that LendingClub expects for it's search
        """
        self.__normalize()

        # Get the template
        tmpl_source = unicode(open(self.tmpl_file).read())

        # Process template
        compiler = Compiler()
        template = compiler.compile(tmpl_source)
        out = template(self)
        if not out:
            return False
        out = ''.join(out)

        #
        # Cleanup output and remove all extra space
        #

        # remove extra spaces
        out = re.sub('\n', '', out)
        out = re.sub('\s{3,}', ' ', out)

        # Remove hanging commas i.e: [1, 2,]
        out = re.sub(',\s*([}\\]])', '\\1', out)

        # Space between brackets i.e: ],  [
        out = re.sub('([{\\[}\\]])(,?)\s*([{\\[}\\]])', '\\1\\2\\3', out)

        # Cleanup spaces around [, {, }, ], : and , characters
        out = re.sub('\s*([{\\[\\]}:,])\s*', '\\1', out)

        return out


class SavedFilter(Filter):
    """
    Load a saved search filter from the site. Since this is
    loading a filter from the server, the individual values cannot be modified.
    Most often it is easiest to load the saved filters from LendingClub, via `get_saved_filters` and `get_saved_filter`.
    See examples.

    Parameters
    ----------
    lc : :py:class:`lendingclub.LendingClub`
        An instance of the LendingClub class that will be used to communicate with the site
    filter_id : int
        The ID of the filter to load

    Examples
    --------

    The SavedFilter needs to use an instance of LendingClub to access the site, so the class has a couple wrappers
    you can use to load SavedFilters. Here are a couple examples of loading saved filters from the LendingClub instance.

    Load all saved filters:
        >>> from lendingclub import LendingClub
        >>> from lendingclub.filters import SavedFilter
        >>> lc = LendingClub(email='test@test.com', password='secret123')
        >>> lc.authenticate()
        True
        >>> filters = SavedFilter.all_filters(lc)    # Get a list of all saved filters on LendinClub.com
        >>> print filters
        [<SavedFilter: 12345, '90 Percent'>, <SavedFilter: 23456, 'Only A loans'>]

    Load a single saved filter:
        >>> from lendingclub import LendingClub
        >>> from lendingclub.filters import SavedFilter
        >>> lc = LendingClub(email='test@test.com', password='secret123')
        >>> lc.authenticate()
        True
        >>> filter = lc.get_saved_filter(23456)    # Get a single saved search filter from the site by ID
        >>> filter.name
        u'Only A'
    """
    id = None
    lc = None
    name = None
    json = None
    json_text = None
    response = None

    @staticmethod
    def all_filters(lc):
        """
        Get a list of all your saved filters

        Parameters
        ----------
        lc : :py:class:`lendingclub.LendingClub`
            An instance of the authenticated LendingClub class

        Returns
        -------
        list
            A list of lendingclub.filters.SavedFilter objects
        """

        filters = []
        response = lc.session.get('/browse/getSavedFiltersAj.action')
        json_response = response.json()

        # Load all filters
        if lc.session.json_success(json_response):
            for saved in json_response['filters']:
                filters.append(SavedFilter(lc, saved['id']))

        return filters

    def __init__(self, lc, filter_id):
        self.id = filter_id
        self.lc = lc
        self.load()

    def reload(self):
        """
        Reload the saved filter
        """
        self.load()

    def load(self):
        """
        Load the filter from the server
        """

        # Attempt to load the saved filter
        payload = {
            'id': self.id
        }
        response = self.lc.session.get('/browse/getSavedFilterAj.action', query=payload)
        self.response = response
        json_response = response.json()

        if self.lc.session.json_success(json_response) and json_response['filterName'] != 'No filters':
            self.name = json_response['filterName']

            #
            # Parse out the filter JSON string manually from the response JSON.
            # If the filter JSON is modified at all, or any value is out of order,
            # LendingClub will reject the filter and perform a wildcard search instead,
            # without any error. So we need to retain the filter JSON value exactly how it is given to us.
            #
            text = response.text

            # Cut off everything  before "filter": [...]
            text = re.sub('\n', '', text)
            text = re.sub('^.*?,\s*["\']filter["\']:\s*\[(.*)', '[\\1', text)

            # Now loop through the string until we find the end of the filter block
            # This is a simple parser that keeps track of block elements, quotes and
            # escape characters
            blockTracker = []
            blockChars = {
                '[': ']',
                '{': '}'
            }
            inQuote = False
            lastChar = None
            json_text = ""
            for char in text:
                json_text += char

                # Escape char
                if char == '\\':
                    if lastChar == '\\':
                        lastChar = ''
                    else:
                        lastChar = char
                    continue

                # Quotes
                if char == "'" or char == '"':
                    if inQuote is False:  # Starting a quote block
                        inQuote = char
                    elif inQuote == char:  # Ending a quote block
                        inQuote = False
                    lastChar = char
                    continue

                # Start of a block
                if char in blockChars.keys():
                    blockTracker.insert(0, blockChars[char])

                # End of a block, remove from block path
                elif len(blockTracker) > 0 and char == blockTracker[0]:
                    blockTracker.pop(0)

                # No more blocks in the tracker which means we're at the end of the filter block
                if len(blockTracker) == 0 and lastChar is not None:
                    break

                lastChar = char

            # Verify valid JSON
            try:
                if json_text.strip() == '':
                    raise SavedFilterError('A saved filter could not be found for ID {0}'.format(self.id), response)

                json_test = json.loads(json_text)

                # Make sure it looks right
                assert type(json_test) is list, 'Expecting a list, instead received a {0}'.format(type(json_test))
                assert 'm_id' in json_test[0], 'Expecting a \'m_id\' property in each filter'
                assert 'm_value' in json_test[0], 'Expecting a \'m_value\' property in each filter'

                self.json = json_test
            except Exception as e:
                raise SavedFilterError('Could not parse filter from the JSON response: {0}'.format(str(e)))

            self.json_text = json_text
            self.__analyze()

        else:
            raise SavedFilterError('A saved filter could not be found for ID {0}'.format(self.id), response)

    def __str__(self):
        return '<SavedFilter: {0}, \'{1}\'>'.format(self.id, self.name)

    def __repr__(self):
        return self.__str__()

    def __setitem__(self, key, value):
        raise SavedFilterError('A saved filter cannot be modified')

    def __analyze(self):
        """
        Analyze the filter JSON and attempt to parse out the individual filters.
        """
        filter_values = {}

        # ID to filter name mapping
        name_map = {
            10: 'grades',
            11: 'loan_purpose',
            13: 'approved',
            15: 'funding_progress',
            38: 'exclude_existing',
            39: 'term',
            43: 'keyword'
        }

        if self.json is not None:
            filters = self.json

            for f in filters:
                if 'm_id' in f:
                    name = f['m_id']

                    # Get the name to represent this filter
                    if f['m_id'] in name_map:
                        name = name_map[f['m_id']]

                    # Get values
                    if 'm_value' in f:
                        raw_values = f['m_value']
                        value = {}

                        # Loop through multiple values
                        if type(raw_values) is list:

                            # A single non string value, is THE value
                            if len(raw_values) == 1 and type(raw_values[0]['value']) not in [str, unicode]:
                                value = raw_values[0]['value']

                            # Create a dict of values: name = True
                            for val in raw_values:
                                if type(val['value']) in [str, unicode]:
                                    value[val['value']] = True

                        # A single value
                        else:
                            value = raw_values

                        # Normalize grades array
                        if name == 'grades':
                            if 'All' not in value:
                                value['All'] = False

                    # Add filter value
                    filter_values[name] = value
                    dict.__setitem__(self, name, value)

        return filter_values

    def __normalize():
        pass

    def search_string(self):
        """
        Get the search JSON string to send to the server
        """
        return self.json_text


class FilterByLoanID(Filter):
    """
    Creates a filter to search by loan ID. You can either search by
    1 loan ID or for multiple loans by ID.

    Parameters
    ----------
    loan_id : int or list
        The loan ID or a list of loan IDs

    Examples
    --------

    Search for 1 loan by ID:

        >>> from lendingclub import LendingClub
        >>> from lendingclub.filters import FilterByLoanID
        >>> lc = LendingClub(email='test@test.com', password='secret123')
        >>> lc.authenticate()
        True
        >>> filter = FilterByLoanID(1234)  # Search for the loan 1234
        >>> results = lc.search(filter)
        >>> len(results['loans'])
        1

    Search for multiple loans by ID:

        >>> from lendingclub import LendingClub
        >>> from lendingclub.filters import FilterByLoanID
        >>> lc = LendingClub(email='test@test.com', password='secret123')
        >>> lc.authenticate()
        True
        >>> filter = FilterByLoanID(54321, 76432)  # Search for two loans: 54321 and 76432
        >>> results = lc.search(filter)
        >>> len(results['loans'])
        2
    """

    def __init__(self, loan_id):

        # Convert a list to comma delimited string
        if type(loan_id) is list:
            loan_id = map(str, loan_id)
            loan_id = ','.join(loan_id)

        self['loan_id'] = loan_id
        this_path = os.path.dirname(os.path.realpath(__file__))
        self.tmpl_file = os.path.join(this_path, 'filter.handlebars')

    def __normalize():
        pass


class FilterValidationError(Exception):
    """
    A loan note does not match the filters set.

    After a search is performed, each loan returned from the server will be
    validate against the filter's criteria, for good measure. If it doesn't match, this exception is thrown.

    Parameters
    ----------
    value : string
        The error message
    loan : dict
        The loan that did not match
    criteria : string
        The filter item that the loan failed on.
    """
    value = None
    loan = None
    criteria = None

    def __init__(self, value=None, loan=None, criteria=None):
        self.loan = loan
        self.criteria = criteria

        if value is None:
            if criteria is None:
                self.value = 'Did not meet filter criteria'
            else:
                self.value = 'Did not meet filter criteria for {0}'.format(criteria)
        else:
            self.value = value

    def __str__(self):
        return repr(self.value)


class SavedFilterError(Exception):
    """
    An error occurred while loading or processing a :class:SavedFilter

    Parameters
    ----------
    value : string
        The error message
    response : `requests.Response <http://docs.python-requests.org/en/latest/api/#requests.Response>`_
        The Response object from the HTTP request to find the saved filter.
    """
    value = None
    request = None

    def __init__(self, value, request=None):
        self.value = value
        self.request = request

    def __str__(self):
        return repr(self.value)

########NEW FILE########
__FILENAME__ = session
#!/usr/bin/env python

"""
Manage the LendingClub user session and all raw HTTP calls to the LendingClub site.
This will almost always be accessed through the API calls in
:class:`lendingclub.LendingClub` instead of directly.
"""

"""
The MIT License (MIT)

Copyright (c) 2013 Jeremy Gillick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import re
import requests
import getpass
import time as time
from bs4 import BeautifulSoup
from requests.exceptions import *


class Session:

    email = None
    __pass = None
    __logger = None

    last_response = None

    session_timeout = 10
    """ Minutes until the session expires.
    The session will attempt to reauth before the next HTTP call after timeout."""

    base_url = 'https://www.lendingclub.com/'
    """ The root URL that all paths are appended to """

    last_request_time = 0
    """ The timestamp of the last HTTP request """

    __session = None

    def __init__(self, email=None, password=None, logger=None):
        self.email = email
        self.__pass = password
        self.__logger = logger

    def __log(self, message):
        """
        Log a debugging message
        """
        if self.__logger:
            self.__logger.debug(message)

    def __continue_session(self):
        """
        Check if the time since the last HTTP request is under the
        session timeout limit. If it's been too long since the last request
        attempt to authenticate again.
        """
        now = time.time()
        diff = abs(now - self.last_request_time)
        timeout_sec = self.session_timeout * 60  # convert minutes to seconds

        if diff >= timeout_sec:
            self.__log('Session timed out, attempting to authenticate')
            self.authenticate()

    def set_logger(self, logger):
        """
        Have the Session class send debug logging to your python logging logger.
        Set to None stop the logging.

        Parameters
        ----------
        logger : `Logger <http://docs.python.org/2/library/logging.html>`_
            The logger to send debug output to.
        """
        self.__logger = logger

    def build_url(self, path):
        """
        Build a LendingClub URL from a URL path (without the domain).

        Parameters
        ----------
        path : string
            The path part of the URL after the domain. i.e. https://www.lendingclub.com/<path>
        """
        url = '{0}{1}'.format(self.base_url, path)
        url = re.sub('([^:])//', '\\1/', url)  # Remove double slashes
        return url

    def authenticate(self, email=None, password=None):
        """
        Authenticate with LendingClub and preserve the user session for future requests.
        This will raise an exception if the login appears to have failed, otherwise it returns True.

        Since Lending Club doesn't seem to have a login API, the code has to try to decide if the login
        worked or not by looking at the URL redirect and parsing the returned HTML for errors.

        Parameters
        ----------
        email : string
            The email of a user on Lending Club
        password : string
            The user's password, for authentication.

        Returns
        -------
        boolean
            True on success or throws an exception on failure.

        Raises
        ------
        session.AuthenticationError
            If authentication failed
        session.NetworkError
            If a network error occurred
        """

        # Get email and password
        if email is None:
            email = self.email
        else:
            self.email = email

        if password is None:
            password = self.__pass
        else:
            self.__pass = password

        # Get them from the user
        if email is None:
            email = raw_input('Email:')
            self.email = email
        if password is None:
            password = getpass.getpass()
            self.__pass = password

        self.__log('Attempting to authenticate: {0}'.format(self.email))

        # Start session
        self.__session = requests.Session()
        self.__session.headers = {
            'Referer': 'https://www.lendingclub.com/',
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31'
        }

        # Set last request time to now
        self.last_request_time = time.time()

        # Send login request to LC
        payload = {
            'login_email': email,
            'login_password': password
        }
        response = self.post('/account/login.action', data=payload, redirects=False)

        # Get URL redirect URL and save the last part of the path as the endpoint
        response_url = response.url
        if response.status_code == 302:
            response_url = response.headers['location']
        endpoint = response_url.split('/')[-1]

        # Debugging
        self.__log('Status code: {0}'.format(response.status_code))
        self.__log('Redirected to: {0}'.format(response_url))
        self.__log('Cookies: {0}'.format(str(response.cookies.keys())))

        # Show query and data that the server received
        if 'x-echo-query' in response.headers:
            self.__log('Query: {0}'.format(response.headers['x-echo-query']))
        if 'x-echo-data' in response.headers:
            self.__log('Data: {0}'.format(response.headers['x-echo-data']))

        # Parse any errors from the HTML
        soup = BeautifulSoup(response.text, "html5lib")
        errors = soup.find(id='master_error-list')
        if errors:
            errors = errors.text.strip()

            # Remove extra spaces and newlines from error message
            errors = re.sub('\t+', '', errors)
            errors = re.sub('\s*\n+\s*', ' * ', errors)

            if errors == '':
                errors = None

        # Raise error
        if errors is not None:
            raise AuthenticationError(errors)

        # Redirected back to the login page...must be an error
        if endpoint == 'login.action':
            raise AuthenticationError('Unknown! Redirected back to the login page without an error message')

        return True

    def is_site_available(self):
        """
        Returns true if we can access LendingClub.com
        This is also a simple test to see if there's a network connection

        Returns
        -------
        boolean
            True or False
        """
        try:
            response = requests.head(self.base_url)
            status = response.status_code
            return 200 <= status < 400  # Returns true if the status code is greater than 200 and less than 400
        except Exception:
            return False

    def request(self, method, path, query=None, data=None, redirects=True):
        """
        Sends HTTP request to LendingClub.

        Parameters
        ----------
        method : {GET, POST, HEAD, DELETE}
            The HTTP method to use: GET, POST, HEAD or DELETE
        path : string
            The path that will be appended to the domain defined in :attr:`base_url`.
        query : dict
            A dictionary of query string parameters
        data : dict
            A dictionary of POST data values
        redirects : boolean
            True to follow redirects, False to return the original response from the server.

        Returns
        -------
        requests.Response
            A `requests.Response <http://docs.python-requests.org/en/latest/api/#requests.Response>`_ object
        """

        # Check session time
        self.__continue_session()

        try:
            url = self.build_url(path)
            method = method.upper()

            self.__log('{0} request to: {1}'.format(method, url))

            if method == 'POST':
                request = self.__session.post(url, params=query, data=data, allow_redirects=redirects)
            elif method == 'GET':
                request = self.__session.get(url, params=query, data=data, allow_redirects=redirects)
            elif method == 'HEAD':
                request = self.__session.head(url, params=query, data=data, allow_redirects=redirects)
            elif method == 'DELETE':
                request = self.__session.delete(url, params=query, data=data, allow_redirects=redirects)
            else:
                raise SessionError('{0} is not a supported HTTP method'.format(method))

            self.last_response = request

            self.__log('Status code: {0}'.format(request.status_code))

            # Update session time
            self.last_request_time = time.time()

        except (RequestException, ConnectionError, TooManyRedirects, HTTPError) as e:
            raise NetworkError('{0} failed to: {1}'.format(method, url), e)
        except Timeout:
            raise NetworkError('{0} request timed out: {1}'.format(method, url), e)

        return request

    def post(self, path, query=None, data=None, redirects=True):
        """
        POST request wrapper for :func:`request()`
        """
        return self.request('POST', path, query, data, redirects)

    def get(self, path, query=None, redirects=True):
        """
        GET request wrapper for :func:`request()`
        """
        return self.request('GET', path, query, None, redirects)

    def head(self, path, query=None, data=None, redirects=True):
        """
        HEAD request wrapper for :func:`request()`
        """
        return self.request('HEAD', path, query, None, redirects)

    def clear_session_order(self):
        """
        Clears any existing order in the LendingClub.com user session.
        """
        self.get('/portfolio/confirmStartNewPortfolio.action')

    def json_success(self, json):
        """
        Check the JSON response object for the success flag

        Parameters
        ----------
        json : dict
            A dictionary representing a JSON object from lendingclub.com
        """
        if type(json) is dict and 'result' in json and json['result'] == 'success':
            return True
        return False


class SessionError(Exception):
    """
    Base exception class for :mod:`lendingclub.session`

    Parameters
    ----------
    value : string
        The error message
    origin : Exception
        The original exception, if this exception was caused by another.
    """
    value = 'Unknown error'
    origin = None

    def __init__(self, value, origin=None):
        self.value = value
        self.origin = origin

    def __str__(self):
        if self.origin is None:
            return repr(self.value)
        else:
            return '{0} (from {1})'.format(repr(self.value), repr(self.origin))


class AuthenticationError(SessionError):
    """
    Authentication failed
    """
    pass


class NetworkError(SessionError):
    """
    An error occurred while making an HTTP request
    """
    pass

########NEW FILE########
__FILENAME__ = filter_test
#!/usr/bin/env python

import re
import sys
import json as pyjson
import unittest
from logger import TestLogger
from server import ServerThread

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from lendingclub import LendingClub
from lendingclub.filters import *


def matches(regex, subject):
    """
    Returns True if the regex string matches the subject
    """
    return re.match(regex, subject) is not None


class TestFilters(unittest.TestCase):
    filters = None

    def setUp(self):
        self.filters = Filter()

    def tearDown(self):
        pass

    def get_values(self, m_id):
        """
        Get the m_values array from the filter JSON for this m_id
        """
        search_json = self.filters.search_string()
        json = pyjson.loads(search_json)
        for filterObj in json:
            if filterObj['m_id'] == m_id:
                return filterObj['m_value']

    def test_term_all(self):
        """ test_term_all
        Test the default state, having 36 and 60 month terms
        """
        values = self.get_values(39)

        self.assertEqual(len(values), 2)
        self.assertEqual(values[0]['value'], 'Year3')
        self.assertEqual(values[1]['value'], 'Year5')

    def test_term_36(self):
        """ test_term_36
        36 month term only
        """
        self.filters['term']['Year3'] = True
        self.filters['term']['Year5'] = False
        values = self.get_values(39)

        self.assertEqual(len(values), 1)
        self.assertEqual(values[0]['value'], 'Year3')

    def test_term_60(self):
        """ test_term_60
        60 month term only
        """
        self.filters['term']['Year3'] = False
        self.filters['term']['Year5'] = True
        values = self.get_values(39)

        self.assertEqual(len(values), 1)
        self.assertEqual(values[0]['value'], 'Year5')

    def test_exclude_existing(self):
        self.filters['exclude_existing'] = True
        values = self.get_values(38)

        self.assertEqual(len(values), 1)

    def test_include_existing(self):
        self.filters['exclude_existing'] = False
        values = self.get_values(38)

        self.assertEqual(values, None)

    def test_default_funding_progress(self):
        values = self.get_values(15)
        self.assertEqual(values, None)

    def test_funding_progress_rounding(self):
        """ test_funding_progress_rounding
        Funding progress should be rounded to the nearest 10
        """
        self.filters['funding_progress'] = 56
        values = self.get_values(15)
        self.assertEqual(values[0]['value'], 60)

    def test_funding_progress_set(self):
        """ test_funding_progress_round_up
        Funding progress set to 90
        """
        self.filters['funding_progress'] = 90
        values = self.get_values(15)
        self.assertEqual(values[0]['value'], 90)

    def test_funding_progress_round_up(self):
        """ test_funding_progress_round_up
        Test the progress rounding. It should round to the nearest 10
        """
        self.filters['funding_progress'] = 67
        values = self.get_values(15)
        self.assertEqual(values[0]['value'], 70)

    def test_funding_progress_round_down(self):
        """ test_funding_progress_round_down
        Test the progress rounding. It should round to the nearest 10
        """
        self.filters['funding_progress'] = 63
        values = self.get_values(15)
        self.assertEqual(values[0]['value'], 60)

    def test_grades(self):
        """ test_grade
        Test setting grades to 'B'
        """
        self.filters['grades']['All'] = False
        self.filters['grades']['B'] = True
        values = self.get_values(10)

        self.assertEqual(len(values), 1)
        self.assertEqual(values[0]['value'], 'B')

    def test_grades_all(self):
        """ test_grades_all
        All should be set to False if another grade is set to True
        """
        self.filters['grades']['C'] = True

        values = self.get_values(10)

        self.assertEqual(len(values), 1)
        self.assertEqual(values[0]['value'], 'C')


class TestFilterValidation(unittest.TestCase):
    filters = None
    logger = None
    lc = None
    loan_list = None

    def setUp(self):
        self.filters = Filter()
        self.filters['exclude_existing'] = False
        self.logger = TestLogger()

        self.lc = LendingClub(logger=self.logger)
        self.lc.session.base_url = 'http://127.0.0.1:8000/'
        self.lc.session.set_logger(None)
        self.lc.authenticate('test@test.com', 'supersecret')

        response = self.lc.session.get('/filter_validation', query={'id': 1})
        json_response = response.json()
        self.loan_list = json_response['loanFractions']

    def tearDown(self):
        pass

    def test_validation_defaults(self):
        """ test_validation_defaults
        Default filters should match
        """
        self.assertTrue(self.filters.validate(self.loan_list))

    def test_validation_grade_valid(self):
        self.filters['C'] = True
        self.assertTrue(self.filters.validate(self.loan_list))

    def test_validation_grade_fail(self):
        self.filters['grades']['B'] = True
        self.assertRaises(
            FilterValidationError,
            lambda: self.filters.validate(self.loan_list)
        )

    def test_validation_term_36(self):
        """ test_validation_term_36
        Should fail on the 60 month loan, loan_id: 12345
        """
        self.filters['term']['Year3'] = True
        self.filters['term']['Year5'] = False
        try:
            self.filters.validate(self.loan_list)

        # Check the loan it failed on
        except FilterValidationError as e:
            self.assertEqual(e.loan['loan_id'], 12345)

        # Invalid Exception
        except Exception:
            self.assertTrue(False)

    def test_validation_term_60(self):
        """ test_validation_term_60
        Should fail on the 36 month loan, loan_id: 23456
        """
        self.filters['term']['Year3'] = False
        self.filters['term']['Year5'] = True
        try:
            self.filters.validate(self.loan_list)

        # Check the loan it failed on
        except FilterValidationError as e:
            self.assertEqual(e.loan['loan_id'], 23456)

        # Invalid Exception
        except Exception:
            self.assertTrue(False)

    def test_validation_progress_70(self):
        """ test_validation_progress_70
        Loan 12345 is 91 percent funded
        Loan 23456 is 77 percent funded
        """
        self.filters['funding_progress'] = 70
        self.assertTrue(self.filters.validate(self.loan_list))

    def test_validation_progress_90(self):
        """ test_validation_term_90
        Should fail
        Loan 12345 is 91 percent funded
        Loan 23456 is 77 percent funded
        """
        self.filters['funding_progress'] = 90
        try:
            self.filters.validate(self.loan_list)

        # Check the loan it failed on
        except FilterValidationError as e:
            self.assertEqual(e.loan['loan_id'], 23456)

        # Invalid Exception
        except Exception:
            self.assertTrue(False)

    def test_validation_progress_95(self):
        """ test_validation_progress_95
        Should fail
        Loan 12345 is 91 percent funded
        Loan 23456 is 77 percent funded
        """
        self.filters['funding_progress'] = 95
        try:
            self.filters.validate(self.loan_list)

        # Check the loan it failed on
        except FilterValidationError as e:
            self.assertEqual(e.loan['loan_id'], 12345)

        # Invalid Exception
        except Exception:
            self.assertTrue(False)

    def test_validation_exclude_existing(self):
        """ test_validation_exclude_existing
        Should fail on loan 23456, which the user is already invested in.
        """
        self.filters['exclude_existing'] = True
        try:
            self.filters.validate(self.loan_list)

        # Check the loan it failed on
        except FilterValidationError as e:
            self.assertEqual(e.loan['loan_id'], 23456)

        # Invalid Exception
        except Exception:
            self.assertTrue(False)


class TestSavedFilters(unittest.TestCase):
    filters = None
    logger = None
    lc = None
    loan_list = None

    def setUp(self):
        self.logger = TestLogger()

        self.lc = LendingClub(logger=self.logger)
        self.lc.session.base_url = 'http://127.0.0.1:8000/'
        self.lc.session.set_logger(None)
        self.lc.authenticate('test@test.com', 'supersecret')

    def tearDown(self):
        pass

    def test_get_all_filters(self):
        filters = SavedFilter.all_filters(self.lc)

        self.assertEqual(len(filters), 2)
        self.assertEqual(filters[0].name, 'Filter 1')

    def test_get_saved_filters(self):
        saved = SavedFilter(self.lc, 1)

        self.assertEqual(saved.name, 'Filter 1')
        self.assertEqual(saved.id, 1)
        self.assertNotEqual(saved.search_string(), None)

    def test_validation_1(self):
        """ test_validation_1
        Filter 1 against filter_validation 1
        """
        saved = SavedFilter(self.lc, 1)

        # Get loan list
        response = self.lc.session.get('/filter_validation', query={'id': 1})
        json_response = response.json()
        self.loan_list = json_response['loanFractions']

        # Validate, should fail on 'exclude_invested'
        try:
            saved.validate(self.loan_list)
            assert False, 'Test should fail on exclude_existing'
        except FilterValidationError as e:
            print e.criteria
            self.assertTrue(matches('exclude loans', e.criteria))

    def test_validation_2(self):
        """ test_validation_2
        Filter 2 against filter_validation 2
        """
        saved = SavedFilter(self.lc, 2)

        # Get loan list
        response = self.lc.session.get('/filter_validation', query={'id': 2})
        json_response = response.json()
        self.loan_list = json_response['loanFractions']

        # Validate, should fail on 'exclude_invested'
        try:
            saved.validate(self.loan_list)
            assert False, 'Test should fail on loan_purpose'
        except FilterValidationError as e:
            print e.criteria
            self.assertTrue(matches('loan purpose', e.criteria))

    def test_validation_2_1(self):
        """ test_validation_2_1
        Filter 2 against filter_validation 1
        """
        saved = SavedFilter(self.lc, 2)

        # Get loan list
        response = self.lc.session.get('/filter_validation', query={'id': 1})
        json_response = response.json()
        self.loan_list = json_response['loanFractions']

        # Validate, should not fail
        saved.validate(self.loan_list)

    def test_validation_2_3(self):
        """ test_validation_3
        Filter 2 against filter_validation 3
        """
        saved = SavedFilter(self.lc, 2)

        # Get loan list
        response = self.lc.session.get('/filter_validation', query={'id': 3})
        json_response = response.json()
        self.loan_list = json_response['loanFractions']

        # Validate, should fail on 'exclude_invested'
        try:
            saved.validate(self.loan_list)
            assert False, 'Test should fail on grade'
        except FilterValidationError as e:
            print e.criteria
            self.assertTrue(matches('grade', e.criteria))


if __name__ == '__main__':
    # Start the web-server in a background thread
    http = ServerThread()
    http.start()

    # Run tests
    unittest.main()

    # Stop threads
    http.stop()

########NEW FILE########
__FILENAME__ = lendingclub_test
#!/usr/bin/env python

import sys
import unittest
from logger import TestLogger
from server import ServerThread

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from lendingclub import LendingClub


class TestLendingClub(unittest.TestCase):
    lc = None
    logger = None

    def setUp(self):
        self.logger = TestLogger()

        self.lc = LendingClub(logger=self.logger)
        self.lc.session.base_url = 'http://127.0.0.1:8000/'
        self.lc.session.set_logger(None)

        self.lc.authenticate('test@test.com', 'supersecret')

        # Make sure session is enabled and clear
        self.lc.session.post('/session/enabled')
        self.lc.session.request('delete', '/session')

    def tearDown(self):
        pass

    def test_cash_balance(self):
        cash = self.lc.get_cash_balance()
        self.assertEqual(cash, 216.02)

    def test_portfolios(self):
        portfolios = self.lc.get_portfolio_list()
        self.assertEquals(len(portfolios), 2)
        self.assertEquals(portfolios[0]['portfolioName'], 'Existing Portfolio')

    def test_build_portfolio(self):
        portfolio = self.lc.build_portfolio(200, 25, 15, 16)

        self.assertNotEqual(portfolio, False)
        self.assertEqual(portfolio['percentage'], 15.28)

        self.assertTrue('loan_fractions' in portfolio)
        self.assertEqual(len(portfolio['loan_fractions']), 15)

    def test_build_portfolio_session_fail(self):
        """ test_build_portfolio_session_fail"
        If the session isn't saved, fractions shouldn't be found,
        which should make the entire method return False
        """

        # Disable session
        self.lc.session.post('/session/disabled')

        portfolio = self.lc.build_portfolio(200, 25, 15, 16)
        self.assertFalse(portfolio)

    def test_build_portfolio_no_match(self):
        """ test_build_portfolio_no_match"
        Enter a min/max percent that cannot match dummy returned JSON
        """
        portfolio = self.lc.build_portfolio(200, 25, 17.6, 18.5)
        self.assertFalse(portfolio)

    def test_search(self):
        results = self.lc.search()
        self.assertTrue(results is not False)
        self.assertTrue('loans' in results)
        self.assertTrue(len(results['loans']) > 0)


if __name__ == '__main__':
    # Start the web-server in a background thread
    http = ServerThread()
    http.start()

    # Run tests
    unittest.main()

    # Stop threads
    http.stop()
########NEW FILE########
__FILENAME__ = live_session_test
#!/usr/bin/env python

import sys
import unittest
import getpass
from logger import TestLogger

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from lendingclub import session


class LiveTestSession(unittest.TestCase):
    http = None
    session = None
    logger = None

    def setUp(self):
        self.logger = TestLogger()
        self.session = session.Session(logger=self.logger)

    def tearDown(self):
        pass

    def test_login(self):
        """ test_valid_login
        Test login with credentials from the user
        """

        print '\n\nEnter a valid LendingClub account information...'
        email = raw_input('Email:')
        password = getpass.getpass()

        self.assertTrue(self.session.authenticate(email, password))
        print 'Authentication successful'

    def test_invalid_login(self):
        """ test_invalid_password
        Test login with the wrong password
        """
        self.assertRaises(
            session.AuthenticationError,
            lambda: self.session.authenticate('test@test.com', 'wrongsecret')
        )


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = live_tests
#!/usr/bin/env python

import sys
import unittest
import getpass
from random import choice
from logger import TestLogger

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from lendingclub import LendingClub, Order
from lendingclub.filters import Filter

logger = TestLogger()
lc = LendingClub(logger=logger)


class LiveTests(unittest.TestCase):

    def setUp(self):
        # Clear any existing orders
        lc.session.clear_session_order()

        # Override Order.__place_order so that no orders can be made
        Order._Order__place_order = self.place_order_override

        # Make sure that the override worked
        o = Order(lc)
        self.assertEqual(o._Order__place_order('token'), 12345)

    def place_order_override(self, token):
        """
        This overrides the Order.__place_order method so that no
        actual order is ever made
        """
        assert token, 'The token is empty or does not exist'
        return 12345

    def tearDown(self):
        pass

    def test_is_site_available(self):
        self.assertTrue(lc.is_site_available())

    def test_get_balance(self):
        cash = lc.get_cash_balance()

        self.assertTrue(cash is not False)
        self.assertTrue(cash >= 25)

    def test_get_investable_balance(self):
        cash = lc.get_investable_balance()

        self.assertTrue(cash is not False)
        self.assertTrue(cash >= 25)
        self.assertTrue(cash % 25 == 0)

    def test_get_portfolio_list(self):
        porfolio_list = lc.get_portfolio_list()

        assert len(porfolio_list), 'You do not have any named portfolios in your account'

        first = porfolio_list[0]
        self.assertEqual(type(first), dict)
        self.assertTrue('portfolioName' in first)

    def test_search(self):
        loans = lc.search()
        self.assertTrue(len(loans) > 0)

    def test_search_with_filters(self):
        f = Filter({'grades': {'B': True}})
        results = lc.search(f)

        self.assertTrue(len(results['loans']) > 0)

        # Ensure all the notes are B grade
        for loan in results['loans']:
            self.assertEqual(loan['loanGrade'][0], 'B')

    def test_build_portfolio(self):
        f = Filter({'grades': {'B': True}})
        portfolio = lc.build_portfolio(25, 25, 9.0, 14.0, filters=f)

        self.assertEqual(len(portfolio['loan_fractions']), 1)
        self.assertEqual(portfolio['b'], 100)
        self.assertEqual(portfolio['number_of_b_loans'], 1)
        self.assertTrue(14.0 > portfolio['percentage'] > 9.0)

    def test_build_portfolio_invest(self):
        f = Filter({'grades': {'B': True}})
        portfolio = lc.build_portfolio(25, 25, 9.0, 14.0, filters=f, automatically_invest=True)

        self.assertEqual(len(portfolio['loan_fractions']), 1)
        self.assertEqual(portfolio['b'], 100)
        self.assertTrue('order_id' in portfolio)
        self.assertEqual(portfolio['order_id'], 12345)

        # Try to reinvest this same portfolio
        o = lc.start_order()
        self.assertRaises(
            AssertionError,
            lambda: o.add_batch(portfolio)
        )

    def test_my_notes(self):
        notes = lc.my_notes()
        self.assertTrue(len(notes) > 0)

    def test_get_note(self):
        notes = lc.my_notes()
        self.assertTrue(len(notes['loans']) > 0)

        note = choice(notes['loans'])  # Get random note

        found = lc.get_note(note['noteId'])
        self.assertEqual(note['noteId'], found['noteId'])

    def search_my_notes(self):
        # Find a note to use as something to search from
        notes = lc.my_notes()
        note = choice(notes['loans'])  # Get random note

        # Find by loan_id
        found = lc.search_my_notes(loan_id=note['loanId'])
        self.assertTrue(len(found) > 0)
        self.assertEqual(found[0]['loanId'], note['loanId'])

        # Find by order_id
        found = lc.search_my_notes(loan_id=note['orderId'])
        self.assertTrue(len(found) > 0)
        self.assertEqual(found[0]['orderId'], note['orderId'])

        # Find by Grade
        grade = note['rate'][0]
        found = lc.search_my_notes(grade=grade)
        self.assertTrue(len(found) > 0)
        for note in found:
            self.assertEqual(grade, note['rate'][0])


print """
!!!WARNING !!!
This is a live test of the module communicating with LendingClub.com with your account!!!
Your account must have at least $25 to continue. Tests will attempt to get full API test
coverage coming just short of investing money from your account.

However, this is not guaranteed if something in the tests are broken. Please continue at your own risk.
"""
res = raw_input('Continue with the tests? [yes/no]')
if res.lower() != 'yes':
    exit()

print '\n\nEnter a valid LendingClub account information...'
email = raw_input('Email:')
password = getpass.getpass()


assert lc.is_site_available(), 'No network connection or cannot access lendingclub.com'
assert lc.authenticate(email, password), 'Could not authenticate'
assert lc.get_investable_balance(), 'You do not have at least $25 in your account.'

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = logger
#!/usr/bin/env python

"""
A dummy python logger
"""

"""
The MIT License (MIT)

Copyright (c) 2013 Jeremy Gillick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import sys
import traceback
#import logging

class TestLogger():
    """
    A dummy python logger that outputs everything to stdout and keeps a history of output.
    """

    infos = []
    errors = []
    warnings = []
    debugs = []

    def __init__(self):
        self.infos = []
        self.errors = []
        self.warnings = []
        self.debugs = []

    def info(self, msg):
        #print '\nINVESTOR INFO: {0}\n'.format(msg)
        self.infos.append(msg)

    def error(self, msg):
        self.errors.append(msg)
        print '\nLOG ERROR: {0}'.format(msg)

        # Traceback
        exc_type, exc_value, exc_traceback = sys.exc_info()
        traceback.print_tb(exc_traceback, limit=2, file=sys.stdout)

    def warning(self, msg):
        print '\nLOG WARNING: {0}\n'.format(msg)
        self.warnings.append(msg)

    def debug(self, msg):
        print 'LOG DEBUG: {0}'.format(msg)
        self.debugs.append(msg)

########NEW FILE########
__FILENAME__ = order_test
#!/usr/bin/env python

import json
import sys
import unittest
from logger import TestLogger
from server import ServerThread

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from lendingclub import LendingClub
from lendingclub.filters import FilterValidationError


class TestOrder(unittest.TestCase):
    lc = None
    order = None
    logger = None

    def setUp(self):
        self.logger = TestLogger()

        self.lc = LendingClub(logger=self.logger)
        self.lc.session.base_url = 'http://127.0.0.1:8000/'
        self.lc.session.set_logger(None)

        self.lc.authenticate('test@test.com', 'supersecret')

        # Make sure session is enabled and clear
        self.lc.session.post('/session/enabled')
        self.lc.session.request('delete', '/session')

        # Use version 2 of browseNotesAj.json
        self.lc.session.post('/session', data={'browseNotesAj': '2'})

        # Start order
        self.order = self.lc.start_order()

    def tearDown(self):
        pass

    def test_add(self):
        self.order.add(123, 50)
        self.assertEqual(len(self.order.loans), 1)
        self.assertEqual(self.order.loans[123], 50)

    def test_update(self):
        self.order.add(123, 50)
        self.assertEqual(self.order.loans[123], 50)

        self.order.add(123, 100)
        self.assertEqual(len(self.order.loans), 1)
        self.assertEqual(self.order.loans[123], 100)

    def test_remove(self):
        self.order.add(123, 50)
        self.order.add(234, 75)

        self.assertEqual(len(self.order.loans), 2)

        self.order.remove(234)

        self.assertEqual(len(self.order.loans), 1)
        self.assertEqual(self.order.loans[123], 50)
        self.assertFalse(234 in self.order.loans)

    def test_multiple_of_25(self):
        self.assertRaises(
            AssertionError,
            lambda: self.order.add(123, 0)
        )
        self.assertRaises(
            AssertionError,
            lambda: self.order.add(123, 26)
        )


class TestBatchOrder(unittest.TestCase):
    lc = None
    order = None
    logger = None

    def setUp(self):
        self.logger = TestLogger()

        self.lc = LendingClub(logger=self.logger)
        self.lc.session.base_url = 'http://127.0.0.1:8000/'
        self.lc.session.set_logger(None)

        self.lc.authenticate('test@test.com', 'supersecret')

        # Make sure session is enabled and clear
        self.lc.session.post('/session/enabled')
        self.lc.session.request('delete', '/session')

        # Use version 3 of browseNotesAj.json
        self.lc.session.post('/session', data={'browseNotesAj': '3'})

        # Start order
        self.order = self.lc.start_order()

    def tearDown(self):
        pass

    def test_add_batch_dict(self):
        """ test_add_batch_dict
        Add a batch of dict loan objects
        """
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ])

        self.assertEqual(len(self.order.loans), 2)
        self.assertEqual(self.order.loans[123], 50)
        self.assertEqual(self.order.loans[234], 75)

    def test_add_batch_dict_amount(self):
        """ test_add_batch_dict_amount
        Add a batch dict with a batch_amount parameter value to override the individual values
        """
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ], 100)

        self.assertEqual(len(self.order.loans), 2)
        self.assertEqual(self.order.loans[123], 100)
        self.assertEqual(self.order.loans[234], 100)

    def test_add_batch_list(self):
        """ test_add_batch_list
        Add a batch of IDs from a list, not a dict
        """
        self.order.add_batch([123, 234], 75)

        self.assertEqual(len(self.order.loans), 2)
        self.assertEqual(self.order.loans[123], 75)
        self.assertEqual(self.order.loans[234], 75)

    def test_add_batch_list_no_amount(self):
        """ test_add_batch_list_no_amount
        Send a list of IDs to add_batch, without an amount
        """
        self.assertRaises(
            AssertionError,
            lambda: self.order.add_batch([123, 234])
        )

    def test_add_batch_object(self):
        """ test_add_batch_object
        Pulling loans from the 'loan_fractions' value is no longer supported
        """
        loanDict = {
            'loan_fractions': [
                {
                    'loan_id': 123,
                    'invest_amount': 50
                }, {
                    'loan_id': 234,
                    'invest_amount': 75
                }
            ]
        }
        self.assertRaises(
            AssertionError,
            lambda: self.order.add_batch(loanDict)
        )

    def test_execute(self):
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ])

        order_id = self.order.execute()
        self.assertNotEqual(order_id, 0)

    def test_execute_wrong_id(self):
        """ test_execute_wrong_id
        Server returns an ID that doesn't match an ID added to batch (345)
        """
        self.order.add_batch([234, 345], 75)
        self.assertRaises(
            FilterValidationError,
            lambda: self.order.execute()
        )

    def test_execute_existing_portfolio(self):
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ])

        portfolio = 'New Portfolio'
        order_id = self.order.execute(portfolio)
        self.assertNotEqual(order_id, 0)

        # Check portfolio name
        request = self.lc.session.get('/session')
        http_session = request.json()
        self.assertEqual(http_session['new_portfolio'], portfolio)

    def test_execute_new_portfolio(self):
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ])

        portfolio = 'Existing Portfolio'
        order_id = self.order.execute(portfolio)
        self.assertNotEqual(order_id, 0)

        # Check portfolio name
        request = self.lc.session.get('/session')
        http_session = request.json()
        self.assertEqual(http_session['existing_portfolio'], portfolio)

    def test_double_execute(self):
        """ test_double_execute
        An order can only be executed once
        """
        self.order.add_batch([
            {
                'loan_id': 123,
                'invest_amount': 50
            }, {
                'loan_id': 234,
                'invest_amount': 75
            }
        ])

        order_id = self.order.execute()
        self.assertNotEqual(order_id, 0)

        self.assertRaises(
            AssertionError,
            lambda: self.order.execute()
        )


if __name__ == '__main__':
    # Start the web-server in a background thread
    http = ServerThread()
    http.start()

    # Run tests
    unittest.main()

    # Stop threads
    http.stop()
########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python

"""
A dummy web server used to test the LendingClub API requests
"""

"""
The MIT License (MIT)

Copyright (c) 2013 Jeremy Gillick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import os
import json
import urlparse
import cgi
import SocketServer
from threading import Thread
from BaseHTTPServer import BaseHTTPRequestHandler

logging = None
http_session = {}
session_disabled = False


class TestServerHandler(BaseHTTPRequestHandler):
    httpd = None
    query = None
    data = None

    headers_sent = False

    auth = {
        'email': 'test@test.com',
        'password': 'supersecret'
    }
    """
    Dummy authenticated email and password for this LendingClub server.
    Any other combination will fail on auth.
    """

    def log(self, msg):
        global logging

        msg = 'SERVER: {0}'.format(msg)
        if logging is not None:
            logging.debug(msg)
        else:
            print '{0}\n'.format(msg)

    def start(self):
        """
        Start the http server
        """
        self.log('Server started...')
        self.httpd.serve_forever()

    def stop(self):
        """
        Shutdown http server
        """
        self.httpd.shutdown()

    def send_headers(self, status_code=200, headers=None, content_type="text/plain"):
        """
        Send all the HTTP headers and prepare the response for content
        """
        self.send_response(status_code)
        self.send_header('Content-Type', content_type)

        if type(headers) is dict:
            for key, value in headers.iteritems():
                self.send_header(key, value)

        # Debug by echoing the query and data base
        if self.query:
            self.send_header('x-echo-query', repr(self.query))
        if self.data:
            self.send_header('x-echo-data', repr(self.data))

        self.end_headers()
        self.headers_sent = True

    def read_asset_file(self, file_name):
        """
        Read a file from the assets directory
        """
        this_dir = os.path.dirname(os.path.realpath(__file__))
        asset_file = os.path.join(this_dir, 'assets', file_name)

        if not os.path.exists(asset_file):
            raise Exception('The asset file \'{0}\' does not exist in {1}'.format(file_name, this_dir))

        return open(asset_file).read()

    def write(self, output):
        """
        Write to the response stream and send default headers if they haven't been sent yet
        """
        if self.headers_sent is False:
            self.send_headers()
        self.wfile.write(output)

    def add_session(self, key, value):
        """
        Add a value to the HTTP session
        """
        global http_session
        if not session_disabled:
            http_session[key] = value

        print 'Add to session: {0}={1}'.format(key, value)

    def output_file(self, file_name):
        """
        Read a file from the assets directory and write it to response stream
        """
        self.write(self.read_asset_file(file_name))

    def output_error_json(self, message):
        """
        Output a JSON error message to the response stream
        """
        error = {
            'result': 'error',
            'error': [message]
        }
        self.write(json.dumps(error))

    def process_post_data(self):
        content_len = int(self.headers.getheader('content-length'))
        postvars = cgi.parse_qs(self.rfile.read(content_len))

        # Flatten values
        for key, values in postvars.iteritems():
            if len(values) == 1:
                postvars[key] = values[0]

        self.data = postvars

    def process_url(self):
        """
        Separate the path from the query
        """
        url = urlparse.urlparse(self.path)
        self.path = url.path
        self.query = urlparse.parse_qs(url.query)

        # Flatten query string values
        for key, values in self.query.iteritems():
            if len(values) == 1:
                self.query[key] = values[0]

    def do_GET(self):
        """
        Process at GET request
        """
        global http_session
        self.process_url()

        path = self.path
        query = self.query

        #self.log('GET {0} {1}'.format(path, query))

        # Summary page
        if '/account/summary.action' == path:
            self.write('Summary Page')

        # Cash balance JSON
        elif '/browse/cashBalanceAj.action' == path:
            self.output_file('cashBalanceAj.json')

        # Portfolio list
        elif '/data/portfolioManagement' == path:
            if 'method' in query:
                if query['method'] == 'getLCPortfolios':
                    self.output_file('portfolioManagement_getLCPortfolios.json')
                else:
                    self.write('Unknown method {0}'.format(query['method']))
            else:
                self.write('No method provided')

        # Place order and strut token
        elif '/portfolio/placeOrder.action' == path:
            self.output_file('placeOrder.html')

        # Select portfolio option and save to session
        elif '/portfolio/recommendPortfolio.action' == path:
            self.add_session('lending_match_point', query['lending_match_point'])
            self.send_headers(302, {'location': '/portfolio/autoInvest.action'})

        # Clear portfolio building session
        elif '/portfolio/confirmStartNewPortfolio.action' == path:
            if 'lending_match_point' in http_session:
                del http_session['lending_match_point']
            self.send_headers(302, {'location': '/portfolio/viewOrder.action'})

        # Get list of loan fractions (must have lending_match_point set in the session)
        elif '/data/portfolio' == path and 'getPortfolio' == query['method']:
            if 'lending_match_point' in http_session:
                self.output_file('portfolio_getPortfolio.json')
            else:
                print 'lending_match_point was not set'
                self.write('{"error": "The lending match point was not set"}')

        # Saved filters
        elif '/browse/getSavedFiltersAj.action' == path:
            self.output_file('getSavedFiltersAj.json')

        # One saved filter
        elif '/browse/getSavedFilterAj.action' == path and 'id' in query and query['id'] in ['1', '2']:
            self.output_file('getSavedFilterAj_{0}.json'.format(query['id']))

        # Stage an order
        elif '/data/portfolio' == path and 'addToPortfolioNew' == query['method']:
            self.output_file('portfolio_addToPortfolioNew.json')

        # Stage an order 2
        elif '/data/portfolio' == path and 'addToPortfolio' == query['method']:
            self.output_file('portfolio_addToPortfolio.json')

        # Loan list for validation
        elif '/filter_validation' == path and 'id' in query and query['id'] in ['1', '2', '3']:
            self.output_file('filter_validate_{0}.json'.format(query['id']))

        # Get a dump of the session
        elif '/session' == path:
            self.write(json.dumps(http_session))

        # Nothing here yet
        elif '/portfolio/autoInvest.action' == path:
            self.write('/portfolio/autoInvest.action')
        elif '/portfolio/viewOrder.action' == path:
            self.write('/portfolio/viewOrder.action')

        else:
            self.write('{"error": "Unknown path"}')

    def do_POST(self):
        """
        Process at POST request
        """
        global http_session, session_disabled
        #self.log('POST {0}'.format(self.path))
        self.process_url()
        self.process_post_data()

        path = self.path
        data = self.data
        query = self.query

        #self.log('Post Data {0}'.format(self.data))

        # Login - if the email and password match, set the cookie
        if '/account/login.action' == path:
            if data['login_email'] == self.auth['email'] and data['login_password'] == self.auth['password']:
                self.send_headers(302, {
                    'Set-Cookie': 'LC_FIRSTNAME=John',
                    'Content-Type': 'text/plain',
                    'location': '/account/summary.action'
                })
                return
            else:
                self.output_file('login_fail.html')

        # Search
        elif '/browse/browseNotesAj.action' == path and 'method' in data and data['method'] == 'search':
            ver = '1'
            if 'browseNotesAj' in http_session:
                ver = http_session['browseNotesAj']
            self.output_file('browseNotesAj_{0}.json'.format(ver))

        # Investment option search
        elif '/portfolio/lendingMatchOptionsV2.action' == path:

            # Default filters
            if data['filter'] == 'default':
                self.output_file('lendingMatchOptionsV2.json')

            # Custom filters
            else:
                self.output_file('lendingMatchOptionsV2_filter_1.json')

        # Order confirmation
        elif '/portfolio/orderConfirmed.action' == path:
            if 'struts.token' in data and data['struts.token'].strip() != '':
                self.output_file('orderConfirmed.html')
            else:
                print "No struts token passed"
                self.write('{"error": "No struts token passed"}')

        # Assign to portfolio
        elif '/data/portfolioManagement' == path:

            if 'method' in query:
                # Existing portfolio
                if 'addToLCPortfolio' == query['method']:
                    http_session['existing_portfolio'] = query['lcportfolio_name']
                    self.output_file('portfolioManagement_addToLCPortfolio.json')

                # New portfolio
                elif 'createLCPortfolio' == query['method']:
                    http_session['new_portfolio'] = query['lcportfolio_name']
                    self.output_file('portfolioManagement_createLCPortfolio.json')

                else:
                    self.write('Unknown method: {0}'.format(query.method))
            else:
                self.write('{"error": "No method passed"}')

        # Select a loan note
        elif '/browse/updateLSRAj.action' == path:
            self.output_file('updateLSRAj.json')

        # Disable the session
        elif '/session/disabled' == path:
            session_disabled = True
            http_session = {}
            self.write('Session disabled')

        # Enable the session
        elif '/session/enabled' == path:
            session_disabled = False
            self.write('Session enabled')

        # Add the post data to the session
        elif '/session' == path:
            if session_disabled is True:
                self.write('{"error": "Session disabled"}')
            else:
                for key, value in data.iteritems():
                    self.add_session(key, value)
                self.send_headers(302, {'location': '/session'})

        else:
            self.write('{"error": "Unknown path"}')

    def do_HEAD(self):
        """
        Process at HEAD request
        """
        return self.do_GET()

    def do_DELETE(self):
        """
        Process at DELETE request
        """
        global http_session

        # Delete the session
        if '/session' == self.path:
            http_session = {}
            self.write(json.dumps(http_session))

        else:
            self.send_headers(500)
            self.write('Unknown delete action: {0}'.format(self.path))


class ReusableServer(SocketServer.TCPServer):
    allow_reuse_address = True


class TestWebServer:
    """
    Simple class to start/stop the server
    """
    http = None

    def __init__(self):
        #self.http = HTTPServer(('127.0.0.1', 7357), TestServerHandler)
        pass

    def start(self):
        print 'Starting server at 127.0.0.1:8000'
        self.http = ReusableServer(('127.0.0.1', 8000), TestServerHandler)
        self.http.serve_forever()

    def stop(self):
        print 'Stopping server...'
        self.http.shutdown()
        self.http = None


class ServerThread:
    """
    Start the server in it's own thread
    """

    httpd = None
    thread = None

    def __init__(self):
        self.httpd = TestWebServer()
        self.thread = Thread(target=self.httpd.start)
        self.thread.daemon = True

    def start(self):
        self.thread.start()
        print 'Server thread started'

    def stop(self):
        self.httpd.stop()


#
# When called from the command line
#
if __name__ == '__main__':
    server = TestWebServer()

    try:
        server.start()
    except KeyboardInterrupt:
        print '\nShutting down the test server'
        server.stop()

########NEW FILE########
__FILENAME__ = session_test
#!/usr/bin/env python

import sys
import os
import unittest
import subprocess
from logger import TestLogger
from server import ServerThread

sys.path.insert(0, '.')
sys.path.insert(0, '../')
sys.path.insert(0, '../../')

from LendingClub import session


class TestSession(unittest.TestCase):
    session = None
    logger = None

    def setUp(self):
        self.logger = TestLogger()
        self.session = session.Session(logger=self.logger)
        self.session.base_url = 'http://127.0.0.1:8000/'

    def tearDown(self):
        pass

    def test_valid_login(self):
        """ test_valid_login
        Test login with valid credentials
        """
        self.assertTrue(self.session.authenticate('test@test.com', 'supersecret'))

    def test_invalid_password(self):
        """ test_invalid_password
        Test login with the wrong password
        """
        self.assertRaises(
            session.AuthenticationError,
            lambda: self.session.authenticate('test@test.com', 'wrongsecret')
        )

    def test_invalid_email(self):
        """ test_invalid_email
        Test login with wrong email
        """
        self.assertRaises(
            session.AuthenticationError,
            lambda: self.session.authenticate('wrong@test.com', 'supersecret')
        )


if __name__ == '__main__':
    # Start the web-server in a background thread
    http = ServerThread()
    http.start()

    # Run tests
    unittest.main()

    # Stop threads
    http.stop()

########NEW FILE########
