__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# pywws documentation build configuration file, created by
# sphinx-quickstart on Fri Sep 30 08:05:58 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

sys.path.insert(0, os.path.abspath('..'))

# cludge to allow documentation to be compiled without installing dependencies
class Dummy(object):
    def __getattr__(self, name):
        if name in ('__file__',):
            return None
        return Dummy

for mod_name in ('hid', 'oauth2', 'twitter', 'usb', 'usb.core', 'usb.util',
                 'daemon', 'daemon.runner'):
    sys.modules[mod_name] = Dummy()

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.autosummary',
              'sphinx.ext.viewcode']

autosummary_generate = True
autoclass_content = 'both'
autodoc_member_order = 'bysource'
autodoc_default_flags = ['members', 'undoc-members']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

rst_epilog = """
----

Comments or questions? Please subscribe to the pywws mailing list
http://groups.google.com/group/pywws and let us know.
"""

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pywws'
copyright = u'2008-14, Jim Easterbrook'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
#version = 
# The full version, including alpha/beta/rc tags.
#release =
from pywws import __version__ as release
version = release[:release.rfind('.')]

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None
if 'LANG' in os.environ:
    language = os.environ['LANG'].split('_')[0]

locale_dirs = ['../pywws/lang']

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None
html_logo = 'pywws_logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None
html_favicon = 'pywws_logo.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pywwsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pywws.tex', u'pywws Documentation',
   u'Jim Easterbrook', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pywws', u'pywws Documentation',
     [u'Jim Easterbrook'], 1)
]

########NEW FILE########
__FILENAME__ = calib
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Calibrate raw weather station data
==================================

This module allows adjustment of raw data from the weather station as
part of the 'processing' step (see :doc:`pywws.Process`). For example,
if you have fitted a funnel to double your rain gauge's collection
area, you can write a calibration routine to double the rain value.

The default calibration generates the relative atmospheric pressure.
Any user calibration you write must also do this.

Writing your calibration module
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Firstly, decide where you want to keep your module. Like your text and
graph templates, it's best to keep it separate from the pywws code, so
it isn't affected by pywws upgrades. I suggest creating a ``modules``
directory in the same place as your ``templates`` directory.

You could start by copying one of the example calibration modules, or
you can create a plain text file in your ``modules`` directory, e.g.
``calib.py`` and copy the following text into it::

    class Calib(object):
        def __init__(self, params, stored_data):
            self.pressure_offset = eval(params.get('config', 'pressure offset'))

        def calib(self, raw):
            result = dict(raw)
            # calculate relative pressure
            result['rel_pressure'] = result['abs_pressure'] + self.pressure_offset
            return result

The :class:`Calib` class has two methods. :py:meth:`Calib.__init__` is
the constructor and is a good place to set any constants you need. It
is passed a reference to the raw data storage which can be useful for
advanced tasks such as spike removal. :py:meth:`Calib.calib` generates
a single set of 'calibrated' data from a single set of 'raw' data.
There are a few rules to follow when writing this method:

    - Make sure you include the line ``result = dict(raw)``, which
      copies all the raw data to your result value, at the start.

    - Don't modify any of the raw data.

    - Make sure you set ``result['rel_pressure']``.

    - Don't forget to ``return`` the result at the end.

When you've finished writing your calibration module you can get pywws
to use it by putting its location in your ``weather.ini`` file. It
goes in the ``[paths]`` section, as shown in the example below::

    [paths]
    work = /tmp/weather
    templates = /home/jim/weather/templates/
    graph_templates = /home/jim/weather/graph_templates/
    user_calib = /home/jim/weather/modules/usercalib

Note that the ``user_calib`` value need not include the ``.py`` at the
end of the file name.

"""

__docformat__ = "restructuredtext en"

import logging
import os
import sys

class DefaultCalib(object):
    """Default calibration class.

    This class sets the relative pressure, using a pressure offset
    originally read from the weather station. This is the bare minimum
    'calibration' required.

    """
    def __init__(self, params, stored_data):
        self.pressure_offset = eval(params.get('config', 'pressure offset'))

    def calib(self, raw):
        result = dict(raw)
        # calculate relative pressure
        result['rel_pressure'] = result['abs_pressure'] + self.pressure_offset
        return result

usercalib = None

class Calib(object):
    """Calibration class that implements default or user calibration.

    Other pywws modules use this method to create a calibration
    object. The constructor creates either a default calibration
    object or a user calibration object, depending on the
    ``user_calib`` value in the ``[paths]`` section of the ``params``
    parameter. It then adopts the calibration object's
    :py:meth:`calib` method as its own.

    """
    calibrator = None
    def __init__(self, params, stored_data):
        global usercalib
        self.logger = logging.getLogger('pywws.Calib')
        if not Calib.calibrator:
            user_module = params.get('paths', 'user_calib', None)
            if user_module:
                self.logger.info('Using user calibration')
                path, module = os.path.split(user_module)
                sys.path.insert(0, path)
                module = os.path.splitext(module)[0]
                usercalib = __import__(
                    module, globals(), locals(), ['Calib'])
                Calib.calibrator = usercalib.Calib(params, stored_data)
            else:
                self.logger.info('Using default calibration')
                Calib.calibrator = DefaultCalib(params, stored_data)
        self.calib = Calib.calibrator.calib

########NEW FILE########
__FILENAME__ = constants
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Bits of data used in several places.

This module collects together some 'constants' that are used in other
pywws modules.

"""

__docformat__ = "restructuredtext en"

from datetime import timedelta

SECOND = timedelta(seconds=1)

class Twitter(object):
    consumer_key = '62moSmU9ERTs0LK0g2xHAg'
    consumer_secret = 'ygdXpjr0rDagU3dqULPqXF8GFgUOD6zYDapoHAH9ck'

########NEW FILE########
__FILENAME__ = conversions
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""conversions.py - a set of functions to convert pywws native units
(Centigrade, mm, m/s, hPa) to other popular units

"""

from __future__ import absolute_import

import math

# rename imports to prevent them being imported when
# doing 'from pywws.conversions import *'
from . import Localisation as _Localisation

def illuminance_wm2(lux):
    "Approximate conversion of illuminance in lux to solar radiation in W/m2"
    if lux is None:
        return None
    return lux * 0.005

def pressure_inhg(hPa):
    "Convert pressure from hectopascals/millibar to inches of mercury"
    if hPa is None:
        return None
    return hPa / 33.86389

def pressure_trend_text(trend):
    """Convert pressure trend to a string, as used by the UK met
    office.

    """
    _ = _Localisation.translation.gettext
    if trend > 6.0:
        return _('rising very rapidly')
    elif trend > 3.5:
        return _('rising quickly')
    elif trend > 1.5:
        return _('rising')
    elif trend >= 0.1:
        return _('rising slowly')
    elif trend < -6.0:
        return _('falling very rapidly')
    elif trend < -3.5:
        return _('falling quickly')
    elif trend < -1.5:
        return _('falling')
    elif trend <= -0.1:
        return _('falling slowly')
    return _('steady')

def rain_inch(mm):
    "Convert rainfall from millimetres to inches"
    if mm is None:
        return None
    return mm / 25.4

def temp_f(c):
    "Convert temperature from Celsius to Fahrenheit"
    if c is None:
        return None
    return (c * 9.0 / 5.0) + 32.0

def winddir_degrees(pts):
    "Convert wind direction from 0..15 to degrees"
    if pts is None:
        return None
    return pts * 22.5

_winddir_text_array = None

def winddir_text(pts):
    "Convert wind direction from 0..15 to compass point text"
    global _winddir_text_array
    if pts is None:
        return None
    if not _winddir_text_array:
        _ = _Localisation.translation.gettext
        _winddir_text_array = (
            _('N'), _('NNE'), _('NE'), _('ENE'),
            _('E'), _('ESE'), _('SE'), _('SSE'),
            _('S'), _('SSW'), _('SW'), _('WSW'),
            _('W'), _('WNW'), _('NW'), _('NNW'),
            )
    return _winddir_text_array[pts]

def wind_kmph(ms):
    "Convert wind from metres per second to kilometres per hour"
    if ms is None:
        return None
    return ms * 3.6

def wind_mph(ms):
    "Convert wind from metres per second to miles per hour"
    if ms is None:
        return None
    return ms * 3.6 / 1.609344

def wind_kn(ms):
    "Convert wind from metres per second to knots"
    if ms is None:
        return None
    return ms * 3.6 / 1.852

_bft_threshold = (
    0.3, 1.5, 3.4, 5.4, 7.9, 10.7, 13.8, 17.1, 20.7, 24.4, 28.4, 32.6)

def wind_bft(ms):
    "Convert wind from metres per second to Beaufort scale"
    if ms is None:
        return None
    for bft in range(len(_bft_threshold)):
        if ms < _bft_threshold[bft]:
            return bft
    return len(_bft_threshold)

def dew_point(temp, hum):
    """Compute dew point, using formula from
    http://en.wikipedia.org/wiki/Dew_point.

    """
    if temp is None or hum is None:
        return None
    a = 17.27
    b = 237.7
    gamma = ((a * temp) / (b + temp)) + math.log(float(hum) / 100.0)
    return (b * gamma) / (a - gamma)

def cadhumidex(temp, humidity):
    "Calculate Humidity Index as per Canadian Weather Standards"
    if temp is None or humidity is None:
        return None
    # Formulas are adapted to not use e^(...) with no appreciable
    # change in accuracy (0.0227%)
    saturation_pressure = (6.112 * (10.0**(7.5 * temp / (237.7 + temp))) *
                           float(humidity) / 100.0)
    return temp + (0.555 * (saturation_pressure - 10.0))

def usaheatindex(temp, humidity, dew):
    """Calculate Heat Index as per USA National Weather Service Standards

    See http://en.wikipedia.org/wiki/Heat_index, formula 1. The
    formula is not valid for T < 26.7C, Dew Point < 12C, or RH < 40%

    """
    if temp is None or humidity is None:
        return None
    if temp < 26.7 or humidity < 40 or dew < 12.0:
        return temp
    T = (temp * 1.8) + 32.0
    R = humidity
    c_1 = -42.379
    c_2 = 2.04901523
    c_3 = 10.14333127
    c_4 = -0.22475541
    c_5 = -0.00683783
    c_6 = -0.05481717
    c_7 = 0.00122874
    c_8 = 0.00085282
    c_9 = -0.00000199
    return ((c_1 + (c_2 * T) + (c_3 * R) + (c_4 * T * R) + (c_5 * (T**2)) +
             (c_6 * (R**2)) + (c_7 * (T**2) * R) + (c_8 * T * (R**2)) +
             (c_9 * (T**2) * (R**2))) - 32.0) / 1.8

def wind_chill(temp, wind):
    """Compute wind chill, using formula from
    http://en.wikipedia.org/wiki/wind_chill

    """
    if temp is None or wind is None:
        return None
    wind_kph = wind * 3.6
    if wind_kph <= 4.8 or temp > 10.0:
        return temp
    return min(13.12 + (temp * 0.6215) +
               (((0.3965 * temp) - 11.37) * (wind_kph ** 0.16)),
               temp)

def apparent_temp(temp, rh, wind):
    """Compute apparent temperature (real feel), using formula from
    http://www.bom.gov.au/info/thermal_stress/

    """
    if temp is None or rh is None or wind is None:
        return None
    vap_press = (float(rh) / 100.0) * 6.105 * math.exp(
        17.27 * temp / (237.7 + temp))
    return temp + (0.33 * vap_press) - (0.70 * wind) - 4.00

def _main(argv=None):
    global _winddir_text_array
    # run some simple tests
    print 'Wind speed:'
    print '%6s %8s %8s %8s %6s' % ('m/s', 'km/h', 'mph', 'knots', 'bft')
    for ms in (0, 1, 2, 4, 6, 9, 12, 15, 18, 22, 26, 30, 34):
        print '%6g %8.3f %8.3f %8.3f %6d' % (
            ms, wind_kmph(ms), wind_mph(ms), wind_kn(ms), wind_bft(ms))
    print 'Wind direction:'
    for pts in range(16):
        print winddir_text(pts),
    print
    print 'Wind direction, in Swedish:'
    _Localisation.SetTranslation('sv')
    _winddir_text_array = None
    for pts in range(16):
        print winddir_text(pts),
    print

if __name__ == "__main__":
    _main()

########NEW FILE########
__FILENAME__ = DataStore
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
DataStore.py - stores readings in easy to access files

Introduction
------------

This module is at the core of pywws. It stores data on disc, but
without the overhead of a full scale database system. I have designed
it to run on a small memory machine such as my Asus router. To
minimise memory usage it only loads one day's worth of raw data at a
time into memory.

From a "user" point of view, the data is accessed as a cross between a
list and a dictionary. Each data record is indexed by a
:py:class:`datetime.datetime` object (dictionary behaviour), but
records are stored in order and can be accessed as slices (list
behaviour).

For example, to access the hourly data for Christmas day 2009, one
might do the following::

  from datetime import datetime
  from pywws import DataStore
  hourly = DataStore.hourly_store('weather_data')
  for data in hourly[datetime(2009, 12, 25):datetime(2009, 12, 26)]:
      print data['idx'], data['temp_out']

Some more examples of data access::

  # get value nearest 9:30 on Christmas day 2008
  data[data.nearest(datetime(2008, 12, 25, 9, 30))]
  # get entire array, equivalent to data[:]
  data[datetime.min:datetime.max]
  # get last 12 hours worth of data
  data[datetime.utcnow() - timedelta(hours=12):]

Note that the :py:class:`datetime.datetime` index is in UTC. You may
need to apply an offset to convert to local time.

The module provides five classes to store different data.
:py:class:`data_store` takes "raw" data from the weather station;
:py:class:`calib_store`, :py:class:`hourly_store`,
:py:class:`daily_store` and :py:class:`monthly_store` store processed
data (see :py:mod:`pywws.Process`). All three are derived from the
same ``core_store`` class, they only differ in the keys and types of
data stored in each record.

Detailed API
------------

"""

from __future__ import with_statement

from ConfigParser import RawConfigParser
import csv
from datetime import date, datetime, timedelta, MAXYEAR
import os
import sys
from threading import Lock
import time

DAY = timedelta(days=1)

def safestrptime(date_string, format=None):
    # time.strptime is time consuming (because it's so flexible?) so don't use
    # it for the fixed format datetime strings in our csv files
    if format:
        return datetime(*(time.strptime(date_string, format)[0:6]))
    return datetime(*map(int, (date_string[0:4],
                               date_string[5:7],
                               date_string[8:10],
                               date_string[11:13],
                               date_string[14:16],
                               date_string[17:19])))

class ParamStore(object):
    def __init__(self, root_dir, file_name):
        self._lock = Lock()
        with self._lock:
            if not os.path.isdir(root_dir):
                os.makedirs(root_dir)
            self._path = os.path.join(root_dir, file_name)
            self._dirty = False
            # open config file
            self._config = RawConfigParser()
            self._config.read(self._path)

    def __del__(self):
        self.flush()

    def flush(self):
        if not self._dirty:
            return
        with self._lock:
            self._dirty = False
            of = open(self._path, 'w')
            self._config.write(of)
            of.close()

    def get(self, section, option, default=None):
        """Get a parameter value and return a string.

        If default is specified and section or option are not defined
        in the file, they are created and set to default, which is
        then the return value.

        """
        with self._lock:
            if not self._config.has_option(section, option):
                if default is not None:
                    self._set(section, option, default)
                return default
            return self._config.get(section, option)

    def get_datetime(self, section, option, default=None):
        result = self.get(section, option, default)
        if result:
            return safestrptime(result)
        return result

    def set(self, section, option, value):
        """Set option in section to string value."""
        with self._lock:
            self._set(section, option, value)

    def _set(self, section, option, value):
        if not self._config.has_section(section):
            self._config.add_section(section)
        elif (self._config.has_option(section, option) and
              self._config.get(section, option) == value):
            return
        self._config.set(section, option, value)
        self._dirty = True

    def unset(self, section, option):
        """Remove option from section."""
        with self._lock:
            if not self._config.has_section(section):
                return
            if self._config.has_option(section, option):
                self._config.remove_option(section, option)
                self._dirty = True
            if not self._config.options(section):
                self._config.remove_section(section)
                self._dirty = True

class params(ParamStore):
    def __init__(self, root_dir):
        """Parameters are stored in a file "weather.ini" in root_dir."""
        ParamStore.__init__(self, root_dir, 'weather.ini')

class status(ParamStore):
    def __init__(self, root_dir):
        """Status is stored in a file "status.ini" in root_dir."""
        ParamStore.__init__(self, root_dir, 'status.ini')

class _Cache(object):
    def __init__(self):
        self.data = []
        self.ptr = 0
        self.path = ''
        self.lo = date.max
        self.hi = date.min
        self.dirty = False

    def copy(self, other):
        self.data = other.data
        self.ptr = other.ptr
        self.path = other.path
        self.lo = other.lo
        self.hi = other.hi
        self.dirty = False

    def set_ptr(self, idx):
        hi = len(self.data) - 1
        if hi < 0 or self.data[0]['idx'] >= idx:
            self.ptr = 0
            return
        if self.data[hi]['idx'] < idx:
            self.ptr = hi + 1
            return
        lo = 0
        start = min(self.ptr, hi)
        if self.data[start]['idx'] < idx:
            lo = start
        else:
            hi = start
        while hi > lo + 1:
            mid = (lo + hi) // 2
            if self.data[mid]['idx'] < idx:
                lo = mid
            else:
                hi = mid
        self.ptr = hi

class core_store(object):
    def __init__(self, root_dir):
        self._root_dir = root_dir
        # initialise caches
        self._wr_cache = _Cache()
        self._rd_cache = _Cache()
        # get conservative first and last days for which data (might) exist
        self._lo_limit = date.max - timedelta(days=500)
        self._hi_limit = date.min + timedelta(days=500)
        for root, dirs, files in os.walk(self._root_dir):
            files.sort()
            for file in files:
                if file[0] == '.':
                    continue
                path, self._lo_limit, hi = self._get_cache_path(
                    safestrptime(file, "%Y-%m-%d.txt").date())
                break
            else:
                dirs.sort()
                continue
            break
        for root, dirs, files in os.walk(self._root_dir):
            files.sort()
            files.reverse()
            for file in files:
                if file[0] == '.':
                    continue
                path, lo, self._hi_limit = self._get_cache_path(
                    safestrptime(file, "%Y-%m-%d.txt").date())
                break
            else:
                dirs.sort()
                dirs.reverse()
                continue
            break
        self._lo_limit_dt = datetime(
            self._lo_limit.year, self._lo_limit.month, self._lo_limit.day)
        self._hi_limit_dt = datetime(
            self._hi_limit.year, self._hi_limit.month, self._hi_limit.day)

    def __del__(self):
        self.flush()

    def _slice(self, i):
        if i.step is not None:
            raise TypeError("slice step not permitted")
        a = i.start
        if a is None:
            a = self._lo_limit_dt
        elif not isinstance(a, datetime):
            raise TypeError("slice indices must be %s or None" % (datetime))
        elif a < self._lo_limit_dt:
            a = self._lo_limit_dt
        b = i.stop
        if b is None:
            b = self._hi_limit_dt
        elif not isinstance(b, datetime):
            raise TypeError("slice indices must be %s or None" % (datetime))
        elif b > self._hi_limit_dt:
            b = self._hi_limit_dt
        return a, b

    def _get_slice(self, i):
        a, b = self._slice(i)
        if a > b:
            return
        # go to start of slice
        self._set_cache_ptr(self._rd_cache, a)
        cache = self._rd_cache.data
        cache_hi = self._rd_cache.hi
        cache_ptr = self._rd_cache.ptr
        # iterate over complete caches
        while cache_hi <= b.date():
            for data in cache[cache_ptr:]:
                yield data
            if cache_hi >= self._hi_limit:
                return
            self._load(self._rd_cache, cache_hi)
            cache = self._rd_cache.data
            cache_hi = self._rd_cache.hi
            cache_ptr = 0
        # iterate over part of cache
        for data in cache[cache_ptr:]:
            if data['idx'] >= b:
                return
            yield data

    def __getitem__(self, i):
        """Return the data item or items with index i.

        i must be a datetime object or a slice.
        If i is a single datetime then a value with that index must exist."""
        if isinstance(i, slice):
            return self._get_slice(i)
        if not isinstance(i, datetime):
            raise TypeError("list indices must be %s" % (datetime))
        self._set_cache_ptr(self._rd_cache, i)
        if (self._rd_cache.ptr >= len(self._rd_cache.data) or
            self._rd_cache.data[self._rd_cache.ptr]['idx'] != i):
            raise KeyError(i)
        return self._rd_cache.data[self._rd_cache.ptr]

    def __setitem__(self, i, x):
        """Store a value x with index i.

        i must be a datetime object.
        If there is already a value with index i, it is overwritten.
        """
        if not isinstance(i, datetime):
            raise TypeError("index '%s' is not %s" % (i, datetime))
        x['idx'] = i
        self._set_cache_ptr(self._wr_cache, i)
        if len(self._wr_cache.data) == 0:
            self._lo_limit = min(self._lo_limit, self._wr_cache.lo)
            self._hi_limit = max(self._hi_limit, self._wr_cache.hi)
            self._lo_limit_dt = datetime(
                self._lo_limit.year, self._lo_limit.month, self._lo_limit.day)
            self._hi_limit_dt = datetime(
                self._hi_limit.year, self._hi_limit.month, self._hi_limit.day)
        if (self._wr_cache.ptr < len(self._wr_cache.data) and
            self._wr_cache.data[self._wr_cache.ptr]['idx'] == i):
            self._wr_cache.data[self._wr_cache.ptr] = x
        else:
            self._wr_cache.data.insert(self._wr_cache.ptr, x)
        self._wr_cache.dirty = True

    def _del_slice(self, i):
        a, b = self._slice(i)
        if a > b:
            return
        # go to start of slice
        self._set_cache_ptr(self._wr_cache, a)
        # delete to end of cache
        while self._wr_cache.hi <= b.date():
            del self._wr_cache.data[self._wr_cache.ptr:]
            self._wr_cache.dirty = True
            if self._wr_cache.hi >= self._hi_limit:
                return
            self._load(self._wr_cache, self._wr_cache.hi)
            self._wr_cache.ptr = 0
        # delete part of cache
        ptr = self._wr_cache.ptr
        self._wr_cache.set_ptr(b)
        del self._wr_cache.data[ptr:self._wr_cache.ptr]
        self._wr_cache.dirty = True

    def __delitem__(self, i):
        """Delete the data item or items with index i.

        i must be a datetime object or a slice.
        If i is a single datetime then a value with that index must exist."""
        if isinstance(i, slice):
            return self._del_slice(i)
        if not isinstance(i, datetime):
            raise TypeError("list indices must be %s" % (datetime))
        self._set_cache_ptr(self._wr_cache, i)
        if (self._wr_cache.ptr >= len(self._wr_cache.data) or
            self._wr_cache.data[self._wr_cache.ptr]['idx'] != i):
            raise KeyError(i)
        del self._wr_cache.data[self._wr_cache.ptr]
        self._wr_cache.dirty = True

    def before(self, idx):
        """Return datetime of newest existing data record whose
        datetime is < idx.

        Might not even be in the same year! If no such record exists,
        return None."""
        if not isinstance(idx, datetime):
            raise TypeError("'%s' is not %s" % (idx, datetime))
        day = min(idx.date(), self._hi_limit - DAY)
        while day >= self._lo_limit:
            if day < self._rd_cache.lo or day >= self._rd_cache.hi:
                self._load(self._rd_cache, day)
            self._rd_cache.set_ptr(idx)
            if self._rd_cache.ptr > 0:
                return self._rd_cache.data[self._rd_cache.ptr - 1]['idx']
            day = self._rd_cache.lo - DAY
        return None

    def after(self, idx):
        """Return datetime of oldest existing data record whose
        datetime is >= idx.

        Might not even be in the same year! If no such record exists,
        return None."""
        if not isinstance(idx, datetime):
            raise TypeError("'%s' is not %s" % (idx, datetime))
        day = max(idx.date(), self._lo_limit)
        while day < self._hi_limit:
            if day < self._rd_cache.lo or day >= self._rd_cache.hi:
                self._load(self._rd_cache, day)
            self._rd_cache.set_ptr(idx)
            if self._rd_cache.ptr < len(self._rd_cache.data):
                return self._rd_cache.data[self._rd_cache.ptr]['idx']
            day = self._rd_cache.hi
        return None

    def nearest(self, idx):
        """Return datetime of record whose datetime is nearest idx."""
        hi = self.after(idx)
        lo = self.before(idx)
        if hi is None:
            return lo
        if lo is None:
            return hi
        if abs(hi - idx) < abs(lo - idx):
            return hi
        return lo

    def _set_cache_ptr(self, cache, i):
        day = i.date()
        if day < cache.lo or day >= cache.hi:
            self._load(cache, day)
        cache.set_ptr(i)

    def _load(self, cache, target_date):
        self._flush(cache)
        new_path, new_lo, new_hi = self._get_cache_path(target_date)
        if new_path == self._wr_cache.path:
            cache.copy(self._wr_cache)
            return
        if new_path == self._rd_cache.path:
            cache.copy(self._rd_cache)
            return
        cache.data = []
        cache.ptr = 0
        cache.path, cache.lo, cache.hi = new_path, new_lo, new_hi
        if not os.path.exists(cache.path):
            return
        if sys.version_info[0] >= 3:
            csvfile = open(cache.path, 'r', newline='')
        else:
            csvfile = open(cache.path, 'rb')
        reader = csv.reader(csvfile, quoting=csv.QUOTE_NONE)
        for row in reader:
            result = {}
            for key, value in zip(self.key_list, row):
                if value == '':
                    result[key] = None
                else:
                    result[key] = self.conv[key](value)
            cache.data.append(result)
        csvfile.close()

    def flush(self):
        self._flush(self._wr_cache)
        self._flush(self._rd_cache)

    def _flush(self, cache):
        if not cache.dirty:
            return
        cache.dirty = False
        if len(cache.data) == 0:
            if os.path.exists(cache.path):
                # existing data has been wiped, so delete file
                os.unlink(cache.path)
            return
        dir = os.path.dirname(cache.path)
        if not os.path.isdir(dir):
            os.makedirs(dir)
        if sys.version_info[0] >= 3:
            csvfile = open(cache.path, 'w', newline='')
        else:
            csvfile = open(cache.path, 'wb')
        writer = csv.writer(csvfile, quoting=csv.QUOTE_NONE)
        for data in cache.data:
            row = []
            for key in self.key_list[0:len(data)]:
                if isinstance(data[key], float):
                    row.append(str(data[key]))
                else:
                    row.append(data[key])
            writer.writerow(row)
        csvfile.close()

    def _get_cache_path(self, target_date):
        # default implementation - one file per day
        path = os.path.join(self._root_dir,
                            target_date.strftime("%Y"),
                            target_date.strftime("%Y-%m"),
                            target_date.strftime("%Y-%m-%d.txt"))
        lo = min(target_date, date.max - DAY)
        hi = lo + DAY
        return path, lo, hi

class data_store(core_store):
    """Stores raw weather station data."""
    def __init__(self, root_dir):
        core_store.__init__(self, os.path.join(root_dir, 'raw'))

    key_list = [
        'idx', 'delay', 'hum_in', 'temp_in', 'hum_out', 'temp_out',
        'abs_pressure', 'wind_ave', 'wind_gust', 'wind_dir', 'rain',
        'status', 'illuminance', 'uv',
        ]
    conv = {
        'idx'          : safestrptime,
        'delay'        : int,
        'hum_in'       : int,
        'temp_in'      : float,
        'hum_out'      : int,
        'temp_out'     : float,
        'abs_pressure' : float,
        'wind_ave'     : float,
        'wind_gust'    : float,
        'wind_dir'     : int,
        'rain'         : float,
        'status'       : int,
        'illuminance'  : float,
        'uv'           : int,
        }

class calib_store(core_store):
    """Stores 'calibrated' weather station data."""
    def __init__(self, root_dir):
        core_store.__init__(self, os.path.join(root_dir, 'calib'))

    key_list = [
        'idx', 'delay', 'hum_in', 'temp_in', 'hum_out', 'temp_out',
        'abs_pressure', 'rel_pressure', 'wind_ave', 'wind_gust', 'wind_dir',
        'rain', 'status', 'illuminance', 'uv',
        ]
    conv = {
        'idx'          : safestrptime,
        'delay'        : int,
        'hum_in'       : int,
        'temp_in'      : float,
        'hum_out'      : int,
        'temp_out'     : float,
        'abs_pressure' : float,
        'rel_pressure' : float,
        'wind_ave'     : float,
        'wind_gust'    : float,
        'wind_dir'     : int,
        'rain'         : float,
        'status'       : int,
        'illuminance'  : float,
        'uv'           : int,
        }

class hourly_store(core_store):
    """Stores hourly summary weather station data."""
    def __init__(self, root_dir):
        core_store.__init__(self, os.path.join(root_dir, 'hourly'))

    key_list = [
        'idx', 'hum_in', 'temp_in', 'hum_out', 'temp_out',
        'abs_pressure', 'rel_pressure', 'pressure_trend',
        'wind_ave', 'wind_gust', 'wind_dir', 'rain', 'illuminance', 'uv',
        ]
    conv = {
        'idx'               : safestrptime,
        'hum_in'            : int,
        'temp_in'           : float,
        'hum_out'           : int,
        'temp_out'          : float,
        'abs_pressure'      : float,
        'rel_pressure'      : float,
        'pressure_trend'    : float,
        'wind_ave'          : float,
        'wind_gust'         : float,
        'wind_dir'          : int,
        'rain'              : float,
        'illuminance'       : float,
        'uv'                : int,
        }

class daily_store(core_store):
    """Stores daily summary weather station data."""
    def __init__(self, root_dir):
        core_store.__init__(self, os.path.join(root_dir, 'daily'))

    key_list = [
        'idx', 'start',
        'hum_out_ave',
        'hum_out_min', 'hum_out_min_t', 'hum_out_max', 'hum_out_max_t',
        'temp_out_ave',
        'temp_out_min', 'temp_out_min_t', 'temp_out_max', 'temp_out_max_t',
        'hum_in_ave',
        'hum_in_min', 'hum_in_min_t', 'hum_in_max', 'hum_in_max_t',
        'temp_in_ave',
        'temp_in_min', 'temp_in_min_t', 'temp_in_max', 'temp_in_max_t',
        'abs_pressure_ave',
        'abs_pressure_min', 'abs_pressure_min_t',
        'abs_pressure_max', 'abs_pressure_max_t',
        'rel_pressure_ave',
        'rel_pressure_min', 'rel_pressure_min_t',
        'rel_pressure_max', 'rel_pressure_max_t',
        'wind_ave', 'wind_gust', 'wind_gust_t', 'wind_dir',
        'rain',
        'illuminance_ave', 'illuminance_max', 'illuminance_max_t',
        'uv_ave', 'uv_max', 'uv_max_t',
        ]
    conv = {
        'idx'                : safestrptime,
        'start'              : safestrptime,
        'hum_out_ave'        : float,
        'hum_out_min'        : int,
        'hum_out_min_t'      : safestrptime,
        'hum_out_max'        : int,
        'hum_out_max_t'      : safestrptime,
        'temp_out_ave'       : float,
        'temp_out_min'       : float,
        'temp_out_min_t'     : safestrptime,
        'temp_out_max'       : float,
        'temp_out_max_t'     : safestrptime,
        'hum_in_ave'         : float,
        'hum_in_min'         : int,
        'hum_in_min_t'       : safestrptime,
        'hum_in_max'         : int,
        'hum_in_max_t'       : safestrptime,
        'temp_in_ave'        : float,
        'temp_in_min'        : float,
        'temp_in_min_t'      : safestrptime,
        'temp_in_max'        : float,
        'temp_in_max_t'      : safestrptime,
        'abs_pressure_ave'   : float,
        'abs_pressure_min'   : float,
        'abs_pressure_min_t' : safestrptime,
        'abs_pressure_max'   : float,
        'abs_pressure_max_t' : safestrptime,
        'rel_pressure_ave'   : float,
        'rel_pressure_min'   : float,
        'rel_pressure_min_t' : safestrptime,
        'rel_pressure_max'   : float,
        'rel_pressure_max_t' : safestrptime,
        'wind_ave'           : float,
        'wind_gust'          : float,
        'wind_gust_t'        : safestrptime,
        'wind_dir'           : int,
        'rain'               : float,
        'illuminance_ave'    : float,
        'illuminance_max'    : float,
        'illuminance_max_t'  : safestrptime,
        'uv_ave'             : float,
        'uv_max'             : int,
        'uv_max_t'           : safestrptime,
        }

    def _get_cache_path(self, target_date):
        # one file per month
        path = os.path.join(self._root_dir,
                            target_date.strftime("%Y"),
                            target_date.strftime("%Y-%m-01.txt"))
        lo = target_date.replace(day=1)
        if lo.month < 12:
            hi = lo.replace(month=lo.month+1)
        elif lo.year < MAXYEAR:
            hi = lo.replace(year=lo.year+1, month=1)
        else:
            hi = lo
            lo = hi.replace(month=hi.month-1)
        return path, lo, hi

class monthly_store(core_store):
    """Stores monthly summary weather station data."""
    def __init__(self, root_dir):
        core_store.__init__(self, os.path.join(root_dir, 'monthly'))

    key_list = [
        'idx', 'start',
        'hum_out_ave',
        'hum_out_min', 'hum_out_min_t', 'hum_out_max', 'hum_out_max_t',
        'temp_out_ave',
        'temp_out_min_lo', 'temp_out_min_lo_t',
        'temp_out_min_hi', 'temp_out_min_hi_t', 'temp_out_min_ave',
        'temp_out_max_lo', 'temp_out_max_lo_t',
        'temp_out_max_hi', 'temp_out_max_hi_t', 'temp_out_max_ave',
        'hum_in_ave',
        'hum_in_min', 'hum_in_min_t', 'hum_in_max', 'hum_in_max_t',
        'temp_in_ave',
        'temp_in_min_lo', 'temp_in_min_lo_t',
        'temp_in_min_hi', 'temp_in_min_hi_t', 'temp_in_min_ave',
        'temp_in_max_lo', 'temp_in_max_lo_t',
        'temp_in_max_hi', 'temp_in_max_hi_t', 'temp_in_max_ave',
        'abs_pressure_ave',
        'abs_pressure_min', 'abs_pressure_min_t',
        'abs_pressure_max', 'abs_pressure_max_t',
        'rel_pressure_ave',
        'rel_pressure_min', 'rel_pressure_min_t',
        'rel_pressure_max', 'rel_pressure_max_t',
        'wind_ave', 'wind_gust', 'wind_gust_t', 'wind_dir',
        'rain', 'rain_days',
        'illuminance_ave',
        'illuminance_max_lo', 'illuminance_max_lo_t',
        'illuminance_max_hi', 'illuminance_max_hi_t', 'illuminance_max_ave',
        'uv_ave',
        'uv_max_lo', 'uv_max_lo_t', 'uv_max_hi', 'uv_max_hi_t', 'uv_max_ave',
        ]
    conv = {
        'idx'                  : safestrptime,
        'start'                : safestrptime,
        'hum_out_ave'          : float,
        'hum_out_min'          : int,
        'hum_out_min_t'        : safestrptime,
        'hum_out_max'          : int,
        'hum_out_max_t'        : safestrptime,
        'temp_out_ave'         : float,
        'temp_out_min_lo'      : float,
        'temp_out_min_lo_t'    : safestrptime,
        'temp_out_min_hi'      : float,
        'temp_out_min_hi_t'    : safestrptime,
        'temp_out_min_ave'     : float,
        'temp_out_max_lo'      : float,
        'temp_out_max_lo_t'    : safestrptime,
        'temp_out_max_hi'      : float,
        'temp_out_max_hi_t'    : safestrptime,
        'temp_out_max_ave'     : float,
        'hum_in_ave'           : float,
        'hum_in_min'           : int,
        'hum_in_min_t'         : safestrptime,
        'hum_in_max'           : int,
        'hum_in_max_t'         : safestrptime,
        'temp_in_ave'          : float,
        'temp_in_min_lo'       : float,
        'temp_in_min_lo_t'     : safestrptime,
        'temp_in_min_hi'       : float,
        'temp_in_min_hi_t'     : safestrptime,
        'temp_in_min_ave'      : float,
        'temp_in_max_lo'       : float,
        'temp_in_max_lo_t'     : safestrptime,
        'temp_in_max_hi'       : float,
        'temp_in_max_hi_t'     : safestrptime,
        'temp_in_max_ave'      : float,
        'abs_pressure_ave'     : float,
        'abs_pressure_min'     : float,
        'abs_pressure_min_t'   : safestrptime,
        'abs_pressure_max'     : float,
        'abs_pressure_max_t'   : safestrptime,
        'rel_pressure_ave'     : float,
        'rel_pressure_min'     : float,
        'rel_pressure_min_t'   : safestrptime,
        'rel_pressure_max'     : float,
        'rel_pressure_max_t'   : safestrptime,
        'wind_ave'             : float,
        'wind_gust'            : float,
        'wind_gust_t'          : safestrptime,
        'wind_dir'             : int,
        'rain'                 : float,
        'rain_days'            : int,
        'illuminance_ave'      : float,
        'illuminance_max_lo'   : float,
        'illuminance_max_lo_t' : safestrptime,
        'illuminance_max_hi'   : float,
        'illuminance_max_hi_t' : safestrptime,
        'illuminance_max_ave'  : float,
        'uv_ave'               : float,
        'uv_max_lo'            : int,
        'uv_max_lo_t'          : safestrptime,
        'uv_max_hi'            : int,
        'uv_max_hi_t'          : safestrptime,
        'uv_max_ave'           : float,
        }

    def _get_cache_path(self, target_date):
        # one file per year
        path = os.path.join(self._root_dir,
                            target_date.strftime("%Y-01-01.txt"))
        lo = target_date.replace(month=1, day=1)
        if lo.year < MAXYEAR:
            hi = lo.replace(year=lo.year+1)
        else:
            hi = lo
            lo = hi.replace(year=hi.year-1)
        return path, lo, hi

########NEW FILE########
__FILENAME__ = device_ctypes_hidapi
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Low level USB interface to weather station, using ctypes to access hidapi.

Introduction
============

This module handles low level communication with the weather station
via `ctypes <http://docs.python.org/2/library/ctypes.html>`_ and the
`hidapi <https://github.com/signal11/hidapi>`_ library. Alternative
modules, :doc:`pywws.device_cython_hidapi` and
:doc:`pywws.device_pyusb`, use other libraries. The choice of which
module to use depends on which libraries are available for you
computer.

Users of recent versions of Mac OS have less choice. The operating
system makes it very difficult to access HID devices (such as the
weather station) directly, so the ``hidapi`` library has to be used.

Users of OpenWRT and similar embedded Linux platforms will probably
not be able to install ``ctypes`` or ``cython-hidapi``, so are
constrained to use ``libusb`` and its ``PyUSB`` Python interface.

Installation
============

Some of this software may already be installed on your machine, so do
check before downloading sources and compiling them yourself.

#.  Install hidapi.

    Create a local copy of the git repository, change to the new
    directory and then follow the instructions in ``README.txt``::

        git clone https://github.com/signal11/hidapi.git
        cd hidapi
        more README.txt

#.  Install ctypes.

    This should be available as a package for your operating system.
    For example::

        sudo zypper install python-ctypes

Testing
=======

Run ``TestWeatherStation.py`` with increased verbosity so it reports
which USB device access module is being used::

    python TestWeatherStation.py -vv
    18:10:27:pywws.WeatherStation.CUSBDrive:using pywws.device_ctypes_hidapi
    0000 55 aa ff ff ff ff ff ff ff ff ff ff ff ff ff ff 05 20 01 51 11 00 00 00 81 00 00 07 01 00 d0 56
    0020 61 1c 61 1c 00 00 00 00 00 00 00 12 02 14 18 09 41 23 c8 00 32 80 47 2d 2c 01 2c 81 5e 01 1e 80
    0040 a0 00 c8 80 a0 28 80 25 a0 28 80 25 03 36 00 05 6b 00 00 0a 00 f4 01 18 00 00 00 00 00 00 00 00
    0060 00 00 54 1c 63 0a 2f 01 71 00 7a 01 59 80 7a 01 59 80 e4 00 f5 ff 69 54 00 00 fe ff 00 00 b3 01
    0080 0c 02 d0 ff d3 ff 5a 24 d2 24 dc 17 00 11 09 06 15 40 10 03 07 22 18 10 08 11 08 30 11 03 07 12
    00a0 36 08 07 24 17 17 11 02 28 10 10 09 06 30 14 29 12 02 11 06 57 09 06 30 14 29 12 02 11 06 57 08
    00c0 08 31 14 30 12 02 14 18 04 12 02 01 10 12 11 09 13 17 19 11 08 21 16 53 11 09 13 17 19 12 01 18
    00e0 07 17 10 02 22 11 06 11 11 06 13 12 11 11 06 13 12 11 11 10 11 38 11 11 10 11 38 10 02 22 14 43

API
===

"""

__docformat__ = "restructuredtext en"

import ctypes
from ctypes.util import find_library
import sys

if 'sphinx' in sys.modules:
    # building documentation, don't need to import hidapi
    pass
else:
    # open hidapi shared library
    path = find_library('hidapi')
    if not path:
        path = find_library('hidapi-libusb')
    if not path:
        path = find_library('hidapi-hidraw')
    if not path:
        raise ImportError('Cannot find hidapi library')
    hidapi = ctypes.CDLL(path)
    hidapi.hid_open.argtypes = [
        ctypes.c_ushort, ctypes.c_ushort, ctypes.c_wchar_p]
    hidapi.hid_open.restype = ctypes.c_void_p
    hidapi.hid_read_timeout.argtypes = [
        ctypes.c_void_p, ctypes.c_char_p, ctypes.c_size_t, ctypes.c_int]
    hidapi.hid_write.argtypes = [
        ctypes.c_void_p, ctypes.c_char_p, ctypes.c_size_t]

class USBDevice(object):
    def __init__(self, vendor_id, product_id):
        """Low level USB device access via hidapi library.

        :param idVendor: the USB "vendor ID" number, for example 0x1941.

        :type idVendor: int

        :param idProduct: the USB "product ID" number, for example 0x8021.

        :type idProduct: int

        """
        self.device = hidapi.hid_open(vendor_id, product_id, None)
        if not self.device:
            raise IOError("Weather station device not found")
        # flush any unread input
        try:
            self.read_data(32)
        except IOError:
            pass

    def read_data(self, size):
        """Receive data from the device.

        If the read fails for any reason, an :obj:`IOError` exception
        is raised.

        :param size: the number of bytes to read.

        :type size: int

        :return: the data received.

        :rtype: list(int)

        """
        result = list()
        data = ctypes.create_string_buffer(8)
        while size > 0:
            length = min(size, 8)
            n = hidapi.hid_read_timeout(self.device, data, length, 100)
            if n <= 0:
                raise IOError(
                    'pywws.device_ctypes_hidapi.USBDevice.read_data failed')
            for i in range(n):
                result.append(ord(data[i]))
            size -= n
        return result

    def write_data(self, buf):
        """Send data to the device.

        :param buf: the data to send.

        :type buf: list(int)

        :return: success status.

        :rtype: bool

        """
        data = ''.join(map(chr, buf))
        size = len(data)
        if hidapi.hid_write(self.device, ctypes.c_char_p(data), size) != size:
            raise IOError(
                'pywws.device_ctypes_hidapi.USBDevice.write_data failed')
        return True

########NEW FILE########
__FILENAME__ = device_cython_hidapi
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Low level USB interface to weather station, using cython-hidapi.

Introduction
============

This module handles low level communication with the weather station
via the `cython-hidapi <https://github.com/gbishop/cython-hidapi>`_
library. An alternative module, :doc:`pywws.device_pyusb`, uses the
`PyUSB <http://sourceforge.net/apps/trac/pyusb/>`_ library. The choice
of which module to use depends on which libraries are available for
you computer.

Users of recent versions of Mac OS have no choice. The operating
system makes it very difficult to access HID devices (such as the
weather station) directly, so the ``hidapi`` library has to be used.
``cython-hidapi`` is a Python interface to that library.

Users of OpenWRT and similar embedded Linux platforms will probably
not be able to install ``cython-hidapi``, so are constrained to use
``libusb`` and its ``PyUSB`` Python interface.

Installation
============

Some of this software may already be installed on your machine, so do
check before downloading sources and compiling them yourself.

#.  Install hidapi.

    Create a local copy of the git repository, change to the new
    directory and then follow the instructions in ``README.txt``::

        git clone https://github.com/signal11/hidapi.git
        cd hidapi
        more README.txt

#.  Install cython.

    This should be available as a package for your operating system.
    For example::

        sudo apt-get install cython

#.  Install cython-hidapi.

    This also needs to be downloaded and built::

        git clone https://github.com/gbishop/cython-hidapi.git
        cd cython-hidapi
        python setup.py build
        sudo python setup.py install

    Replace ``setup.py`` with ``setup-mac.py`` or ``setup-windows.py``
    if you are using Mac OS or Windows.

Testing
=======

Run ``TestWeatherStation.py`` with increased verbosity so it reports
which USB device access module is being used::

    python TestWeatherStation.py -vv
    18:10:27:pywws.WeatherStation.CUSBDrive:using pywws.device_cython_hidapi
    0000 55 aa ff ff ff ff ff ff ff ff ff ff ff ff ff ff 05 20 01 51 11 00 00 00 81 00 00 07 01 00 d0 56
    0020 61 1c 61 1c 00 00 00 00 00 00 00 12 02 14 18 09 41 23 c8 00 32 80 47 2d 2c 01 2c 81 5e 01 1e 80
    0040 a0 00 c8 80 a0 28 80 25 a0 28 80 25 03 36 00 05 6b 00 00 0a 00 f4 01 18 00 00 00 00 00 00 00 00
    0060 00 00 54 1c 63 0a 2f 01 71 00 7a 01 59 80 7a 01 59 80 e4 00 f5 ff 69 54 00 00 fe ff 00 00 b3 01
    0080 0c 02 d0 ff d3 ff 5a 24 d2 24 dc 17 00 11 09 06 15 40 10 03 07 22 18 10 08 11 08 30 11 03 07 12
    00a0 36 08 07 24 17 17 11 02 28 10 10 09 06 30 14 29 12 02 11 06 57 09 06 30 14 29 12 02 11 06 57 08
    00c0 08 31 14 30 12 02 14 18 04 12 02 01 10 12 11 09 13 17 19 11 08 21 16 53 11 09 13 17 19 12 01 18
    00e0 07 17 10 02 22 11 06 11 11 06 13 12 11 11 06 13 12 11 11 10 11 38 11 11 10 11 38 10 02 22 14 43

API
===

"""

__docformat__ = "restructuredtext en"

import hid

class USBDevice(object):
    def __init__(self, idVendor, idProduct):
        """Low level USB device access via cython-hidapi library.

        :param idVendor: the USB "vendor ID" number, for example 0x1941.

        :type idVendor: int

        :param idProduct: the USB "product ID" number, for example 0x8021.

        :type idProduct: int

        """
        if not hid.enumerate(idVendor, idProduct):
            raise IOError("No weather station connected")
        self.hid = hid.device(idVendor, idProduct)

    def read_data(self, size):
        """Receive data from the device.

        If the read fails for any reason, an :obj:`IOError` exception
        is raised.

        :param size: the number of bytes to read.

        :type size: int

        :return: the data received.

        :rtype: list(int)

        """
        result = list()
        while size > 0:
            count = min(size, 8)
            buf = self.hid.read(count)
            if len(buf) < count:
                raise IOError(
                    'pywws.device_cython_hidapi.USBDevice.read_data failed')
            result += buf
            size -= count
        return result

    def write_data(self, buf):
        """Send data to the device.

        :param buf: the data to send.

        :type buf: list(int)

        :return: success status.

        :rtype: bool

        """
        if self.hid.write(buf) != len(buf):
            raise IOError(
                'pywws.device_cython_hidapi.USBDevice.write_data failed')
        return True

########NEW FILE########
__FILENAME__ = device_pyusb
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Low level USB interface to weather station, using PyUSB.

Introduction
============

This module handles low level communication with the weather station
via the `PyUSB <http://sourceforge.net/apps/trac/pyusb/>`_ library. An
alternative module, :doc:`pywws.device_cython_hidapi`, uses the
`cython-hidapi <https://github.com/gbishop/cython-hidapi>`_ library.
The choice of which module to use depends on which libraries are
available for you computer.

Users of recent versions of Mac OS have no choice. The operating
system makes it very difficult to access HID devices (such as the
weather station) directly, so the ``hidapi`` library has to be used.
``cython-hidapi`` is a Python interface to that library.

Users of OpenWRT and similar embedded Linux platforms will probably
not be able to install ``cython-hidapi``, so are constrained to use
``libusb`` and its ``PyUSB`` Python interface.

Installation
============

Some of this software may already be installed on your machine, so do
check before downloading sources and compiling them yourself.

#.  Install libusb and PyUSB.

    These should be available as packages for your operating system,
    but their names may vary. For example, on Ubuntu Linux::

        sudo apt-get install libusb-0.1 python-usb

    On some embedded linux systems::

        ipkg install libusb py25-usb

Testing
=======

Run ``TestWeatherStation.py`` with increased verbosity so it reports
which USB device access module is being used::

    python TestWeatherStation.py -vv
    18:28:09:pywws.WeatherStation.CUSBDrive:using pywws.device_pyusb
    0000 55 aa ff ff ff ff ff ff ff ff ff ff ff ff ff ff 05 20 01 41 11 00 00 00 81 00 00 0f 05 00 e0 51
    0020 03 27 ce 27 00 00 00 00 00 00 00 12 02 14 18 27 41 23 c8 00 00 00 46 2d 2c 01 64 80 c8 00 00 00
    0040 64 00 64 80 a0 28 80 25 a0 28 80 25 03 36 00 05 6b 00 00 0a 00 f4 01 12 00 00 00 00 00 00 00 00
    0060 00 00 49 0a 63 12 05 01 7f 00 36 01 60 80 36 01 60 80 bc 00 7b 80 95 28 12 26 6c 28 25 26 c8 01
    0080 1d 02 d8 00 de 00 ff 00 ff 00 ff 00 00 11 10 06 01 29 12 02 01 19 32 11 09 09 05 18 12 01 22 13
    00a0 14 11 11 04 15 04 11 12 17 05 12 11 09 02 15 26 12 02 11 07 05 11 09 02 15 26 12 02 11 07 05 11
    00c0 09 10 09 12 12 02 02 12 38 12 02 07 19 00 11 12 16 03 27 12 02 03 11 00 11 12 16 03 27 11 12 26
    00e0 21 32 11 12 26 21 32 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57

API
===

"""

__docformat__ = "restructuredtext en"

import platform
import usb

class USBDevice(object):
    def __init__(self, idVendor, idProduct):
        """Low level USB device access via PyUSB library.

        :param idVendor: the USB "vendor ID" number, for example 0x1941.

        :type idVendor: int

        :param idProduct: the USB "product ID" number, for example 0x8021.

        :type idProduct: int

        """
        dev = self._find_device(idVendor, idProduct)
        if not dev:
            raise IOError("Weather station device not found")
        self.devh = dev.open()
        if not self.devh:
            raise IOError("Open device failed")
        self.devh.reset()
##        if platform.system() is 'Windows':
##            self.devh.setConfiguration(1)
        try:
            self.devh.claimInterface(0)
        except usb.USBError:
            # claim interface failed, try detaching kernel driver first
            if not hasattr(self.devh, 'detachKernelDriver'):
                raise RuntimeError(
                    "Please upgrade pyusb (or python-usb) to 0.4 or higher")
            try:
                self.devh.detachKernelDriver(0)
                self.devh.claimInterface(0)
            except usb.USBError:
                raise IOError("Claim interface failed")
        # device may have data left over from an incomplete read
        for i in range(4):
            try:
                self.devh.interruptRead(0x81, 8, 1200)
            except usb.USBError:
                break

    def __del__(self):
        if self.devh:
            try:
                self.devh.releaseInterface()
            except usb.USBError:
                # interface was not claimed. No problem
                pass

    def _find_device(self, idVendor, idProduct):
        """Find a USB device by product and vendor id."""
        for bus in usb.busses():
            for device in bus.devices:
                if (device.idVendor == idVendor and
                    device.idProduct == idProduct):
                    return device
        return None

    def read_data(self, size):
        """Receive data from the device.

        If the read fails for any reason, an :obj:`IOError` exception
        is raised.

        :param size: the number of bytes to read.

        :type size: int

        :return: the data received.

        :rtype: list(int)

        """
        result = self.devh.interruptRead(0x81, size, 1200)
        if result is None or len(result) < size:
            raise IOError('pywws.device_libusb.USBDevice.read_data failed')
        return list(result)

    def write_data(self, buf):
        """Send data to the device.

        If the write fails for any reason, an :obj:`IOError` exception
        is raised.

        :param buf: the data to send.

        :type buf: list(int)

        :return: success status.

        :rtype: bool

        """
        result = self.devh.controlMsg(
            usb.ENDPOINT_OUT + usb.TYPE_CLASS + usb.RECIP_INTERFACE,
            usb.REQ_SET_CONFIGURATION, buf, value=0x200, timeout=50)
        if result != len(buf):
            raise IOError('pywws.device_libusb.USBDevice.write_data failed')
        return True

########NEW FILE########
__FILENAME__ = device_pyusb1
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Low level USB interface to weather station, using PyUSB.

Introduction
============

This module handles low level communication with the weather station
via the `PyUSB <http://sourceforge.net/apps/trac/pyusb/>`_ library
(version 1.0). Alternative modules, :doc:`pywws.device_pyusb`,
:doc:`pywws.device_ctypes_hidapi`, and
:doc:`pywws.device_cython_hidapi`, use different libraries. The choice
of which module to use depends on which libraries are available for
your computer.

Users of recent versions of Mac OS have less choice. The operating
system makes it very difficult to access HID devices (such as the
weather station) directly, so the ``hidapi`` library has to be used.

Installation
============

Some of this software may already be installed on your machine, so do
check before downloading sources and compiling them yourself.

#.  Install libusb and PyUSB.

    These should be available as packages for your operating system,
    but their names may vary. For example, on Ubuntu Linux::

        sudo apt-get install python-usb

    On some embedded linux systems::

        ipkg install libusb py25-usb

Testing
=======

Run ``TestWeatherStation.py`` with increased verbosity so it reports
which USB device access module is being used::

    python TestWeatherStation.py -vv
    18:28:09:pywws.WeatherStation.CUSBDrive:using pywws.device_pyusb1
    0000 55 aa ff ff ff ff ff ff ff ff ff ff ff ff ff ff 05 20 01 41 11 00 00 00 81 00 00 0f 05 00 e0 51
    0020 03 27 ce 27 00 00 00 00 00 00 00 12 02 14 18 27 41 23 c8 00 00 00 46 2d 2c 01 64 80 c8 00 00 00
    0040 64 00 64 80 a0 28 80 25 a0 28 80 25 03 36 00 05 6b 00 00 0a 00 f4 01 12 00 00 00 00 00 00 00 00
    0060 00 00 49 0a 63 12 05 01 7f 00 36 01 60 80 36 01 60 80 bc 00 7b 80 95 28 12 26 6c 28 25 26 c8 01
    0080 1d 02 d8 00 de 00 ff 00 ff 00 ff 00 00 11 10 06 01 29 12 02 01 19 32 11 09 09 05 18 12 01 22 13
    00a0 14 11 11 04 15 04 11 12 17 05 12 11 09 02 15 26 12 02 11 07 05 11 09 02 15 26 12 02 11 07 05 11
    00c0 09 10 09 12 12 02 02 12 38 12 02 07 19 00 11 12 16 03 27 12 02 03 11 00 11 12 16 03 27 11 12 26
    00e0 21 32 11 12 26 21 32 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57 12 02 06 19 57

API
===

"""

__docformat__ = "restructuredtext en"

import sys
import usb.core
import usb.util

class USBDevice(object):
    def __init__(self, idVendor, idProduct):
        """Low level USB device access via PyUSB 1.0 library.

        :param idVendor: the USB "vendor ID" number, for example 0x1941.

        :type idVendor: int

        :param idProduct: the USB "product ID" number, for example 0x8021.

        :type idProduct: int

        """
        self.dev = usb.core.find(idVendor=idVendor, idProduct=idProduct)
        if not self.dev:
            raise IOError("Weather station device not found")
        if sys.platform.startswith('linux'):
            try:
                detach = self.dev.is_kernel_driver_active(0)
            except NotImplementedError:
                detach = True
            if detach:
                try:
                    self.dev.detach_kernel_driver(0)
                except usb.core.USBError:
                    pass
        self.dev.set_configuration()
        self.dev.reset()

    def read_data(self, size):
        """Receive data from the device.

        If the read fails for any reason, an :obj:`IOError` exception
        is raised.

        :param size: the number of bytes to read.

        :type size: int

        :return: the data received.

        :rtype: list(int)

        """
        result = self.dev.read(0x81, size, timeout=1200)
        if not result or len(result) < size:
            raise IOError('pywws.device_pyusb1.USBDevice.read_data failed')
        return list(result)

    def write_data(self, buf):
        """Send data to the device.

        If the write fails for any reason, an :obj:`IOError` exception
        is raised.

        :param buf: the data to send.

        :type buf: list(int)

        :return: success status.

        :rtype: bool

        """
        bmRequestType = usb.util.build_request_type(
            usb.util.ENDPOINT_OUT,
            usb.util.CTRL_TYPE_CLASS,
            usb.util.CTRL_RECIPIENT_INTERFACE
            )
        result = self.dev.ctrl_transfer(
            bmRequestType=bmRequestType,
            bRequest=usb.REQ_SET_CONFIGURATION,
            data_or_wLength=buf,
            wValue=0x200,
            timeout=50)
        if result != len(buf):
            raise IOError('pywws.device_pyusb1.USBDevice.write_data failed')
        return True

########NEW FILE########
__FILENAME__ = EWtoPy
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Convert EasyWeather.dat data to pywws format
::

%s

Introduction
------------

This program converts data from the format used by the EasyWeather
program supplied with the weather station to the format used by pywws.
It is useful if you've been using EasyWeather for a while before
discovering pywws.

The ``EasyWeather.dat`` file is only used to provide data from before
the start of the pywws data. As your weather station has its own
memory, you should run :py:mod:`pywws.LogData` before
:py:mod:`pywws.EWtoPy` to minimise use of the EasyWeather.dat file.

:py:mod:`pywws.EWtoPy` converts the time stamps in EasyWeather.dat
from local time to UTC. This can cause problems when daylight savings
time ends, as local time appears to jump back one hour. The program
attempts to detect this and correct the affected time stamps, but I
have not been able to test this on a variety of time zones.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.EWtoPy [options] EasyWeather_file data_dir
 options are:
  -h or --help    display this help
 EasyWeather_file is the input data file, e.g. EasyWeather.dat
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

from datetime import datetime, timedelta
import getopt
import os
import sys

from . import DataStore
from . import TimeZone

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o in ('-h', '--help'):
            print >>sys.stderr, __usage__.strip()
            return 0
    # check arguments
    if len(args) != 2:
        print >>sys.stderr, 'Error: 2 arguments required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    # process arguments
    in_name = args[0]
    out_name = args[1]
    # open input
    in_file = open(in_name, 'r')
    # open data file store
    ds = DataStore.data_store(out_name)
    # get time to go forward to
    first_stored = ds.after(datetime.min)
    if first_stored == None:
        first_stored = datetime.max
    # copy any missing data
    last_date = None
    count = 0
    for line in in_file:
        items = line.split(',')
        local_date = DataStore.safestrptime(items[2].strip(), '%Y-%m-%d %H:%M:%S')
        local_date = local_date.replace(tzinfo=TimeZone.Local)
        date = local_date.astimezone(TimeZone.utc)
        if last_date and date < last_date:
            date = date + timedelta(hours=1)
            print "Corrected DST ambiguity %s %s -> %s" % (
                local_date, local_date.tzname(), date)
        last_date = date
        date = date.replace(tzinfo=None)
        # get data
        data = {}
        data['delay'] = int(items[3])
        data['hum_in'] = int(items[4])
        data['temp_in'] = float(items[5])
        try:
            data['hum_out'] = int(items[6])
        except:
            data['hum_out'] = None
        try:
            data['temp_out'] = float(items[7])
        except:
            data['temp_out'] = None
        data['abs_pressure'] = float(items[10])
        try:
            data['wind_ave'] = float(items[12])
        except:
            data['wind_ave'] = None
        try:
            data['wind_gust'] = float(items[14])
        except:
            data['wind_gust'] = None
        try:
            data['wind_dir'] = int(items[16])
        except:
            data['wind_dir'] = None
        data['rain'] = int(items[18]) * 0.3
        data['status'] = int(items[35].split()[15], 16)
        # check against first_stored
        if first_stored - date < timedelta(minutes=data['delay'] // 2):
            break
        ds[date] = data
        count += 1
    print "%d records written" % count
    in_file.close()
    del ds
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = calib_jim
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from datetime import datetime

class Calib(object):
    """Jim's weather station calibration class."""
    def __init__(self, params, raw_data):
        # pressure sensor went wrong on 19th August 2011
        self.pressure_fault = datetime(2011, 8, 19, 11, 0, 0)
        # finally replaced weather station on 11th November 2011
        self.new_station = datetime(2011, 11, 11, 12, 5, 0)

    def calib(self, raw):
        result = dict(raw)
        # set relative pressure and tweak temperature and humidity to make old
        # and new stations closer
        if result['idx'] > self.new_station:
            result['rel_pressure'] = result['abs_pressure'] + 5.2
            if result['temp_out'] is not None:
                result['temp_out'] += 0.6
            if result['hum_out'] is not None:
                result['hum_out'] -= 1
        else:
            if result['idx'] > self.pressure_fault:
                # pressure readings are nonsense since sensor failed
                result['abs_pressure'] = None
                result['rel_pressure'] = None
            else:
                result['rel_pressure'] = result['abs_pressure'] + 7.4
            if result['temp_out'] is not None:
                result['temp_out'] -= 0.6
            if result['hum_out'] is not None:
                result['hum_out'] += 2
        return result

########NEW FILE########
__FILENAME__ = default
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

class Calib(object):
    """Minimum weather station calibration class."""
    def __init__(self, params, raw_data):
        self.pressure_offset = eval(params.get('config', 'pressure offset'))

    def calib(self, raw):
        result = dict(raw)
        # calculate relative pressure
        result['rel_pressure'] = result['abs_pressure'] + self.pressure_offset
        return result

########NEW FILE########
__FILENAME__ = remove_temperature_spikes
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from datetime import timedelta
import logging

from pywws.Process import SECOND

MINUTEx30 = timedelta(minutes=30)

class Calib(object):
    """Weather station calibration class with temperature spike removal."""
    def __init__(self, params, raw_data):
        self.logger = logging.getLogger('pywws.Calib')
        self.raw_data = raw_data
        self.pressure_offset = eval(params.get('config', 'pressure offset'))

    def calib(self, raw):
        result = dict(raw)
        # try to remove spikes in outside temperature
        if result['temp_out'] is not None:
            # get last 30 mins valid temperatures
            history = []
            for data in self.raw_data[result['idx'] - MINUTEx30:
                                      result['idx'] + SECOND]:
                if data['temp_out'] is not None:
                    history.append(data['temp_out'])
            history.sort()
            if len(history) >= 4:
                median = history[(len(history) - 1) / 2]
                if abs(result['temp_out'] - median) > 1.5:
                    self.logger.warning(
                        'spike? %s %s', str(history), str(result['temp_out']))
                if abs(result['temp_out'] - median) > 2.0:
                    result['temp_out'] = None
        # calculate relative pressure
        result['rel_pressure'] = result['abs_pressure'] + self.pressure_offset
        return result

########NEW FILE########
__FILENAME__ = rain_offset
#!/usr/bin/env python

__usage__ = """
Remove rain offset from raw data.
 usage: %s [options] data_dir
 options are:
  -h or --help     display this help
 data_dir is the root directory of the weather data (e.g. $(HOME)/weather/data)
""" % __file__

from datetime import datetime
import getopt
import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '../../..'))
from pywws import DataStore

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    data_dir = args[0]
    # date & time range of data to be changed, in UTC!
    start = datetime(2013, 10, 26, 15, 23)
    stop  = datetime(2013, 10, 30, 12, 47)
    # open data store
    raw_data = DataStore.data_store(data_dir)
    # change the data
    for data in raw_data[start:stop]:
        data['rain'] -= 263.1
        raw_data[data['idx']] = data
    # make sure it's saved
    raw_data.flush()
    # clear calibrated data that needs to be regenerated
    calib_data = DataStore.calib_store(data_dir)
    del calib_data[start:]
    calib_data.flush()
    # done
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = temperature_despike
#!/usr/bin/env python

__usage__ = """
Remove temperature spikes from raw data.
 usage: %s [options] data_dir
 options are:
  -h or --help     display this help
  -n or --noaction show what would be done but don't modify data
 data_dir is the root directory of the weather data (e.g. $(HOME)/weather/data)
""" % __file__

from datetime import datetime, timedelta
import getopt
import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '../../..'))
from pywws import DataStore
from pywws.Process import SECOND

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "hn", ['help', 'noaction'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    noaction = False
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
        elif o == '-n' or o == '--noaction':
            noaction = True
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    data_dir = args[0]
    # date & time range of data to be changed, in UTC!
    start = datetime(2013, 10, 27, 11, 21)
    stop  = datetime(2013, 10, 29, 18, 32)
    # open data store
    raw_data = DataStore.data_store(data_dir)
    # process the data
    aperture = timedelta(minutes=14, seconds=30)
    # make list of changes to apply after examining the data
    changes = []
    for data in raw_data[start:stop]:
        if data['temp_out'] is None:
            continue
        # get temperatures at nearby times
        idx = data['idx']
        temp_list = []
        for local_data in raw_data[idx-aperture:idx+aperture]:
            temp = local_data['temp_out']
            if temp is not None:
                temp_list.append(temp)
        if len(temp_list) < 3:
            continue
        # get median
        temp_list.sort()
        median = temp_list[len(temp_list) / 2]
        # remove anything too far from median
        if abs(data['temp_out'] - median) >= 2.5:
            print str(idx), temp_list, data['temp_out']
            changed = dict(data)
            changed['temp_out'] = None
            changes.append(changed)
    # store the changed data
    if changes and not noaction:
        for changed in changes:
            raw_data[changed['idx']] = changed
        # make sure it's saved
        raw_data.flush()
        # clear calibrated data that needs to be regenerated
        calib_data = DataStore.calib_store(data_dir)
        del calib_data[changes[0]['idx']:]
        calib_data.flush()
    # done
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Forecast
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Predict future weather using recent data
::

%s

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.Forecast [options] data_dir
 options are:
  -h | --help  display this help
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

from datetime import datetime, timedelta
import getopt
import sys

from . import DataStore
from . import Localisation
from .TimeZone import Local, utc
from . import ZambrettiCore

def ZambrettiCode(params, hourly_data):
    north = eval(params.get('Zambretti', 'north', 'True'))
    baro_upper = eval(params.get('Zambretti', 'baro upper', '1050.0'))
    baro_lower = eval(params.get('Zambretti', 'baro lower', '950.0'))
    if not hourly_data['rel_pressure']:
        return ''
    if hourly_data['wind_ave'] is None or hourly_data['wind_ave'] < 0.3:
        wind = None
    else:
        wind = hourly_data['wind_dir']
    if hourly_data['pressure_trend'] is None:
        trend = 0.0
    else:
        trend = hourly_data['pressure_trend'] / 3.0
    return ZambrettiCore.ZambrettiCode(
        hourly_data['rel_pressure'], hourly_data['idx'].month, wind, trend,
        north=north, baro_top=baro_upper, baro_bottom=baro_lower)

def Zambretti(params, hourly_data):
    code = ZambrettiCode(params, hourly_data)
    return Localisation.translation.ugettext(ZambrettiCore.ZambrettiText(code))

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, "Error: 1 argument required"
        print >>sys.stderr, __usage__.strip()
        return 2
    data_dir = args[0]
    params = DataStore.params(data_dir)
    Localisation.SetApplicationLanguage(params)
    hourly_data = DataStore.hourly_store(data_dir)
    idx = hourly_data.before(datetime.max)
    print 'Zambretti (current):', Zambretti(params, hourly_data[idx])
    idx = idx.replace(tzinfo=utc).astimezone(Local)
    if idx.hour < 8 or (idx.hour == 8 and idx.minute < 30):
        idx -= timedelta(hours=24)
    idx = idx.replace(hour=9, minute=0, second=0)
    idx = hourly_data.nearest(idx.astimezone(utc).replace(tzinfo=None))
    lcl = idx.replace(tzinfo=utc).astimezone(Local)
    print 'Zambretti (at %s):' % lcl.strftime('%H:%M %Z'), Zambretti(
        params, hourly_data[idx])
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Hourly
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Get weather data, process it, prepare graphs & text files and
upload to a web site.

Typically run every hour from cron. ::

%s

This script does little more than call other modules in sequence to
get data from the weather station, process it, plot some graphs,
generate some text files and upload the results to a web site.

For more information on using ``Hourly.py``, see
:doc:`../guides/hourlylogging`.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: %s [options] data_dir
 options are:
  -h or --help     display this help
  -v or --verbose  increase amount of reassuring messages
 data_dir is the root directory of the weather data (e.g. $(HOME)/weather/data)
"""
__doc__ %= __usage__ % ('python -m pywws.Hourly')

import getopt
import os
import sys

from . import DataStore
from . import Localisation
from .LogData import DataLogger
from .Logger import ApplicationLogger
from . import Process
from . import Tasks

def Hourly(data_dir):
    # get file locations
    params = DataStore.params(data_dir)
    status = DataStore.status(data_dir)
    # localise application
    Localisation.SetApplicationLanguage(params)
    # open data file stores
    raw_data = DataStore.data_store(data_dir)
    calib_data = DataStore.calib_store(data_dir)
    hourly_data = DataStore.hourly_store(data_dir)
    daily_data = DataStore.daily_store(data_dir)
    monthly_data = DataStore.monthly_store(data_dir)
    # get weather station data
    DataLogger(params, status, raw_data).log_data()
    # do the processing
    Process.Process(params,
                    raw_data, calib_data, hourly_data, daily_data, monthly_data)
    # do tasks
    if not Tasks.RegularTasks(params, status, raw_data, calib_data,
                              hourly_data, daily_data, monthly_data).do_tasks():
        return 1
    return 0

def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(argv[1:], "hv", ['help', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # process options
    verbose = 0
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o == '-v' or o == '--verbose':
            verbose += 1
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, usage
        return 2
    logger = ApplicationLogger(verbose)
    return Hourly(args[0])

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = LiveLog
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Get weather data, store it, and process it.

Run this continuously, having set what tasks are to be done. This
script can also be run with the ``pywws-livelog`` command. ::
%s
For more information on using ``LiveLog.py``, see
:doc:`../guides/livelogging`.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: %s [options] data_dir
 options are:
  -h      or --help      display this help
  -l file or --log file  write log information to file
  -v      or --verbose   increase amount of reassuring messages
 data_dir is the root directory of the weather data (e.g. ~/weather/data)
"""
__doc__ %= __usage__ % ('python -m pywws.LiveLog')

from datetime import datetime, timedelta
import getopt
import logging
import os
import sys
import time

from . import DataStore
from . import Localisation
from .LogData import DataLogger
from .Logger import ApplicationLogger
from . import Process
from . import Tasks

def LiveLog(data_dir):
    logger = logging.getLogger('pywws.LiveLog')
    params = DataStore.params(data_dir)
    status = DataStore.status(data_dir)
    # localise application
    Localisation.SetApplicationLanguage(params)
    # open data file stores
    raw_data = DataStore.data_store(data_dir)
    calib_data = DataStore.calib_store(data_dir)
    hourly_data = DataStore.hourly_store(data_dir)
    daily_data = DataStore.daily_store(data_dir)
    monthly_data = DataStore.monthly_store(data_dir)
    # create a DataLogger object
    datalogger = DataLogger(params, status, raw_data)
    # create a RegularTasks object
    asynch = eval(params.get('config', 'asynchronous', 'False'))
    tasks = Tasks.RegularTasks(params, status, raw_data, calib_data,
                               hourly_data, daily_data, monthly_data,
                               asynch=asynch)
    # get live data
    try:
        for data, logged in datalogger.live_data(
                                    logged_only=(not tasks.has_live_tasks())):
            if logged:
                # process new data
                Process.Process(params, raw_data, calib_data,
                                hourly_data, daily_data, monthly_data)
                # do tasks
                tasks.do_tasks()
            else:
                tasks.do_live(data)
    except Exception, ex:
        logger.exception(ex)
    finally:
        tasks.stop_thread()
    return 0

def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(argv[1:], "hl:v", ['help', 'log=', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # process options
    logfile = None
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o in ('-l', '--log'):
            logfile = a
        elif o in ('-v', '--verbose'):
            verbose += 1
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, usage
        return 2
    logger = ApplicationLogger(verbose, logfile)
    return LiveLog(args[0])

if __name__ == "__main__":
    logger = logging.getLogger('pywws')
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        pass
    except Exception, e:
        logger.exception(str(e))

########NEW FILE########
__FILENAME__ = livelogdaemon
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Run 'live logging' as a UNIX daemon.

This script can also be run with the ``pywws-livelog-daemon`` command. ::
%s
Requires the python-daemon library.

If you get a "function() argument 1 must be code, not str" error, try
installing python-daemon from PyPI instead of your Linux repos.

For more information on 'live logging' see :doc:`../guides/livelogging`.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: %s [options] data_dir log_file start|stop|restart
 options are:
  -h      or --help        display this help
  -p file or --pid file    store pid in 'file' (default /run/lock/pywws.pid)
  -v      or --verbose     increase amount of logging messages
 data_dir is the root directory of the weather data (e.g. ~/weather/data)
 log_file is a file to write logging to, e.g. /var/log/pywws.log
"""
__doc__ %= __usage__ % ('python -m pywws.livelogdaemon')

from daemon.runner import DaemonRunner
import getopt
import os
import sys

from .LiveLog import LiveLog
from .Logger import ApplicationLogger

class Runner(DaemonRunner):
    def __init__(self, data_dir, action, files_preserve, pid_file):
        self.data_dir = os.path.abspath(data_dir)
        # attributes required by daemon runner
        self.stdin_path = '/dev/null'
        self.stdout_path = '/dev/null'
        self.stderr_path = '/dev/null'
        self.pidfile_path = pid_file
        self.pidfile_timeout = 5
        # initialise daemon runner
        DaemonRunner.__init__(self, self)
        self.daemon_context.files_preserve = files_preserve
        self.action = action

    def parse_args(self, argv=None):
        # don't let daemon runner do its own command line parsing
        pass

    def run(self):
        LiveLog(self.data_dir)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(
            argv[1:], "hp:v", ['help', 'pid=', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # process options
    pid_file = '/run/lock/pywws.pid'
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o in ('-p', '--pid'):
            pid_file = a
        elif o in ('-v', '--verbose'):
            verbose += 1
    # check arguments
    if len(args) != 3:
        print >>sys.stderr, 'Error: 3 arguments required\n'
        print >>sys.stderr, usage
        return 2
    logger = ApplicationLogger(verbose, args[1])
    runner = Runner(
        args[0], args[2], map(lambda x: x.stream, logger.handlers), pid_file)
    try:
        runner.do_action()
    except Exception, ex:
        logger.exception(ex)
        return 3
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Localisation
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Localisation.py - provide translations of strings into local
language

::

%s

Introduction
------------

Some of the pywws modules, such as WindRose.py, can automatically use
your local language for such things as wind directions. The
Localisation.py module, mostly copied from examples in the Python
documentation, enables this.

Localisation of pywws is done in two parts - translating strings such
as 'rising very rapidly', and changing the 'locale' which controls
things like month names and number representation (e.g. '23,2' instead
of '23.2'). On some computers it may not be possible to set the
locale, but translated strings can still be used.

Using a different language
--------------------------

The language used by pywws is set in the ``[config]`` section of the
``weather.ini`` file. This can be a two-letter language code, such as
``en`` (English), or can specify a national variant, such as ``fr_CA``
(Canadian French). It could also include a character set, for example
``de_DE.UTF-8``.

The choice of language is very system dependant, so Localisation.py
can be run as a standalone program to test language codes. A good
starting point might be your system's ``LANG`` environment variable,
for example::

    jim@brains:~/Documents/weather/pywws/code$ echo $LANG
    en_GB.UTF-8
    jim@brains:~/Documents/weather/pywws/code$ python -m pywws.Localisation -t en_GB.UTF-8
    Locale changed from (None, None) to ('en_GB', 'UTF8')
    Translation set OK
    Locale
      decimal point: 23.2
      date & time: Friday, 14 October (14/10/11 13:02:00)
    Translations
      'NNW' => 'NNW'
      'rising very rapidly' => 'rising very rapidly'
      'Rain at times, very unsettled' => 'Rain at times, very unsettled'
    jim@brains:~/Documents/weather/pywws/code$

In most cases no more than a two-letter code is required::

    jim@brains:~/Documents/weather/pywws/code$ python -m pywws.Localisation -t fr
    Locale changed from (None, None) to ('fr_FR', 'UTF8')
    Translation set OK
    Locale
      decimal point: 23,2
      date & time: vendredi, 14 octobre (14/10/2011 13:04:44)
    Translations
      'NNW' => 'NNO'
      'rising very rapidly' => 'en hausse très rapide'
      'Rain at times, very unsettled' => 'Quelques précipitations, très perturbé'
    jim@brains:~/Documents/weather/pywws/code$

If you try an unsupported language, pywws falls back to English::

    jim@brains:~/Documents/weather/pywws/code$ python -m pywws.Localisation -t ja
    Failed to set locale: ja
    No translation file found for: ja
    Locale
      decimal point: 23.2
      date & time: Friday, 14 October (10/14/11 13:08:49)
    Translations
      'NNW' => 'NNW'
      'rising very rapidly' => 'rising very rapidly'
      'Rain at times, very unsettled' => 'Rain at times, very unsettled'
    jim@brains:~/Documents/weather/pywws/code$

Once you've found a suitable language code that works, you can
configure pywws to use it by editing your ``weather.ini`` file::

 [config]
 language = fr

Creating a new translation
--------------------------

If there is no translation file for your preferred language then you
need to create one. See :doc:`../guides/language` for detailed
instructions.

"""

__docformat__ = "restructuredtext en"

__usage__ = """
 usage: python -m pywws.Localisation [options]
 options are:
  -h       or  --help       display this help
  -t code  or  --test code  test use of a language code
"""

__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import getopt
import gettext
import locale
import os
import pkg_resources
import sys
import time

# set translation to be used if SetTranslation is not called
translation = gettext.NullTranslations()
# Python 3 translations don't have a ugettext method
if not hasattr(translation, 'ugettext'):
    translation.ugettext = translation.gettext

def SetLocale(lang):
    """Set the 'locale' used by a program.

    This affects the entire application, changing the way dates,
    currencies and numbers are represented. It should not be called
    from a library routine that may be used in another program.

    The ``lang`` parameter can be any string that is recognised by
    ``locale.setlocale()``, for example ``en``, ``en_GB`` or ``en_GB.UTF-8``.

    :param lang: language code.
    :type lang: string
    :return: success status.
    :rtype: bool

    """
    # get the default locale
    lc, encoding = locale.getdefaultlocale()
    try:
        if '.' in lang:
            locale.setlocale(locale.LC_ALL, lang)
        else:
            locale.setlocale(locale.LC_ALL, (lang, encoding))
    except locale.Error:
        return False
    return True

def SetTranslation(lang):
    """Set the translation used by (some) pywws modules.

    This sets the translation object ``Localisation.translation`` to
    use a particular language.

    The ``lang`` parameter can be any string of the form ``en``,
    ``en_GB`` or ``en_GB.UTF-8``. Anything after a ``.`` character is
    ignored. In the case of a string such as ``en_GB``, the routine
    will search for an ``en_GB`` language file before searching for an
    ``en`` one.

    :param lang: language code.
    :type lang: string
    :return: success status.
    :rtype: bool

    """
    global translation
    # make list of possible languages, in order of preference
    langs = list()
    if lang:
        if '.' in lang:
            lang = lang.split('.')[0]
        langs += [lang, lang[:2]]
    # get translation object
    path = pkg_resources.resource_filename('pywws', 'lang')
    codeset = locale.getpreferredencoding()
    if codeset == 'ASCII':
        codeset = 'UTF-8'
    try:
        translation = gettext.translation(
            'pywws', path, languages=langs, codeset=codeset)
        # Python 3 translations don't have a ugettext method
        if not hasattr(translation, 'ugettext'):
            translation.ugettext = translation.gettext
    except IOError:
        return False
    return True

def SetApplicationLanguage(params):
    """Set the locale and translation for a pywws program.

    This function reads the language from the configuration file, then
    calls :func:`SetLocale` and :func:`SetTranslation`.

    :param params: a :class:`pywws.DataStore.params` object.

    :type params: object

    """
    lang = params.get('config', 'language', None)
    if lang:
        SetLocale(lang)
        SetTranslation(lang)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "ht:", ['help', 'test='])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    code = None
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
        elif o in ('-t', '--test'):
            code = a
    # check arguments
    if len(args) != 0:
        print >>sys.stderr, 'Error: no arguments required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    # test language code
    if code:
        old_locale = locale.getlocale()
        if SetLocale(code):
            new_locale = locale.getlocale()
            print "Locale changed from", old_locale, "to", new_locale
        else:
            print "Failed to set locale:", code
        if SetTranslation(code):
            print "Translation set OK"
        else:
            print "No translation file found for:", code
    # try a few locale / translation effects
    print "Locale"
    print "  decimal point:", locale.format("%4.1f", 23.2)
    print "  date & time:", time.strftime("%A, %d %B (%x %X)")
    print "Translations"
    print "  'NNW' => '%s'" % (translation.lgettext('NNW'))
    print "  'rising very rapidly' => '%s'" % (
        translation.lgettext('rising very rapidly'))
    print "  'Rain at times, very unsettled' => '%s'" % (
        translation.lgettext('Rain at times, very unsettled'))
    return 0

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = LogData
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14 Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Save weather station history to file
::

%s

This module gets data from the weather station's memory and stores it
to file. Each time it is run it fetches all data that is newer than
the last stored data, so it only needs to be run every hour or so. As
the weather station typically stores two weeks' readings (depending on
the logging interval), :py:mod:`pywws.LogData` could be run quite
infrequently if you don't need up-to-date data.

There is no date or time information in the raw weather station data,
so :py:mod:`pywws.LogData` creates a time stamp for each reading. It
uses the computer's clock, rather than the weather station clock which
can not be read accurately by the computer. A networked computer
should have its clock set accurately by `ntp
<http://en.wikipedia.org/wiki/Network_Time_Protocol>`_.

Synchronisation with the weather station is achieved by waiting for a
change in the current data. There are two levels of synchronisation,
set by the config file or a command line option. Level 0 is quicker,
but is only accurate to around twelve seconds. Level 1 waits until the
weather station stores a new logged record, and gets time stamps
accurate to a couple of seconds. Note that this could take a long
time, if the logging interval is greater than the recommended five
minutes.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.LogData [options] data_dir
 options are:
  -h   | --help     display this help
  -c   | --clear    clear weather station's memory full indicator
  -s n | --sync n   set quality of synchronisation to weather station (0 or 1)
  -v   | --verbose  increase number of informative messages
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

from datetime import datetime, timedelta
import getopt
import logging
import os
import sys
import time

from .constants import SECOND
from . import DataStore
from .Logger import ApplicationLogger
from .TimeZone import HOUR
from .WeatherStation import weather_station

class DataLogger(object):
    def __init__(self, params, status, raw_data):
        self.logger = logging.getLogger('pywws.DataLogger')
        self.params = params
        self.status = status
        self.raw_data = raw_data
        # connect to weather station
        ws_type = self.params.get('fixed', 'ws type')
        if ws_type:
            self.params.unset('fixed', 'ws type')
            self.params.set('config', 'ws type', ws_type)
        ws_type = self.params.get('config', 'ws type', 'Unknown')
        avoid = eval(self.params.get('config', 'usb activity margin', '3.0'))
        self.ws = weather_station(
            ws_type=ws_type, status=self.status, avoid=avoid)
        # check for valid weather station type
        fixed_block = self.check_fixed_block()
        if ws_type not in ('1080', '3080'):
            print "Unknown weather station type. Please edit weather.ini"
            print "and set 'ws type' to '1080' or '3080', as appropriate."
            if fixed_block['lux_wm2_coeff'] == 0.0:
                print "Your station is probably a '1080' type."
            else:
                print "Your station is probably a '3080' type."
            sys.exit(1)
        # check computer clock isn't earlier than last stored data
        last_stored = self.raw_data.before(datetime.max)
        if last_stored and datetime.utcnow() < last_stored:
            raise ValueError('Computer time is earlier than last stored data')

    def check_fixed_block(self):
        fixed_block = self.ws.get_fixed_block(unbuffered=True)
        # check clocks
        try:
            s_time = DataStore.safestrptime(
                fixed_block['date_time'], '%Y-%m-%d %H:%M')
        except Exception:
            s_time = None
        if s_time:
            c_time = datetime.now().replace(second=0, microsecond=0)
            diff = abs(s_time - c_time)
            if diff > timedelta(minutes=2):
                self.logger.warning(
                    "Computer and weather station clocks disagree by %s (H:M:S).", str(diff))
        # store info from fixed block
        self.status.unset('fixed', 'pressure offset')
        if not self.params.get('config', 'pressure offset'):
            self.params.set('config', 'pressure offset', '%g' % (
                fixed_block['rel_pressure'] - fixed_block['abs_pressure']))
        self.params.unset('fixed', 'fixed block')
        self.status.set('fixed', 'fixed block', str(fixed_block))
        # check ws type
        if (fixed_block['lux_wm2_coeff'] == 0.0) != (self.ws.ws_type == '1080'):
            self.logger.warning('weather station type appears to be incorrect')
        return fixed_block

    def catchup(self, last_date, last_ptr):
        fixed_block = self.ws.get_fixed_block(unbuffered=True)
        # get time to go back to
        last_stored = self.raw_data.before(datetime.max)
        if not last_stored:
            last_stored = datetime.min
        if self.status.get('data', 'ptr'):
            saved_ptr, saved_date = self.status.get('data', 'ptr').split(',')
            saved_ptr = int(saved_ptr, 16)
            saved_date = DataStore.safestrptime(saved_date)
            saved_date = self.raw_data.nearest(saved_date)
            while saved_date < last_stored:
                saved_date = self.raw_data.after(saved_date + SECOND)
                saved_ptr = self.ws.inc_ptr(saved_ptr)
        else:
            saved_ptr = None
            saved_date = None
        last_stored += timedelta(seconds=fixed_block['read_period'] * 30)
        if last_date <= last_stored:
            # nothing to do
            return
        self.status.set(
            'data', 'ptr', '%06x,%s' % (last_ptr, last_date.isoformat(' ')))
        # data_count includes record currently being updated every 48 seconds
        max_count = fixed_block['data_count'] - 1
        count = 0
        duplicates = []
        while last_date > last_stored and count < max_count:
            data = self.ws.get_data(last_ptr)
            if last_ptr == saved_ptr:
                if any(data[key] != self.raw_data[saved_date][key] for key in (
                        'hum_in', 'temp_in', 'hum_out', 'temp_out',
                        'abs_pressure', 'wind_ave', 'wind_gust', 'wind_dir',
                        'rain', 'status')):
                    # pointer matches but data is different, so no duplicates
                    duplicates = None
                    saved_ptr = None
                    saved_date = None
                else:
                    # potential duplicate data
                    duplicates.append(last_date)
                    saved_date = self.raw_data.before(saved_date)
                    saved_ptr = self.ws.dec_ptr(saved_ptr)
            if data['delay'] is None or data['delay'] > 30:
                self.logger.error('invalid data at %04x, %s',
                                  last_ptr, last_date.isoformat(' '))
                last_date -= timedelta(minutes=fixed_block['read_period'])
            else:
                self.raw_data[last_date] = data
                count += 1
                last_date -= timedelta(minutes=data['delay'])
            last_ptr = self.ws.dec_ptr(last_ptr)
        if duplicates:
            for d in duplicates:
                del self.raw_data[d]
            count -= len(duplicates)
        last_date = self.raw_data.nearest(last_date)
        next_date = self.raw_data.after(last_date + SECOND)
        if next_date:
            gap = (next_date - last_date).seconds // 60
            gap -= fixed_block['read_period']
            if gap > 0:
                self.logger.critical("%d minutes gap in data detected", gap)
        self.logger.info("%d catchup records", count)

    def log_data(self, sync=None, clear=False):
        fixed_block = self.check_fixed_block()
        # get sync config value
        if sync is None:
            if fixed_block['read_period'] <= 5:
                sync = int(self.params.get('config', 'logdata sync', '1'))
            else:
                sync = int(self.params.get('config', 'logdata sync', '0'))
        # get address and date-time of last complete logged data
        self.logger.info('Synchronising to weather station')
        range_hi = datetime.max
        range_lo = datetime.min
        last_delay = self.ws.get_data(self.ws.current_pos())['delay']
        if last_delay == 0:
            prev_date = datetime.min
        else:
            prev_date = datetime.utcnow()
        for data, last_ptr, logged in self.ws.live_data(logged_only=(sync > 1)):
            last_date = data['idx']
            self.logger.debug('Reading time %s', last_date.strftime('%H:%M:%S'))
            if logged:
                break
            if sync < 2 and self.ws._station_clock.clock:
                err = last_date - datetime.fromtimestamp(
                    self.ws._station_clock.clock)
                last_date -= timedelta(
                    minutes=data['delay'], seconds=err.seconds % 60)
                self.logger.debug('log time %s', last_date.strftime('%H:%M:%S'))
                last_ptr = self.ws.dec_ptr(last_ptr)
                break
            if sync < 1:
                hi = last_date - timedelta(minutes=data['delay'])
                if last_date - prev_date > timedelta(seconds=50):
                    lo = hi - timedelta(seconds=60)
                elif data['delay'] == last_delay:
                    lo = hi - timedelta(seconds=60)
                    hi = hi - timedelta(seconds=48)
                else:
                    lo = hi - timedelta(seconds=48)
                last_delay = data['delay']
                prev_date = last_date
                range_hi = min(range_hi, hi)
                range_lo = max(range_lo, lo)
                err = (range_hi - range_lo) / 2
                last_date = range_lo + err
                self.logger.debug('est log time %s +- %ds (%s..%s)',
                                  last_date.strftime('%H:%M:%S'), err.seconds,
                                  lo.strftime('%H:%M:%S'), hi.strftime('%H:%M:%S'))
                if err < timedelta(seconds=15):
                    last_ptr = self.ws.dec_ptr(last_ptr)
                    break
        # go back through stored data, until we catch up with what we've already got
        self.logger.info('Fetching data')
        self.catchup(last_date, last_ptr)
        if clear:
            self.logger.info('Clearing weather station memory')
            ptr = self.ws.fixed_format['data_count'][0]
            self.ws.write_data([(ptr, 1), (ptr+1, 0)])

    def live_data(self, logged_only=False):
        next_hour = datetime.utcnow(
            ).replace(minute=0, second=0, microsecond=0) + HOUR
        next_ptr = None
        for data, ptr, logged in self.ws.live_data(logged_only=logged_only):
            if logged:
                now = data['idx']
                if ptr == next_ptr:
                    # data is contiguous with last logged value
                    self.raw_data[now] = data
                    if now >= next_hour:
                        next_hour += HOUR
                        self.check_fixed_block()
                    self.status.set(
                        'data', 'ptr', '%06x,%s' % (ptr, now.isoformat(' ')))
                else:
                    # catch up missing data
                    self.catchup(now, ptr)
                next_ptr = self.ws.inc_ptr(ptr)
            yield data, logged

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(
            argv[1:], "hcs:v", ('help', 'clear', 'sync=', 'verbose'))
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    clear = False
    sync = None
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
        elif o in ('-c', '--clear'):
            clear = True
        elif o in ('-s', '--sync'):
            sync = int(a)
        elif o in ('-v', '--verbose'):
            verbose += 1
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(verbose)
    root_dir = args[0]
    DataLogger(
        DataStore.params(root_dir), DataStore.status(root_dir),
        DataStore.data_store(root_dir)).log_data(sync=sync, clear=clear)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Logger
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Common code for logging info and errors.
"""

from __future__ import absolute_import

import logging
import logging.handlers
import sys

from . import __version__

def ApplicationLogger(verbose, logfile=None):
    logger = logging.getLogger('')
    if logfile:
        logger.setLevel(max(logging.ERROR - (verbose * 10), 1))
        handler = logging.handlers.RotatingFileHandler(
            logfile, maxBytes=128*1024, backupCount=3)
        datefmt = '%Y-%m-%d %H:%M:%S'
    else:
        logger.setLevel(max(logging.WARNING - (verbose * 10), 1))
        handler = logging.StreamHandler()
        datefmt = '%H:%M:%S'
    handler.setFormatter(
        logging.Formatter('%(asctime)s:%(name)s:%(message)s', datefmt))
    logger.addHandler(handler)
    pywws_logger = logging.getLogger('pywws.Logger')
    pywws_logger.warning('pywws version %s', __version__)
    pywws_logger.info('Python version %s', sys.version)
    return logger

########NEW FILE########
__FILENAME__ = Plot
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Plot graphs of weather data according to an XML recipe
::

%s

Introduction
------------

Like Template.py this is one of the more difficult to use modules in
the weather station software collection. It plots a graph (or set of
graphs) of weather data. Almost everything about the graph is
controlled by an XML file. I refer to these files as templates, but
they aren't templates in the same sense as Template.py uses to create
text files.

Before writing your own graph template files, it might be useful to
look at some of the examples in the example_graph_templates directory.
If (like I was) you are unfamiliar with XML, I suggest reading the W3
Schools XML tutorial.

XML graph file syntax
^^^^^^^^^^^^^^^^^^^^^

Here is the simplest useful graph template. It plots the external
temperature for the last 24 hours. ::

  <?xml version="1.0" encoding="ISO-8859-1"?>
  <graph>
    <plot>
      <subplot>
        <title>Temperature (°C)</title>
        <ycalc>data['temp_out']</ycalc>
      </subplot>
    </plot>
  </graph>

In this example, the root element graph has one plot element, which
has one subplot element. The subplot element contains a title element
and a ycalc element. To plot more data on the same set of axes (for
example dew point and temperature), we can add more subplot elements.
To plot more than one set of axes (for example wind speed is measured
in different units from temperature) in the same file we can add more
plot elements.

The complete element hierarchy is shown below. ::

    graph
        plot
            subplot
                xcalc
                ycalc
                axes
                style
                colour
                title
            bmargin
            yrange
            y2range
            ytics
            y2tics
            ylabel
            ylabelangle
            y2label
            y2labelangle
            grid
            source
            boxwidth
            title
            command
        start
        stop
        duration
        layout
        size
        fileformat
        terminal
        lmargin
        rmargin
        xformat
        xlabel
        dateformat
        xtics
        title

graph
^^^^^

This is the root element of the graph XML file. It does not have to be
called "graph", but there must be exactly one root element.

plot
^^^^

Every graph element should contain at least one plot element. A
separate graph is drawn for each plot element, but all share the same
X axis.

start
^^^^^

This element sets the date & time of the start of the X axis. It is
used in the constructor of a Python datetime object. For example, to
start the graph at noon (local time) on Christmas day 2008:
``<start>year=2008, month=12, day=25, hour=12</start>``. The default
value is (stop - duration).

stop
^^^^

This element sets the date & time of the end of the X axis. It is used
in the constructor of a Python datetime object. For example, to end
the graph at 10 am (local time) on new year's day: ``<stop>year=2009,
month=1, day=1, hour=10</stop>``. The default value is (start +
duration), unless start is not defined in which case the timestamp of
the latest weather station hourly reading is used.

duration
^^^^^^^^

This element sets the extent of the X axis of the graph, unless both
start and stop are defined. It is used in the constructor of a Python
timedelta object. For example, to plot one week:
``<duration>weeks=1</duration>``. The default value is hours=24.

layout
^^^^^^

Controls the layout of the plots. Default is a single column. The
layout element specifies rows and columns. For example: ``<layout>4,
2</layout>`` will use a grid of 4 rows and 2 columns.

size
^^^^

Sets the overall dimensions of the image file containing the graph.
Default (in a single column layout) is a width of 600 pixels and
height of 200 pixels for each plot, so a graph with four plot elements
would be 600 x 800 pixels. Any size element must include both width
and height. For example: ``<size>800, 600</size>`` will produce an
image 800 pixels wide and 600 pixels high.

fileformat
^^^^^^^^^^

Sets the image format of the file containing the graph. Default is
png. Any string recognised by your installation of gnuplot should do.
For example: ``<fileformat>gif</fileformat>`` will produce a GIF
image.

terminal
^^^^^^^^

Allows complete control of gnuplot's 'terminal' settings. You may want
to use this if you are plotting to an unusual image format. Any string
recognised by your installation of gnuplot's 'set terminal' command
should do. For example: ``<terminal>svg enhanced font "arial,9" size
600,800 dynamic rounded</terminal>``. This setting overwrites both
size and fileformat.

lmargin
^^^^^^^

Sets the left margin of the plots, i.e. the distance from the left
hand axis to the left hand edge of the image area. According to the
gnuplot documentation the units of lmargin are character widths. The
default value is 5, which should look OK in most circumstances.

rmargin
^^^^^^^

Sets the right margin of the plots, i.e. the distance from the right
hand axis to the right hand edge of the image area. According to the
gnuplot documentation the units of rmargin are character widths. The
default value is -1, which sets automatic adjustment.

xformat
^^^^^^^

Sets the format of the time / date xtic labels. The value is a
strftime style format string. Default depends on the graph duration:
24 hours or less is "%%H%%M", 24 hours to 7 days is "%%a %%d" and 7
days or more is "%%Y/%%m/%%d".

xlabel
^^^^^^

Sets the X axis label. The value is a strftime style format string.
Default depends on the graph duration: 24 hours or less is "Time
(%%Z)", 24 hours to 7 days is "Day" and 7 days or more is "Date". The
datetime used to compute this is start, which may produce unexpected
results when a graph spans DST start or end.

dateformat
^^^^^^^^^^

Sets the format of the date labels at each end of X axis. The value is
a strftime style format string. Default is "%%Y/%%m/%%d". The right
hand label is only drawn if it differs from the left. To have no
labels, set an empty format: ``<dateformat></dateformat>``

xtics
^^^^^

Sets the spacing of the "tic" marks on the X axis. The value is an
integer number of hours. The default is to allow gnuplot to set an
appropriate interval.

title
^^^^^

Sets the title of the graph. A single line of text, for example:
``<title>Today's weather</title>``. This title appears at the very top
of the graph, outside any plot area.

subplot
^^^^^^^

Every plot element should contain at least one subplot element. A
separate trace is drawn for each subplot element, but all share the
same X and Y axes.

bmargin
^^^^^^^

Sets the bottom margin, i.e. the spacing between the lower X axis and
the edge of the graph (or the next plot). The default is to let
gnuplot adjust this automatically, which works OK most of the time but
you may wish to fine tune the value to suit your installation.

The permitted value is any non-negative real number. On my setup 0.9
is a good value, set as follows: ``<bmargin>0.9</bmargin>``.

yrange
^^^^^^

Sets the lower and upper limits of the (left hand) Y axis. The value
is anything understood by gnuplot, typically a pair of numbers. The
default is to allow gnuplot to set appropriate values, which is
unlikely to be what you want. For example, to plot typical UK
temperatures with no value going off the graph: ``<yrange>-10,
30</yrange>``. Note that commas are converted to colons, so
``<yrange>-10:30</yrange>`` would be equivalent.

You can use an asterisk to have gnuplot choose a suitable value. For
example, to have the upper value auto scale whilst fixing the lower
value at zero, use ``<yrange>0:*</yrange>``.

y2range
^^^^^^^

Sets the lower and upper limits of the right hand Y axis. Default is
for the right hand Y axis to be the same as the left, but setting a
different range is useful in dual axis plotting.

ytics
^^^^^

Controls the "tic" marks on the left hand Y axis. The value can be
anything that's understood by gnuplot. For example, to set the tic
spacing to 45 use ``<ytics>45</ytics>``. More complex things are also
possible, e.g. to label a wind direction graph with compass points,
use ``<y2tics>('N' 0, 'E' 90, 'S' 180, 'W' 270, 'N' 360)</y2tics>``.

y2tics
^^^^^^

Controls the "tic" marks on the right hand axis. The format is the
same as that for ytics. Default behaviour is to copy the left hand tic
marks, but without labels.

ylabel
^^^^^^

Adds a label to the (left hand) Y axis. For example, when plotting
temperature: ``<ylabel>°C</ylabel>``. If you use ylabel you will
probably want to adjust lmargin.

ylabelangle
^^^^^^^^^^^

Adjust the angle of the (left hand) Y axis label, if your version of
gnuplot supports it. For example, to write the label horizontally:
``<ylabelangle>90</ylabelangle>``.

y2label
^^^^^^^

Adds a label to the right hand Y axis. For example, when plotting
humidity: ``<y2label>%%</y2label>``. This is mostly used when plotting
dual axis graphs. If you use y2label you will probably want to adjust
rmargin.

y2labelangle
^^^^^^^^^^^^

Adjust the angle of the right hand Y axis label, if your version of
gnuplot supports it. For example, to write the label horizontally:
``<y2labelangle>90</y2labelangle>``.

grid
^^^^

Adds a grid to the plot. In most situations gnuplot's default grid is
suitable, so no value is needed: ``<grid></grid>``. More control is
possible using any of the options understood by gnuplot's set grid
command. For example, to have horizontal grid lines only:
``<grid>ytics</grid>``.

source
^^^^^^

Select the weather data to be plotted. Permitted values are
``<source>raw</source>``, ``<source>hourly</source>``,
``<source>daily</source>`` and ``<source>monthly</source>``. Default
is raw. Note that the different sources have different data
dictionaries, so this choice affects ycalc.

boxwidth
^^^^^^^^

Sets the width of the "boxes" used when drawing bar graphs. The value
is an integer expression yielding a number of seconds. Default depends
on source: raw is 240, hourly is 2800 and daily is 2800 * 24.

title
^^^^^

Sets the title of the plot. A single line of text, for example:
``<title>Temperature (°C)</title>``. This title appears within the
plot area, above any subplot titles.

command
^^^^^^^

Execute any gnuplot command, just before the main "plot" command. This
option allows advanced users to have greater control over the graph
appearance. The value is any valid gnuplot command, typically
beginning with the word set. For example: ``<command>set key tmargin
center horizontal width 1 noreverse enhanced autotitles box linetype
-1 linewidth 1</command>``. (Don't ask me what this example does — I'm
not an advanced user).

xcalc
^^^^^

Controls the X axis positioning of plotted data values. The default
value of data['idx'] is correct for most data, but there are some
exceptions. For example, when plotting bar charts of hourly rainfall,
it's nice to centre the bars on 30 minutes past the hour:
``<xcalc>data['idx'].replace(minute=30, second=0)</xcalc>``.

ycalc
^^^^^

Selects the data to be plotted. Any one line Python expression that
returns a single float value can be used. At its simplest this just
selects one value from the "data" dictionary, for example:
``<ycalc>data['temp_out']</ycalc>`` plots the external temperature.
More complex expressions are possible, and some helper functions are
provided. For example: ``<ycalc>dew_point(data['temp_out'],
data['hum_out'])</ycalc>`` plots the external dew point, and
``<ycalc>wind_mph(data['wind_ave'])</ycalc>`` plots the average wind
speed in miles per hour.

Cumulative plots are also possible. The result of each ycalc
computation is stored and made available to the next computation in
the variable last_ycalc. This can be used with any data, but is most
useful with rainfall: ``<ycalc>data['rain'] + last_ycalc</ycalc>``.

axes
^^^^

Selects which Y axis the data is plotted against. Default is the left
hand axis, but the right hand axis can be chosen with:
``<axes>x1y2</axes>``. This can be used in conjunction with y2range to
plot two unrelated quantities on one graph, for example temperature
and humidity.

style
^^^^^

Sets the line style for the graph. Default is a smooth continuous
line, thickness 1. To select a bar graph use: ``<style>box</style>``.
To select points without a connecting line use: ``<style>+</style>``
or ``<style>x</style>``. To select a line thickness 3 (for example)
use: ``<style>line 3</style>``. The thickness of points can be set in
a similar fashion. For complete control (for advanced users) a full
gnuplot style can be set: ``<style>smooth unique lc 5 lw 3</style>``.

colour
^^^^^^

Sets the colour of the subplot line or boxes. Any integer value is
accepted. The mapping of colours to numbers is set by gnuplot. Default
value is the previous colour plus one.

title
^^^^^

Sets the title of the subplot. A single line of text, for example:
``<title>Temperature (°C)</title>``. This title appears within the
plot area, next to a short segment of the line colour used for the
subplot.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.Plot [options] data_dir temp_dir xml_file output_file
 options are:
  -h or --help    display this help
 data_dir is the root directory of the weather data
 temp_dir is a workspace for temporary files e.g. /tmp
 xml_file is the name of the source file that describes the plot
 output_file is the name of the image file to be created e.g. 24hrs.png
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import codecs
from datetime import datetime, timedelta
import getopt
import locale
import logging
import os
import subprocess
import sys
import xml.dom.minidom

from .conversions import *
from . import DataStore
from . import Localisation
from .Logger import ApplicationLogger
from .TimeZone import Local

class GraphNode(object):
    def __init__(self, node):
        self.node = node

    def get_children(self, name):
        result = []
        for child in self.node.childNodes:
            if child.localName == name:
                result.append(GraphNode(child))
        return result

    def get_value(self, name, default):
        for child in self.node.childNodes:
            if child.localName == name:
                if child.childNodes:
                    return child.childNodes[0].data.strip()
                else:
                    return ''
        return default

class GraphFileReader(GraphNode):
    def __init__(self, input_file):
        self.input_file = input_file
        self.doc = GraphNode(xml.dom.minidom.parse(input_file))
        graphs = self.doc.get_children('graph')
        if not graphs:
            raise RuntimeError('%s has no graph node' % input_file)
        GraphNode.__init__(self, graphs[0].node)

    def close(self):
        self.doc.node.unlink()

class BasePlotter(object):
    def __init__(self, params, status, raw_data, hourly_data,
                 daily_data, monthly_data, work_dir):
        self.logger = logging.getLogger('pywws.%s' % self.__class__.__name__)
        self.raw_data = raw_data
        self.hourly_data = hourly_data
        self.daily_data = daily_data
        self.monthly_data = monthly_data
        self.work_dir = work_dir
        self.pressure_offset = eval(params.get('config', 'pressure offset'))
        self.gnuplot_version = eval(
            params.get('config', 'gnuplot version', '4.2'))
        # set language related stuff
        self.encoding = params.get('config', 'gnuplot encoding', 'iso_8859_1')
        # create work directory
        if not os.path.isdir(self.work_dir):
            os.makedirs(self.work_dir)

    def DoPlot(self, input_file, output_file):
        if isinstance(input_file, GraphFileReader):
            self.graph = input_file
        else:
            # read XML graph description
            self.graph = GraphFileReader(input_file)
        # get list of plots
        plot_list = self.graph.get_children(self.plot_name)
        self.plot_count = len(plot_list)
        if self.plot_count < 1:
            # nothing to plot
            self.logger.info('%s has no %s nodes', self.graph.input_file, self.plot_name)
            self.graph.close()
            return 1
        # get start and end datetimes
        self.x_lo = self.graph.get_value('start', None)
        self.x_hi = self.graph.get_value('stop', None)
        self.duration = self.graph.get_value('duration', None)
        if self.duration:
            self.duration = eval('timedelta(%s)' % self.duration)
        else:
            self.duration = timedelta(hours=24)
        if self.x_lo:
            self.x_lo = eval('datetime(%s)' % self.x_lo)
            if self.x_hi:
                self.x_hi = eval('datetime(%s)' % self.x_hi)
                self.duration = self.x_hi - self.x_lo
            else:
                self.x_hi = self.x_lo + self.duration
        elif self.x_hi:
            self.x_hi = eval('datetime(%s)' % self.x_hi)
            self.x_lo = self.x_hi - self.duration
        else:
            self.x_hi = self.hourly_data.before(datetime.max)
            if not self.x_hi:
                self.x_hi = datetime.utcnow()    # only if no hourly data
            self.x_hi += Local.utcoffset(self.x_hi)
            # set end of graph to start of the next hour after last item
            self.x_hi += timedelta(minutes=55)
            self.x_hi = self.x_hi.replace(minute=0, second=0)
            self.x_lo = self.x_hi - self.duration
        self.utcoffset = Local.utcoffset(self.x_hi)
        # open gnuplot command file
        self.tmp_files = []
        cmd_file = os.path.join(self.work_dir, 'plot.cmd')
        self.tmp_files.append(cmd_file)
        if sys.version_info[0] >= 3:
            of = open(cmd_file, 'w', encoding=self.encoding)
        else:
            of = open(cmd_file, 'w')
        # write gnuplot set up
        self.rows = self.GetDefaultRows()
        self.cols = (self.plot_count + self.rows - 1) // self.rows
        self.rows, self.cols = eval(self.graph.get_value(
            'layout', '%d, %d' % (self.rows, self.cols)))
        w, h = self.GetDefaultPlotSize()
        w = w * self.cols
        h = h * self.rows
        w, h = eval(self.graph.get_value('size', '(%d, %d)' % (w, h)))
        fileformat = self.graph.get_value('fileformat', 'png')
        if fileformat == 'svg':
            terminal = '%s enhanced font "arial,9" size %d,%d dynamic rounded' % (
                fileformat, w, h)
        else:
            terminal = '%s large size %d,%d' % (fileformat, w, h)
        terminal = self.graph.get_value('terminal', terminal)
        of.write('set encoding %s\n' % (self.encoding))
        lcl = locale.getlocale()
        if lcl[0]:
            of.write('set locale "%s.%s"\n' % lcl)
        of.write('set terminal %s\n' % (terminal))
        of.write('set output "%s"\n' % (output_file))
        # set overall title
        title = self.graph.get_value('title', '')
        if title:
            if sys.version_info[0] < 3:
                title = title.encode(self.encoding)
            title = 'title "%s"' % title
        of.write('set multiplot layout %d, %d %s\n' % (self.rows, self.cols, title))
        # do actual plots
        of.write(self.GetPreamble())
        for plot_no in range(self.plot_count):
            plot = plot_list[plot_no]
            # set key / title location
            title = plot.get_value('title', '')
            if sys.version_info[0] < 3:
                title = title.encode(self.encoding)
            of.write('set key horizontal title "%s"\n' % title)
            # optional yaxis labels
            ylabel = plot.get_value('ylabel', '')
            if ylabel:
                if sys.version_info[0] < 3:
                    ylabel = ylabel.encode(self.encoding)
                ylabelangle = plot.get_value('ylabelangle', '')
                if ylabelangle:
                    ylabelangle = ' rotate by %s' % (ylabelangle)
                of.write('set ylabel "%s"%s\n' % (ylabel, ylabelangle))
            else:
                of.write('set ylabel\n')
            y2label = plot.get_value('y2label', '')
            if y2label:
                if sys.version_info[0] < 3:
                    y2label = y2label.encode(self.encoding)
                y2labelangle = plot.get_value('y2labelangle', '')
                if y2labelangle:
                    y2labelangle = ' rotate by %s' % (y2labelangle)
                of.write('set y2label "%s"%s\n' % (y2label, y2labelangle))
            else:
                of.write('set y2label\n')
            # set data source
            source = plot.get_value('source', 'raw')
            if source == 'raw':
                source = self.raw_data
            elif source == 'hourly':
                source = self.hourly_data
            elif source == 'monthly':
                source = self.monthly_data
            else:
                source = self.daily_data
            # do the plot
            of.write(self.PlotData(plot_no, plot, source))
        of.close()
        self.graph.close()
        # run gnuplot on file
        subprocess.check_call(['gnuplot', cmd_file])
        for file in self.tmp_files:
            os.unlink(file)
        return 0

class Record(object):
    pass

class GraphPlotter(BasePlotter):
    plot_name = 'plot'
    def GetDefaultRows(self):
        return self.plot_count

    def GetDefaultPlotSize(self):
        return 200 // self.cols, 600 // self.cols

    def GetPreamble(self):
        result = """set style fill solid
set xdata time
set timefmt "%Y-%m-%dT%H:%M:%S"
"""
        result += 'set xrange ["%s":"%s"]\n' % (
            self.x_lo.isoformat(), self.x_hi.isoformat())
        lmargin = eval(self.graph.get_value('lmargin', '5'))
        result += 'set lmargin %g\n' % (lmargin)
        rmargin = eval(self.graph.get_value('rmargin', '-1'))
        result += 'set rmargin %g\n' % (rmargin)
        if self.duration <= timedelta(hours=24):
            xformat = '%H%M'
        elif self.duration <= timedelta(days=7):
            xformat = '%a %d'
        else:
            xformat = '%Y/%m/%d'
        xformat = self.graph.get_value('xformat', xformat)
        result += 'set format x "%s"\n' % xformat
        xtics = self.graph.get_value('xtics', None)
        if xtics:
            result += 'set xtics %d\n' % (eval(xtics) * 3600)
        if sys.version_info[0] < 3:
            result = result.encode(self.encoding)
        return result

    def PlotData(self, plot_no, plot, source):
        _ = Localisation.translation.ugettext
        subplot_list = plot.get_children('subplot')
        subplot_count = len(subplot_list)
        if subplot_count < 1:
            return ''
        result = ''
        pressure_offset = self.pressure_offset
        # label x axis of last plot
        if plot_no == self.plot_count - 1:
            if self.duration <= timedelta(hours=24):
                # TX_NOTE Keep the "(%Z)" formatting string
                xlabel = _('Time (%Z)')
            elif self.duration <= timedelta(days=7):
                xlabel = _('Day')
            else:
                xlabel = _('Date')
            xlabel = self.graph.get_value('xlabel', xlabel)
            if sys.version_info[0] < 3:
                xlabel = xlabel.encode(self.encoding)
            result += 'set xlabel "%s"\n' % (
                self.x_hi.replace(tzinfo=Local).strftime(xlabel))
            dateformat = '%Y/%m/%d'
            dateformat = self.graph.get_value('dateformat', dateformat)
            if sys.version_info[0] < 3:
                dateformat = dateformat.encode(self.encoding)
            ldat = self.x_lo.replace(tzinfo=Local).strftime(dateformat)
            rdat = self.x_hi.replace(tzinfo=Local).strftime(dateformat)
            if ldat:
                result += 'set label "%s" at "%s", graph -0.3 left\n' % (
                    ldat, self.x_lo.isoformat())
            if rdat != ldat:
                result += 'set label "%s" at "%s", graph -0.3 right\n' % (
                    rdat, self.x_hi.isoformat())
        # set bottom margin
        bmargin = eval(plot.get_value('bmargin', '-1'))
        result += 'set bmargin %g\n' % (bmargin)
        # set y ranges and tics
        yrange = plot.get_value('yrange', None)
        y2range = plot.get_value('y2range', None)
        ytics = plot.get_value('ytics', 'autofreq')
        y2tics = plot.get_value('y2tics', '')
        if y2tics and not y2range:
            y2range = yrange
        elif y2range and not y2tics:
            y2tics = 'autofreq'
        if yrange:
            result += 'set yrange [%s]\n' % (yrange.replace(',', ':'))
        else:
            result += 'set yrange [*:*]\n'
        if y2range:
            result += 'set y2range [%s]\n' % (y2range.replace(',', ':'))
        if y2tics:
            result += 'set ytics nomirror %s; set y2tics %s\n' % (ytics, y2tics)
        else:
            result += 'unset y2tics; set ytics mirror %s\n' % (ytics)
        # set grid
        result += 'unset grid\n'
        grid = plot.get_value('grid', None)
        if grid is not None:
            result += 'set grid %s\n' % grid
        # x_lo & x_hi are in local time, data is indexed in UTC
        start = self.x_lo - self.utcoffset
        stop = self.x_hi - self.utcoffset
        cumu_start = start
        if source == self.raw_data:
            boxwidth = 240      # assume 5 minute data interval
            start = source.before(start)
        elif source == self.hourly_data:
            boxwidth = 2800
            start = source.before(start)
            interval = timedelta(minutes=90)
        elif source == self.monthly_data:
            boxwidth = 2800 * 24 * 30
            interval = timedelta(days=46)
        else:
            interval = timedelta(hours=36)
            boxwidth = 2800 * 24
        boxwidth = eval(plot.get_value('boxwidth', str(boxwidth)))
        result += 'set boxwidth %d\n' % boxwidth
        command = plot.get_value('command', None)
        if command:
            result += '%s\n' % command
        stop = source.after(stop)
        if stop:
            stop = stop + timedelta(minutes=1)
        # write data files
        subplots = []
        for subplot_no in range(subplot_count):
            subplot = Record()
            subplot.subplot = subplot_list[subplot_no]
            subplot.dat_file = os.path.join(self.work_dir, 'plot_%d_%d.dat' % (
                plot_no, subplot_no))
            self.tmp_files.append(subplot.dat_file)
            subplot.dat = open(subplot.dat_file, 'w')
            subplot.xcalc = subplot.subplot.get_value('xcalc', None)
            subplot.ycalc = subplot.subplot.get_value('ycalc', None)
            subplot.cummulative = 'last_ycalc' in subplot.ycalc
            if subplot.xcalc:
                subplot.xcalc = compile(subplot.xcalc, '<string>', 'eval')
            subplot.ycalc = compile(subplot.ycalc, '<string>', 'eval')
            subplot.last_ycalcs = 0.0
            subplot.last_idx = None
            subplots.append(subplot)
        for data in source[start:stop]:
            for subplot in subplots:
                if subplot.xcalc:
                    idx = eval(subplot.xcalc)
                    if idx is None:
                        continue
                else:
                    idx = data['idx']
                idx += self.utcoffset
                if not subplot.cummulative and subplot.last_idx:
                    if source == self.raw_data:
                        interval = timedelta(minutes=((data['delay']*3)+1)//2)
                    if idx - subplot.last_idx > interval:
                        # missing data
                        subplot.dat.write('%s ?\n' % (idx.isoformat()))
                subplot.last_idx = idx
                try:
                    if subplot.cummulative and data['idx'] <= cumu_start:
                        value = 0.0
                    else:
                        last_ycalc = subplot.last_ycalcs
                        value = eval(subplot.ycalc)
                    subplot.dat.write('%s %g\n' % (idx.isoformat(), value))
                    subplot.last_ycalcs = value
                except TypeError:
                    if not subplot.cummulative:
                        subplot.dat.write('%s ?\n' % (idx.isoformat()))
                    subplot.last_ycalcs = 0.0
        for subplot in subplots:
            # ensure the data file isn't empty
            idx = self.x_hi + self.duration
            subplot.dat.write('%s ?\n' % (idx.isoformat()))
            subplot.dat.close()
        # plot data
        result += 'plot '
        colour = 0
        for subplot_no in range(subplot_count):
            subplot = subplots[subplot_no]
            colour = eval(subplot.subplot.get_value('colour', str(colour+1)))
            style = subplot.subplot.get_value(
                'style', 'smooth unique lc %d lw 1' % (colour))
            words = style.split()
            if len(words) > 1 and words[0] in ('+', 'x', 'line'):
                width = int(words[1])
            else:
                width = 1
            if style == 'box':
                style = 'lc %d lw 0 with boxes' % (colour)
            elif words[0] == '+':
                style = 'lc %d lw %d pt 1 with points' % (colour, width)
            elif words[0] == 'x':
                style = 'lc %d lw %d pt 2 with points' % (colour, width)
            elif words[0] == 'line':
                style = 'smooth unique lc %d lw %d' % (colour, width)
            axes = subplot.subplot.get_value('axes', 'x1y1')
            title = subplot.subplot.get_value('title', '')
            result += ' "%s" using 1:($2) axes %s title "%s" %s' % (
                subplot.dat_file, axes, title, style)
            if subplot_no != subplot_count - 1:
                result += ', \\'
            result += '\n'
        if sys.version_info[0] < 3:
            result = result.encode(self.encoding)
        return result

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 4:
        print >>sys.stderr, 'Error: 4 arguments required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(2)
    params = DataStore.params(args[0])
    status = DataStore.status(args[0])
    Localisation.SetApplicationLanguage(params)
    return GraphPlotter(
        params, status,
        DataStore.calib_store(args[0]), DataStore.hourly_store(args[0]),
        DataStore.daily_store(args[0]), DataStore.monthly_store(args[0]),
        args[1]
        ).DoPlot(GraphFileReader(args[2]), args[3])

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Process
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Generate hourly, daily & monthly summaries of raw weather station
data
::

%s

This module takes raw weather station data (typically sampled every
five or ten minutes) and generates hourly, daily and monthly summary
data, which is useful when creating tables and graphs.

Before computing the data summaries, raw data is "calibrated" using a
user-programmable function. See :doc:`pywws.calib` for details.

The hourly data is derived from all the records in one hour, e.g. from
18:00:00 to 18:59:59, and is given the index of the last complete
record in that hour.

The daily data summarises the weather over a 24 hour period typically
ending at 2100 or 0900 hours, local (non DST) time, though midnight is
another popular convention. It is also indexed by the last complete
record in the period. Daytime and nightime, as used when computing
maximum and minimum temperatures, are assumed to start at 0900 and
2100 local time, or 1000 and 2200 when DST is in effect, regardless of
the meteorological day.

To adjust the meteorological day to your preference, or that used by
your local official weather station, edit the "day end hour" line in
your ``weather.ini`` file, then run Reprocess.py to regenerate the
summaries.

Monthly summary data is computed from the daily summary data. If the
meteorological day does not end at midnight, then each month may begin
and end up to 12 hours before or after midnight.

Wind speed data is averaged over the hour (or day) and the maximum
gust speed during the hour (or day) is recorded. The predominant wind
direction is calculated using vector arithmetic.

Rainfall is converted from the raw "total since last reset" figure to
a more useful total in the last hour, day or month.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.Process [options] data_dir
 options are:
  -h or --help     display this help
  -v or --verbose  increase number of informative messages
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

from collections import deque
from datetime import date, datetime, timedelta
import getopt
import logging
import math
import os
import sys

from .calib import Calib
from . import DataStore
from .Logger import ApplicationLogger
from .TimeZone import STDOFFSET, HOUR

SECOND = timedelta(seconds=1)
TIME_ERR = timedelta(seconds=45)
HOURx3 = timedelta(hours=3)
DAY = timedelta(hours=24)
WEEK = timedelta(days=7)

class Average(object):
    """Compute average of multiple data values."""
    def __init__(self):
        self.acc = 0.0
        self.count = 0

    def add(self, value):
        if value is None:
            return
        self.acc += value
        self.count += 1

    def result(self):
        if self.count == 0:
            return None
        return self.acc / float(self.count)

class Minimum(object):
    """Compute minimum value and timestamp of multiple data values."""
    def __init__(self):
        self.value = None
        self.time = None

    def add(self, value, time):
        if not self.time or value <= self.value:
            self.value = value
            self.time = time

    def result(self):
        if self.time:
            return self.value, self.time
        return None, None

class Maximum(object):
    """Compute maximum value and timestamp of multiple data values."""
    def __init__(self):
        self.value = None
        self.time = None

    def add(self, value, time):
        if not self.time or value > self.value:
            self.value = value
            self.time = time

    def result(self):
        if self.time:
            return self.value, self.time
        return None, None

sin_LUT = map(
    lambda x: math.sin(math.radians(float(x * 360) / 16.0)), range(16))
cos_LUT = map(
    lambda x: math.cos(math.radians(float(x * 360) / 16.0)), range(16))

class HourAcc(object):
    """'Accumulate' raw weather data to produce hourly summary.

    Compute average wind speed and maximum wind gust, find dominant
    wind direction and compute total rainfall.

    """
    def __init__(self, last_rain):
        self.logger = logging.getLogger('pywws.Process.HourAcc')
        self.last_rain = last_rain
        self.wind_dir = list()
        for i in range(16):
            self.wind_dir.append(0.0)
        self.copy_keys = ['idx', 'hum_in', 'temp_in', 'hum_out', 'temp_out',
                          'abs_pressure', 'rel_pressure']
        self.reset()

    def reset(self):
        for i in range(16):
            self.wind_dir[i] = 0.0
        self.wind_acc = 0.0
        self.wind_gust = (-2.0, None)
        self.rain = 0.0
        self.wind_count = 0
        self.retval = {'idx' : None, 'temp_out' : None}

    def add_raw(self, data):
        idx = data['idx']
        wind_ave = data['wind_ave']
        if wind_ave is not None:
            wind_dir = data['wind_dir']
            if wind_dir is not None:
                self.wind_dir[wind_dir] += wind_ave
            self.wind_acc += wind_ave
            self.wind_count += 1
        wind_gust = data['wind_gust']
        if wind_gust is not None and wind_gust > self.wind_gust[0]:
            self.wind_gust = (wind_gust, idx)
        rain = data['rain']
        if rain is not None:
            if self.last_rain is not None:
                diff = rain - self.last_rain
                if diff < -0.001:
                    self.logger.warning(
                        '%s rain reset %.1f -> %.1f', str(idx), self.last_rain, rain)
                elif diff > float(data['delay'] * 5):
                    # rain exceeds 5mm / minute, assume corrupt data and ignore it
                    self.logger.warning(
                        '%s rain jump %.1f -> %.1f', str(idx), self.last_rain, rain)
                else:
                    self.rain += max(0.0, diff)
            self.last_rain = rain
        # copy some current readings
        if 'illuminance' in data and not 'illuminance' in self.copy_keys:
            self.copy_keys.append('illuminance')
            self.copy_keys.append('uv')
        # if near the end of the hour, ignore 'lost contact' readings
        if (data['idx'].minute < 45 or data['temp_out'] is not None or
                                self.retval['temp_out'] is None):
            for key in self.copy_keys:
                self.retval[key] = data[key]

    def result(self):
        if not self.retval['idx']:
            return None
        if self.wind_count > 0:
            # convert weighted wind directions to a vector
            Ve = 0.0
            Vn = 0.0
            for dir in range(16):
                val = self.wind_dir[dir]
                Ve -= val * sin_LUT[dir]
                Vn -= val * cos_LUT[dir]
            # get direction of total vector
            dir_ave = (math.degrees(math.atan2(Ve, Vn)) + 180.0) * 16.0 / 360.0
            self.retval['wind_dir'] = int(dir_ave + 0.5) % 16
            wind_ave = self.wind_acc / float(self.wind_count)
            self.retval['wind_ave'] = wind_ave
        else:
            self.retval['wind_dir'] = None
            self.retval['wind_ave'] = None
        if self.wind_gust[1]:
            self.retval['wind_gust'] = self.wind_gust[0]
        else:
            self.retval['wind_gust'] = None
        self.retval['rain'] = self.rain
        return self.retval

class DayAcc(object):
    """'Accumulate' weather data to produce daily summary.

    Compute average wind speed, maximum wind gust and daytime max &
    nighttime min temperatures, find dominant wind direction and
    compute total rainfall.

    Daytime is assumed to be 0900-2100 and nighttime to be 2100-0900,
    local time (1000-2200 and 2200-1000 during DST), regardless of the
    "day end hour" setting.

    """
    def __init__(self):
        self.logger = logging.getLogger('pywws.Process.DayAcc')
        self.has_illuminance = False
        self.wind_dir = list()
        for i in range(16):
            self.wind_dir.append(0.0)
        self.ave = {}
        self.max = {}
        self.min = {}
        self.reset()

    def reset(self):
        for i in range(16):
            self.wind_dir[i] = 0.0
        self.wind_acc = 0.0
        self.wind_count = 0
        self.wind_gust = (-1.0, None)
        self.rain = 0.0
        for i in ('temp_in', 'temp_out', 'hum_in', 'hum_out',
                  'abs_pressure', 'rel_pressure'):
            self.ave[i] = Average()
            self.max[i] = Maximum()
            self.min[i] = Minimum()
        for i in ('illuminance', 'uv'):
            self.ave[i] = Average()
            self.max[i] = Maximum()
        self.retval = dict()

    def add_raw(self, data):
        idx = data['idx']
        local_hour = (idx + STDOFFSET).hour
        wind_gust = data['wind_gust']
        if wind_gust is not None and wind_gust > self.wind_gust[0]:
            self.wind_gust = (wind_gust, idx)
        for i in ('temp_in', 'temp_out'):
            temp = data[i]
            if temp is not None:
                self.ave[i].add(temp)
                if local_hour >= 9 and local_hour < 21:
                    # daytime max temperature
                    self.max[i].add(temp, idx)
                else:
                    # nighttime min temperature
                    self.min[i].add(temp, idx)
        for i in ('hum_in', 'hum_out', 'abs_pressure', 'rel_pressure'):
            value = data[i]
            if value is not None:
                self.ave[i].add(value)
                self.max[i].add(value, idx)
                self.min[i].add(value, idx)
        if 'illuminance' in data:
            self.has_illuminance = True
            for i in ('illuminance', 'uv'):
                value = data[i]
                if value is not None:
                    self.ave[i].add(value)
                    self.max[i].add(value, idx)

    def add_hourly(self, data):
        wind_ave = data['wind_ave']
        if wind_ave is not None:
            wind_dir = data['wind_dir']
            if wind_dir is not None:
                self.wind_dir[wind_dir] += wind_ave
            self.wind_acc += wind_ave
            self.wind_count += 1
        rain = data['rain']
        if rain is not None:
            self.rain += rain
        self.retval['idx'] = data['idx']

    def result(self):
        if not self.retval:
            return None
        if self.wind_count > 0:
            # convert weighted wind directions to a vector
            Ve = 0.0
            Vn = 0.0
            for dir in range(16):
                val = self.wind_dir[dir]
                Ve -= val * sin_LUT[dir]
                Vn -= val * cos_LUT[dir]
            # get direction of total vector
            dir_ave = (math.degrees(math.atan2(Ve, Vn)) + 180.0) * 16.0 / 360.0
            self.retval['wind_dir'] = int(dir_ave + 0.5) % 16
            wind_ave = self.wind_acc / float(self.wind_count)
            self.retval['wind_ave'] = wind_ave
        else:
            self.retval['wind_dir'] = None
            self.retval['wind_ave'] = None
        if self.wind_gust[1]:
            self.retval['wind_gust'] = self.wind_gust[0]
        else:
            self.retval['wind_gust'] = None
        self.retval['wind_gust_t'] = self.wind_gust[1]
        self.retval['rain'] = self.rain
        for i in ('temp_in', 'temp_out', 'hum_in', 'hum_out',
                  'abs_pressure', 'rel_pressure'):
            self.retval['%s_ave' % i] = self.ave[i].result()
            (self.retval['%s_max' % i],
             self.retval['%s_max_t' % i]) = self.max[i].result()
            (self.retval['%s_min' % i],
             self.retval['%s_min_t' % i]) = self.min[i].result()
        if self.has_illuminance:
            for i in ('illuminance', 'uv'):
                self.retval['%s_ave' % i] = self.ave[i].result()
                (self.retval['%s_max' % i],
                 self.retval['%s_max_t' % i]) = self.max[i].result()
        return self.retval

class MonthAcc(object):
    """'Accumulate' daily weather data to produce monthly summary.

    Compute daytime max & nighttime min temperatures.

    """
    def __init__(self, rain_day_threshold):
        self.rain_day_threshold = rain_day_threshold
        self.has_illuminance = False
        self.ave = {}
        self.min = {}
        self.max = {}
        self.min_lo = {}
        self.min_hi = {}
        self.min_ave = {}
        self.max_lo = {}
        self.max_hi = {}
        self.max_ave = {}
        self.wind_dir = list()
        for i in range(16):
            self.wind_dir.append(0.0)
        self.reset()

    def reset(self):
        for i in ('temp_in', 'temp_out'):
            self.ave[i] = Average()
            self.min_lo[i] = Minimum()
            self.min_hi[i] = Maximum()
            self.min_ave[i] = Average()
            self.max_lo[i] = Minimum()
            self.max_hi[i] = Maximum()
            self.max_ave[i] = Average()
        for i in ('hum_in', 'hum_out', 'abs_pressure', 'rel_pressure'):
            self.ave[i] = Average()
            self.max[i] = Maximum()
            self.min[i] = Minimum()
        for i in ('illuminance', 'uv'):
            self.ave[i] = Average()
            self.max_lo[i] = Minimum()
            self.max_hi[i] = Maximum()
            self.max_ave[i] = Average()
        for i in range(16):
            self.wind_dir[i] = 0.0
        self.wind_acc = 0.0
        self.wind_count = 0
        self.wind_gust = (-1.0, None)
        self.rain = 0.0
        self.rain_days = 0
        self.valid = False

    def add_daily(self, data):
        self.idx = data['idx']
        for i in ('temp_in', 'temp_out'):
            temp = data['%s_ave' % i]
            if temp is not None:
                self.ave[i].add(temp)
            temp = data['%s_min' % i]
            if temp is not None:
                self.min_lo[i].add(temp, data['%s_min_t' % i])
                self.min_hi[i].add(temp, data['%s_min_t' % i])
                self.min_ave[i].add(temp)
            temp = data['%s_max' % i]
            if temp is not None:
                self.max_lo[i].add(temp, data['%s_max_t' % i])
                self.max_hi[i].add(temp, data['%s_max_t' % i])
                self.max_ave[i].add(temp)
        for i in ('hum_in', 'hum_out', 'abs_pressure', 'rel_pressure'):
            value = data['%s_ave' % i]
            if value is not None:
                self.ave[i].add(value)
            value = data['%s_min' % i]
            if value is not None:
                self.min[i].add(value, data['%s_min_t' % i])
            value = data['%s_max' % i]
            if value is not None:
                self.max[i].add(value, data['%s_max_t' % i])
        wind_ave = data['wind_ave']
        if wind_ave is not None:
            wind_dir = data['wind_dir']
            if wind_dir is not None:
                self.wind_dir[wind_dir] += wind_ave
            self.wind_acc += wind_ave
            self.wind_count += 1
        wind_gust = data['wind_gust']
        if wind_gust is not None and wind_gust > self.wind_gust[0]:
            self.wind_gust = (wind_gust, data['wind_gust_t'])
        if 'illuminance_ave' in data:
            self.has_illuminance = True
            for i in ('illuminance', 'uv'):
                value = data['%s_ave' % i]
                if value is not None:
                    self.ave[i].add(value)
                value = data['%s_max' % i]
                if value is not None:
                    self.max_lo[i].add(value, data['%s_max_t' % i])
                    self.max_hi[i].add(value, data['%s_max_t' % i])
                    self.max_ave[i].add(value)
        self.rain += data['rain']
        if data['rain'] >= self.rain_day_threshold:
            self.rain_days += 1
        self.valid = True

    def result(self):
        if not self.valid:
            return None
        result = {}
        result['idx'] = self.idx
        result['rain'] = self.rain
        result['rain_days'] = self.rain_days
        for i in ('temp_in', 'temp_out'):
            result['%s_ave' % i] = self.ave[i].result()
            result['%s_min_ave' % i] = self.min_ave[i].result()
            (result['%s_min_lo' % i],
             result['%s_min_lo_t' % i]) = self.min_lo[i].result()
            (result['%s_min_hi' % i],
             result['%s_min_hi_t' % i]) = self.min_hi[i].result()
            result['%s_max_ave' % i] = self.max_ave[i].result()
            (result['%s_max_lo' % i],
             result['%s_max_lo_t' % i]) = self.max_lo[i].result()
            (result['%s_max_hi' % i],
             result['%s_max_hi_t' % i]) = self.max_hi[i].result()
        for i in ('hum_in', 'hum_out', 'abs_pressure', 'rel_pressure'):
            result['%s_ave' % i] = self.ave[i].result()
            (result['%s_max' % i],
             result['%s_max_t' % i]) = self.max[i].result()
            (result['%s_min' % i],
             result['%s_min_t' % i]) = self.min[i].result()
        if self.wind_count > 0:
            # convert weighted wind directions to a vector
            Ve = 0.0
            Vn = 0.0
            for dir in range(16):
                val = self.wind_dir[dir]
                Ve -= val * sin_LUT[dir]
                Vn -= val * cos_LUT[dir]
            # get direction of total vector
            dir_ave = (math.degrees(math.atan2(Ve, Vn)) + 180.0) * 16.0 / 360.0
            result['wind_dir'] = int(dir_ave + 0.5) % 16
            wind_ave = self.wind_acc / float(self.wind_count)
            result['wind_ave'] = wind_ave
        else:
            result['wind_dir'] = None
            result['wind_ave'] = None
        if self.wind_gust[1]:
            result['wind_gust'] = self.wind_gust[0]
        else:
            result['wind_gust'] = None
        result['wind_gust_t'] = self.wind_gust[1]
        if self.has_illuminance:
            for i in ('illuminance', 'uv'):
                result['%s_ave' % i] = self.ave[i].result()
                result['%s_max_ave' % i] = self.max_ave[i].result()
                (result['%s_max_lo' % i],
                 result['%s_max_lo_t' % i]) = self.max_lo[i].result()
                (result['%s_max_hi' % i],
                 result['%s_max_hi_t' % i]) = self.max_hi[i].result()
        return result

def calibrate_data(logger, params, raw_data, calib_data):
    """'Calibrate' raw data, using a user-supplied function."""
    start = calib_data.before(datetime.max)
    if start is None:
        start = datetime.min
    start = raw_data.after(start + SECOND)
    if start is None:
        return start
    del calib_data[start:]
    calibrator = Calib(params, raw_data)
    count = 0
    for data in raw_data[start:]:
        idx = data['idx']
        count += 1
        if count % 10000 == 0:
            logger.info("calib: %s", idx.isoformat(' '))
        elif count % 500 == 0:
            logger.debug("calib: %s", idx.isoformat(' '))
        calib_data[idx] = calibrator.calib(data)
    return start

def generate_hourly(logger, calib_data, hourly_data, process_from):
    """Generate hourly summaries from calibrated data."""
    start = hourly_data.before(datetime.max)
    if start is None:
        start = datetime.min
    start = calib_data.after(start + SECOND)
    if process_from:
        if start:
            start = min(start, process_from)
        else:
            start = process_from
    if start is None:
        return start
    # set start of hour in local time (not all time offsets are integer hours)
    start += STDOFFSET
    start = start.replace(minute=0, second=0)
    start -= STDOFFSET
    del hourly_data[start:]
    # preload pressure history, and find last valid rain
    prev = None
    pressure_history = deque()
    last_rain = None
    for data in calib_data[start - HOURx3:start]:
        if data['rel_pressure']:
            pressure_history.append((data['idx'], data['rel_pressure']))
        if data['rain'] is not None:
            last_rain = data['rain']
        prev = data
    # iterate over data in one hour chunks
    stop = calib_data.before(datetime.max)
    hour_start = start
    acc = HourAcc(last_rain)
    count = 0
    while hour_start <= stop:
        count += 1
        if count % 1008 == 0:
            logger.info("hourly: %s", hour_start.isoformat(' '))
        elif count % 24 == 0:
            logger.debug("hourly: %s", hour_start.isoformat(' '))
        hour_end = hour_start + HOUR
        acc.reset()
        for data in calib_data[hour_start:hour_end]:
            if data['rel_pressure']:
                pressure_history.append((data['idx'], data['rel_pressure']))
            if prev:
                err = data['idx'] - prev['idx']
                if abs(err - timedelta(minutes=data['delay'])) > TIME_ERR:
                    logger.info('unexpected data interval %s %s',
                                data['idx'].isoformat(' '), str(err))
            acc.add_raw(data)
            prev = data
        new_data = acc.result()
        if new_data and new_data['idx'].minute >= 9:
            # compute pressure trend
            new_data['pressure_trend'] = None
            if new_data['rel_pressure']:
                target = new_data['idx'] - HOURx3
                while (len(pressure_history) >= 2 and
                       abs(pressure_history[0][0] - target) >
                       abs(pressure_history[1][0] - target)):
                    pressure_history.popleft()
                if (pressure_history and
                        abs(pressure_history[0][0] - target) < HOUR):
                    new_data['pressure_trend'] = (
                        new_data['rel_pressure'] - pressure_history[0][1])
            # store new hourly data
            hourly_data[new_data['idx']] = new_data
        hour_start = hour_end
    return start

def generate_daily(logger, day_end_hour,
                   calib_data, hourly_data, daily_data, process_from):
    """Generate daily summaries from calibrated and hourly data."""
    start = daily_data.before(datetime.max)
    if start is None:
        start = datetime.min
    start = calib_data.after(start + SECOND)
    if process_from:
        if start:
            start = min(start, process_from)
        else:
            start = process_from
    if start is None:
        return start
    # round to start of this day, in local time
    start += STDOFFSET
    if start.hour < day_end_hour:
        start = start - DAY
    start = start.replace(hour=day_end_hour, minute=0, second=0)
    start -= STDOFFSET
    del daily_data[start:]
    stop = calib_data.before(datetime.max)
    day_start = start
    acc = DayAcc()
    count = 0
    while day_start <= stop:
        count += 1
        if count % 30 == 0:
            logger.info("daily: %s", day_start.isoformat(' '))
        else:
            logger.debug("daily: %s", day_start.isoformat(' '))
        day_end = day_start + DAY
        acc.reset()
        for data in calib_data[day_start:day_end]:
            acc.add_raw(data)
        for data in hourly_data[day_start:day_end]:
            acc.add_hourly(data)
        new_data = acc.result()
        if new_data:
            new_data['start'] = day_start
            daily_data[new_data['idx']] = new_data
        day_start = day_end
    return start

def generate_monthly(logger, rain_day_threshold, day_end_hour,
                     daily_data, monthly_data, process_from):
    """Generate monthly summaries from daily data."""
    start = monthly_data.before(datetime.max)
    if start is None:
        start = datetime.min
    start = daily_data.after(start + SECOND)
    if process_from:
        if start:
            start = min(start, process_from)
        else:
            start = process_from
    if start is None:
        return start
    # set start to start of first day of month (local time)
    start += STDOFFSET
    start = start.replace(day=1, hour=day_end_hour, minute=0, second=0)
    if day_end_hour >= 12:
        # month actually starts on the last day of previous month
        start -= DAY
    start -= STDOFFSET
    del monthly_data[start:]
    stop = daily_data.before(datetime.max)
    month_start = start
    acc = MonthAcc(rain_day_threshold)
    count = 0
    while month_start <= stop:
        count += 1
        if count % 12 == 0:
            logger.info("monthly: %s", month_start.isoformat(' '))
        else:
            logger.debug("monthly: %s", month_start.isoformat(' '))
        month_end = month_start + WEEK
        if month_end.month < 12:
            month_end = month_end.replace(month=month_end.month+1)
        else:
            month_end = month_end.replace(month=1, year=month_end.year+1)
        month_end = month_end - WEEK
        acc.reset()
        for data in daily_data[month_start:month_end]:
            acc.add_daily(data)
        new_data = acc.result()
        if new_data:
            new_data['start'] = month_start
            monthly_data[new_data['idx']] = new_data
        month_start = month_end
    return start

def Process(params,
            raw_data, calib_data, hourly_data, daily_data, monthly_data):
    """Generate summaries from raw weather station data.

    The meteorological day end (typically 2100 or 0900 local time) is
    set in the preferences file ``weather.ini``. The default value is
    2100 (2200 during DST), following the historical convention for
    weather station readings.

    """
    logger = logging.getLogger('pywws.Process')
    logger.info('Generating summary data')
    # get time of last record
    last_raw = raw_data.before(datetime.max)
    if last_raw is None:
        raise IOError('No data found. Check data directory parameter.')
    # get daytime end hour (in local time)
    day_end_hour = eval(params.get('config', 'day end hour', '21')) % 24
    # get other config
    rain_day_threshold = eval(params.get('config', 'rain day threshold', '0.2'))
    # calibrate raw data
    start = calibrate_data(logger, params, raw_data, calib_data)
    # generate hourly data
    start = generate_hourly(logger, calib_data, hourly_data, start)
    # generate daily data
    start = generate_daily(logger, day_end_hour,
                           calib_data, hourly_data, daily_data, start)
    # generate monthly data
    generate_monthly(logger, rain_day_threshold, day_end_hour,
                     daily_data, monthly_data, start)
    return 0

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "hv", ['help', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
        elif o in ('-v', '--verbose'):
            verbose += 1
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(verbose)
    data_dir = args[0]
    return Process(DataStore.params(data_dir),
                   DataStore.data_store(data_dir),
                   DataStore.calib_store(data_dir),
                   DataStore.hourly_store(data_dir),
                   DataStore.daily_store(data_dir),
                   DataStore.monthly_store(data_dir))

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Reprocess
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Regenerate hourly and daily summary data.

This script can also be run with the ``pywws-reprocess`` command. ::
%s
This program recreates the calibrated, hourly, daily and monthly
summary data that is created by the :py:mod:`pywws.Process` module. It
should be run whenever you upgrade to a newer version of pywws (if the
summary data format has changed), change your calibration module or
alter your pressure offset.

The ``-u`` (or ``--update``) option is a special case. It should be
used when upgrading from any pywws version earlier than 14.02.dev1143.
Unlike normal reprocessing, the ``-u`` option changes your raw data.
You are advised to backup your data before using the ``-u`` option.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: %s [options] data_dir
 options are:
  -h | --help     display this help
  -u | --update   update status on old data to include bits from wind_dir byte
  -v | --verbose  increase number of informative messages
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__ % ('python -m pywws.Reprocess')

import getopt
import logging
import os
import sys

from . import DataStore
from .Logger import ApplicationLogger
from . import Process

def Reprocess(data_dir, update):
    logger = logging.getLogger('pywws.Reprocess')
    raw_data = DataStore.data_store(data_dir)
    if update:
        # update old data to copy high nibble of wind_dir to status
        logger.warning("Updating status to include extra bits from wind_dir")
        count = 0
        for data in raw_data[:]:
            count += 1
            idx = data['idx']
            if count % 10000 == 0:
                logger.info("update: %s", idx.isoformat(' '))
            elif count % 500 == 0:
                logger.debug("update: %s", idx.isoformat(' '))
            if data['wind_dir'] is not None:
                if data['wind_dir'] >= 16:
                    data['status'] |= (data['wind_dir'] & 0xF0) << 4
                    data['wind_dir'] &= 0x0F
                    raw_data[idx] = data
                if data['status'] & 0x800:
                    data['wind_dir'] = None
                    raw_data[idx] = data
        raw_data.flush()
    # delete old format summary files
    logger.warning('Deleting old summaries')
    for summary in ['calib', 'hourly', 'daily', 'monthly']:
        for root, dirs, files in os.walk(
                os.path.join(data_dir, summary), topdown=False):
            logger.info(root)
            for file in files:
                os.unlink(os.path.join(root, file))
            os.rmdir(root)
    # create data summaries
    logger.warning('Generating hourly and daily summaries')
    params = DataStore.params(data_dir)
    calib_data = DataStore.calib_store(data_dir)
    hourly_data = DataStore.hourly_store(data_dir)
    daily_data = DataStore.daily_store(data_dir)
    monthly_data = DataStore.monthly_store(data_dir)
    Process.Process(
        params,
        raw_data, calib_data, hourly_data, daily_data, monthly_data)
    return 0

def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(
            argv[1:], "huv", ['help', 'update', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # process options
    update = False
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o in ('-u', '--update'):
            update = True
        elif o in ('-v', '--verbose'):
            verbose += 1
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, 'Error: 1 argument required\n'
        print >>sys.stderr, usage
        return 2
    logger = ApplicationLogger(verbose)
    data_dir = args[0]
    return Reprocess(data_dir, update)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = SetWeatherStation
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Set some weather station parameters.

This script can also be run with the ``pywws-setweatherstation`` command. ::
%s

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.SetWeatherStation [options]
 options are:
  -h   | --help           display this help
  -c   | --clock          set weather station clock to computer time
                          (unlikely to work)
  -p f | --pressure f     set relative pressure to f hPa
  -r n | --read_period n  set logging interval to n minutes
  -v   | --verbose        increase error message verbosity
  -z   | --zero_memory    clear the weather station logged reading count
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

from datetime import datetime, timedelta
import getopt
import logging
import sys
import time

from .Logger import ApplicationLogger
from . import WeatherStation

def bcd_encode(value):
    hi = value // 10
    lo = value % 10
    return (hi * 16) + lo
def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(
            argv[1:], "hcp:r:vz",
            ['help', 'clock', 'pressure=', 'read_period=',
             'verbose', 'zero_memory'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    clock = False
    pressure = None
    read_period = None
    verbose = 0
    zero_memory = False
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
        elif o in ('-c', '--clock'):
            clock = True
        elif o in ('-p', '--pressure'):
            pressure = int((float(a) * 10.0) + 0.5)
        elif o in ('-r', '--read_period'):
            read_period = int(a)
        elif o in ('-v', '--verbose'):
            verbose += 1
        elif o in ('-z', '--zero_memory'):
            zero_memory = True
    # check arguments
    if len(args) != 0:
        print >>sys.stderr, "Error: No arguments required"
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(verbose)
    # open connection to weather station
    ws = WeatherStation.weather_station()
    # set data to be sent to station
    data = []
    # set relative pressure
    if pressure:
        ptr = ws.fixed_format['rel_pressure'][0]
        data.append((ptr,   pressure % 256))
        data.append((ptr+1, pressure // 256))
    # set read period
    if read_period:
        data.append((ws.fixed_format['read_period'][0], read_period))
    # reset data count
    if zero_memory:
        ptr = ws.fixed_format['data_count'][0]
        data.append((ptr,   1))
        data.append((ptr+1, 0))
    # set clock
    if clock:
        print "Clock setting is not known to work on any model of weather station."
        print "If it works for you, please let Jim Easterbrook know."
        print "waiting for exact minute"
        now = datetime.now()
        if now.second >= 55:
            time.sleep(10)
            now = datetime.now()
        now += timedelta(minutes=1)
        ptr = ws.fixed_format['date_time'][0]
        data.append((ptr,   bcd_encode(now.year - 2000)))
        data.append((ptr+1, bcd_encode(now.month)))
        data.append((ptr+2, bcd_encode(now.day)))
        data.append((ptr+3, bcd_encode(now.hour)))
        data.append((ptr+4, bcd_encode(now.minute)))
        time.sleep(59 - now.second)
    # send it all in one go
    if data:
        ws.write_data(data)
if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Tasks
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Routines to perform common tasks such as plotting gaphs or uploading files."""

from __future__ import absolute_import

from collections import deque
from datetime import datetime, timedelta
import logging
import os
import shutil
import threading

from .calib import Calib
from . import Plot
from . import Template
from .TimeZone import STDOFFSET, Local
from .toservice import ToService
from . import Upload
from . import WindRose
from . import YoWindow

class RegularTasks(object):
    def __init__(self, params, status,
                 raw_data, calib_data, hourly_data, daily_data, monthly_data,
                 asynch=False):
        self.logger = logging.getLogger('pywws.Tasks.RegularTasks')
        self.params = params
        self.status = status
        self.raw_data = raw_data
        self.calib_data = calib_data
        self.hourly_data = hourly_data
        self.daily_data = daily_data
        self.monthly_data = monthly_data
        self.asynch = asynch
        self.flush = eval(self.params.get('config', 'frequent writes', 'False'))
        # get directories
        self.work_dir = self.params.get('paths', 'work', '/tmp/weather')
        self.template_dir = self.params.get(
            'paths', 'templates', os.path.expanduser('~/weather/templates/'))
        self.graph_template_dir = self.params.get(
            'paths', 'graph_templates', os.path.expanduser('~/weather/graph_templates/'))
        self.local_dir = self.params.get(
            'paths', 'local_files', os.path.expanduser('~/weather/results/'))
        # create calibration object
        self.calibrator = Calib(self.params, self.raw_data)
        # create templater object
        self.templater = Template.Template(
            self.params, self.status, self.calib_data, self.hourly_data,
            self.daily_data, self.monthly_data)
        # create plotter objects
        self.plotter = Plot.GraphPlotter(
            self.params, self.status, self.calib_data, self.hourly_data,
            self.daily_data, self.monthly_data, self.work_dir)
        self.roseplotter = WindRose.RosePlotter(
            self.params, self.status, self.calib_data, self.hourly_data,
            self.daily_data, self.monthly_data, self.work_dir)
        # create FTP uploader object
        self.uploader = Upload.Upload(self.params)
        self.uploads_directory = os.path.join(self.work_dir, 'uploads')
        if not os.path.isdir(self.uploads_directory):
            os.makedirs(self.uploads_directory)
        # delay creation of a Twitter object until we know it's needed
        self.twitter = None
        # create a YoWindow object
        self.yowindow = YoWindow.YoWindow(self.calib_data)
        # get daytime end hour, in UTC
        self.day_end_hour = eval(params.get('config', 'day end hour', '21'))
        self.day_end_hour = (self.day_end_hour - (STDOFFSET.seconds // 3600)) % 24
        # parse "cron" sections
        self.cron = {}
        for section in self.params._config.sections():
            if section.split()[0] != 'cron':
                continue
            import croniter
            self.cron[section] = croniter.croniter(
                self.params.get(section, 'format', ''))
            self.cron[section].get_prev()
            last_update = self.status.get_datetime('last update', section)
            if last_update:
                last_update = last_update + Local.utcoffset(last_update)
                while self.cron[section].get_current(datetime) <= last_update:
                    self.cron[section].get_next()
        # create service uploader objects
        self.services = {}
        for section in self.cron.keys() + [
                       'live', 'logged', 'hourly', '12 hourly', 'daily']:
            for name in eval(self.params.get(section, 'services', '[]')):
                if name not in self.services:
                    self.services[name] = ToService(
                        self.params, self.status, self.calib_data,
                        service_name=name)
            # check for deprecated syntax
            if self.params.get(section, 'twitter') not in (None, '[]'):
                self.logger.warning(
                    'Deprecated twitter entry in [%s]', section)
            if self.params.get(section, 'yowindow'):
                self.logger.warning(
                    'Deprecated yowindow entry in [%s]', section)
        # create queues for things to upload / send
        self.tweet_queue = deque()
        self.service_queue = {}
        for name in self.services:
            self.service_queue[name] = deque()
        self.uploads_queue = deque()
        # start asynchronous thread to do uploads
        if self.asynch:
            self.logger.info('Starting asynchronous thread')
            self.shutdown_thread = threading.Event()
            self.wake_thread = threading.Event()
            self.thread = threading.Thread(target=self._asynch_thread)
            self.thread.start()

    def stop_thread(self):
        if not self.asynch:
            return
        self.shutdown_thread.set()
        self.wake_thread.set()
        self.thread.join()
        self.logger.debug('Asynchronous thread terminated')

    def _asynch_thread(self):
        try:
            while not self.shutdown_thread.isSet():
                timeout = 600
                while True:
                    self.wake_thread.wait(timeout)
                    if not self.wake_thread.isSet():
                        # main thread has stopped putting things on the queue
                        break
                    self.wake_thread.clear()
                    timeout = 2
                self.logger.debug('Doing asynchronous tasks')
                self._do_queued_tasks()
        except Exception, ex:
            self.logger.exception(ex)

    def _do_queued_tasks(self):
        while self.tweet_queue:
            tweet = self.tweet_queue[0]
            self.logger.info("Tweeting")
            if not self.twitter.Upload(tweet):
                break
            self.tweet_queue.popleft()
        for name in self.service_queue:
            service = self.services[name]
            count = 0
            while self.service_queue[name]:
                timestamp, prepared_data = self.service_queue[name][0]
                if len(self.service_queue[name]) > 1 and service.catchup <= 0:
                    # don't send queued 'catchup' records
                    pass
                elif service.send_data(timestamp, prepared_data):
                    count += 1
                else:
                    break
                self.service_queue[name].popleft()
            if count > 0:
                service.logger.info('%d records sent', count)
        while self.uploads_queue:
            file = self.uploads_queue.popleft()
            targ = os.path.join(self.uploads_directory, os.path.basename(file))
            if os.path.exists(targ):
                os.unlink(targ)
            shutil.move(file, self.uploads_directory)
        self._do_uploads()

    def has_live_tasks(self):
        if self.cron:
            return True
        yowindow_file = self.params.get('live', 'yowindow')
        if yowindow_file:
            return True
        if self.params.get('live', 'twitter') not in (None, '[]'):
            return True
        for name in eval(self.params.get('live', 'services', '[]')):
            return True
        for template in eval(self.params.get('live', 'plot', '[]')):
            return True
        for template in eval(self.params.get('live', 'text', '[]')):
            return True
        return False

    def _parse_templates(self, section, option):
        for template in eval(self.params.get(section, option, '[]')):
            if isinstance(template, (list, tuple)):
                yield template
            else:
                yield template, ''

    def _do_common(self, sections, live_data=None):
        if self.asynch and not self.thread.isAlive():
            raise RuntimeError('Asynchronous thread terminated unexpectedly')
        for section in sections:
            yowindow_file = self.params.get(section, 'yowindow')
            if yowindow_file:
                self.yowindow.write_file(yowindow_file)
                break
        for section in sections:
            templates = self.params.get(section, 'twitter')
            if templates not in (None, '[]'):
                for template in eval(templates):
                    self.do_twitter(template)
        uploads = []
        local_files = []
        service_done = []
        for section in sections:
            for name in eval(self.params.get(section, 'services', '[]')):
                if name not in service_done:
                    self._do_service(name, live_data)
                    service_done.append(name)
            for template, flags in self._parse_templates(section, 'text'):
                if 'T' in flags:
                    self.do_twitter(template, live_data)
                    continue
                upload = self.do_template(template, live_data)
                if 'L' in flags:
                    if upload not in local_files:
                        local_files.append(upload)
                elif upload not in uploads:
                    uploads.append(upload)
            for template, flags in self._parse_templates(section, 'plot'):
                upload = self.do_plot(template)
                if not upload:
                    continue
                if 'L' in flags:
                    if upload not in local_files:
                        local_files.append(upload)
                elif upload not in uploads:
                    uploads.append(upload)
        if local_files:
            if not os.path.isdir(self.local_dir):
                os.makedirs(self.local_dir)
            for file in local_files:
                targ = os.path.join(
                    self.local_dir, os.path.basename(file))
                if os.path.exists(targ):
                    os.unlink(targ)
                shutil.move(file, self.local_dir)
        for file in uploads:
            self.uploads_queue.append(file)
        if self.asynch:
            self.wake_thread.set()
        else:
            self._do_queued_tasks()

    def _do_cron(self, live_data=None):
        if not self.cron:
            return
        # get timestamp of latest data
        if live_data:
            now = live_data['idx']
        else:
            now = self.calib_data.before(datetime.max)
        if not now:
            now = datetime.utcnow()
        # convert to local time
        local_now = now + Local.utcoffset(now)
        # get list of due sections
        sections = []
        for section in self.cron:
            if self.cron[section].get_current(datetime) > local_now:
                continue
            sections.append(section)
            while self.cron[section].get_current(datetime) <= local_now:
                self.cron[section].get_next()
        if not sections:
            return
        # do it!
        self._do_common(sections, live_data)
        for section in sections:
            self.status.set('last update', section, now.isoformat(' '))

    def do_live(self, data):
        calib_data = self.calibrator.calib(data)
        self._do_common(['live'], calib_data)
        self._do_cron(calib_data)

    def do_tasks(self):
        sections = ['logged']
        self.params.unset('logged', 'last update')
        now = self.calib_data.before(datetime.max)
        if now:
            now += timedelta(minutes=self.calib_data[now]['delay'])
        else:
            now = datetime.utcnow().replace(microsecond=0)
        threshold = (now + STDOFFSET).replace(minute=0, second=0) - STDOFFSET
        last_update = self.params.get_datetime('hourly', 'last update')
        if last_update:
            self.params.unset('hourly', 'last update')
            self.status.set('last update', 'hourly', last_update.isoformat(' '))
        last_update = self.status.get_datetime('last update', 'hourly')
        if (not last_update) or (last_update < threshold):
            # time to do hourly tasks
            sections.append('hourly')
            # set 12 hourly threshold
            threshold -= timedelta(hours=(threshold.hour - self.day_end_hour) % 12)
            last_update = self.params.get_datetime('12 hourly', 'last update')
            if last_update:
                self.params.unset('12 hourly', 'last update')
                self.status.set('last update', '12 hourly', last_update.isoformat(' '))
            last_update = self.status.get_datetime('last update', '12 hourly')
            if (not last_update) or (last_update < threshold):
                # time to do 12 hourly tasks
                sections.append('12 hourly')
            # set daily threshold
            threshold -= timedelta(hours=(threshold.hour - self.day_end_hour) % 24)
            last_update = self.params.get_datetime('daily', 'last update')
            if last_update:
                self.params.unset('daily', 'last update')
                self.status.set('last update', 'daily', last_update.isoformat(' '))
            last_update = self.status.get_datetime('last update', 'daily')
            if (not last_update) or (last_update < threshold):
                # time to do daily tasks
                sections.append('daily')
        self._do_common(sections)
        for section in sections:
            self.status.set('last update', section, now.isoformat(' '))
        self._do_cron()
        if self.flush or 'hourly' in sections:
            # save any unsaved data
            self.params.flush()
            self.status.flush()
            self.raw_data.flush()
            self.calib_data.flush()
            self.hourly_data.flush()
            self.daily_data.flush()
            self.monthly_data.flush()

    def _do_uploads(self):
        # get list of pending uploads
        uploads = []
        for name in os.listdir(self.uploads_directory):
            path = os.path.join(self.uploads_directory, name)
            if os.path.isfile(path):
                uploads.append(path)
        if not uploads:
            return True
        # upload files
        if not self.uploader.connect():
            return
        for path in uploads:
            if self.uploader.upload_file(path):
                os.unlink(path)
        self.uploader.disconnect()

    def _do_service(self, name, live_data):
        service = self.services[name]
        if len(self.service_queue[name]) >= 50:
            return
        for data in service.next_data(True, live_data):
            prepared_data = service.prepare_data(data)
            if not prepared_data:
                continue
            self.service_queue[name].append((data['idx'], prepared_data))
            if len(self.service_queue[name]) >= 50:
                break
        if self.asynch:
            self.wake_thread.set()

    def do_twitter(self, template, data=None):
        if not self.twitter:
            from . import ToTwitter
            self.twitter = ToTwitter.ToTwitter(self.params)
        self.logger.info("Templating %s", template)
        input_file = os.path.join(self.template_dir, template)
        tweet = self.templater.make_text(input_file, live_data=data)[:140]
        self.tweet_queue.append(tweet)
        if self.asynch:
            self.wake_thread.set()

    def do_plot(self, template):
        self.logger.info("Graphing %s", template)
        input_file = os.path.join(self.graph_template_dir, template)
        output_file = os.path.join(self.work_dir, os.path.splitext(template)[0])
        input_xml = Plot.GraphFileReader(input_file)
        if (input_xml.get_children(self.plotter.plot_name) and
                        self.plotter.DoPlot(input_xml, output_file) == 0):
            return output_file
        if (input_xml.get_children(self.roseplotter.plot_name) and
                        self.roseplotter.DoPlot(input_xml, output_file) == 0):
            return output_file
        self.logger.warning('nothing to graph in %s', input_file)
        return None

    def do_template(self, template, data=None):
        self.logger.info("Templating %s", template)
        input_file = os.path.join(self.template_dir, template)
        output_file = os.path.join(self.work_dir, template)
        self.templater.make_file(input_file, output_file, live_data=data)
        return output_file

########NEW FILE########
__FILENAME__ = Template
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Create text data file based on a template
::

%s

Introduction
------------

This is probably the most difficult to use module in the weather
station software collection. It generates text files based on a
"template" file plus the raw, hourly, daily & monthly weather station
data. The template processing goes beyond simple substitution of
values to include loops, jumps forwards or backwards in the data,
processing of the data and substitution of missing values.

A template file can be any sort of text file (plain text, xml, html,
etc.) to which "processing instructions" have been added. These
processing instructions are delimited by hash ('#') characters. They
are not copied to the output, but cause something else to happen:
either a data value is inserted or one of a limited number of other
actions is carried out.

Before writing your own template files, it might be useful to look at
some of the examples in the example_templates directory.

Processing instructions
-----------------------

Note that if the closing '#' of a processing instruction is the last
character on a line then the following line break is not outputted.
This makes templates easier to edit as you can have a separate line
for each processing instruction and still produce output with no line
breaks. If you want to output a line break after a processing
instruction, put a blank line immediately after it.

``##``
^^^^^^

output a single '#' character.

``#! comment text#``
^^^^^^^^^^^^^^^^^^^^

a comment, no output generated. ``comment text`` can be any text
without a line break.

``#monthly#``
^^^^^^^^^^^^^

switch to "monthly" summary data. The index is reset to the most
recent value.

``#daily#``
^^^^^^^^^^^

switch to "daily" summary data. The index is reset to the most recent
value.

``#hourly#``
^^^^^^^^^^^^

switch to "hourly" summary data. The index is reset to the most recent
value.

``#raw#``
^^^^^^^^^

switch to "raw" data. The index is reset to the most recent value.

.. versionchanged:: 11.09
   This now selects "calibrated" data. The directive name remains
   unchanged for backwards compatibility.

``#live#``
^^^^^^^^^^

switch to "live" data. If the template is processed in the ``[live]``
section of ``weather.ini`` this will select the most up-to-date
weather data, otherwise it will have the same effect as ``#raw#``. Any
``#jump#`` will go to "raw" data.

``#timezone name#``
^^^^^^^^^^^^^^^^^^^

convert all datetime values to time zone ``name`` before output.
Permitted values for name are ``utc`` or ``local``.

``#locale expr#``
^^^^^^^^^^^^^^^^^

switch use of 'locale' on or off, according to ``expr``. When locale
is on floating point numbers may use a comma as the decimal separator
instead of a point, depending on your localisation settings. Use
``"True"`` or ``"False"`` for expr.

``#roundtime expr#``
^^^^^^^^^^^^^^^^^^^^

switch time rounding on or off, according to ``expr``. When time
rounding is on, 30 seconds is added to each time value used. This is
useful if you are only printing out hours and minutes, e.g. with a
"%%H:%%M" format, and want time values such as 10:23:58 to appear as
"10:24". Use ``"True"`` or ``"False"`` for expr.

``#jump count#``
^^^^^^^^^^^^^^^^

jump ``count`` values. The data index is adjusted by ``count`` hours
or days. Negative values jump back in time.

It is a good idea to put jumps within a loop at the end, just before
the ``#endloop#`` instruction. The loop can then terminate cleanly if
it has run out of data.

``#goto date-time#``
^^^^^^^^^^^^^^^^^^^^

go to ``date-time``. The data index is adjusted to the record
immediately after ``date-time``. This can be in UTC or your local time
zone, according to the setting of ``timezone``, and must exactly match
the ISO date format, for example ``"2010-11-01 12:00:00"`` is noon on
1st November 2010.

Parts of ``date-time`` can be replaced with strftime style %% format
characters to specify the current loop index. For example,
``"%%Y-%%m-01 12:00:00"`` is noon on 1st of this month.

``#loop count#``
^^^^^^^^^^^^^^^^

start a loop that will repeat ``count`` times. ``count`` must be one
or more.

``#endloop#``
^^^^^^^^^^^^^

end a loop started by ``#loop count#``. The template processing will
go back to the line containing the ``#loop count#`` instruction. Don't
try to nest loops.

``#key fmt_string no_value_string conversion#``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

output a data value. ``key`` is the data key, e.g. ``temp_out`` for
outdoor temperature. ``fmt_string`` is a printf-like format string
(actually Python's %% operator) except for datetime values, when it is
input to datetime's ``strftime()`` method. ``no_value_string`` is
output instead of ``fmt_string`` when the data value is absent, e.g.
if the station lost contact with the outside sensor. ``conversion`` is
a Python expression to convert the data, e.g. to convert wind speed
from m/s to mph you could use ``"x * 3.6 / 1.609344"``, or the more
convenient provided function ``"wind_mph(x)"``. See the
:py:mod:`pywws.conversions` module for details of the available
functions.

All these values need double quotes " if they contain spaces or other
potentially difficult characters. All except ``key`` are optional, but
note that if you want to specify a conversion, you also need to
specify ``fmt_string`` and ``no_value_string``.

``#calc expression fmt_string no_value_string conversion#``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

output a value computed from one or more data items. ``expression`` is
any valid Python expression, e.g. ``"dew_point(data['temp_out'],
data['hum_out'])"`` to compute the outdoor dew point. ``fmt_string``,
``no_value_string`` and ``conversion`` are as described above. Note
that it is probably more efficient to incorporate any conversion into
expression.

In addition to the functions in the :py:mod:`pywws.conversions` module
there are three more useful functions: ``rain_hour(data)`` returns the
amount of rain in the last hour, ``rain_day(data)`` returns the amount
of rain since midnight (local time) and ``hour_diff(data, key)``
returns the change in data item ``key`` over the last hour.

Example
-------

Here is an example snippet showing basic and advanced use of the
template features. It is part of the 6hrs.txt example template file,
which generates an HTML table of 7 hourly readings (which should span
6 hours). ::

  #hourly#
  #jump -6#
  #loop 7#
    <tr>
      <td>#idx "%%Y/%%m/%%d" "" "[None, x][x.hour == 0 or loop_count == 7]"#</td>
      <td>#idx "%%H%%M %%Z"#</td>
      <td>#temp_out "%%.1f °C"#</td>
      <td>#hum_out "%%d%%%%"#</td>
      <td>#wind_dir "%%s" "-" "winddir_text(x)"#</td>
      <td>#wind_ave "%%.0f mph" "" "wind_mph(x)"#</td>
      <td>#wind_gust "%%.0f mph" "" "wind_mph(x)"#</td>
      <td>#rain "%%0.1f mm"#</td>
      <td>#rel_pressure "%%.0f hPa"#, #pressure_trend "%%s" "" "pressure_trend_text(x)"#</td>
    </tr>
  #jump 1#
  #endloop#

The first three lines of this snippet do the following: select hourly
data, jump back 6 hours, start a loop with a count of 7. A jump
forward of one hour appears just before the end of the repeated
segment. As this last jump (of one hour) happens each time round the
loop, a sequence of 7 data readings will be output. The last line
marks the end of the loop — everything between the ``#loop 7#`` and
``#endloop#`` lines is output 7 times.

The ``#temp_out ...#``, ``#hum_out ...#``, ``#rain ...#`` and
``#rel_pressure ...#`` instructions show basic data output. They each
use a ``fmt_string`` to format the data appropriately. The ``#wind_ave
...#`` and ``#wind_gust ...#`` instructions show how to use a
conversion expression to convert m/s to mph.

The ``#wind_dir ...#`` and ``#pressure_trend ...#`` instructions show
use of the built-in functions ``winddir_text`` and
``pressure_trend_text`` to convert numerical values into text.

Finally we get to datetime values. The ``#idx "%%H%%M"#`` instruction
simply outputs the time (in HHMM format) of the data's index. The
``#idx "%%Y/%%m/%%d" "" "[None, x][x.hour == 0 or loop_count == 7]"#``
instruction is a bit more complicated. It outputs the date, but only
on the first line or if the date has changed. It does this by indexing
the array ``[None, x]`` with a boolean expression that is true when
``loop_count`` is 7 (i.e. on the first pass through the loop) or
``x.hour`` is zero (i.e. this is the first hour of the day).

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.Template [options] data_dir template_file output_file
 options are:
  --help    display this help
 data_dir is the root directory of the weather data
 template_file is the template text source file
 output_file is the name of the text file to be created
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import codecs
from datetime import datetime, timedelta
import getopt
import locale
import logging
import os
import shlex
import sys

from . import conversions
from .conversions import *
from . import DataStore
from .Forecast import Zambretti, ZambrettiCode
from . import Localisation
from .Logger import ApplicationLogger
from .TimeZone import Local, utc

SECOND = timedelta(seconds=1)
HOUR = timedelta(hours=1)
DAY = timedelta(hours=24)

class Template(object):
    def __init__(self, params, status,
                 calib_data, hourly_data, daily_data, monthly_data,
                 use_locale=True):
        self.logger = logging.getLogger('pywws.Template')
        self.params = params
        self.status = status
        self.calib_data = calib_data
        self.hourly_data = hourly_data
        self.daily_data = daily_data
        self.monthly_data = monthly_data
        self.use_locale = use_locale
        self.midnight = None
        self.rain_midnight = None
        # get character encoding of template input & output
        self.encoding = params.get('config', 'template encoding', 'iso-8859-1')

    def process(self, live_data, template_file):
        def jump(idx, count):
            while count > 0:
                new_idx = data_set.after(idx + SECOND)
                if new_idx == None:
                    break
                idx = new_idx
                count -= 1
            while count < 0:
                new_idx = data_set.before(idx)
                if new_idx == None:
                    break
                idx = new_idx
                count += 1
            return idx, count == 0

        params = self.params
        if not live_data:
            idx = self.calib_data.before(datetime.max)
            if not idx:
                self.logger.error("No calib data - run Process.py first")
                return
            live_data = self.calib_data[idx]
        # get conversions module to create its 'private' wind dir text
        # array, then copy it to deprecated wind_dir_text variable
        winddir_text(0)
        wind_dir_text = conversions._winddir_text_array
        hour_diff = self._hour_diff
        rain_hour = self._rain_hour
        rain_day = self._rain_day
        pressure_offset = eval(self.params.get('config', 'pressure offset'))
        fixed_block = eval(self.status.get('fixed', 'fixed block'))
        # start off with no time rounding
        round_time = None
        # start off in hourly data mode
        data_set = self.hourly_data
        # start off in utc
        time_zone = utc
        # start off with default use_locale setting
        use_locale = self.use_locale
        # jump to last item
        idx, valid_data = jump(datetime.max, -1)
        if not valid_data:
            self.logger.error("No summary data - run Process.py first")
            return
        data = data_set[idx]
        # open template file, if not already a file(like) object
        if hasattr(template_file, 'readline'):
            tmplt = template_file
        elif sys.version_info[0] >= 3:
            tmplt = open(template_file, 'r', encoding=self.encoding)
        else:
            tmplt = open(template_file, 'r')
        # do the text processing
        while True:
            line = tmplt.readline()
            if line == '':
                break
            parts = line.split('#')
            for i in range(len(parts)):
                if i % 2 == 0:
                    # not a processing directive
                    if i == 0 or parts[i] != '\n':
                        yield parts[i]
                    continue
                if parts[i] and parts[i][0] == '!':
                    # comment
                    continue
                command = shlex.split(parts[i])
                if command == []:
                    # empty command == print a single '#'
                    yield '#'
                elif command[0] in data.keys() + ['calc']:
                    # output a value
                    if not valid_data:
                        continue
                    # format is: key fmt_string no_value_string conversion
                    # get value
                    if command[0] == 'calc':
                        x = eval(command[1])
                        del command[1]
                    else:
                        x = data[command[0]]
                    # adjust time
                    if isinstance(x, datetime):
                        if round_time:
                            x += round_time
                        x = x.replace(tzinfo=utc)
                        x = x.astimezone(time_zone)
                    # convert data
                    if x != None and len(command) > 3:
                        x = eval(command[3])
                    # get format
                    fmt = '%s'
                    if len(command) > 1:
                        fmt = command[1]
                    # write output
                    if x == None:
                        if len(command) > 2:
                            yield command[2]
                    elif isinstance(x, datetime):
                        yield x.strftime(fmt)
                    elif not use_locale:
                        yield fmt % (x)
                    elif sys.version_info >= (2, 7) or '%%' not in fmt:
                        yield locale.format_string(fmt, x)
                    else:
                        yield locale.format_string(
                            fmt.replace('%%', '##'), x).replace('##', '%')
                elif command[0] == 'monthly':
                    data_set = self.monthly_data
                    idx, valid_data = jump(datetime.max, -1)
                    data = data_set[idx]
                elif command[0] == 'daily':
                    data_set = self.daily_data
                    idx, valid_data = jump(datetime.max, -1)
                    data = data_set[idx]
                elif command[0] == 'hourly':
                    data_set = self.hourly_data
                    idx, valid_data = jump(datetime.max, -1)
                    data = data_set[idx]
                elif command[0] == 'raw':
                    data_set = self.calib_data
                    idx, valid_data = jump(datetime.max, -1)
                    data = data_set[idx]
                elif command[0] == 'live':
                    data_set = self.calib_data
                    idx = datetime.max
                    valid_data = True
                    data = live_data
                elif command[0] == 'timezone':
                    if command[1] == 'utc':
                        time_zone = utc
                    elif command[1] == 'local':
                        time_zone = Local
                    else:
                        self.logger.error("Unknown time zone: %s", command[1])
                        return
                elif command[0] == 'locale':
                    use_locale = eval(command[1])
                elif command[0] == 'roundtime':
                    if eval(command[1]):
                        round_time = timedelta(seconds=30)
                    else:
                        round_time = None
                elif command[0] == 'jump':
                    prevdata = data
                    idx, valid_data = jump(idx, int(command[1]))
                    data = data_set[idx]
                elif command[0] == 'goto':
                    prevdata = data
                    time_str = command[1]
                    if '%' in time_str:
                        lcl = idx.replace(tzinfo=utc).astimezone(time_zone)
                        time_str = lcl.strftime(time_str)
                    new_idx = DataStore.safestrptime(time_str)
                    new_idx = new_idx.replace(tzinfo=time_zone).astimezone(utc)
                    new_idx = data_set.after(new_idx.replace(tzinfo=None))
                    if new_idx:
                        idx = new_idx
                        data = data_set[idx]
                        valid_data = True
                    else:
                        valid_data = False
                elif command[0] == 'loop':
                    loop_count = int(command[1])
                    loop_start = tmplt.tell()
                elif command[0] == 'endloop':
                    loop_count -= 1
                    if valid_data and loop_count > 0:
                        tmplt.seek(loop_start, 0)
                else:
                    self.logger.error(
                        "Unknown processing directive: #%s#", parts[i])
                    return

    def make_text(self, template_file, live_data=None):
        result = ''
        for text in self.process(live_data, template_file):
            if sys.version_info[0] < 3 and isinstance(text, unicode):
                text = text.encode(self.encoding)
            result += text
        return result

    def make_file(self, template_file, output_file, live_data=None):
        if sys.version_info[0] >= 3:
            of = open(output_file, 'w', encoding=self.encoding)
        else:
            of = open(output_file, 'w')
        for text in self.process(live_data, template_file):
            if sys.version_info[0] < 3 and isinstance(text, unicode):
                text = text.encode(self.encoding)
            of.write(text)
        of.close()
        return 0

    def _hour_diff(self, data, key):
        hour_ago = self.calib_data[self.calib_data.nearest(data['idx'] - HOUR)]
        return data[key] - hour_ago[key]

    def _rain_hour(self, data):
        rain_hour = self.calib_data[self.calib_data.nearest(data['idx'] - HOUR)]['rain']
        return max(0.0, data['rain'] - rain_hour)

    def _rain_day(self, data):
        if not self.midnight:
            self.midnight = datetime.utcnow().replace(tzinfo=utc).astimezone(
                Local).replace(hour=0, minute=0, second=0).astimezone(
                    utc).replace(tzinfo=None)
        while data['idx'] < self.midnight:
            self.midnight -= DAY
            self.rain_midnight = None
        while data['idx'] >= self.midnight + DAY:
            self.midnight += DAY
            self.rain_midnight = None
        if self.rain_midnight is None:
            self.rain_midnight = self.calib_data[
                self.calib_data.nearest(self.midnight)]['rain']
        return max(0.0, data['rain'] - self.rain_midnight)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # check arguments
    if len(args) != 3:
        print >>sys.stderr, 'Error: 3 arguments required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    # process options
    for o, a in opts:
        if o == '--help':
            print __usage__.strip()
            return 0
    logger = ApplicationLogger(1)
    params = DataStore.params(args[0])
    status = DataStore.status(args[0])
    Localisation.SetApplicationLanguage(params)
    return Template(
        params, status,
        DataStore.calib_store(args[0]), DataStore.hourly_store(args[0]),
        DataStore.daily_store(args[0]), DataStore.monthly_store(args[0])
        ).make_file(args[1], args[2])

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = TestWeatherStation
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Test connection to weather station.

This script can also be run with the ``pywws-testweatherstation``
command. ::
%s
This is a simple utility to test communication with the weather
station. If this doesn't work, then there's a problem that needs to be
sorted out before trying any of the other programs. Likely problems
include not properly installing the USB libraries, or a permissions
problem. The most unlikely problem is that you forgot to connect the
weather station to your computer!

"""

from __future__ import absolute_import

__usage__ = """
 usage: %s [options]
 options are:
         --help       display this help
  -c   | --change     display any changes in "fixed block" data
  -d   | --decode     display meaningful values instead of raw data
  -h n | --history n  display the last "n" readings
  -l   | --live       display 'live' data
  -m   | --logged     display 'logged' data
  -u   | --unknown    display unknown fixed block values
  -v   | --verbose    increase amount of reassuring messages
                      (repeat for even more messages e.g. -vvv)
"""

__doc__ %= __usage__ % ('python -m pywws.TestWeatherStation')

import datetime
import getopt
import sys
import time

from .Logger import ApplicationLogger
from . import WeatherStation

def raw_dump(pos, data):
    print "%04x" % pos,
    for item in data:
        print "%02x" % item,
    print
def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(
            argv[1:], "cdh:lmuv",
            ('help', 'change', 'decode', 'history=', 'live', 'logged',
             'unknown', 'verbose'))
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # check arguments
    if len(args) != 0:
        print >>sys.stderr, 'Error: no arguments allowed\n'
        print >>sys.stderr, usage
        return 2
    # process options
    change = False
    history_count = 0
    decode = False
    live = False
    logged = False
    unknown = False
    verbose = 0
    for o, a in opts:
        if o == '--help':
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o in ('-c', '--change'):
            change = True
        elif o in ('-d', '--decode'):
            decode = True
        elif o in ('-h', '--history'):
            history_count = int(a)
        elif o in ('-l', '--live'):
            live = True
            logged = False
        elif o in ('-m', '--logged'):
            live = False
            logged = True
        elif o in ('-u', '--unknown'):
            unknown = True
        elif o in ('-v', '--verbose'):
            verbose += 1
    # do it!
    logger = ApplicationLogger(verbose)
    ws = WeatherStation.weather_station()
    raw_fixed = ws.get_raw_fixed_block()
    if not raw_fixed:
        print "No valid data block found"
        return 3
    if decode:
        # dump entire fixed block
        print ws.get_fixed_block()
        # dump a few selected items
        print "min -> temp_out ->", ws.get_fixed_block(['min', 'temp_out'])
        print "alarm -> hum_out ->", ws.get_fixed_block(['alarm', 'hum_out'])
        print "rel_pressure ->", ws.get_fixed_block(['rel_pressure'])
        print "abs_pressure ->", ws.get_fixed_block(['abs_pressure'])
    else:
        for ptr in range(0x0000, 0x0100, 0x20):
            raw_dump(ptr, raw_fixed[ptr:ptr+0x20])
    if unknown:
        for k in sorted(ws.fixed_format):
            if 'unk' in k:
                print k, ws.get_fixed_block([k])
        for k in sorted(ws.fixed_format):
            if 'settings' in k or 'display' in k or 'alarm' in k:
                bits = ws.get_fixed_block([k])
                for b in sorted(bits):
                    if 'bit' in b:
                        print k, b, bits[b]
    if history_count > 0:
        fixed_block = ws.get_fixed_block()
        print "Recent history"
        ptr = fixed_block['current_pos']
        date = datetime.datetime.now().replace(second=0, microsecond=0)
        for i in range(history_count):
            if decode:
                data = ws.get_data(ptr)
                print date, data
                date = date - datetime.timedelta(minutes=data['delay'])
            else:
                raw_dump(ptr, ws.get_raw_data(ptr))
            ptr = ws.dec_ptr(ptr)
    if change:
        while True:
            new_fixed = ws.get_raw_fixed_block(unbuffered=True)
            for ptr in range(len(new_fixed)):
                if new_fixed[ptr] != raw_fixed[ptr]:
                    print datetime.datetime.now().strftime('%H:%M:%S'),
                    print ' %04x (%d)  %02x -> %02x' % (
                        ptr, ptr, raw_fixed[ptr], new_fixed[ptr])
            raw_fixed = new_fixed
            time.sleep(0.5)
    if live:
        for data, ptr, logged in ws.live_data():
            print "%04x" % ptr,
            print data['idx'].strftime('%H:%M:%S'),
            del data['idx']
            print data
    if logged:
        for data, ptr, logged in ws.live_data(logged_only=True):
            print "%04x" % ptr,
            print data['idx'].strftime('%H:%M:%S'),
            del data['idx']
            print data
    del ws
    return 0
if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        pass

########NEW FILE########
__FILENAME__ = TimeZone
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-13  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Provide a couple of :py:class:`datetime.tzinfo` objects
representing local time and UTC.

Introduction
------------

This module provides two :py:class:`datetime.tzinfo` objects
representing UTC and local time zones. These are used to convert
timestamps to and from UTC and local time. The weather station
software stores data with UTC timestamps, to avoid problems with
daylight savings time, but the template and plot programs output data
with local times.

The module is copied directly from the :py:class:`datetime.tzinfo`
module documentation.

Detailed API
------------

"""

from datetime import tzinfo, timedelta, datetime
import sys
import time as _time

ZERO = timedelta(0)
HOUR = timedelta(hours=1)

class UTC(tzinfo):
    """UTC"""
    def utcoffset(self, dt):
        return ZERO
    def tzname(self, dt):
        return "UTC"
    def dst(self, dt):
        return ZERO
utc = UTC()

STDOFFSET = timedelta(seconds = -_time.timezone)
if _time.daylight:
    DSTOFFSET = timedelta(seconds = -_time.altzone)
else:
    DSTOFFSET = STDOFFSET
DSTDIFF = DSTOFFSET - STDOFFSET

class LocalTimezone(tzinfo):
    """Local time"""
    def utcoffset(self, dt):
        if self._isdst(dt):
            return DSTOFFSET
        else:
            return STDOFFSET
    def dst(self, dt):
        if self._isdst(dt):
            return DSTDIFF
        else:
            return ZERO
    def tzname(self, dt):
        return _time.tzname[self._isdst(dt)]
    def _isdst(self, dt):
        tt = (dt.year, dt.month, dt.day,
              dt.hour, dt.minute, dt.second,
              dt.weekday(), 0, -1)
        stamp = _time.mktime(tt)
        tt = _time.localtime(stamp)
        return tt.tm_isdst > 0
Local = LocalTimezone()

def main():
    print datetime.now(utc).strftime('%Y/%m/%d %H:%M %Z')
    print datetime.now(Local).strftime('%Y/%m/%d %H:%M %Z')

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = toservice
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Post weather update to services such as Weather Underground
::

%s

Introduction
------------

There are an increasing number of web sites around the world that
encourage amateur weather station owners to upload data over the
internet.

This module enables pywws to upload readings to these organisations.
It is highly customisable using configuration files. Each 'service'
requires a configuration file and one or two templates in
``pywws/services`` (that should not need to be edited by the user) and
a section in ``weather.ini`` containing user specific data such as
your site ID and password.

See :ref:`How to integrate pywws with various weather services
<guides-integration-other>` for details of the available services.

Configuration
-------------

If you haven't already done so, visit the organisation's web site and
create an account for your weather station. Make a note of any site ID
and password details you are given.

Stop any pywws software that is running and then run ``toservice`` to
create a section in ``weather.ini``::

    python -m pywws.toservice data_dir service_name

``service_name`` is the single word service name used by pywws, such
as ``metoffice``, ``data_dir`` is your weather data directory, as
usual.

Edit ``weather.ini`` and find the section corresponding to the service
name, e.g. ``[underground]``. Copy your site details into this
section, for example::

    [underground]
    password = secret
    station = ABCDEFG1A

Now you can test your configuration::

    python -m pywws.toservice -vvv data_dir service_name

This should show you the data string that is uploaded. Any failure
should generate an error message.

Upload old data
---------------

Now you can upload your last 7 days' data, if the service supports it.
Edit your ``status.ini`` file and remove the appropriate line from the
``last update`` section, then run ``toservice`` with the catchup
option::

    python -m pywws.toservice -cvv data_dir service_name

This may take 20 minutes or more, depending on how much data you have.

Add service(s) upload to regular tasks
--------------------------------------

Edit your ``weather.ini`` again, and add a list of services to the
``[live]``, ``[logged]``, ``[hourly]``, ``[12 hourly]`` or ``[daily]``
section, depending on how often you want to send data. For example::

    [live]
    twitter = []
    plot = []
    text = []
    services = ['underground_rf', 'cwop']

    [logged]
    twitter = []
    plot = []
    text = []
    services = ['metoffice', 'cwop']

    [hourly]
    twitter = []
    plot = []
    text = []
    services = ['underground']

Note that the ``[live]`` section is only used when running
:py:mod:`pywws.LiveLog`. It is a good idea to repeat any
service selected in ``[live]`` in the ``[logged]`` or ``[hourly]``
section in case you switch to running :py:mod:`pywws.Hourly`.

Restart your regular pywws program (:py:mod:`pywws.Hourly` or
:py:mod:`pywws.LiveLog`) and visit the appropriate web site to
see regular updates from your weather station.

API
---

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.toservice [options] data_dir service_name
 options are:
  -h or --help     display this help
  -c or --catchup  upload all data since last upload
  -v or --verbose  increase amount of reassuring messages
 data_dir is the root directory of the weather data
 service_name is the service to upload to, e.g. underground
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import base64
from ConfigParser import SafeConfigParser
from datetime import datetime, timedelta
import getopt
import logging
import os
import pkg_resources
import re
import socket
import sys
import urllib
import urllib2
import urlparse

from . import DataStore
from .Logger import ApplicationLogger
from . import Template
from . import __version__

PARENT_MARGIN = timedelta(minutes=2)

class ToService(object):
    """Upload weather data to weather services such as Weather
    Underground.

    """
    def __init__(self, params, status, calib_data, service_name):
        """

        :param params: pywws configuration.

        :type params: :class:`pywws.DataStore.params`
        
        :param status: pywws status store.

        :type status: :class:`pywws.DataStore.status`
        
        :param calib_data: 'calibrated' data.

        :type calib_data: :class:`pywws.DataStore.calib_store`

        :param service_name: name of service to upload to.

        :type service_name: string
    
        """
        self.logger = logging.getLogger('pywws.ToService(%s)' % service_name)
        self.params = params
        self.status = status
        self.data = calib_data
        self.service_name = service_name
        # 'derived' services such as 'underground_rf' share their
        # parent's config and templates
        config_section = self.service_name.split('_')[0]
        if config_section == self.service_name:
            self.parent = None
        else:
            self.parent = config_section
        self.old_response = None
        self.old_ex = None
        # set default socket timeout, so urlopen calls don't hang forever
        socket.setdefaulttimeout(30)
        # open params file
        service_params = SafeConfigParser()
        service_params.optionxform = str
        service_params.readfp(pkg_resources.resource_stream(
            'pywws', 'services/%s.ini' % (self.service_name)))
        # get URL
        self.server = service_params.get('config', 'url')
        parsed_url = urlparse.urlsplit(self.server)
        if parsed_url.scheme == 'aprs':
            self.send_data = self.aprs_send_data
            server, port = parsed_url.netloc.split(':')
            self.server = (server, int(port))
        else:
            self.send_data = self.http_send_data
            self.use_get = eval(service_params.get('config', 'use get'))
        # get fixed part of upload data
        self.fixed_data = dict()
        for name, value in service_params.items('fixed'):
            if value[0] == '*':
                value = self.params.get(config_section, value[1:], 'unknown')
            self.fixed_data[name] = value
        # create templater
        self.templater = Template.Template(
            self.params, self.status, self.data, self.data, None, None,
            use_locale=False)
        template_name = 'services/%s_template_%s.txt' % (
            config_section, self.params.get('config', 'ws type'))
        if not pkg_resources.resource_exists('pywws', template_name):
            template_name = 'services/%s_template_1080.txt' % (config_section)
        self.template_file = pkg_resources.resource_stream(
            'pywws', template_name)
        # get other parameters
        self.auth_type = service_params.get('config', 'auth_type')
        if self.auth_type == 'basic':
            user = self.params.get(config_section, 'user', 'unknown')
            password = self.params.get(config_section, 'password', 'unknown')
            self.auth = 'Basic %s' % base64.b64encode('%s:%s' % (user, password))
        self.catchup = eval(service_params.get('config', 'catchup'))
        self.expected_result = eval(service_params.get('config', 'result'))
        self.interval = eval(service_params.get('config', 'interval'))
        self.interval = max(self.interval, 40)
        self.interval = timedelta(seconds=self.interval)
        # move 'last update' from params to status
        last_update = self.params.get_datetime(self.service_name, 'last update')
        if last_update:
            self.params.unset(self.service_name, 'last update')
            self.status.set(
                'last update', self.service_name, last_update.isoformat(' '))
        # set timestamp of first data to upload
        self.next_update = datetime.utcnow() - timedelta(days=self.catchup)

    def prepare_data(self, data):
        """Prepare a weather data record.

        The :obj:`data` parameter contains the data to be encoded. It
        should be a 'calibrated' data record, as stored in
        :class:`pywws.DataStore.calib_store`. The relevant data items
        are extracted and converted to strings using a template, then
        merged with the station's "fixed" data.

        :param data: the weather data record.

        :type data: dict

        :return: dict.

        :rtype: string
        
        """
        # check we have external data
        if data['temp_out'] is None:
            return None
        # convert data
        prepared_data = eval(self.templater.make_text(self.template_file, data))
        self.template_file.seek(0)
        prepared_data.update(self.fixed_data)
        return prepared_data

    def aprs_send_data(self, timestamp, prepared_data):
        """Upload a weather data record using APRS.

        The :obj:`prepared_data` parameter contains the data to be uploaded.
        It should be a dictionary of string keys and string values.

        :param timestamp: the timestamp of the data to upload.

        :type timestamp: datetime

        :param prepared_data: the data to upload.

        :type prepared_data: dict

        :return: success status

        :rtype: bool

        """

        login = 'user %s pass %s vers pywws %s\n' % (
            prepared_data['designator'], prepared_data['passcode'], __version__)
        packet = '%s>APRS,TCPIP*:@%sz%s/%s_%s/%sg%st%sr%sP%sb%sh%s.pywws-%s\n' % (
            prepared_data['designator'],   prepared_data['idx'],
            prepared_data['latitude'],     prepared_data['longitude'],
            prepared_data['wind_dir'],     prepared_data['wind_ave'],
            prepared_data['wind_gust'],    prepared_data['temp_out'],
            prepared_data['rain_hour'],    prepared_data['rain_day'],
            prepared_data['rel_pressure'], prepared_data['hum_out'],
            __version__
            )
        self.logger.debug('packet: "%s"', packet)
        sock = socket.socket()
        try:
            sock.connect(self.server)
            try:
                response = sock.recv(4096)
                self.logger.debug('server software: %s', response.strip())
                sock.sendall(login)
                response = sock.recv(4096)
                self.logger.debug('server login ack: %s', response.strip())
                sock.sendall(packet)
                sock.shutdown(socket.SHUT_RDWR)
            finally:
                sock.close()
        except Exception, ex:
            e = str(ex)
            if e != self.old_ex:
                self.logger.error(e)
                self.old_ex = e
            return False
        self.set_last_update(timestamp)
        return True

    def http_send_data(self, timestamp, prepared_data):
        """Upload a weather data record using HTTP.

        The :obj:`prepared_data` parameter contains the data to be uploaded.
        It should be a dictionary of string keys and string values.

        :param timestamp: the timestamp of the data to upload.

        :type timestamp: datetime

        :param prepared_data: the data to upload.

        :type prepared_data: dict

        :return: success status

        :rtype: bool
        
        """
        coded_data = urllib.urlencode(prepared_data)
        self.logger.debug(coded_data)
        new_ex = self.old_ex
        extra_ex = []
        try:
            try:
                if self.use_get:
                    request = urllib2.Request('%s?%s' % (self.server, coded_data))
                else:
                    request = urllib2.Request(self.server, coded_data)
                if self.auth_type == 'basic':
                    request.add_header('Authorization', self.auth)
                wudata = urllib2.urlopen(request)
            except urllib2.HTTPError, ex:
                if ex.code != 400:
                    raise
                wudata = ex
            response = wudata.readlines()
            wudata.close()
            if len(response) == len(self.expected_result):
                for actual, expected in zip(response, self.expected_result):
                    if not re.match(expected, actual):
                        break
                else:
                    self.old_response = response
                    self.set_last_update(timestamp)
                    return True
            if response != self.old_response:
                for line in response:
                    self.logger.error(line.strip())
            self.old_response = response
        except urllib2.HTTPError, ex:
            new_ex = str(ex)
            extra_ex = str(ex.info()).split('\n')
            for line in ex.readlines():
                extra_ex.append(re.sub('<.+?>', '', line))
        except Exception, ex:
            new_ex = str(ex)
        if new_ex == self.old_ex:
            log = self.logger.debug
        else:
            log = self.logger.error
            self.old_ex = new_ex
        log(new_ex)
        for extra in extra_ex:
            extra = extra.strip()
            if extra:
                log(extra)
        return False

    def next_data(self, catchup, live_data):
        """Get weather data records to upload.

        This method returns either the most recent weather data
        record, or all records since the last upload, according to
        the value of :obj:`catchup`.

        :param catchup: ``True`` to get all records since last upload,
         or ``False`` to get most recent data only.

        :type catchup: boolean

        :param live_data: a current 'live' data record, or ``None``.

        :type live_data: dict

        :return: yields weather data records.

        :rtype: dict
        
        """
        last_update = self.status.get_datetime('last update', self.service_name)
        if last_update:
            self.next_update = max(self.next_update,
                                   last_update + self.interval)
        if catchup:
            start = self.next_update
        else:
            start = self.data.before(datetime.max)
        if live_data:
            stop = live_data['idx'] - self.interval
        else:
            stop = None
        for data in self.data[start:stop]:
            if data['idx'] >= self.next_update:
                self.next_update = data['idx'] + self.interval
                yield data
        if live_data and live_data['idx'] >= self.next_update:
            self.next_update = live_data['idx'] + self.interval
            yield live_data

    def set_last_update(self, timestamp):
        self.status.set(
            'last update', self.service_name, timestamp.isoformat(' '))
        if self.parent:
            last_update = self.status.get_datetime('last update', self.parent)
            if last_update and last_update >= timestamp - PARENT_MARGIN:
                self.status.set('last update', self.parent,
                                (timestamp + PARENT_MARGIN).isoformat(' '))

    def Upload(self, catchup=True, live_data=None):
        """Upload one or more weather data records.

        This method uploads either the most recent weather data
        record, or all records since the last upload (up to 7 days),
        according to the value of :obj:`catchup`.

        It sets the ``last update`` configuration value to the time
        stamp of the most recent record successfully uploaded.

        :param catchup: upload all data since last upload.

        :type catchup: bool

        :return: success status

        :rtype: bool
        
        """
        count = 0
        for data in self.next_data(catchup, live_data):
            prepared_data = self.prepare_data(data)
            if not prepared_data:
                continue
            if not self.send_data(data['idx'], prepared_data):
                return False
            count += 1
        if count > 1:
            self.logger.info('%d records sent', count)
        return True

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(
            argv[1:], "hcv", ['help', 'catchup', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    catchup = False
    verbose = 0
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
        elif o == '-c' or o == '--catchup':
            catchup = True
        elif o == '-v' or o == '--verbose':
            verbose += 1
    # check arguments
    if len(args) != 2:
        print >>sys.stderr, "Error: 2 arguments required"
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(verbose)
    return ToService(
        DataStore.params(args[0]), DataStore.status(args[0]),
        DataStore.calib_store(args[0]), args[1]).Upload(catchup=catchup)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = ToTwitter
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Post a message to Twitter
::

%s

This module posts a brief message to `Twitter
<https://twitter.com/>`_. Before posting to Twitter you need to set up
an account and then authorise pywws by running the
:py:mod:`TwitterAuth` program. See :doc:`../guides/twitter` for
detailed instructions.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.ToTwitter [options] data_dir file
 options are:
  -h | --help  display this help
 data_dir is the root directory of the weather data
 file is the text file to be uploaded
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import codecs
import getopt
import logging
import sys

twitter = None
tweepy = None
try:
    import twitter
except ImportError:
    import tweepy

from .constants import Twitter as pct
from . import DataStore
from . import Localisation
from .Logger import ApplicationLogger

class TweepyHandler(object):
    def __init__(self, key, secret, latitude, longitude):
        auth = tweepy.OAuthHandler(pct.consumer_key, pct.consumer_secret)
        auth.set_access_token(key, secret)
        self.api = tweepy.API(auth)
        if latitude is not None and longitude is not None:
            self.kwargs = {'lat' : latitude, 'long' : longitude}
        else:
            self.kwargs = {}

    def post(self, status, media):
        if media:
            self.api.update_with_media(media, status[:117], **self.kwargs)
        else:
            self.api.update_status(status[:140], **self.kwargs)

class PythonTwitterHandler(object):
    def __init__(self, key, secret, latitude, longitude):
        self.api = twitter.Api(
            consumer_key=pct.consumer_key,
            consumer_secret=pct.consumer_secret,
            access_token_key=key, access_token_secret=secret)
        if latitude is not None and longitude is not None:
            self.kwargs = {'latitude' : latitude, 'longitude' : longitude}
        else:
            self.kwargs = {}

    def post(self, status, media):
        if media:
            self.api.PostMedia(status[:117], media, **self.kwargs)
        else:
            self.api.PostUpdate(status[:140], **self.kwargs)

class ToTwitter(object):
    def __init__(self, params):
        self.logger = logging.getLogger('pywws.ToTwitter')
        self.old_ex = None
        # get character encoding of template output
        self.encoding = params.get('config', 'template encoding', 'iso-8859-1')
        # get parameters
        key = params.get('twitter', 'key')
        secret = params.get('twitter', 'secret')
        if (not key) or (not secret):
            raise RuntimeError('Authentication data not found')
        latitude = params.get('twitter', 'latitude')
        longitude = params.get('twitter', 'longitude')
        # open API
        if twitter:
            self.api = PythonTwitterHandler(key, secret, latitude, longitude)
        else:
            self.api = TweepyHandler(key, secret, latitude, longitude)

    def Upload(self, tweet):
        if not tweet:
            return True
        if tweet.startswith('media'):
            media, tweet = tweet.split('\n', 1)
            media = media.split()[1]
        else:
            media = None
        if not isinstance(tweet, unicode):
            tweet = tweet.decode(self.encoding)
        try:
            self.api.post(tweet, media)
            return True
        except Exception, ex:
            e = str(ex)
            if 'is a duplicate' in e:
                return True
            if e != self.old_ex:
                self.logger.error(e)
                self.old_ex = e
        return False

    def UploadFile(self, file):
        tweet_file = codecs.open(file, 'r', encoding=self.encoding)
        tweet = tweet_file.read()
        tweet_file.close()
        return self.Upload(tweet)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 2:
        print >>sys.stderr, "Error: 2 arguments required"
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(1)
    params = DataStore.params(args[0])
    Localisation.SetApplicationLanguage(params)
    if ToTwitter(params).UploadFile(args[1]):
        return 0
    return 3

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = TwitterAuth
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Authorise pywws to post to your Twitter account
::

%s

This program authorises :py:mod:`pywws.ToTwitter` to post to a Twitter
account. You need to create an account before running
:py:mod:`TwitterAuth`. It opens a web browser window (or gives you a
URL to copy to your web browser) where you log in to your Twitter
account. If the login is successful the browser will display a 7 digit
number which you then copy to :py:mod:`TwitterAuth`.

See :doc:`../guides/twitter` for more detail on using Twitter with
pywws.

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.TwitterAuth [options] data_dir
 options are:
  -h or --help       display this help
 data_dir is the root directory of the weather data
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import getopt
import oauth2 as oauth
import sys
import urlparse
import webbrowser

from .constants import Twitter
from . import DataStore

def TwitterAuth(params):
    consumer = oauth.Consumer(Twitter.consumer_key, Twitter.consumer_secret)
    client = oauth.Client(consumer)
    # step 1 - obtain a request token
    resp, content = client.request(
        'https://api.twitter.com/oauth/request_token', 'POST')
    if resp['status'] != '200':
        print 'Failed to get request token. [%s]' % resp['status']
        return 1
    request_token = dict(urlparse.parse_qsl(content))
    # step 2 - redirect the user
    redirect_url = 'https://api.twitter.com/oauth/authorize?oauth_token=%s' % (
        request_token['oauth_token'])
    if not webbrowser.open(redirect_url, new=2, autoraise=0):
        print 'Please use a web browser to open the following URL'
        print redirect_url
    pin = raw_input('Please enter the PIN shown in your web browser: ').strip()
    # step 3 - convert the request token to an access token
    token = oauth.Token(
        request_token['oauth_token'], request_token['oauth_token_secret'])
    token.set_verifier(pin)
    client = oauth.Client(consumer, token)
    resp, content = client.request(
        'https://api.twitter.com/oauth/access_token', 'POST')
    if resp['status'] != '200':
        print 'Failed to get access token. [%s]' % resp['status']
        return 1
    access_token = dict(urlparse.parse_qsl(content))
    params.set('twitter', 'key', access_token['oauth_token'])
    params.set('twitter', 'secret', access_token['oauth_token_secret'])
    print 'Success! Authorisation data has been stored in %s' % params._path
    return 0

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 1:
        print >>sys.stderr, "Error: 1 argument required"
        print >>sys.stderr, __usage__.strip()
        return 2
    return TwitterAuth(DataStore.params(args[0]))

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = Upload
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Upload files to a web server by ftp or copy them to a local directory
::

%s

Introduction
------------

This module uploads files to (typically) a website *via* ftp/sftp or
copies files to a local directory (e.g. if you are running pywws on
the your web server). Details of the upload destination are stored in
the file ``weather.ini`` in your data directory. The only way to set
these details is to edit the file. Run :py:mod:`pywws.Upload` once to
set the default values, which you can then change. Here is what you're
likely to find when you edit ``weather.ini``::

  [ftp]
  secure = False
  directory = public_html/weather/data/
  local site = False
  password = secret
  site = ftp.username.your_isp.co.uk
  user = username

These are, I hope, fairly obvious. The ``local site`` option lets you
switch from uploading to a remote site to copying to a local site. If
you set ``local site = True`` then you can delete the ``secure``,
``site``, ``user`` and ``password`` lines.

``directory`` is the name of a directory in which all the uploaded
files will be put. This will depend on the structure of your web site
and the sort of host you use. Your hosting provider should be able to
tell you what ``site`` and ``user`` details to use. You should have
already chosen a ``password``.

The ``secure`` option lets you switch from normal ftp to sftp (ftp
over ssh). Some hosting providers offer this as a more secure upload
mechanism, so you should probably use it if available.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.Upload [options] data_dir file [file...]
 options are:
  -h or --help    display this help
 data_dir is the root directory of the weather data
 file is a file to be uploaded

Login and ftp site details are read from the weather.ini file in
data_dir.
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import getopt
import logging
import os
import shutil
import sys

from . import DataStore
from .Logger import ApplicationLogger

class _ftp(object):
    def __init__(self, logger, site, user, password, directory, port):
        global ftplib
        import ftplib
        self.logger = logger
        self.site = site
        self.user = user
        self.password = password
        self.directory = directory
        self.port = port

    def connect(self):
        self.logger.info("Uploading to web site with FTP")
        self.ftp = ftplib.FTP()
        self.ftp.connect(self.site, self.port)
        self.ftp.login(self.user, self.password)
        self.logger.debug(self.ftp.getwelcome())
        self.ftp.cwd(self.directory)

    def put(self, src, dest):
        text_file = os.path.splitext(src)[1] in ('.txt', '.xml', '.html')
        if text_file and sys.version_info[0] < 3:
            f = open(src, 'r')
        else:
            f = open(src, 'rb')
        if text_file:
            self.ftp.storlines('STOR %s' % (dest), f)
        else:
            self.ftp.storbinary('STOR %s' % (dest), f)
        f.close()

    def close(self):
        self.ftp.close()

class _sftp(object):
    def __init__(self, logger, site, user, password, directory, port):
        global paramiko
        import paramiko
        self.logger = logger
        self.site = site
        self.user = user
        self.password = password
        self.directory = directory
        self.port = port

    def connect(self):
        self.logger.info("Uploading to web site with SFTP")
        self.transport = paramiko.Transport((self.site, self.port))
        self.transport.connect(username=self.user, password=self.password)
        self.ftp = paramiko.SFTPClient.from_transport(self.transport)
        self.ftp.chdir(self.directory)

    def put(self, src, dest):
        self.ftp.put(src, dest)

    def close(self):
        self.ftp.close()
        self.transport.close()

class _copy(object):
    def __init__(self, logger, directory):
        self.logger = logger
        self.directory = directory

    def connect(self):
        self.logger.info("Copying to local directory")
        if not os.path.isdir(self.directory):
            os.makedirs(self.directory)

    def put(self, src, dest):
        shutil.copy2(src, os.path.join(self.directory, dest))

    def close(self):
        pass

class Upload(object):
    def __init__(self, params):
        self.logger = logging.getLogger('pywws.Upload')
        self.params = params
        self.old_ex = None
        if eval(self.params.get('ftp', 'local site', 'False')):
            # copy to local directory
            directory = self.params.get(
                'ftp', 'directory',
                os.path.expanduser('~/public_html/weather/data/'))
            self.uploader = _copy(self.logger, directory)
        else:
            # get remote site details
            site = self.params.get('ftp', 'site', 'ftp.username.your_isp.co.uk')
            user = self.params.get('ftp', 'user', 'username')
            password = self.params.get('ftp', 'password', 'secret')
            directory = self.params.get(
                'ftp', 'directory', 'public_html/weather/data/')
            if eval(self.params.get('ftp', 'secure', 'False')):
                port = eval(self.params.get('ftp', 'port', '22'))
                self.uploader = _sftp(
                    self.logger, site, user, password, directory, port)
            else:
                port = eval(self.params.get('ftp', 'port', '21'))
                self.uploader = _ftp(
                    self.logger, site, user, password, directory, port)

    def connect(self):
        try:
            self.uploader.connect()
        except Exception, ex:
            e = str(ex)
            if e == self.old_ex:
                self.logger.debug(e)
            else:
                self.logger.error(e)
                self.old_ex = e
            return False
        return True

    def upload_file(self, file):
        target = os.path.basename(file)
        try:
            self.uploader.put(file, target)
            return True
        except Exception, ex:
            e = str(ex)
            if e == self.old_ex:
                self.logger.debug(e)
            else:
                self.logger.error(e)
                self.old_ex = e
        return False

    def disconnect(self):
        self.uploader.close()

    def upload(self, files):
        if not self.connect():
            return False
        OK = True
        for file in files:
            if not self.upload_file(file):
                OK = False
                break
        self.disconnect()
        return OK

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) < 2:
        print >>sys.stderr, "Error: at least 2 arguments required"
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(1)
    if Upload(DataStore.params(args[0])).upload(args[1:]):
        return 0
    return 3

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = USBQualityTest
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Test quality of USB connection to weather station

::

%s

The USB link to my weather station is not 100%% reliable. The data
read from the station by the computer is occasionally corrupted,
perhaps by interference. I've been trying to solve this by putting
ferrite beads around the USB cable and relocating possible
interference sources such as external hard drives. All without any
success so far.

This program tests the USB connection for errors by continuously
reading the entire weather station memory (except for those parts that
may be changing) looking for errors. Each 32-byte block is read twice,
and if the two readings differ a warning message is displayed. Also
displayed are the number of blocks read, and the number of errors
found.

I typically get one or two errors per hour, so the test needs to be
run for several hours to produce a useful measurement. Note that other
software that accesses the weather station (such as
:py:mod:`pywws.Hourly` or :py:mod:`pywws.LiveLog`)
must not be run while the test is in progress.

If you run this test and get no errors at all, please let me know.
There is something good about your setup and I'd love to know what it
is!

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"

__usage__ = """
 usage: python -m pywws.USBQualityTest [options]
 options are:
  -h | --help           display this help
  -v | --verbose        increase amount of reassuring messages
                        (repeat for even more messages e.g. -vvv)
"""

__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import getopt
import sys

from .Logger import ApplicationLogger
from . import WeatherStation

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "hv", ('help', 'verbose'))
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # check arguments
    if len(args) != 0:
        print >>sys.stderr, 'Error: no arguments allowed\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    # process options
    verbose = 0
    for o, a in opts:
        if o in ('-h', '--help'):
            print __usage__.strip()
            return 0
        elif o in ('-v', '--verbose'):
            verbose += 1
    # do it!
    logger = ApplicationLogger(verbose)
    ws = WeatherStation.weather_station()
    fixed_block = ws.get_fixed_block()
    if not fixed_block:
        print "No valid data block found"
        return 3
    # loop
    ptr = ws.data_start
    total_count = 0
    bad_count = 0
    while True:
        if total_count % 1000 == 0:
            active = ws.current_pos()
        while True:
            ptr += 0x20
            if ptr >= 0x10000:
                ptr = ws.data_start
            if active < ptr - 0x10 or active >= ptr + 0x20:
                break
        result_1 = ws._read_block(ptr, retry=False)
        result_2 = ws._read_block(ptr, retry=False)
        if result_1 != result_2:
            logger.warning('read_block changing %06x', ptr)
            logger.warning('  %s', str(result_1))
            logger.warning('  %s', str(result_2))
            bad_count += 1
        total_count += 1
        print "\r %d/%d " % (bad_count, total_count),
        sys.stdout.flush()
    print ''
    return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        pass

########NEW FILE########
__FILENAME__ = version
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Display pywws version information.

This script can also be run with the ``pywws-version`` command. ::
%s

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: %s [options]
 options are:
  -h      or --help      display this help
  -v      or --verbose   show verbose version information
"""
__doc__ %= __usage__ % ('python -m pywws.version')

import getopt
import os
from pkg_resources import resource_filename
import sys

from . import __version__, _commit

def main(argv=None):
    if argv is None:
        argv = sys.argv
    usage = (__usage__ % (argv[0])).strip()
    try:
        opts, args = getopt.getopt(argv[1:], "hv", ['help', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, usage
        return 1
    # process options
    verbose = False
    for o, a in opts:
        if o in ('-h', '--help'):
            print __doc__.split('\n\n')[0]
            print usage
            return 0
        elif o in ('-v', '--verbose'):
            verbose = True
    # check arguments
    if len(args) != 0:
        print >>sys.stderr, 'Error: no arguments permitted\n'
        print >>sys.stderr, usage
        return 2
    print __version__
    if verbose:
        print 'commit:', _commit
        print 'Python:', sys.version
        try:
            from .WeatherStation import USBDevice
            print 'USB:   ', USBDevice.__module__
        except ImportError:
            print 'USB:    missing'
        example_dir = resource_filename('pywws', 'examples')
        if os.path.exists(example_dir):
            print 'examples:'
            print '  ', example_dir
        doc_index = resource_filename('pywws', 'doc/index.html')
        if os.path.exists(doc_index):
            doc_index = 'file://%s' % doc_index
        else:
            doc_index = 'http://jim-easterbrook.github.com/pywws/'
        print 'docs:'
        print '  ', doc_index
    return 0

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = WeatherStation
# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Get data from WH1080/WH3080 compatible weather stations.

Derived from wwsr.c by Michael Pendec (michael.pendec@gmail.com),
wwsrdump.c by Svend Skafte (svend@skafte.net), modified by Dave Wells,
and other sources.

Introduction
------------

This is the module that actually talks to the weather station base
unit. I don't have much understanding of USB, so copied a lot from
Michael Pendec's C program wwsr.

The weather station memory has two parts: a "fixed block" of 256 bytes
and a circular buffer of 65280 bytes. As each weather reading takes 16
bytes the station can store 4080 readings, or 14 days of 5-minute
interval readings. (The 3080 type stations store 20 bytes per reading,
so store a maximum of 3264.) As data is read in 32-byte chunks, but
each weather reading is 16 or 20 bytes, a small cache is used to
reduce USB traffic. The caching behaviour can be over-ridden with the
``unbuffered`` parameter to ``get_data`` and ``get_raw_data``.

Decoding the data is controlled by the static dictionaries
``_reading_format``, ``lo_fix_format`` and ``fixed_format``. The keys
are names of data items and the values can be an ``(offset, type,
multiplier)`` tuple or another dictionary. So, for example, the
_reading_format dictionary entry ``'rain' : (13, 'us', 0.3)`` means
that the rain value is an unsigned short (two bytes), 13 bytes from
the start of the block, and should be multiplied by 0.3 to get a
useful value.

The use of nested dictionaries in the ``fixed_format`` dictionary
allows useful subsets of data to be decoded. For example, to decode
the entire block ``get_fixed_block`` is called with no parameters::

  ws = WeatherStation.weather_station()
  print ws.get_fixed_block()

To get the stored minimum external temperature, ``get_fixed_block`` is
called with a sequence of keys::

  ws = WeatherStation.weather_station()
  print ws.get_fixed_block(['min', 'temp_out', 'val'])

Often there is no requirement to read and decode the entire fixed
block, as its first 64 bytes contain the most useful data: the
interval between stored readings, the buffer address where the current
reading is stored, and the current date & time. The
``get_lo_fix_block`` method provides easy access to these.

For more examples of using the WeatherStation module, see the
TestWeatherStation program.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"

from datetime import datetime
import logging
import sys
import time

from . import Localisation
USBDevice = None
if not USBDevice:
    try:
        from .device_pyusb1 import USBDevice
    except ImportError:
        pass
if not USBDevice:
    try:
        from .device_pyusb import USBDevice
    except ImportError:
        pass
if not USBDevice:
    try:
        from .device_ctypes_hidapi import USBDevice
    except ImportError:
        pass
if not USBDevice:
    try:
        from .device_cython_hidapi import USBDevice
    except ImportError:
        pass
if not USBDevice:
    raise ImportError('No USB library found')

def decode_status(status):
    result = {}
    for key, mask in (('invalid_wind_dir', 0x800),
                      ('rain_overflow',    0x080),
                      ('lost_connection',  0x040),
                      ('unknown',          0x73f),
                      ):
        result[key] = status & mask
    return result

# decode weather station raw data formats
def _plain_byte(raw, offset):
    return raw[offset]

def _unsigned_byte(raw, offset):
    res = raw[offset]
    if res == 0xFF:
        return None
    return res

def _signed_byte(raw, offset):
    res = raw[offset]
    if res == 0xFF:
        return None
    if res >= 128:
        return 128 - res
    return res

def _unsigned_short(raw, offset):
    lo = raw[offset]
    hi = raw[offset+1]
    if lo == 0xFF and hi == 0xFF:
        return None
    return (hi * 256) + lo

def _signed_short(raw, offset):
    lo = raw[offset]
    hi = raw[offset+1]
    if lo == 0xFF and hi == 0xFF:
        return None
    if hi >= 128:
        return ((128 - hi) * 256) - lo
    return (hi * 256) + lo

def _unsigned_int3(raw, offset):
    lo = raw[offset]
    md = raw[offset+1]
    hi = raw[offset+2]
    if lo == 0xFF and md == 0xFF and hi == 0xFF:
        return None
    return (hi * 256 * 256) + (md * 256) + lo

def _bcd_decode(byte):
    hi = (byte // 16) & 0x0F
    lo = byte & 0x0F
    return (hi * 10) + lo

def _date_time(raw, offset):
    year = _bcd_decode(raw[offset])
    month = _bcd_decode(raw[offset+1])
    day = _bcd_decode(raw[offset+2])
    hour = _bcd_decode(raw[offset+3])
    minute = _bcd_decode(raw[offset+4])
    return '%4d-%02d-%02d %02d:%02d' % (year + 2000, month, day, hour, minute)

def _time(raw, offset):
    hour = _bcd_decode(raw[offset])
    minute = _bcd_decode(raw[offset+1])
    return '%02d:%02d' % (hour, minute)

def _wind_ave(raw, offset):
    # wind average - 12 bits split across a byte and a nibble
    result = raw[offset] + ((raw[offset+2] & 0x0F) << 8)
    if result == 0xFFF:
        result = None
    return result

def _wind_gust(raw, offset):
    # wind gust - 12 bits split across a byte and a nibble
    result = raw[offset] + ((raw[offset+1] & 0xF0) << 4)
    if result == 0xFFF:
        result = None
    return result

def _bit_field(raw, offset):
    # convert byte to list of 8 booleans
    mask = 1
    result = []
    for i in range(8):
        result.append(raw[offset] & mask != 0)
        mask = mask << 1
    return result

_decoders = {
    'pb' : _plain_byte,
    'ub' : _unsigned_byte,
    'sb' : _signed_byte,
    'us' : _unsigned_short,
    'ss' : _signed_short,
    'u3' : _unsigned_int3,
    'dt' : _date_time,
    'tt' : _time,
    'wa' : _wind_ave,
    'wg' : _wind_gust,
    'bf' : _bit_field,
    }

def _decode(raw, format):
    if not raw:
        return None
    if isinstance(format, dict):
        result = {}
        for key, value in format.items():
            result[key] = _decode(raw, value)
    else:
        pos, type, scale = format
        result = _decoders[type](raw, pos)
        if type == 'bf':
            # bit field - 'scale' is a list of bit names
            result = dict(zip(scale, result))
        elif scale and result:
            result = float(result) * scale
    return result

class CUSBDrive(object):
    """Low level interface to weather station via USB.

    Loosely modeled on a C++ class obtained from
    http://site.ambientweatherstore.com/easyweather/ws_1080_2080_protocol.zip.
    I don't know the provenance of this, but it looks as if it may
    have come from the manufacturer.

    """
    EndMark          = 0x20
    ReadCommand      = 0xA1
    WriteCommand     = 0xA0
    WriteCommandWord = 0xA2

    def __init__(self):
        self.logger = logging.getLogger('pywws.WeatherStation.CUSBDrive')
        self.logger.info('using %s', USBDevice.__module__)
        self.dev = USBDevice(0x1941, 0x8021)

    def read_block(self, address):
        """Read 32 bytes from the weather station.

        If the read fails for any reason, :obj:`None` is returned.

        :param address: address to read from.

        :type address: int

        :return: the data from the weather station.

        :rtype: list(int)

        """
        buf = [
            self.ReadCommand,
            address // 256,
            address % 256,
            self.EndMark,
            self.ReadCommand,
            address // 256,
            address % 256,
            self.EndMark,
            ]
        if not self.dev.write_data(buf):
            return None
        return self.dev.read_data(32)

    def write_byte(self, address, data):
        """Write a single byte to the weather station.

        :param address: address to write to.

        :type address: int

        :param data: the value to write.

        :type data: int

        :return: success status.

        :rtype: bool

        """
        buf = [
            self.WriteCommandWord,
            address // 256,
            address % 256,
            self.EndMark,
            self.WriteCommandWord,
            data,
            0,
            self.EndMark,
            ]
        if not self.dev.write_data(buf):
            return False
        buf = self.dev.read_data(8)
        if buf is None:
            return False
        for byte in buf:
            if byte != 0xA5:
                return False
        return True

class DriftingClock(object):
    def __init__(self, logger, name, status, period, margin):
        self.logger = logger
        self.name = name
        self.status = status
        self.period = period
        self.margin = margin
        if self.status:
            self.clock = eval(
                self.status.get('clock', self.name, 'None'))
            self.drift = eval(
                self.status.get('clock', '%s drift' % self.name, '0.0'))
        else:
            self.clock = None
            self.drift = 0.0
        self._set_real_period()
        self.old_clock = self.clock

    def _set_real_period(self):
        self._real_period = self.period * (1.0 + (self.drift / (24.0 * 3600.0)))

    def before(self, now):
        if not self.clock:
            return None
        error = (now - self.clock) % self._real_period
        return now - error

    def nearest(self, now):
        if not self.clock:
            return None
        error = (now - self.clock) % self._real_period
        if error > (self._real_period / 2.0):
            error -= self._real_period
        return now - error

    def avoid(self):
        if not self.clock:
            return 1000.0
        now = time.time()
        phase = now - self.clock
        if phase > 24 * 3600:
            # clock was last measured a day ago, so reset it
            self.clock = None
            return 1000.0
        return (self.margin - phase) % self._real_period

    def set_clock(self, now):
        if self.clock:
            diff = (now - self.clock) % self._real_period
            if diff < 2.0 or diff > self._real_period - 2.0:
                return
            self.logger.error('unexpected %s clock change', self.name)
        self.clock = now
        self.logger.warning('setting %s clock %g', self.name, now % self.period)
        if self.status:
            self.status.set('clock', self.name, str(self.clock))
        if self.old_clock:
            diff = now - self.old_clock
            if diff < 8 * 3600:
                # drift measurement needs more than 8 hours gap
                return
            drift = diff % self.period
            if drift > self.period / 2:
                drift -= self.period
            drift = (float(drift) * 24.0 * 3600.0 / float(diff))
            self.drift += max(min(drift - self.drift, 3.0), -3.0) / 4.0
            self._set_real_period()
            self.logger.warning(
                '%s clock drift %g %g', self.name, drift, self.drift)
            if self.status:
                self.status.set(
                    'clock', '%s drift' % self.name, str(self.drift))
        self.old_clock = self.clock

    def invalidate(self):
        self.clock = None

class weather_station(object):
    """Class that represents the weather station to user program."""
    # minimum interval between polling for data change
    min_pause = 0.5
    # margin of error for various decisions
    margin = (min_pause * 2.0) - 0.1
    def __init__(self, ws_type='1080', status=None, avoid=3.0):
        """Connect to weather station and prepare to read data."""
        self.logger = logging.getLogger('pywws.weather_station')
        # create basic IO object
        self.cusb = CUSBDrive()
        # init variables
        self.status = status
        self.avoid = max(avoid, 0.0)
        self._fixed_block = None
        self._data_block = None
        self._data_pos = None
        self._current_ptr = None
        self._station_clock = DriftingClock(
            self.logger, 'station', self.status, 60, self.avoid)
        self._sensor_clock = DriftingClock(
            self.logger, 'sensor', self.status, 48, self.avoid)
        self.ws_type = ws_type

    def live_data(self, logged_only=False):
        # There are two things we want to synchronise to - the data is
        # updated every 48 seconds and the address is incremented
        # every 5 minutes (or 10, 15, ..., 30). Rather than getting
        # data every second or two, we sleep until one of the above is
        # due. (During initialisation we get data every half second
        # anyway.)
        read_period = self.get_fixed_block(['read_period'])
        log_interval = float(read_period * 60)
        live_interval = 48.0
        old_ptr = self.current_pos()
        old_data = self.get_data(old_ptr, unbuffered=True)
        now = time.time()
        next_live = self._sensor_clock.before(now + live_interval)
        if next_live:
            last_log = (next_live - live_interval) - (old_data['delay'] * 60.0)
        else:
            last_log = now - ((old_data['delay'] + 1) * 60.0)
        next_log = self._station_clock.before(last_log + log_interval)
        ptr_time = 0
        data_time = 0
        last_status = decode_status(0)
        while True:
            # sleep until just before next reading is due
            now = time.time()
            advance = now + max(self.avoid, self.min_pause) + self.min_pause
            if next_live:
                pause = next_live - advance
            else:
                pause = self.min_pause
            if next_log:
                pause = min(pause, next_log - advance)
            else:
                pause = min(pause, last_log + log_interval - advance)
            pause = max(pause, self.min_pause)
            self.logger.debug(
                'delay %s, pause %g', str(old_data['delay']), pause)
            time.sleep(pause)
            # get new pointer
            last_ptr_time = ptr_time
            new_ptr = self.current_pos()
            ptr_time = time.time()
            # get new data
            last_data_time = data_time
            new_data = self.get_data(old_ptr, unbuffered=True)
            data_time = time.time()
            # when ptr changes, internal sensor data gets updated
            if new_ptr != old_ptr:
                for key in ('hum_in', 'temp_in', 'abs_pressure'):
                    old_data[key] = new_data[key]
            # log any change of status except 'invalid_wind_dir'
            new_status = decode_status(new_data['status'])
            last_status['invalid_wind_dir'] = new_status['invalid_wind_dir']
            if new_status != last_status:
                self.logger.warning('status %s', str(new_status))
            last_status = new_status
            if (new_status['lost_connection'] and not
                decode_status(old_data['status'])['lost_connection']):
                # 'lost connection' decision can happen at any time
                old_data = new_data
            # has data changed?
            if any(new_data[key] != old_data[key] for key in (
                    'hum_in', 'temp_in', 'hum_out', 'temp_out',
                    'abs_pressure', 'wind_ave', 'wind_gust', 'wind_dir',
                    'rain', 'status')):
                self.logger.debug('live_data new data')
                if data_time - last_data_time < self.margin:
                    # data has just changed, so definitely at a 48s update time
                    self._sensor_clock.set_clock(data_time)
                elif next_live and data_time < next_live - self.margin:
                    self.logger.warning(
                        'live_data lost sync %g', data_time - next_live)
                    self.logger.warning('old data %s', str(old_data))
                    self.logger.warning('new data %s', str(new_data))
                    self._sensor_clock.invalidate()
                next_live = self._sensor_clock.nearest(data_time)
                if next_live:
                    if not logged_only:
                        result = dict(new_data)
                        result['idx'] = datetime.utcfromtimestamp(int(next_live))
                        yield result, old_ptr, False
                    next_live += live_interval
            elif next_live and data_time > next_live + 6.0:
                self.logger.info('live_data missed')
                next_live += live_interval
            old_data = new_data
            # has ptr changed?
            if new_ptr != old_ptr:
                self.logger.info('live_data new ptr: %06x', new_ptr)
                last_log = ptr_time
                if ptr_time - last_ptr_time < self.margin:
                    # pointer has just changed, so definitely at a logging time
                    self._station_clock.set_clock(ptr_time)
                elif next_log and ptr_time < next_log - self.margin:
                    self.logger.warning(
                        'live_data lost log sync %g', ptr_time - next_log)
                    self._station_clock.invalidate()
                next_log = self._station_clock.nearest(ptr_time)
                if next_log:
                    result = dict(new_data)
                    result['idx'] = datetime.utcfromtimestamp(int(next_log))
                    yield result, old_ptr, True
                    next_log += log_interval
                old_ptr = new_ptr
                old_data['delay'] = 0
                data_time = 0
            elif ptr_time > last_log + log_interval + 180.0:
                # if station stops logging data, don't keep reading
                # USB until it locks up
                raise IOError('station is not logging data')
            elif next_log and ptr_time > next_log + 6.0:
                self.logger.warning('live_data log extended')
                next_log += 60.0

    def inc_ptr(self, ptr):
        """Get next circular buffer data pointer."""
        result = ptr + self.reading_len[self.ws_type]
        if result >= 0x10000:
            result = self.data_start
        return result

    def dec_ptr(self, ptr):
        """Get previous circular buffer data pointer."""
        result = ptr - self.reading_len[self.ws_type]
        if result < self.data_start:
            result = 0x10000 - self.reading_len[self.ws_type]
        return result

    def get_raw_data(self, ptr, unbuffered=False):
        """Get raw data from circular buffer.

        If unbuffered is false then a cached value that was obtained
        earlier may be returned."""
        if unbuffered:
            self._data_pos = None
        # round down ptr to a 'block boundary'
        idx = ptr - (ptr % 0x20)
        ptr -= idx
        count = self.reading_len[self.ws_type]
        if self._data_pos == idx:
            # cache contains useful data
            result = self._data_block[ptr:ptr + count]
            if len(result) >= count:
                return result
        else:
            result = list()
        if ptr + count > 0x20:
            # need part of next block, which may be in cache
            if self._data_pos != idx + 0x20:
                self._data_pos = idx + 0x20
                self._data_block = self._read_block(self._data_pos)
            result += self._data_block[0:ptr + count - 0x20]
            if len(result) >= count:
                return result
        # read current block
        self._data_pos = idx
        self._data_block = self._read_block(self._data_pos)
        result = self._data_block[ptr:ptr + count] + result
        return result

    def get_data(self, ptr, unbuffered=False):
        """Get decoded data from circular buffer.

        If unbuffered is false then a cached value that was obtained
        earlier may be returned."""
        result = _decode(self.get_raw_data(ptr, unbuffered),
                         self._reading_format[self.ws_type])
        # split up 'wind_dir' byte
        if result['wind_dir'] is not None:
            result['status'] |= (result['wind_dir'] & 0xF0) << 4
            if result['wind_dir'] & 0x80:
                result['wind_dir'] = None
            else:
                result['wind_dir'] &= 0x0F
        return result

    def current_pos(self):
        """Get circular buffer location where current data is being written."""
        new_ptr = _decode(
            self._read_fixed_block(0x0020), self.lo_fix_format['current_pos'])
        if new_ptr == self._current_ptr:
            return self._current_ptr
        if self._current_ptr and new_ptr != self.inc_ptr(self._current_ptr):
            self.logger.error(
                'unexpected ptr change %06x -> %06x', self._current_ptr, new_ptr)
        self._current_ptr = new_ptr
        return self._current_ptr

    def get_raw_fixed_block(self, unbuffered=False):
        """Get the raw "fixed block" of settings and min/max data."""
        if unbuffered or not self._fixed_block:
            self._fixed_block = self._read_fixed_block()
        return self._fixed_block

    def get_fixed_block(self, keys=[], unbuffered=False):
        """Get the decoded "fixed block" of settings and min/max data.

        A subset of the entire block can be selected by keys."""
        if unbuffered or not self._fixed_block:
            self._fixed_block = self._read_fixed_block()
        format = self.fixed_format
        # navigate down list of keys to get to wanted data
        for key in keys:
            format = format[key]
        return _decode(self._fixed_block, format)

    def _wait_for_station(self):
        # avoid times when station is writing to memory
        while True:
            pause = 60.0
            pause = min(pause, self._station_clock.avoid())
            pause = min(pause, self._sensor_clock.avoid())
            if pause >= self.avoid * 2.0:
                return
            self.logger.debug('avoid %s', str(pause))
            time.sleep(pause)

    def _read_block(self, ptr, retry=True):
        # Read block repeatedly until it's stable. This avoids getting corrupt
        # data when the block is read as the station is updating it.
        old_block = None
        while True:
            self._wait_for_station()
            new_block = self.cusb.read_block(ptr)
            if new_block:
                if (new_block == old_block) or not retry:
                    break
                if old_block:
                    self.logger.debug('_read_block changing %06x', ptr)
                old_block = new_block
        return new_block

    def _read_fixed_block(self, hi=0x0100):
        result = []
        for mempos in range(0x0000, hi, 0x0020):
            result += self._read_block(mempos)
        # check 'magic number'
        if result[:2] not in ([0x55, 0xAA], [0xFF, 0xFF],
                              [0x55, 0x55], [0xC4, 0x00]):
            self.logger.critical(
                "Unrecognised 'magic number' %02x %02x", result[0], result[1])
        return result

    def _write_byte(self, ptr, value):
        self._wait_for_station()
        if not self.cusb.write_byte(ptr, value):
            raise IOError('_write_byte failed')

    def write_data(self, data):
        """Write a set of single bytes to the weather station. Data must be an
        array of (ptr, value) pairs."""
        # send data
        for ptr, value in data:
            self._write_byte(ptr, value)
        # set 'data changed'
        self._write_byte(self.fixed_format['data_changed'][0], 0xAA)
        # wait for station to clear 'data changed'
        while True:
            ack = _decode(
                self._read_fixed_block(0x0020), self.fixed_format['data_changed'])
            if ack == 0:
                break
            self.logger.debug('write_data waiting for ack')
            time.sleep(6)

    # Tables of "meanings" for raw weather station data. Each key
    # specifies an (offset, type, multiplier) tuple that is understood
    # by _decode.
    # depends on weather station type
    _reading_format = {}
    _reading_format['1080'] = {
        'delay'        : (0, 'ub', None),
        'hum_in'       : (1, 'ub', None),
        'temp_in'      : (2, 'ss', 0.1),
        'hum_out'      : (4, 'ub', None),
        'temp_out'     : (5, 'ss', 0.1),
        'abs_pressure' : (7, 'us', 0.1),
        'wind_ave'     : (9, 'wa', 0.1),
        'wind_gust'    : (10, 'wg', 0.1),
        'wind_dir'     : (12, 'ub', None),
        'rain'         : (13, 'us', 0.3),
        'status'       : (15, 'pb', None),
        }
    _reading_format['3080'] = {
        'illuminance' : (16, 'u3', 0.1),
        'uv'          : (19, 'ub', None),
        }
    _reading_format['3080'].update(_reading_format['1080'])
    lo_fix_format = {
        'read_period'   : (16, 'ub', None),
        'settings_1'    : (17, 'bf', ('temp_in_F', 'temp_out_F', 'rain_in',
                                      'bit3', 'bit4', 'pressure_hPa',
                                      'pressure_inHg', 'pressure_mmHg')),
        'settings_2'    : (18, 'bf', ('wind_mps', 'wind_kmph', 'wind_knot',
                                      'wind_mph', 'wind_bft', 'bit5',
                                      'bit6', 'bit7')),
        'display_1'     : (19, 'bf', ('pressure_rel', 'wind_gust', 'clock_12hr',
                                      'date_mdy', 'time_scale_24', 'show_year',
                                      'show_day_name', 'alarm_time')),
        'display_2'     : (20, 'bf', ('temp_out_temp', 'temp_out_chill',
                                      'temp_out_dew', 'rain_hour', 'rain_day',
                                      'rain_week', 'rain_month', 'rain_total')),
        'alarm_1'       : (21, 'bf', ('bit0', 'time', 'wind_dir', 'bit3',
                                      'hum_in_lo', 'hum_in_hi',
                                      'hum_out_lo', 'hum_out_hi')),
        'alarm_2'       : (22, 'bf', ('wind_ave', 'wind_gust',
                                      'rain_hour', 'rain_day',
                                      'pressure_abs_lo', 'pressure_abs_hi',
                                      'pressure_rel_lo', 'pressure_rel_hi')),
        'alarm_3'       : (23, 'bf', ('temp_in_lo', 'temp_in_hi',
                                      'temp_out_lo', 'temp_out_hi',
                                      'wind_chill_lo', 'wind_chill_hi',
                                      'dew_point_lo', 'dew_point_hi')),
        'timezone'      : (24, 'sb', None),
        'unknown_01'    : (25, 'pb', None),
        'data_changed'  : (26, 'ub', None),
        'data_count'    : (27, 'us', None),
        'display_3'     : (29, 'bf', ('illuminance_fc', 'bit1', 'bit2', 'bit3',
                                      'bit4', 'bit5', 'bit6', 'bit7')),
        'current_pos'   : (30, 'us', None),
        }
    fixed_format = {
        'rel_pressure'  : (32, 'us', 0.1),
        'abs_pressure'  : (34, 'us', 0.1),
        'lux_wm2_coeff' : (36, 'us', 0.1),
        'date_time'     : (43, 'dt', None),
        'unknown_18'    : (97, 'pb', None),
        'alarm'         : {
            'hum_in'        : {'hi' : (48, 'ub', None), 'lo'  : (49, 'ub', None)},
            'temp_in'       : {'hi' : (50, 'ss', 0.1), 'lo'  : (52, 'ss', 0.1)},
            'hum_out'       : {'hi' : (54, 'ub', None), 'lo'  : (55, 'ub', None)},
            'temp_out'      : {'hi' : (56, 'ss', 0.1), 'lo'  : (58, 'ss', 0.1)},
            'windchill'     : {'hi' : (60, 'ss', 0.1), 'lo'  : (62, 'ss', 0.1)},
            'dewpoint'      : {'hi' : (64, 'ss', 0.1), 'lo'  : (66, 'ss', 0.1)},
            'abs_pressure'  : {'hi' : (68, 'us', 0.1), 'lo'  : (70, 'us', 0.1)},
            'rel_pressure'  : {'hi' : (72, 'us', 0.1), 'lo'  : (74, 'us', 0.1)},
            'wind_ave'      : {'bft' : (76, 'ub', None), 'ms' : (77, 'ub', 0.1)},
            'wind_gust'     : {'bft' : (79, 'ub', None), 'ms' : (80, 'ub', 0.1)},
            'wind_dir'      : (82, 'ub', None),
            'rain'          : {'hour' : (83, 'us', 0.3), 'day'   : (85, 'us', 0.3)},
            'time'          : (87, 'tt', None),
            'illuminance'   : (89, 'u3', 0.1),
            'uv'            : (92, 'ub', None),
            },
        'max'           : {
            'uv'            : {'val' : (93, 'ub', None)},
            'illuminance'   : {'val' : (94, 'u3', 0.1)},
            'hum_in'        : {'val' : (98, 'ub', None), 'date'   : (141, 'dt', None)},
            'hum_out'       : {'val' : (100, 'ub', None), 'date'  : (151, 'dt', None)},
            'temp_in'       : {'val' : (102, 'ss', 0.1), 'date'  : (161, 'dt', None)},
            'temp_out'      : {'val' : (106, 'ss', 0.1), 'date'  : (171, 'dt', None)},
            'windchill'     : {'val' : (110, 'ss', 0.1), 'date'  : (181, 'dt', None)},
            'dewpoint'      : {'val' : (114, 'ss', 0.1), 'date'  : (191, 'dt', None)},
            'abs_pressure'  : {'val' : (118, 'us', 0.1), 'date'  : (201, 'dt', None)},
            'rel_pressure'  : {'val' : (122, 'us', 0.1), 'date'  : (211, 'dt', None)},
            'wind_ave'      : {'val' : (126, 'us', 0.1), 'date'  : (221, 'dt', None)},
            'wind_gust'     : {'val' : (128, 'us', 0.1), 'date'  : (226, 'dt', None)},
            'rain'          : {
                'hour'          : {'val' : (130, 'us', 0.3), 'date'  : (231, 'dt', None)},
                'day'           : {'val' : (132, 'us', 0.3), 'date'  : (236, 'dt', None)},
                'week'          : {'val' : (134, 'us', 0.3), 'date'  : (241, 'dt', None)},
                'month'         : {'val' : (136, 'us', 0.3), 'date'  : (246, 'dt', None)},
                'total'         : {'val' : (138, 'us', 0.3), 'date'  : (251, 'dt', None)},
                },
            },
        'min'           : {
            'hum_in'        : {'val' : (99, 'ub', None), 'date'   : (146, 'dt', None)},
            'hum_out'       : {'val' : (101, 'ub', None), 'date'  : (156, 'dt', None)},
            'temp_in'       : {'val' : (104, 'ss', 0.1), 'date'  : (166, 'dt', None)},
            'temp_out'      : {'val' : (108, 'ss', 0.1), 'date'  : (176, 'dt', None)},
            'windchill'     : {'val' : (112, 'ss', 0.1), 'date'  : (186, 'dt', None)},
            'dewpoint'      : {'val' : (116, 'ss', 0.1), 'date'  : (196, 'dt', None)},
            'abs_pressure'  : {'val' : (120, 'us', 0.1), 'date'  : (206, 'dt', None)},
            'rel_pressure'  : {'val' : (124, 'us', 0.1), 'date'  : (216, 'dt', None)},
            },
        }
    fixed_format.update(lo_fix_format)
    # start of readings / end of fixed block
    data_start = 0x0100     # 256
    # bytes per reading, depends on weather station type
    reading_len = {
        '1080'  : 16,
        '3080'  : 20,
        }

########NEW FILE########
__FILENAME__ = WindRose
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Plot a "wind rose"

::

%s

Introduction
------------

This routine plots one or more "wind roses" (see `Wikipedia
<http://en.wikipedia.org/wiki/Wind_rose>`_ for a description). Like
:py:mod:`pywws.Plot` almost everything is controlled by an XML
"recipe" / template file.

Before writing your own template files, it might be useful to look at
some of the examples in the example_graph_templates directory. If
(like I was) you are unfamiliar with XML, I suggest reading the `W3
Schools XML tutorial <http://www.w3schools.com/xml/>`_.

XML graph file syntax
---------------------

Here is the simplest useful wind rose template. It plots wind over the
last 24 hours. ::

  <?xml version="1.0" encoding="ISO-8859-1"?>
  <graph>
    <windrose>
      <ycalc>data['wind_ave']</ycalc>
    </windrose>
  </graph>

In this example, the root element graph has one windrose element which
contains nothing more than a ycalc element.

The complete element hierarchy is shown below. ::

    graph
        windrose
            xcalc
            ycalc
            threshold
            colour
            yrange
            points
            source
            title
        start
        stop
        duration
        layout
        size
        fileformat
        lmargin, rmargin, tmargin, bmargin
        title

graph
^^^^^

This is the root element of the graph XML file. It does not have to be
called "graph", but there must be exactly one root element.

windrose
^^^^^^^^

A separate plot is drawn for each windrose element, but all share the
same time period.

start
^^^^^

This element sets the date & time of the wind roses. It is used in the
constructor of a Python datetime object. For example, to start at noon
(local time) on Christmas day 2008: ``<start>year=2008, month=12,
day=25, hour=12</start>``. The default value is (stop - duration).

stop
^^^^

This element sets the date & time of the end of the wind roses. It is
used in the constructor of a Python datetime object. For example, to
end at 10 am (local time) on new year's day 2009: ``<stop>year=2009,
month=1, day=1, hour=10</stop>``. The default value is (start +
duration), unless start is not defined in which case the timestamp of
the latest weather station hourly reading is used.

duration
^^^^^^^^

This element sets the duration of wind roses, unless both start and
stop are defined. It is used in the constructor of a Python timedelta
object. For example, to plot one week:
``<duration>weeks=1</duration>``. The default value is hours=24.

layout
^^^^^^

Controls the layout of the plots. Default is a grid that is wider than
it is tall. The layout element specifies rows and columns. For
example: ``<layout>4, 2</layout>`` will use a grid of 4 rows and 2
columns.

size
^^^^

Sets the overall dimensions of the image file containing the graph.
Default is a height of 600 pixels and a width that depends on the
layout. Any size element must include both width and height. For
example: ``<size>800, 600</size>`` will produce an image 800 pixels
wide and 600 pixels high.

fileformat
^^^^^^^^^^

Sets the image format of the file containing the plots. Default is
png. Any string recognised by your installation of gnuplot should do.
For example: ``<fileformat>gif</fileformat>`` will produce a GIF
image.

lmargin, rmargin, tmargin, bmargin
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Over-rides the automatically computed left, right, top or bottom
margin. Supply any positive real number, for example
``<lmargin>1.3</lmargin>``. Some experimentation may be necessary to
find the best values.

title
^^^^^

Sets the overall title of the plots. A single line of text, for
example: ``<title>Today's weather</title>``. This title appears at the
very top, outside any plot area.

xcalc
^^^^^

Selects if data is included in the wind rose. The value should be a
valid Python logical expression. For example, to plot a rose for
afternoon winds only: ``<xcalc>data['idx'].hour &gt;= 12</xcalc>``.
This allows aggregation of afternoon wind data over several days.
Remember that data is indexed in UTC, so you need to use an expression
that takes account of your time zone. The default value is 'True'.

ycalc
^^^^^

Selects the data to be plotted. Any one line Python expression that
returns a single float value can be used. At its simplest this just
selects one value from the "data" dictionary, for example:
``<ycalc>data['wind_ave']</ycalc>``. To convert to mph use:
``<ycalc>data['wind_ave'] * 3.6 / 1.609344</ycalc>``. You are unlikely
to want to use anything other than 'wind_ave' here.

threshold
^^^^^^^^^

Sets the thresholds for each colour on the rose petals. Defaults are
based on the Wikipedia example. The values should be a correctly
ordered list of real numbers, for example: ``<threshold>0.5, 3.5, 7.5,
12.5, 18.5, 24.5, 31.5</threshold>`` approximates to the Beaufort
scale, if ycalc has been set to convert windspeeds to mph.

colour
^^^^^^

Sets the colours of the threshold petal segments. Any sequence of
integer values is accepted. The mapping of colours to numbers is set
by gnuplot. Default value is 0, 1, 2, 3, etc.

yrange
^^^^^^

Sets the upper limits of the axes. The rose shows what percentage of
the time the wind came from a particular direction. For example, if
you live somewhere with a very steady wind you might want to allow
higher percentages than normal: ``<yrange>91</yrange>``. Auto-scaling
is also possible, using an asterisk: ``<yrange>*</yrange>``

points
^^^^^^

Sets the text of the compass points. The defaults are 'N', 'S', 'E' &
'W'. For graphs in another language you can over-ride this, for
example: ``<points>'No', 'Zu', 'Oo', 'We'</points>``. (The preferred
way to do this is to create a language file, see Localisation.py.)

source
^^^^^^

Select the weather data to be plotted. Permitted values are
``<source>raw</source>``, ``<source>hourly</source>``,
``<source>daily</source>`` and ``<source>monthly</source>``. Default
is raw. Note that the different sources have different data
dictionaries, so this choice affects ycalc.

title
^^^^^

Sets the title of the plot. A single line of text, for example:
``<title>Morning winds</title>``. This title appears within the plot
area, above the threshold colour key.

Detailed API
------------

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.WindRose [options] data_dir temp_dir xml_file output_file
 options are:
  -h or --help    display this help
 data_dir is the root directory of the weather data
 temp_dir is a workspace for temporary files e.g. /tmp
 xml_file is the name of the source file that describes the plot
 output_file is the name of the image file to be created e.g. 24hrs.png
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import codecs
from datetime import datetime, timedelta
import getopt
import math
import os
import sys
import xml.dom.minidom

from .conversions import *
from . import DataStore
from . import Localisation
from .Logger import ApplicationLogger
from .Plot import BasePlotter

class RosePlotter(BasePlotter):
    plot_name = 'windrose'
    def GetDefaultRows(self):
        return int(math.sqrt(self.plot_count))

    def GetDefaultPlotSize(self):
        return 600 // self.rows, 600 // self.rows

    def GetPreamble(self):
        result = """set polar
set angles degrees
set zeroaxis
set grid polar 22.5
set size square
unset border
set noytics
"""
        if self.gnuplot_version >= 4.6:
            result += """set noxtics
set rtics nomirror
unset raxis
"""
        else:
            result += 'set xtics axis nomirror\n'
        lmargin = eval(self.graph.get_value('lmargin', '-1'))
        result += 'set lmargin %g\n' % (lmargin)
        lmargin = eval(self.graph.get_value('rmargin', '-1'))
        result += 'set rmargin %g\n' % (lmargin)
        lmargin = eval(self.graph.get_value('tmargin', '-1'))
        result += 'set tmargin %g\n' % (lmargin)
        lmargin = eval(self.graph.get_value('bmargin', '-1'))
        result += 'set bmargin %g\n' % (lmargin)
        return result

    def PlotData(self, plot_no, plot, source):
        _ = Localisation.translation.ugettext
        # get statistics
        thresh = eval(plot.get_value(
            'threshold', '0.0, 1.54, 3.09, 5.14, 8.23, 10.8, 15.5'))
        thresh = thresh + (1000.0,)
        colour = eval(plot.get_value('colour', str(range(len(thresh)))))
        xcalc = plot.get_value('xcalc', 'True')
        xcalc = compile(xcalc, '<string>', 'eval')
        ycalc = plot.get_value('ycalc', None)
        ycalc = compile(ycalc, '<string>', 'eval')
        histograms = []
        for i in range(len(thresh)):
            hist = []
            for n in range(16):
                hist.append(0)
            histograms.append(hist)
        # x_lo & x_hi are in local time, data is indexed in UTC
        start = self.x_lo - self.utcoffset
        stop = self.x_hi - self.utcoffset
        stop = stop + timedelta(minutes=1)
        for data in source[start:stop]:
            wind_dir = data['wind_dir']
            if wind_dir is None:
                continue
            if not eval(xcalc):
                continue
            value = eval(ycalc)
            if value is None:
                continue
            for t in range(len(thresh)):
                if value <= thresh[t]:
                    histograms[t][wind_dir] += 1
                    break
        # evenly distribute zero speed
        total = 0
        for n in range(16):
            total += histograms[0][n]
        for n in range(16):
            histograms[0][n] = total // 16
        # integrate histograms
        for i in range(1, len(thresh)):
            for n in range(16):
                histograms[i][n] += histograms[i-1][n]
        total = 0
        for n in range(16):
            total += histograms[-1][n]
        result = ''
        yrange = plot.get_value('yrange', '31')
        if yrange == '*':
            # auto-ranging
            if total > 0:
                max_petal = 100.0 * float(max(histograms[-1])) / float(total)
            else:
                max_petal = 0.0
            if max_petal > 40.0:
                yrange = (int(max_petal / 20.0) * 20) + 21
            elif max_petal > 30.0:
                yrange = 41
            elif max_petal > 20.0:
                yrange = 31
            else:
                yrange = 21
        else:
            yrange = eval(yrange)
        result += 'set rrange [0:%d]\n' % (yrange)
        result += 'set xrange [-%d:%d]\n' % (yrange, yrange)
        result += 'set yrange [-%d:%d]\n' % (yrange, yrange)
        points = [_('N'), _('S'), _('E'), _('W')]
        points = eval(plot.get_value('points', str(points)))
        result += 'set label 1000 "%s" at 0, %d center front\n' % (points[0], yrange)
        result += 'set label 1001 "%s" at 0, -%d center front\n' % (points[1], yrange)
        result += 'set label 1002 "%s" at %d, 0 center front\n' % (points[2], yrange)
        result += 'set label 1003 "%s" at -%d, 0 center front\n' % (points[3], yrange)
        # plot segments for each speed-direction
        result += 'plot '
        for i in reversed(range(len(thresh))):
            dat_file = os.path.join(self.work_dir, 'plot_%d_%d.dat' % (plot_no, i))
            self.tmp_files.append(dat_file)
            dat = open(dat_file, 'w')
            sub_total = 0
            for n in range(16):
                angle = 90.0 - (n * 22.5)
                sub_total += histograms[i][n]
                if i > 0:
                    sub_total -= histograms[i-1][n]
                if total > 0:
                    value = 100.0 * float(histograms[i][n]) / float(total)
                else:
                    value = 0.0
                if i == 0:
                    dat.write('%g %g\n' % (angle - 11.24, value * 0.994))
                else:
                    dat.write('%g %g\n' % (angle - 8.1, 0))
                dat.write('%g %g\n' % (angle - 8.0, value * 0.997))
                dat.write('%g %g\n' % (angle, value))
                dat.write('%g %g\n' % (angle + 8.0, value * 0.997))
                if i == 0:
                    dat.write('%g %g\n' % (angle + 11.24, value * 0.994))
                    dat.write('%g %g\n' % (angle + 11.25, 0))
                else:
                    dat.write('%g %g\n' % (angle + 8.1, 0))
            dat.close()
            # plot data
            if total > 0:
                value = 100.0 * float(sub_total) / float(total)
            else:
                value = 0.0
            if i == 0:
                title = '0 .. %g (%.3g%%)' % (thresh[i], value)
            elif i == len(thresh) - 1:
                title = '> %g (%.3g%%)' % (thresh[i-1], value)
            else:
                title = '%g .. %g (%.3g%%)' % (thresh[i-1], thresh[i], value)
            result += '"%s" using 1:2 title "%s" with filledcurve lt %d' % (
                dat_file, title, colour[i % len(colour)])
            if i > 0:
                result += ', \\'
            result += '\n'
        return result

def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "h", ['help'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
    # check arguments
    if len(args) != 4:
        print >>sys.stderr, 'Error: 4 arguments required\n'
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(2)
    params = DataStore.params(args[0])
    Localisation.SetApplicationLanguage(params)
    return RosePlotter(
        params, DataStore.status(args[0]),
        DataStore.calib_store(args[0]), DataStore.hourly_store(args[0]),
        DataStore.daily_store(args[0]), DataStore.monthly_store(args[0]),
        args[1]
        ).DoPlot(args[2], args[3])

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = YoWindow
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Generate YoWindow XML file
::

%s

"""

from __future__ import absolute_import

__docformat__ = "restructuredtext en"
__usage__ = """
 usage: python -m pywws.YoWindow [options] data_dir output_file
 options are:
  -h or --help     display this help
  -v or --verbose  increase amount of reassuring messages
 data_dir is the root directory of the weather data
 output_file is the YoWindow XML file to be written
"""
__doc__ %= __usage__
__usage__ = __doc__.split('\n')[0] + __usage__

import getopt
import logging
import sys
from datetime import datetime, timedelta

from . import DataStore
from .Logger import ApplicationLogger
from .TimeZone import Local, utc
from .conversions import apparent_temp

class YoWindow(object):
    """
    Class to write YoWindow XML file.
    For file spec see http://yowindow.com/doc/yowindow_pws_format.xml
    """
    def __init__(self, calib_data):
        self.logger = logging.getLogger('pywws.YoWindow')
        self.data = calib_data
        # compute local midnight
        self.midnight = datetime.utcnow().replace(tzinfo=utc).astimezone(
            Local).replace(hour=0, minute=0, second=0).astimezone(
                utc).replace(tzinfo=None)
        self.day = timedelta(hours=24)
        self.hour = timedelta(hours=1)
        self.last_update = None
    def write_file(self, file_name, data=None):
        if not data:
            data = self.data[self.data.before(datetime.max)]
        data_hour = self.data[self.data.nearest(data['idx'] - self.hour)]
        while data['idx'] < self.midnight:
            self.midnight -= self.day
        while data['idx'] >= self.midnight + self.day:
            self.midnight += self.day
        data_midnight = self.data[self.data.before(self.midnight)]
        of = open(file_name, 'w')
        of.write('<response>\n')
        of.write('  <current_weather>\n')
        if data['temp_out'] != None:
            of.write('    <temperature unit="c">\n')
            of.write('      <current value="%.1f"/>\n' % (data['temp_out']))
            if data['hum_out'] != None and data['wind_ave'] != None:
                of.write('      <feels_like value="%.1f"/>\n' % (
                    apparent_temp(
                        data['temp_out'], data['hum_out'], data['wind_ave'])))
            of.write('    </temperature>\n')
        if data['hum_out'] != None:
            of.write('    <humidity value="%d"/>\n' % (data['hum_out']))
        of.write('    <pressure value="%.1f" trend="%.1f" unit="hPa"/>\n' % (
            data['rel_pressure'],
            data['rel_pressure'] - data_hour['rel_pressure']))
        if data['wind_ave'] != None:
            of.write('    <wind>\n')
            of.write('      <speed value="%.1f" unit="m/s"/>\n' % (
                data['wind_ave']))
            if data['wind_dir'] != None and data['wind_dir'] < 16:
                of.write('      <direction value="%.0f"/>\n' % (
                    data['wind_dir'] * 22.5))
            if data['wind_gust'] != None:
                of.write('      <gusts value="%.1f" unit="m/s"/>\n' % (
                    data['wind_gust']))
            of.write('    </wind>\n')
        of.write('    <sky>\n')
        of.write('      <precipitation>\n')
        of.write('        <rain>\n')
        of.write('          <rate value="%.1f" unit="mm"/>\n' % (
            max(data['rain'] - data_hour['rain'], 0.0)))
        of.write('          <daily_total value="%.1f" unit="mm"/>\n' % (
            max(data['rain'] - data_midnight['rain'], 0.0)))
        of.write('        </rain>\n')
        of.write('      </precipitation>\n')
        of.write('    </sky>\n')
        of.write('    <auto_update>\n')
        if self.last_update:
            interval = (data['idx'] - self.last_update).seconds
        else:
            interval = data['delay'] * 60
        self.last_update = data['idx']
        of.write('      <interval value="%d"/>\n' % (interval))
        of.write('    </auto_update>\n')
        of.write('  </current_weather>\n')
        of.write('</response>\n')
        of.close()
def main(argv=None):
    if argv is None:
        argv = sys.argv
    try:
        opts, args = getopt.getopt(argv[1:], "hv", ['help', 'verbose'])
    except getopt.error, msg:
        print >>sys.stderr, 'Error: %s\n' % msg
        print >>sys.stderr, __usage__.strip()
        return 1
    # process options
    verbose = 0
    for o, a in opts:
        if o == '-h' or o == '--help':
            print __usage__.strip()
            return 0
        elif o == '-v' or o == '--verbose':
            verbose += 1
    # check arguments
    if len(args) != 2:
        print >>sys.stderr, "Error: 2 arguments required"
        print >>sys.stderr, __usage__.strip()
        return 2
    logger = ApplicationLogger(verbose)
    return YoWindow(DataStore.calib_store(args[0])).write_file(args[1])
if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = ZambrettiCore
#!/usr/bin/env python

# pywws - Python software for USB Wireless Weather Stations
# http://github.com/jim-easterbrook/pywws
# Copyright (C) 2008-14  Jim Easterbrook  jim@jim-easterbrook.me.uk
# Inspired by beteljuice.com Java algorithm, as converted to Python by
# honeysucklecottage.me.uk, and further information from
# http://www.meteormetrics.com/zambretti.htm

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

from __future__ import absolute_import

def _(msg) : return msg

forecast_text = {
    'A' : _("Settled fine"),
    'B' : _("Fine weather"),
    'C' : _("Becoming fine"),
    'D' : _("Fine, becoming less settled"),
    'E' : _("Fine, possible showers"),
    'F' : _("Fairly fine, improving"),
    'G' : _("Fairly fine, possible showers early"),
    'H' : _("Fairly fine, showery later"),
    'I' : _("Showery early, improving"),
    'J' : _("Changeable, mending"),
    'K' : _("Fairly fine, showers likely"),
    'L' : _("Rather unsettled clearing later"),
    'M' : _("Unsettled, probably improving"),
    'N' : _("Showery, bright intervals"),
    'O' : _("Showery, becoming less settled"),
    'P' : _("Changeable, some rain"),
    'Q' : _("Unsettled, short fine intervals"),
    'R' : _("Unsettled, rain later"),
    'S' : _("Unsettled, some rain"),
    'T' : _("Mostly very unsettled"),
    'U' : _("Occasional rain, worsening"),
    'V' : _("Rain at times, very unsettled"),
    'W' : _("Rain at frequent intervals"),
    'X' : _("Rain, very unsettled"),
    'Y' : _("Stormy, may improve"),
    'Z' : _("Stormy, much rain")
    }

del _

def ZambrettiCode(pressure, month, wind, trend,
                  north=True, baro_top=1050.0, baro_bottom=950.0):
    """Simple implementation of Zambretti forecaster algorithm.
    Inspired by beteljuice.com Java algorithm, as converted to Python by
    honeysucklecottage.me.uk, and further information
    from http://www.meteormetrics.com/zambretti.htm"""
    # normalise pressure
    pressure = 950.0 + ((1050.0 - 950.0) *
                        (pressure - baro_bottom) / (baro_top - baro_bottom))
    # adjust pressure for wind direction
    if wind != None:
        if not north:
            # southern hemisphere, so add 180 degrees
            wind = (wind + 8) % 16
        pressure += (  5.2,  4.2,  3.2,  1.05, -1.1, -3.15, -5.2, -8.35,
                     -11.5, -9.4, -7.3, -5.25, -3.2, -1.15,  0.9,  3.05)[wind]
    # compute base forecast from pressure and trend (hPa / hour)
    if trend >= 0.1:
        # rising pressure
        if north == (month >= 4 and month <= 9):
            pressure += 3.2
        F = 0.1740 * (1031.40 - pressure)
        LUT = ('A', 'B', 'B', 'C', 'F', 'G', 'I', 'J', 'L', 'M', 'M', 'Q', 'T',
               'Y')
    elif trend <= -0.1:
        # falling pressure
        if north == (month >= 4 and month <= 9):
            pressure -= 3.2
        F = 0.1553 * (1029.95 - pressure)
        LUT = ('B', 'D', 'H', 'O', 'R', 'U', 'V', 'X', 'X', 'Z')
    else:
        # steady
        F = 0.2314 * (1030.81 - pressure)
        LUT = ('A', 'B', 'B', 'B', 'E', 'K', 'N', 'N', 'P', 'P', 'S', 'W', 'W',
               'X', 'X', 'X', 'Z')
    # clip to range of lookup table
    F = min(max(int(F + 0.5), 0), len(LUT) - 1)
    # convert to letter code
    return LUT[F]

def ZambrettiText(letter):
    return forecast_text[letter]

def main(argv=None):
    from .conversions import winddir_text
    for pressure in range(1030, 960, -10):
        for trend_txt in ('S', 'R-S', 'R-W', 'F-W', 'F-S'):
            trend, month = {
                'R-W' : ( 0.2, 1),
                'F-W' : (-0.2, 1),
                'R-S' : ( 0.2, 7),
                'F-S' : (-0.2, 7),
                'S'   : ( 0.0, 7),
                }[trend_txt]
            for wind in (0, 2, 14, None, 4, 12, 6, 10, 8):
                if wind is None:
                    wind_txt = 'calm'
                else:
                    wind_txt = winddir_text(wind)
                print '%4d %4s %4s  %3s' % (
                    pressure, trend_txt, wind_txt,
                    ZambrettiCode(pressure, month, wind, trend))
        print ''

if __name__ == "__main__":
    main()

########NEW FILE########
