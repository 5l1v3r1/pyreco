__FILENAME__ = conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# complexity documentation build configuration file, created by
# sphinx-quickstart on Tue Jul  9 22:26:36 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# Get the project root dir, which is the parent dir of this
cwd = os.getcwd()
project_root = os.path.dirname(cwd)

# Insert the project root dir as the first element in the PYTHONPATH.
# This lets us ensure that the source package is imported, and that its
# version is used.
sys.path.insert(0, project_root)
sys.path.append(os.path.abspath('_themes'))

import robobrowser

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'robobrowser'
copyright = u'"", Joshua Carp'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = robobrowser.__version__
# The full version, including alpha/beta/rc tags.
release = robobrowser.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'robobrowserdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'robobrowser.tex', u'robobrowser Documentation',
   u'Joshua Carp', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'robobrowser', u'robobrowser Documentation',
     [u'Joshua Carp'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'robobrowser', u'robobrowser Documentation',
   u'Joshua Carp', 'robobrowser', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = browser
"""
Robotic browser.
"""

import re
import requests
from bs4 import BeautifulSoup
from bs4.element import Tag
from requests.exceptions import RequestException

from robobrowser.compat import urlparse, string_types
from robobrowser import helpers
from robobrowser.forms.form import Form
from robobrowser.cache import RoboHTTPAdapter
from robobrowser.helpers import retry


class RoboError(Exception): pass

_link_ptn = re.compile(r'^(a|button)$', re.I)
_form_ptn = re.compile(r'^form$', re.I)


class RoboState(object):
    """Representation of a browser state. Wraps the browser and response, and
    lazily parses the response content.

    """

    def __init__(self, browser, response):
        self.browser = browser
        self.response = response
        self.url = response.url
        self._parsed = None

    @property
    def parsed(self):
        """Lazily parse response content, using HTML parser specified by the
        browser.

        """
        if self._parsed is None:
            self._parsed = BeautifulSoup(
                self.response.content,
                features=self.browser.parser,
            )
        return self._parsed


class RoboBrowser(object):
    """Robotic web browser. Represents HTTP requests and responses using the
    requests library and parsed HTML using BeautifulSoup.

    :param tuple auth: Tuple of (username, password)
    :param str parser: HTML parser; used by BeautifulSoup
    :param dict headers: Default headers
    :param str user_agent: Default user-agent
    :param history: History length; infinite if True, 1 if falsy, else
        takes integer value
    :param int timeout: Default timeout in seconds
    :param bool verify: Verify SSL

    :param bool cache: Cache responses
    :param list cache_patterns: List of URL patterns for cache
    :param timedelta max_age: Max age for cache
    :param int max_count: Max count for cache

    :param int tries: Number of retries
    :param Exception errors: Exception(s) to catch
    :param int delay: Delay between retries
    :param int multiplier: Delay multiplier between retries

    """
    def __init__(self, auth=None, parser=None, headers=None, user_agent=None,
                 history=True, timeout=None, verify=True, cache=False,
                 cache_patterns=None, max_age=None, max_count=None, tries=None,
                 errors=RequestException, delay=None, multiplier=None):

        self.session = requests.Session()

        # Add default basic auth
        if auth:
            self.session.auth = auth

        # Add default headers
        headers = headers or {}
        if user_agent is not None:
            headers['User-Agent'] = user_agent
        self.session.headers.update(headers)

        self.parser = parser
        self.timeout = timeout
        self.verify = verify

        # Set up caching
        if cache:
            adapter = RoboHTTPAdapter(max_age=max_age, max_count=max_count)
            cache_patterns = cache_patterns or ['http://', 'https://']
            for pattern in cache_patterns:
                self.session.mount(pattern, adapter)
        elif max_age:
            raise ValueError('Parameter `max_age` is provided, '
                             'but caching is turned off')
        elif max_count:
            raise ValueError('Parameter `max_count` is provided, '
                             'but caching is turned off')

        # Configure history
        self.history = history
        if history is True:
            self._maxlen = None
        elif not history:
            self._maxlen = 1
        else:
            self._maxlen = history
        self._states = []
        self._cursor = -1

        # Set up retries
        if tries:
            decorator = retry(tries, errors, delay, multiplier)
            self._open, self.open = self.open, decorator(self.open)
            self._submit_form, self.submit_form = \
                self.submit_form, decorator(self.submit_form)

    def __repr__(self):
        try:
            return '<RoboBrowser url={0}>'.format(self.url)
        except RoboError:
            return '<RoboBrowser>'

    @property
    def state(self):
        if self._cursor == -1:
            raise RoboError('No state')
        try:
            return self._states[self._cursor]
        except IndexError:
            raise RoboError('Index out of range')

    @property
    def response(self):
        return self.state.response

    @property
    def url(self):
        return self.state.url

    @property
    def parsed(self):
        return self.state.parsed

    @property
    def find(self):
        """See ``BeautifulSoup::find``."""
        try:
            return self.parsed.find
        except AttributeError:
            raise RoboError

    @property
    def find_all(self):
        """See ``BeautifulSoup::find_all``."""
        try:
            return self.parsed.find_all
        except AttributeError:
            raise RoboError

    @property
    def select(self):
        """See ``BeautifulSoup::select``."""
        try:
            return self.parsed.select
        except AttributeError:
            raise RoboError

    def _build_url(self, url):
        """Build absolute URL.

        :param url: Full or partial URL
        :return: Full URL

        """
        return urlparse.urljoin(
            self.url,
            url
        )

    def open(self, url, timeout=None, verify=None):
        """Open a URL.

        :param str url: URL
        :param int timeout: Timeout in seconds
        :param bool verify: Verify SSL

        """
        response = self.session.get(
            url,
            timeout=timeout or self.timeout,
            verify=verify if verify is not None else self.verify,
        )
        self._update_state(response)

    def _update_state(self, response):
        """Update the state of the browser. Create a new state object, and
        append to or overwrite the browser's state history.

        :param requests.MockResponse: New response object

        """
        # Clear trailing states
        self._states = self._states[:self._cursor + 1]

        # Append new state
        state = RoboState(self, response)
        self._states.append(state)
        self._cursor += 1

        # Clear leading states
        if self._maxlen:
            decrement = len(self._states) - self._maxlen
            if decrement > 0:
                self._states = self._states[decrement:]
                self._cursor -= decrement

    def _traverse(self, n=1):
        """Traverse state history. Used by `back` and `forward` methods.

        :param int n: Cursor increment. Positive values move forward in the
            browser history; negative values move backward.

        """
        if not self.history:
            raise RoboError('Not tracking history')
        cursor = self._cursor + n
        if cursor >= len(self._states) or cursor < 0:
            raise RoboError('Index out of range')
        self._cursor = cursor

    def back(self, n=1):
        """Go back in browser history.

        :param int n: Number of pages to go back

        """
        self._traverse(-1 * n)

    def forward(self, n=1):
        """Go forward in browser history.

        :param int n: Number of pages to go forward

        """
        self._traverse(n)

    def get_link(self, text=None, *args, **kwargs):
        """Find an anchor or button by containing text, as well as standard
        BeautifulSoup arguments.

        :param text: String or regex to be matched in link text
        :return: BeautifulSoup tag if found, else None

        """
        return helpers.find(
            self.parsed, _link_ptn, text=text, *args, **kwargs
        )

    def get_links(self, text=None, *args, **kwargs):
        """Find anchors or buttons by containing text, as well as standard
        BeautifulSoup arguments.

        :param text: String or regex to be matched in link text
        :return: List of BeautifulSoup tags

        """
        return helpers.find_all(
            self.parsed, _link_ptn, text=text, *args, **kwargs
        )

    def get_form(self, id=None, *args, **kwargs):
        """Find form by ID, as well as standard BeautifulSoup arguments.

        :param str id: Form ID
        :return: BeautifulSoup tag if found, else None

        """
        if id:
            kwargs['id'] = id
        form = self.find(_form_ptn, *args, **kwargs)
        if form is not None:
            return Form(form)

    def get_forms(self, *args, **kwargs):
        """Find forms by standard BeautifulSoup arguments.

        :return: List of BeautifulSoup tags

        """
        forms = self.find_all(_form_ptn, *args, **kwargs)
        return [
            Form(form)
            for form in forms
        ]

    def follow_link(self, value=None, *args, **kwargs):
        """Find a click a link by tag, pattern, and/or BeautifulSoup
        arguments.

        :param value: BeautifulSoup tag, string, or regex. If tag, follow its
            href; if string or regex, search parsed document for match.

        """
        if isinstance(value, Tag):
            link = value
        elif isinstance(value, string_types):
            link = self.get_link(text=value, *args, **kwargs)
        elif isinstance(value, re._pattern_type):
            link = self.get_link(text=value, *args, **kwargs)
        else:
            link = self.get_link(*args, **kwargs)
        if link is None:
            raise RoboError('No results found')
        href = link.get('href')
        if href is None:
            raise RoboError('Link element must have href attribute')
        self.open(self._build_url(href))

    def submit_form(self, form):
        """Submit a form.

        :param Form form: Filled-out form object

        """
        # Get HTTP verb
        method = form.method.upper()

        # Send request
        url = self._build_url(form.action) or self.url
        form_data = form.serialize()
        response = self.session.request(method, url, **form_data.to_requests())

        # Update history
        self._update_state(response)

########NEW FILE########
__FILENAME__ = cache
"""
Caching utilities for robotic browsers. Credit to
https://github.com/Lukasa/httpcache
"""

import logging
import datetime
from requests.adapters import HTTPAdapter

from robobrowser.compat import OrderedDict, iteritems

logger = logging.getLogger(__name__)

# Modified from https://github.com/Lukasa/httpcache/blob/master/httpcache/cache.py
# RoboBrowser should only cache GET requests; HEAD and OPTIONS not exposed
CACHE_VERBS = ['GET']
CACHE_CODES = [200, 203, 300, 301, 410]

class RoboCache(object):

    def __init__(self, max_age=None, max_count=None):
        self.data = OrderedDict()
        self.max_age = max_age
        self.max_count = max_count

    def _reduce_age(self, now):
        """Reduce size of cache by date.

        :param datetime.datetime now: Current time

        """
        if self.max_age:
            for key, value in iteritems(self.data):
                if now - value['date'] > self.max_age:
                    del self.data[key]

    def _reduce_count(self):
        """Reduce size of cache by count.

        """
        if self.max_count:
            while len(self.data) > self.max_count:
                self.data.popitem(last=False)

    def store(self, response):
        """Store response in cache, skipping if code is forbidden.

        :param requests.Response response: HTTP response

        """
        if response.status_code not in CACHE_CODES:
            return
        now = datetime.datetime.now()
        self.data[response.url] = {
            'date': now,
            'response': response,
        }
        logger.info('Stored response in cache')
        self._reduce_age(now)
        self._reduce_count()

    def retrieve(self, request):
        """Look up request in cache, skipping if verb is forbidden.

        :param requests.Request request: HTTP request

        """
        if request.method not in CACHE_VERBS:
            return
        try:
            response = self.data[request.url]['response']
            logger.info('Retrieved response from cache')
            return response
        except KeyError:
            return None

    def clear(self):
        "Clear cache."
        self.data = OrderedDict()

class RoboHTTPAdapter(HTTPAdapter):

    def __init__(self, max_age=None, max_count=None, **kwargs):
        super(RoboHTTPAdapter, self).__init__(**kwargs)
        self.cache = RoboCache(max_age=max_age, max_count=max_count)

    def send(self, request, **kwargs):
        cached_resp = self.cache.retrieve(request)
        if cached_resp is not None:
            return cached_resp
        else:
            return super(RoboHTTPAdapter, self).send(request, **kwargs)

    def build_response(self, request, response):
        resp = super(RoboHTTPAdapter, self).build_response(request, response)
        self.cache.store(resp)
        return resp

########NEW FILE########
__FILENAME__ = compat
import sys

PY2 = int(sys.version[0]) == 2
PY26 = PY2 and int(sys.version_info[1]) < 7

if PY26:
    from .ordereddict import OrderedDict
else:
    from collections import OrderedDict
OrderedDict = OrderedDict

if PY2:
    import urlparse
    urlparse = urlparse
    string_types = (str, unicode)
    unicode = unicode
    basestring = basestring
    iterkeys = lambda d: d.iterkeys()
    itervalues = lambda d: d.itervalues()
    iteritems = lambda d: d.iteritems()
    builtin_name = '__builtin__'
else:
    import urllib.parse
    urlparse = urllib.parse
    string_types = (str,)
    unicode = str
    basestring = (str, bytes)
    iterkeys = lambda d: iter(d.keys())
    itervalues = lambda d: iter(d.values())
    iteritems = lambda d: iter(d.items())
    builtin_name = 'builtins'

def with_metaclass(meta, *bases):
    """Defines a metaclass.

    Creates a dummy class with a dummy metaclass. When subclassed, the dummy
    metaclass is used, which has a constructor that instantiates a
    new class from the original parent. This ensures that the dummy class and
    dummy metaclass are not in the inheritance tree.

    Credit to Armin Ronacher.

    """
    class metaclass(meta):
        __call__ = type.__call__
        __init__ = type.__init__
        def __new__(cls, name, this_bases, d):
            if this_bases is None:
                return type.__new__(cls, name, (), d)
            return meta(name, bases, d)
    return metaclass('temporary_class', None, {})

########NEW FILE########
__FILENAME__ = fields
"""
HTML form fields.
"""

import abc

from robobrowser.compat import with_metaclass, string_types
from .. import helpers


class ValueMeta(type):
    """Metaclass that creates a value property on class creation. Classes
    with this metaclass should define _get_value and optionally _set_value
    methods.

    """
    def __init__(cls, name, bases, dct):
        cls.value = property(
            getattr(cls, '_get_value'),
            getattr(cls, '_set_value', None),
        )
        super(ValueMeta, cls).__init__(name, bases, dct)


class FieldMeta(ValueMeta, abc.ABCMeta):
    """Multiply inherit from ValueMeta and ABCMeta; classes with this metaclass
    are automatically assigned a value property and can use methods from
    ABCMeta (e.g. abstractmethod).

    """
    pass

class BaseField(with_metaclass(FieldMeta)):
    """Abstract base class for form fields.

    :param parsed: String or BeautifulSoup tag

    """
    def __init__(self, parsed):
        self._parsed = helpers.ensure_soup(parsed)
        self._value = None
        self.name = self._get_name(parsed)

    def _get_name(self, parsed):
        return parsed.get('name')

    # Different form fields may serialize their values under different keys.
    # See `FormData` for details.
    form_data_key = None

    def serialize(self):
        return {self.name: self.value}

    # Property methods
    def _get_value(self):
        return self._value if self._value else ''

    def _set_value(self, value):
        self._value = value


class Input(BaseField):

    def __init__(self, parsed):
        super(Input, self).__init__(parsed)
        self.value = self._parsed.get('value')


class FileInput(BaseField):

    def _set_value(self, value):
        if hasattr(value, 'read'):
            self._value = value
        elif isinstance(value, string_types):
            self._value = open(value)
        else:
            raise ValueError('Value must be a file object or file path')

    # Serialize value to 'files' key for compatibility with file attachments
    # in requests.
    form_data_key = 'files'

    def serialize(self):
        return {self.name: self.value}


class MultiOptionField(BaseField):

    def __init__(self, parsed):
        super(MultiOptionField, self).__init__(parsed)
        self.options, self.labels, initial = self._get_options(parsed)
        self._set_initial(initial)

    @abc.abstractmethod
    def _get_options(self, parsed):
        return [], [], []

    def _set_initial(self, initial):
        self._value = None
        try:
            self.value = initial[0]
        except IndexError:
            pass

    def _value_to_index(self, value):
        if value in self.options:
            return self.options.index(value)
        if value in self.labels:
            index = self.labels.index(value)
            if index not in self.labels[index:]:
                return index
        raise ValueError

    # Property methods
    def _get_value(self):
        if self._value is None:
            return ''
        return self.options[self._value]

    def _set_value(self, value):
        self._value = self._value_to_index(value)


class MultiValueField(MultiOptionField):

    def _set_initial(self, initial):
        self.value = initial

    # Property methods
    def _get_value(self):
        return [
            self.options[idx]
            for idx in self._value
        ]

    def _set_value(self, value):
        if not isinstance(value, list):
            value = [value]
        self._value = [
            self._value_to_index(item)
            for item in value
        ]

    # List-like methods
    def append(self, value):
        index = self._value_to_index(value)
        if index in self._value:
            raise ValueError
        self._value.append(index)
        self._value.sort()

    def remove(self, value):
        index = self._value_to_index(value)
        self._value.remove(index)


class FlatOptionField(MultiOptionField):

    def _get_name(self, parsed):
        return parsed[0].get('name')

    def _get_options(self, parsed):
        options, labels, initial = [], [], []
        for option in parsed:
            value = option.get('value')
            checked = option.get('checked')
            options.append(value)
            labels.append(
                option.next.string
                if isinstance(option.next, string_types)
                else None
            )
            if checked is not None:
                initial.append(value)
        return options, labels, initial


class NestedOptionField(MultiOptionField):

    def _get_options(self, parsed):
        options, labels, initial = [], [], []
        for option in parsed.find_all('option'):
            value = option.get('value')
            selected = option.get('selected')
            options.append(value)
            labels.append(option.text)
            if selected is not None:
                initial.append(value)
        return options, labels, initial


class Textarea(Input):

    def __init__(self, parsed):
        super(Textarea, self).__init__(parsed)
        self.value = self._parsed.text.rstrip('\r').rstrip('\n')


class Checkbox(FlatOptionField, MultiValueField):
    pass


class Radio(FlatOptionField, MultiOptionField):
    pass


class Select(NestedOptionField, MultiOptionField):
    def _set_initial(self, initial):
        """If no option is selected initially, select the first option.

        """
        super(Select, self)._set_initial(initial)
        if not self._value:
            self.value = self.options[0]


class MultiSelect(NestedOptionField, MultiValueField):
    pass

########NEW FILE########
__FILENAME__ = form
"""
HTML forms.
"""

import re
import collections

from robobrowser.compat import OrderedDict, iteritems

from . import fields
from .. import helpers


_tags = ['input', 'textarea', 'select']
_tag_ptn = re.compile(
    '|'.join(_tags),
    re.I
)


def _group_flat_tags(tag, tags):
    """Extract tags sharing the same name as the provided tag. Used to collect
    options for radio and checkbox inputs.

    :param Tag tag: BeautifulSoup tag
    :param list tags: List of tags
    :return: List of matching tags

    """
    grouped = [tag]
    name = tag.get('name').lower()
    while tags and tags[0].get('name').lower() == name:
        grouped.append(tags.pop(0))
    return grouped


def _parse_fields(parsed):
    """Parse form fields from HTML.

    :param BeautifulSoup parsed: Parsed HTML
    :return OrderedDict: Collection of field objects

    """
    # Note: Call this `rv` to avoid name conflict with `fields` module
    rv = OrderedDict()

    # Prepare field tags
    tags = parsed.find_all(_tag_ptn)
    for tag in tags:
        helpers.lowercase_attr_names(tag)

    while tags:

        tag = tags.pop(0)
        tag_type = tag.name.lower()

        # Get name attribute, skipping if undefined
        name = tag.get('name')
        if name is None:
            continue
        name = name.lower()

        field = None

        # Create form field
        if tag_type == 'input':
            tag_type = tag.get('type', '').lower()
            if tag_type == 'file':
                field = fields.FileInput(tag)
            elif tag_type == 'radio':
                radios = _group_flat_tags(tag, tags)
                field = fields.Radio(radios)
            elif tag_type == 'checkbox':
                checkboxes = _group_flat_tags(tag, tags)
                field = fields.Checkbox(checkboxes)
            else:
                field = fields.Input(tag)
        elif tag_type == 'textarea':
            field = fields.Textarea(tag)
        elif tag_type == 'select':
            if tag.get('multiple') is not None:
                field = fields.MultiSelect(tag)
            else:
                field = fields.Select(tag)

        # Add field
        if field is not None:
            rv[name] = field

    return rv


class FormData(object):
    """Container for serialized form outputs that knows how to export to
    the format expected by Requests. By default, form values are stored in
    `payload`.

    """
    def __init__(self):
        self.payload = {}
        self.options = collections.defaultdict(dict)

    def add(self, data, key=None):
        """Add field values to container.

        :param dict data: Serialized values for field
        :param str key: Optional key; if not provided, values will be added
            to `self.payload`.

        """
        sink = self.options[key] if key is not None else self.payload
        sink.update(data)

    def to_requests(self, method='get'):
        """Export to Requests format.

        :param str method: Request method
        :returns: Dict of keyword arguments formatted for `requests.request`

        """
        out = {}
        payload_key = 'params' if method.lower() == 'get' else 'data'
        out[payload_key] = self.payload
        out.update(self.options)
        return out


class Form(object):
    """Representation of an HTML form."""

    def __init__(self, parsed):
        parsed = helpers.ensure_soup(parsed)
        if parsed.name != 'form':
            parsed = parsed.find('form')
        self.parsed = parsed
        self.action = self.parsed.get('action')
        self.method = self.parsed.get('method', 'get')
        self.fields = _parse_fields(self.parsed)

    def __repr__(self):
        state = ', '.join(
            [
                '{0}={1}'.format(name, field.value)
                for name, field in iteritems(self.fields)
            ]
        )
        if state:
            return '<RoboForm {0}>'.format(state)
        return '<RoboForm>'

    def keys(self):
        return self.fields.keys()

    def __getitem__(self, item):
        return self.fields[item]

    def __setitem__(self, key, value):
        self.fields[key].value = value

    def serialize(self):
        """Serialize each form field to a FormData container.

        :returns: FormData instance

        """
        form_data = FormData()
        for field in self.fields.values():
            form_data.add(field.serialize(), field.form_data_key)
        return form_data

########NEW FILE########
__FILENAME__ = helpers
"""
Miscellaneous helper functions
"""

import re
import time
import logging
import functools

from bs4 import BeautifulSoup
from bs4.element import Tag

from robobrowser.compat import string_types, iteritems

def match_text(text, tag):
    if isinstance(text, string_types):
        return text in tag.text
    if isinstance(text, re._pattern_type):
        return text.search(tag.text)

def find_all(soup, name=None, attrs=None, recursive=True, text=None,
              limit=None, **kwargs):
    """The `find` and `find_all` methods of `BeautifulSoup` don't handle the
    `text` parameter combined with other parameters. This is necessary for
    e.g. finding links containing a string or pattern. This method first
    searches by text content, and then by the standard BeautifulSoup arguments.

    """
    if text is None:
        return soup.find_all(
            name, attrs or {}, recursive, text, limit, **kwargs
        )
    if isinstance(text, string_types):
        text = re.compile(re.escape(text), re.I)
    tags = soup.find_all(
        name, attrs or {}, recursive, **kwargs
    )
    rv = []
    for tag in tags:
        if match_text(text, tag):
            rv.append(tag)
        if limit is not None and len(rv) >= limit:
            break
    return rv

def find(soup, name=None, attrs=None, recursive=True, text=None, **kwargs):
    """Modified find method; see `find_all`, above.

    """
    tags = find_all(
        soup, name, attrs or {}, recursive, text, 1, **kwargs
    )
    if tags:
        return tags[0]

def ensure_soup(value):
    """Coerce a value (or list of values) to BeautifulSoup (or list of
    BeautifulSoups).

    :param value: String, BeautifulSoup, Tag, or list of the above
    :return: BeautifulSoup or list of BeautifulSoups

    """
    if isinstance(value, Tag):
        return value
    if isinstance(value, list):
        return [
            ensure_soup(item)
            for item in value
        ]
    return BeautifulSoup(value)

def lowercase_attr_names(tag):
    """Lower-case all attribute names of the provided BeautifulSoup tag.
    Note: this mutates the tag's attribute names and does not return a new
    tag.

    :param Tag: BeautifulSoup tag

    """
    # Use list comprehension instead of dict comprehension for 2.6 support
    tag.attrs = dict([
        (key.lower(), value)
        for key, value in iteritems(tag.attrs)
    ])

def retry(tries, errors=None, delay=3, multiplier=2, logger=None):

    errors = errors or Exception
    logger = logger or logging.getLogger(__name__)

    def decorator(func):

        @functools.wraps(func)
        def decorated(*args, **kwargs):
            mdelay = delay
            for _ in range(tries - 1):
                try:
                    return func(*args, **kwargs)
                except errors as error:
                    logger.exception(error)
                    time.sleep(mdelay)
                    mdelay *= multiplier
                return func(*args, **kwargs)
        return decorated

    return decorator

########NEW FILE########
__FILENAME__ = ordereddict
# -*- coding: utf-8 -*-
'''A Python 2.6-compatible ordered dictionary.'''
# OrderedDict
# Copyright (c) 2009 Raymond Hettinger
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be
#     included in all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#     OTHER DEALINGS IN THE SOFTWARE.

from UserDict import DictMixin

class OrderedDict(dict, DictMixin):

    def __init__(self, *args, **kwds):
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__end
        except AttributeError:
            self.clear()
        self.update(*args, **kwds)

    def clear(self):
        self.__end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.__map = {}                 # key --> [key, prev, next]
        dict.clear(self)

    def __setitem__(self, key, value):
        if key not in self:
            end = self.__end
            curr = end[1]
            curr[2] = end[1] = self.__map[key] = [key, curr, end]
        dict.__setitem__(self, key, value)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        key, prev, next = self.__map.pop(key)
        prev[2] = next
        next[1] = prev

    def __iter__(self):
        end = self.__end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

    def __reversed__(self):
        end = self.__end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

    def popitem(self, last=True):
        if not self:
            raise KeyError('dictionary is empty')
        if last:
            key = reversed(self).next()
        else:
            key = iter(self).next()
        value = self.pop(key)
        return key, value

    def __reduce__(self):
        items = [[k, self[k]] for k in self]
        tmp = self.__map, self.__end
        del self.__map, self.__end
        inst_dict = vars(self).copy()
        self.__map, self.__end = tmp
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def keys(self):
        return list(self)

    setdefault = DictMixin.setdefault
    update = DictMixin.update
    pop = DictMixin.pop
    values = DictMixin.values
    items = DictMixin.items
    iterkeys = DictMixin.iterkeys
    itervalues = DictMixin.itervalues
    iteritems = DictMixin.iteritems

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, self.items())

    def copy(self):
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        if isinstance(other, OrderedDict):
            if len(self) != len(other):
                return False
            for p, q in  zip(self.items(), other.items()):
                if p != q:
                    return False
            return True
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

########NEW FILE########
__FILENAME__ = responses
"""
Copyright 2013 Dropbox, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from __future__ import (
    absolute_import, print_function, division, unicode_literals
)

import re

import six
if six.PY2:
    try:
        from six import cStringIO as BufferIO
    except ImportError:
        from six import StringIO as BufferIO
else:
    from io import BytesIO as BufferIO

from collections import namedtuple, Sequence, Sized
from functools import wraps
from requests.adapters import HTTPAdapter
from requests.exceptions import ConnectionError
from requests.packages.urllib3.response import HTTPResponse

Call = namedtuple('Call', ['request', 'response'])


class CallList(Sequence, Sized):
    def __init__(self):
        self._calls = []

    def __iter__(self):
        return iter(self._calls)

    def __len__(self):
        return len(self._calls)

    def __getitem__(self, idx):
        return self._calls[idx]

    def add(self, request, response):
        self._calls.append(Call(request, response))

    def reset(self):
        self._calls = []


class RequestsMock(object):
    DELETE = 'DELETE'
    GET = 'GET'
    HEAD = 'HEAD'
    OPTIONS = 'OPTIONS'
    PATCH = 'PATCH'
    POST = 'POST'
    PUT = 'PUT'

    def __init__(self):
        self._calls = CallList()
        self.reset()

    def reset(self):
        self._urls = []
        self._calls.reset()

    def add(self, method, url, body='', match_querystring=False,
            status=200, adding_headers=None, stream=False,
            content_type='text/plain'):
        # ensure the url has a default path set
        if url.count('/') == 2:
            url = url.replace('?', '/?', 1) if match_querystring \
                else url + '/'

        # body must be bytes
        if isinstance(body, six.text_type):
            body = body.encode('utf-8')

        self._urls.append({
            'url': url,
            'method': method,
            'body': body,
            'content_type': content_type,
            'match_querystring': match_querystring,
            'status': status,
            'adding_headers': adding_headers,
            'stream': stream,
        })

    @property
    def calls(self):
        return self._calls

    def activate(self, func):
        @wraps(func)
        def wrapped(*args, **kwargs):
            self._start()
            try:
                return func(*args, **kwargs)
            finally:
                self._stop()
                self.reset()
        return wrapped

    def _find_match(self, request):
        url = request.url
        url_without_qs = url.split('?', 1)[0]

        for match in self._urls:
            if request.method != match['method']:
                continue

            # TODO(dcramer): we could simplify this by compiling a single
            # regexp on register
            if match['match_querystring']:
                if not re.match(re.escape(match['url']), url):
                    continue
            else:
                if match['url'] != url_without_qs:
                    continue

            return match

        return None

    def _on_request(self, request, **kwargs):
        match = self._find_match(request)

        # TODO(dcramer): find the correct class for this
        if match is None:
            error_msg = 'Connection refused: {0}'.format(request.url)
            response = ConnectionError(error_msg)

            self._calls.add(request, response)
            raise response

        headers = {
            'Content-Type': match['content_type'],
        }
        if match['adding_headers']:
            headers.update(match['adding_headers'])

        response = HTTPResponse(
            status=match['status'],
            body=BufferIO(match['body']),
            headers=headers,
            preload_content=False,
        )

        adapter = HTTPAdapter()

        response = adapter.build_response(request, response)
        if not match['stream']:
            response.content  # NOQA

        self._calls.add(request, response)

        return response

    def _start(self):
        import mock
        self._patcher = mock.patch('requests.Session.send', self._on_request)
        self._patcher.start()

    def _stop(self):
        self._patcher.stop()


# expose default mock namespace
_default_mock = RequestsMock()
__all__ = []
for __attr in (a for a in dir(_default_mock) if not a.startswith('_')):
    __all__.append(__attr)
    globals()[__attr] = getattr(_default_mock, __attr)

########NEW FILE########
__FILENAME__ = test_browser
import mock
import unittest
from nose.tools import *

import re
import requests
import functools

from robobrowser import responses
from robobrowser.browser import RoboBrowser
from robobrowser.browser import RoboError
from tests.utils import ArgCatcher


def mock_responses(resps):
    """Decorator factory to make tests more DRY. Bundles responses.activate
    with a collection of response rules.

    :param list resps: List of response-formatted ArgCatcher arguments.

    """
    def wrapper(func):
        @responses.activate
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            for resp in resps:
                responses.add(*resp.args, **resp.kwargs)
            return func(*args, **kwargs)
        return wrapped
    return wrapper

mock_links = mock_responses(
    [
        ArgCatcher(
            responses.GET, 'http://robobrowser.com/links/',
            body=b'''
                <a href="/link1/">sheer heart attack</a>
                <a href="/link2/" class="song">night at the opera</a>
            '''
        ),
        ArgCatcher(responses.GET, 'http://robobrowser.com/link1/'),
        ArgCatcher(responses.GET, 'http://robobrowser.com/link2/'),
    ]
)

mock_forms = mock_responses(
    [
        ArgCatcher(
            responses.GET, 'http://robobrowser.com/get/',
            body=b'''
                <form id="bass" method="post" action="/post/">'
                    <input name="deacon" value="john" />
                </form>
                <form id="drums" method="post" action="/post/">'
                    <input name="deacon" value="john" />
                </form>
            '''
        ),
        ArgCatcher(
            responses.POST, 'http://robobrowser.com/post/',
        ),
    ]
)

mock_urls = mock_responses(
    [
        ArgCatcher(responses.GET, 'http://robobrowser.com/page1/'),
        ArgCatcher(responses.GET, 'http://robobrowser.com/page2/'),
        ArgCatcher(responses.GET, 'http://robobrowser.com/page3/'),
        ArgCatcher(responses.GET, 'http://robobrowser.com/page4/'),
    ]
)

class TestHeaders(unittest.TestCase):

    def test_headers(self):
        headers = {
            'X-Song': 'Innuendo',
            'X-Writer': 'Freddie',
        }
        browser = RoboBrowser(headers=headers)
        browser.open('http://robobrowser.com/links/')
        for key, value in headers.items():
            assert_equal(browser.session.headers[key], value)

    def test_user_agent(self):
        browser = RoboBrowser(user_agent='freddie')
        browser.open('http://robobrowser.com/links/')
        assert_true('User-Agent' in browser.session.headers)
        assert_equal(
            browser.session.headers['User-Agent'], 'freddie'
        )

    def test_default_headers(self):
        browser = RoboBrowser()
        assert_equal(browser.session.headers, requests.Session().headers)

class TestLinks(unittest.TestCase):

    @mock_links
    def setUp(self):
        self.browser = RoboBrowser()
        self.browser.open('http://robobrowser.com/links/')

    @mock_links
    def test_get_link(self):
        link = self.browser.get_link()
        assert_equal(link.get('href'), '/link1/')

    @mock_links
    def test_get_links(self):
        links = self.browser.get_links()
        assert_equal(len(links), 2)

    @mock_links
    def test_get_link_by_text(self):
        link = self.browser.get_link('opera')
        assert_equal(link.get('href'), '/link2/')

    @mock_links
    def test_follow_link_tag(self):
        link = self.browser.get_link(text=re.compile('sheer'))
        self.browser.follow_link(link)
        assert_equal(self.browser.url, 'http://robobrowser.com/link1/')

    @mock_links
    def test_follow_link_text(self):
        self.browser.follow_link('heart attack')
        assert_equal(self.browser.url, 'http://robobrowser.com/link1/')

    @mock_links
    def test_follow_link_regex(self):
        self.browser.follow_link(re.compile(r'opera'))
        assert_equal(self.browser.url, 'http://robobrowser.com/link2/')

    @mock_links
    def test_follow_link_bs_args(self):
        self.browser.follow_link(class_=re.compile(r'song'))
        assert_equal(self.browser.url, 'http://robobrowser.com/link2/')

class TestForms(unittest.TestCase):

    @mock_forms
    def setUp(self):
        self.browser = RoboBrowser()
        self.browser.open('http://robobrowser.com/get/')

    @mock_forms
    def test_get_forms(self):
        forms = self.browser.get_forms()
        assert_equal(len(forms), 2)

    @mock_forms
    def test_get_form_by_id(self):
        form = self.browser.get_form('bass')
        assert_equal(form.parsed.get('id'), 'bass')

    @mock_forms
    def test_submit_form(self):
        form = self.browser.get_form()
        self.browser.submit_form(form)
        assert_equal(
            self.browser.url,
            'http://robobrowser.com/post/?deacon=john'
        )

class TestHistoryInternals(unittest.TestCase):

    def setUp(self):
        self.browser = RoboBrowser(history=True)

    @mock_urls
    def test_open_appends_to_history(self):
        assert_equal(len(self.browser._states), 0)
        assert_equal(self.browser._cursor, -1)
        self.browser.open('http://robobrowser.com/page1/')
        assert_equal(len(self.browser._states), 1)
        assert_equal(self.browser._cursor, 0)

    @mock_forms
    def test_submit_appends_to_history(self):
        self.browser.open('http://robobrowser.com/get/')
        form = self.browser.get_form()
        self.browser.submit_form(form)

        assert_equal(len(self.browser._states), 2)
        assert_equal(self.browser._cursor, 1)

    @mock_urls
    def test_open_clears_history_after_back(self):
        self.browser.open('http://robobrowser.com/page1/')
        self.browser.open('http://robobrowser.com/page2/')
        self.browser.back()
        self.browser.open('http://robobrowser.com/page3/')
        assert_equal(len(self.browser._states), 2)
        assert_equal(self.browser._cursor, 1)

    @mock_urls
    def test_state_deque_max_length(self):
        browser = RoboBrowser(history=5)
        for _ in range(5):
            browser.open('http://robobrowser.com/page1/')
        assert_equal(len(browser._states), 5)
        browser.open('http://robobrowser.com/page2/')
        assert_equal(len(browser._states), 5)

    @mock_urls
    def test_state_deque_no_history(self):
        browser = RoboBrowser(history=False)
        for _ in range(5):
            browser.open('http://robobrowser.com/page1/')
            assert_equal(len(browser._states), 1)
            assert_equal(browser._cursor, 0)

class TestHistory(unittest.TestCase):

    @mock_urls
    def setUp(self):
        self.browser = RoboBrowser(history=True)
        self.browser.open('http://robobrowser.com/page1/')
        self.browser.open('http://robobrowser.com/page2/')
        self.browser.open('http://robobrowser.com/page3/')

    def test_back(self):
        self.browser.back()
        assert_equal(
            self.browser.url,
            'http://robobrowser.com/page2/'
        )

    def test_back_n(self):
        self.browser.back(n=2)
        assert_equal(
            self.browser.url,
            'http://robobrowser.com/page1/'
        )

    def test_forward(self):
        self.browser.back()
        self.browser.forward()
        assert_equal(
            self.browser.url,
            'http://robobrowser.com/page3/'
        )

    def test_forward_n(self):
        self.browser.back(n=2)
        self.browser.forward(n=2)
        assert_equal(
            self.browser.url,
            'http://robobrowser.com/page3/'
        )

    @mock_urls
    def test_open_clears_forward(self):
        self.browser.back(n=2)
        self.browser.open('http://robobrowser.com/page4/')
        assert_equal(
            self.browser._cursor,
            len(self.browser._states) - 1
        )
        assert_raises(
            RoboError,
            self.browser.forward
        )

    def test_back_error(self):
        assert_raises(
            RoboError,
            self.browser.back,
            5
        )


class TestTimeout(unittest.TestCase):

    @mock.patch('requests.Session.get')
    def test_no_timeout(self, mock_get):
        browser = RoboBrowser()
        browser.open('http://robobrowser.com/')
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', timeout=None, verify=True
        )

    @mock.patch('requests.Session.get')
    def test_instance_timeout(self, mock_get):
        browser = RoboBrowser(timeout=5)
        browser.open('http://robobrowser.com/')
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', timeout=5, verify=True
        )

    @mock.patch('requests.Session.get')
    def test_call_timeout(self, mock_get):
        browser = RoboBrowser(timeout=5)
        browser.open('http://robobrowser.com/', timeout=10)
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', timeout=10, verify=True
        )


class TestVerify(unittest.TestCase):

    @mock.patch('requests.Session.get')
    def test_no_verify(self, mock_get):
        browser = RoboBrowser()
        browser.open('http://robobrowser.com/')
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', verify=True, timeout=None
        )

    @mock.patch('requests.Session.get')
    def test_instance_verify(self, mock_get):
        browser = RoboBrowser(verify=True)
        browser.open('http://robobrowser.com/')
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', verify=True, timeout=None
        )

    @mock.patch('requests.Session.get')
    def test_call_verify(self, mock_get):
        browser = RoboBrowser(verify=True)
        browser.open('http://robobrowser.com/', verify=False)
        mock_get.assert_called_once_with(
            'http://robobrowser.com/', verify=False, timeout=None
        )

########NEW FILE########
__FILENAME__ = test_cache
import unittest
from nose.tools import *

import datetime

from robobrowser.browser import RoboBrowser
from robobrowser.cache import RoboCache
from tests.utils import KwargSetter

class TestAdapter(unittest.TestCase):

    def test_cache_on(self):
        self.browser = RoboBrowser(cache=True)
        self.browser.open('http://httpbin.org/')
        resp1 = self.browser.state.response
        self.browser.open('http://httpbin.org/')
        resp2 = self.browser.state.response
        assert_true(resp1 is resp2)

    def test_cache_off(self):
        self.browser = RoboBrowser(cache=False)
        self.browser.open('http://httpbin.org/')
        resp1 = self.browser.state.response
        self.browser.open('http://httpbin.org/')
        resp2 = self.browser.state.response
        assert_true(resp1 is not resp2)

class TestCache(unittest.TestCase):

    def setUp(self):
        self.cache = RoboCache()

    def test_store(self):
        url = 'http://robobrowser.com/'
        response = KwargSetter(url=url, status_code=200)
        now = datetime.datetime.now()
        self.cache.store(response)
        assert_true(url in self.cache.data)
        assert_equal(self.cache.data[url]['response'], response)
        date_diff = self.cache.data[url]['date'] - now
        assert_true(date_diff < datetime.timedelta(seconds=0.1))

    def test_store_invalid_verb(self):
        url = 'http://robobrowser.com/'
        response = KwargSetter(url=url, status_code=400)
        self.cache.store(response)
        assert_false(url in self.cache.data)

    def test_retrieve_not_stored(self):
        request = KwargSetter(url='http://robobrowser.com/', method='GET')
        retrieved = self.cache.retrieve(request)
        assert_equal(retrieved, None)

    def test_retrieve_stored(self):
        request = KwargSetter(url='http://robobrowser.com/', method='GET')
        response = KwargSetter(url='http://robobrowser.com/', status_code=200)
        self.cache.store(response)
        retrieved = self.cache.retrieve(request)
        assert_equal(retrieved, response)

    def test_retrieve_invalid_code(self):
        request = KwargSetter(url='http://robobrowser.com/', method='GET')
        response = KwargSetter(url='http://robobrowser.com/', status_code=400)
        self.cache.store(response)
        retrieved = self.cache.retrieve(request)
        assert_equal(retrieved, None)

    def test_reduce_age(self):
        for idx in range(5):
            response = KwargSetter(url=idx, status_code=200)
            self.cache.store(response)
            # time.sleep(0.1)
        assert_equal(len(self.cache.data), 5)
        now = datetime.datetime.now()
        self.cache.max_age = now - self.cache.data[2]['date']
        self.cache._reduce_age(now)
        assert_equal(len(self.cache.data), 3)
        # Cast keys to list for 3.3 compatibility
        assert_equal(list(self.cache.data.keys()), [2, 3, 4])

    def test_reduce_count(self):
        for idx in range(5):
            response = KwargSetter(url=idx, status_code=200)
            self.cache.store(response)
        assert_equal(len(self.cache.data), 5)
        self.cache.max_count = 3
        self.cache._reduce_count()
        assert_equal(len(self.cache.data), 3)
        # Cast keys to list for 3.3 compatibility
        assert_equal(list(self.cache.data.keys()), [2, 3, 4])

########NEW FILE########
__FILENAME__ = test_forms
import mock
import unittest
from nose.tools import *

import tempfile
from bs4 import BeautifulSoup

from robobrowser.compat import builtin_name
from robobrowser.forms.form import Form, FormData, fields, _parse_fields


class TestFormData(unittest.TestCase):

    def setUp(self):
        self.form_data = FormData()
        self.form_data.add({'red': 'special'})

    def test_add_payload(self):
        self.form_data.add({'lazing': 'sunday'})
        assert_true('lazing' in self.form_data.payload)
        assert_equal(self.form_data.payload['lazing'], 'sunday')

    def test_add_by_key(self):
        self.form_data.add({'lazing': 'sunday'}, 'afternoon')
        assert_false('lazing' in self.form_data.payload)
        assert_true('afternoon' in self.form_data.options)
        assert_true('lazing' in self.form_data.options['afternoon'])
        assert_equal(
            self.form_data.options['afternoon']['lazing'],
            'sunday'
        )

    def test_requests_get(self):
        out = self.form_data.to_requests('get')
        assert_true('params' in out)
        assert_equal(out['params'], {'red': 'special'})

    def test_requests_post(self):
        out = self.form_data.to_requests('post')
        assert_true('data' in out)
        assert_equal(out['data'], {'red': 'special'})


class TestForm(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <form>
                <input name="vocals" />
                <input name="guitar" type="file" />
                <select name="drums">
                    <option value="roger">Roger<br />
                    <option value="john">John<br />
                </select>
                <input type="radio" name="bass" value="Roger">Roger<br />
                <input type="radio" name="bass" value="John">John<br />
            </form>
        '''
        self.form = Form(self.html)

    def test_fields(self):
        keys = set(('vocals', 'guitar', 'drums', 'bass'))
        assert_equal(set(self.form.fields.keys()), keys)
        assert_equal(set(self.form.keys()), keys)

    def test_repr(self):
        assert_equal(
            repr(self.form),
            '<RoboForm vocals=, guitar=, drums=roger, bass=>'
        )

    def test_repr_empty(self):
        assert_equal(
            repr(Form('<form></form>')),
            '<RoboForm>'
        )


class TestParser(unittest.TestCase):

    def setUp(self):
        self.form = Form('<form></form>')

    def test_method_default(self):
        assert_equal(self.form.method, 'get')

    def test_method(self):
        form = Form('<form method="put"></form>')
        assert_equal(form.method, 'put')

    def test_action(self):
        form = Form('<form action="/"></form>')
        assert_equal(form.action, '/')

    def test_parse_input(self):
        html = '<input name="band" value="queen" />'
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 1)
        assert_true(isinstance(_fields['band'], fields.Input))

    def test_parse_file_input(self):
        html = '<input name="band" type="file" />'
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 1)
        assert_true(isinstance(_fields['band'], fields.FileInput))

    def test_parse_textarea(self):
        html = '<textarea name="band">queen</textarea>'
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 1)
        assert_true(isinstance(_fields['band'], fields.Textarea))

    def test_parse_radio(self):
        html = '''
            <input type="radio" name="favorite_member" />freddie<br />
            <input type="radio" name="favorite_member" />brian<br />
            <input type="radio" name="favorite_member" />roger<br />
            <input type="radio" name="favorite_member" />john<br />
            <input type="radio" name="favorite_song" />rhapsody<br />
            <input type="radio" name="favorite_song" />killer<br />
        '''
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 2)
        assert_true(isinstance(_fields['favorite_member'], fields.Radio))
        assert_true(isinstance(_fields['favorite_song'], fields.Radio))
        assert_equal(
            len(_fields['favorite_member']._parsed), 4
        )
        assert_equal(
            len(_fields['favorite_song']._parsed), 2
        )

    def test_parse_checkbox(self):
        html = '''
            <input type="checkbox" name="favorite_member" />freddie<br />
            <input type="checkbox" name="favorite_member" />brian<br />
            <input type="checkbox" name="favorite_member" />roger<br />
            <input type="checkbox" name="favorite_member" />john<br />
            <input type="checkbox" name="favorite_song" />rhapsody<br />
            <input type="checkbox" name="favorite_song" />killer<br />
        '''
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 2)
        assert_true(isinstance(_fields['favorite_member'], fields.Checkbox))
        assert_true(isinstance(_fields['favorite_song'], fields.Checkbox))
        assert_equal(
            len(_fields['favorite_member']._parsed), 4
        )
        assert_equal(
            len(_fields['favorite_song']._parsed), 2
        )

    def test_parse_select(self):
        html = '''
            <select name="instrument">
                <option value="vocals">vocals</option>
                <option value="guitar">guitar</option>
                <option value="drums">drums</option>
                <option value="bass">bass</option>
            </select>
        '''
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 1)
        assert_true(isinstance(_fields['instrument'], fields.Select))

    def test_parse_select_multi(self):
        html = '''
            <select name="instrument" multiple>
                <option value="vocals">vocals</option>
                <option value="guitar">guitar</option>
                <option value="drums">drums</option>
                <option value="bass">bass</option>
            </select>
        '''
        _fields = _parse_fields(BeautifulSoup(html))
        assert_equal(len(_fields), 1)
        assert_true(isinstance(_fields['instrument'], fields.MultiSelect))


class TestInput(unittest.TestCase):

    def setUp(self):
        self.html = '<input name="brian" value="may" />'
        self.input = fields.Input(BeautifulSoup(self.html).find('input'))

    def test_name(self):
        assert_equal(self.input.name, 'brian')

    def test_initial(self):
        assert_equal(self.input._value, 'may')
        assert_equal(self.input.value, 'may')

    def test_value(self):
        self.input.value = 'red special'
        assert_equal(self.input._value, 'red special')
        assert_equal(self.input.value, 'red special')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'brian': 'may'}
        )


class TestInputBlank(unittest.TestCase):

    def setUp(self):
        self.html = '<input name="blank" />'
        self.input = fields.Input(BeautifulSoup(self.html).find('input'))

    def test_initial(self):
        assert_equal(self.input._value, None)
        assert_equal(self.input.value, '')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'blank': ''}
        )


class TestTextarea(unittest.TestCase):

    def setUp(self):
        self.html = '<textarea name="roger">taylor</textarea>'
        self.input = fields.Textarea(BeautifulSoup(self.html).find('textarea'))

    def test_name(self):
        assert_equal(self.input.name, 'roger')

    def test_initial(self):
        assert_equal(self.input._value, 'taylor')
        assert_equal(self.input.value, 'taylor')

    def test_value(self):
        self.input.value = 'the drums'
        assert_equal(self.input._value, 'the drums')
        assert_equal(self.input.value, 'the drums')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'roger': 'taylor'}
        )


class TestTextareaBlank(unittest.TestCase):

    def setUp(self):
        self.html = '<textarea name="blank"></textarea>'
        self.input = fields.Textarea(BeautifulSoup(self.html).find('textarea'))

    def test_initial(self):
        assert_equal(self.input._value, '')
        assert_equal(self.input.value, '')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'blank': ''}
        )


class TestSelect(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <select name="john">
                <option value="tie">your mother down</option>
                <option value="you're" selected>my best friend</option>
                <option value="the">millionaire waltz</option>
            </select>
        '''
        self.input = fields.Select(BeautifulSoup(self.html).find('select'))

    def test_name(self):
        assert_equal(self.input.name, 'john')

    def test_options(self):
        assert_equal(
            self.input.options,
            ['tie', "you're", 'the']
        )

    def test_initial(self):
        assert_equal(self.input._value, 1)
        assert_equal(self.input.value, "you're")

    def test_value(self):
        self.input.value = 'the'
        assert_equal(self.input._value, 2)
        assert_equal(self.input.value, 'the')

    def test_value_label(self):
        self.input.value = 'millionaire waltz'
        assert_equal(self.input._value, 2)
        assert_equal(self.input.value, 'the')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'john': "you're"}
        )


class TestSelectBlank(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <select name="john">
                <option value="tie">your mother down</option>
                <option value="you're">my best friend</option>
                <option value="the">millionaire waltz</option>
            </select>
        '''
        self.input = fields.Select(BeautifulSoup(self.html).find('select'))

    def test_name(self):
        assert_equal(self.input.name, 'john')

    def test_initial(self):
        assert_equal(self.input._value, 0)
        assert_equal(self.input.value, 'tie')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'john': 'tie'}
        )


class TestMultiSelect(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <select name="john" multiple>
                <option value="tie">your mother down</option>
                <option value="you're" selected>my best friend</option>
                <option value="the">millionaire waltz</option>
            </select>
        '''
        self.input = fields.MultiSelect(BeautifulSoup(self.html).find('select'))


class TestMixedCase(unittest.TestCase):

    def test_upper_type(self):
        html = '''
            <input type="RADIO" name="members" value="mercury" />vocals<br />
        '''
        input = fields.Radio(BeautifulSoup(html).find_all('input'))
        assert_equal(input.name, 'members')

    def test_upper_name(self):
        html = '''
            <input type="radio" NAME="members" value="mercury" />vocals<br />
        '''
        input = fields.Radio(BeautifulSoup(html).find_all('input'))
        assert_equal(input.name, 'members')

    def test_mixed_radio_names(self):
        html = '''
            <input type="radio" NAME="members" value="mercury" />vocals<br />
            <input type="radio" NAME="MEMBERS" value="may" />guitar<br />
        '''
        input = fields.Radio(BeautifulSoup(html).find_all('input'))
        assert_equal(input.name, 'members')
        assert_equal(
            input.options,
            ['mercury', 'may']
        )


class TestRadio(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <input type="radio" name="members" value="mercury" checked />vocals<br />
            <input type="radio" name="members" value="may" />guitar<br />
            <input type="radio" name="members" value="taylor" />drums<br />
            <input type="radio" name="members" value="deacon" checked />bass<br />
        '''
        self.input = fields.Radio(BeautifulSoup(self.html).find_all('input'))

    def test_name(self):
        assert_equal(self.input.name, 'members')

    def test_options(self):
        assert_equal(
            self.input.options,
            ['mercury', 'may', 'taylor', 'deacon']
        )

    def test_initial(self):
        assert_equal(self.input.value, 'mercury')

    def test_value(self):
        self.input.value = 'taylor'
        assert_equal(self.input._value, 2)
        assert_equal(self.input.value, 'taylor')

    def test_value_label(self):
        self.input.value = 'drums'
        assert_equal(self.input._value, 2)
        assert_equal(self.input.value, 'taylor')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'members': 'mercury'}
        )


class TestRadioBlank(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <input type="radio" name="member" value="mercury" />vocals<br />
            <input type="radio" name="member" value="may" />guitar<br />
            <input type="radio" name="member" value="taylor" />drums<br />
            <input type="radio" name="member" value="deacon" />bass<br />
        '''
        self.input = fields.Radio(BeautifulSoup(self.html).find_all('input'))

    def test_initial(self):
        assert_equal(self.input.value, '')

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'member': ''}
        )


class TestCheckbox(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <input type="checkbox" name="member" value="mercury" checked />vocals<br />
            <input type="checkbox" name="member" value="may" />guitar<br />
            <input type="checkbox" name="member" value="taylor" />drums<br />
            <input type="checkbox" name="member" value="deacon" checked />bass<br />
        '''
        self.input = fields.Checkbox(BeautifulSoup(self.html).find_all('input'))

    def test_name(self):
        assert_equal(self.input.name, 'member')

    def test_options(self):
        assert_equal(
            self.input.options,
            ['mercury', 'may', 'taylor', 'deacon']
        )

    def test_initial(self):
        assert_equal(
            self.input.value,
            ['mercury', 'deacon']
        )

    def test_value(self):
        self.input.value = 'taylor'
        assert_equal(self.input._value, [2])
        assert_equal(self.input.value, ['taylor'])

    def test_value(self):
        self.input.value = ['taylor', 'deacon']
        assert_equal(self.input._value, [2, 3])
        assert_equal(self.input.value, ['taylor', 'deacon'])

    def test_value_label(self):
        self.input.value = 'drums'
        assert_equal(self.input._value, [2])
        assert_equal(self.input.value, ['taylor'])

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'member': ['mercury', 'deacon']}
        )


class TestCheckboxBlank(unittest.TestCase):

    def setUp(self):
        self.html = '''
            <input type="checkbox" name="member" value="mercury" />vocals<br />
            <input type="checkbox" name="member" value="may" />guitar<br />
            <input type="checkbox" name="member" value="taylor" />drums<br />
            <input type="checkbox" name="member" value="deacon" />bass<br />
        '''
        self.input = fields.Checkbox(BeautifulSoup(self.html).find_all('input'))

    def test_initial(self):
        assert_equal(
            self.input.value, []
        )

    def test_serialize(self):
        assert_equal(
            self.input.serialize(),
            {'member': []}
        )


class TestFileInput(unittest.TestCase):

    def setUp(self):
        self.html = '<input name="song" type="file" />'
        self.input = fields.FileInput(BeautifulSoup(self.html).find('input'))

    def test_name(self):
        assert_equal(self.input.name, 'song')

    def test_value_file(self):
        file = tempfile.TemporaryFile('r')
        self.input.value = file
        assert_equal(self.input._value, file)
        assert_equal(self.input.value, file)

    @mock.patch('{0}.open'.format(builtin_name))
    def test_value_name(self, mock_open):
        file = tempfile.TemporaryFile('r')
        mock_open.return_value = file
        self.input.value = 'temp'
        assert_equal(self.input._value, file)
        assert_equal(self.input.value, file)

    def test_serialize(self):
        file = tempfile.TemporaryFile('r')
        self.input.value = file
        assert_equal(
            self.input.serialize(),
            {'song': file}
        )

########NEW FILE########
__FILENAME__ = utils
from robobrowser.compat import iteritems

class ArgCatcher(object):
    """Simple class for memorizing positional and keyword arguments. Used to
    capture responses for mock_responses.

    """
    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

class KwargSetter(object):
    """Simple class for memorizing keyword arguments as instance attributes.
    Used to mock requests and responses for testing.

    """
    def __init__(self, **kwargs):
        for key, value in iteritems(kwargs):
            setattr(self, key, value)

########NEW FILE########
