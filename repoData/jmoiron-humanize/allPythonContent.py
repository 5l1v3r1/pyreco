__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
from datetime import datetime

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
projpath = os.path.abspath('..')
sys.path.append(projpath)

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'humanize'
copyright = u'2010 Jason Moiron'

# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
version = None
for line in open(os.path.join(projpath, 'setup.py'), 'r'):
    if line.startswith('version'):
        exec line
if version is None:
    version = '0.1'
# The full version, including alpha/beta/rc tags.
release = version

print ("Building release: %s, version: %s" % (release, version))

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
#html_theme = 'default'
html_theme = 'nature'
html_theme_path = ['_theme']
#html_theme_options = {}

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'humanizedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'humanize.tex', u'humanize Documentation',
   u'Jason Moiron', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


########NEW FILE########
__FILENAME__ = compat
import sys

if sys.version_info < (3,):
    string_types = (basestring,)
else:
    string_types = (str,)


########NEW FILE########
__FILENAME__ = filesize
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Bits & Bytes related humanization."""

suffixes = {
    'decimal': ('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'),
    'binary': ('KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'),
    'gnu': "KMGTPEZY",
}


def naturalsize(value, binary=False, gnu=False, format='%.1f'):
    """Format a number of byteslike a human readable filesize (eg. 10 kB).  By
    default, decimal suffixes (kB, MB) are used.  Passing binary=true will use
    binary suffixes (KiB, MiB) are used and the base will be 2**10 instead of
    10**3.  If ``gnu`` is True, the binary argument is ignored and GNU-style
    (ls -sh style) prefixes are used (K, M) with the 2**10 definition.
    Non-gnu modes are compatible with jinja2's ``filesizeformat`` filter."""
    if gnu: suffix = suffixes['gnu']
    elif binary: suffix = suffixes['binary']
    else: suffix = suffixes['decimal']

    base = 1024 if (gnu or binary) else 1000
    bytes = float(value)

    if bytes == 1 and not gnu: return '1 Byte'
    elif bytes < base and not gnu: return '%d Bytes' % bytes
    elif bytes < base and gnu: return '%dB' % bytes

    for i,s in enumerate(suffix):
        unit = base ** (i+2)
        if bytes < unit and not gnu:
            return (format + ' %s') % ((base * bytes / unit), s)
        elif bytes < unit and gnu:
            return (format + '%s') % ((base * bytes / unit), s)
    if gnu:
        return (format + '%s') % ((base * bytes / unit), s)
    return (format + ' %s') % ((base * bytes / unit), s)


########NEW FILE########
__FILENAME__ = i18n
# -*- coding: utf-8 -*-
import gettext as gettext_module
from threading import local
import os.path

__all__ = ['activate', 'deactivate', 'gettext', 'ngettext']

_TRANSLATIONS = {None: gettext_module.NullTranslations()}
_CURRENT = local()

_DEFAULT_LOCALE_PATH = os.path.join(os.path.dirname(__file__), 'locale')


def get_translation():
    try:
        return _TRANSLATIONS[_CURRENT.locale]
    except (AttributeError, KeyError):
        return _TRANSLATIONS[None]


def activate(locale, path=None):
    """Set 'locale' as current locale. Search for locale in directory 'path'
    @param locale: language name, eg 'en_GB'"""
    if path is None:
        path = _DEFAULT_LOCALE_PATH
    if locale not in _TRANSLATIONS:
        translation = gettext_module.translation('humanize', path, [locale])
        _TRANSLATIONS[locale] = translation
    _CURRENT.locale = locale
    return _TRANSLATIONS[locale]


def deactivate():
    _CURRENT.locale = None


def gettext(message):
    return get_translation().gettext(message)


def pgettext(msgctxt, message):
    """'Particular gettext' function.
    It works with 'msgctxt' .po modifiers and allow duplicate keys with
    different translations.
    Python 2 don't have support for this GNU gettext function, so we
    reimplement it. It works by joining msgctx and msgid by '4' byte."""
    key = msgctxt + '\x04' + message
    translation = get_translation().gettext(key)
    return message if translation == key else translation


def ngettext(message, plural, num):
    return get_translation().ngettext(message, plural, num)


def gettext_noop(message):
    """Example usage:
    CONSTANTS = [gettext_noop('first'), gettext_noop('second')]
    def num_name(n):
        return gettext(CONSTANTS[n])"""
    return message

########NEW FILE########
__FILENAME__ = number
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Humanizing functions for numbers."""

import re
from fractions import Fraction
from .import compat
from .i18n import gettext as _, gettext_noop as N_, pgettext as P_


def ordinal(value):
    """Converts an integer to its ordinal as a string. 1 is '1st', 2 is '2nd',
    3 is '3rd', etc. Works for any integer or anything int() will turn into an
    integer.  Anything other value will have nothing done to it."""
    try:
        value = int(value)
    except (TypeError, ValueError):
        return value
    t = (P_('0', 'th'),
         P_('1', 'st'),
         P_('2', 'nd'),
         P_('3', 'rd'),
         P_('4', 'th'),
         P_('5', 'th'),
         P_('6', 'th'),
         P_('7', 'th'),
         P_('8', 'th'),
         P_('9', 'th'))
    if value % 100 in (11, 12, 13):  # special case
        return "%d%s" % (value, t[0])
    return '%d%s' % (value, t[value % 10])


def intcomma(value):
    """Converts an integer to a string containing commas every three digits.
    For example, 3000 becomes '3,000' and 45000 becomes '45,000'.  To maintain
    some compatability with Django's intcomma, this function also accepts
    floats."""
    try:
        if isinstance(value, compat.string_types):
            float(value.replace(',', ''))
        else:
            float(value)
    except (TypeError, ValueError):
        return value
    orig = str(value)
    new = re.sub("^(-?\d+)(\d{3})", '\g<1>,\g<2>', orig)
    if orig == new:
        return new
    else:
        return intcomma(new)

powers = [10 ** x for x in (6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 100)]
human_powers = (N_('million'), N_('billion'), N_('trillion'), N_('quadrillion'),
                N_('quintillion'), N_('sextillion'), N_('septillion'),
                N_('octillion'), N_('nonillion'), N_('decillion'), N_('googol'))


def intword(value, format='%.1f'):
    """Converts a large integer to a friendly text representation. Works best for
    numbers over 1 million. For example, 1000000 becomes '1.0 million', 1200000
    becomes '1.2 million' and '1200000000' becomes '1.2 billion'.  Supports up to
    decillion (33 digits) and googol (100 digits).  You can pass format to change
    the number of decimal or general format of the number portion.  This function
    returns a string unless the value passed was unable to be coaxed into an int."""
    try:
        value = int(value)
    except (TypeError, ValueError):
        return value

    if value < powers[0]:
        return str(value)
    for ordinal, power in enumerate(powers[1:], 1):
        if value < power:
            chopped = value / float(powers[ordinal - 1])
            return (' '.join([format, _(human_powers[ordinal - 1])])) % chopped
    return str(value)


def apnumber(value):
    """For numbers 1-9, returns the number spelled out. Otherwise, returns the
    number. This follows Associated Press style.  This always returns a string
    unless the value was not int-able, unlike the Django filter."""
    try:
        value = int(value)
    except (TypeError, ValueError):
        return value
    if not 0 < value < 10:
        return str(value)
    return (_('one'), _('two'), _('three'), _('four'), _('five'), _('six'),
            _('seven'), _('eight'), _('nine'))[value - 1]


def fractional(value):
    '''
    There will be some cases where one might not want to show
        ugly decimal places for floats and decimals.
    This function returns a human readable fractional number
        in form of fractions and mixed fractions.
    Pass in a string, or a number or a float, and this function returns
        a string representation of a fraction
        or whole number
        or a mixed fraction
    Examples:
        fractional(0.3) will return '1/3'
        fractional(1.3) will return '1 3/10'
        fractional(float(1/3)) will return '1/3'
        fractional(1) will return '1'
    This will always return a string.
    '''
    try:
        number = float(value)
    except (TypeError, ValueError):
        return value
    wholeNumber = int(number)
    frac = Fraction(number - wholeNumber).limit_denominator(1000)
    numerator = frac._numerator
    denominator = frac._denominator
    if wholeNumber and not numerator and denominator == 1:
        return '%.0f' % wholeNumber  # this means that an integer was passed in (or variants of that integer like 1.0000)
    elif not wholeNumber:
        return '%.0f/%.0f' % (numerator, denominator)
    else:
        return '%.0f %.0f/%.0f' % (wholeNumber, numerator, denominator)

########NEW FILE########
__FILENAME__ = time
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Time humanizing functions.  These are largely borrowed from Django's
``contrib.humanize``."""

import time
from datetime import datetime, timedelta, date
from .i18n import ngettext, gettext as _

__all__ = ['naturaldelta', 'naturaltime', 'naturalday', 'naturaldate']

def _now():
    return datetime.now()

def abs_timedelta(delta):
    """Returns an "absolute" value for a timedelta, always representing a
    time distance."""
    if delta.days < 0:
        now = _now()
        return now - (now + delta)
    return delta

def date_and_delta(value):
    """Turn a value into a date and a timedelta which represents how long ago
    it was.  If that's not possible, return (None, value)."""
    now = _now()
    if isinstance(value, datetime):
        date = value
        delta = now - value
    elif isinstance(value, timedelta):
        date = now - value
        delta = value
    else:
        try:
            value = int(value)
            delta = timedelta(seconds=value)
            date = now - delta
        except (ValueError, TypeError):
            return (None, value)
    return date, abs_timedelta(delta)

def naturaldelta(value, months=True):
    """Given a timedelta or a number of seconds, return a natural
    representation of the amount of time elapsed.  This is similar to
    ``naturaltime``, but does not add tense to the result.  If ``months``
    is True, then a number of months (based on 30.5 days) will be used
    for fuzziness between years."""
    now = _now()
    date, delta = date_and_delta(value)
    if date is None:
        return value

    use_months = months

    seconds = abs(delta.seconds)
    days = abs(delta.days)
    years = days // 365
    days = days % 365
    months = int(days // 30.5)

    if not years and days < 1:
        if seconds == 0:
            return _("a moment")
        elif seconds == 1:
            return _("a second")
        elif seconds < 60:
            return ngettext("%d second", "%d seconds", seconds) % seconds
        elif 60 <= seconds < 120:
            return _("a minute")
        elif 120 <= seconds < 3600:
            minutes = seconds // 60
            return ngettext("%d minute", "%d minutes", minutes) % minutes
        elif 3600 <= seconds < 3600 * 2:
            return _("an hour")
        elif 3600 < seconds:
            hours = seconds // 3600
            return ngettext("%d hour", "%d hours", hours) % hours
    elif years == 0:
        if days == 1:
            return _("a day")
        if not use_months:
            return ngettext("%d day", "%d days", days) % days
        else:
            if not months:
                return ngettext("%d day", "%d days", days) % days
            elif months == 1:
                return _("a month")
            else:
                return ngettext("%d month", "%d months", months) % months
    elif years == 1:
        if not months and not days:
            return _("a year")
        elif not months:
            return ngettext("1 year, %d day", "1 year, %d days", days) % days
        elif use_months:
            if months == 1:
                return _("1 year, 1 month")
            else:
                return ngettext("1 year, %d month",
                                "1 year, %d months", months) % months
        else:
            return ngettext("1 year, %d day", "1 year, %d days", days) % days
    else:
        return ngettext("%d year", "%d years", years) % years


def naturaltime(value, future=False, months=True):
    """Given a datetime or a number of seconds, return a natural representation
    of that time in a resolution that makes sense.  This is more or less
    compatible with Django's ``naturaltime`` filter.  ``future`` is ignored for
    datetimes, where the tense is always figured out based on the current time.
    If an integer is passed, the return value will be past tense by default,
    unless ``future`` is set to True."""
    now = _now()
    date, delta = date_and_delta(value)
    if date is None:
        return value
    # determine tense by value only if datetime/timedelta were passed
    if isinstance(value, (datetime, timedelta)):
        future = date > now

    ago = _('%s from now') if future else _('%s ago')
    delta = naturaldelta(delta)

    if delta == _("a moment"):
        return _("now")

    return ago % delta

def naturalday(value, format='%b %d'):
    """For date values that are tomorrow, today or yesterday compared to
    present day returns representing string. Otherwise, returns a string
    formatted according to ``format``."""
    try:
        value = date(value.year, value.month, value.day)
    except AttributeError:
        # Passed value wasn't date-ish
        return value
    except (OverflowError, ValueError):
        # Date arguments out of range
        return value
    delta = value - date.today()
    if delta.days == 0:
        return _('today')
    elif delta.days == 1:
        return _('tomorrow')
    elif delta.days == -1:
        return _('yesterday')
    return value.strftime(format)

def naturaldate(value):
    """Like naturalday, but will append a year for dates that are a year
    ago or more."""
    try:
        value = date(value.year, value.month, value.day)
    except AttributeError:
        # Passed value wasn't date-ish
        return value
    except (OverflowError, ValueError):
        # Date arguments out of range
        return value
    delta = abs_timedelta(value - date.today())
    if delta.days >= 365:
        return naturalday(value, '%b %d %Y')
    return naturalday(value)



########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests base classes."""

from unittest import TestCase

class HumanizeTestCase(TestCase):

    def assertManyResults(self, function, args, results):
        """Goes through a list of arguments and makes sure that function called
        upon them lists a similarly ordered list of results.  If more than one
        argument is required, each position in args may be a tuple."""
        for arg, result in zip(args, results):
            if isinstance(arg, tuple):
                self.assertEqual(function(*arg), result)
            else:
                self.assertEqual(function(arg), result)

    def assertEqualDatetime(self, dt1, dt2):
        self.assertEqual((dt1 - dt2).seconds, 0)

    def assertEqualTimedelta(self, td1, td2):
        self.assertEqual(td1.days, td2.days)
        self.assertEqual(td1.seconds, td2.seconds)


########NEW FILE########
__FILENAME__ = filesize
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests for filesize humanizing."""

from humanize import filesize
from .base import HumanizeTestCase

class FilesizeTestCase(HumanizeTestCase):
    def test_naturalsize(self):
        tests = (300, 3000, 3000000, 3000000000, 3000000000000, (300, True),
            (3000, True), (3000000, True), (300, False, True), (3000, False, True),
            (3000000, False, True), (1024, False, True), (10**26 * 30, False, True),
            (10**26 * 30, True), 10**26 * 30,
            (3141592, False, False, '%.2f'), (3000, False, True, '%.3f'),
            (3000000000, False, True, '%.0f'), (10**26 * 30, True, False, '%.3f'),)
        results = ('300 Bytes', '3.0 kB', '3.0 MB', '3.0 GB', '3.0 TB',
            '300 Bytes', '2.9 KiB', '2.9 MiB', '300B', '2.9K', '2.9M', '1.0K', '2481.5Y',
            '2481.5 YiB', '3000.0 YB',
            '3.14 MB', '2.930K', '3G', '2481.542 YiB')
        self.assertManyResults(filesize.naturalsize, tests, results)


########NEW FILE########
__FILENAME__ = number
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Number tests."""

from humanize import number
from .base import HumanizeTestCase

class NumberTestCase(HumanizeTestCase):

    def test_ordinal(self):
        test_list = ('1', '2', '3', '4', '11', '12', '13', '101', '102', '103',
            '111', 'something else', None)
        result_list = ('1st', '2nd', '3rd', '4th', '11th', '12th', '13th',
            '101st', '102nd', '103rd', '111th', 'something else', None)
        self.assertManyResults(number.ordinal, test_list, result_list)

    def test_intcomma(self):
        test_list = (100, 1000, 10123, 10311, 1000000, 1234567.25, '100',
            '1000', '10123', '10311', '1000000', '1234567.1234567', None)
        result_list = ('100', '1,000', '10,123', '10,311', '1,000,000',
            '1,234,567.25', '100', '1,000', '10,123', '10,311', '1,000,000',
            '1,234,567.1234567', None)
        self.assertManyResults(number.intcomma, test_list, result_list)

    def test_intword(self):
        # make sure that powers & human_powers have the same number of items
        self.assertEqual(len(number.powers), len(number.human_powers))
        # test the result of intword
        test_list = ('100', '1000000', '1200000', '1290000', '1000000000',
            '2000000000', '6000000000000', '1300000000000000',
            '3500000000000000000000', '8100000000000000000000000000000000',
            None, ('1230000', '%0.2f'), 10**101)
        result_list = ('100', '1.0 million', '1.2 million', '1.3 million',
           '1.0 billion', '2.0 billion', '6.0 trillion', '1.3 quadrillion',
           '3.5 sextillion', '8.1 decillion', None, '1.23 million',
           '1'+'0'*101)
        self.assertManyResults(number.intword, test_list, result_list)

    def test_apnumber(self):
        test_list = (1, 2, 4, 5, 9, 10, '7', None)
        result_list = ('one', 'two', 'four', 'five', 'nine', '10', 'seven', None)
        self.assertManyResults(number.apnumber, test_list, result_list)

    def test_fractional(self):
        test_list = (1, 2.0, (4.0/3.0), (5.0/6.0), '7', '8.9', 'ten', None)
        result_list = ('1', '2', '1 1/3', '5/6', '7',  '8 9/10', 'ten', None)
        self.assertManyResults(number.fractional, test_list, result_list)

########NEW FILE########
__FILENAME__ = time
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Tests for time humanizing."""

from mock import patch

from humanize import time
from datetime import date, datetime, timedelta
from .base import HumanizeTestCase

today = date.today()
one_day = timedelta(days=1)

class fakedate(object):
    def __init__(self, year, month, day):
        self.year, self.month, self.day = year, month, day

class TimeUtilitiesTestCase(HumanizeTestCase):
    """These are not considered "public" interfaces, but require tests anyway."""
    def test_date_and_delta(self):
        now = datetime.now()
        td = timedelta
        int_tests = (3, 29, 86399, 86400, 86401*30)
        date_tests = [now - td(seconds=x) for x in int_tests]
        td_tests = [td(seconds=x) for x in int_tests]
        results = [(now - td(seconds=x), td(seconds=x)) for x in int_tests]
        for t in (int_tests, date_tests, td_tests):
            for arg, result in zip(t, results):
                dt, d = time.date_and_delta(arg)
                self.assertEqualDatetime(dt, result[0])
                self.assertEqualTimedelta(d, result[1])
        self.assertEqual(time.date_and_delta("NaN"), (None, "NaN"))

class TimeTestCase(HumanizeTestCase):
    """Tests for the public interface of humanize.time"""

    def test_naturaldelta_nomonths(self):
        now = datetime.now()
        test_list = [
            timedelta(days=7),
            timedelta(days=31),
            timedelta(days=230),
            timedelta(days=400),
        ]
        result_list = [
            '7 days',
            '31 days',
            '230 days',
            '1 year, 35 days',
        ]
        with patch('humanize.time._now') as mocked:
            mocked.return_value = now
            nd_nomonths = lambda d: time.naturaldelta(d, months=False)
            self.assertManyResults(nd_nomonths, test_list, result_list)

    def test_naturaldelta(self):
        now = datetime.now()
        test_list = [
            0,
            1,
            30,
            timedelta(minutes=1, seconds=30),
            timedelta(minutes=2),
            timedelta(hours=1, minutes=30, seconds=30),
            timedelta(hours=23, minutes=50, seconds=50),
            timedelta(days=1),
            timedelta(days=500),
            timedelta(days=365*2 + 35),
            timedelta(seconds=1),
            timedelta(seconds=30),
            timedelta(minutes=1, seconds=30),
            timedelta(minutes=2),
            timedelta(hours=1, minutes=30, seconds=30),
            timedelta(hours=23, minutes=50, seconds=50),
            timedelta(days=1),
            timedelta(days=500),
            timedelta(days=365*2 + 35),
            # regression tests for bugs in post-release humanize
            timedelta(days=10000),
            timedelta(days=365+35),
            30,
            timedelta(days=365*2 + 65),
            timedelta(days=365 + 4),
            timedelta(days=35),
            timedelta(days=65),
            timedelta(days=9),
            timedelta(days=365),
            "NaN",
        ]
        result_list = [
            'a moment',
            'a second',
            '30 seconds',
            'a minute',
            '2 minutes',
            'an hour',
            '23 hours',
            'a day',
            '1 year, 4 months',
            '2 years',
            'a second',
            '30 seconds',
            'a minute',
            '2 minutes',
            'an hour',
            '23 hours',
            'a day',
            '1 year, 4 months',
            '2 years',
            '27 years',
            '1 year, 1 month',
            '30 seconds',
            '2 years',
            '1 year, 4 days',
            'a month',
            '2 months',
            '9 days',
            'a year',
            "NaN",
        ]
        with patch('humanize.time._now') as mocked:
            mocked.return_value = now
            self.assertManyResults(time.naturaldelta, test_list, result_list)

    def test_naturaltime(self):
        now = datetime.now()
        test_list = [
            now,
            now - timedelta(seconds=1),
            now - timedelta(seconds=30),
            now - timedelta(minutes=1, seconds=30),
            now - timedelta(minutes=2),
            now - timedelta(hours=1, minutes=30, seconds=30),
            now - timedelta(hours=23, minutes=50, seconds=50),
            now - timedelta(days=1),
            now - timedelta(days=500),
            now - timedelta(days=365*2 + 35),
            now + timedelta(seconds=1),
            now + timedelta(seconds=30),
            now + timedelta(minutes=1, seconds=30),
            now + timedelta(minutes=2),
            now + timedelta(hours=1, minutes=30, seconds=30),
            now + timedelta(hours=23, minutes=50, seconds=50),
            now + timedelta(days=1),
            now + timedelta(days=500),
            now + timedelta(days=365*2 + 35),
            # regression tests for bugs in post-release humanize
            now + timedelta(days=10000),
            now - timedelta(days=365+35),
            30,
            now - timedelta(days=365*2 + 65),
            now - timedelta(days=365 + 4),
            "NaN",
        ]
        result_list = [
            'now',
            'a second ago',
            '30 seconds ago',
            'a minute ago',
            '2 minutes ago',
            'an hour ago',
            '23 hours ago',
            'a day ago',
            '1 year, 4 months ago',
            '2 years ago',
            'a second from now',
            '30 seconds from now',
            'a minute from now',
            '2 minutes from now',
            'an hour from now',
            '23 hours from now',
            'a day from now',
            '1 year, 4 months from now',
            '2 years from now',
            '27 years from now',
            '1 year, 1 month ago',
            '30 seconds ago',
            '2 years ago',
            '1 year, 4 days ago',
            "NaN",
        ]
        with patch('humanize.time._now') as mocked:
            mocked.return_value = now
            self.assertManyResults(time.naturaltime, test_list, result_list)

    def test_naturalday(self):
        tomorrow = today + one_day
        yesterday = today - one_day
        if today.month != 3:
            someday = date(today.year, 3, 5)
            someday_result = 'Mar 05'
        else:
            someday = date(today.year, 9, 5)
            someday_result = 'Sep 05'
        valerrtest = fakedate(290149024, 2, 2)
        overflowtest = fakedate(120390192341, 2, 2)
        test_list = (today, tomorrow, yesterday, someday, '02/26/1984',
            (date(1982, 6, 27), '%Y.%M.%D'), None, "Not a date at all.",
            valerrtest, overflowtest
        )
        result_list = ('today', 'tomorrow', 'yesterday', someday_result, '02/26/1984',
            date(1982, 6, 27).strftime('%Y.%M.%D'), None, "Not a date at all.",
            valerrtest, overflowtest
        )
        self.assertManyResults(time.naturalday, test_list, result_list)

    def test_naturaldate(self):
        tomorrow = today + one_day
        yesterday = today - one_day

        if today.month != 3:
            someday = date(today.year, 3, 5)
            someday_result = 'Mar 05'
        else:
            someday = date(today.year, 9, 5)
            someday_result = 'Sep 05'

        test_list = (today, tomorrow, yesterday, someday, date(1982, 6, 27))
        result_list = ('today', 'tomorrow', 'yesterday', someday_result, 'Jun 27 1982')
        self.assertManyResults(time.naturaldate, test_list, result_list)


########NEW FILE########
