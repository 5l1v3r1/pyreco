__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-durationfield documentation build configuration file, created by
# sphinx-quickstart on Thu Mar 17 21:59:51 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import durationfield

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-durationfield'
copyright = u'2011, John Paulett'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = durationfield.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-durationfielddoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-durationfield.tex', u'django-durationfield Documentation',
   u'John Paulett', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-durationfield', u'django-durationfield Documentation',
     [u'John Paulett'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'django-durationfield'
epub_author = u'John Paulett'
epub_publisher = u'John Paulett'
epub_copyright = u'2011, John Paulett'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = duration
# -*- coding: utf-8 -*-
from datetime import timedelta
from django.core import exceptions
from django.db.models.fields import Field
from django.db import models
from django.utils import six
from django.utils.translation import ugettext_lazy as _
from django.utils.encoding import smart_text

from durationfield.utils.timestring import str_to_timedelta
from durationfield.forms.fields import DurationField as FDurationField

try:
    from south.modelsinspector import add_introspection_rules
except ImportError:
    add_introspection_rules = None


class DurationField(six.with_metaclass(models.SubfieldBase, Field)):
    """
    A duration field is used
    """
    description = _("A duration of time")

    default_error_messages = {
        'invalid': _("This value must be in \"w d h min s ms us\" format."),
        'unknown_type': _("The value's type could not be converted"),
    }

    def __init__(self, *args, **kwargs):
        super(DurationField, self).__init__(*args, **kwargs)
        #self.max_digits, self.decimal_places = 20, 6

    def get_internal_type(self):
        return "DurationField"

    def db_type(self, connection=None):
        """
        Returns the database column data type for this field, for the provided connection.
        Django 1.1.X does not support multiple db's and therefore does not pass in the db
        connection string. Called by Django only when the framework constructs the table
        """
        return "bigint"

    def get_db_prep_value(self, value, connection=None, prepared=False):
        """
        Returns field's value prepared for interacting with the database backend.
        In our case this is an integer representing the number of microseconds
        elapsed.
        """
        if value is None:
            return None  # db NULL
        if isinstance(value, six.integer_types):
            value = timedelta(microseconds=value)
        value = abs(value)  # all durations are positive

        return (
            value.days * 24 * 3600 * 1000000
            + value.seconds * 1000000
            + value.microseconds
        )

    def get_db_prep_save(self, value, connection=None):
        return self.get_db_prep_value(value, connection=connection)

    def value_to_string(self, obj):
        value = self._get_val_from_obj(obj)
        return smart_text(value)

    def to_python(self, value):
        """
        Converts the input value into the timedelta Python data type, raising
        django.core.exceptions.ValidationError if the data can't be converted.
        Returns the converted value as a timedelta.
        """

        # Note that value may be coming from the database column or a serializer so we should
        # handle a timedelta, string or an integer
        if value is None:
            return value

        if isinstance(value, timedelta):
            return value

        if isinstance(value, six.integer_types):
            return timedelta(microseconds=value)

        # Try to parse the value
        str_val = smart_text(value)
        if isinstance(str_val, six.string_types):
            try:
                return str_to_timedelta(str_val)
            except ValueError:
                raise exceptions.ValidationError(self.default_error_messages['invalid'])

        raise exceptions.ValidationError(self.default_error_messages['unknown_type'])

    def formfield(self, **kwargs):
        defaults = {'form_class': FDurationField}
        defaults.update(kwargs)
        return super(DurationField, self).formfield(**defaults)


if add_introspection_rules:
    # Rules for South field introspection
    duration_rules = [
        (
            (DurationField,),
            [],
            {}
        )
    ]
    add_introspection_rules(
        duration_rules, ["^durationfield\.db\.models\.fields"]
    )

########NEW FILE########
__FILENAME__ = fields
from django.forms.fields import Field
from django.forms import ValidationError
from django.utils.translation import ugettext_lazy as _

from durationfield.forms.widgets import DurationInput
from durationfield.utils.timestring import str_to_timedelta


class DurationField(Field):
    widget = DurationInput

    default_error_messages = {
        'invalid': _('Enter a valid duration.'),
    }

    def __init__(self, *args, **kwargs):
        super(DurationField, self).__init__(*args, **kwargs)

    def clean(self, value):
        """
        Returns a datetime.timedelta object.
        """
        super(DurationField, self).clean(value)
        try:
            return str_to_timedelta(value)
        except ValueError:
            raise ValidationError(self.default_error_messages['invalid'])

    def to_python(self, value):
        try:
            return str_to_timedelta(value)
        except ValueError:
            raise ValidationError(self.default_error_messages['invalid'])

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-
from django.utils import formats, six
from django.forms.util import flatatt
from django.forms.widgets import TextInput
from django.utils.safestring import mark_safe
from django.utils.encoding import force_text
from datetime import timedelta


class DurationInput(TextInput):
    def render(self, name, value, attrs=None):
        """
        output.append(u'<li>%(cb)s<label%(for)s>%(label)s</label></li>' % {"for": label_for, "label": option_label, "cb": rendered_cb})
        """
        if value is None:
            value = ''

        final_attrs = self.build_attrs(attrs, type=self.input_type, name=name)
        if value != '':
            # Only add the 'value' attribute if a value is non-empty.
            if isinstance(value, six.integer_types):
                value = timedelta(microseconds=value)

            # Otherwise, we've got a timedelta already

            final_attrs['value'] = force_text(formats.localize_input(value))
        return mark_safe('<input%s />' % flatatt(final_attrs))

########NEW FILE########
__FILENAME__ = timestring
# -*- coding: utf-8 -*-
"""
Utility functions to convert back and forth between a timestring and timedelta.
"""

from django.conf import settings
from django.core.exceptions import ValidationError

from datetime import timedelta
import re

ALLOW_MONTHS = getattr(settings, "DURATIONFIELD_ALLOW_MONTHS", False)
ALLOW_YEARS = getattr(settings, "DURATIONFIELD_ALLOW_YEARS", False)
MONTHS_TO_DAYS = getattr(settings, "DURATIONFIELD_MONTHS_TO_DAYS", 30)
YEARS_TO_DAYS = getattr(settings, "DURATIONFIELD_YEARS_TO_DAYS", 365)


def str_to_timedelta(td_str):
    """
    Returns a timedelta parsed from the native string output of a timedelta.

    Timedelta displays in the format ``X day(s), H:MM:SS.ffffff``
    Both the days section and the microseconds section are optional and ``days``
    is singular in cases where there is only one day.

    Additionally will handle user input in months and years, translating those
    bits into a count of days which is 'close enough'.
    """
    if not td_str:
        return None

    time_format = r"(?:(?P<weeks>\d+)\W*(?:weeks?|w),?)?\W*(?:(?P<days>\d+)\W*(?:days?|d),?)?\W*(?:(?P<hours>\d+):(?P<minutes>\d+)(?::(?P<seconds>\d+)(?:\.(?P<microseconds>\d+))?)?)?"
    if ALLOW_MONTHS:
        time_format = r"(?:(?P<months>\d+)\W*(?:months?|m),?)?\W*" + time_format
    if ALLOW_YEARS:
        time_format = r"(?:(?P<years>\d+)\W*(?:years?|y),?)?\W*" + time_format
    time_matcher = re.compile(time_format)
    time_matches = time_matcher.match(td_str)
    time_groups = time_matches.groupdict()

    # If passed an invalid string, the regex will return all None's, so as
    # soon as we get a non-None value, we are more confident the string
    # is valid (possibly some invalid numeric formats this will not catch.
    # Refs #11
    is_valid = False
    for key in time_groups.keys():
        if time_groups[key] is not None:
            is_valid = True
            value = time_groups[key]
            if key == 'microseconds':
                # When parsing time regex, make sure the microseconds value
                # uses the correct number of digits. This must be correctly
                # padded so 3.14 == 3.140 == 3.1400 == 3.14000 == 3.140000
                # 3.14 == 3 seconds 140,000 microseconds
                value = value.ljust(6, '0')
            time_groups[key] = int(value)

        else:
            time_groups[key] = 0

    if not is_valid:
        raise ValidationError("Invalid timedelta string, '{0}'".format(td_str))

    if "years" in time_groups.keys():
        time_groups["days"] = time_groups["days"] + (time_groups["years"] * YEARS_TO_DAYS)
    if "months" in time_groups.keys():
        time_groups["days"] = time_groups["days"] + (time_groups["months"] * MONTHS_TO_DAYS)
    time_groups["days"] = time_groups["days"] + (time_groups["weeks"] * 7)

    return timedelta(
        days=time_groups["days"],
        hours=time_groups["hours"],
        minutes=time_groups["minutes"],
        seconds=time_groups["seconds"],
        microseconds=time_groups["microseconds"]
    )

########NEW FILE########
__FILENAME__ = models
import datetime
from django.db import models
from durationfield.db.models.fields.duration import DurationField

DEFAULT_DURATION = datetime.timedelta(days=730)


class TestModel(models.Model):
    duration_field = DurationField()


class TestNullableModel(models.Model):
    duration_field = DurationField(null=True, blank=True)


class TestDefaultModel(models.Model):
    duration_field = DurationField(default=DEFAULT_DURATION)

########NEW FILE########
__FILENAME__ = settings
import django

version = django.VERSION[0:3]

if version[0] <= 1 and version[1] < 2:
    # use old syntax for Django<1.2
    DATABASE_ENGINE = 'sqlite3'
    DATABASE_NAME = 'durationfieldtest.db'
else:
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': 'durationfieldtest.db',
        }
    }

INSTALLED_APPS = (
    'tests',
)

DURATIONFIELD_ALLOW_YEARS = True
DURATIONFIELD_ALLOW_MONTHS = True

SECRET_KEY = '_2roqfdp42u3qn23xc=z4**vueob2#!yloe=_+go&wxsi&glt1'

########NEW FILE########
__FILENAME__ = tests
from django.core.exceptions import ValidationError
from django.test import TestCase
from django.utils import six, unittest
from .models import (
    TestModel,
    TestNullableModel,
    TestDefaultModel,
    DEFAULT_DURATION
)
from durationfield.utils import timestring
from datetime import timedelta


class DurationFieldTests(TestCase):

    def setUp(self):
        self.test_tds = [
            timedelta(hours=1),  # No days, no micro, single-digit hour
            timedelta(hours=10),  # double-digit hour
            timedelta(hours=10, minutes=35, seconds=1),
            timedelta(days=1),  # Day, no micro
            timedelta(days=1, microseconds=1),  # Day, with micro
            timedelta(days=10),  # Days, no micro
            timedelta(days=10, microseconds=1),  # Days, with micro
        ]

        return super(DurationFieldTests, self).setUp()

    def _delta_to_microseconds(self, td):
        """
        Get the total number of microseconds in a timedelta, normalizing days and
        seconds to microseconds.
        """
        SECONDS_TO_US = 1000 * 1000
        MINUTES_TO_US = SECONDS_TO_US * 60
        HOURS_TO_US = MINUTES_TO_US * 60
        DAYS_TO_US = HOURS_TO_US * 24

        td_in_ms = td.days * DAYS_TO_US + td.seconds * SECONDS_TO_US + td.microseconds
        self.assertEqual(timedelta(microseconds=td_in_ms), td)

        return td_in_ms

    def testTimedeltaStrRoundtrip(self):
        for td in self.test_tds:
            td_str = str(td)
            td_from_str = timestring.str_to_timedelta(td_str)
            self.assertEqual(td_from_str, td)

    def testTimedeltaStrInvalid(self):
        self.assertRaises(ValidationError, timestring.str_to_timedelta, 'fake')

    def testDbRoundTrip(self):
        """
        Data should remain the same when taking a round trip to and from the db
        """
        models = [TestModel, TestNullableModel, TestDefaultModel]

        for td in self.test_tds:
            for ModelClass in models:
                tm = ModelClass()
                tm.duration_field = td
                tm.save()

                tm_saved = ModelClass.objects.get(pk=tm.pk)
                self.assertEqual(tm_saved.duration_field, tm.duration_field)

    def testInvalidSaveAttempt(self):
        self.assertRaises(ValidationError, TestModel, duration_field='invalid')

        # not saved in DB
        self.assertEqual(TestModel.objects.count(), 0)

    def testDefaultValue(self):
        """
        Default value should be empty and fetchable
        """
        model_test = TestNullableModel()
        model_test.save()
        model_test_saved = TestNullableModel.objects.get(pk=model_test.pk)

        self.assertEqual(model_test.duration_field, None)
        self.assertEqual(model_test_saved.duration_field, None)

    def testDefaultGiven(self):
        """
        Default value should use the default argument
        """
        model_test = TestDefaultModel()
        model_test.save()

        model_test_saved = TestDefaultModel.objects.get(pk=model_test.pk)
        self.assertEqual(model_test.duration_field, DEFAULT_DURATION)
        self.assertEqual(model_test_saved.duration_field, DEFAULT_DURATION)

    def testApplicationType(self):
        """
        Timedeltas should be returned to the applciation
        """
        for td in self.test_tds:
            model_test = TestModel()
            model_test.duration_field = td
            model_test.save()
            model_test = TestModel.objects.get(pk=model_test.pk)
            self.assertEqual(td, model_test.duration_field)

            # Test with strings
            model_test = TestModel()
            model_test.duration_field = str(td)
            model_test.save()
            model_test = TestModel.objects.get(pk=model_test.pk)
            self.assertEqual(td, model_test.duration_field)

            # Test with int
            model_test = TestModel()
            model_test.duration_field = self._delta_to_microseconds(td)
            model_test.save()
            model_test = TestModel.objects.get(pk=model_test.pk)
            self.assertEqual(td, model_test.duration_field)

    @unittest.skipIf(six.PY3, 'long not present in Python 3')
    def testLongInPython2(self):
        for td in self.test_tds:
            # Test with long
            model_test = TestModel()
            model_test.duration_field = long(self._delta_to_microseconds(td))
            model_test.save()
            model_test = TestModel.objects.get(pk=model_test.pk)
            self.assertEqual(td, model_test.duration_field)

    def testInputTime(self):
        delta = timestring.str_to_timedelta("10:23")
        seconds = (10 * 60 * 60) + (23 * 60)
        self.assertEqual(seconds, delta.seconds)

    def testInputTimeSeonds(self):
        delta = timestring.str_to_timedelta("12:21:24")
        seconds = (12 * 60 * 60) + (21 * 60) + 24
        self.assertEqual(seconds, delta.seconds)

    def testInputTimeSecondsMicroseconds(self):
        delta = timestring.str_to_timedelta("11:20:22.000098")
        seconds = (11 * 60 * 60) + (20 * 60) + 22
        self.assertEqual(seconds, delta.seconds)
        self.assertEqual(98, delta.microseconds)

    def testInputTimeMicrosecondsRightPadZeros(self):
        delta = timestring.str_to_timedelta("11:20:22.160")
        self.assertEqual(160000, delta.microseconds)

    def testInputTimeMicrosecondsLeftPadZeros(self):
        delta = timestring.str_to_timedelta("11:20:22.016")
        self.assertEqual(16000, delta.microseconds)

    def testInputTimeMicrosecondsBothPadZeros(self):
        delta = timestring.str_to_timedelta("11:20:22.0160")
        self.assertEqual(16000, delta.microseconds)

    def testInputAll(self):
        delta = timestring.str_to_timedelta("1 year, 10 months, 3 weeks, 2 days, 3:40:50")
        days = (
            (1 * 365) +
            (10 * 30) +
            (3 * 7) +
            2
        )
        seconds = (
            (3 * 60 * 60) +
            (40 * 60) +
            50
        )
        self.assertEqual(
            days, delta.days
        )
        self.assertEqual(
            seconds, delta.seconds
        )

    def testInputAllAbbreviated(self):
        delta = timestring.str_to_timedelta("2y 9m 1w 20d 0:10:39")
        days = (
            (2 * 365) +
            (9 * 30) +
            (1 * 7) +
            20
        )
        seconds = (
            (0 * 60 * 60) +
            (10 * 60) +
            39
        )
        self.assertEqual(
            days, delta.days
        )
        self.assertEqual(
            seconds, delta.seconds
        )

    def testInputDaysOnly(self):
        delta = timestring.str_to_timedelta("24 days")
        self.assertEqual(
            24, delta.days
        )

########NEW FILE########
