__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-hunger documentation build configuration file, created by
# sphinx-quickstart on Fri Mar 30 18:57:24 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-hunger'
copyright = u'2013, Joshua Karjala, Simon Ye'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-hungerdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-hunger.tex', u'django-hunger Documentation',
   u'Joshua Karjala, Simon Ye', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-hunger', u'django-hunger Documentation',
     [u'Joshua Karjala, Simon Ye'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-hunger', u'django-hunger Documentation',
   u'Joshua Karjala, Simon Ye', 'django-hunger', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'example.sqlite',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'y#rmfqpl68yg!=!ue7^(y^^sdbfrph-p*$oc0398$m@ayff@c6'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'hunger.middleware.BetaMiddleware',
)

ROOT_URLCONF = 'example.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'example.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# One-week activation window; you may, of course, use a different value.
ACCOUNT_ACTIVATION_DAYS = 7

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

HUNGER_ALWAYS_ALLOW_VIEWS = (
    'registration_activation_complete',
    'registration_activate',
    'registration_complete',
    'registration_disallowed',
    'registration_register',
    'home',
)


INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',
    'django.contrib.admindocs',
    'registration',
    'hunger',
    'example',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns(
    '',
    url(r'^admin/doc/', include('django.contrib.admindocs.urls')),
    url(r'^admin/', include(admin.site.urls)),
    url(r'', include('django.contrib.auth.urls')),
    url(r'^accounts/', include('registration.backends.default.urls')),
    url(r'^$', 'example.views.home', name='home'),
    url(r'^hunger/', include('hunger.urls')),
    url(r'^accounts/profile/$', 'example.views.profile', name='profile'),
)

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render


def home(request):
    return render(request, 'base.html')


def nonbeta(request):
    return render(request, 'nonbeta.html')


def profile(request):
    return render(request, 'profile.html')

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for example project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = admin
from __future__ import unicode_literals
import csv
from datetime import datetime
from django.contrib import admin
from django.http import HttpResponse
from hunger.models import InvitationCode, Invitation
from hunger.utils import now
from hunger.forms import InvitationCodeAdminForm

CSV_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"


def export_email(modeladmin, request, queryset):
    response = HttpResponse(mimetype='text/csv')
    response['Content-Disposition'] = 'attachment; filename=email.csv'
    writer = csv.writer(response)

    writer.writerow(['email', 'created', 'invited', 'used'])

    for obj in queryset:
        code = obj.code
        email = obj.user.email
        used = obj.used
        invited = obj.invited
        created = datetime.strftime(code.created, CSV_DATE_FORMAT)
        try:
            invited = datetime.strftime(obj.invited, CSV_DATE_FORMAT)
        except TypeError:
            invited = ''
        try:
            used = datetime.strftime(obj.used, CSV_DATE_FORMAT)
        except TypeError:
            used = ''

        if email:
            row = [email, created, invited, used]
            writer.writerow(row)
    # Return CSV file to browser as download
    return response


def send_invite(modeladmin, request, queryset):
    for obj in queryset:
        if not obj.invited:
            obj.invited = now()
            obj.save(send_email=True, request=request)


def resend_invite(modeladmin, request, queryset):
    for obj in queryset:
        if obj.invited:
            obj.save(send_email=True, request=request)


class InvitationAdmin(admin.ModelAdmin):
    list_display = ('user', 'code', 'used', 'invited')
    list_filter = ('code',)
    search_fields = ['user__username', 'user__email']
    actions = [send_invite, resend_invite, export_email]


class InvitationCodeAdmin(admin.ModelAdmin):
    """Admin for invitation code"""
    form = InvitationCodeAdminForm
    list_display = ('code', 'num_invites', 'owner', )
    filter_horizontal = ('invited_users', )
    search_fields = ['created_by__email', 'owner__username']


admin.site.register(Invitation, InvitationAdmin)
admin.site.register(InvitationCode, InvitationCodeAdmin)

########NEW FILE########
__FILENAME__ = email
from __future__ import unicode_literals
import os.path
from django.conf import settings
from django.core.mail import EmailMultiAlternatives
from django.core.urlresolvers import reverse
from django.template.loader import get_template
from django.template import Context
from hunger.utils import setting

try:
    from templated_email import send_templated_mail
    templated_email_available = True
except ImportError:
    templated_email_available = False


def beta_invite(email, request, code=None, **kwargs):
    """
    Email for sending out the invitation code to the user.
    Invitation URL is added to the context, so it can be rendered with standard
    django template engine.
    """
    context_dict = kwargs.copy()
    if code:
        invite_url = request.build_absolute_uri(
            reverse('hunger-verify', args=[code]))
    else:
        invite_url = setting('HUNGER_VERIFIED_REDIRECT')
    context_dict.setdefault('invite_url', invite_url)

    context = Context(context_dict)

    templates_folder = setting('HUNGER_EMAIL_TEMPLATES_DIR')
    templates_folder = os.path.join(templates_folder, '')
    from_email = kwargs.get('from_email',
                            getattr(settings, 'DEFAULT_FROM_EMAIL'))
    if templates_folder == 'hunger':
        file_extension = 'email'
    else:
        file_extension = None

    if templated_email_available:
        send_templated_mail(
            template_name='invite_email',
            from_email=from_email,
            recipient_list=[email],
            context=context_dict,
            template_dir=templates_folder,
            file_extension=file_extension,
        )
    else:
        plaintext = get_template(os.path.join(templates_folder,
                                              'invite_email.txt'))
        invite_path = os.path.join(templates_folder, 'invite_email.html')
        html = get_template(invite_path)

        subject_path = os.path.join(templates_folder,
                                    'invite_email_subject.txt')
        subject = get_template(subject_path).render(context).strip()
        to = email
        text_content = plaintext.render(context)
        html_content = html.render(context)
        msg = EmailMultiAlternatives(subject, text_content, from_email, [to],
                                     headers={'From': '%s' % from_email})
        msg.attach_alternative(html_content, "text/html")
        msg.send()

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals
from django import forms
from hunger.models import Invitation, InvitationCode


class InviteSendForm(forms.ModelForm):
    class Meta:
        model = Invitation
        fields = ('email',)

    def __init__(self, *args, **kwargs):
        super(InviteSendForm, self).__init__(*args, **kwargs)

        # When sending an invitation, the email address is required
        self.fields['email'].required = True


class InvitationCodeAdminForm(forms.ModelForm):
    code = forms.CharField(
        initial=lambda: InvitationCode.generate_invite_code())

    class Meta:
        model = InvitationCode

########NEW FILE########
__FILENAME__ = middleware
from __future__ import unicode_literals
from django.utils import six
from django.conf import settings
from django.core.urlresolvers import reverse, resolve
from django.shortcuts import redirect
from django.db.models import Q
from hunger.models import InvitationCode, Invitation
from hunger.utils import setting, now


class BetaMiddleware(object):
    """
    Add this to your ``MIDDLEWARE_CLASSES`` make all views except for
    those in the account application require that a user be logged in.
    This can be a quick and easy way to restrict views on your site,
    particularly if you remove the ability to create accounts.

    **Settings:**

    ``HUNGER_ENABLE_BETA``
        Whether or not the beta middleware should be used. If set to
        `False` the BetaMiddleware middleware will be ignored and the
        request will be returned. This is useful if you want to
        disable privatebeta on a development machine. Default is
        `True`.

    ``HUNGER_ALWAYS_ALLOW_VIEWS``
        A list of full view names that should always pass through.

    ``HUNGER_ALWAYS_ALLOW_MODULES``
        A list of modules that should always pass through.  All
        views in ``django.contrib.auth.views``, ``django.views.static``
        and ``hunger.views`` will pass through.

    ``HUNGER_REDIRECT``
        The redirect when not in beta.
    """

    def __init__(self):
        self.enable_beta = setting('HUNGER_ENABLE')

        self.always_allow_views = setting('HUNGER_ALWAYS_ALLOW_VIEWS')
        self.always_allow_modules = setting('HUNGER_ALWAYS_ALLOW_MODULES')
        self.redirect = setting('HUNGER_REDIRECT')
        self.allow_flatpages = setting('HUNGER_ALLOW_FLATPAGES')

    def process_view(self, request, view_func, view_args, view_kwargs):
        if not self.enable_beta:
            return

        if (request.path in self.allow_flatpages or
            (getattr(settings, 'APPEND_SLASH', True) and
             '%s/' % request.path in self.allow_flatpages)):
            from django.contrib.flatpages.views import flatpage
            return flatpage(request, request.path_info)

        whitelisted_modules = ['django.contrib.auth.views',
                               'django.contrib.admin.sites',
                               'django.views.static',
                               'django.contrib.staticfiles.views']

        # All hunger views, except NotBetaView, are off limits until in beta
        whitelisted_views = ['hunger.views.NotBetaView',
                             'hunger.views.verify_invite',
                             'hunger.views.InvalidView']

        short_name = view_func.__class__.__name__
        if short_name == 'function':
            short_name = view_func.__name__
        view_name = self._get_view_name(request)

        full_view_name = '%s.%s' % (view_func.__module__, short_name)

        if self.always_allow_modules:
            whitelisted_modules += self.always_allow_modules

        if '%s' % view_func.__module__ in whitelisted_modules:
            return

        if self.always_allow_views:
            whitelisted_views += self.always_allow_views

        if (full_view_name in whitelisted_views or
            view_name in whitelisted_views):
            return

        if not request.user.is_authenticated():
            # Ask anonymous user to log in if trying to access in-beta view
            return redirect(setting('LOGIN_URL'))

        if request.user.is_staff:
            return

        # Prevent queries by caching in_beta status in session
        if request.session.get('hunger_in_beta'):
            return

        cookie_code = request.COOKIES.get('hunger_code')
        invitations = Invitation.objects.filter(
            Q(user=request.user) |
            Q(email=request.user.email)
            ).select_related('code')

        # User already in the beta - cache in_beta in session
        if any([i.used for i in invitations if i.invited]):
            request.session['hunger_in_beta'] = True
            return

        # User has been invited - use the invitation and place in beta.
        activates = [i for i in invitations if i.invited and not i.used]

        # Check for matching cookie code if available.
        if cookie_code:
            for invitation in activates:
                if invitation.code.code == cookie_code:
                    # Invitation may be attached to email
                    invitation.user = request.user
                    invitation.used = now()
                    invitation.save()
                    request.session['hunger_in_beta'] = True
                    request._hunger_delete_cookie = True
                    return

        # No cookie - let's just choose the first invitation if it exists
        if activates:
            invitation = activates[0]
            # Invitation may be attached to email
            invitation.user = request.user
            invitation.used = now()
            invitation.save()
            request.session['hunger_in_beta'] = True
            return

        if not cookie_code:
            if not invitations:
                invitation = Invitation(user=request.user)
                invitation.save()
            return redirect(self.redirect)

        # No invitation, all we have is this cookie code
        try:
            code = InvitationCode.objects.get(code=cookie_code,
                                              num_invites__gt=0)
        except InvitationCode.DoesNotExist:
            request._hunger_delete_cookie = True
            return redirect(reverse('hunger-invalid', args=(cookie_code,)))

        right_now = now()
        if code.private:
            # If we got here, we're trying to fix up a previous private
            # invitation to the correct user/email.
            invitation = Invitation.objects.filter(code=code)[0]
            invitation.user = request.user
            invitation.invited = right_now
            invitation.used = right_now
            code.num_invites = 0
        else:
            invitation = Invitation(user=request.user,
                                    code=code,
                                    invited=right_now,
                                    used=right_now)
            code.num_invites -= 1
        invitation.save()
        code.save()
        return

    def process_response(self, request, response):
        if getattr(request, '_hunger_delete_cookie', False):
            if six.PY2:
                code = u'hunger_code'.encode('utf-8')
            elif six.PY3:
                code = 'hunger_code'
            response.delete_cookie(code)
        return response

    @staticmethod
    def _get_view_name(request):
        """Return the urlpattern name."""
        if hasattr(request, 'resolver_match'):
            # Django >= 1.5
            return request.resolver_match.view_name

        match = resolve(request.path)
        return match.url_name

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals
import importlib
import random
import string
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from hunger.utils import setting

try:
    from django.contrib.auth import get_user_model
    User = get_user_model()
except RuntimeError:
    User = settings.AUTH_USER_MODEL
except ImportError:
    from django.contrib.auth.models import User


class Invitation(models.Model):
    user = models.ForeignKey(User, blank=True, null=True)
    email = models.EmailField(_('Email'), blank=True, null=True)
    code = models.ForeignKey('InvitationCode', blank=True, null=True)
    used = models.DateTimeField(_('Used'), blank=True, null=True)
    invited = models.DateTimeField(_('Invited'), blank=True, null=True)
    created = models.DateTimeField(_('Created'), auto_now_add=True)

    def save(self, *args, **kwargs):
        send_email = kwargs.pop('send_email', False)
        request = kwargs.pop('request', None)
        if send_email and self.invited and not self.used:
            send_invitation(self, request=request, user=self.user)

        super(Invitation, self).save(*args, **kwargs)

    class Meta:
        unique_together = (('user', 'code'),)


def send_invitation(invitation, **kwargs):
    """Send invitation code to user.

    Invitation could be InvitationCode or Invitation.
    """
    email = invitation.user.email
    code = invitation.code.code if invitation.code else None
    bits = setting('HUNGER_EMAIL_INVITE_FUNCTION').rsplit('.', 1)
    module_name, func_name = bits
    module = importlib.import_module(module_name)
    func = getattr(module, func_name)
    func(email, code=code, **kwargs)


class InvitationCode(models.Model):
    code = models.CharField(_('Invitation code'), max_length=30, unique=True)
    private = models.BooleanField(default=True)
    max_invites = models.PositiveIntegerField(
        _('Max number of invitations'), default=1)
    num_invites = models.PositiveIntegerField(
        _('Remaining invitations'), default=1)
    invited_users = models.ManyToManyField(
        User, related_name='invitations', through='Invitation')
    owner = models.ForeignKey(User, related_name='created_invitations',
                              blank=True, null=True)

    def __unicode__(self):
        return self.code

    def remaining_invites(self):
        """The number of invites remaining for this code."""
        return max([0, self.max_invites - self.invited_users.count()])

    @classmethod
    def generate_invite_code(self):
        return ''.join(random.choice(string.ascii_letters) for i in range(16))

    def save(self, *args, **kwargs):
        if not self.code:
            self.code = self.generate_invite_code()
        # self.num_invites = self.max_invites - self.invited_users.count()
        super(InvitationCode, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = urls
from __future__ import unicode_literals
from django.conf.urls import patterns, url
from .views import (InviteView, VerifiedView, InvalidView, NotBetaView,
                    InviteSentView)


urlpatterns = patterns(
    '',
    url(r'^verify/(\w+)/$', 'hunger.views.verify_invite',
        name='hunger-verify'),
    url(r'^invite/$', InviteView.as_view(), name='hunger-invite'),
    url(r'^sent/$', InviteSentView.as_view(), name='hunger-invite-sent'),
    url(r'^not-in-beta/$', NotBetaView.as_view(), name='hunger-not-in-beta'),
    url(r'^verified/$', VerifiedView.as_view(), name='hunger-verified'),
    url(r'^invalid/(?P<code>\w+)/$', InvalidView.as_view(),
        name='hunger-invalid'),
)

########NEW FILE########
__FILENAME__ = utils
from __future__ import unicode_literals
import datetime
from django.conf import settings
from django.core.urlresolvers import reverse_lazy
from django.contrib.auth.models import User


DEFAULT_SETTINGS = {
    'AUTH_USER_MODEL': User,
    'HUNGER_ENABLE': True,
    'HUNGER_ALWAYS_ALLOW_VIEWS': [],
    'HUNGER_ALWAYS_ALLOW_MODULES': [],
    'HUNGER_REDIRECT': reverse_lazy('hunger-not-in-beta'),
    'HUNGER_VERIFIED_REDIRECT': reverse_lazy('hunger-verified'),
    'HUNGER_INVITE_SENT_REDIRECT': reverse_lazy('hunger-invite-sent'),
    'HUNGER_ALLOW_FLATPAGES': [],
    'HUNGER_EMAIL_TEMPLATES_DIR': 'hunger',
    'HUNGER_EMAIL_INVITE_FUNCTION': 'hunger.email.beta_invite',
}


def setting(name):
    """Return setting value for given name or default value."""
    return getattr(settings, name, None) or DEFAULT_SETTINGS[name]


def now():
    """Backwards compatible now function when USE_TZ=False."""
    if getattr(settings, 'USE_TZ'):
        from django.utils import timezone
        return timezone.now()
    else:
        return datetime.datetime.now()

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import redirect
from hunger.models import InvitationCode
from hunger.forms import InviteSendForm
from hunger.utils import setting, now
from django.views.generic.base import TemplateView
from django.views.generic.edit import FormView
from django.contrib.auth.decorators import login_required


class InviteView(FormView):
    """
    Allow a user to send invites.
    """
    template_name = 'hunger/request_invite.html'
    form_class = InviteSendForm
    success_url = setting('HUNGER_INVITE_SENT_REDIRECT')

    def form_valid(self, form):
        valid_code = InvitationCode.objects.get(owner=self.request.user,
                                                num_invites__gt=0)
        form.instance.code = valid_code
        form.instance.invited = now()
        form.save()

        return super(InviteView, self).form_valid(form)


class NotBetaView(TemplateView):
    """
    Display a message to the user after the invite request is completed
    successfully.
    """
    template_name = 'hunger/not_in_beta.html'


class VerifiedView(TemplateView):
    """
    Display a message to the user after the invite request is completed
    successfully.
    """
    template_name = 'hunger/verified.html'


class InvalidView(TemplateView):
    """
    Display a message to the user that the invitation code is
    invalid or has already been used.
    """
    template_name = 'hunger/invalid.html'


class InviteSentView(TemplateView):
    """
    Display a message to the user after sending out invitations to people.
    """
    template_name = 'hunger/invite_sent.html'


@login_required
def verify_invite(request, code):
    """Verify new invitee by storing invite code for middleware to validate."""
    response = redirect(setting('HUNGER_VERIFIED_REDIRECT'))
    response.set_cookie('hunger_code', code)
    return response

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
from __future__ import unicode_literals
import sys
from os.path import dirname, abspath, join
from optparse import OptionParser

parent = dirname(abspath(__file__))
sys.path.insert(0, parent)

from django.conf import settings

if not settings.configured:
    settings.configure(
        DATABASE_ENGINE='sqlite3',
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
                'TEST_NAME': 'hunger_tests.db',
            },
        },
        DATABASE_NAME='test_hunger',
        TEST_DATABASE_NAME='hunger_tests.db',
        INSTALLED_APPS=[
            'django.contrib.auth',
            'django.contrib.admin',
            'django.contrib.sessions',
            'django.contrib.sites',
            'django.contrib.contenttypes',
            # 'south',
            'hunger',
            'tests',
        ],
        ROOT_URLCONF='',
        DEBUG=False,
        SITE_ID=1,
        TEMPLATE_DEBUG=True,
        TEMPLATE_DIRS=[join(parent, 'tests', 'templates')],

        MIDDLEWARE_CLASSES=(
            'django.middleware.common.CommonMiddleware',
            'django.contrib.sessions.middleware.SessionMiddleware',
            'django.middleware.csrf.CsrfViewMiddleware',
            'django.contrib.auth.middleware.AuthenticationMiddleware',
            'hunger.middleware.BetaMiddleware'
        ),
        HUNGER_REDIRECT='rejection',
        HUNGER_ALWAYS_ALLOW_VIEWS=[
            'tests.views.always_allow',
            'tests.views.rejection',
        ],
        HUNGER_ALWAYS_ALLOW_MODULES=['tests.always_allow_views'],
    )

from django.test.simple import DjangoTestSuiteRunner


def runtests(*test_args, **kwargs):
    if 'south' in settings.INSTALLED_APPS:
        from south.management.commands import patch_for_test_db_setup
        patch_for_test_db_setup()

    if not test_args:
        test_args = ['tests']

    test_runner = DjangoTestSuiteRunner(
        verbosity=kwargs.get('verbosity', 1),
        interactive=kwargs.get('interactive', False),
        failfast=kwargs.get('failfast'))

    failures = test_runner.run_tests(test_args)
    sys.exit(failures)

if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option('--failfast', action='store_true', default=False,
                      dest='failfast')

    (options, args) = parser.parse_args()

    runtests(failfast=options.failfast, *args)

########NEW FILE########
__FILENAME__ = always_allow_views
from __future__ import unicode_literals
from django.shortcuts import render


def allowed(request):
    return render(request, 'default.html')

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
from __future__ import unicode_literals
from django.core.urlresolvers import reverse
from django.contrib.auth.models import User
from django.test import TestCase
from hunger.utils import setting, now
from hunger.models import Invitation, InvitationCode


class BetaViewTests(TestCase):
    urls = 'tests.urls'

    redirect = setting('HUNGER_REDIRECT')

    def create_invite(self, email):
        code = InvitationCode(num_invites=0)
        code.save()
        invitation = Invitation(code=code, email=email, invited=now())
        invitation.save()
        return invitation

    def create_code(self, private=True, email=''):
        code = InvitationCode(private=private)
        code.save()
        if private:
            invitation = Invitation(code=code, email=email, invited=now())
            invitation.save()
        return code

    def setUp(self):
        """Creates a few basic users.

        Alice is registered but not in beta
        Bob is registered and in beta (self-signup)
        Charlie is in beta and has one invite
        """
        self.alice = User.objects.create_user('alice', 'alice@example.com', 'secret')
        self.bob = User.objects.create_user('bob', 'bob@example.com', 'secret')
        right_now = now()
        invitation = Invitation(user=self.bob, invited=right_now, used=right_now)
        invitation.save()

        self.charlie = User.objects.create_user('charlie', 'charlie@example.com', 'secret')
        invitation = Invitation(user=self.charlie, invited=right_now, used=right_now)
        invitation.save()
        code = InvitationCode(owner=self.charlie)
        code.save()

    def test_always_allow_view(self):
        response = self.client.get(reverse('always_allow'))
        self.assertEqual(response.status_code, 200)

    def test_always_allow_module(self):
        response = self.client.get(reverse('always_allow_module'))
        self.assertEqual(response.status_code, 200)

    def test_garden_when_not_invited(self):
        """Confirm that an unauthenticated user is redirected to login"""
        response = self.client.get(reverse('invited_only'))
        self.assertRedirects(response, setting('LOGIN_URL'))

    def test_using_invite(self):
        cary = User.objects.create_user('cary', 'cary@example.com', 'secret')
        self.client.login(username='cary', password='secret')
        response = self.client.get(reverse('invited_only'))
        self.assertRedirects(response, reverse(self.redirect))

        response = self.client.get(reverse('invited_only'))
        self.assertRedirects(response, reverse(self.redirect))
        invitation = Invitation.objects.get(user=cary)
        invitation.invited = now()
        invitation.save()
        response = self.client.get(reverse('invited_only'))
        self.assertEqual(response.status_code, 200)

    def test_user_invite(self):
        self.client.login(username='charlie', password='secret')
        response = self.client.post(reverse('hunger-invite'), {'email': 'cary@example.com'})
        self.assertEqual(response.status_code, 302)
        self.client.logout()

        # Replace with examining email body
        invitation = Invitation.objects.get(email='cary@example.com')
        self.client.get(reverse('hunger-verify', args=[invitation.code.code]))

        User.objects.create_user('dany', 'dany@example.com', 'secret')
        self.client.login(username='dany', password='secret')
        response = self.client.get(reverse('invited_only'))
        # Dany should be denied, since he has no connection with email account
        self.assertEqual(response.status_code, 302)

    def test_invite_non_user_with_email(self):
        self.create_invite(email='dany@example.com')
        User.objects.create_user('dany', 'dany@example.com', 'secret')
        self.client.login(username='dany', password='secret')
        response = self.client.get(reverse('invited_only'))
        self.assertEqual(response.status_code, 200)

    def test_invite_existing_user_with_email(self):
        self.create_invite(email='alice@example.com')
        self.client.login(username='alice', password='secret')
        response = self.client.get(reverse('invited_only'))
        self.assertEqual(response.status_code, 200)

    def test_invite_non_user_without_email(self):
        code = self.create_code(email='dany1@example.com')
        self.client.get(reverse('hunger-verify', args=[code.code]))
        User.objects.create_user('dany', 'dany@example.com', 'secret')
        self.client.login(username='dany', password='secret')
        response = self.client.get(reverse('invited_only'))
        # Dany should be denied, since he has no connection with email account
        self.assertEqual(response.status_code, 302)

    def test_invite_existing_user_without_email(self):
        code = self.create_code(email='alice1@example.com')
        self.client.get(reverse('hunger-verify', args=[code.code]))
        self.client.login(username='alice', password='secret')
        response = self.client.get(reverse('invited_only'))
        # Alice should be denied, since she has no connection with email account
        self.assertEqual(response.status_code, 302)

    def test_invalid_code(self):
        invalid_code = 'XXXXinvalidcodeXXXX'
        self.client.login(username='alice', password='secret')
        response = self.client.get(reverse('hunger-verify', args=[invalid_code]), follow=True)
        self.assertRedirects(response, reverse('hunger-invalid', args=[invalid_code]))

########NEW FILE########
__FILENAME__ = urls
from __future__ import unicode_literals
from django.conf.urls import patterns, url, include


urlpatterns = patterns(
    '',
    url(r'^invited-only/$', 'tests.views.invited_only', name='invited_only'),
    url(r'^always-allow/$', 'tests.views.always_allow', name='always_allow'),
    url(r'^always-allow-module/$', 'tests.always_allow_views.allowed',
        name='always_allow_module'),
    url(r'^not-allowed/$', 'tests.views.rejection', name='rejection'),
    url(r'^hunger/', include('hunger.urls')),
    url(r'^accounts/', include('django.contrib.auth.urls'))
)

########NEW FILE########
__FILENAME__ = views
from __future__ import unicode_literals
from django.shortcuts import render


def always_allow(request):
    return render(request, 'default.html')


def rejection(request):
    return render(request, 'default.html')


def invited_only(request):
    return render(request, 'default.html')

########NEW FILE########
