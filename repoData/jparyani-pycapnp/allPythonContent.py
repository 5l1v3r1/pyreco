__FILENAME__ = addressbook.capnp.orphan
from __future__ import print_function
import os
import capnp

this_dir = os.path.dirname(__file__)
addressbook = capnp.load(os.path.join(this_dir, 'addressbook.capnp'))

print = lambda *x: x


def writeAddressBook():
    addressBook = addressbook.AddressBook.new_message()
    people = addressBook.init_resizable_list('people')

    alice = people.add()
    alice.id = 123
    alice.name = 'Alice'
    alice.email = 'alice@example.com'
    alicePhones = alice.init('phones', 1)
    alicePhones[0].number = "555-1212"
    alicePhones[0].type = 'mobile'

    bob = people.add()
    bob.id = 456
    bob.name = 'Bob'
    bob.email = 'bob@example.com'
    bobPhones = bob.init('phones', 2)
    bobPhones[0].number = "555-4567"
    bobPhones[0].type = 'home'
    bobPhones[1].number = "555-7654"
    bobPhones[1].type = 'work'

    people.finish()
    msg_bytes = addressBook.to_bytes()
    return msg_bytes

def printAddressBook(msg_bytes):
    addressBook = addressbook.AddressBook.from_bytes(msg_bytes)

    for person in addressBook.people:
        print(person.name, ':', person.email)
        for phone in person.phones:
            print(phone.type, ':', phone.number)
        print()


if __name__ == '__main__':
    for i in range(10000):
        msg_bytes = writeAddressBook()

        printAddressBook(msg_bytes)


########NEW FILE########
__FILENAME__ = addressbook.capnp
from __future__ import print_function
import os
import capnp

this_dir = os.path.dirname(__file__)
addressbook = capnp.load(os.path.join(this_dir, 'addressbook.capnp'))

print = lambda *x: x


def writeAddressBook():
    addressBook = addressbook.AddressBook.new_message()
    people = addressBook.init('people', 2)

    alice = people[0]
    alice.id = 123
    alice.name = 'Alice'
    alice.email = 'alice@example.com'
    alicePhones = alice.init('phones', 1)
    alicePhones[0].number = "555-1212"
    alicePhones[0].type = 'mobile'

    bob = people[1]
    bob.id = 456
    bob.name = 'Bob'
    bob.email = 'bob@example.com'
    bobPhones = bob.init('phones', 2)
    bobPhones[0].number = "555-4567"
    bobPhones[0].type = 'home'
    bobPhones[1].number = "555-7654"
    bobPhones[1].type = 'work'

    msg_bytes = addressBook.to_bytes()
    return msg_bytes

def printAddressBook(msg_bytes):
    addressBook = addressbook.AddressBook.from_bytes(msg_bytes)

    for person in addressBook.people:
        print(person.name, ':', person.email)
        for phone in person.phones:
            print(phone.type, ':', phone.number)
        print()


if __name__ == '__main__':
    for i in range(10000):
        msg_bytes = writeAddressBook()

        printAddressBook(msg_bytes)


########NEW FILE########
__FILENAME__ = addressbook.proto
from __future__ import print_function
import addressbook_pb2 as addressbook
import os

print = lambda *x: x


def writeAddressBook():
    addressBook = addressbook.AddressBook()

    alice = addressBook.person.add()
    alice.id = 123
    alice.name = 'Alice'
    alice.email = 'alice@example.com'
    alicePhones = [alice.phone.add()]
    alicePhones[0].number = "555-1212"
    alicePhones[0].type = addressbook.Person.MOBILE

    bob = addressBook.person.add()
    bob.id = 456
    bob.name = 'Bob'
    bob.email = 'bob@example.com'
    bobPhones = [bob.phone.add(), bob.phone.add()]
    bobPhones[0].number = "555-4567"
    bobPhones[0].type = addressbook.Person.HOME
    bobPhones[1].number = "555-7654"
    bobPhones[1].type = addressbook.Person.WORK

    message_string = addressBook.SerializeToString()
    return message_string


def printAddressBook(message_string):
    addressBook = addressbook.AddressBook()
    addressBook.ParseFromString(message_string)

    for person in addressBook.person:
        print(person.name, ':', person.email)
        for phone in person.phone:
            print(phone.type, ':', phone.number)
        print()


if __name__ == '__main__':
    for i in range(10000):
        message_string = writeAddressBook()

        printAddressBook(message_string)


########NEW FILE########
__FILENAME__ = addressbook_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: addressbook.proto

from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)




DESCRIPTOR = _descriptor.FileDescriptor(
  name='addressbook.proto',
  package='tutorial',
  serialized_pb='\n\x11\x61\x64\x64ressbook.proto\x12\x08tutorial\"\xda\x01\n\x06Person\x12\x0c\n\x04name\x18\x01 \x02(\t\x12\n\n\x02id\x18\x02 \x02(\x05\x12\r\n\x05\x65mail\x18\x03 \x01(\t\x12+\n\x05phone\x18\x04 \x03(\x0b\x32\x1c.tutorial.Person.PhoneNumber\x1aM\n\x0bPhoneNumber\x12\x0e\n\x06number\x18\x01 \x02(\t\x12.\n\x04type\x18\x02 \x01(\x0e\x32\x1a.tutorial.Person.PhoneType:\x04HOME\"+\n\tPhoneType\x12\n\n\x06MOBILE\x10\x00\x12\x08\n\x04HOME\x10\x01\x12\x08\n\x04WORK\x10\x02\"/\n\x0b\x41\x64\x64ressBook\x12 \n\x06person\x18\x01 \x03(\x0b\x32\x10.tutorial.Person')



_PERSON_PHONETYPE = _descriptor.EnumDescriptor(
  name='PhoneType',
  full_name='tutorial.Person.PhoneType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='MOBILE', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='HOME', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='WORK', index=2, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=207,
  serialized_end=250,
)


_PERSON_PHONENUMBER = _descriptor.Descriptor(
  name='PhoneNumber',
  full_name='tutorial.Person.PhoneNumber',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='number', full_name='tutorial.Person.PhoneNumber.number', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='type', full_name='tutorial.Person.PhoneNumber.type', index=1,
      number=2, type=14, cpp_type=8, label=1,
      has_default_value=True, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=128,
  serialized_end=205,
)

_PERSON = _descriptor.Descriptor(
  name='Person',
  full_name='tutorial.Person',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='name', full_name='tutorial.Person.name', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='id', full_name='tutorial.Person.id', index=1,
      number=2, type=5, cpp_type=1, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='email', full_name='tutorial.Person.email', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='phone', full_name='tutorial.Person.phone', index=3,
      number=4, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[_PERSON_PHONENUMBER, ],
  enum_types=[
    _PERSON_PHONETYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=32,
  serialized_end=250,
)


_ADDRESSBOOK = _descriptor.Descriptor(
  name='AddressBook',
  full_name='tutorial.AddressBook',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='person', full_name='tutorial.AddressBook.person', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=252,
  serialized_end=299,
)

_PERSON_PHONENUMBER.fields_by_name['type'].enum_type = _PERSON_PHONETYPE
_PERSON_PHONENUMBER.containing_type = _PERSON;
_PERSON.fields_by_name['phone'].message_type = _PERSON_PHONENUMBER
_PERSON_PHONETYPE.containing_type = _PERSON;
_ADDRESSBOOK.fields_by_name['person'].message_type = _PERSON
DESCRIPTOR.message_types_by_name['Person'] = _PERSON
DESCRIPTOR.message_types_by_name['AddressBook'] = _ADDRESSBOOK

class Person(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType

  class PhoneNumber(_message.Message):
    __metaclass__ = _reflection.GeneratedProtocolMessageType
    DESCRIPTOR = _PERSON_PHONENUMBER

    # @@protoc_insertion_point(class_scope:tutorial.Person.PhoneNumber)
  DESCRIPTOR = _PERSON

  # @@protoc_insertion_point(class_scope:tutorial.Person)

class AddressBook(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ADDRESSBOOK

  # @@protoc_insertion_point(class_scope:tutorial.AddressBook)


# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python

import argparse
import sys
import os
from importlib import import_module
from timeit import default_timer
import random

_this_dir = os.path.dirname(__file__)
sys.path.append(os.path.join(_this_dir, '..'))
from common import do_benchmark

def parse_args_simple():
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", help="Mode to use for serialization, ie. object or bytes")
    parser.add_argument("reuse", help="Currently ignored")
    parser.add_argument("compression", help="Valid values are none or packed")
    parser.add_argument("iters", help="Number of iterations to run for", type=int)
    parser.add_argument("-I", "--includes", help="Directories to add to PYTHONPATH", default='/usr/local/include')

    return parser.parse_args()

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("name", help="Name of the benchmark to run, eg. carsales", nargs='?', default='carsales')
    parser.add_argument("-c", "--compression", help="Specify the compression type", default=None)
    parser.add_argument("-s", "--suffix", help="Choose the protocol type.", default='pycapnp')
    parser.add_argument("-m", "--mode", help="Specify the mode", default='object')
    parser.add_argument("-i", "--iters", help="Specify the number of iterations manually. By default, it will be looked up in preset table", default=10, type=int)
    parser.add_argument("-r", "--reuse", help="If this flag is passed, objects will be re-used", action='store_true')
    parser.add_argument("-I", "--includes", help="Directories to add to PYTHONPATH", default='/usr/local/include')

    return parser.parse_args()

def run_test(name, mode, reuse, compression, iters, suffix, includes):
    tic = default_timer()

    name = name
    sys.path.append(includes)
    module = import_module(name + '_' + suffix)
    benchmark = module.Benchmark(compression=compression)

    do_benchmark(mode=mode, benchmark=benchmark, iters=iters, reuse=reuse)
    toc = default_timer()
    return toc - tic

def main():
    args = parse_args()
    run_test(**vars(args))

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = run_all
#!/usr/bin/env python
from __future__ import print_function

from subprocess import Popen, PIPE
import sys
import os
import json
import argparse

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', "--langs", help="Add languages to test, ie: -l capnproto -l protobuf", action='append', default=['pycapnp', 'pyproto', 'pyproto_cpp'])
    parser.add_argument("-r", "--reuse", help="If this flag is passed, re-use tests will be run", action='store_true')
    parser.add_argument("-c", "--compression", help="If this flag is passed, compression tests will be run", action='store_true')
    parser.add_argument("-i", "--scale_iters", help="Scaling factor to multiply the default iters by", type=float, default=1.0)

    return parser.parse_args()

def run_one(prefix, name, mode, iters, faster, compression):
    res_type = prefix
    reuse = 'no-reuse'

    if faster:
        reuse = 'reuse'
        res_type += '_reuse'
    if compression != 'none':
        res_type += '_' + compression

    command = ["time", "-p", prefix+"-"+name, mode, reuse, compression, str(iters)]
    p = Popen(command, stdout=PIPE, stderr=PIPE)
    res = p.communicate()[1]

    data = {}

    if p.returncode != 0:
        sys.stderr.write(' '.join(command) + ' failed to run with errors: \n' + res + '\n')
        sys.stderr.flush()
    else:
        res = res.strip()

        for line in res.split('\n'):
            vals = line.split()
            data[vals[0]] = float(vals[1])

    data['type'] = res_type
    data['mode'] = mode
    data['name'] = name
    data['iters'] = iters

    return data


def run_each(name, langs, reuse, compression, iters):
    ret = []

    for lang_name in langs:
        ret.append(run_one(lang_name, name, 'object', iters, False, 'none'))
        ret.append(run_one(lang_name, name, 'bytes', iters, False, 'none'))
        if reuse:
            ret.append(run_one(lang_name, name, 'object', iters, True, 'none'))
            ret.append(run_one(lang_name, name, 'bytes', iters, True, 'none'))
            if compression:
                ret.append(run_one(lang_name, name, 'bytes', iters, True, 'packed'))
        if compression:
            ret.append(run_one(lang_name, name, 'bytes', iters, False, 'packed'))

    return ret

def main():
    args = parse_args()

    os.environ['PATH'] += ':.'

    data = []
    data += run_each('carsales', args.langs, args.reuse, args.compression, int(2000 * args.scale_iters))
    data += run_each('catrank', args.langs, args.reuse, args.compression, int(100 * args.scale_iters))
    data += run_each('eval', args.langs, args.reuse, args.compression, int(10000 * args.scale_iters))
    json.dump(data, sys.stdout, sort_keys=True, indent=4, separators=(',', ': '))

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = carsales_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: carsales.proto

from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)




DESCRIPTOR = _descriptor.FileDescriptor(
  name='carsales.proto',
  package='capnp.benchmark.protobuf',
  serialized_pb='\n\x0e\x63\x61rsales.proto\x12\x18\x63\x61pnp.benchmark.protobuf\"8\n\nParkingLot\x12*\n\x03\x63\x61r\x18\x01 \x03(\x0b\x32\x1d.capnp.benchmark.protobuf.Car\"\x1c\n\nTotalValue\x12\x0e\n\x06\x61mount\x18\x01 \x02(\x04\"\xbc\x03\n\x03\x43\x61r\x12\x0c\n\x04make\x18\x01 \x01(\t\x12\r\n\x05model\x18\x02 \x01(\t\x12.\n\x05\x63olor\x18\x03 \x01(\x0e\x32\x1f.capnp.benchmark.protobuf.Color\x12\r\n\x05seats\x18\x04 \x01(\r\x12\r\n\x05\x64oors\x18\x05 \x01(\r\x12.\n\x05wheel\x18\x06 \x03(\x0b\x32\x1f.capnp.benchmark.protobuf.Wheel\x12\x0e\n\x06length\x18\x07 \x01(\r\x12\r\n\x05width\x18\x08 \x01(\r\x12\x0e\n\x06height\x18\t \x01(\r\x12\x0e\n\x06weight\x18\n \x01(\r\x12\x30\n\x06\x65ngine\x18\x0b \x01(\x0b\x32 .capnp.benchmark.protobuf.Engine\x12\x15\n\rfuel_capacity\x18\x0c \x01(\x02\x12\x12\n\nfuel_level\x18\r \x01(\x02\x12\x19\n\x11has_power_windows\x18\x0e \x01(\x08\x12\x1a\n\x12has_power_steering\x18\x0f \x01(\x08\x12\x1a\n\x12has_cruise_control\x18\x10 \x01(\x08\x12\x13\n\x0b\x63up_holders\x18\x11 \x01(\r\x12\x16\n\x0ehas_nav_system\x18\x12 \x01(\x08\"C\n\x05Wheel\x12\x10\n\x08\x64iameter\x18\x01 \x01(\r\x12\x14\n\x0c\x61ir_pressure\x18\x02 \x01(\x02\x12\x12\n\nsnow_tires\x18\x03 \x01(\x08\"d\n\x06\x45ngine\x12\x12\n\nhorsepower\x18\x01 \x01(\r\x12\x11\n\tcylinders\x18\x02 \x01(\r\x12\n\n\x02\x63\x63\x18\x03 \x01(\r\x12\x10\n\x08uses_gas\x18\x04 \x01(\x08\x12\x15\n\ruses_electric\x18\x05 \x01(\x08*j\n\x05\x43olor\x12\t\n\x05\x42LACK\x10\x00\x12\t\n\x05WHITE\x10\x01\x12\x07\n\x03RED\x10\x02\x12\t\n\x05GREEN\x10\x03\x12\x08\n\x04\x42LUE\x10\x04\x12\x08\n\x04\x43YAN\x10\x05\x12\x0b\n\x07MAGENTA\x10\x06\x12\n\n\x06YELLOW\x10\x07\x12\n\n\x06SILVER\x10\x08')

_COLOR = _descriptor.EnumDescriptor(
  name='Color',
  full_name='capnp.benchmark.protobuf.Color',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='BLACK', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='WHITE', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='RED', index=2, number=2,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='GREEN', index=3, number=3,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='BLUE', index=4, number=4,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='CYAN', index=5, number=5,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='MAGENTA', index=6, number=6,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='YELLOW', index=7, number=7,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='SILVER', index=8, number=8,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=750,
  serialized_end=856,
)

Color = enum_type_wrapper.EnumTypeWrapper(_COLOR)
BLACK = 0
WHITE = 1
RED = 2
GREEN = 3
BLUE = 4
CYAN = 5
MAGENTA = 6
YELLOW = 7
SILVER = 8



_PARKINGLOT = _descriptor.Descriptor(
  name='ParkingLot',
  full_name='capnp.benchmark.protobuf.ParkingLot',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='car', full_name='capnp.benchmark.protobuf.ParkingLot.car', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=44,
  serialized_end=100,
)


_TOTALVALUE = _descriptor.Descriptor(
  name='TotalValue',
  full_name='capnp.benchmark.protobuf.TotalValue',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='amount', full_name='capnp.benchmark.protobuf.TotalValue.amount', index=0,
      number=1, type=4, cpp_type=4, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=102,
  serialized_end=130,
)


_CAR = _descriptor.Descriptor(
  name='Car',
  full_name='capnp.benchmark.protobuf.Car',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='make', full_name='capnp.benchmark.protobuf.Car.make', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='model', full_name='capnp.benchmark.protobuf.Car.model', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='color', full_name='capnp.benchmark.protobuf.Car.color', index=2,
      number=3, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='seats', full_name='capnp.benchmark.protobuf.Car.seats', index=3,
      number=4, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='doors', full_name='capnp.benchmark.protobuf.Car.doors', index=4,
      number=5, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='wheel', full_name='capnp.benchmark.protobuf.Car.wheel', index=5,
      number=6, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='length', full_name='capnp.benchmark.protobuf.Car.length', index=6,
      number=7, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='width', full_name='capnp.benchmark.protobuf.Car.width', index=7,
      number=8, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='height', full_name='capnp.benchmark.protobuf.Car.height', index=8,
      number=9, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='weight', full_name='capnp.benchmark.protobuf.Car.weight', index=9,
      number=10, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='engine', full_name='capnp.benchmark.protobuf.Car.engine', index=10,
      number=11, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='fuel_capacity', full_name='capnp.benchmark.protobuf.Car.fuel_capacity', index=11,
      number=12, type=2, cpp_type=6, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='fuel_level', full_name='capnp.benchmark.protobuf.Car.fuel_level', index=12,
      number=13, type=2, cpp_type=6, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='has_power_windows', full_name='capnp.benchmark.protobuf.Car.has_power_windows', index=13,
      number=14, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='has_power_steering', full_name='capnp.benchmark.protobuf.Car.has_power_steering', index=14,
      number=15, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='has_cruise_control', full_name='capnp.benchmark.protobuf.Car.has_cruise_control', index=15,
      number=16, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='cup_holders', full_name='capnp.benchmark.protobuf.Car.cup_holders', index=16,
      number=17, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='has_nav_system', full_name='capnp.benchmark.protobuf.Car.has_nav_system', index=17,
      number=18, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=133,
  serialized_end=577,
)


_WHEEL = _descriptor.Descriptor(
  name='Wheel',
  full_name='capnp.benchmark.protobuf.Wheel',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='diameter', full_name='capnp.benchmark.protobuf.Wheel.diameter', index=0,
      number=1, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='air_pressure', full_name='capnp.benchmark.protobuf.Wheel.air_pressure', index=1,
      number=2, type=2, cpp_type=6, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='snow_tires', full_name='capnp.benchmark.protobuf.Wheel.snow_tires', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=579,
  serialized_end=646,
)


_ENGINE = _descriptor.Descriptor(
  name='Engine',
  full_name='capnp.benchmark.protobuf.Engine',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='horsepower', full_name='capnp.benchmark.protobuf.Engine.horsepower', index=0,
      number=1, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='cylinders', full_name='capnp.benchmark.protobuf.Engine.cylinders', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='cc', full_name='capnp.benchmark.protobuf.Engine.cc', index=2,
      number=3, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='uses_gas', full_name='capnp.benchmark.protobuf.Engine.uses_gas', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='uses_electric', full_name='capnp.benchmark.protobuf.Engine.uses_electric', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=648,
  serialized_end=748,
)

_PARKINGLOT.fields_by_name['car'].message_type = _CAR
_CAR.fields_by_name['color'].enum_type = _COLOR
_CAR.fields_by_name['wheel'].message_type = _WHEEL
_CAR.fields_by_name['engine'].message_type = _ENGINE
DESCRIPTOR.message_types_by_name['ParkingLot'] = _PARKINGLOT
DESCRIPTOR.message_types_by_name['TotalValue'] = _TOTALVALUE
DESCRIPTOR.message_types_by_name['Car'] = _CAR
DESCRIPTOR.message_types_by_name['Wheel'] = _WHEEL
DESCRIPTOR.message_types_by_name['Engine'] = _ENGINE

class ParkingLot(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PARKINGLOT

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.ParkingLot)

class TotalValue(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TOTALVALUE

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.TotalValue)

class Car(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _CAR

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.Car)

class Wheel(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _WHEEL

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.Wheel)

class Engine(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ENGINE

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.Engine)


# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = carsales_proto
#!/usr/bin/env python

import carsales_pb2
from common import rand_int, rand_double, rand_bool, from_bytes_helper
from random import choice

MAKES = ["Toyota", "GM", "Ford", "Honda", "Tesla"]
MODELS = ["Camry", "Prius", "Volt", "Accord", "Leaf", "Model S"]
COLORS = ["black", "white", "red", "green", "blue", "cyan", "magenta", "yellow", "silver"]

def random_car(car):
    car.make = choice(MAKES)
    car.model = choice(MODELS)
    car.color = rand_int(len(COLORS))

    car.seats = 2 + rand_int(6)
    car.doors = 2 + rand_int(3)

    for _ in range(4):
        wheel = car.wheel.add()
        wheel.diameter = 25 + rand_int(15)
        wheel.air_pressure = 30 + rand_double(20)
        wheel.snow_tires = rand_int(16) == 0

    car.length = 170 + rand_int(150)
    car.width = 48 + rand_int(36)
    car.height = 54 + rand_int(48)
    car.weight = car.length * car.width * car.height / 200

    engine = car.engine
    engine.horsepower = 100 * rand_int(400)
    engine.cylinders = 4 + 2 * rand_int(3)
    engine.cc = 800 + rand_int(10000)
    engine.uses_gas = True
    engine.uses_electric = rand_bool()

    car.fuel_capacity = 10.0 + rand_double(30.0)
    car.fuel_level = rand_double(car.fuel_capacity)
    car.has_power_windows = rand_bool()
    car.has_power_steering = rand_bool()
    car.has_cruise_control = rand_bool()
    car.cup_holders = rand_int(12)
    car.has_nav_system = rand_bool()

def calc_value(car):
    result = 0

    result += car.seats * 200
    result += car.doors * 350
    for wheel in car.wheel:
        result += wheel.diameter * wheel.diameter
        result += 100 if wheel.snow_tires else 0

    result += car.length * car.width * car.height / 50

    engine = car.engine
    result += engine.horsepower * 40
    if engine.uses_electric:
        if engine.uses_gas:
          result += 5000
        else:
          result += 3000

    result += 100 if car.has_power_windows else 0
    result += 200 if car.has_power_steering else 0
    result += 400 if car.has_cruise_control else 0
    result += 2000 if car.has_nav_system else 0

    result += car.cup_holders * 25

    return result

class Benchmark:
    def __init__(self, compression):
        self.Request = carsales_pb2.ParkingLot
        self.Response = carsales_pb2.TotalValue
        self.from_bytes_request = from_bytes_helper(carsales_pb2.ParkingLot)
        self.from_bytes_response = from_bytes_helper(carsales_pb2.TotalValue)
        self.to_bytes = lambda x: x.SerializeToString()

    def setup(self, request):
        result = 0
        for _ in range(rand_int(200)):
          car = request.car.add()
          random_car(car)
          result += calc_value(car)
        return result

    def handle(self, request, response):
        result = 0
        for car in request.car:
          result += calc_value(car)

        response.amount = result

    def check(self, response, expected):
        return response.amount == expected
########NEW FILE########
__FILENAME__ = carsales_pycapnp
#!/usr/bin/env python

import capnp
import carsales_capnp
from common import rand_int, rand_double, rand_bool
from random import choice

MAKES = ["Toyota", "GM", "Ford", "Honda", "Tesla"]
MODELS = ["Camry", "Prius", "Volt", "Accord", "Leaf", "Model S"]
COLORS = ["black", "white", "red", "green", "blue", "cyan", "magenta", "yellow", "silver"]

def random_car(car):
    car.make = choice(MAKES)
    car.model = choice(MODELS)
    car.color = choice(COLORS)

    car.seats = 2 + rand_int(6)
    car.doors = 2 + rand_int(3)

    for wheel in car.init('wheels', 4):
        wheel.diameter = 25 + rand_int(15)
        wheel.airPressure = 30 + rand_double(20)
        wheel.snowTires = rand_int(16) == 0

    car.length = 170 + rand_int(150)
    car.width = 48 + rand_int(36)
    car.height = 54 + rand_int(48)
    car.weight = car.length * car.width * car.height / 200

    engine = car.init('engine')
    engine.horsepower = 100 * rand_int(400)
    engine.cylinders = 4 + 2 * rand_int(3)
    engine.cc = 800 + rand_int(10000)
    engine.usesGas = True
    engine.usesElectric = rand_bool()

    car.fuelCapacity = 10.0 + rand_double(30.0)
    car.fuelLevel = rand_double(car.fuelCapacity)
    car.hasPowerWindows = rand_bool()
    car.hasPowerSteering = rand_bool()
    car.hasCruiseControl = rand_bool()
    car.cupHolders = rand_int(12)
    car.hasNavSystem = rand_bool()

def calc_value(car):
    result = 0

    result += car.seats * 200
    result += car.doors * 350
    for wheel in car.wheels:
        result += wheel.diameter * wheel.diameter
        result += 100 if wheel.snowTires else 0

    result += car.length * car.width * car.height / 50

    engine = car.engine
    result += engine.horsepower * 40
    if engine.usesElectric:
        if engine.usesGas:
          result += 5000
        else:
          result += 3000

    result += 100 if car.hasPowerWindows else 0
    result += 200 if car.hasPowerSteering else 0
    result += 400 if car.hasCruiseControl else 0
    result += 2000 if car.hasNavSystem else 0

    result += car.cupHolders * 25

    return result

class Benchmark:
    def __init__(self, compression):
        self.Request = carsales_capnp.ParkingLot.new_message
        self.Response = carsales_capnp.TotalValue.new_message
        if compression == 'packed':
            self.from_bytes_request = carsales_capnp.ParkingLot.from_bytes_packed
            self.from_bytes_response = carsales_capnp.TotalValue.from_bytes_packed
            self.to_bytes = lambda x: x.to_bytes_packed()
        else:
            self.from_bytes_request = carsales_capnp.ParkingLot.from_bytes
            self.from_bytes_response = carsales_capnp.TotalValue.from_bytes
            self.to_bytes = lambda x: x.to_bytes()

    def setup(self, request):
        result = 0
        for car in request.init('cars', rand_int(200)):
          random_car(car)
          result += calc_value(car)
        return result

    def handle(self, request, response):
        result = 0
        for car in request.cars:
          result += calc_value(car)

        response.amount = result

    def check(self, response, expected):
        return response.amount == expected
########NEW FILE########
__FILENAME__ = catrank_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: catrank.proto

from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)




DESCRIPTOR = _descriptor.FileDescriptor(
  name='catrank.proto',
  package='capnp.benchmark.protobuf',
  serialized_pb='\n\rcatrank.proto\x12\x18\x63\x61pnp.benchmark.protobuf\"J\n\x10SearchResultList\x12\x36\n\x06result\x18\x01 \x03(\x0b\x32&.capnp.benchmark.protobuf.SearchResult\";\n\x0cSearchResult\x12\x0b\n\x03url\x18\x01 \x01(\t\x12\r\n\x05score\x18\x02 \x01(\x01\x12\x0f\n\x07snippet\x18\x03 \x01(\t')




_SEARCHRESULTLIST = _descriptor.Descriptor(
  name='SearchResultList',
  full_name='capnp.benchmark.protobuf.SearchResultList',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='result', full_name='capnp.benchmark.protobuf.SearchResultList.result', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=43,
  serialized_end=117,
)


_SEARCHRESULT = _descriptor.Descriptor(
  name='SearchResult',
  full_name='capnp.benchmark.protobuf.SearchResult',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='url', full_name='capnp.benchmark.protobuf.SearchResult.url', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='score', full_name='capnp.benchmark.protobuf.SearchResult.score', index=1,
      number=2, type=1, cpp_type=5, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='snippet', full_name='capnp.benchmark.protobuf.SearchResult.snippet', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=119,
  serialized_end=178,
)

_SEARCHRESULTLIST.fields_by_name['result'].message_type = _SEARCHRESULT
DESCRIPTOR.message_types_by_name['SearchResultList'] = _SEARCHRESULTLIST
DESCRIPTOR.message_types_by_name['SearchResult'] = _SEARCHRESULT

class SearchResultList(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _SEARCHRESULTLIST

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.SearchResultList)

class SearchResult(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _SEARCHRESULT

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.SearchResult)


# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = catrank_proto
#!/usr/bin/env python

from common import rand_int, rand_double, rand_bool, WORDS, from_bytes_helper
from random import choice
from string import letters
from itertools import izip
import catrank_pb2

class Benchmark:
    def __init__(self, compression):
        self.Request = catrank_pb2.SearchResultList
        self.Response = catrank_pb2.SearchResultList
        self.from_bytes_request = from_bytes_helper(catrank_pb2.SearchResultList)
        self.from_bytes_response = from_bytes_helper(catrank_pb2.SearchResultList)
        self.to_bytes = lambda x: x.SerializeToString()

    def setup(self, request):
        goodCount = 0
        count = rand_int(1000)

        for i in range(count):
            result = request.result.add()
            result.score = 1000 - i
            url_size = rand_int(100)
            result.url = "http://example.com/" + ''.join([choice(letters) for _ in range(url_size)])

            isCat = rand_bool()
            isDog = rand_bool()
            if isCat and not isDog:
                goodCount += 1

            snippet = [choice(WORDS) for i in range(rand_int(20))]

            if isCat:
                snippet.append(" cat ")
            if isDog:
                snippet.append(" dog ")

            snippet += [choice(WORDS) for i in range(rand_int(20))]

            result.snippet = ''.join(snippet)

        return goodCount

    def handle(self, request, response):
        for req in request.result:
            resp = response.result.add()
            score = req.score

            if " cat " in req.snippet:
                score *= 10000
            if " dog " in req.snippet:
                score /= 10000

            resp.score = score
            resp.url = req.url
            resp.snippet = req.snippet


    def check(self, response, expected):
        goodCount = 0
        
        for result in response.result:
            if result.score > 1001:
                goodCount += 1

        return goodCount == expected

########NEW FILE########
__FILENAME__ = catrank_pycapnp
#!/usr/bin/env python

import capnp
import catrank_capnp
from common import rand_int, rand_double, rand_bool, WORDS
from random import choice
from string import letters
from itertools import izip

class Benchmark:
    def __init__(self, compression):
        self.Request = catrank_capnp.SearchResultList.new_message
        self.Response = catrank_capnp.SearchResultList.new_message
        if compression == 'packed':
            self.from_bytes_request = catrank_capnp.SearchResultList.from_bytes_packed
            self.from_bytes_response = catrank_capnp.SearchResultList.from_bytes_packed
            self.to_bytes = lambda x: x.to_bytes_packed()
        else:
            self.from_bytes_request = catrank_capnp.SearchResultList.from_bytes
            self.from_bytes_response = catrank_capnp.SearchResultList.from_bytes
            self.to_bytes = lambda x: x.to_bytes()

    def setup(self, request):
        goodCount = 0
        count = rand_int(1000)

        results = request.init('results', count)

        for i, result in enumerate(results):
            result.score = 1000 - i
            url_size = rand_int(100)
            result.url = "http://example.com/" + ''.join([choice(letters) for _ in range(url_size)])

            isCat = rand_bool()
            isDog = rand_bool()
            if isCat and not isDog:
                goodCount += 1

            snippet = [choice(WORDS) for i in range(rand_int(20))]

            if isCat:
                snippet.append(" cat ")
            if isDog:
                snippet.append(" dog ")

            snippet += [choice(WORDS) for i in range(rand_int(20))]

            result.snippet = ''.join(snippet)

        return goodCount

    def handle(self, request, response):
        results = response.init('results', len(request.results))

        for req, resp in izip(request.results, results):
            score = req.score

            if " cat " in req.snippet:
                score *= 10000
            if " dog " in req.snippet:
                score /= 10000

            resp.score = score
            resp.url = req.url
            resp.snippet = req.snippet


    def check(self, response, expected):
        goodCount = 0

        for result in response.results:
            if result.score > 1001:
                goodCount += 1

        return goodCount == expected

########NEW FILE########
__FILENAME__ = common
from random import random
import pyximport
importers = pyximport.install()
from common_fast import rand_int, rand_double, rand_bool 
pyximport.uninstall(*importers)

WORDS = ["foo ", "bar ", "baz ", "qux ", "quux ", "corge ", "grault ", "garply ", "waldo ", "fred ",
    "plugh ", "xyzzy ", "thud "]

def from_bytes_helper(klass):
    def helper(text):
        obj = klass()
        obj.ParseFromString(text)
        return obj
    return helper

def pass_by_object(reuse, iters, benchmark):
    for _ in range(iters):
        request = benchmark.Request()
        expected = benchmark.setup(request)

        response = benchmark.Response()
        benchmark.handle(request, response)

        if not benchmark.check(response, expected):
            raise ValueError('Expected {}'.format(expected))

def pass_by_bytes(reuse, iters, benchmark):
    for _ in range(iters):
        request = benchmark.Request()
        expected = benchmark.setup(request)
        req_bytes = benchmark.to_bytes(request)

        request2 = benchmark.from_bytes_request(req_bytes)
        response = benchmark.Response()
        benchmark.handle(request2, response)
        resp_bytes = benchmark.to_bytes(response)

        response2 = benchmark.from_bytes_response(resp_bytes)
        if not benchmark.check(response2, expected):
            raise ValueError('Expected {}'.format(expected))

def do_benchmark(mode, *args, **kwargs):
    if mode == "client":
        pass
    elif mode == "object":
        return pass_by_object(*args, **kwargs)
    elif mode == "bytes":
        return pass_by_bytes(*args, **kwargs)
    else:
        raise ValueError("Unknown mode: " + str(mode))
#   typedef typename BenchmarkTypes::template BenchmarkMethods<TestCase, Reuse, Compression>
#       BenchmarkMethods;
#   if (mode == "client") {
#     return BenchmarkMethods::syncClient(STDIN_FILENO, STDOUT_FILENO, iters);
#   } else if (mode == "server") {
#     return BenchmarkMethods::server(STDIN_FILENO, STDOUT_FILENO, iters);
#   } else if (mode == "object") {
#     return BenchmarkMethods::passByObject(iters, false);
#   } else if (mode == "object-size") {
#     return BenchmarkMethods::passByObject(iters, true);
#   } else if (mode == "bytes") {
#     return BenchmarkMethods::passByBytes(iters);
#   } else if (mode == "pipe") {
#     return passByPipe<BenchmarkMethods>(BenchmarkMethods::syncClient, iters);
#   } else if (mode == "pipe-async") {
#     return passByPipe<BenchmarkMethods>(BenchmarkMethods::asyncClient, iters);
#   } else {
#     fprintf(stderr, "Unknown mode: %s\n", mode.c_str());
#     exit(1);
#   }
# }
########NEW FILE########
__FILENAME__ = eval_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: eval.proto

from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)




DESCRIPTOR = _descriptor.FileDescriptor(
  name='eval.proto',
  package='capnp.benchmark.protobuf',
  serialized_pb='\n\neval.proto\x12\x18\x63\x61pnp.benchmark.protobuf\"\xe5\x01\n\nExpression\x12/\n\x02op\x18\x01 \x02(\x0e\x32#.capnp.benchmark.protobuf.Operation\x12\x12\n\nleft_value\x18\x02 \x01(\x05\x12=\n\x0fleft_expression\x18\x03 \x01(\x0b\x32$.capnp.benchmark.protobuf.Expression\x12\x13\n\x0bright_value\x18\x04 \x01(\x05\x12>\n\x10right_expression\x18\x05 \x01(\x0b\x32$.capnp.benchmark.protobuf.Expression\"!\n\x10\x45valuationResult\x12\r\n\x05value\x18\x01 \x02(\x11*I\n\tOperation\x12\x07\n\x03\x41\x44\x44\x10\x00\x12\x0c\n\x08SUBTRACT\x10\x01\x12\x0c\n\x08MULTIPLY\x10\x02\x12\n\n\x06\x44IVIDE\x10\x03\x12\x0b\n\x07MODULUS\x10\x04')

_OPERATION = _descriptor.EnumDescriptor(
  name='Operation',
  full_name='capnp.benchmark.protobuf.Operation',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='ADD', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='SUBTRACT', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='MULTIPLY', index=2, number=2,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='DIVIDE', index=3, number=3,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='MODULUS', index=4, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=307,
  serialized_end=380,
)

Operation = enum_type_wrapper.EnumTypeWrapper(_OPERATION)
ADD = 0
SUBTRACT = 1
MULTIPLY = 2
DIVIDE = 3
MODULUS = 4



_EXPRESSION = _descriptor.Descriptor(
  name='Expression',
  full_name='capnp.benchmark.protobuf.Expression',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='op', full_name='capnp.benchmark.protobuf.Expression.op', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='left_value', full_name='capnp.benchmark.protobuf.Expression.left_value', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='left_expression', full_name='capnp.benchmark.protobuf.Expression.left_expression', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='right_value', full_name='capnp.benchmark.protobuf.Expression.right_value', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='right_expression', full_name='capnp.benchmark.protobuf.Expression.right_expression', index=4,
      number=5, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=41,
  serialized_end=270,
)


_EVALUATIONRESULT = _descriptor.Descriptor(
  name='EvaluationResult',
  full_name='capnp.benchmark.protobuf.EvaluationResult',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='value', full_name='capnp.benchmark.protobuf.EvaluationResult.value', index=0,
      number=1, type=17, cpp_type=1, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=272,
  serialized_end=305,
)

_EXPRESSION.fields_by_name['op'].enum_type = _OPERATION
_EXPRESSION.fields_by_name['left_expression'].message_type = _EXPRESSION
_EXPRESSION.fields_by_name['right_expression'].message_type = _EXPRESSION
DESCRIPTOR.message_types_by_name['Expression'] = _EXPRESSION
DESCRIPTOR.message_types_by_name['EvaluationResult'] = _EVALUATIONRESULT

class Expression(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _EXPRESSION

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.Expression)

class EvaluationResult(_message.Message):
  __metaclass__ = _reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _EVALUATIONRESULT

  # @@protoc_insertion_point(class_scope:capnp.benchmark.protobuf.EvaluationResult)


# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = eval_proto
#!/usr/bin/env python

from common import rand_int, rand_double, rand_bool, from_bytes_helper
from random import choice
import eval_pb2

MAX_INT = 2**31 - 1
MIN_INT = -(2**31)

OPERATIONS = [
  "add",
  "subtract",
  "multiply",
  "divide",
  "modulus"]

def clamp(res):
    if res > MAX_INT:
        return MAX_INT
    elif res < MIN_INT:
        return MIN_INT
    else:
        return res

def div(a, b):
    if b == 0:
        return MAX_INT
    if a == MIN_INT and b == -1:
        return MAX_INT

    return a / b

def mod(a, b):
    if b == 0:
        return MAX_INT
    if a == MIN_INT and b == -1:
        return MAX_INT

    return a % b

def make_expression(exp, depth):
    exp.op = rand_int(len(OPERATIONS))

    if rand_int(8) < depth:
        left = rand_int(128) + 1
        exp.left_value = left
    else:
        left = make_expression(exp.left_expression, depth+1)

    if rand_int(8) < depth:
        right = rand_int(128) + 1
        exp.right_value = right
    else:
        right = make_expression(exp.right_expression, depth+1)

    op = exp.op
    if op == 0:
        return clamp(left + right)
    elif op == 1:
        return clamp(left - right)
    elif op == 2:
        return clamp(left * right)
    elif op == 3:
        return div(left, right)
    elif op == 4:
        return mod(left, right)
    raise RuntimeError("op wasn't a valid value: " + str(op))

def evaluate_expression(exp):
    left = 0
    right = 0

    if exp.HasField('left_value'):
        left = exp.left_value
    else:
        left = evaluate_expression(exp.left_expression)

    if exp.HasField('right_value'):
        right = exp.right_value
    else:
        right = evaluate_expression(exp.right_expression)


    op = exp.op
    if op == 0:
        return clamp(left + right)
    elif op == 1:
        return clamp(left - right)
    elif op == 2:
        return clamp(left * right)
    elif op == 3:
        return div(left, right)
    elif op == 4:
        return mod(left, right)
    raise RuntimeError("op wasn't a valid value: " + str(op))

class Benchmark:
    def __init__(self, compression):
        self.Request = eval_pb2.Expression
        self.Response = eval_pb2.EvaluationResult
        self.from_bytes_request = from_bytes_helper(eval_pb2.Expression)
        self.from_bytes_response = from_bytes_helper(eval_pb2.EvaluationResult)
        self.to_bytes = lambda x: x.SerializeToString()

    def setup(self, request):
        return make_expression(request, 0)

    def handle(self, request, response):
        response.value = evaluate_expression(request)

    def check(self, response, expected):
        return response.value == expected
########NEW FILE########
__FILENAME__ = eval_pycapnp
#!/usr/bin/env python

import capnp
import eval_capnp
from common import rand_int, rand_double, rand_bool
from random import choice

MAX_INT = 2**31 - 1
MIN_INT = -(2**31)

OPERATIONS = [
  "add",
  "subtract",
  "multiply",
  "divide",
  "modulus"]

def clamp(res):
    if res > MAX_INT:
        return MAX_INT
    elif res < MIN_INT:
        return MIN_INT
    else:
        return res

def div(a, b):
    if b == 0:
        return MAX_INT
    if a == MIN_INT and b == -1:
        return MAX_INT

    return a / b

def mod(a, b):
    if b == 0:
        return MAX_INT
    if a == MIN_INT and b == -1:
        return MAX_INT

    return a % b

def make_expression(exp, depth):
    exp.op = choice(OPERATIONS)

    if rand_int(8) < depth:
        left = rand_int(128) + 1
        exp.left.value = left
    else:
        left = make_expression(exp.left.init('expression'), depth+1)

    if rand_int(8) < depth:
        right = rand_int(128) + 1
        exp.right.value = right
    else:
        right = make_expression(exp.right.init('expression'), depth+1)

    op = exp.op
    if op == 'add':
        return clamp(left + right)
    elif op == 'subtract':
        return clamp(left - right)
    elif op == 'multiply':
        return clamp(left * right)
    elif op == 'divide':
        return div(left, right)
    elif op == 'modulus':
        return mod(left, right)
    raise RuntimeError("op wasn't a valid value: " + str(op))

def evaluate_expression(exp):
    left = 0
    right = 0

    which = exp.left.which()
    if which == 'value':
        left = exp.left.value
    elif which == 'expression':
        left = evaluate_expression(exp.left.expression)

    which = exp.right.which()
    if which == 'value':
        right = exp.right.value
    elif which == 'expression':
        right = evaluate_expression(exp.right.expression)


    op = exp.op
    if op == 'add':
        return clamp(left + right)
    elif op == 'subtract':
        return clamp(left - right)
    elif op == 'multiply':
        return clamp(left * right)
    elif op == 'divide':
        return div(left, right)
    elif op == 'modulus':
        return mod(left, right)
    raise RuntimeError("op wasn't a valid value: " + str(op))

class Benchmark:
    def __init__(self, compression):
        self.Request = eval_capnp.Expression.new_message
        self.Response = eval_capnp.EvaluationResult.new_message
        if compression == 'packed':
            self.from_bytes_request = eval_capnp.Expression.from_bytes_packed
            self.from_bytes_response = eval_capnp.EvaluationResult.from_bytes_packed
            self.to_bytes = lambda x: x.to_bytes_packed()
        else:
            self.from_bytes_request = eval_capnp.Expression.from_bytes
            self.from_bytes_response = eval_capnp.EvaluationResult.from_bytes
            self.to_bytes = lambda x: x.to_bytes()

    def setup(self, request):
        return make_expression(request, 0)

    def handle(self, request, response):
        response.value = evaluate_expression(request)

    def check(self, response, expected):
        return response.value == expected
########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# capnp documentation build configuration file, created by
# sphinx-quickstart on Sat Aug 17 18:00:25 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, string

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'capnp'
copyright = u'2013, Author'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
import capnp

vs = capnp.__version__
# The short X.Y version.
version = vs.rstrip(string.letters)
# The full version, including alpha/beta/rc tags.
release = vs

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'capnpdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'capnp.tex', u'capnp Documentation',
   u'Author', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'capnp', u'capnp Documentation',
     [u'Author'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'capnp', u'capnp Documentation',
   u'Author', 'capnp', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'capnp'
epub_author = u'Author'
epub_publisher = u'Author'
epub_copyright = u'2013, Author'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = addressbook
from __future__ import print_function
import os
import capnp

import addressbook_capnp

def writeAddressBook(file):
    addresses = addressbook_capnp.AddressBook.new_message()
    people = addresses.init('people', 2)

    alice = people[0]
    alice.id = 123
    alice.name = 'Alice'
    alice.email = 'alice@example.com'
    alicePhones = alice.init('phones', 1)
    alicePhones[0].number = "555-1212"
    alicePhones[0].type = 'mobile'
    alice.employment.school = "MIT"

    bob = people[1]
    bob.id = 456
    bob.name = 'Bob'
    bob.email = 'bob@example.com'
    bobPhones = bob.init('phones', 2)
    bobPhones[0].number = "555-4567"
    bobPhones[0].type = 'home'
    bobPhones[1].number = "555-7654"
    bobPhones[1].type = 'work'
    bob.employment.unemployed = None

    addresses.write(file)


def printAddressBook(file):
    addresses = addressbook_capnp.AddressBook.read(file)

    for person in addresses.people:
        print(person.name, ':', person.email)
        for phone in person.phones:
            print(phone.type, ':', phone.number)

        which = person.employment.which()
        print(which)

        if which == 'unemployed':
            print('unemployed')
        elif which == 'employer':
            print('employer:', person.employment.employer)
        elif which == 'school':
            print('student at:', person.employment.school)
        elif which == 'selfEmployed':
            print('self employed')
        print()


if __name__ == '__main__':
    f = open('example', 'w')
    writeAddressBook(f)

    f = open('example', 'r')
    printAddressBook(f)

########NEW FILE########
__FILENAME__ = calculator_client
#!/usr/bin/env python

from __future__ import print_function
import argparse
import socket
import capnp

import calculator_capnp


class PowerFunction(calculator_capnp.Calculator.Function.Server):

    '''An implementation of the Function interface wrapping pow().  Note that
    we're implementing this on the client side and will pass a reference to
    the server.  The server will then be able to make calls back to the client.'''

    def call(self, params, **kwargs):
        '''Note the **kwargs. This is very necessary to include, since
        protocols can add parameters over time. Also, by default, a _context
        variable is passed to all server methods, but you can also return
        results directly as python objects, and they'll be added to the
        results struct in the correct order'''

        return pow(params[0], params[1])


def parse_args():
    parser = argparse.ArgumentParser(usage='Connects to the Calculator server \
at the given address and does some RPCs')
    parser.add_argument("host", help="HOST:PORT")

    return parser.parse_args()


def main(host):
    client = capnp.TwoPartyClient(host)

    # Pass "calculator" to ez_restore (there's also a `restore` function that
    # takes a struct or AnyPointer as an argument), and then cast the returned
    # capability to it's proper type. This casting is due to capabilities not
    # having a reference to their schema
    calculator = client.ez_restore('calculator').cast_as(calculator_capnp.Calculator)

    '''Make a request that just evaluates the literal value 123.

    What's interesting here is that evaluate() returns a "Value", which is
    another interface and therefore points back to an object living on the
    server.  We then have to call read() on that object to read it.
    However, even though we are making two RPC's, this block executes in
    *one* network round trip because of promise pipelining:  we do not wait
    for the first call to complete before we send the second call to the
    server.'''

    print('Evaluating a literal... ', end="")

    # Make the request. Note we are using the shorter function form (instead
    # of evaluate_request), and we are passing a dictionary that represents a
    # struct and its member to evaluate
    eval_promise = calculator.evaluate({"literal": 123})

    # This is equivalent to:
    '''
    request = calculator.evaluate_request()
    request.expression.literal = 123

    # Send it, which returns a promise for the result (without blocking).
    eval_promise = request.send()
    '''

    # Using the promise, create a pipelined request to call read() on the
    # returned object. Note that here we are using the shortened method call
    # syntax read(), which is mostly just sugar for read_request().send()
    read_promise = eval_promise.value.read()

    # Now that we've sent all the requests, wait for the response.  Until this
    # point, we haven't waited at all!
    response = read_promise.wait()
    assert response.value == 123

    print("PASS")

    '''Make a request to evaluate 123 + 45 - 67.

    The Calculator interface requires that we first call getOperator() to
    get the addition and subtraction functions, then call evaluate() to use
    them.  But, once again, we can get both functions, call evaluate(), and
    then read() the result -- four RPCs -- in the time of *one* network
    round trip, because of promise pipelining.'''

    print("Using add and subtract... ", end='')

    # Get the "add" function from the server.
    add = calculator.getOperator(op='add').func
    # Get the "subtract" function from the server.
    subtract = calculator.getOperator(op='subtract').func

    # Build the request to evaluate 123 + 45 - 67. Note the form is 'evaluate'
    # + '_request', where 'evaluate' is the name of the method we want to call
    request = calculator.evaluate_request()
    subtract_call = request.expression.init('call')
    subtract_call.function = subtract
    subtract_params = subtract_call.init('params', 2)
    subtract_params[1].literal = 67.0

    add_call = subtract_params[0].init('call')
    add_call.function = add
    add_params = add_call.init('params', 2)
    add_params[0].literal = 123
    add_params[1].literal = 45

    # Send the evaluate() request, read() the result, and wait for read() to finish.
    eval_promise = request.send()
    read_promise = eval_promise.value.read()

    response = read_promise.wait()
    assert response.value == 101

    print("PASS")

    '''
    Note: a one liner version of building the previous request (I highly
    recommend not doing it this way for such a complicated structure, but I
    just wanted to demonstrate it is possible to set all of the fields with a
    dictionary):

    eval_promise = calculator.evaluate(
{'call': {'function': subtract,
          'params': [{'call': {'function': add,
                               'params': [{'literal': 123},
                                          {'literal': 45}]}},
                     {'literal': 67.0}]}})
    '''

    '''Make a request to evaluate 4 * 6, then use the result in two more
    requests that add 3 and 5.

    Since evaluate() returns its result wrapped in a `Value`, we can pass
    that `Value` back to the server in subsequent requests before the first
    `evaluate()` has actually returned.  Thus, this example again does only
    one network round trip.'''

    print("Pipelining eval() calls... ", end="")

    # Get the "add" function from the server.
    add = calculator.getOperator(op='add').func
    # Get the "multiply" function from the server.
    multiply = calculator.getOperator(op='multiply').func

    # Build the request to evaluate 4 * 6
    request = calculator.evaluate_request()

    multiply_call = request.expression.init("call")
    multiply_call.function = multiply
    multiply_params = multiply_call.init("params", 2)
    multiply_params[0].literal = 4
    multiply_params[1].literal = 6

    multiply_result = request.send().value

    # Use the result in two calls that add 3 and add 5.

    add_3_request = calculator.evaluate_request()
    add_3_call = add_3_request.expression.init("call")
    add_3_call.function = add
    add_3_params = add_3_call.init("params", 2)
    add_3_params[0].previousResult = multiply_result
    add_3_params[1].literal = 3
    add_3_promise = add_3_request.send().value.read()

    add_5_request = calculator.evaluate_request()
    add_5_call = add_5_request.expression.init("call")
    add_5_call.function = add
    add_5_params = add_5_call.init("params", 2)
    add_5_params[0].previousResult = multiply_result
    add_5_params[1].literal = 5
    add_5_promise = add_5_request.send().value.read()

    # Now wait for the results.
    assert add_3_promise.wait().value == 27
    assert add_5_promise.wait().value == 29

    print("PASS")

    '''Our calculator interface supports defining functions.  Here we use it
    to define two functions and then make calls to them as follows:

      f(x, y) = x * 100 + y
      g(x) = f(x, x + 1) * 2;
      f(12, 34)
      g(21)

    Once again, the whole thing takes only one network round trip.'''

    print("Defining functions... ", end="")

    # Get the "add" function from the server.
    add = calculator.getOperator(op='add').func
    # Get the "multiply" function from the server.
    multiply = calculator.getOperator(op='multiply').func

    # Define f.
    request = calculator.defFunction_request()
    request.paramCount = 2

    # Build the function body.
    add_call = request.body.init("call")
    add_call.function = add
    add_params = add_call.init("params", 2)
    add_params[1].parameter = 1  # y

    multiply_call = add_params[0].init("call")
    multiply_call.function = multiply
    multiply_params = multiply_call.init("params", 2)
    multiply_params[0].parameter = 0  # x
    multiply_params[1].literal = 100

    f = request.send().func

    # Define g.
    request = calculator.defFunction_request()
    request.paramCount = 1

    # Build the function body.
    multiply_call = request.body.init("call")
    multiply_call.function = multiply
    multiply_params = multiply_call.init("params", 2)
    multiply_params[1].literal = 2

    f_call = multiply_params[0].init("call")
    f_call.function = f
    f_params = f_call.init("params", 2)
    f_params[0].parameter = 0

    add_call = f_params[1].init("call")
    add_call.function = add
    add_params = add_call.init("params", 2)
    add_params[0].parameter = 0
    add_params[1].literal = 1

    g = request.send().func

    # OK, we've defined all our functions.  Now create our eval requests.

    # f(12, 34)
    f_eval_request = calculator.evaluate_request()
    f_call = f_eval_request.expression.init("call")
    f_call.function = f
    f_params = f_call.init("params", 2)
    f_params[0].literal = 12
    f_params[1].literal = 34
    f_eval_promise = f_eval_request.send().value.read()

    # g(21)
    g_eval_request = calculator.evaluate_request()
    g_call = g_eval_request.expression.init("call")
    g_call.function = g
    g_call.init('params', 1)[0].literal = 21
    g_eval_promise = g_eval_request.send().value.read()

    # Wait for the results.
    assert f_eval_promise.wait().value == 1234
    assert g_eval_promise.wait().value == 4244

    print("PASS")

    '''Make a request that will call back to a function defined locally.

    Specifically, we will compute 2^(4 + 5).  However, exponent is not
    defined by the Calculator server.  So, we'll implement the Function
    interface locally and pass it to the server for it to use when
    evaluating the expression.

    This example requires two network round trips to complete, because the
    server calls back to the client once before finishing.  In this
    particular case, this could potentially be optimized by using a tail
    call on the server side -- see CallContext::tailCall().  However, to
    keep the example simpler, we haven't implemented this optimization in
    the sample server.'''

    print("Using a callback... ", end="")

    # Get the "add" function from the server.
    add = calculator.getOperator(op='add').func

    # Build the eval request for 2^(4+5).
    request = calculator.evaluate_request()

    pow_call = request.expression.init("call")
    pow_call.function = PowerFunction()
    pow_params = pow_call.init("params", 2)
    pow_params[0].literal = 2

    add_call = pow_params[1].init("call")
    add_call.function = add
    add_params = add_call.init("params", 2)
    add_params[0].literal = 4
    add_params[1].literal = 5

    # Send the request and wait.
    response = request.send().value.read().wait()
    assert response.value == 512

    print("PASS")

if __name__ == '__main__':
    main(parse_args().host)

########NEW FILE########
__FILENAME__ = calculator_server
#!/usr/bin/env python

from __future__ import print_function
import argparse
import socket
import random
import capnp

import calculator_capnp


def read_value(value):
    '''Helper function to asynchronously call read() on a Calculator::Value and
    return a promise for the result.  (In the future, the generated code might
    include something like this automatically.)'''

    return value.read().then(lambda result: result.value)


def evaluate_impl(expression, params=None):
    '''Implementation of CalculatorImpl::evaluate(), also shared by
    FunctionImpl::call().  In the latter case, `params` are the parameter
    values passed to the function; in the former case, `params` is just an
    empty list.'''

    which = expression.which()

    if which == 'literal':
        return capnp.Promise(expression.literal)
    elif which == 'previousResult':
        return read_value(expression.previousResult)
    elif which == 'parameter':
        assert expression.parameter < len(params)
        return capnp.Promise(params[expression.parameter])
    elif which == 'call':
        call = expression.call
        func = call.function

        # Evaluate each parameter.
        paramPromises = [evaluate_impl(param, params) for param in call.params]

        joinedParams = capnp.join_promises(paramPromises)
        # When the parameters are complete, call the function.
        ret = (joinedParams
               .then(lambda vals: func.call(vals))
               .then(lambda result: result.value))

        return ret
    else:
        raise ValueError("Unknown expression type: " + which)


class ValueImpl(calculator_capnp.Calculator.Value.Server):

    "Simple implementation of the Calculator.Value Cap'n Proto interface."

    def __init__(self, value):
        self.value = value

    def read(self, **kwargs):
        return self.value


class FunctionImpl(calculator_capnp.Calculator.Function.Server):

    '''Implementation of the Calculator.Function Cap'n Proto interface, where the
    function is defined by a Calculator.Expression.'''

    def __init__(self, paramCount, body):
        self.paramCount = paramCount
        self.body = body.as_builder()

    def call(self, params, _context, **kwargs):
        '''Note that we're returning a Promise object here, and bypassing the
        helper functionality that normally sets the results struct from the
        returned object. Instead, we set _context.results directly inside of
        another promise'''

        assert len(params) == self.paramCount
        # using setattr because '=' is not allowed inside of lambdas
        return evaluate_impl(self.body, params).then(lambda value: setattr(_context.results, 'value', value))


class OperatorImpl(calculator_capnp.Calculator.Function.Server):

    '''Implementation of the Calculator.Function Cap'n Proto interface, wrapping
    basic binary arithmetic operators.'''

    def __init__(self, op):
        self.op = op

    def call(self, params, **kwargs):
        assert len(params) == 2

        op = self.op

        if op == 'add':
            return params[0] + params[1]
        elif op == 'subtract':
            return params[0] - params[1]
        elif op == 'multiply':
            return params[0] * params[1]
        elif op == 'divide':
            return params[0] / params[1]
        else:
            raise ValueError('Unknown operator')


class CalculatorImpl(calculator_capnp.Calculator.Server):

    "Implementation of the Calculator Cap'n Proto interface."

    def evaluate(self, expression, _context, **kwargs):
        return evaluate_impl(expression).then(lambda value: setattr(_context.results, 'value', ValueImpl(value)))

    def defFunction(self, paramCount, body, _context, **kwargs):
        return FunctionImpl(paramCount, body)

    def getOperator(self, op, **kwargs):
        return OperatorImpl(op)


def parse_args():
    parser = argparse.ArgumentParser(usage='''Runs the server bound to the\
given address/port ADDRESS may be '*' to bind to all local addresses.\
:PORT may be omitted to choose a port automatically. ''')

    parser.add_argument("address", help="ADDRESS[:PORT]")

    return parser.parse_args()


def restore(ref):
    assert ref.as_text() == 'calculator'
    return CalculatorImpl()


def main():
    address = parse_args().address

    server = capnp.TwoPartyServer(address, restore)
    server.run_forever()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = capnp-json
#!/usr/bin/env python

import argparse
import sys
import json
import capnp

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("command")
    parser.add_argument("schema_file")
    parser.add_argument("struct_name")
    parser.add_argument("-d", "--defaults", help="include default values in json output", action="store_true")

    return parser.parse_args()

def encode(schema_file, struct_name, **kwargs):
    schema = capnp.load(schema_file)

    struct_schema = getattr(schema, struct_name)
    
    struct_dict = json.load(sys.stdin)
    struct = struct_schema.from_dict(struct_dict)

    struct.write(sys.stdout)

def decode(schema_file, struct_name, defaults):
    schema = capnp.load(schema_file)

    struct_schema = getattr(schema, struct_name)
    struct = struct_schema.read(sys.stdin)
    
    json.dump(struct.to_dict(defaults), sys.stdout)

def main():
    args = parse_args()

    command = args.command
    kwargs = vars(args)
    del kwargs['command']

    globals()[command](**kwargs) # hacky way to get defined functions, and call function with name=command

main()
########NEW FILE########
__FILENAME__ = capnp_test_pycapnp
#!/usr/bin/env python
from __future__ import print_function
import capnp
import os
capnp.add_import_hook([os.getcwd(), "/usr/local/include/"]) # change this to be auto-detected?

import test_capnp

import sys

def decode(name):
    class_name = name[0].upper() + name[1:]
    print(getattr(test_capnp, class_name).from_bytes(sys.stdin.read())._short_str())

def encode(name):
    val = getattr(test_capnp, name)
    class_name = name[0].upper() + name[1:]
    message = getattr(test_capnp, class_name).from_dict(val.to_dict())
    print(message.to_bytes())

if sys.argv[1] == 'decode':
    decode(sys.argv[2])
else:
    encode(sys.argv[2])

########NEW FILE########
__FILENAME__ = test_capability
import pytest
import capnp
import os

import test_capability_capnp as capability

class Server(capability.TestInterface.Server):
    def __init__(self, val=1):
        self.val = val

    def foo(self, i, j, **kwargs):
        extra = 0
        if j:
            extra = 1
        return str(i * 5 + extra + self.val)

    def buz(self, i, **kwargs):
        return i.host + '_test'

    def bam(self, i, **kwargs):
        return str(i) + '_test', i

class PipelineServer(capability.TestPipeline.Server):
    def getCap(self, n, inCap, _context, **kwargs):
        def _then(response):
            _results = _context.results
            _results.s = response.x + '_foo'
            _results.outBox.cap = Server(100)

        return inCap.foo(i=n).then(_then)

def test_client():
    client = capability.TestInterface._new_client(Server())
    
    req = client._request('foo')
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'
    
    req = client.foo_request()
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'

    with pytest.raises(ValueError):
        client.foo2_request()

    req = client.foo_request()

    with pytest.raises(ValueError):
        req.i = 'foo'

    req = client.foo_request()

    with pytest.raises(AttributeError):
        req.baz = 1

def test_simple_client():
    client = capability.TestInterface._new_client(Server())
    
    remote = client._send('foo', i=5)
    response = remote.wait()

    assert response.x == '26'

    
    remote = client.foo(i=5)
    response = remote.wait()

    assert response.x == '26'
    
    remote = client.foo(i=5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5)
    response = remote.wait()

    assert response.x == '26'

    remote = client.foo(5, True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.buz(capability.TestSturdyRefHostId.new_message(host='localhost'))
    response = remote.wait()

    assert response.x == 'localhost_test'

    remote = client.bam(i=5)
    response = remote.wait()

    assert response.x == '5_test'
    assert response.i == 5

    with pytest.raises(ValueError):
        remote = client.foo(5, 10)

    with pytest.raises(ValueError):
        remote = client.foo(5, True, 100)

    with pytest.raises(ValueError):
        remote = client.foo(i='foo')

    with pytest.raises(ValueError):
        remote = client.foo2(i=5)

    with pytest.raises(AttributeError):
        remote = client.foo(baz=5)

def test_pipeline():
    client = capability.TestPipeline._new_client(PipelineServer())
    foo_client = capability.TestInterface._new_client(Server())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    response = pipelinePromise.wait()
    assert response.x == '150'

    response = remote.wait()
    assert response.s == '26_foo'

class BadServer(capability.TestInterface.Server):
    def __init__(self, val=1):
        self.val = val

    def foo(self, i, j, **kwargs):
        extra = 0
        if j:
            extra = 1
        return str(i * 5 + extra + self.val), 10 # returning too many args

def test_exception_client():
    client = capability.TestInterface._new_client(BadServer())
    
    remote = client._send('foo', i=5)
    with pytest.raises(capnp.KjException):
        remote.wait()

class BadPipelineServer(capability.TestPipeline.Server):
    def getCap(self, n, inCap, _context, **kwargs):
        def _then(response):
            _results = _context.results
            _results.s = response.x + '_foo'
            _results.outBox.cap = Server(100)
        def _error(error):
            raise Exception('test was a success')

        return inCap.foo(i=n).then(_then, _error)

def test_exception_chain():
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    try:
        remote.wait()
    except Exception as e:
        assert 'test was a success' in str(e)

def test_pipeline_exception():
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    with pytest.raises(Exception):
        loop.wait(pipelinePromise)

    with pytest.raises(Exception):
        remote.wait()

def test_casting():
    client = capability.TestExtends._new_client(Server())
    client2 = client.upcast(capability.TestInterface)
    client3 = client2.cast_as(capability.TestInterface)

    with pytest.raises(Exception):
        client.upcast(capability.TestPipeline)

class TailCallOrder(capability.TestCallOrder.Server):
    def __init__(self):
        self.count = -1

    def getCallSequence(self, expected, **kwargs):
        self.count += 1
        return self.count

class TailCaller(capability.TestTailCaller.Server):
    def __init__(self):
        self.count = 0

    def foo(self, i, callee, _context, **kwargs):
        self.count += 1

        tail = callee.foo_request(i=i, t='from TailCaller')
        return _context.tail_call(tail)

class TailCallee(capability.TestTailCallee.Server):
    def __init__(self):
        self.count = 0

    def foo(self, i, t, _context, **kwargs):
        self.count += 1

        results = _context.results
        results.i = i
        results.t = t
        results.c = TailCallOrder()

def test_tail_call():
    callee_server = TailCallee()
    caller_server = TailCaller()

    callee = capability.TestTailCallee._new_client(callee_server)
    caller = capability.TestTailCaller._new_client(caller_server)

    promise = caller.foo(i=456, callee=callee)
    dependent_call1 = promise.c.getCallSequence()

    response = promise.wait()

    assert response.i == 456
    assert response.i == 456

    dependent_call2 = response.c.getCallSequence()
    dependent_call3 = response.c.getCallSequence()

    result = dependent_call1.wait()
    assert result.n == 0
    result = dependent_call2.wait()
    assert result.n == 1
    result = dependent_call3.wait()
    assert result.n == 2

    assert callee_server.count == 1
    assert caller_server.count == 1
########NEW FILE########
__FILENAME__ = test_capability_context
import pytest
import capnp
import os

this_dir = os.path.dirname(__file__)

@pytest.fixture
def capability():
     return capnp.load(os.path.join(this_dir, 'test_capability.capnp'))

class Server:
    def __init__(self, val=1):
        self.val = val

    def foo_context(self, context):
        extra = 0
        if context.params.j:
            extra = 1
        context.results.x = str(context.params.i * 5 + extra + self.val)

    def buz_context(self, context):
        context.results.x = context.params.i.host + '_test'

class PipelineServer:
    def getCap_context(self, context):
        def _then(response):
            context.results.s = response.x + '_foo'
            context.results.outBox.cap = capability().TestInterface._new_server(Server(100))

        return context.params.inCap.foo(i=context.params.n).then(_then)

def test_client_context(capability):
    client = capability.TestInterface._new_client(Server())
    
    req = client._request('foo')
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'
    
    req = client.foo_request()
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'

    with pytest.raises(ValueError):
        client.foo2_request()

    req = client.foo_request()

    with pytest.raises(ValueError):
        req.i = 'foo'

    req = client.foo_request()

    with pytest.raises(AttributeError):
        req.baz = 1

def test_simple_client_context(capability):
    client = capability.TestInterface._new_client(Server())
    
    remote = client._send('foo', i=5)
    response = remote.wait()

    assert response.x == '26'

    
    remote = client.foo(i=5)
    response = remote.wait()

    assert response.x == '26'
    
    remote = client.foo(i=5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5)
    response = remote.wait()

    assert response.x == '26'

    remote = client.foo(5, True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.buz(capability.TestSturdyRefHostId.new_message(host='localhost'))
    response = remote.wait()

    assert response.x == 'localhost_test'

    with pytest.raises(ValueError):
        remote = client.foo(5, 10)

    with pytest.raises(ValueError):
        remote = client.foo(5, True, 100)

    with pytest.raises(ValueError):
        remote = client.foo(i='foo')

    with pytest.raises(ValueError):
        remote = client.foo2(i=5)

    with pytest.raises(AttributeError):
        remote = client.foo(baz=5)

def test_pipeline_context(capability):
    client = capability.TestPipeline._new_client(PipelineServer())
    foo_client = capability.TestInterface._new_client(Server())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    response = pipelinePromise.wait()
    assert response.x == '150'

    response = remote.wait()
    assert response.s == '26_foo'

class BadServer:
    def __init__(self, val=1):
        self.val = val

    def foo_context(self, context):
        context.results.x = str(context.params.i * 5 + self.val)
        context.results.x2 = 5 # raises exception

def test_exception_client_context(capability):
    client = capability.TestInterface._new_client(BadServer())
    
    remote = client._send('foo', i=5)
    with pytest.raises(capnp.KjException):
        remote.wait()

class BadPipelineServer:
    def getCap_context(self, context):
        def _then(response):
            context.results.s = response.x + '_foo'
            context.results.outBox.cap = capability().TestInterface._new_server(Server(100))
        def _error(error):
            raise Exception('test was a success')

        return context.params.inCap.foo(i=context.params.n).then(_then, _error)

def test_exception_chain_context(capability):
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    try:
        remote.wait()
    except Exception as e:
        assert 'test was a success' in str(e)

def test_pipeline_exception_context(capability):
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    with pytest.raises(Exception):
        loop.wait(pipelinePromise)

    with pytest.raises(Exception):
        remote.wait()

def test_casting_context(capability):
    client = capability.TestExtends._new_client(Server())
    client2 = client.upcast(capability.TestInterface)
    client3 = client2.cast_as(capability.TestInterface)

    with pytest.raises(Exception):
        client.upcast(capability.TestPipeline)

class TailCallOrder:
    def __init__(self):
        self.count = -1

    def getCallSequence_context(self, context):
        self.count += 1
        context.results.n = self.count

class TailCaller:
    def __init__(self):
        self.count = 0

    def foo_context(self, context):
        self.count += 1

        tail = context.params.callee.foo_request(i=context.params.i, t='from TailCaller')
        return context.tail_call(tail)

class TailCallee:
    def __init__(self):
        self.count = 0

    def foo_context(self, context):
        self.count += 1

        results = context.results
        results.i = context.params.i
        results.t = context.params.t
        results.c = capability().TestCallOrder._new_server(TailCallOrder())

def test_tail_call(capability):
    callee_server = TailCallee()
    caller_server = TailCaller()

    callee = capability.TestTailCallee._new_client(callee_server)
    caller = capability.TestTailCaller._new_client(caller_server)

    promise = caller.foo(i=456, callee=callee)
    dependent_call1 = promise.c.getCallSequence()

    response = promise.wait()

    assert response.i == 456
    assert response.i == 456

    dependent_call2 = response.c.getCallSequence()
    dependent_call3 = response.c.getCallSequence()

    result = dependent_call1.wait()
    assert result.n == 0
    result = dependent_call2.wait()
    assert result.n == 1
    result = dependent_call3.wait()
    assert result.n == 2

    assert callee_server.count == 1
    assert caller_server.count == 1

########NEW FILE########
__FILENAME__ = test_capability_old
import pytest
import capnp
import os

this_dir = os.path.dirname(__file__)

@pytest.fixture
def capability():
     return capnp.load(os.path.join(this_dir, 'test_capability.capnp'))

class Server:
    def __init__(self, val=1):
        self.val = val

    def foo(self, i, j, **kwargs):
        extra = 0
        if j:
            extra = 1
        return str(i * 5 + extra + self.val)

    def buz(self, i, **kwargs):
        return i.host + '_test'

class PipelineServer:
    def getCap(self, n, inCap, _context, **kwargs):
        def _then(response):
            _results = _context.results
            _results.s = response.x + '_foo'
            _results.outBox.cap = capability().TestInterface._new_server(Server(100))

        return inCap.foo(i=n).then(_then)

def test_client(capability):
    client = capability.TestInterface._new_client(Server())
    
    req = client._request('foo')
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'
    
    req = client.foo_request()
    req.i = 5

    remote = req.send()
    response = remote.wait()

    assert response.x == '26'

    with pytest.raises(ValueError):
        client.foo2_request()

    req = client.foo_request()

    with pytest.raises(ValueError):
        req.i = 'foo'

    req = client.foo_request()

    with pytest.raises(AttributeError):
        req.baz = 1

def test_simple_client(capability):
    client = capability.TestInterface._new_client(Server())
    
    remote = client._send('foo', i=5)
    response = remote.wait()

    assert response.x == '26'

    
    remote = client.foo(i=5)
    response = remote.wait()

    assert response.x == '26'
    
    remote = client.foo(i=5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5)
    response = remote.wait()

    assert response.x == '26'

    remote = client.foo(5, True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.foo(5, j=True)
    response = remote.wait()

    assert response.x == '27'

    remote = client.buz(capability.TestSturdyRefHostId.new_message(host='localhost'))
    response = remote.wait()

    assert response.x == 'localhost_test'

    with pytest.raises(ValueError):
        remote = client.foo(5, 10)

    with pytest.raises(ValueError):
        remote = client.foo(5, True, 100)

    with pytest.raises(ValueError):
        remote = client.foo(i='foo')

    with pytest.raises(ValueError):
        remote = client.foo2(i=5)

    with pytest.raises(AttributeError):
        remote = client.foo(baz=5)

def test_pipeline(capability):
    client = capability.TestPipeline._new_client(PipelineServer())
    foo_client = capability.TestInterface._new_client(Server())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    response = pipelinePromise.wait()
    assert response.x == '150'

    response = remote.wait()
    assert response.s == '26_foo'

class BadServer:
    def __init__(self, val=1):
        self.val = val

    def foo(self, i, j, **kwargs):
        extra = 0
        if j:
            extra = 1
        return str(i * 5 + extra + self.val), 10 # returning too many args

def test_exception_client(capability):
    client = capability.TestInterface._new_client(BadServer())
    
    remote = client._send('foo', i=5)
    with pytest.raises(capnp.KjException):
        remote.wait()

class BadPipelineServer:
    def getCap(self, n, inCap, _context, **kwargs):
        def _then(response):
            _results = _context.results
            _results.s = response.x + '_foo'
            _results.outBox.cap = capability().TestInterface._new_server(Server(100))
        def _error(error):
            raise Exception('test was a success')

        return inCap.foo(i=n).then(_then, _error)

def test_exception_chain(capability):
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    try:
        remote.wait()
    except Exception as e:
        assert 'test was a success' in str(e)

def test_pipeline_exception(capability):
    client = capability.TestPipeline._new_client(BadPipelineServer())
    foo_client = capability.TestInterface._new_client(BadServer())

    remote = client.getCap(n=5, inCap=foo_client)

    outCap = remote.outBox.cap
    pipelinePromise = outCap.foo(i=10)

    with pytest.raises(Exception):
        loop.wait(pipelinePromise)

    with pytest.raises(Exception):
        remote.wait()

def test_casting(capability):
    client = capability.TestExtends._new_client(Server())
    client2 = client.upcast(capability.TestInterface)
    client3 = client2.cast_as(capability.TestInterface)

    with pytest.raises(Exception):
        client.upcast(capability.TestPipeline)

class TailCallOrder:
    def __init__(self):
        self.count = -1

    def getCallSequence(self, expected, **kwargs):
        self.count += 1
        return self.count

class TailCaller:
    def __init__(self):
        self.count = 0

    def foo(self, i, callee, _context, **kwargs):
        self.count += 1

        tail = callee.foo_request(i=i, t='from TailCaller')
        return _context.tail_call(tail)

class TailCallee:
    def __init__(self):
        self.count = 0

    def foo(self, i, t, _context, **kwargs):
        self.count += 1

        results = _context.results
        results.i = i
        results.t = t
        results.c = capability().TestCallOrder._new_server(TailCallOrder())

def test_tail_call(capability):
    callee_server = TailCallee()
    caller_server = TailCaller()

    callee = capability.TestTailCallee._new_client(callee_server)
    caller = capability.TestTailCaller._new_client(caller_server)

    promise = caller.foo(i=456, callee=callee)
    dependent_call1 = promise.c.getCallSequence()

    response = promise.wait()

    assert response.i == 456
    assert response.i == 456

    dependent_call2 = response.c.getCallSequence()
    dependent_call3 = response.c.getCallSequence()

    result = dependent_call1.wait()
    assert result.n == 0
    result = dependent_call2.wait()
    assert result.n == 1
    result = dependent_call3.wait()
    assert result.n == 2

    assert callee_server.count == 1
    assert caller_server.count == 1
########NEW FILE########
__FILENAME__ = test_load
import pytest
import capnp
import os
import sys

this_dir = os.path.dirname(__file__)

@pytest.fixture
def addressbook():
     return capnp.load(os.path.join(this_dir, 'addressbook.capnp'))

@pytest.fixture
def foo():
     return capnp.load(os.path.join(this_dir, 'foo.capnp'))

@pytest.fixture
def bar():
     return capnp.load(os.path.join(this_dir, 'bar.capnp'))

def test_basic_load():
    capnp.load(os.path.join(this_dir, 'addressbook.capnp'))

def test_constants(addressbook):
    assert addressbook.qux == 123

def test_classes(addressbook):
    assert addressbook.AddressBook
    assert addressbook.Person

def test_import(foo, bar):
    m = capnp._MallocMessageBuilder()
    foo = m.init_root(foo.Foo)
    m2 = capnp._MallocMessageBuilder()
    bar = m2.init_root(bar.Bar)

    foo.name = 'foo'
    bar.foo = foo

    assert bar.foo.name == 'foo'

def test_failed_import():
    s = capnp.SchemaParser()
    s2 = capnp.SchemaParser()

    foo = s.load(os.path.join(this_dir, 'foo.capnp'))
    bar = s2.load(os.path.join(this_dir, 'bar.capnp'))

    m = capnp._MallocMessageBuilder()
    foo = m.init_root(foo.Foo)
    m2 = capnp._MallocMessageBuilder()
    bar = m2.init_root(bar.Bar)

    foo.name = 'foo'

    with pytest.raises(ValueError):
        bar.foo = foo

def test_defualt_import_hook():
    import addressbook_capnp

def test_add_import_hook():
    capnp.add_import_hook([this_dir])

    import addressbook_capnp
    addressbook_capnp.AddressBook.new_message()

def test_multiple_add_import_hook():
    capnp.add_import_hook()
    capnp.add_import_hook()
    capnp.add_import_hook([this_dir])

    import addressbook_capnp
    addressbook_capnp.AddressBook.new_message()

def test_remove_import_hook():
    capnp.add_import_hook([this_dir])
    capnp.remove_import_hook()

    if 'addressbook_capnp' in sys.modules:
        del sys.modules['addressbook_capnp'] # hack to deal with it being imported already

    with pytest.raises(ImportError):
        import addressbook_capnp

########NEW FILE########
__FILENAME__ = test_object
import pytest
import capnp
import os

this_dir = os.path.dirname(__file__)

@pytest.fixture
def object():
     return capnp.load(os.path.join(this_dir, 'object.capnp'))

def test_object_basic(object):
    obj = object.TestObject.new_message()
    person = obj.object.as_struct(object.Person)
    person.name = 'test'
    person.id = 1000

    same_person = obj.object.as_struct(object.Person)
    assert same_person.name == 'test'
    assert same_person.id == 1000

    obj_r = obj.as_reader()
    same_person = obj_r.object.as_struct(object.Person)
    assert same_person.name == 'test'
    assert same_person.id == 1000

########NEW FILE########
__FILENAME__ = test_regression
import pytest
import capnp
import os
import math

this_dir = os.path.dirname(__file__)

@pytest.fixture
def addressbook():
     return capnp.load(os.path.join(this_dir, 'addressbook.capnp'))

def test_addressbook_message_classes(addressbook):
    def writeAddressBook(fd):
        message = capnp._MallocMessageBuilder()
        addressBook = message.init_root(addressbook.AddressBook)
        people = addressBook.init('people', 2)

        alice = people[0]
        alice.id = 123
        alice.name = 'Alice'
        alice.email = 'alice@example.com'
        alicePhones = alice.init('phones', 1)
        alicePhones[0].number = "555-1212"
        alicePhones[0].type = 'mobile'
        alice.employment.school = "MIT"

        bob = people[1]
        bob.id = 456
        bob.name = 'Bob'
        bob.email = 'bob@example.com'
        bobPhones = bob.init('phones', 2)
        bobPhones[0].number = "555-4567"
        bobPhones[0].type = 'home'
        bobPhones[1].number = "555-7654"
        bobPhones[1].type = 'work'
        bob.employment.unemployed = None

        capnp._write_packed_message_to_fd(fd, message)


    def printAddressBook(fd):
        message = capnp._PackedFdMessageReader(f.fileno())
        addressBook = message.get_root(addressbook.AddressBook)

        people = addressBook.people

        alice = people[0]
        assert alice.id == 123
        assert alice.name == 'Alice'
        assert alice.email == 'alice@example.com'
        alicePhones = alice.phones
        assert alicePhones[0].number == "555-1212"
        assert alicePhones[0].type == 'mobile'
        assert alice.employment.school == "MIT"

        bob = people[1]
        assert bob.id == 456
        assert bob.name == 'Bob'
        assert bob.email == 'bob@example.com'
        bobPhones = bob.phones
        assert bobPhones[0].number == "555-4567"
        assert bobPhones[0].type == 'home'
        assert bobPhones[1].number == "555-7654"
        assert bobPhones[1].type == 'work'
        assert bob.employment.unemployed == None

    f = open('example', 'w')
    writeAddressBook(f.fileno())

    f = open('example', 'r')
    printAddressBook(f.fileno())

def test_addressbook(addressbook):
    def writeAddressBook(file):
        addresses = addressbook.AddressBook.new_message()
        people = addresses.init('people', 2)

        alice = people[0]
        alice.id = 123
        alice.name = 'Alice'
        alice.email = 'alice@example.com'
        alicePhones = alice.init('phones', 1)
        alicePhones[0].number = "555-1212"
        alicePhones[0].type = 'mobile'
        alice.employment.school = "MIT"

        bob = people[1]
        bob.id = 456
        bob.name = 'Bob'
        bob.email = 'bob@example.com'
        bobPhones = bob.init('phones', 2)
        bobPhones[0].number = "555-4567"
        bobPhones[0].type = 'home'
        bobPhones[1].number = "555-7654"
        bobPhones[1].type = 'work'
        bob.employment.unemployed = None

        addresses.write(file)


    def printAddressBook(file):
        addresses = addressbook.AddressBook.read(file)

        people = addresses.people

        alice = people[0]
        assert alice.id == 123
        assert alice.name == 'Alice'
        assert alice.email == 'alice@example.com'
        alicePhones = alice.phones
        assert alicePhones[0].number == "555-1212"
        assert alicePhones[0].type == 'mobile'
        assert alice.employment.school == "MIT"

        bob = people[1]
        assert bob.id == 456
        assert bob.name == 'Bob'
        assert bob.email == 'bob@example.com'
        bobPhones = bob.phones
        assert bobPhones[0].number == "555-4567"
        assert bobPhones[0].type == 'home'
        assert bobPhones[1].number == "555-7654"
        assert bobPhones[1].type == 'work'
        assert bob.employment.unemployed == None


    f = open('example', 'w')
    writeAddressBook(f)

    f = open('example', 'r')
    printAddressBook(f)

def test_addressbook_resizable(addressbook):
    def writeAddressBook(file):
        addresses = addressbook.AddressBook.new_message()
        people = addresses.init_resizable_list('people')

        alice = people.add()
        alice.id = 123
        alice.name = 'Alice'
        alice.email = 'alice@example.com'
        alicePhones = alice.init('phones', 1)
        alicePhones[0].number = "555-1212"
        alicePhones[0].type = 'mobile'
        alice.employment.school = "MIT"

        bob = people.add()
        bob.id = 456
        bob.name = 'Bob'
        bob.email = 'bob@example.com'
        bobPhones = bob.init('phones', 2)
        bobPhones[0].number = "555-4567"
        bobPhones[0].type = 'home'
        bobPhones[1].number = "555-7654"
        bobPhones[1].type = 'work'
        bob.employment.unemployed = None

        people.finish()
        
        addresses.write(file)


    def printAddressBook(file):
        addresses = addressbook.AddressBook.read(file)

        people = addresses.people

        alice = people[0]
        assert alice.id == 123
        assert alice.name == 'Alice'
        assert alice.email == 'alice@example.com'
        alicePhones = alice.phones
        assert alicePhones[0].number == "555-1212"
        assert alicePhones[0].type == 'mobile'
        assert alice.employment.school == "MIT"

        bob = people[1]
        assert bob.id == 456
        assert bob.name == 'Bob'
        assert bob.email == 'bob@example.com'
        bobPhones = bob.phones
        assert bobPhones[0].number == "555-4567"
        assert bobPhones[0].type == 'home'
        assert bobPhones[1].number == "555-7654"
        assert bobPhones[1].type == 'work'
        assert bob.employment.unemployed == None


    f = open('example', 'w')
    writeAddressBook(f)

    f = open('example', 'r')
    printAddressBook(f)


@pytest.fixture
def all_types():
    return capnp.load(os.path.join(this_dir, 'all_types.capnp'))

# TODO:  These tests should be extended to:
# - Read each field in Python and assert that it is equal to the expected value.
# - Build an identical message using Python code and compare it to the golden.
#

def init_all_types(builder):
    builder.voidField = None
    builder.boolField = True
    builder.int8Field = -123
    builder.int16Field = -12345
    builder.int32Field = -12345678
    builder.int64Field = -123456789012345
    builder.uInt8Field = 234
    builder.uInt16Field = 45678
    builder.uInt32Field = 3456789012
    builder.uInt64Field = 12345678901234567890
    builder.float32Field = 1234.5
    builder.float64Field = -123e45
    builder.textField = "foo"
    builder.dataField = b"bar"

    subBuilder = builder.structField
    subBuilder.voidField = None
    subBuilder.boolField = True
    subBuilder.int8Field = -12
    subBuilder.int16Field = 3456
    subBuilder.int32Field = -78901234
    subBuilder.int64Field = 56789012345678
    subBuilder.uInt8Field = 90
    subBuilder.uInt16Field = 1234
    subBuilder.uInt32Field = 56789012
    subBuilder.uInt64Field = 345678901234567890
    subBuilder.float32Field = -1.25e-10
    subBuilder.float64Field = 345
    subBuilder.textField = "baz"
    subBuilder.dataField = b"qux"
    subSubBuilder = subBuilder.structField
    subSubBuilder.textField = "nested"
    subSubBuilder.structField.textField = "really nested"
    subBuilder.enumField = "baz"

    subBuilder.voidList = [None, None, None]
    subBuilder.boolList = [False, True, False, True, True]
    subBuilder.int8List = [12, -34, -0x80, 0x7f]
    subBuilder.int16List = [1234, -5678, -0x8000, 0x7fff]
    subBuilder.int32List = [12345678, -90123456, -0x80000000, 0x7fffffff]
    subBuilder.int64List = [123456789012345, -678901234567890, -0x8000000000000000, 0x7fffffffffffffff]
    subBuilder.uInt8List = [12, 34, 0, 0xff]
    subBuilder.uInt16List = [1234, 5678, 0, 0xffff]
    subBuilder.uInt32List = [12345678, 90123456, 0, 0xffffffff]
    subBuilder.uInt64List = [123456789012345, 678901234567890, 0, 0xffffffffffffffff]
    subBuilder.float32List = [0, 1234567, 1e37, -1e37, 1e-37, -1e-37]
    subBuilder.float64List = [0, 123456789012345, 1e306, -1e306, 1e-306, -1e-306]
    subBuilder.textList = ["quux", "corge", "grault"]
    subBuilder.dataList = [b"garply", b"waldo", b"fred"]
    listBuilder = subBuilder.init('structList', 3)
    listBuilder[0].textField = "x structlist 1"
    listBuilder[1].textField = "x structlist 2"
    listBuilder[2].textField = "x structlist 3"
    subBuilder.enumList = ["qux", "bar", "grault"]

    builder.enumField = "corge"

    builder.init("voidList", 6)
    builder.boolList = [True, False, False, True]
    builder.int8List = [111, -111]
    builder.int16List = [11111, -11111]
    builder.int32List = [111111111, -111111111]
    builder.int64List = [1111111111111111111, -1111111111111111111]
    builder.uInt8List = [111, 222]
    builder.uInt16List = [33333, 44444]
    builder.uInt32List = [3333333333]
    builder.uInt64List = [11111111111111111111]
    builder.float32List = [5555.5, float("inf"), float("-inf"), float("nan")]
    builder.float64List = [7777.75, float("inf"), float("-inf"), float("nan")]
    builder.textList = ["plugh", "xyzzy", "thud"]
    builder.dataList = [b"oops", b"exhausted", b"rfc3092"]
    listBuilder = builder.init('structList', 3)
    listBuilder[0].textField = "structlist 1"
    listBuilder[1].textField = "structlist 2"
    listBuilder[2].textField = "structlist 3"
    builder.enumList = ["foo", "garply"]

def assert_almost(float1, float2):
    if float1 != float2:
        assert abs((float1 - float2) / float1) < 0.00001

def check_list(reader, expected):
    assert len(reader) == len(expected)
    for (i, v) in enumerate(expected):
        if type(v) is float:
            assert_almost(reader[i], v)
        else:
            assert reader[i] == v

def check_all_types(reader):
    assert reader.voidField == None
    assert reader.boolField == True
    assert reader.int8Field == -123
    assert reader.int16Field == -12345
    assert reader.int32Field == -12345678
    assert reader.int64Field == -123456789012345
    assert reader.uInt8Field == 234
    assert reader.uInt16Field == 45678
    assert reader.uInt32Field == 3456789012
    assert reader.uInt64Field == 12345678901234567890
    assert reader.float32Field == 1234.5
    assert_almost(reader.float64Field, -123e45)
    assert reader.textField == "foo"
    assert reader.dataField == b"bar"

    subReader = reader.structField
    assert subReader.voidField == None
    assert subReader.boolField == True
    assert subReader.int8Field == -12
    assert subReader.int16Field == 3456
    assert subReader.int32Field == -78901234
    assert subReader.int64Field == 56789012345678
    assert subReader.uInt8Field == 90
    assert subReader.uInt16Field == 1234
    assert subReader.uInt32Field == 56789012
    assert subReader.uInt64Field == 345678901234567890
    assert_almost(subReader.float32Field, -1.25e-10)
    assert subReader.float64Field == 345
    assert subReader.textField == "baz"
    assert subReader.dataField == b"qux"

    subSubReader = subReader.structField
    assert subSubReader.textField == "nested"
    assert subSubReader.structField.textField == "really nested"

    assert subReader.enumField == "baz"

    check_list(subReader.voidList, [None, None, None])
    check_list(subReader.boolList, [False, True, False, True, True])
    check_list(subReader.int8List, [12, -34, -0x80, 0x7f])
    check_list(subReader.int16List, [1234, -5678, -0x8000, 0x7fff])
    check_list(subReader.int32List, [12345678, -90123456, -0x80000000, 0x7fffffff])
    check_list(subReader.int64List, [123456789012345, -678901234567890, -0x8000000000000000, 0x7fffffffffffffff])
    check_list(subReader.uInt8List, [12, 34, 0, 0xff])
    check_list(subReader.uInt16List, [1234, 5678, 0, 0xffff])
    check_list(subReader.uInt32List, [12345678, 90123456, 0, 0xffffffff])
    check_list(subReader.uInt64List, [123456789012345, 678901234567890, 0, 0xffffffffffffffff])
    check_list(subReader.float32List, [0.0, 1234567.0, 1e37, -1e37, 1e-37, -1e-37])
    check_list(subReader.float64List, [0.0, 123456789012345.0, 1e306, -1e306, 1e-306, -1e-306])
    check_list(subReader.textList, ["quux", "corge", "grault"])
    check_list(subReader.dataList, [b"garply", b"waldo", b"fred"])

    listReader = subReader.structList
    assert len(listReader) == 3
    assert listReader[0].textField == "x structlist 1"
    assert listReader[1].textField == "x structlist 2"
    assert listReader[2].textField == "x structlist 3"

    check_list(subReader.enumList, ["qux", "bar", "grault"])

    assert reader.enumField == "corge"

    assert len(reader.voidList) == 6
    check_list(reader.boolList, [True, False, False, True])
    check_list(reader.int8List, [111, -111])
    check_list(reader.int16List, [11111, -11111])
    check_list(reader.int32List, [111111111, -111111111])
    check_list(reader.int64List, [1111111111111111111, -1111111111111111111])
    check_list(reader.uInt8List, [111, 222])
    check_list(reader.uInt16List, [33333, 44444])
    check_list(reader.uInt32List, [3333333333])
    check_list(reader.uInt64List, [11111111111111111111])

    listReader = reader.float32List
    assert len(listReader) == 4
    assert listReader[0] == 5555.5
    assert listReader[1] == float("inf")
    assert listReader[2] == -float("inf")
    assert math.isnan(listReader[3])

    listReader = reader.float64List
    len(listReader) == 4
    assert listReader[0] == 7777.75
    assert listReader[1] == float("inf")
    assert listReader[2] == -float("inf")
    assert math.isnan(listReader[3])

    check_list(reader.textList, ["plugh", "xyzzy", "thud"])
    check_list(reader.dataList, [b"oops", b"exhausted", b"rfc3092"])

    listReader = reader.structList
    len(listReader) == 3
    assert listReader[0].textField == "structlist 1"
    assert listReader[1].textField == "structlist 2"
    assert listReader[2].textField == "structlist 3"

    check_list(reader.enumList, ["foo", "garply"])

def test_build(all_types):
    root = all_types.TestAllTypes.new_message()
    init_all_types(root)
    expectedText = open(os.path.join(this_dir, 'all-types.txt'), 'r').read()
    assert str(root) + '\n' == expectedText

def test_build_first_segment_size(all_types):
    root = all_types.TestAllTypes.new_message(1)
    init_all_types(root)
    expectedText = open(os.path.join(this_dir, 'all-types.txt'), 'r').read()
    assert str(root) + '\n' == expectedText

    root = all_types.TestAllTypes.new_message(1024*1024)
    init_all_types(root)
    expectedText = open(os.path.join(this_dir, 'all-types.txt'), 'r').read()
    assert str(root) + '\n' == expectedText

def test_binary_read(all_types):
    f = open(os.path.join(this_dir, 'all-types.binary'), 'r')
    root = all_types.TestAllTypes.read(f)
    check_all_types(root)

    expectedText = open(os.path.join(this_dir, 'all-types.txt'), 'r').read()
    assert str(root) + '\n' == expectedText

    # Test set_root().
    builder = capnp._MallocMessageBuilder()
    builder.set_root(root)
    check_all_types(builder.get_root(all_types.TestAllTypes))

    builder2 = capnp._MallocMessageBuilder()
    builder2.set_root(builder.get_root(all_types.TestAllTypes))
    check_all_types(builder2.get_root(all_types.TestAllTypes))

def test_packed_read(all_types):
    f = open(os.path.join(this_dir, 'all-types.packed'), 'r')
    root = all_types.TestAllTypes.read_packed(f)
    check_all_types(root)

    expectedText = open(os.path.join(this_dir, 'all-types.txt'), 'r').read()
    assert str(root) + '\n' == expectedText

def test_binary_write(all_types):
    root = all_types.TestAllTypes.new_message()
    init_all_types(root)
    root.write(open('example', 'w'))

    check_all_types(all_types.TestAllTypes.read(open('example', 'r')))

def test_packed_write(all_types):
    root = all_types.TestAllTypes.new_message()
    init_all_types(root)
    root.write_packed(open('example', 'w'))

    check_all_types(all_types.TestAllTypes.read_packed(open('example', 'r')))

########NEW FILE########
__FILENAME__ = test_rpc
import pytest
import capnp
import os
import socket

import test_capability_capnp


class Server(test_capability_capnp.TestInterface.Server):

    def __init__(self, val=1):
        self.val = val

    def foo(self, i, j, **kwargs):
        return str(i * 5 + self.val)


def restore_func(ref_id):
    return Server(100)


class SimpleRestorer(test_capability_capnp.TestSturdyRefObjectId.Restorer):

    def restore(self, ref_id):
        assert ref_id.tag == 'testInterface'
        return Server(100)


def test_simple_rpc():
    read, write = socket.socketpair(socket.AF_UNIX)

    restorer = SimpleRestorer()
    server = capnp.TwoPartyServer(write, restorer)
    client = capnp.TwoPartyClient(read)

    ref = test_capability_capnp.TestSturdyRefObjectId.new_message(tag='testInterface')
    cap = client.restore(ref)
    cap = cap.cast_as(test_capability_capnp.TestInterface)

    remote = cap.foo(i=5)
    response = remote.wait()

    assert response.x == '125'


def test_simple_rpc_restore_func():
    read, write = socket.socketpair(socket.AF_UNIX)

    server = capnp.TwoPartyServer(write, restore_func)
    client = capnp.TwoPartyClient(read)

    ref = test_capability_capnp.TestSturdyRefObjectId.new_message(tag='testInterface')
    cap = client.restore(ref)
    cap = cap.cast_as(test_capability_capnp.TestInterface)

    remote = cap.foo(i=5)
    response = remote.wait()

    assert response.x == '125'


def text_restore_func(objectId):
    text = objectId.as_text()
    assert text == 'testInterface'
    return Server(100)


def test_ez_rpc():
    read, write = socket.socketpair(socket.AF_UNIX)

    server = capnp.TwoPartyServer(write, text_restore_func)
    client = capnp.TwoPartyClient(read)

    cap = client.ez_restore('testInterface')
    cap = cap.cast_as(test_capability_capnp.TestInterface)

    remote = cap.foo(i=5)
    response = remote.wait()

    assert response.x == '125'

    cap = client.restore(test_capability_capnp.TestSturdyRefObjectId.new_message())
    cap = cap.cast_as(test_capability_capnp.TestInterface)

    remote = cap.foo(i=5)

    with pytest.raises(capnp.KjException):
        response = remote.wait()

########NEW FILE########
__FILENAME__ = test_rpc_calculator
import capnp
import os
import socket
import gc

import sys  # add examples dir to sys.path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'examples'))
import calculator_client
import calculator_server


def test_calculator():
    read, write = socket.socketpair(socket.AF_UNIX)

    server = capnp.TwoPartyServer(write, calculator_server.restore)
    calculator_client.main(read)


def test_calculator_gc():
    def new_evaluate_impl(old_evaluate_impl):
        def call(*args, **kwargs):
            gc.collect()
            return old_evaluate_impl(*args, **kwargs)
        return call

    read, write = socket.socketpair(socket.AF_UNIX)

    # inject a gc.collect to the beginning of every evaluate_impl call
    evaluate_impl_orig = calculator_server.evaluate_impl
    calculator_server.evaluate_impl = new_evaluate_impl(evaluate_impl_orig)

    server = capnp.TwoPartyServer(write, calculator_server.restore)
    calculator_client.main(read)

    calculator_server.evaluate_impl = evaluate_impl_orig

########NEW FILE########
__FILENAME__ = test_serialization
import pytest
import capnp
import os
import platform
import test_regression
import tempfile

this_dir = os.path.dirname(__file__)

@pytest.fixture
def all_types():
    return capnp.load(os.path.join(this_dir, 'all_types.capnp'))

def test_roundtrip_file(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write(f)

    f.seek(0)
    msg = all_types.TestAllTypes.read(f)
    test_regression.check_all_types(msg)

def test_roundtrip_file_packed(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write_packed(f)

    f.seek(0)
    msg = all_types.TestAllTypes.read_packed(f)
    test_regression.check_all_types(msg)

def test_roundtrip_bytes(all_types):
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    message_bytes = msg.to_bytes()

    msg = all_types.TestAllTypes.from_bytes(message_bytes)
    test_regression.check_all_types(msg)

def test_roundtrip_bytes_packed(all_types):
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    message_bytes = msg.to_bytes_packed()

    msg = all_types.TestAllTypes.from_bytes_packed(message_bytes)
    test_regression.check_all_types(msg)

def test_roundtrip_file_multiple(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write(f)
    msg.write(f)
    msg.write(f)

    f.seek(0)
    for msg in all_types.TestAllTypes.read_multiple(f):
        test_regression.check_all_types(msg)

def test_roundtrip_file_multiple_packed(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write_packed(f)
    msg.write_packed(f)
    msg.write_packed(f)

    f.seek(0)
    for msg in all_types.TestAllTypes.read_multiple_packed(f):
        test_regression.check_all_types(msg)

def test_roundtrip_dict(all_types):
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    d = msg.to_dict()

    msg = all_types.TestAllTypes.from_dict(d)
    test_regression.check_all_types(msg)

def test_file_and_bytes(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write(f)

    f.seek(0)

    assert f.read() == msg.to_bytes()

def test_file_and_bytes_packed(all_types):
    f = tempfile.TemporaryFile()
    msg = all_types.TestAllTypes.new_message()
    test_regression.init_all_types(msg)
    msg.write_packed(f)

    f.seek(0)

    assert f.read() == msg.to_bytes_packed()

########NEW FILE########
__FILENAME__ = test_struct
import pytest
import capnp
import os
import tempfile
import sys

this_dir = os.path.dirname(__file__)


@pytest.fixture
def addressbook():
    return capnp.load(os.path.join(this_dir, 'addressbook.capnp'))


@pytest.fixture
def all_types():
    return capnp.load(os.path.join(this_dir, 'all_types.capnp'))


def test_which_builder(addressbook):
    addresses = addressbook.AddressBook.new_message()
    people = addresses.init('people', 2)

    alice = people[0]
    alice.employment.school = "MIT"

    assert alice.employment.which == addressbook.Person.Employment.school
    assert alice.employment.which == "school"

    bob = people[1]

    assert bob.employment.which == addressbook.Person.Employment.unemployed
    assert bob.employment.which == "unemployed"

    bob.employment.unemployed = None

    assert bob.employment.which == addressbook.Person.Employment.unemployed
    assert bob.employment.which == "unemployed"

    with pytest.raises(ValueError):
        addresses.which
    with pytest.raises(ValueError):
        addresses.which


def test_which_reader(addressbook):
    def writeAddressBook(fd):
        message = capnp._MallocMessageBuilder()
        addressBook = message.init_root(addressbook.AddressBook)
        people = addressBook.init('people', 2)

        alice = people[0]
        alice.employment.school = "MIT"

        bob = people[1]
        bob.employment.unemployed = None

        capnp._write_packed_message_to_fd(fd, message)

    f = tempfile.TemporaryFile()
    writeAddressBook(f.fileno())
    f.seek(0)

    addresses = addressbook.AddressBook.read_packed(f)

    people = addresses.people

    alice = people[0]
    assert alice.employment.which == "school"

    bob = people[1]
    assert bob.employment.which == "unemployed"

    with pytest.raises(ValueError):
        addresses.which
    with pytest.raises(ValueError):
        addresses.which


@pytest.mark.skipif(capnp.version.LIBCAPNP_VERSION < 5000, reason="Using ints as enums requires v0.5.0+ of the C++ capnp library")
def test_enum(addressbook):
    addresses = addressbook.AddressBook.new_message()
    people = addresses.init('people', 2)

    alice = people[0]
    phones = alice.init('phones', 2)

    assert phones[0].type == phones[1].type

    phones[0].type = addressbook.Person.PhoneNumber.Type.home

    assert phones[0].type != phones[1].type

    phones[1].type = 'home'

    assert phones[0].type == phones[1].type


def test_builder_set(addressbook):
    person = addressbook.Person.new_message()

    person.name = 'test'

    assert person.name == 'test'

    with pytest.raises(AttributeError):
        person.foo = 'test'


def test_null_str(all_types):
    msg = all_types.TestAllTypes.new_message()

    msg.textField = "f\x00oo"
    msg.dataField = b"b\x00ar"

    assert msg.textField == "f\x00oo"
    assert msg.dataField == b"b\x00ar"


def test_unicode_str(all_types):
    msg = all_types.TestAllTypes.new_message()

    if sys.version_info[0] == 2:
        msg.textField = u"f\u00e6oo".encode('utf-8')

        assert msg.textField.decode('utf-8') == u"f\u00e6oo"
    else:
        msg.textField = "f\u00e6oo"

        assert msg.textField == "f\u00e6oo"


def test_new_message(all_types):
    msg = all_types.TestAllTypes.new_message(int32Field=100)

    assert msg.int32Field == 100

    msg = all_types.TestAllTypes.new_message(structField={'int32Field': 100})

    assert msg.structField.int32Field == 100

    msg = all_types.TestAllTypes.new_message(structList=[{'int32Field': 100}, {'int32Field': 101}])

    assert msg.structList[0].int32Field == 100
    assert msg.structList[1].int32Field == 101

    msg = all_types.TestAllTypes.new_message(int32Field=100)

    assert msg.int32Field == 100

    msg = all_types.TestAllTypes.new_message(**{'int32Field': 100, 'int64Field': 101})

    assert msg.int32Field == 100
    assert msg.int64Field == 101


def test_set_dict(all_types):
    msg = all_types.TestAllTypes.new_message()

    msg.structField = {'int32Field': 100}

    assert msg.structField.int32Field == 100

    msg.init('structList', 2)
    msg.structList[0] = {'int32Field': 102}

    assert msg.structList[0].int32Field == 102


def test_set_dict_union(addressbook):
    person = addressbook.Person.new_message(**{'employment': {'employer': {'name': 'foo'}}})

    assert person.employment.employer.name == 'foo'

########NEW FILE########
