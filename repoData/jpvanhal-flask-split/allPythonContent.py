__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Split documentation build configuration file, created by
# sphinx-quickstart on Sat Mar 10 23:03:48 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

from flask.ext.split import __version__

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Split'
copyright = u'2012, Janne Vanhala'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'index_logo': False,
    'github_fork': 'jpvanhal/flask-split',
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Splitdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Split.tex', u'Flask-Split Documentation',
   u'Janne Vanhala', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-split', u'Flask-Split Documentation',
     [u'Janne Vanhala'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Flask-Split', u'Flask-Split Documentation',
   u'Janne Vanhala', 'Flask-Split', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
"""
    flask.ext.split.core
    ~~~~~~~~~~~~~~~~~~~~

    Implements the core functionality for doing A/B tests.

    :copyright: (c) 2012 by Janne Vanhala.
    :license: MIT, see LICENSE for more details.
"""

import re

from flask import current_app, request, session
from redis import ConnectionError

from .models import Alternative, Experiment
from .utils import _get_redis_connection
from .views import split


@split.record
def init_app(state):
    """
    Prepare the Flask application for Flask-Split.

    :param state: :class:`BlueprintSetupState` instance
    """
    app = state.app

    app.config.setdefault('SPLIT_ALLOW_MULTIPLE_EXPERIMENTS', False)
    app.config.setdefault('SPLIT_DB_FAILOVER', False)
    app.config.setdefault('SPLIT_IGNORE_IP_ADDRESSES', [])
    app.config.setdefault('SPLIT_ROBOT_REGEX', r"""
        (?i)\b(
            Baidu|
            Gigabot|
            Googlebot|
            libwww-perl|
            lwp-trivial|
            msnbot|
            SiteUptime|
            Slurp|
            WordPress|
            ZIBB|
            ZyBorg
        )\b
    """)

    app.jinja_env.globals.update({
        'ab_test': ab_test,
        'finished': finished
    })

    @app.template_filter()
    def percentage(number):
        number *= 100
        if abs(number) < 10:
            return "%.1f%%" % round(number, 1)
        else:
            return "%d%%" % round(number)


def ab_test(experiment_name, *alternatives):
    """
    Start a new A/B test.

    Returns one of the alternatives. If the user has already seen the test,
    they will get the same alternative as before.

    :param experiment_name: Name of the experiment.  You should never use the
        same experiment name to refer to a second experiment.
    :param alternatives: A list of alternatives.  Each item can be either a
        string or a two-tuple of the form (alternative name, weight).  By
        default each alternative has the weight of 1.  The first alternative
        is the control.  Every experiment must have at least  two alternatives.
    """
    redis = _get_redis_connection()
    try:
        experiment = Experiment.find_or_create(
            redis, experiment_name, *alternatives)
        if experiment.winner:
            return experiment.winner.name
        else:
            forced_alternative = _override(
                experiment.name, experiment.alternative_names)
            if forced_alternative:
                return forced_alternative
            _clean_old_versions(experiment)
            if (_exclude_visitor() or
                    _not_allowed_to_test(experiment.key)):
                _begin_experiment(experiment)

            alternative_name = _get_session().get(experiment.key)
            if alternative_name:
                return alternative_name
            alternative = experiment.next_alternative()
            alternative.increment_participation()
            _begin_experiment(experiment, alternative.name)
            return alternative.name
    except ConnectionError:
        if not current_app.config['SPLIT_DB_FAILOVER']:
            raise
        control = alternatives[0]
        return control[0] if isinstance(control, tuple) else control


def finished(experiment_name, reset=True):
    """
    Track a conversion.

    :param experiment_name: Name of the experiment.
    :param reset: If set to `True` current user's session is reset so that they
        may start the test again in the future.  If set to `False` the user
        will always see the alternative they started with.  Defaults to `True`.
    """
    if _exclude_visitor():
        return
    redis = _get_redis_connection()
    try:
        experiment = Experiment.find(redis, experiment_name)
        if not experiment:
            return
        alternative_name = _get_session().get(experiment.key)
        if alternative_name:
            if 'split_finished' not in session:
                session['split_finished'] = set()
            if experiment.key not in session['split_finished']:
                alternative = Alternative(
                    redis, alternative_name, experiment_name)
                alternative.increment_completion()
            if reset:
                _get_session().pop(experiment.key, None)
                try:
                    session['split_finished'].remove(experiment.key)
                except KeyError:
                    pass
                session.modified = True
            else:
                session['split_finished'].add(experiment.key)
                session.modified = True
    except ConnectionError:
        if not current_app.config['SPLIT_DB_FAILOVER']:
            raise


def _override(experiment_name, alternatives):
    if request.args.get(experiment_name) in alternatives:
        return request.args.get(experiment_name)


def _begin_experiment(experiment, alternative_name=None):
    if not alternative_name:
        alternative_name = experiment.control.name
    _get_session()[experiment.key] = alternative_name
    session.modified = True


def _get_session():
    if 'split' not in session:
        session['split'] = {}
    return session['split']


def _exclude_visitor():
    """
    Return `True` if the current visitor should be excluded from participating
    to the A/B test, or `False` otherwise.
    """
    return _is_robot() or _is_ignored_ip_address()


def _not_allowed_to_test(experiment_key):
    return (
        not current_app.config['SPLIT_ALLOW_MULTIPLE_EXPERIMENTS'] and
        _doing_other_tests(experiment_key)
    )


def _doing_other_tests(experiment_key):
    """
    Return `True` if the current user is doing other experiments than the
    experiment with the key ``experiment_key`` at the moment, or `False`
    otherwise.
    """
    for key in _get_session().iterkeys():
        if key != experiment_key:
            return True
    return False


def _clean_old_versions(experiment):
    for old_key in _old_versions(experiment):
        del _get_session()[old_key]
    session.modified = True


def _old_versions(experiment):
    if experiment.version > 0:
        return [
            key for key in _get_session().iterkeys()
            if key.startswith(experiment.name) and key != experiment.key
        ]
    else:
        return []


def _is_robot():
    """
    Return `True` if the current visitor is a robot or spider, or
    `False` otherwise.

    This function works by comparing the request's user agent with a regular
    expression.  The regular expression can be configured with the
    ``SPLIT_ROBOT_REGEX`` setting.
    """
    robot_regex = current_app.config['SPLIT_ROBOT_REGEX']
    user_agent = request.headers.get('User-Agent', '')
    return re.search(robot_regex, user_agent, flags=re.VERBOSE)


def _is_ignored_ip_address():
    """
    Return `True` if the IP address of the current visitor should be
    ignored, or `False` otherwise.

    The list of ignored IP addresses can be configured with the
    ``SPLIT_IGNORE_IP_ADDRESSES`` setting.
    """
    ignore_ip_addresses = current_app.config['SPLIT_IGNORE_IP_ADDRESSES']
    return request.remote_addr in ignore_ip_addresses

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
    flask.ext.split.models
    ~~~~~~~~~~~~~~~~~~~~~~

    This module provides the models for experiments and alternatives.

    :copyright: (c) 2012 by Janne Vanhala.
    :license: MIT, see LICENSE for more details.
"""

from datetime import datetime
from math import sqrt
from random import random


class Alternative(object):
    def __init__(self, redis, name, experiment_name):
        self.redis = redis
        self.experiment_name = experiment_name
        if isinstance(name, tuple):
            self.name, self.weight = name
        else:
            self.name = name
            self.weight = 1

    def _get_participant_count(self):
        return int(self.redis.hget(self.key, 'participant_count') or 0)

    def _set_participant_count(self, count):
        self.redis.hset(self.key, 'participant_count', int(count))

    participant_count = property(
        _get_participant_count,
        _set_participant_count
    )

    def _get_completed_count(self):
        return int(self.redis.hget(self.key, 'completed_count') or 0)

    def _set_completed_count(self, count):
        self.redis.hset(self.key, 'completed_count', int(count))

    completed_count = property(
        _get_completed_count,
        _set_completed_count
    )

    def increment_participation(self):
        self.redis.hincrby(self.key, 'participant_count', 1)

    def increment_completion(self):
        self.redis.hincrby(self.key, 'completed_count', 1)

    @property
    def is_control(self):
        return self.experiment.control.name == self.name

    @property
    def conversion_rate(self):
        if self.participant_count == 0:
            return 0
        return float(self.completed_count) / float(self.participant_count)

    @property
    def experiment(self):
        return Experiment.find(self.redis, self.experiment_name)

    def save(self):
        self.redis.hsetnx(self.key, 'participant_count', 0)
        self.redis.hsetnx(self.key, 'completed_count', 0)

    def reset(self):
        self.redis.hmset(self.key, {
            'participant_count': 0,
            'completed_count': 0
        })

    def delete(self):
        self.redis.delete(self.key)

    @property
    def key(self):
        return '%s:%s' % (self.experiment_name, self.name)

    @property
    def z_score(self):
        control = self.experiment.control
        alternative = self

        if control.name == alternative.name:
            return None

        cr = alternative.conversion_rate
        crc = control.conversion_rate

        n = alternative.participant_count
        nc = control.participant_count

        if n == 0 or nc == 0:
            return None

        mean = cr - crc
        var_cr = cr * (1 - cr) / float(n)
        var_crc = crc * (1 - crc) / float(nc)

        if var_cr + var_crc == 0:
            return None

        return mean / sqrt(var_cr + var_crc)

    @property
    def confidence_level(self):
        z = self.z_score
        if z is None:
            return 'N/A'
        z = abs(round(z, 3))
        if z == 0:
            return 'no change'
        elif z < 1.64:
            return 'no confidence'
        elif z < 1.96:
            return '90% confidence'
        elif z < 2.57:
            return '95% confidence'
        elif z < 3.29:
            return '99% confidence'
        else:
            return '99.9% confidence'


class Experiment(object):
    def __init__(self, redis, name, *alternative_names):
        self.redis = redis
        self.name = name
        self.alternatives = [
            Alternative(redis, alternative, name)
            for alternative in alternative_names
        ]

    @property
    def control(self):
        return self.alternatives[0]

    def _get_winner(self):
        winner = self.redis.hget('experiment_winner', self.name)
        if winner:
            return Alternative(self.redis, winner, self.name)

    def _set_winner(self, winner_name):
        self.redis.hset('experiment_winner', self.name, winner_name)

    winner = property(
        _get_winner,
        _set_winner
    )

    def reset_winner(self):
        """Reset the winner of this experiment."""
        self.redis.hdel('experiment_winner', self.name)

    @property
    def start_time(self):
        """The start time of this experiment."""
        t = self.redis.hget('experiment_start_times', self.name)
        if t:
            return datetime.strptime(t, '%Y-%m-%dT%H:%M:%S')

    @property
    def total_participants(self):
        """The total number of participants in this experiment."""
        return sum(a.participant_count for a in self.alternatives)

    @property
    def total_completed(self):
        """The total number of users who completed this experiment."""
        return sum(a.completed_count for a in self.alternatives)

    @property
    def alternative_names(self):
        """A list of alternative names. in this experiment."""
        return [alternative.name for alternative in self.alternatives]

    def next_alternative(self):
        """Return the winner of the experiment if set, or a random
        alternative."""
        return self.winner or self.random_alternative()

    def random_alternative(self):
        total = sum(alternative.weight for alternative in self.alternatives)
        point = random() * total
        for alternative in self.alternatives:
            if alternative.weight >= point:
                return alternative
            point -= alternative.weight

    @property
    def version(self):
        return int(self.redis.get('%s:version' % self.name) or 0)

    def increment_version(self):
        self.redis.incr('%s:version' % self.name)

    @property
    def key(self):
        if self.version > 0:
            return "%s:%s" % (self.name, self.version)
        else:
            return self.name

    def reset(self):
        """Delete all data for this experiment."""
        for alternative in self.alternatives:
            alternative.reset()
        self.reset_winner()
        self.increment_version()

    def delete(self):
        """Delete this experiment and all its data."""
        for alternative in self.alternatives:
            alternative.delete()
        self.reset_winner()
        self.redis.srem('experiments', self.name)
        self.redis.delete(self.name)
        self.increment_version()

    @property
    def is_new_record(self):
        return self.name not in self.redis

    def save(self):
        if self.is_new_record:
            start_time = self._get_time().isoformat()[:19]
            self.redis.sadd('experiments', self.name)
            self.redis.hset('experiment_start_times', self.name, start_time)
            for alternative in reversed(self.alternatives):
                self.redis.lpush(self.name, alternative.name)

    @classmethod
    def load_alternatives_for(cls, redis, name):
        return redis.lrange(name, 0, -1)

    @classmethod
    def all(cls, redis):
        return [cls.find(redis, e) for e in redis.smembers('experiments')]

    @classmethod
    def find(cls, redis, name):
        if name in redis:
            return cls(redis, name, *cls.load_alternatives_for(redis, name))

    @classmethod
    def find_or_create(cls, redis, key, *alternatives):
        name = key.split(':')[0]

        if len(alternatives) < 2:
            raise TypeError('You must declare at least 2 alternatives.')

        experiment = cls.find(redis, name)
        if experiment:
            alts = [a[0] if isinstance(a, tuple) else a for a in alternatives]
            if [a.name for a in experiment.alternatives] != alts:
                experiment.reset()
                for alternative in experiment.alternatives:
                    alternative.delete()
                experiment = cls(redis, name, *alternatives)
                experiment.save()
        else:
            experiment = cls(redis, name, *alternatives)
            experiment.save()
        return experiment

    def _get_time(self):
        return datetime.now()

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
"""
    flask.ext.split.utils
    ~~~~~~~~~~~~~~~~~~~~~

    Generic utility functions.

    :copyright: (c) 2012 by Janne Vanhala.
    :license: MIT, see LICENSE for more details.
"""

import urlparse

from flask import current_app
import redis


urlparse.uses_netloc.append('redis')


def _get_redis_connection():
    """
    Return a Redis connection based on the Flask application's configuration.

    The connection parameters are retrieved from `REDIS_URL` configuration
    variable.

    :return: an instance of :class:`redis.Connection`
    """
    url = current_app.config.get('REDIS_URL', 'redis://localhost:6379')
    return redis.from_url(url)

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-
"""
    flask.ext.split.views
    ~~~~~~~~~~~~~~~~~~~~~

    This module provides the views for Flask-Split's web interface.

    :copyright: (c) 2012 by Janne Vanhala.
    :license: MIT, see LICENSE for more details.
"""

import os

from flask import Blueprint, redirect, render_template, request, url_for

from .models import Alternative, Experiment
from .utils import _get_redis_connection


root = os.path.abspath(os.path.dirname(__file__))
split = Blueprint('split', 'flask.ext.split',
    template_folder=os.path.join(root, 'templates'),
    static_folder=os.path.join(root, 'static'),
    url_prefix='/split'
)


@split.context_processor
def inject_version():
    from . import __version__
    return dict(version=__version__)


@split.route('/')
def index():
    """Render a dashboard that lists all active experiments."""
    redis = _get_redis_connection()
    return render_template('split/index.html',
        experiments=Experiment.all(redis)
    )


@split.route('/<experiment>', methods=['POST'])
def set_experiment_winner(experiment):
    """Mark an alternative as the winner of the experiment."""
    redis = _get_redis_connection()
    experiment = Experiment.find(redis, experiment)
    if experiment:
        alternative_name = request.form.get('alternative')
        alternative = Alternative(redis, alternative_name, experiment.name)
        if alternative.name in experiment.alternative_names:
            experiment.winner = alternative.name
    return redirect(url_for('.index'))


@split.route('/<experiment>/reset', methods=['POST'])
def reset_experiment(experiment):
    """Delete all data for an experiment."""
    redis = _get_redis_connection()
    experiment = Experiment.find(redis, experiment)
    if experiment:
        experiment.reset()
    return redirect(url_for('.index'))


@split.route('/<experiment>/delete', methods=['POST'])
def delete_experiment(experiment):
    """Delete an experiment and all its data."""
    redis = _get_redis_connection()
    experiment = Experiment.find(redis, experiment)
    if experiment:
        experiment.delete()
    return redirect(url_for('.index'))

########NEW FILE########
__FILENAME__ = test_dashboard
# -*- coding: utf-8 -*-

from datetime import datetime

from flask_split.models import Alternative, Experiment
from flexmock import flexmock

from . import assert_redirects, TestCase


class TestDashboard(TestCase):
    def test_responds_to_index(self):
        response = self.client.get('/split/')
        assert response.status_code == 200

    def test_reset_an_experiment(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')

        red = Alternative(self.redis, 'red', 'link_color')
        blue = Alternative(self.redis, 'blue', 'link_color')
        red.participant_count = 5
        blue.participant_count = 6

        response = self.client.post('/split/link_color/reset')
        assert_redirects(response, '/split/')

        assert red.participant_count == 0
        assert blue.participant_count == 0

    def test_reset_a_non_existing_experiment(self):
        response = self.client.post('/split/foobar/reset')
        assert_redirects(response, '/split/')

    def test_delete_an_experiment(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        response = self.client.post('/split/link_color/delete')
        assert_redirects(response, '/split/')
        assert Experiment.find(self.redis, 'link_color') is None

    def test_delete_a_non_existing_experiment(self):
        response = self.client.post('/split/foobar/delete')
        assert_redirects(response, '/split/')

    def test_mark_an_alternative_as_the_winner(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        assert experiment.winner is None

        response = self.client.post('/split/link_color',
            data={'alternative': 'red'})
        assert_redirects(response, '/split/')

        assert experiment.winner.name == 'red'

    def test_mark_a_non_existing_alternative_as_the_winner(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        assert experiment.winner is None

        response = self.client.post('/split/link_color',
            data={'alternative': 'foobar'})
        assert_redirects(response, '/split/')

        assert experiment.winner is None

    def test_mark_alternative_as_winner_for_non_existing_experiment(self):
        response = self.client.post('/split/foobar',
            data={'alternative': 'red'})
        assert_redirects(response, '/split/')

    def test_displays_the_start_date(self):
        experiment_start_time = datetime(2011, 7, 7)
        (flexmock(Experiment)
            .should_receive('_get_time')
            .and_return(experiment_start_time))
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        response = self.client.get('/split/')
        assert '2011-07-07' in response.data

########NEW FILE########
__FILENAME__ = test_extension
# -*- coding: utf-8 -*-

from __future__ import with_statement

from flask import session
from flask_split import ab_test, finished
from flask_split.core import _get_session
from flask_split.models import Alternative, Experiment
from flexmock import flexmock
from pytest import raises
from redis import ConnectionError, Redis

from . import TestCase


class TestExtension(TestCase):
    def test_provides_defaults_for_settings(self):
        assert self.app.config['SPLIT_IGNORE_IP_ADDRESSES'] == []
        assert self.app.config['SPLIT_ROBOT_REGEX'].strip() == r"""
        (?i)\b(
            Baidu|
            Gigabot|
            Googlebot|
            libwww-perl|
            lwp-trivial|
            msnbot|
            SiteUptime|
            Slurp|
            WordPress|
            ZIBB|
            ZyBorg
        )\b
        """.strip()
        assert self.app.config['SPLIT_DB_FAILOVER'] is False
        assert self.app.config['SPLIT_ALLOW_MULTIPLE_EXPERIMENTS'] is False

    def test_ab_test_assigns_random_alternative_to_a_new_user(self):
        ab_test('link_color', 'blue', 'red')
        assert _get_session()['link_color'] in ['red', 'blue']

    def test_ab_test_increments_participation_counter_for_new_user(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')

        red = Alternative(self.redis, 'red', 'link_color')
        blue = Alternative(self.redis, 'blue', 'link_color')

        previous_red_count = red.participant_count
        previous_blue_count = blue.participant_count

        ab_test('link_color', 'blue', 'red')

        new_red_count = red.participant_count
        new_blue_count = blue.participant_count

        assert (new_red_count + new_blue_count ==
            previous_red_count + previous_blue_count + 1)

    def test_ab_test_returns_the_given_alternative_for_an_existing_user(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative = ab_test('link_color', 'blue', 'red')
        repeat_alternative = ab_test('link_color', 'blue', 'red')
        assert alternative == repeat_alternative

    def test_ab_test_always_returns_the_winner_if_one_is_present(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.winner = "orange"

        assert ab_test('link_color', 'blue', 'red') == 'orange'

    def test_ab_test_allows_the_share_of_visitors_see_an_alternative(self):
        ab_test('link_color', ('blue', 0.8), ('red', 20))
        assert _get_session()['link_color'] in ['red', 'blue']

    def test_ab_test_only_lets_user_participate_in_one_experiment(self):
        ab_test('link_color', 'blue', 'red')
        ab_test('button_size', 'small', 'big')
        assert _get_session()['button_size'] == 'small'
        big = Alternative(self.redis, 'big', 'button_size')
        assert big.participant_count == 0
        small = Alternative(self.redis, 'small', 'button_size')
        assert small.participant_count == 0

    def test_can_participate_in_many_experiments_with_allow_multiple_experiments(self):
        self.app.config['SPLIT_ALLOW_MULTIPLE_EXPERIMENTS'] = True
        link_color = ab_test('link_color', 'blue', 'red')
        button_size = ab_test('button_size', 'small', 'big')
        assert _get_session()['button_size'] == button_size
        button_size_alt = Alternative(self.redis, button_size, 'button_size')
        assert button_size_alt.participant_count == 1

    def test_finished_increments_completed_alternative_counter(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        previous_completion_count = alternative.completed_count
        finished('link_color')
        new_completion_count = alternative.completed_count
        assert new_completion_count == previous_completion_count + 1

    def test_finished_clears_out_users_participation_from_their_session(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')

        assert session['split'] == {"link_color": alternative_name}
        finished('link_color')
        assert session['split'] == {}

    def test_finished_clears_test_session_when_version_is_greater_than_0(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.increment_version()

        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {"link_color:1": alternative_name}

        finished('link_color')
        assert session['split'] == {}

    def test_finished_dont_clear_out_the_users_session_if_reset_is_false(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')

        assert session['split'] == {"link_color": alternative_name}
        finished('link_color', reset=False)
        assert session['split'] == {
            "link_color": alternative_name,
        }
        assert session['split_finished'] == set(['link_color'])

    def test_finished_does_nothing_if_experiment_was_not_started_by_the_user(self):
        session['split'] = None
        finished('some_experiment_not_started_by_the_user')

    def test_finished_dont_incr_completed_twice_if_no_reset(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')

        alternative_name = ab_test('link_color', 'blue', 'red')
        finished('link_color', reset=False)
        finished('link_color', reset=False)

        alternative = Alternative(self.redis, alternative_name, 'link_color')
        completion_count = alternative.completed_count
        assert completion_count == 1

    def test_finished_dont_incr_completed_twice_if_ver_gt_0_and_no_reset(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.increment_version()

        alternative_name = ab_test('link_color', 'blue', 'red')
        finished('link_color', reset=False)

        alternative_name = ab_test('link_color', 'blue', 'red')
        finished('link_color', reset=False)

        alternative = Alternative(self.redis, alternative_name, 'link_color')
        completion_count = alternative.completed_count
        assert completion_count == 1

    def test_conversions_return_conversion_rates_for_alternatives(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')

        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.conversion_rate == 0.0

        finished('link_color')

        assert alternative.conversion_rate == 1.0


class TestExtensionWhenUserIsARobot(TestCase):
    def make_test_request_context(self):
        return self.app.test_request_context(
            headers={
                'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)'
            }
        )

    def test_ab_test_return_the_control(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative = ab_test('link_color', 'blue', 'red')
        assert alternative == experiment.control.name

    def test_ab_test_does_not_increment_the_participation_count(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')

        red = Alternative(self.redis, 'red', 'link_color')
        blue = Alternative(self.redis, 'blue', 'link_color')

        previous_red_count = red.participant_count
        previous_blue_count = blue.participant_count

        ab_test('link_color', 'blue', 'red')

        new_red_count = red.participant_count
        new_blue_count = blue.participant_count

        assert (new_red_count + new_blue_count ==
            previous_red_count + previous_blue_count)

    def test_finished_does_not_increment_the_completed_count(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        alternative = Alternative(self.redis, alternative_name, 'link_color')

        previous_completion_count = alternative.completed_count

        finished('link_color')

        new_completion_count = alternative.completed_count

        assert new_completion_count == previous_completion_count


class TestExtensionWhenIPAddressIsIgnored(TestCase):
    def setup_method(self, method):
        super(TestExtensionWhenIPAddressIsIgnored, self).setup_method(method)
        self.app.config['SPLIT_IGNORE_IP_ADDRESSES'] = ['81.19.48.130']

    def make_test_request_context(self):
        return self.app.test_request_context(environ_overrides={
            'REMOTE_ADDR': '81.19.48.130'
        })

    def test_ab_test_return_the_control(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative = ab_test('link_color', 'blue', 'red')
        assert alternative == experiment.control.name

    def test_ab_test_does_not_increment_the_participation_count(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')

        red = Alternative(self.redis, 'red', 'link_color')
        blue = Alternative(self.redis, 'blue', 'link_color')

        previous_red_count = red.participant_count
        previous_blue_count = blue.participant_count

        ab_test('link_color', 'blue', 'red')

        new_red_count = red.participant_count
        new_blue_count = blue.participant_count

        assert (new_red_count + new_blue_count ==
            previous_red_count + previous_blue_count)

    def test_finished_does_not_increment_the_completed_count(self):
        Experiment.find_or_create(self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        alternative = Alternative(self.redis, alternative_name, 'link_color')

        previous_completion_count = alternative.completed_count

        finished('link_color')

        new_completion_count = alternative.completed_count

        assert new_completion_count == previous_completion_count


class TestVersionedExperiments(TestCase):
    def test_uses_version_zero_if_no_version_is_present(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert experiment.version == 0
        assert session['split'] == {'link_color': alternative_name}

    def test_saves_the_version_of_the_experiment_to_the_session(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.reset()
        assert experiment.version == 1
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color:1': alternative_name}

    def test_loads_the_experiment_even_if_the_version_is_not_0(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.reset()
        assert experiment.version == 1
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color:1': alternative_name}
        return_alternative_name = ab_test('link_color', 'blue', 'red')
        assert return_alternative_name == alternative_name

    def test_resets_users_session_on_an_older_version_of_the_experiment(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color': alternative_name}
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.participant_count == 1

        experiment.reset()
        assert experiment.version == 1
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.participant_count == 0

        new_alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split']['link_color:1'] == new_alternative_name
        new_alternative = Alternative(
            self.redis, new_alternative_name, 'link_color')
        assert new_alternative.participant_count == 1

    def test_cleans_up_old_versions_of_experiments_from_the_session(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color': alternative_name}
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.participant_count == 1

        experiment.reset()
        assert experiment.version == 1
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.participant_count == 0

        new_alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color:1': new_alternative_name}

    def test_only_counts_completion_of_users_on_the_current_version(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        alternative_name = ab_test('link_color', 'blue', 'red')
        assert session['split'] == {'link_color': alternative_name}
        alternative = Alternative(self.redis, alternative_name, 'link_color')

        experiment.reset()
        assert experiment.version == 1

        finished('link_color')
        alternative = Alternative(self.redis, alternative_name, 'link_color')
        assert alternative.completed_count == 0


class TestExtensionWhenRedisNotAvailable(TestCase):
    def test_ab_test_raises_an_exception_without_db_failover(self):
        self.app.config['SPLIT_DB_FAILOVER'] = False
        (flexmock(Redis)
            .should_receive('execute_command')
            .and_raise(ConnectionError))
        with raises(ConnectionError):
            ab_test('link_color', 'blue', 'red')

    def test_finished_raises_an_exception_without_db_failover(self):
        self.app.config['SPLIT_DB_FAILOVER'] = False
        (flexmock(Redis)
            .should_receive('execute_command')
            .and_raise(ConnectionError))
        with raises(ConnectionError):
            finished('link_color')

    def test_ab_test_does_not_raise_an_exception_with_db_failover(self):
        self.app.config['SPLIT_DB_FAILOVER'] = True
        (flexmock(Redis)
            .should_receive('execute_command')
            .and_raise(ConnectionError))
        ab_test('link_color', 'blue', 'red')

    def test_ab_test_always_uses_first_alternative_with_db_failover(self):
        self.app.config['SPLIT_DB_FAILOVER'] = True
        (flexmock(Redis)
            .should_receive('execute_command')
            .and_raise(ConnectionError))
        assert ab_test('link_color', 'blue', 'red') == 'blue'
        assert ab_test('link_color', ('blue', 0.01), ('red', 0.2)) == 'blue'
        assert ab_test('link_color', ('blue', 0.8), ('red', 20)) == 'blue'

    def test_finished_does_not_raise_an_exception_with_db_failover(self):
        self.app.config['SPLIT_DB_FAILOVER'] = True
        (flexmock(Redis)
            .should_receive('execute_command')
            .and_raise(ConnectionError))
        finished('link_color')

########NEW FILE########
__FILENAME__ = test_models
# -*- coding: utf-8 -*-

from datetime import datetime

from flask_split.models import Alternative, Experiment
from flexmock import flexmock

from . import TestCase


class TestAlternative(TestCase):
    def test_has_name(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.name == 'Basket'

    def test_has_default_participation_count_of_0(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.participant_count == 0

    def test_has_default_completed_count_of_0(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.completed_count == 0

    def test_belong_to_an_experiment(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.experiment.name == experiment.name

    def test_saves_to_redis(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        alternative.save()
        assert 'basket_text:Basket' in self.redis

    def test_increment_participation_count(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', "Cart")
        experiment.save()
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        old_participant_count = alternative.participant_count
        alternative.increment_participation()
        assert alternative.participant_count == old_participant_count + 1

    def test_increment_completed_count(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', "Cart")
        experiment.save()
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        old_completed_count = alternative.participant_count
        alternative.increment_completion()
        assert alternative.completed_count == old_completed_count + 1

    def test_can_be_reset(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        alternative.participant_count = 10
        alternative.completed_count = 4
        alternative.reset()
        assert alternative.participant_count == 0
        assert alternative.completed_count == 0

    def test_know_if_it_is_the_control_of_an_experiment(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.is_control
        alternative = Alternative(self.redis, 'Cart', 'basket_text')
        assert not alternative.is_control

    def test_conversion_rate_is_0_if_there_are_no_conversions(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        assert alternative.completed_count == 0
        assert alternative.conversion_rate == 0

    def test_conversion_rate_does_something(self):
        alternative = Alternative(self.redis, 'Basket', 'basket_text')
        alternative.participant_count = 10
        alternative.completed_count = 4
        assert alternative.conversion_rate == 0.4

    def test_z_score_is_none_for_the_control(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        assert experiment.control.z_score is None

    def test_z_score_is_none_when_the_control_has_no_participations(self):
        experiment = Experiment(self.redis, 'link_color', 'blue', 'red')
        experiment.save()
        alternative = Alternative(self.redis, 'red', 'link_color')
        assert alternative.z_score is None

    def test_z_score_is_none_when_alternative_has_no_participations(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.save()
        alternative = Alternative(self.redis, 'red', 'link_color')
        assert alternative.z_score is None

    def test_z_score_when_control_and_alternative_have_perfect_conversion(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.save()
        control = Alternative(self.redis, 'blue', 'link_color')
        control.completed_count = 10
        control.participant_count = 10
        alternative = Alternative(self.redis, 'red', 'link_color')
        alternative.completed_count = 8
        alternative.participant_count = 8
        assert alternative.z_score is None

    def test_z_score(self):
        Experiment.find_or_create(self.redis, 'Treatment',
            'Control', 'Treatment A', 'Treatment B', 'Treatment C')

        control = Alternative(self.redis, 'Control', 'Treatment')
        control.participant_count = 182
        control.completed_count = 35

        treatment_a = Alternative(self.redis, 'Treatment A', 'Treatment')
        treatment_a.participant_count = 180
        treatment_a.completed_count = 45

        treatment_b = Alternative(self.redis, 'Treatment B', 'Treatment')
        treatment_b.participant_count = 189
        treatment_b.completed_count = 28

        treatment_c = Alternative(self.redis, 'Treatment C', 'Treatment')
        treatment_c.participant_count = 188
        treatment_c.completed_count = 61

        assert control.z_score is None
        assert round(treatment_a.z_score, 2) == 1.33
        assert round(treatment_b.z_score, 2) == -1.13
        assert round(treatment_c.z_score, 2) == 2.94


class TestExperiment(TestCase):
    def test_has_name(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        assert experiment.name == 'basket_text'

    def test_has_alternatives(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        assert len(experiment.alternatives) == 2

    def test_saves_to_redis(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        assert 'basket_text' in self.redis

    def test_saves_the_start_time_to_redis(self):
        experiment_start_time = datetime(2012, 3, 9, 22, 01, 34)
        (flexmock(Experiment)
            .should_receive('_get_time')
            .and_return(experiment_start_time))
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        assert experiment.start_time == experiment_start_time

    def test_handles_not_having_a_start_time(self):
        experiment_start_time = datetime(2012, 3, 9, 22, 01, 34)
        (flexmock(Experiment)
            .should_receive('_get_time')
            .and_return(experiment_start_time))
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()

        self.redis.hdel('experiment_start_times', experiment.name)

        assert experiment.start_time is None

    def test_does_not_create_duplicates_when_saving_multiple_times(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        experiment.save()
        assert 'basket_text' in self.redis
        assert self.redis.lrange('basket_text', 0, -1) == ['Basket', 'Cart']

    def test_deleting_should_delete_itself(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()

        experiment.delete()
        assert 'basket_text' not in self.redis

    def test_deleting_should_increment_the_version(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        assert experiment.version == 0
        experiment.delete()
        assert experiment.version == 1

    def test_is_new_record_knows_if_it_hasnt_been_saved_yet(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        assert experiment.is_new_record

    def test_is_new_record_knows_if_it_has_been_saved_yet(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        assert not experiment.is_new_record

    def test_find_returns_an_existing_experiment(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        assert Experiment.find(self.redis, 'basket_text').name == 'basket_text'

    def test_handles_non_existing_experiment(self):
        assert Experiment.find(self.redis, 'non_existent_experiment') is None

    def test_control_is_the_first_alternative(self):
        experiment = Experiment(self.redis, 'basket_text', 'Basket', 'Cart')
        experiment.save()
        assert experiment.control.name == 'Basket'

    def test_have_no_winner_initially(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        assert experiment.winner is None

    def test_allow_you_to_specify_a_winner(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        experiment.winner = 'red'

        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red')
        assert experiment.winner.name == 'red'

    def test_reset_should_reset_all_alternatives(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        green = Alternative(self.redis, 'green', 'link_color')
        experiment.winner = 'green'

        assert experiment.next_alternative().name == 'green'
        green.increment_participation()

        experiment.reset()

        reset_green = Alternative(self.redis, 'green', 'link_color')
        assert reset_green.participant_count == 0
        assert reset_green.completed_count == 0

    def test_reset_should_reset_the_winner(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        green = Alternative(self.redis, 'green', 'link_color')
        experiment.winner = 'green'

        assert experiment.next_alternative().name == 'green'
        green.increment_participation()

        experiment.reset()

        assert experiment.winner is None

    def test_reset_should_increment_the_version(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        assert experiment.version == 0
        experiment.reset()
        assert experiment.version == 1

    def test_next_alternative_always_returns_the_winner_if_one_exists(self):
        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        green = Alternative(self.redis, 'green', 'link_color')
        experiment.winner = 'green'

        assert experiment.next_alternative().name == 'green'
        green.increment_participation()

        experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'red', 'green')
        assert experiment.next_alternative().name == 'green'

    def test_reset_an_experiment_if_loaded_with_different_alternatives(self):
        experiment = Experiment(
            self.redis, 'link_color', 'blue', 'red', 'green')
        experiment.save()
        blue = Alternative(self.redis, 'blue', 'link_color')
        blue.participant_count = 5
        blue.save()
        same_experiment = Experiment.find_or_create(
            self.redis, 'link_color', 'blue', 'yellow', 'orange')
        alternative_names = [a.name for a in same_experiment.alternatives]
        assert alternative_names == ['blue', 'yellow', 'orange']
        new_blue = Alternative(self.redis, 'blue', 'link_color')
        assert new_blue.participant_count == 0

########NEW FILE########
