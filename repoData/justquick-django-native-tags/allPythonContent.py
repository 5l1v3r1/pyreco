__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Native Tags documentation build configuration file, created by
# sphinx-quickstart on Fri Oct 30 03:18:09 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'example_project.settings'
import native_tags
# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Native Tags'
copyright = u'2010, Justin Quick <justquick@gmail.com>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = release = native_tags.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoNativeTagsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoNativeTags.tex', u'Django Native Tags Documentation',
   u'Justin Quick', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = app_tags
from native_tags.decorators import function, comparison, filter
from datetime import datetime

def dynamic(*a, **kw):
    return list(a) + sorted(kw.items())
dynamic = function(dynamic)

def no_render(*a, **kw):
     return list(a) + sorted(kw.items())
no_render = function(no_render, resolve=False)

def myfilter(value, arg):
    return value + arg
myfilter = filter(myfilter, test={'args':(1,1),'result':2})
    
def adder(x, y):
    return x + y
adder = function(adder, name='add', test={'args':(1,1),'result':2})
    
def cmp_kwargs(**kw):
    return len(kw)
cmp_kwargs = comparison(cmp_kwargs)

def myinc(noun):
    return 'unittest.html', {'noun': noun}
myinc = function(myinc, inclusion=True)

def ifsomething():
    return True
ifsomething = comparison(ifsomething)

def date():
    return datetime.now()
date = function(date, cache=3600)

def fail():
    1/0
fail = function(fail, fallback='woot')
########NEW FILE########
__FILENAME__ = tests
import datetime
from django.contrib.auth.models import User
from django.template import Template, Context, TemplateSyntaxError
from django.test import TestCase
from django.core.serializers import deserialize
from django.core.cache import cache

from native_tags.registry import register, AlreadyRegistered
from native_tags.nodes import get_cache_key

def render(src, ctx={}):
    return Template(src).render(Context(ctx))

class TemplateTests(TestCase):
    def setUp(self):
        self.test_user = User.objects.create(username='tester', email='test')
        # User.objects.create(username='tester2', email='test2')
        # User.objects.create(username='tester3', email='test3')
        # User.objects.create(username='tester4', email='test4')
        self.hash = {'foo':'bar'}


    def test_less(self):
        t = """{% if_less 1 2 %}y{% endif_less %}{% if_less_or_equal 1 2 %}y{% endif_less_or_equal %}{% if_greater 2 1 %}n{% endif_greater %}{% if_greater_or_equal 1 1 %}y{% endif_greater_or_equal %}"""
        self.assertEqual(render(t), 'yyny')
    
    def test_set(self):
        t = "{% set src='import this' %}{{ src }}"
        self.assertEqual(render(t), 'import this')
    
    def test_del(self):
        t = "{% del test %}{{ test }}"
        self.assertEqual(render(t,{'test': 'yup'}), '')
    
    def _serialize(self, format):
        t = "{% serialize format users as seria %}{{ seria|safe }}"
        seria = render(t, {'format':format,'users':User.objects.all()})
        if format == 'python': seria = eval(seria)
        self.assertEqual(deserialize(format, seria).next().object.username, 'tester')
    
    def test_serialize_json(self):
        self._serialize('json')
    
    def test_serialize_python(self):
        self._serialize('python')
    
    def test_serialize_xml(self):
        self._serialize('xml')
    
    def test_contains(self):
        t = "{% if_contains 'team' 'i' %}yup{% endif_contains %}"
        self.assertEqual(render(t), '')
    
    def test_divisible(self):
        t = "{% if_divisible_by 150 5 %}buzz{% endif_divisible_by %}"
        self.assertEqual(render(t), 'buzz')
    
    def test_startswith(self):
        t = "{% if_startswith 'python' 'p' %}yup{% endif_startswith %}"
        self.assertEqual(render(t), 'yup')
    
    def test_subset(self):
        t = "{% if_subset l1 l2 %}yup{% endif_subset %}"
        self.assertEqual(render(t, {'l1':[2,3], 'l2':range(5)}), 'yup')
    
    def test_superset(self):
        self.assertEqual(render("{% if_superset l1 l2 %}yup{% endif_superset %}",{'l1':range(5),'l2':[2,3]}),'yup')
    
    def test_endswith(self):
        self.assertEqual(render("{% if_endswith 'python' 'n' %}yup{% endif_endswith %}"), 'yup')
    
    def test_startswith_negate(self):
        t = "{% if_startswith 'python' 'p' negate %}yup{% endif_startswith %}"
        self.assertEqual(render(t), '')
    
    def test_startswith_negate_else(self):
        t = "{% if_startswith 'python' 'p' negate %}yup{% else %}nope{% endif_startswith %}"
        self.assertEqual(render(t), 'nope')
    
    def test_setting(self):
        t = "{% if_setting 'DEBUG' %}debug{% endif_setting %}"
        self.assertEqual(render(t), 'debug')
    
    def test_sha1_filter(self):
        sha1 = '62cdb7020ff920e5aa642c3d4066950dd1f01f4d'
        self.assertEqual(render('{{ foo|sha1 }}', self.hash), sha1)
    
    def test_sha1_function(self):
        sha1 = '62cdb7020ff920e5aa642c3d4066950dd1f01f4d'
        self.assertEqual(render('{% sha1 foo %}', self.hash), sha1)
    
    def test_md5_2X(self):
        md5 = '37b51d194a7513e45b56f6524f2d51f2'
        self.assertEqual(render('{{ foo|md5 }}{% md5 foo %}', self.hash), md5*2)
    
    def test_greater(self):
        t = '{% if_greater 2 1 %}yup{% endif_greater %}'
        self.assertEqual(render(t), 'yup')
    
    def test_render_block(self):
        t = '{% render_block as myvar %}hello {{ place }}{% endrender_block %}{{ myvar }}'
        self.assertEqual(render(t, {'place':'world'}), 'hello world')
    
    def test_get_latest_object(self):
        t = '{% get_latest_object auth.user date_joined %}'
        self.assertEqual(render(t), 'tester')
    
    def test_get_latest_objects(self):
        t = '{% get_latest_objects auth.user 10 %}'
        self.assertEqual(render(t), '[<User: tester>]')
    
    def test_get_random_object(self):
        t = '{% get_random_object auth.user %}'
        self.assertEqual(render(t), 'tester')
    
    def test_get_random_objects(self):
        t = '{% get_random_objects auth.user 10 %}'
        self.assertEqual(render(t), '[<User: tester>]')
    
    def test_retrieve_object(self):
        t = '{% retrieve_object auth.user username=tester %}'
        self.assertEqual(render(t), 'tester')
    
    def test_matches(self):
        t = "{% if_matches '\w{4}' 'hiya' %}yup{% endif_matches %}"
        self.assertEqual(render(t), 'yup')
    
    def test_search(self):
        t = "{% search '^(\d{3})$' 800 as match %}{{ match.groups|safe }}"
        self.assertEqual(render(t), u"('800',)")
    
    def test_substitute(self):
        t = "{% substitute 'ROAD$' 'RD.' '100 NORTH MAIN ROAD' %}"
        self.assertEqual(render(t), '100 NORTH MAIN RD.')
    
    def test_map(self):
        t = '{% map sha1 hello world as hashes %}{{ hashes|join:"-" }}'
        self.assertEqual(render(t),  'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d-7c211433f02071597741e6ff5a8ea34789abbf43')
    
    def test_reduce(self):
        t = '{% reduce add 300 30 3 %}'
        self.assertEqual(render(t), '333')
    
    def test_calendar_month(self):
        self.assert_(render('{% calendar month 2009 10 %}').startswith('<table'))
    
    def test_calendar_year(self):
        self.assert_(render('{% calendar year 2009 %}').startswith('<table'))
    
    def test_calendar_yearpage(self):
        self.assert_(render('{% calendar yearpage 2009 %}').startswith('<?xml version="1.0" encoding="ascii"?>'))
    
    def test_randrange(self):
        self.assert_(render('{% randrange 10 %}') in map(str,range(10)))
    
    def test_randint(self):
        self.assert_(0 <= int(render('{% randint 0 10 %}')) <= 10)
    
    def test_randchoice(self):
        self.assert_(render('{% randchoice 1 2 3 %}') in '123')
    
    def test_random(self):
        self.assert_(0. <= float(render('{% random %}')) < 1.)
    
    def test_loops_work(self):
        """
        Does looping while setting a context variable work
        """
        t = "{% for i in items %}{% add 1 i as roomba %}{{roomba}}{% endfor %}"
        o = render(t, {'items':[1,2,3]})
        self.assertEqual(o, "234")
    
    def test_b64encode(self):
        self.assertEqual(render('{% b64encode "hello world" %}'), 'aGVsbG8gd29ybGQ=')
    
    def test_b64decode(self):
        self.assertEqual(render('{% b64decode encoded %}', {'encoded':'aGVsbG8gd29ybGQ='}), 'hello world')
    
    def test_dynamic(self):
        self.assertEqual(eval(render('{% dynamic a b c d=1 e=2 %}')),
                          ['a', 'b', 'c', ('d', 1), ('e', 2)])
    
    def test_no_render(self):
        self.assertEqual(eval(render('{% no_render a b c d d=1 e=2 f=var %}', {'var':'hello'})),
                          ['a', 'b', 'c', 'd', ('d', '1'), ('e', '2'), ('f', 'var')])
    
    def test_filter_args(self):
        self.assertEqual(render('{{ var|myfilter:"baz" }}', {'var':'foobar'}), 'foobarbaz')
    
    def test_adder(self):
        self.assertEqual(render('{% load native humanize %}{% add 1000 100 as num %}{{ num|intcomma }}'), '1,100')
    
    def test_cmp_kwargs(self):
        self.assertEqual(render('{% if_cmp_kwargs foo=bar %}yup{% endif_cmp_kwargs %}'), 'yup')
    
    def test_zremove_tag(self):
        self.assert_('add' in register['function'])
        register.unregister('function', 'add')
        self.assert_(not 'add' in register['function'])
       
    def test_inclusion(self):
        self.assertEqual(render('{% myinc cheese %}'), 'im just here for the cheese')
    
    def test_map_builtins(self):
        self.assertEqual(render('{% map len l1 l2 l3 %}', {'l1':[1], 'l2':[1,2], 'l3':[1,2,3]}), '[1, 2, 3]')
    
    def test_smartypants(self):
        # this should b bombing, but i get DEBUG as False when testing despite the settings (just in testing?)
        self.assertEqual(render('{{ value|smartypants }}', {'value': 'wtf'}), 'wtf')
        
    def test_custom_if(self):
        self.assertEqual(render('{% ifsomething %}yup{% endifsomething %}'), 'yup')
    
    def test_filter_faker(self):
        self.assertRaises(TemplateSyntaxError, render, '{% sha1 "my | filter | faker" %}')
    
    def test_math(self):
        import math
        self.assertAlmostEqual(float(render('{% acos .3 %}')), 1.26610367278)
        self.assertEqual(float(render('{{ 1.5|floor }}')), 1.)
        self.assertEqual(float(render('{{ 4|sqrt }}')), 2.)
        self.assertAlmostEqual(float(render('{{ 180|radians }}')), math.pi)
    
    def test_native_debug(self):
        self.assertEqual(render('{% native_debug as debug %}{{ debug.keys|safe }}'), "['function', 'comparison', 'filter', 'block']")
        
    def test_cache(self):
        k = get_cache_key('function', 'date', (), {})
        self.assert_(cache.get(k) is None)
        self.assertEqual(render('{% date %}'), render('{% date %}'))
        self.assert_(isinstance(cache.get(k), datetime.datetime))
    
    def test_split(self):
        from native_tags.nodes import split
        a = 'fetch_user username as "author"'
        b = 'fetch_user "what the fuck" as "author"'
        self.assertEqual(split(a), ['fetch_user', 'username', 'as', 'author'])
        self.assertEqual(split(b), ['fetch_user', 'what the fuck', 'as', 'author'])
        
    def test_fail(self):
        self.assertEqual(render('{% fail %}'), 'woot')
    
    try:
        import hashlib
        def test_sha224_hashlib(self):
            ctx = {'foo':'bar'}
            sha224 = '07daf010de7f7f0d8d76a76eb8d1eb40182c8d1e7a3877a6686c9bf0'
            self.assertEqual(render('{{ foo|sha224 }}{% sha224 foo %}', ctx), sha224*2)
    except ImportError:
        pass
    
    try:
        import pygments
        def test_highlight_style(self):
            t = '<style>{% highlight_style style=native cssclass=srcdiv %}</style>'
            self.assert_(render(t).startswith('<style>.srcdiv .hll { background-color: #404040 }'))
    
        def test_highlight(self):
            t = '{% highlight src python cssclass=srcdiv %}'
            self.assertEqual(render(t,{'src':'print "hello world"'}),
                '<div class="srcdiv"><pre><span class="k">print</span> <span class="s">&quot;hello world&quot;</span>\n</pre></div>\n')
    
        def test_highlight_block(self):
            t = "{% highlight_block python as source %}import this{% endhighlight_block %}{{ source|safe }}"
            self.assertEqual(render(t),'<div class="highlight"><pre><span class="kn">import</span> <span class="nn">this</span>\n</pre></div>\n')
    except ImportError:
        pass
    
    try:
        import GChartWrapper
        def test_gchart(self):
            t = '''{% gchart bvg data encoding=text instance=true as chart %}
                scale 0 59
                color lime red blue
                legend Goucher Truman Kansas
                fill c lg 45 cccccc 0 black 1
                fill bg s cccccc
                size 200 100
                title mytittle
                axes.type x
                axes.label label2
            {% endgchart %}{{ chart.checksum }}'''
            self.assertEqual(
                render(t, {'data':[[31],[59],[4]]}),
                '77f733ad30d44411b5b5fcac7e5848b5d5f2dd04')
    except ImportError:
        pass
    
    
    try:
        import feedparser
        def test_parse_feed(self):
            t = '{% load cache %}{% cache 3600 ljworld %}{% parse_feed "http://www2.ljworld.com/rss/headlines/" as ljworld_feed %}{{ ljworld_feed.keys|safe }}{% endcache %}'
            l = set(eval(render(t), {}, {}))
            self.assertEqual(len(l - set(['feed', 'status', 'version', 'encoding', 'bozo', 'headers', 'etag', 'href', 'namespaces', 'entries'])), 0)
    
        def test_include_feed(self):
            self.assertEqual(render('{% load cache %}{% cache 3600 ljworld2 %}{% include_feed "http://www2.ljworld.com/rss/headlines/" 10 feeds.html %}{% endcache %}'), '10 10')
    except ImportError:
        pass
    
    # To test this next one:
    #   get markdown (pip install markdown)
    #   add 'django.contrib.markup' to your INSTALLED_APPS
    try:
        import markdown
        def test_markdown(self):
            t = "{{ src|markdown }}"
            self.assertEqual(render(t, {'src':'`i`'}), '<p><code>i</code></p>')
    except ImportError:
        pass
    
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys

sys.path.insert(0, './externals')
sys.path.insert(0, './apps')

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import sys, os

# Quick hack to put native_tags from the parent directory into pythonpath
sys.path.append(
    os.path.abspath(
        os.path.normpath('%s/../' % os.path.dirname(__file__))
    )
)

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASE_ENGINE = 'sqlite3'           # 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
DATABASE_NAME = 'test.db'             # Or path to database file if using sqlite3.
DATABASE_USER = ''             # Not used with sqlite3.
DATABASE_PASSWORD = ''         # Not used with sqlite3.
DATABASE_HOST = ''             # Set to empty string for localhost. Not used with sqlite3.
DATABASE_PORT = ''             # Set to empty string for default. Not used with sqlite3.

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/New_York'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = False

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = 'media'

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/admin/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'wlk%thwka5=lfl(d7qfb((u7j=$!(%h-!(ci6tte)y=b1&evtb'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'django.template.loaders.app_directories.load_template_source',
#     'django.template.loaders.eggs.load_template_source',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware',
)

ROOT_URLCONF = 'example_project.urls'

TEMPLATE_DIRS = (
    'templates',
)

CACHE_BACKEND = 'locmem://'

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.flatpages',
    'django.contrib.humanize',
    'native_tags',
    'app',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.core.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.media",
    "django.core.context_processors.request",
)


NATIVE_TAGS = (
    # Extra native contrib tags to test
    'native_tags.contrib.comparison',
    'native_tags.contrib.context',
    'native_tags.contrib.generic_content',
    'native_tags.contrib.generic_markup',
    'native_tags.contrib.hash',
    'native_tags.contrib.serializers',
    'native_tags.contrib.baseencode',
    'native_tags.contrib.regex',
    'native_tags.contrib.mapreduce',    
    'native_tags.contrib.cal',
    'native_tags.contrib.math_',
    'native_tags.contrib.rand',
        
    # Native tags with dependencies
    'native_tags.contrib.gchart', # GChartWrapper
    'native_tags.contrib.pygmentize', # Pygments
    'native_tags.contrib.feeds', # Feedparser
)

DJANGO_BUILTIN_TAGS = (
    'native_tags.templatetags.native',
    'django.contrib.markup.templatetags.markup',
)

MARKUP_FILTER = ('markdown', { 'safe_mode': True })

try:
    import markdown
    INSTALLED_APPS += ('django.contrib.markup',)
except ImportError:
    pass

try:
    import django_coverage
    TEST_RUNNER = 'django_coverage.coverage_runner.run_tests'
except ImportError:
    pass
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.conf import settings


from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
   (r'^admin/(.*)', admin.site.root),
   (r'^(?P<path>.*)$', 'django.views.static.serve',{'document_root':settings.MEDIA_ROOT}),
)

########NEW FILE########
__FILENAME__ = baseencode
import base64
from native_tags.decorators import function, filter
from hashlib import sha1

def codectag(encoding, codec=True):
    codec = 'b%d%s' % (encoding, codec and 'encode' or 'decode')
    def inner(s, *args, **kwargs):
        return getattr(base64, codec)(s, *args, **kwargs)
    inner.__name__ = codec 
    inner.__doc__ = getattr(base64, codec).__doc__ + """

Syntax::
    
    {%% %s [string] [options] %%}
    """ % codec
    return filter(function(inner))

enc,dec = '1','31'
b16encode = codectag(16)
b16encode.test = {'args':(enc,),'result':dec}
b16decode = codectag(16,False)
b16decode.test = {'args':(dec,),'result':enc}
    
enc,dec = 'z','PI======'
b32encode = codectag(32)
b32encode.test = {'args':(enc,),'result':dec}
b32decode = codectag(32,False)
b32decode.test = {'args':(dec,),'result':enc}
    
enc,dec = 'z','eg=='
b64encode = codectag(64)
b64encode.test = {'args':(enc,),'result':dec}
b64decode = codectag(64,False)
b64decode.test = {'args':(dec,),'result':enc}

########NEW FILE########
__FILENAME__ = cal
from calendar import HTMLCalendar
from native_tags.decorators import function

def calendar(format, *args, **kwargs):
    """
    Creates a formatted ``HTMLCalendar``. 
    Argument ``format`` can be one of ``month``, ``year``, or ``yearpage``
    Keyword arguments are collected and passed into ``HTMLCalendar.formatmonth``, 
    ``HTMLCalendar.formatyear``, and ``HTMLCalendar.formatyearpage``
    
        Syntax::
            
            {% calendar month [year] [month] %}
            {% calendar year [year] %}
            {% calendar yearpage [year] %}
            
        Example::
        
            {% calendr month 2009 10 %}
    """
    cal = HTMLCalendar(kwargs.pop('firstweekday', 0))
    return getattr(cal, 'format%s' % format)(*args, **kwargs)
calendar = function(calendar)


########NEW FILE########
__FILENAME__ = comparison
"""
Comparison tags
"""
try:
    set
except NameError:
    from sets import Set as set
from django.conf import settings
from native_tags.decorators import comparison

def less(x,y):
    'True if x is less than y'
    return x < y
less = comparison(less, test={'args':(0,1)})

def less_or_equal(x,y):
    'True if x is less than or equal to y'
    return x <= y
less_or_equal = comparison(less_or_equal, test={'args':(1,1)})

def greater_or_equal(x,y):
    'True if x is greater than or equal to y'
    return x >= y
greater_or_equal = comparison(greater_or_equal, test={'args':(2,1)})

def greater(x,y):
    'True if x is greater than y'
    return x > y
greater = comparison(greater, test={'args':(2,1)})
    
def startswith(x,y):
    'String comparison. True if x startswith y'
    return x.startswith(y)
startswith = comparison(startswith, test={'args':('wtf','w')})

def endswith(x,y):
    'String comparison. True if x endswith y'
    return x.endswith(y)
endswith = comparison(endswith, test={'args':('wtf','f')})

def contains(x,y):
    'String comparison. True if x contains y anywhere'
    return x.find(y) > -1
contains = comparison(contains, test={'args':('wtf','t')})

def subset(x,y):
    'Set comparison. True if x is a subset of y'
    return set(x) <= set(y)
subset = comparison(subset, test={'args':([2],[1,2])})

def superset(x,y):
    'Set comparison. True if x is a superset of y'
    return set(x) >= set(y)
superset = comparison(superset, test={'args':([1,2],[2])})

def divisible_by(x,y):
    'Numeric comparison. True if x is divisible by y'
    return float(x) % float(y) == 0
divisible_by = comparison(divisible_by, test={'args':(15,5)})

def setting(x):
    'True if setting x is defined in your settings'
    return hasattr(settings, x)
setting = comparison(setting, test={'args':('DEBUG',)})


########NEW FILE########
__FILENAME__ = context
from native_tags.decorators import function, block, filter
from django.template import Template, Context


def document(o):
    'Returns the docstring for a given object'
    try:
        return o.__doc__ or ''
    except AttributeError:
        return ''
document = filter(function(document))

def do_set(context, **kwargs):
    'Updates the context with the keyword arguments'
    context.update(kwargs)
    return ''
do_set = function(do_set, takes_context=1, name='set')


def do_del(context, *args):
    'Deletes template variables from the context'
    for name in args:
        del context[name]
    return ''
do_del = function(do_del, resolve=0, takes_context=1, name='del')


def render_block(context, nodelist):
    'Simply renders the nodelist with the current context'
    return nodelist.render(context)
render_block = block(render_block)


def template_string(context, template):
    'Return the rendered template content with the current context'
    if not isinstance(context, Context):
        context = Context(context)
    return Template(template).render(context)
template_string = function(template_string, takes_context=1)
template_string.test = {'args':({'var':'T'},'W {{ var }} F'),'result':'W T F'}

def template_block(context, nodelist):
    'Return the rendered block\'s content with the current context'
    return Template(nodelist.render(context)).render(context)
template_block = block(template_block)

def native_debug():
    from native_tags.registry import register
    return register
native_debug = function(native_debug)
########NEW FILE########
__FILENAME__ = feeds
"""
Tags which can retrieve and parse RSS and Atom feeds, and return the
results for use in templates.

Based, in part, on the original idea by user baumer1122 and posted to
djangosnippets at http://www.djangosnippets.org/snippets/311/

"""

import datetime
import feedparser
from django.template import TemplateSyntaxError
from native_tags.decorators import function


def include_feed(feed_url, *args):
    """
    Parse an RSS or Atom feed and render a given number of its items
    into HTML.
    
    It is **highly** recommended that you use `Django's template
    fragment caching`_ to cache the output of this tag for a
    reasonable amount of time (e.g., one hour); polling a feed too
    often is impolite, wastes bandwidth and may lead to the feed
    provider banning your IP address.
    
    .. _Django's template fragment caching: http://www.djangoproject.com/documentation/cache/#template-fragment-caching
    
    Arguments should be:
    
    1. The URL of the feed to parse.
    
    2. The name of a template to use for rendering the results into HTML.

    3. The number of items to render (if not supplied, renders all
       items in the feed).
           
    The template used to render the results will receive two variables:
    
    ``items``
        A list of dictionaries representing feed items, each with
        'title', 'summary', 'link' and 'date' members.
    
    ``feed``
        The feed itself, for pulling out arbitrary attributes.
    
    Requires the Universal Feed Parser, which can be obtained at
    http://feedparser.org/. See `its documentation`_ for details of the
    parsed feed object.
    
    .. _its documentation: http://feedparser.org/docs/
    
    Syntax::
    
        {% include_feed [feed_url] [num_items] [template_name] %}
    
    Example::
    
        {% include_feed "http://www2.ljworld.com/rss/headlines/" 10 feed_includes/ljworld_headlines.html %}
    
    """
    feed = feedparser.parse(feed_url)
    items = []
    
    if len(args) == 2:
        # num_items, template_name
        num_items, template_name = args
    elif len(args) == 1:
        # template_name
        num_items, template_name = None, args[0]
    else:
        raise TemplateSyntaxError("'include_feed' tag takes either two or three arguments")
        
    num_items = int(num_items) or len(feed['entries'])
    for i in range(num_items):
        pub_date = feed['entries'][i].updated_parsed
        published = datetime.date(pub_date[0], pub_date[1], pub_date[2])
        items.append({ 'title': feed['entries'][i].title,
                       'summary': feed['entries'][i].summary,
                       'link': feed['entries'][i].link,
                       'date': published })
    return template_name, { 'items': items, 'feed': feed }
include_feed = function(include_feed, inclusion=True)

def parse_feed(feed_url):
    """
    Parses a given feed and returns the result in a given context
    variable.
    
    It is **highly** recommended that you use `Django's template
    fragment caching`_ to cache the output of this tag for a
    reasonable amount of time (e.g., one hour); polling a feed too
    often is impolite, wastes bandwidth and may lead to the feed
    provider banning your IP address.
    
    .. _Django's template fragment caching: http://www.djangoproject.com/documentation/cache/#template-fragment-caching
    
    Arguments should be:
    
    1. The URL of the feed to parse.
    
    Requires the Universal Feed Parser, which can be obtained at
    http://feedparser.org/. See `its documentation`_ for details of the
    parsed feed object.
    
    .. _its documentation: http://feedparser.org/docs/
    
    Syntax::
    
        {% parse_feed [feed_url] as [varname] %}
    
    Example::
    
        {% parse_feed "http://www2.ljworld.com/rss/headlines/" as ljworld_feed %}
    
    """
    return feedparser.parse(feed_url)
parse_feed = function(parse_feed)


########NEW FILE########
__FILENAME__ = gchart
from django.template import VariableNode, TextNode
from GChartWrapper import GChart

from native_tags.decorators import block


CMDS = ('title','axes.type','axes.label','type','encoding','fill','color','scale','legend')

def parse_cmd(value):
    value = value.lstrip()
    for cmd in CMDS:
        if value.startswith(cmd):
            return cmd,value[len(cmd):].strip()
    return None, None

def gchart(context, nodelist, type, dataset, **kwargs):
    G = GChart(type, dataset, encoding=kwargs.pop('encoding','text'))
    for node in nodelist:
        if isinstance(node, TextNode):
            for part in node.render(context).splitlines():
                cmd,value = parse_cmd(part)
                if cmd is None: continue
                if cmd.startswith('axes'):
                    cmd = getattr(G.axes, cmd[5:])
                else:
                    cmd = getattr(G, cmd)
                cmd(*value.split())
    if 'instance' in kwargs:
        return G
    return G.img(**kwargs)
gchart = block(gchart)

########NEW FILE########
__FILENAME__ = generic_content
"""
Template tags which can do retrieval of content from any model.

"""

from django.db.models import get_model
from django.template import TemplateSyntaxError
from native_tags.decorators import function


def _get_model(model):
    m = get_model(*model.split('.'))
    if m is None:
        raise TemplateSyntaxError("Generic content tag got invalid model: %s" % model)
    return m

def get_latest_object(model, field=None):
    """
    Retrieves the latest object from a given model, in that model's
    default ordering, and stores it in a context variable.
    The optional field argument specifies which field to get_latest_by, otherwise the model's default is used
    
    Syntax::
    
        {% get_latest_object [app_name].[model_name] [field] as [varname] %}
    
    Example::
    
        {% get_latest_object comments.freecomment submitted_date as latest_comment %}
    
    """
    return _get_model(model)._default_manager.latest(field)
get_latest_object = function(get_latest_object)    


def get_latest_objects(model, num, field='?'):
    """
    Retrieves the latest ``num`` objects from a given model, in that
    model's default ordering, and stores them in a context variable.
    The optional field argument specifies which field to get_latest_by, otherwise the model's default is used
    
    Syntax::
    
        {% get_latest_objects [app_name].[model_name] [num] [field] as [varname] %}
    
    Example::
    
        {% get_latest_objects comments.freecomment 5 submitted_date as latest_comments %}
    
    """
    model = _get_model(model)
    if field == '?':
        field = model._meta.get_latest_by and '-%s' % model._meta.get_latest_by or field
    return model._default_manager.order_by(field)[:int(num)]
get_latest_objects = function(get_latest_objects)

def get_random_object(model):
    """
    Retrieves a random object from a given model, and stores it in a
    context variable.
    
    Syntax::
    
        {% get_random_object [app_name].[model_name] as [varname] %}
    
    Example::
    
        {% get_random_object comments.freecomment as random_comment %}
    
    """
    try:
        return _get_model(model)._default_manager.order_by('?')[0]
    except IndexError:
        return ''
get_random_object = function(get_random_object)

def get_random_objects(model, num):
    """
    Retrieves ``num`` random objects from a given model, and stores
    them in a context variable.
    
    Syntax::
    
        {% get_random_objects [app_name].[model_name] [num] as [varname] %}
    
    Example::
    
        {% get_random_objects comments.freecomment 5 as random_comments %}
    
    """
    return _get_model(model)._default_manager.order_by('?')[:int(num)]
get_random_objects = function(get_random_objects)

def retrieve_object(model, *args, **kwargs):
    """
    Retrieves a specific object from a given model by primary-key
    lookup, and stores it in a context variable.
    
    Syntax::
    
        {% retrieve_object [app_name].[model_name] [lookup kwargs] as [varname] %}
    
    Example::
    
        {% retrieve_object flatpages.flatpage pk=12 as my_flat_page %}
    
    """
    if len(args) == 1:
        kwargs.update({'pk': args[0]})
    _model = _get_model(model)
    try:
        return _model._default_manager.get(**kwargs)
    except _model.DoesNotExist:
        return ''
retrieve_object = function(retrieve_object)

########NEW FILE########
__FILENAME__ = generic_markup
"""
Filters for converting plain text to HTML and enhancing the
typographic appeal of text on the Web.

"""
from django.conf import settings
from django.template import TemplateSyntaxError

from native_tags.decorators import filter
from _markup import formatter

def apply_markup(value, arg=None):
    """
    Applies text-to-HTML conversion.
    
    Takes an optional argument to specify the name of a filter to use.
    
    """
    if arg is not None:
        return formatter(value, filter_name=arg)
    return formatter(value)
apply_markup = filter(apply_markup, is_safe=True)
apply_markup.test = {'args':('wtf',),'result':'<p>wtf</p>'}

def smartypants(value):
    """
    Applies SmartyPants to a piece of text, applying typographic
    niceties.
    
    Requires the Python SmartyPants library to be installed; see
    http://web.chad.org/projects/smartypants.py/
    
    """
    try:
        from smartypants import smartyPants
    except ImportError:
        if settings.DEBUG:
            raise TemplateSyntaxError("Error in smartypants filter: the Python smartypants module is not installed or could not be imported")
        return value
    else:
        return smartyPants(value)
smartypants = filter(smartypants, is_safe=True)

########NEW FILE########
__FILENAME__ = hash
from django.utils.hashcompat import md5_constructor, sha_constructor
from native_tags.decorators import function, filter

def hexd(algo, value):
    lookup = {
        'md5': md5_constructor,
        'sha1': sha_constructor,
        'sha': sha_constructor,
    }
    try:
        import hashlib
        lookup.update({
            'sha224': hashlib.sha224,
            'sha256': hashlib.sha256,
            'sha384': hashlib.sha384,
            'sha512': hashlib.sha512,
        })
    except ImportError:
        pass
    try:
        return lookup[algo](value).hexdigest()
    except IndexError:
        return ''

def hashtag(algo, lib=False):
    def inner(value):
        return hexd(algo, value)
    return filter(function(inner),
        doc='Returns %s hexadecimal hash of the value. %s' % \
            (algo.upper(), lib and 'Requires the :mod:`hashlib` module' or ''),
        name=algo, test={'args':('wtf',),'result':hexd(algo, 'wtf')})
    
md5 = hashtag('md5')
sha1 = hashtag('sha1')
sha224 = hashtag('sha224',True)
sha256 = hashtag('sha256',True)
sha384 = hashtag('sha384',True)
sha512 = hashtag('sha512',True)

########NEW FILE########
__FILENAME__ = mapreduce
from native_tags.decorators import function

def get_func(func_name, op=True):
    import operator
    from native_tags.registry import register
    try:
        return register['function'][func_name]
    except KeyError:
        pass
    if func_name in __builtins__:
        return __builtins__[func_name]
    elif hasattr(operator, func_name):
        return getattr(operator, func_name)
    return lambda: None
    
def do_map(func_name, *sequence):
    """
    Return a list of the results of applying the function to the items of
    the argument sequence(s).  
    
    Functions may be registered with ``native_tags`` 
    or can be ``builtins`` or from the ``operator`` module
    
    If more than one sequence is given, the
    function is called with an argument list consisting of the corresponding
    item of each sequence, substituting None for missing values when not all
    sequences have the same length.  If the function is None, return a list of
    the items of the sequence (or a list of tuples if more than one sequence).

    Syntax::
    
        {% map [function] [sequence] %}        
        {% map [function] [item1 item2 ...] %}

    For example::
    
        {% map sha1 hello world %}
        
    calculates::
        
        [sha1(hello), sha1(world)]

    """

    if len(sequence)==1:
        sequence = sequence[0]
    return map(get_func(func_name, False), sequence)
do_map = function(do_map, name='map')
do_map.test = {'args':('ord','wtf'),'result':[119, 116, 102]}

def do_reduce(func_name, *sequence):
    """
    Apply a function of two arguments cumulatively to the items of a sequence,
    from left to right, so as to reduce the sequence to a single value.
    
    Functions may be registered with ``native_tags`` 
    or can be ``builtins`` or from the ``operator`` module
    
    Syntax::
    
        {% reduce [function] [sequence] %}        
        {% reduce [function] [item1 item2 ...] %}
    
    For example::
    
        {% reduce add 1 2 3 4 5 %}
        
    calculates::
    
        ((((1+2)+3)+4)+5) = 15
    """
    if len(sequence)==1:
        sequence = sequence[0]
    return reduce(get_func(func_name), sequence)
do_reduce = function(do_reduce, name='reduce')
do_reduce.test = {'args':('add',1,2,3,4,5),'result':15}

########NEW FILE########
__FILENAME__ = math_
import math

from native_tags.decorators import function, filter, comparison

def func_factory(method):
    try:
        func = getattr(math, method)
    except AttributeError:
        return
    def inner(arg1, arg2=None):
        try:
            return func(arg1, arg2)
        except TypeError:
            return func(arg1)
    inner.__name__ = method
    doc = func.__doc__.splitlines()
    if len(doc) > 1 and not doc[1]:
        doc = doc[2:]
    inner.__doc__ = '\n'.join(doc)
    if method.startswith('is'):
        return comparison(inner)
    return filter(function(inner))


acos = func_factory('acos')
acosh = func_factory('acosh')
asin = func_factory('asin')
asinh = func_factory('asinh')
atan = func_factory('atan')
atan2 = func_factory('atan2')
atanh = func_factory('atanh')
ceil = func_factory('ceil')
copysign = func_factory('copysign')
cos = func_factory('cos')
cosh = func_factory('cosh')
degrees = func_factory('degrees')
exp = func_factory('exp')
fabs = func_factory('fabs')
factorial = func_factory('factorial')
floor = func_factory('floor')
fmod = func_factory('fmod')
frexp = func_factory('frexp')
fsum = func_factory('fsum')
hypot = func_factory('hypot')
isinf = func_factory('isinf')
isnan = func_factory('isnan')
ldexp = func_factory('ldexp')
log = func_factory('log')
log10 = func_factory('log10')
log1p = func_factory('log1p')
modf = func_factory('modf')
pow = func_factory('pow')
radians = func_factory('radians')
sin = func_factory('sin')
sinh = func_factory('sinh')
sqrt = func_factory('sqrt')
tan = func_factory('tan')
tanh = func_factory('tanh')
trunc = func_factory('trunc')

########NEW FILE########
__FILENAME__ = op
import operator
from native_tags.decorators import comparison, function

# Comparison operators

def lt(a, b):
    return operator.lt(a, b)
lt = comparison(lt, doc=operator.lt.__doc__)
    
def le(a, b):
    return operator.le(a, b)
le = comparison(le, doc=operator.le.__doc__)
    
def eq(a, b):
    return operator.eq(a, b)
eq = comparison(eq, doc=operator.eq.__doc__)
    
def ne(a, b):
    return operator.ne(a, b)
ne = comparison(ne, doc=operator.ne.__doc__)
    
def ge(a, b):
    return operator.ge(a, b)
ge = comparison(ge, doc=operator.ge.__doc__)
    
def gt(a, b):
    return operator.gt(a, b)
gt = comparison(gt, doc=operator.gt.__doc__)

def not_(a):
    return operator.not_(a)
not_ = comparison(not_, name='not', doc=operator.not_.__doc__)

def is_(a):
    return operator.is_(a)
is_ = comparison(is_, name='is', doc=operator.is_.__doc__)

def is_not(a):
    return operator.is_not(a)
is_not = comparison(is_not, doc=operator.is_not.__doc__)

# Mathematical and bitwise operators

def abs(a):
    return operator.abs(a)
abs = function(comparison(abs), doc=operator.abs.__doc__)

def add(a, b):
    return operator.add(a, b)
add = function(add, doc=operator.add.__doc__)
    
def and_(a, b):
    return operator.and_(a, b)
and_ = function(comparison(and_, name='and'), doc=operator.and_.__doc__)

def div(a, b):
    return operator.div(a, b)
div = function(comparison(div), doc=operator.div.__doc__)
    
def floordiv(a, b):
    return operator.floordiv(a, b)
floordiv = function(comparison(floordiv), doc=operator.floordiv.__doc__)

def index(a):
    return operator.index(a)
index = function(comparison(index), doc=operator.index.__doc__)

def inv(a):
    return operator.inv(a)
inv = function(comparison(inv), doc=operator.inv.__doc__)
    
def lshift(a, b):
    return operator.lshift(a, b)
lshift = function(comparison(lshift), doc=operator.lshift.__doc__)
    
def mod(a, b):
    return operator.mod(a, b)
mod = function(comparison(mod), doc=operator.mod.__doc__)
    
def mul(a, b):
    return operator.mul(a, b)
mul = function(comparison(mul), doc=operator.mul.__doc__)
    
def neg(a):
    return operator.neg(a)
neg = function(comparison(neg), doc=operator.neg.__doc__)
    
def or_(a, b):
    return operator.or_(a, b)
or_ = function(comparison(or_), doc=operator.or_.__doc__)
    
def pos(a):
    return operator.pos(a)
pos = function(comparison(pos), doc=operator.pos.__doc__)
    
def pow(a, b):
    return operator.pow(a, b)
pow = function(comparison(pow), doc=operator.pow.__doc__)
    
def rshift(a, b):
    return operator.rshift(a, b)
rshift = function(comparison(rshift), doc=operator.rshift.__doc__)
    
def sub(a, b):
    return operator.sub(a, b)
sub = function(comparison(sub), doc=operator.sub.__doc__)
    
def truediv(a, b):
    return operator.truediv(a, b)
truediv = function(comparison(truediv), doc=operator.truediv.__doc__)
    
def xor(a, b):
    return operator.xor(a, b)
xor = function(comparison(xor), doc=operator.xor.__doc__)
    
# Sequence operators
    
def concat(a, b):
    return operator.concat(a, b)
concat = function(concat, doc=operator.concat.__doc__)

def contains(a, b):
    return operator.contains(a, b)
contains = function(contains, doc=operator.contains.__doc__)
    
def countOf(a, b):
    return operator.countOf(a, b)
countOf = function(countOf, doc=operator.countOf.__doc__)
    
def delitem(a, b):
    return operator.delitem(a, b)
delitem = function(delitem, doc=operator.delitem.__doc__)
    
def delslice(a, b, c):
    return operator.delslice(a, b, c)
delslice = function(delslice, doc=operator.delslice.__doc__)
    
def getitem(a, b):
    return operator.getitem(a, b)
getitem = function(getitem, doc=operator.getitem.__doc__)
    
def getslice(a, b, c):
    return operator.getslice(a, b, c)
getslice = function(getslice, doc=operator.getslice.__doc__)
    
def indexOf(a, b):
    return operator.indexOf(a, b)
indexOf = function(indexOf, doc=operator.indexOf.__doc__)
    
def repeat(a, b):
    return operator.repeat(a, b)
repeat = function(repeat, doc=operator.repeat.__doc__)
    
def setitem(a, b, c):
    return operator.setitem(a, b, c)
setitem = function(setitem, doc=operator.setitem.__doc__)
    
def setslice(a, b, c, v):
    return operator.setslice(a, b, c, v)
setslice = function(setslice, doc=operator.setslice.__doc__)

########NEW FILE########
__FILENAME__ = pygmentize
try:
    from pygments.formatters import HtmlFormatter
    from pygments.lexers import get_lexer_by_name
    from pygments import highlight as highlighter
except ImportError:
    highlighter = None

from native_tags.decorators import function, block

def highlight_style(cssclass='highlight', **kwargs):
    """
    Returns the CSS from the ``HtmlFormatter``.
    ``cssclass`` is the name of the ``div`` css class to use

        Syntax::

            {% highlight_style [cssclass] [formatter options] %}

        Example::

            {% highlight_style code linenos=true %}
    """
    if highlighter is None:
        return ''
    return HtmlFormatter(**kwargs).get_style_defs('.%s' % cssclass)
highlight_style = function(highlight_style)

def highlight(code, lexer, **kwargs):
    """
    Returns highlighted code ``div`` tag from ``HtmlFormatter``
    Lexer is guessed by ``lexer`` name
    arguments are passed into the formatter

        Syntax::

            {% highlight [source code] [lexer name] [formatter options] %}

        Example::

            {% highlight 'print "Hello World"' python linenos=true %}
    """
    if highlighter is None:
        return '<pre>%s</pre>' % code
    return highlighter(code or '', get_lexer_by_name(lexer), HtmlFormatter(**kwargs))
highlight = function(highlight, is_safe=True)

def highlight_block(context, nodelist, lexer, **kwargs):
    """
    Code is nodelist ``rendered`` in ``context``
    Returns highlighted code ``div`` tag from ``HtmlFormatter``
    Lexer is guessed by ``lexer`` name
    arguments are passed into the formatter

        Syntax::

            {% highlight_block [lexer name] [formatter options] %}
                ... source code ..
            {% endhighlight_block %}

        Example::

            {% highlight_block python linenos=true %}
                print '{{ request.path }}'
            {% endhighlight_block %}
    """
    if highlighter is None:
        return '<pre>%s</pre>' % str(nodelist.render(context) or '')
    return highlighter(nodelist.render(context) or '', get_lexer_by_name(lexer), HtmlFormatter(**kwargs))
highlight_block = block(highlight_block, is_safe=True)

########NEW FILE########
__FILENAME__ = rand
import random as _random
from native_tags.decorators import function

def randrange(*args,**kwargs):
    if len(args)==1:
        args = (0,args[0])
    return _random.randrange(*args,**kwargs)
randrange = function(randrange)
randrange.__doc__ = _random.randrange.__doc__ + """

    Syntax::
        
        {% randrange [stop] [options] %}
        {% randrange [start] [stop] [step] [options] %}
"""

def randint(a, b):
    return _random.randint(a, b)
randint = function(randint)
randint.__doc__ = _random.randint.__doc__ + """

    Syntax::
        
        {% randint [a] [b] %}
"""

def randchoice(*seq):
    if len(seq)==1:
        seq = seq[0]
    return _random.choice(seq)
randchoice = function(randchoice)
randchoice.__doc__ = _random.choice.__doc__ + """

    Syntax::
        
        {% randchoice [sequence] %}
        {% randchoice [choice1 choice2 ...] %}
"""

def random():
    return _random.random()
random = function(random)
random.__doc__ = _random.random.__doc__ + """

    Syntax::
        
        {% random %}
"""


########NEW FILE########
__FILENAME__ = regex
import re

from native_tags.decorators import comparison, function


def matches(pattern, text):
    'String comparison. True if string ``text`` matches regex ``pattern``'
    return re.compile(str(pattern)).match(text)
matches = comparison(matches)
matches.test = {'args':('\d','_'),'result':None}

def substitute(search, replace, text):
    'Regex substitution function. Replaces regex ``search`` with ``replace`` in ``text``'
    return re.sub(re.compile(str(search)), replace, text)
substitute = function(substitute)
substitute.test = {'args':('w','f','wtf'),'result':'ftf'}

def search(pattern, text):
    'Regex pattern search. Returns match if ``pattern`` is found in ``text``'
    return re.compile(str(pattern)).search(str(text))
search = function(search)
search.test = {'args':('\d','asdfasdfwe'),'result':None}

########NEW FILE########
__FILENAME__ = serializers
from django.core.serializers import serialize
    

serialize.function = 1

def serialize_json(queryset): return serialize('json', queryset)
serialize_json.function = 1

def serialize_xml(queryset): return serialize('xml', queryset)
serialize_xml.function = 1

def serialize_python(queryset): return serialize('python', queryset)
serialize_python.function = 1

def serialize_yaml(queryset): return serialize('yaml', queryset)
serialize_yaml.function = 1


########NEW FILE########
__FILENAME__ = _django
"""Default tags used by the template system, available to all templates."""

import sys
import re
from itertools import cycle as itertools_cycle
try:
    reversed
except NameError:
    from django.utils.itercompat import reversed     # Python 2.3 fallback

from django.template import Node, NodeList, Template, Context, Variable
from django.template import TemplateSyntaxError, VariableDoesNotExist, BLOCK_TAG_START, BLOCK_TAG_END, VARIABLE_TAG_START, VARIABLE_TAG_END, SINGLE_BRACE_START, SINGLE_BRACE_END, COMMENT_TAG_START, COMMENT_TAG_END
from django.template import get_library, Library, InvalidTemplateLibrary
from django.conf import settings
from django.utils.encoding import smart_str, smart_unicode
from django.utils.itercompat import groupby
from django.utils.safestring import mark_safe

def autoescape(context, nodelist, setting):
    """
    Force autoescape behaviour for this block.
    """
    old_setting = context.autoescape
    context.autoescape = setting
    output = nodelist.render(context)
    context.autoescape = old_setting
    if setting:
        return mark_safe(output)
    else:
        return output
autoescape.block = 1

def comment(context, nodelist):
    """
    Ignores everything between ``{% comment %}`` and ``{% endcomment %}``.
    """
    return ''
comment.block = 1

def cycle(context, *cyclevars):
    """
    Cycles among the given strings each time this tag is encountered.

    Within a loop, cycles among the given strings each time through
    the loop::

        {% for o in some_list %}
            <tr class="{% cycle 'row1' 'row2' %}">
                ...
            </tr>
        {% endfor %}

    Outside of a loop, give the values a unique name the first time you call
    it, then use that name each sucessive time through::

            <tr class="{% cycle 'row1' 'row2' 'row3' as rowcolors %}">...</tr>
            <tr class="{% cycle rowcolors %}">...</tr>
            <tr class="{% cycle rowcolors %}">...</tr>

    You can use any number of values, separated by spaces. Commas can also
    be used to separate values; if a comma is used, the cycle values are
    interpreted as literal strings.
    """

    return itertools_cycle(cyclevars).next()
cycle.function = 1

def debug(context):
    """
    Outputs a whole load of debugging information, including the current
    context and imported modules.

    Sample usage::

        <pre>
            {% debug %}
        </pre>
    """

    from pprint import pformat
    output = [pformat(val) for val in context]
    output.append('\n\n')
    output.append(pformat(sys.modules))
    return ''.join(output)
debug.function = 1

def filter(context, nodelist, filter_exp):
    """
    Filters the contents of the block through variable filters.

    Filters can also be piped through each other, and they can have
    arguments -- just like in variable syntax.

    Sample usage::

        {% filter force_escape|lower %}
            This text will be HTML-escaped, and will appear in lowercase.
        {% endfilter %}
    """
    output = nodelist.render(context)
    # Apply filters.
    context.update({'var': output})
    filtered = filter_expr.resolve(context)
    context.pop()
    return filtered
filter.block = 1

def firstof(*vars):
    """
    Outputs the first variable passed that is not False, without escaping.

    Outputs nothing if all the passed variables are False.

    Sample usage::

        {% firstof var1 var2 var3 %}

    This is equivalent to::

        {% if var1 %}
            {{ var1|safe }}
        {% else %}{% if var2 %}
            {{ var2|safe }}
        {% else %}{% if var3 %}
            {{ var3|safe }}
        {% endif %}{% endif %}{% endif %}

    but obviously much cleaner!

    You can also use a literal string as a fallback value in case all
    passed variables are False::

        {% firstof var1 var2 var3 "fallback value" %}

    If you want to escape the output, use a filter tag::

        {% filter force_escape %}
            {% firstof var1 var2 var3 "fallback value" %}
        {% endfilter %}

    """
    for var in vars:
        if var:
            return var
firstof.function = 1

def regroup(target, expression):
    """
    Regroups a list of alike objects by a common attribute.

    This complex tag is best illustrated by use of an example:  say that
    ``people`` is a list of ``Person`` objects that have ``first_name``,
    ``last_name``, and ``gender`` attributes, and you'd like to display a list
    that looks like:

        * Male:
            * George Bush
            * Bill Clinton
        * Female:
            * Margaret Thatcher
            * Colendeeza Rice
        * Unknown:
            * Pat Smith

    The following snippet of template code would accomplish this dubious task::

        {% regroup people by gender as grouped %}
        <ul>
        {% for group in grouped %}
            <li>{{ group.grouper }}
            <ul>
                {% for item in group.list %}
                <li>{{ item }}</li>
                {% endfor %}
            </ul>
        {% endfor %}
        </ul>

    As you can see, ``{% regroup %}`` populates a variable with a list of
    objects with ``grouper`` and ``list`` attributes.  ``grouper`` contains the
    item that was grouped by; ``list`` contains the list of objects that share
    that ``grouper``.  In this case, ``grouper`` would be ``Male``, ``Female``
    and ``Unknown``, and ``list`` is the list of people with those genders.

    Note that ``{% regroup %}`` does not work when the list to be grouped is not
    sorted by the key you are grouping by!  This means that if your list of
    people was not sorted by gender, you'd need to make sure it is sorted
    before using it, i.e.::

        {% regroup people|dictsort:"gender" by gender as grouped %}

    """
    if not target: return ''
    return [
        # List of dictionaries in the format:
        # {'grouper': 'key', 'list': [list of contents]}.
        {'grouper': key, 'list': list(val)}
        for key, val in
        groupby(obj_list, lambda v, f=expression.resolve: f(v, True))
    ]
regroup.function = 1

def now(format_string):
    """
    Displays the date, formatted according to the given string.

    Uses the same format as PHP's ``date()`` function; see http://php.net/date
    for all the possible values.

    Sample usage::

        It is {% now "jS F Y H:i" %}
    """
    from datetime import datetime
    from django.utils.dateformat import DateFormat
    return DateFormat(datetime.now()).format(self.format_string)
now.function = 1

def spaceless(context, nodelists):
    """
    Removes whitespace between HTML tags, including tab and newline characters.

    Example usage::

        {% spaceless %}
            <p>
                <a href="foo/">Foo</a>
            </p>
        {% endspaceless %}

    This example would return this HTML::

        <p><a href="foo/">Foo</a></p>

    Only space between *tags* is normalized -- not space between tags and text.
    In this example, the space around ``Hello`` won't be stripped::

        {% spaceless %}
            <strong>
                Hello
            </strong>
        {% endspaceless %}
    """

    from django.utils.html import strip_spaces_between_tags
    return strip_spaces_between_tags(nodelist.render(context).strip())
spaceless.block = 1

def widthratio(value, maxvalue, max_width):
    """
    For creating bar charts and such, this tag calculates the ratio of a given
    value to a maximum value, and then applies that ratio to a constant.

    For example::

        <img src='bar.gif' height='10' width='{% widthratio this_value max_value 100 %}' />

    Above, if ``this_value`` is 175 and ``max_value`` is 200, the image in
    the above example will be 88 pixels wide (because 175/200 = .875;
    .875 * 100 = 87.5 which is rounded up to 88).
    """
    try:
        max_width = int(max_width)
    except ValueError:
        raise TemplateSyntaxError("widthratio final argument must be an number")
    try:
        value = float(value)
        maxvalue = float(maxvalue)
        ratio = (value / maxvalue) * max_width
    except (ValueError, ZeroDivisionError):
        return ''
    return str(int(round(ratio)))
widthratio.function = 1

def with_(context, nodelist, val):
    """
    Adds a value to the context (inside of this block) for caching and easy
    access.

    For example::

        {% with person.some_sql_method as total %}
            {{ total }} object{{ total|pluralize }}
        {% endwith %}
    """
    context.push()
    context[self.name] = val
    output = nodelist.render(context)
    context.pop()
    return output
with_.block = 1

########NEW FILE########
__FILENAME__ = _markup
"""
Utilities for text-to-HTML conversion.

"""


def textile(text, **kwargs):
    """
    Applies Textile conversion to a string, and returns the HTML.
    
    This is simply a pass-through to the ``textile`` template filter
    included in ``django.contrib.markup``, which works around issues
    PyTextile has with Unicode strings. If you're not using Django but
    want to use Textile with ``MarkupFormatter``, you'll need to
    supply your own Textile filter.
    
    """
    from django.contrib.markup.templatetags.markup import textile
    return textile(text)

def markdown(text, **kwargs):
    """
    Applies Markdown conversion to a string, and returns the HTML.
    
    """
    import markdown
    return markdown.markdown(text, **kwargs)

def restructuredtext(text, **kwargs):
    """
    Applies reStructuredText conversion to a string, and returns the
    HTML.
    
    """
    from docutils import core
    parts = core.publish_parts(source=text,
                               writer_name='html4css1',
                               **kwargs)
    return parts['fragment']

DEFAULT_MARKUP_FILTERS = {
    'textile': textile,
    'markdown': markdown,
    'restructuredtext': restructuredtext
    }


class MarkupFormatter(object):
    """
    Generic markup formatter which can handle multiple text-to-HTML
    conversion systems.

    
    Overview
    ========
    
    Conversion is handled by filter functions registered with an
    instance; a set of default filters is provided which cover
    Markdown, reStructuredText and Textile (though using one of these
    requires the appropriate module to be available on your system --
    e.g., using the reST filter requires you to have ``docutils``
    installed).
    
    New filters can be added by registering them with an instance;
    simply define a function which performs the conversion you want,
    and use the ``register`` method to add it; ``register`` expects
    two arguments:
    
    1. The name to associate with the filter.
    
    2. The actual filter function.
    
    So, for example, you might define a new filter function called
    ``my_filter``, and register it like so::
    
        formatter = MarkupFormatter()
        formatter.register('my_filter', my_filter)
    
    Instances are callable, so applying the conversion to a string is
    simple::
    
        my_html = formatter(my_string, filter_name='my_filter')
    
    The filter to use for conversion is determined in either of two
    ways:
    
    1. If the keyword argument ``filter_name`` is supplied, it will be
       used as the filter name.
    
    2. Absent an explicit argument, the filter name will be taken from
       the ``MARKUP_FILTER`` setting in your Django settings file (see
       below).
    
    Additionally, arbitrary keyword arguments can be supplied, and
    they will be passed on to the filter function.
    
    
    Reading default bahavior from a Django setting
    ==============================================
    
    The Django setting ``MARKUP_FILTER`` can be used to specify
    default behavior; if used, its value should be a 2-tuple:
    
    * The first element should be the name of a filter.
    
    * The second element should be a dictionary to use as keyword
      arguments for that filter.
    
    So, for example, to have the default behavior apply Markdown with
    safe mode enabled, you would add this to your Django settings
    file::
    
        MARKUP_FILTER = ('markdown', { 'safe_mode': True })
    
    The filter named in this setting does not have to be from the
    default set; as long as you register a filter of that name before
    trying to use the formatter, it will work.
    
    To have the default behavior apply no conversion whatsoever, set
    ``MARKUP_FILTER`` like so::
    
        MARKUP_FILTER = (None, {})
    
    When the ``filter_name`` keyword argument is supplied, the
    ``MARKUP_FILTER`` setting is ignored entirely -- neither a filter
    name nor any keyword arguments will be read from it. This means
    that, by always supplying ``filter_name`` explicitly, it is
    possible to use this formatter without configuring or even
    installing Django.


    Django and template autoescaping
    ================================

    Django's template system defaults to escaping the output of
    template variables, which can interfere with functions intended to
    return HTML. ``MarkupFormatter`` does not in any way tamper with
    Django's autoescaping, so pasing the results of formatting
    directly to a Django template will result in that text being
    escaped.

    If you need to use ``MarkupFormatter`` for items which will be
    passed to a Django template as variables, use the function
    ``django.utils.safestring.mark_safe`` to tell Django's template
    system not to escape that text.
    
    For convenience, a Django template filter is included (in
    ``templatetags/generic_markup.py``) which applies
    ``MarkupFormatter`` to a string and marks the result as not
    requiring autoescaping.
    
    
    Examples
    ========
    
    Using the default behavior, with the filter name and arguments
    taken from the ``MARKUP_FILTER`` setting::
    
        formatter = MarkupFormatter()
        my_string = 'Lorem ipsum dolor sit amet.\n\nConsectetuer adipiscing elit.'
        my_html = formatter(my_string)
    
    Explicitly naming the filter to use::
    
        my_html = formatter(my_string, filter_name='markdown')
    
    Passing keyword arguments::
    
        my_html = formatter(my_string, filter_name='markdown', safe_mode=True)
    
    Perform no conversion (return the text as-is)::
    
        my_html = formatter(my_string, filter_name=None)
    
    """
    def __init__(self):
        self._filters = {}
        for filter_name, filter_func in DEFAULT_MARKUP_FILTERS.items():
            self.register(filter_name, filter_func)
    
    def register(self, filter_name, filter_func):
        """
        Registers a new filter for use.
        
        """
        self._filters[filter_name] = filter_func
    
    def __call__(self, text, **kwargs):
        """
        Applies text-to-HTML conversion to a string, and returns the
        HTML.
        
        """
        if 'filter_name' in kwargs:
            filter_name = kwargs['filter_name']
            del kwargs['filter_name']
            filter_kwargs = {}
        else:
            from django.conf import settings
            filter_name, filter_kwargs = settings.MARKUP_FILTER
        if filter_name is None:
            return text
        if filter_name not in self._filters:
            raise ValueError("'%s' is not a registered markup filter. Registered filters are: %s." % (filter_name,
                                                                                                       ', '.join(self._filters.iterkeys())))
        filter_func = self._filters[filter_name]
        filter_kwargs.update(**kwargs)
        return filter_func(text, **filter_kwargs)


# Unless you need to have multiple instances of MarkupFormatter lying
# around, or want to subclass it, the easiest way to use it is to
# import this instance.

formatter = MarkupFormatter()

########NEW FILE########
__FILENAME__ = decorators
import settings

def tag(bucket, doc):
    def wrapped(inner, **options):
        options[bucket] = 1
        if 'name' in options:
            inner.__name__ = inner.name = options.pop('name')
        if 'doc' in options:
            inner.__doc__ = inner.doc = options.pop('doc')
        for i in options.items():
            setattr(inner, *i)
        inner.__doc__ = inner.doc = '%s\n%s' % (inner.__doc__, ''.join([
            'This is a :ref:`%s tag<%s-tags>`. ' % (tag, tag)
            for tag in settings.TAG_TYPES
            if hasattr(inner, tag) and
              str(inner.__doc__).find('This is a :ref:`%s' % tag)==-1]))
        return inner
    wrapped.__doc__ = doc
    return wrapped

block = tag('block', """
Block tag function decorator

Syntax::

    @block([**options])
    def my_tag_function(context, nodelist, [*vars], [**tag_options]):
        return nodelist.render(context)
""")
comparison = tag('comparison',"""
Comparison tag function decorator

Syntax::

    @comparison([**options]):
    def my_comparison([*vars], [**tag_options]):
        return True
""")
comparison.__doc__
filter = tag('filter',"""
Filter tag function decorator

Syntax::

    @filter([**options]):
    def my_filter(value, arg):
        return value
""")
function = tag('function',"""
Function tag function decorator

Syntax::

    @function([**options]):
    def my_function([*args], [**kwargs]):
        return args, kwargs
""")

########NEW FILE########
__FILENAME__ = nativelib
from django.core.management.base import BaseCommand
from native_tags.registry import register

class Command(BaseCommand):
    def usage(self, exe):
        return '%s [bucket1 ...]\n\nLists registered tags for the given buckets if any' % exe
    
    def handle(self, *buckets, **kwargs):
        for bucket,items in register.items():
            if len(buckets) and not bucket in buckets:
                continue
            print bucket.title()
            items = [(x,y.__module__) for x,y in items.items()]
            items.sort(lambda x,y: cmp(x[1],y[1]))
            for name,mod in items:
                print '\t%s.%s' % (mod,name)

########NEW FILE########
__FILENAME__ = models
import settings

if 'native_tags.templatetags.native' in settings.BUILTIN_TAGS:
    from django.template import add_to_builtins
    add_to_builtins('native_tags.templatetags.native')

########NEW FILE########
__FILENAME__ = nodes
import re
from shlex import split as lexsplit
from django import template
from django.template import Context, Variable, VariableDoesNotExist
from django.template.loader import get_template
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from django.utils.hashcompat import sha_constructor
from django.core.cache import cache
from registry import register
from settings import DEFAULT_CACHE_TIMEOUT

class Constant(unicode):
    """Just a placeholder unicode constant so you can tell
    which variables failed lookup and should be considered constant.
    You can tell by using ``isinstance(var_or_constant, Constant)``"""
    pass

def split(s):
    """
    Split a string into a list, respecting any quoted strings inside
    Uses ``shelx.split`` which has a bad habbit of inserting null bytes where they are not wanted
    """
    return map(lambda w: filter(lambda c: c != '\x00', w), lexsplit(s))

def lookup(parser, var, context, resolve=True, apply_filters=True):
    """
    Try to resolve the varialbe in a context
    If ``resolve`` is ``False``, only string variables are returned
    """
    if resolve:
        try:
            return Variable(var).resolve(context)
        except VariableDoesNotExist:
            if apply_filters and var.find('|') > -1:
                return parser.compile_filter(var).resolve(context)
            return Constant(var)
        except TypeError:
            # already resolved
            return var
    return var

def get_cache_key(bucket, name, args, kwargs):
    """
    Gets a unique SHA1 cache key for any call to a native tag.
    Use args and kwargs in hash so that the same arguments use the same key
    """
    u = ''.join(map(str, (bucket, name, args, kwargs)))
    return 'native_tags.%s' % sha_constructor(u).hexdigest()
    
def get_signature(token, contextable=False, comparison=False):
    """
    Gets the signature tuple for any native tag
    contextable searchs for ``as`` variable to update context
    comparison if true uses ``negate`` (p) to ``not`` the result (~p)
    returns (``tag_name``, ``args``, ``kwargs``)
    """
    bits = split(token.contents)
    args, kwargs = (), {}
    if comparison and bits[-1] == 'negate':
        kwargs['negate'] = True
        bits = bits[:-1]
    if contextable and len(bits) > 2 and bits[-2] == 'as':
        kwargs['varname'] = bits[-1]
        bits = bits[:-2]
    kwarg_re = re.compile(r'^([-\w]+)\=(.*)$')
    for bit in bits[1:]:
        match = kwarg_re.match(bit)
        if match:
            kwargs[str(match.group(1))] = force_unicode(match.group(2))
        else:
            args += (bit,)
    return bits[0], args, kwargs


class NativeNode(template.Node):
    bucket = None
    def __init__(self, parser, name, *args, **kwargs):
        self.parser = parser
        self.func = register[self.bucket][name]
        self.name = name
        self.args = args
        self.kwargs = kwargs

    def get_args(self, context, resolve=True, apply_filters=True):
        args = (lookup(self.parser, var, context, resolve, apply_filters) for var in self.args)
        if hasattr(self.func, 'takes_context') and getattr(self.func, 'takes_context'):
            args = (context,) + tuple(args)
        if hasattr(self.func, 'takes_request') and getattr(self.func, 'takes_request'):
            try:
                args = (context['request'],) + tuple(args)
            except KeyError:
                raise KeyError('Request not found in context. Make sure "django.core.context_processors.request" is in your TEMPLATE_CONTEXT_PROCESSORS setting')
        return args

    def get_kwargs(self, context, resolve=True, apply_filters=True):
        d = dict(((k, lookup(self.parser, var, context, resolve)) for k, var in self.kwargs.items() if k != 'varname'))
        if 'varname' in self.kwargs:
            d['varname'] = self.kwargs['varname']
        return d

    def render(self, context):
        resolve = getattr(self.func, 'resolve', True)
        apply_filters = getattr(self.func, 'apply_filters', True)
        args = self.get_args(context, resolve, apply_filters)
        kwargs = self.get_kwargs(context, resolve, apply_filters)
        varname = kwargs.pop('varname', None)

        def _get_result():
            try:
                result = self.get_result(context, *args, **kwargs)
            except NotImplementedError:
                raise
            except:
                if hasattr(self.func, 'fallback'):
                    result = self.func.fallback
                else:
                    raise
            if hasattr(self.func, 'is_safe') and getattr(self.func, 'is_safe'):
                return mark_safe(result)
            return result
        
        if not DEFAULT_CACHE_TIMEOUT is None and not hasattr(self.func, 'cache'):
            setattr(self.func, 'cache', DEFAULT_CACHE_TIMEOUT)

        if hasattr(self.func, 'cache'):
            key = get_cache_key(self.bucket, self.name, self.args, self.kwargs)
            result = cache.get(key)
            if result is None:
                result = _get_result()
                cache.set(key, result, getattr(self.func, 'cache'))
        else:
            result = _get_result()

        if varname:
            context[varname] = result
            return ''
        
        return result
    
    def get_result(self, context):
        raise NotImplementedError

class ComparisonNode(NativeNode):
    bucket = 'comparison'
    def get_result(self, context, *args, **kwargs):
        nodelist_false = kwargs.pop('nodelist_false')
        nodelist_true = kwargs.pop('nodelist_true')
        negate = kwargs.pop('negate', False)
        
        try:
            truth_value = self.func(*args, **kwargs)
        except TypeError:
            # If the types don't permit comparison, return nothing.
            return ''

        if truth_value and negate:
            return nodelist_false.render(context)
        elif truth_value:
            return nodelist_true.render(context)
        elif negate:
            return nodelist_true.render(context)
        else:
            return nodelist_false.render(context)

def do_comparison(parser, token):
    """
    Compares passed arguments. 
    Attached functions should return boolean ``True`` or ``False``.
    If the attached function returns ``True``, the first node list is rendered.
    If the attached function returns ``False``, the second optional node list is rendered (part after the ``{% else %}`` statement). 
    If the last argument in the tag is ``negate``, then the opposite node list is rendered (like an ``ifnot`` tag).
    
    Syntax::

        {% if_[comparison] [var args...] [name=value kwargs...] [negate] %}
            {# first node list in here #}
        {% else %}
            {# second optional node list in here #}
        {% endif_[comparison] %}


    Supported comparisons are ``match``, ``find``, ``startswith``, ``endswith``,
    ``less``, ``less_or_equal``, ``greater`` and ``greater_or_equal`` and many more.
    Checkout the :ref:`contrib-index` for more examples

    Examples::

        {% if_less some_object.id 3 %}
        {{ some_object }} has an id less than 3.
        {% endif_less %}

        {% if_match request.path '^/$' %}
        Welcome home
        {% endif_match %}

    """
    name, args, kwargs = get_signature(token, comparison=True)
    name = name.replace('if_if', 'if')
    end_tag = 'end' + name
    kwargs['nodelist_true'] = parser.parse(('else', end_tag))
    token = parser.next_token()
    if token.contents == 'else':
        kwargs['nodelist_false'] = parser.parse((end_tag,))
        parser.delete_first_token()
    else:
        kwargs['nodelist_false'] = template.NodeList()
    if name.startswith('if_'):
        name = name.split('if_')[1]
    return ComparisonNode(parser, name, *args, **kwargs)

class FunctionNode(NativeNode):
    bucket = 'function'
    def get_result(self, context, *args, **kwargs):
        result = self.func(*args, **kwargs)
        if hasattr(self.func, 'inclusion') and getattr(self.func, 'inclusion'):
            template_name, ctx = result
            if not isinstance(ctx, Context):
                ctx = Context(ctx)
            return get_template(template_name).render(ctx)
        return result

def do_function(parser, token):
    """
    Performs a defined function on the passed arguments.
    Normally this returns the output of the function into the template.
    If the second to last argument is ``as``, the result of the function is stored in the context and is named whatever the last argument is.

    Syntax::

        {% [function] [var args...] [name=value kwargs...] [as varname] %}

    Examples::

        {% search '^(\d{3})$' 800 as match %}

        {% map sha1 hello world %}

    """
    name, args, kwargs = get_signature(token, True, True)
    return FunctionNode(parser, name, *args, **kwargs)

class BlockNode(NativeNode):
    bucket = 'block'
    def get_result(self, context, *args, **kwargs):
        nodelist = kwargs.pop('nodelist', ())
        return self.func(context, nodelist, *args, **kwargs)

def do_block(parser, token):
    """
    Process several nodes inside a single block
    Block functions take ``context``, ``nodelist`` as first arguments
    If the second to last argument is ``as``, the rendered result is stored in the context and is named whatever the last argument is.

    Syntax::

        {% [block] [var args...] [name=value kwargs...] [as varname] %}
            ... nodelist ...
        {% end[block] %}

    Examples::

        {% render_block as rendered_output %}
            {{ request.path }}/blog/{{ blog.slug }}
        {% endrender_block %}

        {% highlight_block python %}
            import this
        {% endhighlight_block %}

    """
    name, args, kwargs = get_signature(token, contextable=True)
    kwargs['nodelist'] = parser.parse(('end%s' % name,))
    parser.delete_first_token()
    return BlockNode(parser, name, *args, **kwargs)

########NEW FILE########
__FILENAME__ = registry
from os import listdir
from sys import stderr
from django.conf import settings as djsettings
from django.template import add_to_builtins
from django.utils.importlib import import_module
from django.utils.importlib import import_module

import settings


class AlreadyRegistered(Exception):
    "The function you are trying to register is already in the registry"
    pass

class NotRegistered(Exception):
    "The function you are trying to unregister is not in the registry"
    pass

class Library(dict):
    """
    A simple dictionary with register and unregister functions
    """
    def __init__(self):
        super(Library, self).__init__([(tag, {}) for tag in settings.TAG_TYPES])
        self.update([i for i in settings.LIBRARY.items() if i[0] in settings.TAG_TYPES])

        
        # Comb through installed apps w/ templatetags looking for native tags
        for app in djsettings.INSTALLED_APPS :
            if app == 'native_tags':
                continue
            try:
                mod = import_module('.templatetags', app)
            except ImportError, e:
                continue
        
            # TODO: Make this hurt less
            for f in listdir(mod.__path__[0]):
                if f.endswith('.py') and not f.startswith('__'):
                    n = f.split('.py')[0]
                    e = self.load_module('%s.templatetags.%s' % (app, n))
                    if e is not None:# and settings.DEBUG:
                        print >>stderr, 'Warning: Failed to load module "%s.templatetags.%s": %s' % (app, n, e)
        
        # Load up the native contrib tags
        for tag_module in settings.TAGS:
            e = self.load_module(tag_module)
            if e is not None:# and djsettings.DEBUG:
                print >>stderr, 'Warning: Failed to load module "%s": %s' % (tag_module, e)
        
        # Add the BUILTIN_TAGS to Django's builtins
        for mod in settings.BUILTIN_TAGS:
            # if it tries to add iself in here it blows up really badly
            # this part is done in models.py
            if mod != 'native_tags.templatetags.native':
                add_to_builtins(mod)

    def load_module(self, module):
        """
        Load a module string like django.contrib.markup.templatetags.markup into the registry
        Iterates through the module looking for callables w/ attributes matching Native Tags
        """
        if isinstance(module, basestring) and module.find('.') > -1:
            a = module.split('.')
            module = ('.%s' % a[-1], '.'.join(a[:-1]))
        try:
            module = import_module(*module)
        except Exception, e:
            return e
        
        for name in dir(module):
            if name.startswith('_'): continue
            obj = getattr(module, name)
            if callable(obj):
                for tag in settings.TAG_TYPES:
                    if hasattr(obj, tag) and getattr(obj, tag) in (1, True):
                        name = getattr(obj, 'name', obj.__name__)
                        if name in self[tag]:
                            continue
                        if hasattr(obj, 'name'):
                            self.register(tag, getattr(obj, 'name'), obj)
                        else:
                            self.register(tag, obj)

    def register(self, bucket, name_or_func, func=None):
        """
        Add a function to the registry by name
        """
        assert bucket in self, 'Bucket %s is unknown' % bucket
        if func is None and hasattr(name_or_func, '__name__'):
            name = name_or_func.__name__
            func = name_or_func
        elif func:
            name = name_or_func
        if name in self[bucket]:
            raise AlreadyRegistered('The function %s is already registered' % name)

        self[bucket][name] = func

    def unregister(self, bucket, name):
        """
        Remove the function from the registry by name
        """
        assert bucket in self, 'Bucket %s is unknown' % bucket
        if not name in self[bucket]:
            raise NotRegistered('The function %s is not registered' % name)
        del self[bucket][name]

    def function(self, *a, **kw):
        self.register('function', *a, **kw)

    def comparison(self, *a, **kw):
        self.register('comparison', *a, **kw)

    def filter(self, *a, **kw):
        self.register('filter', *a, **kw)

    def block(self, *a, **kw):
        self.register('block', *a, **kw)

    def get_doc(self, tag_name):
        "Get documentation for the first tag matching the given name"
        for tag,func in self.tags:
            if tag.startswith(tag_name) and func.__doc__:
                return func.__doc__

    def get_bucket(self, name):
        "Find out which bucket a given tag name is in"
        for bucket in self:
            for k,v in self[bucket].items():
                if k == name:
                    return bucket

    def get(self, name):
        "Get the first tag function matching the given name"
        for bucket in self:
            for k,v in self[bucket].items():
                if k == name:
                    return v
                
    def tags(self):
        "Iterate over all tags yielding (name, function)"
        for bucket in self:
            for k,v in self[bucket].items():
                yield k,v
    tags = property(tags)

    def __len__(self):
        return reduce(lambda x,y: x+y, map(len, self.values()))

register = Library()

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

TAG_TYPES = ('function', 'comparison', 'filter', 'block')

LIBRARY = getattr(settings, 'NATIVE_LIBRARY', {})

TAGS = getattr(settings, 'NATIVE_TAGS', (
    'native_tags.contrib.comparison',
    'native_tags.contrib.generic_content',
    'native_tags.contrib.generic_markup',
    'native_tags.contrib.feeds', # Feedparser
))

BUILTIN_TAGS = getattr(settings, 'DJANGO_BUILTIN_TAGS', ())

DEFAULT_CACHE_TIMEOUT = getattr(settings, 'NATIVE_DEFAULT_CACHE_TIMEOUT', None)
########NEW FILE########
__FILENAME__ = native
from django.template import Library

from native_tags.nodes import do_function, do_comparison, do_block
from native_tags.registry import register as native_register


register = Library()

for tag_name in native_register['comparison']:
    if not tag_name.startswith('if'):
        tag_name = 'if_%s' % tag_name 
    register.tags[tag_name] = do_comparison
    
for tag_name in native_register['function']:
    register.tags[tag_name] = do_function

for tag_name in native_register['block']:
    register.tags[tag_name] = do_block

register.filters.update(native_register['filter'])
########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from native_tags.registry import register


def tester(f):
    def inner(unit):
        args, kwargs = f.test.get('args', ()), f.test.get('kwargs', {})
        result = len(kwargs) and f(*args, **kwargs) or f(*args)
        unit.assertEquals(result, f.test.get('result', True))
    return inner

attrs = {}

for bucket,items in register.items():
    for name,func in items.items():
        if hasattr(func, 'test'):
            attrs['test_%s' % name] = tester(func)

NativeTagTests = type('NativeTagTests', (TestCase,), attrs)
       
########NEW FILE########
