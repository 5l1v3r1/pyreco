__FILENAME__ = add_bonding
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
import fcntl
import string
import copy
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command, \
        get_ifconfig_info, is_writable, create_file, \
        copy_file,         move_file,   get_bridge_info, \
        comma_split
    from karesansui.lib.dict_op import DictOp
    from karesansui.lib.parser.ifcfg import ifcfgParser
    from karesansui.lib.parser.modprobe_conf import modprobe_confParser
    from karesansui.lib.const import BONDING_MODE, BONDING_CONFIG_MII_DEFAULT, \
        VENDOR_DATA_BONDING_EVACUATION_DIR, NETWORK_IFCFG_DIR, NETWORK_COMMAND, \
        NETWORK_IFDOWN_COMMAND,             NETWORK_BRCTL_COMMAND

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-d', '--dev', dest='dev', help=_('Bonding Target Device Name'), default=None)
    optp.add_option('-m', '--mode', dest='mode', help=_('Bonding Mode'), default="1")
    optp.add_option('-p', '--primary', dest='primary', help=_('Primary Device Name'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9,]")

    if opts.dev:
        if reg.search(opts.dev):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-d or --dev', opts.dev))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-d or --dev')

    if opts.primary:
        if reg.search(opts.primary):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --primary', opts.primary))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --primary')

    if opts.mode not in BONDING_MODE:
        raise KssCommandOptException('ERROR: Unknown bonding mode "%s".' % opts.mode)

class AddBonding(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        dev_list = comma_split(opts.dev)
        if len(dev_list) < 2:
            # TRANSLATORS:
            #    bondingするためのdeviceが少ないです
            raise KssCommandOptException('ERROR: Small device for bonding. - dev=%s' % (opts.dev))

        interface_list = get_ifconfig_info()
        for dev in dev_list:
            if dev not in interface_list:
                raise KssCommandOptException('ERROR: Bonding target device not found. - dev=%s' % (dev))

        if opts.primary not in dev_list:
            raise KssCommandOptException('ERROR: Primary device not found in bonding device. - primary=%s dev=%s' % (opts.primary, opts.dev))

        exist_bond_max_num = -1
        exist_bond_list = get_ifconfig_info("regex:^bond")
        for bond_name in exist_bond_list.keys():
            try:
                num = int(bond_name.replace("bond",""))
            except ValueError:
                continue

            if exist_bond_max_num < num:
                exist_bond_max_num = num

        self.up_progress(10)
        physical_bond_name = "bond%s" % (exist_bond_max_num + 1)
        bridge_bond_name = "bondbr%s" % (exist_bond_max_num + 1)
        bond_options = '"mode=%s primary=%s miimon=%s"' % (opts.mode, opts.primary, BONDING_CONFIG_MII_DEFAULT)
        self.up_progress(10)

        dop = DictOp()
        ifcfg_parser = ifcfgParser()
        modprobe_parser = modprobe_confParser()

        dop.addconf("ifcfg", ifcfg_parser.read_conf())
        if dop.getconf("ifcfg") == {}:
            raise KssCommandException('Failure read network config file.')

        dop.addconf("modprobe_conf", modprobe_parser.read_conf())
        if dop.getconf("modprobe_conf") == {}:
            raise KssCommandException('Failure read modprobe config file.')

        self.up_progress(10)
        eth_conf_copykey = ["HWADDR",
                            "BOOTPROTO",
                            "ONBOOT",
                            "USERCTL",
                            ]
        bond_conf_nocopykey = ["TYPE",
                               "HWADDR",
                               "MACADDR",
                               "ETHTOOL_OPTS",
                               "ESSID",
                               "CHANNEL",
                               ]

        self.up_progress(10)
        for dev in dev_list:
            conf = dop.get("ifcfg", dev)
            if dev == opts.primary:
                primary_conf = copy.deepcopy(conf)

            dop.unset("ifcfg", dev)
            dop.set("ifcfg", [dev, "DEVICE"], conf["DEVICE"]["value"])
            for key in eth_conf_copykey:
                if key in conf:
                    dop.set("ifcfg", [dev, key], conf[key]["value"])
            dop.set("ifcfg", [dev, "MASTER"], physical_bond_name)
            dop.set("ifcfg", [dev, "SLAVE"], "yes")
            dop.set("ifcfg", [dev, "BOOTPROTO"], "none")

            if dop.get("ifcfg", "p%s" % (dev)):
                hwaddr = dop.get("ifcfg", ["p%s" % (dev), "HWADDR"])
                if hwaddr:
                    dop.set("ifcfg", [dev, "HWADDR"], hwaddr)
                dop.unset("ifcfg", "p%s" % (dev))

        for key in bond_conf_nocopykey:
            if key in primary_conf:
                del primary_conf[key]

        dop.set("ifcfg", bridge_bond_name, primary_conf)
        dop.set("ifcfg", [bridge_bond_name, "DEVICE"], bridge_bond_name)
        dop.set("ifcfg", [bridge_bond_name, "TYPE"], "Bridge")

        dop.set("ifcfg", [physical_bond_name, "DEVICE"], physical_bond_name)
        dop.set("ifcfg", [physical_bond_name, "BRIDGE"], bridge_bond_name)
        dop.set("ifcfg", [physical_bond_name, "BOOTPROTO"], "none")
        dop.set("ifcfg", [physical_bond_name, "ONBOOT"], dop.get("ifcfg", [bridge_bond_name, "ONBOOT"]))
        dop.set("ifcfg", [physical_bond_name, "BONDING_OPTS"], bond_options)

        self.up_progress(10)
        dop.set("modprobe_conf", ["alias", physical_bond_name], "bonding")

        for dev in dev_list:
            if os.path.isfile("%s/ifcfg-%s" % (NETWORK_IFCFG_DIR, dev)):
                copy_file("%s/ifcfg-%s" % (NETWORK_IFCFG_DIR, dev), VENDOR_DATA_BONDING_EVACUATION_DIR)
            if os.path.isfile("%s/ifcfg-p%s" % (NETWORK_IFCFG_DIR, dev)):
                move_file("%s/ifcfg-p%s" % (NETWORK_IFCFG_DIR, dev), VENDOR_DATA_BONDING_EVACUATION_DIR)

        if ifcfg_parser.write_conf(dop.getconf("ifcfg")) is False:
            raise KssCommandException('Failure write network config file.')

        if modprobe_parser.write_conf(dop.getconf("modprobe_conf")) is False:
            raise KssCommandException('Failure write modprobe config file.')

        self.up_progress(10)
        #
        # Delete bridge device
        #
        bridge_list = get_bridge_info()
        for dev in dev_list:
            if dev in bridge_list:
                ifdown_cmd = (NETWORK_IFDOWN_COMMAND,
                              dev,
                              )
                (ifdown_rc, ifdown_res) = execute_command(ifdown_cmd)
                if ifdown_rc != 0:
                    raise KssCommandException('Failure stop interface. interface:%s' % (dev))

                for brif in bridge_list[dev]:
                    brctl_delif_cmd = (NETWORK_BRCTL_COMMAND,
                                       "delif",
                                       dev,
                                       brif,
                                       )
                    (brctl_rc, brctl_res) = execute_command(brctl_delif_cmd)
                    if brctl_rc != 0:
                        raise KssCommandException('Failure delete bridge port. bridge:%s port:%s' % (dev, brif))

                brctl_delbr_cmd = (NETWORK_BRCTL_COMMAND,
                                   "delbr",
                                   dev,
                                   )
                (brctl_rc, brctl_res) = execute_command(brctl_delbr_cmd)
                if brctl_rc != 0:
                    raise KssCommandException('Failure delete bridge. bridge:%s' % (dev, brif))

        self.up_progress(10)
        #
        # Restart network
        #
        network_restart_cmd = (NETWORK_COMMAND,
                               "restart",
                               )
        (net_rc, net_res) = execute_command(network_restart_cmd)
        if net_rc != 0:
            raise KssCommandException('Failure restart network.')

        self.logger.info("Created bonding device. - dev=%s bond=%s" % (opts.dev, bridge_bond_name))
        print >>sys.stdout, _("Created bonding device. - dev=%s bond=%s" % (opts.dev, bridge_bond_name))

        return True

if __name__ == "__main__":
    target = AddBonding()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = add_disk
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, get_disk_img_info
    from karesansui.lib.const import ISCSI_DEVICE_DIR, DISK_USES

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name',   dest='name',   help=_('Domain Name'),    default=None)
    #optp.add_option('-d', '--disk',   dest='disk',   help=_('Disk image file'), default=None)
    #optp.add_option('-s', '--size',   dest='size',   help=_('Disk size (MB)'), default=None)
    #optp.add_option('-p', '--sparse', dest='sparse', help=_('Sparse file'),    action="store_true")
    #optp.add_option('-t', '--target', dest='target', help=_('Device target'),  default=None)
    optp.add_option('-b', '--bus',    dest='bus',    help=_('Device type'),    default=None)
    #optp.add_option('-f', '--format', dest='format', help=_('Disk format'),    default=None)
    optp.add_option('-t', '--type',   dest='type',   help=_('Storage Type'),   default=None)
    optp.add_option('-p', '--pool',   dest='pool',   help=_('Storage Pool'),   default=None)
    optp.add_option('-v', '--volume', dest='volume', help=_('Storage Volume'), default=None)
    optp.add_option('-f', '--format', dest='format', help=_('Disk Format'),    default=None)
    optp.add_option('-T', '--target', dest='target',
                    help=_('Device name of your drive. example=hda or sda or vda...'))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.pool:
        if reg.search(opts.pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool', opts.pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --pool')

    if opts.volume:
        if reg.search(opts.volume):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-v or --volume', opts.volume))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-v or --volume')

    if opts.type:
        if opts.type.lower() != "iscsi" and opts.type.lower() != "file":
            raise KssCommandOptException('ERROR: %s option is require %s or %s.' % ('-t or --type', 'iscsi', 'file'))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --type')

    if opts.bus:
        if reg.search(opts.bus):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-b or --bus', opts.bus))

    if opts.format:
        if reg.search(opts.format):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-f or --format', opts.format))

    if opts.target:
        if reg.search(opts.target):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-f or --format', opts.target))

class AddDisk(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)
            self.up_progress(10)

            active_storage_pools = conn.list_active_storage_pool()
            if opts.pool not in active_storage_pools:
                raise KssCommandException('Storage pool does not exist. - pool=%s' % opts.name)

            if not conn.get_storage_volume(opts.pool, opts.volume):
                raise KssCommandException('Storage volume does not exist. - pool=%s, volume=%s' % (opts.name, opts.volume))

            self.up_progress(10)
            if opts.type.lower() == 'iscsi':
                real_volume_path = conn.get_storage_volume_iscsi_rpath_bystorage(opts.pool, opts.volume)
                if not real_volume_path:
                    raise KssCommandException('Failure get iSCSI volume real path. - pool=%s, volume=%s' % (opts.name, opts.volume))

                format = None
                disk_type = 'block'

            elif opts.type.lower() == 'file':
                real_volume_path = "%s/%s/%s/%s.img" % \
                                   (conn.get_storage_pool_targetpath(opts.pool),
                                    opts.name,
                                    DISK_USES["DISK"],
                                    opts.volume)
                format = opts.format
                disk_type = 'file'
            else:
                raise KssCommandException('Unknown Storage Type. type=%s' % opts.type)

            if opts.target:
                target = opts.target
            else:
                target = conn.guest.next_disk_target(opts.bus)

            self.up_progress(10)
            already_disks = conn.guest.get_disk_info()
            for already_disk in already_disks:
                if already_disk['type'] == 'file':
                    already_path = already_disk['source']['file']
                elif already_disk['type'] == 'block':
                    already_path = already_disk['source']['dev']
                else:
                    already_path = ''

                if already_path == real_volume_path:
                    raise KssCommandException('Source disk is already used. path=%s' % real_volume_path)

            if opts.format is None:
                format = get_disk_img_info(real_volume_path)['file_format']

            conn.guest.append_disk(real_volume_path,
                                   target,
                                   bus=opts.bus,
                                   disk_type=disk_type,
                                   driver_name=None,
                                   driver_type=format,
                                   )

            self.up_progress(30)
        finally:
            conn.close()

        self.logger.info('Added disk device. - dom=%s target=%s path=%s' \
                         % (opts.name, target, real_volume_path))
        print >>sys.stdout, 'Added disk device. - dom=%s target=%s path=%s' \
              % (opts.name, target, real_volume_path)

        return True

if __name__ == "__main__":
    target = AddDisk()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = add_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
<comment-ja>


 使用方法: add_disk.py [オプション]

  オプション:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -t HOST, --target=HOST
                        ターゲットホスト名
  -a AUTH, --auth=AUTH  認証タイプ
  -u USER, --user=USER  認証ユーザー名
  -p PASSWORD, --password=PASSWORD
                        認証パスワード
  -w PASSWORD_FILE, --password-file=PASSWORD_FILE
                        認証パスワードファイル
  -s, --autostart       自動起動

</comment-ja>
<comment-en>
Attach a new disk device to the domain.

 usage: add_disk.py [options]

  options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -t HOST, --target=HOST
                        Target host name
  -a AUTH, --auth=AUTH  Authentication type
  -u USER, --user=USER  Authentication user name
  -p PASSWORD, --password=PASSWORD
                        Authentication password
  -w PASSWORD_FILE, --password-file=PASSWORD_FILE
                        Authentication password file
  -s, --autostart       Autostart

</comment-en>
"""

import os
import sys
import re
import logging
import fcntl
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command, is_readable
    from karesansui.lib.parser.iscsid import iscsidParser
    from karesansui.lib.dict_op import DictOp
    from karesansui.lib.iscsi import iscsi_parse_node, iscsi_print_format_node
    from karesansui.lib.const import ISCSI_CONFIG_KEY_AUTH_METHOD, ISCSI_CONFIG_KEY_AUTH_USER, \
        ISCSI_CONFIG_KEY_AUTH_PASSWORD, ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, \
        ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE, ISCSI_CONFIG_VALUE_SATRTUP_ON, ISCSI_CONFIG_VALUE_SATRTUP_OFF, \
        ISCSI_CMD, ISCSI_CMD_OPTION_MODE, ISCSI_CMD_OPTION_MODE_DISCOVERY, ISCSI_CMD_OPTION_TYPE, \
        ISCSI_CMD_OPTION_TYPE_SENDTARGETS, ISCSI_CMD_OPTION_PORTAL

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-t', '--target', dest='host', help=_('Target host name'), default=None)
    optp.add_option('-a', '--auth', dest='auth', help=_('Authentication type'), default=None)
    optp.add_option('-u', '--user', dest='user', help=_('Authentication user'), default=None)
    optp.add_option('-p', '--password', dest='password', help=_('Authentication password'), default=None)
    optp.add_option('-w', '--password-file', dest='password_file', help=_('Authentication password file'), default=None)
    optp.add_option('-s', '--autostart', dest='autostart', action="store_true", help=_('Autostart'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.host:
        if reg.search(opts.host):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-t or --target', opts.host))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --target')

    if opts.auth:
        if not opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP and not opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE:
            raise KssCommandOptException('ERROR: %s option is require %s or %s.' % '-a', ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE)
        if opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            if opts.user is None:
                raise KssCommandOptException('ERROR: %s option is required.' % '-u or --user')
            if opts.password is None and opts.password_file is None:
                raise KssCommandOptException('ERROR: %s option is required.' % '-p or --password or -w or --password-file')
            if opts.password_file is not None and not is_readable(opts.password_file):
                raise KssCommandOptException('ERROR: %s is not found.' % opts.password_file)
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-a or --auth')

class AddIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        original_parser = iscsidParser()
        new_parser = iscsidParser()
        dop = DictOp()

        dop.addconf("original", original_parser.read_conf())
        dop.addconf("new", new_parser.read_conf())

        self.up_progress(10)

        dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_METHOD, opts.auth)
        if opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            password = ""
            if opts.password is not None:
                password = opts.password
            elif opts.password_file is not None and is_readable(opts.password_file):
                try:
                    fp = open(opts.password_file, "r")
                    try:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                        try:
                            password = fp.readline().strip("\n")
                        finally:
                            fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)

                        self.up_progress(10)
                    finally:
                        fp.close()

                except:
                    raise KssCommandException('Failed to read file. - target host=%s password_file=%s' \
                                                  % (opts.host,opts.password_file))

                try:
                    os.remove(opts.password_file)
                except:
                    raise KssCommandException('Failed to remove file. - target host=%s password_file=%s' \
                                                  % (opts.host,opts.password_file))

            dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_METHOD, opts.auth)
            dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_USER, opts.user)
            dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_PASSWORD, password)
        else:
            dop.comment("new", ISCSI_CONFIG_KEY_AUTH_USER)
            dop.comment("new", ISCSI_CONFIG_KEY_AUTH_PASSWORD)

        self.up_progress(10)
        if opts.autostart:
            dop.cdp_set("new", ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_ON)
        else:
            dop.cdp_set("new", ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_OFF)

        new_parser.write_conf(dop.getconf("new"))
        self.up_progress(10)

        discovery_command_args = (ISCSI_CMD,
                                  ISCSI_CMD_OPTION_MODE,
                                  ISCSI_CMD_OPTION_MODE_DISCOVERY,
                                  ISCSI_CMD_OPTION_TYPE,
                                  ISCSI_CMD_OPTION_TYPE_SENDTARGETS,
                                  ISCSI_CMD_OPTION_PORTAL,
                                  opts.host
                                  )

        (discovery_rc,discovery_res) = execute_command(discovery_command_args)
        self.up_progress(10)

        original_parser.write_conf(dop.getconf("original"))
        self.up_progress(10)

        if discovery_rc != 0:
            raise KssCommandException('Failed to add iSCSI. - host=%s message=%s' % (opts.host, discovery_res))

        if discovery_res == []:
            raise KssCommandException('Failed to add iSCSI. - host=%s message=No exist permit iSCSI disk for target.' % (opts.host))

        for node_line in discovery_res:
            if not node_line:
                continue

            try:
                node = iscsi_parse_node(node_line)
            except:
                self.logger.warn('Failed to parse iSCSI discovery command response. message="%s"' % (node_line))
                continue

            self.logger.info("%s" % (iscsi_print_format_node(node)))
            print >>sys.stdout, _("%s") % (iscsi_print_format_node(node))

        return True

if __name__ == "__main__":
    target = AddIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = add_nic
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, generate_mac_address
except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-m', '--mac', dest='mac', help=_('MAC Address'), default=None)
    optp.add_option('-b', '--bridge', dest='bridge', help=_('Bridge'), default=None)
    optp.add_option('-w', '--network', dest='network', help=_('Network'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.bridge is None and opts.network is None:
        raise KssCommandOptException('ERROR: either %s options must be specified.' % '--bridge or --network')
    """TOOD valid
    オプションチェック
    """

class AddNIC(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            self.up_progress(10)

            if not opts.mac:
                opts.mac = generate_mac_address()

            conn.guest.append_interface(opts.mac,opts.bridge,opts.network)
            self.up_progress(50)
        finally:
            conn.close()

        self.logger.info('Added interface device. - dom=%s mac=%s bridge=%s network=%s' \
                         % (opts.name, opts.mac, opts.bridge, opts.network))
        print >>sys.stdout, _('Added interface device. - dom=%s mac=%s bridge=%s network=%s') \
              % (opts.name, opts.mac, opts.bridge, opts.network)

        return True

if __name__ == "__main__":
    target = AddNIC()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = append_disk
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-d', '--disk', dest='disk', help=_('Disk Image File'))
    optp.add_option('-t', '--target', dest='target', help=_('Device Target'), default=None)

    optp.add_option('-b', '--bus', dest='bus', help=_('Target Bus'), default=None)
    optp.add_option('-D', '--disk-type', dest='disk_type', help=_('Disk Type'), default=None)
    optp.add_option('-N', '--driver-name', dest='driver_name', help=_('Driver Name'), default=None)
    optp.add_option('-T', '--driver-type', dest='driver_type', help=_('Driver Type'), default=None)
    optp.add_option('-W', '--disk-device', dest='disk_device', help=_('Disk Device'), default="disk")
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')
    if not opts.disk or not os.path.exists(opts.disk):
        raise KssCommandOptException('ERROR: disk image not found.')

class AppendDisk(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            self.up_progress(10)
            if not opts.target:
                opts.target = conn.guest.next_disk_target()

            conn.guest.append_disk(opts.disk, opts.target, bus=opts.bus, disk_type=opts.disk_type, driver_name=opts.driver_name, driver_type=opts.driver_type, disk_device=opts.disk_device)
            self.up_progress(50)
        finally:
            conn.close()

        self.logger.info('Appended disk device. - dom=%s target=%s path=%s' \
                         % (opts.name, opts.target, opts.disk))
        print >>sys.stdout, _('Appended disk device. - dom=%s target=%s path=%s') \
              % (opts.name,opts.target,opts.disk)
        return True

if __name__ == "__main__":
    target = AppendDisk()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = apply_lighttpdconf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, copy_file, remove_file
    from karesansui.lib.const import LIGHTTPD_CONF_TEMP_DIR,\
        LIGHTTPD_PORT_CONFIG, LIGHTTPD_ACCESS_CONFIG, LIGHTTPD_SSL_CONFIG

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    opts = OptionParser(usage=usage, version=__version__)
    opts.add_option('-d', '--dest', dest='dest', help=('copy destination directory'))
    opts.add_option('-p', '--port', dest='tmp_port_conf', help=('port.conf temporary file path'))
    opts.add_option('-s', '--ssl', dest='tmp_ssl_conf', help=('ssl.conf temporary file path'))
    opts.add_option('-a', '--access', dest='tmp_access_conf', help=('access.conf temporary file path'))
    return opts.parse_args()

def chkopts(opts):
    # option check
    if not opts.dest:
        raise KssCommandOptException('ERROR: -d or --dest option is required.')
    elif not opts.tmp_port_conf:
        raise KssCommandOptException('ERROR: -p or --port option is required.')
    elif not opts.tmp_ssl_conf:
        raise KssCommandOptException('ERROR: -s or --ssl option is required.')
    elif not opts.tmp_access_conf:
        raise KssCommandOptException('ERROR: -a or --access option is required.')

    # exist check
    if os.path.isdir(opts.dest) is False:
        raise KssCommandOptException('ERROR: Not directory dest=%s' % opts.dest)
    elif os.path.isfile(opts.tmp_port_conf) is False:
        raise KssCommandOptException('ERROR: Not exist temporary file tmp_port_conf=%s' % opts.tmp_port_conf)
    elif os.path.isfile(opts.tmp_ssl_conf) is False:
        raise KssCommandOptException('ERROR: Not exist temporary file tmp_ssl_conf=%s' % opts.tmp_ssl_conf)
    elif os.path.isfile(opts.tmp_access_conf) is False:
        raise KssCommandOptException('ERROR: Not exist temporary file tmp_access_conf=%s' % opts.tmp_access_conf)

class LighttpdConfigFile(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        opts.dest = opts.dest.rstrip('/')
        self.up_progress(10)

        tmp_configfiles = {
            LIGHTTPD_PORT_CONFIG : opts.tmp_port_conf,
            LIGHTTPD_SSL_CONFIG : opts.tmp_ssl_conf,
            LIGHTTPD_ACCESS_CONFIG : opts.tmp_access_conf
        }
        self.up_progress(10)

        for srcfile in tmp_configfiles.values():
            if os.path.isfile(srcfile) is False:
                raise KssCommandException(
                    'Temporary config file is not found. -path=%s' % srcfile)

        self.up_progress(20)
        try:
            for dest, src in tmp_configfiles.items():
                copy_file(src, opts.dest + '/' + dest)
                remove_file(src)

            self.up_progress(40)
        except:
            raise KssCommandException('Failed to copy config file -src=%s dest=%s' % (src, dest))

        self.logger.info('Applied lighttpd settings.')
        print >>sys.stdout, _('Applied lighttpd settings.')

        return True

if __name__ == "__main__":
    target = LighttpdConfigFile()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = apply_snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-i', '--id', dest='id', help=_('Snapshot serial ID'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')
    if not opts.id:
        raise KssCommandOptException('ERROR: -i or --id option is required.')

class ApplySnapshot(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)


        kvs = KaresansuiVirtSnapshot(readonly=False)
        try:
            self.up_progress(10)
            try:

                domain = kvs.whichDomain(opts.id)
                if len(domain) == 0:
                    msg = _("Snapshot '%s' not found in domain '%s'.") % (opts.id,opts.name,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                if not opts.name in domain:
                    msg = _("Snapshot '%s' not found in domain '%s'.") % (opts.id,opts.name,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                ret = kvs.revertSnapshot(opts.id)
                if ret is False:
                    msg = _("Can't revert to snapshot '%s'.") % (opts.id,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                self.up_progress(50)

                msg = _("Domain snapshot '%s' reverted.") % (opts.id,)
                self.logger.info(msg)
                print >>sys.stdout, msg

            except KssCommandException, e:
                raise KssCommandException(''.join(e.args))

            except Exception, e:
                msg = _("Failed to revert to snapshot '%s'.") % (opts.id,)
                msg += ": detail %s" % ''.join(str(e.args))
                self.logger.error(msg)
                raise KssCommandException(msg)

            self.logger.info('Completed revertion to the snapshot - id=%s,name=%s' % (opts.id, opts.name))
            print >>sys.stdout, _('Completed revertion to the snapshot - id=%s,name=%s' % (opts.id, opts.name))
            return True
        finally:
            kvs.finish()

if __name__ == "__main__":
    target = ApplySnapshot()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = autostart_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import fcntl
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                                         KaresansuiVirtConnectionAuth
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import uri_split, uri_join

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-e', '--enable', dest='enable', action="store_true", help=_('Enable autostart'))
    optp.add_option('-d', '--disable', dest='disable', action="store_true", help=_('Disable autostart'))
    optp.add_option('-c', '--connection', dest='uri', help=_('Connection URI'), default=None)
    optp.add_option('-w', '--passwd-file', dest='passwd_file', help=_('Password File for URI Connection'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.enable is None and opts.disable is None:
        raise KssCommandOptException('ERROR: either %s options must be specified.' % '--enable or --disable')

    if opts.enable is not None and opts.disable is not None:
        raise KssCommandOptException('ERROR: %s options are conflicted.' % '--enable and --disable')

    if opts.passwd_file is not None and not os.path.exists(opts.passwd_file):
        raise KssCommandOptException('ERROR: %s is not found.' % opts.passwd_file)

    if opts.uri is not None:
        if uri_split(opts.uri)["scheme"] is None:
            raise KssCommandOptException('ERROR: uri %s is invalid.' % opts.uri)

class AutostartGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        passwd = None
        if opts.passwd_file is not None and os.path.exists(opts.passwd_file):
            try:
                fp = open(opts.passwd_file, "r")
                try:
                    self.up_progress(10)
                    fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                    try:
                        passwd = fp.readline().strip("\n")
                    finally:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
                    self.up_progress(10)
                finally:
                    fp.close()

            except Exception, e:
                self.logger.error('Failed to read.- dom=%s passwd_file=%s' \
                      % (opts.name,opts.passwd_file))
                print >>sys.stderr,_('Failed to read.- dom=%s passwd_file=%s') \
                      % (opts.name,opts.passwd_file)
                raise e

            os.remove(opts.passwd_file)

        try:
            if passwd is None:
                if opts.uri is None:
                    conn = KaresansuiVirtConnection(readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnection(uri, readonly=False)

            else:
                if opts.uri is None:
                    conn = KaresansuiVirtConnectionAuth(creds=passwd,readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnectionAuth(uri,creds=passwd,readonly=False)

            conn.set_domain_name(opts.name)

            flag = None
            if opts.enable:
                flag = True
            if opts.disable:
                flag = False
            self.up_progress(10)
            ret = conn.autostart_guest(flag)
            self.up_progress(40)

        except Exception, e:

            if flag is True:
                self.logger.error('Failed to configure a domain to be automatically started at boot. - dom=%s' % (opts.name))
                print >>sys.stderr, _('Failed to configure a domain to be automatically started at boot. - dom=%s') % (opts.name)
            else:
                self.logger.error('Failed to configure a domain not to be automatically started at boot. - dom=%s' % (opts.name))
                print >>sys.stderr, _('Failed to configure a domain not to be automatically started at boot. - dom=%s') % (opts.name)

            raise e

        finally:
            if 'conn' in locals():
                conn.close()

        if ret is False:
            raise KssCommandException('Failed to set autostart flag. - dom=%s flag=%s' \
                              % (opts.name,flag))

        self.logger.info('Set autostart flag. - dom=%s flag=%s' \
                         % (opts.name,flag))
        print >>sys.stdout, _('Set autostart flag. - dom=%s flag=%s') \
              % (opts.name,flag)
        return True

if __name__ == "__main__":
    target = AutostartGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = autostart_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-e', '--enable', dest='enable', action="store_true", help=_('Enable autostart'))
    optp.add_option('-d', '--disable', dest='disable', action="store_true", help=_('Disable autostart'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.enable is None and opts.disable is None:
        raise KssCommandOptException('ERROR: either %s options must be specified.' % '--enable or --disable')

    if opts.enable is not None and opts.disable is not None:
        raise KssCommandOptException('ERROR: %s options are conflicted.' % '--enable and --disable')

class AutostartNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.network.set_network_name(opts.name)
            flag = None

            if opts.enable is True:
                flag = True
            elif opts.disable is True:
                flag = False
            else:
                raise KssCommandException('either %s options must be specified.' % '--enable or --disable')

            self.up_progress(10)
            ret = conn.autostart_network(flag)
            if ret is False:
                raise KssCommandException('Failed to set autostart flag. - net=%s flag=%s' % (opts.name,flag))
            self.up_progress(40)

            self.logger.info('Set autostart flag. - net=%s flag=%s' % (opts.name,flag))
            print >>sys.stdout, _('Set autostart flag. - net=%s flag=%s') % (opts.name,flag)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = AutostartNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = autostart_service
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.service.config import ServiceConfigParam
    from karesansui.lib.service.sysvinit_rh import SysVInit_RH
    from karesansui.lib.const import SERVICE_XML_FILE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Service name'), default=None)
    optp.add_option('-e', '--enable', dest='enable', action="store_true", help=_('Enable autostart'), default=False)
    optp.add_option('-d', '--disable', dest='disable', action="store_true", help=_('Disable autostart'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.enable is False and opts.disable is False:
        raise KssCommandOptException('ERROR: either %s options must be specified.' % '--enable or --disable')
    if opts.enable is True and opts.disable is True:
        raise KssCommandOptException('ERROR: %s options are conflicted.' % '--enable and --disable')

class AutostartService(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        service = config.findby1service(opts.name)
        if service is None:
            raise KssCommandException("Service not found in xml file. service=%s" % (opts.name))

        self.up_progress(10)
        sysv = SysVInit_RH(service['system_name'], service['system_command'])

        flag = None
        if opts.enable:
            flag = True
        if opts.disable:
            flag = False

        retval = sysv.onboot(flag)
        if not(retval is False) and not(retval is True):
            raise KssCommandException(str(sysv.error_msg))

        self.up_progress(50)
        if flag is True:
            message = 'Enable service. - service=%s' % (opts.name)
        else:
            message = 'Disable service. - service=%s' % (opts.name)

        self.logger.info(message)
        print >>sys.stdout, _(message)

        return True

if __name__ == "__main__":
    target = AutostartService()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = autostart_storage_pool
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Storage pool name'))
    optp.add_option('-e', '--enable', dest='enable', action="store_true", help=_('Enable storage pool autostart'))
    optp.add_option('-d', '--disable', dest='disable', action="store_true", help=_('Disable storage pool autostart'))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.enable is None and opts.disable is None:
        raise KssCommandOptException('ERROR: either %s options must be specified.' % '--enable or --disable')
    if opts.enable is not None and opts.disable is not None:
        raise KssCommandOptException('ERROR: %s options are conflicted.' % '--enable and --disable')

class AutostartStoragePool(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            inactive_storage_pools = conn.list_inactive_storage_pool()
            active_storage_pools = conn.list_active_storage_pool()
            self.up_progress(10)
            if not (opts.name in active_storage_pools or \
                    opts.name in inactive_storage_pools):
                raise KssCommandOptException('Storage pool does not exist. - pool=%s'
                                          % opts.name)

            conn.storage_pool.set_storage_name(opts.name)

            self.up_progress(10)
            flag = None
            if opts.enable:
                flag = True
            elif opts.disable:
                flag = False
            else:
                raise KssCommandException(
                    'ERROR: Execution status information does not exist. enable,disable=%s,%s' \
                    % (str(opts.enable), str(opts.disable)))

            self.up_progress(10)
            if conn.autostart_storage_pool(flag) is False:
                raise KssCommandException(
                    'Failed to autostart storage pool(libvirt). - pool=%s'
                    % (opts.name))

            ret = conn.is_autostart_storage_pool()
            if not (ret is flag):
                raise KssCommandException(
                    'Auto-start failed to set the storage pool. - pool=%s, autostart=%s' \
                    % (opts.name, str(ret)))

            self.up_progress(40)
            if opts.enable:
                self.logger.info('Set autostart storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Set autostart storage pool. - pool=%s') % (opts.name)
            elif opts.disable:
                self.logger.info('Unset autostart storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Unset autostart storage pool. - pool=%s') % (opts.name)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = AutostartStoragePool()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = connect_virt
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                 VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTDOWN
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-c', '--count', dest='count', type="int", help=_('Connection Trial Count'), default=1)
    return optp.parse_args()

def chkopts(opts):
    try:
        int(opts.count)
    except:
        raise KssCommandOptException('ERROR: -c or --count option must be specified as a positive integer.')

class ConnectVirt(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        step = 100 / opts.count

        for cnt in xrange(0,opts.count):
            self.up_progress(step)
            try:
                print cnt
                conn = KaresansuiVirtConnection(readonly=False)
                print conn
            finally:
                pass
                #conn.close()

if __name__ == "__main__":
    target = ConnectVirt()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = control_iptables
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.parser.iptables import iptablesParser as Parser
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    """
    TRANSLATORS:
    翻訳お疲れさまです。
    「設定ファイルのパス」
    """
    optp.add_option('-c', '--config', dest='config', help=_('Path to configuration file'), default=None)
    optp.add_option('-a', '--action', dest='action', help=_('Action'), default=None)
    optp.add_option('-t', '--lint', dest='lint', help=_('Do lint (Specify config file to check)'),  action="store_true", default=False)
    return optp.parse_args()

def chkopts(opts):
    pass

class ControlIptables(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        parser = Parser()

        if opts.config is None:
            config = parser.source_file()[0]
        else:
            if not os.path.exists(opts.config):
                error_msg = "ERROR: file not found '%s'." % (opts.config)
                self.logger.error(error_msg)
                raise KssCommandOptException(error_msg)
            config = opts.config

        self.up_progress(10)
        if opts.lint is True:
            (ret, stdout, stderr) = parser.do_lint(open(config).read())
            if ret != 0:
                print stderr

        elif opts.action is not None:
            try:
                exec("func = parser.do_%s" % opts.action)
                self.up_progress(10)
                (ret,res) = func()
                if ret is False:
                    error_msg = "ERROR: failed to %s" % (opts.action)
                    self.logger.error(error_msg)
                    raise KssCommandOptException(error_msg)
                self.up_progress(30)
            except KssCommandOptException, e:
                raise KssCommandOptException(''.join(e.args))
            except:
                error_msg = "ERROR: unknown action '%s'." % (opts.action)
                self.logger.error(error_msg)
                raise KssCommandOptException(error_msg)

        """
        TODO : 実装お疲れ様です。
        実況結果をstdoutにお願いします
        """
        return True

if __name__ == "__main__":
    target = ControlIptables()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = cputop
#!/usr/bin/env python
# -*- coding: utf-8 -*- 
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys
import os
import curses
import time

import __cmd__

from karesansui.lib.virt.virt import KaresansuiVirtConnection

# initialize curses
stdscr = curses.initscr()
curses.noecho()
curses.cbreak()
stdscr.keypad(1)

#curses.start_color()
#curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)

# timeout getch after 1s
stdscr.timeout(1000)

(maxy, maxx) = stdscr.getmaxyx()

vtop_start = time.time()
first_run = True

conn = KaresansuiVirtConnection()
shares = {}
while True:
    guests = conn.search_guests()
    idx = 1
    cpusum=0
    if first_run:
        for guest in guests:
            id = guest.ID()
            if id > -1:
                name = guest.name()
                info = guest.info()
                shares[name] = info[4]
        first_run = False
    else:
        stdscr.addstr(idx, 1, "Domain\t\tID\tVCPU\t%CPU\t%CPUSUM   ", curses.A_REVERSE)
        idx += 1
        for guest in guests:
            id = guest.ID()
            if id > -1:
                name = guest.name()
                info = guest.info()
                now = time.time()
                share = info[4] - shares[name]
                p = (share*100)/((now - vtop_start) * 10**9)
                cpusum+=p
                stdscr.addstr(idx, 1, "%s\t%d\t%d\t%.2f\t%.2f" % (name, id, info[3], p, cpusum))
                idx += 1
        idx += 1
        stdscr.addstr(idx, 1, "Press 'q' for quit.")
        idx += 1
    c = stdscr.getch()
    if c == ord('q'):
        curses.nocbreak()
        stdscr.keypad(0)
        curses.echo()
        curses.endwin()
        break
    stdscr.erase()
    stdscr.refresh()

    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
curses.endwin()
conn.close()


########NEW FILE########
__FILENAME__ = create_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
import re
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, is_uuid, is_iso9660_filesystem_format
    from karesansui.lib.const import DEFAULT_KEYMAP, GRAPHICS_PORT_MIN_NUMBER, GRAPHICS_PORT_MAX_NUMBER

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    # basic
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-t', '--type', dest='type', help=_('VM Type'), default="xen")
    optp.add_option('-m', '--mem-size', dest='mem_size', help=_('Memory Size (MB)'), default=256)
    optp.add_option('-d', '--disk', dest='disk', help=_('Disk image file'), default=None)
    optp.add_option('-v', '--graphics-port', dest='graphics_port', help=_('Graphics Port Number'), default=None)
    optp.add_option('-u', '--uuid', dest='uuid', help=_('UUID'), default=None)
    optp.add_option('-a', '--mac', dest='mac', help=_('MAC Address'), default=None)
    optp.add_option('-c', '--vcpus', dest='vcpus', help=_('Number of virtual CPUs to allocate'), default=1)
    optp.add_option('-f', '--interface-format', dest='interface_format', help=_('Interface format'), default='b:xenbr0')
    optp.add_option('-b', '--keymap', dest='keymap', help=_('Graphics Keyboard Map'), default=DEFAULT_KEYMAP)
    optp.add_option('-e', '--extra', dest='extra', help=_('Extra kernel options'), default=None)
    # Storage pool only
    optp.add_option('-P', '--storage-pool', dest='storage_pool', help=_('Storage pool name'), default=None)
    optp.add_option('-V', '--storage-volume', dest='storage_volume', help=_('Storage volume name'), default=None)
    # make disk only
    optp.add_option('-D', '--disk-format', dest='disk_format', help=_('Disk format'), default=None)
    optp.add_option('-s', '--disk-size', dest='disk_size', help=_('Disk size (MB)'), default=1024*8)
    # IDE or SCSI or Virtio
    optp.add_option('-B', '--bus', dest='bus', help=_('Device bus type'), default=None)
    # ISO only
    optp.add_option('-o', '--iso', dest='iso', help=_('ISO image'), default=None)
    # Individual designation
    optp.add_option('-k', '--kernel', dest='kernel', help=_('Kernel image'), default=None)
    optp.add_option('-i', '--initrd', dest='initrd', help=_('initrd image'), default=None)

    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.type:
        if opts.type.lower() != "xen" and opts.type.lower() != "kvm":
            raise KssCommandOptException('ERROR: %s option is require %s or %s.' % ('-t or --type', 'xen', 'kvm'))

    if opts.storage_pool:
        if reg.search(opts.storage_pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-P or --storage-pool', opts.storage_pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-P or --storage-pool')

    if opts.storage_volume:
        if reg.search(opts.storage_volume):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-V or --storage-volume', opts.storage_volume))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-V or --storage-volume')

    if opts.bus:
        if reg.search(opts.bus):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-B or --bus', opts.bus))

    reg = re.compile("[^0-9]")
    if opts.mem_size:
        if reg.search(str(opts.mem_size)):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-m or --mem-size', opts.mem_size))

    if opts.graphics_port:
        if reg.search(str(opts.graphics_port)):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-v or --graphics-port', opts.graphics_port))
        elif int(opts.graphics_port) < GRAPHICS_PORT_MIN_NUMBER or GRAPHICS_PORT_MAX_NUMBER < int(opts.graphics_port):
            raise KssCommandOptException('ERROR: Illigal port number. option=%s value=%s' % ('-v or --graphics-port', opts.graphics_port))

    if opts.vcpus:
        if reg.search(str(opts.vcpus)):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-c or --vcpus', opts.vcpus))

    if opts.uuid:
        if not is_uuid(opts.uuid):
            raise KssCommandOptException('ERROR: Illigal UUID. uuid=%s' % (opts.uuid))

    if opts.mac:
        reg = re.compile("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$")
        if not reg.match(opts.mac):
            raise KssCommandOptException('ERROR: Illigal MAC address. mac=%s' % (opts.mac))

    #if opts.disk and os.path.isfile(opts.disk) is False:
    #    raise KssCommandOptException('ERROR: %s not found.' % opts.disk)

    if opts.iso is not None:
        if opts.kernel is not None or opts.initrd is not None:
            raise KssCommandOptException('ERROR: %s option cannot be specified with %s options.' % ('--iso', '--kernel and --initrd',))

        if os.path.isfile(opts.iso) is False:
            raise KssCommandOptException('ERROR: The specified ISO image path does not exist. - %s' % opts.iso)

        if is_iso9660_filesystem_format(opts.iso) is False:
            raise KssCommandOptException('ERROR: The specified ISO image is not valid ISO 9660 CD-ROM filesystem data. - %s' % opts.iso)

    else:
        _r_get_net = re.compile("^(ftp|http)://")

        if opts.kernel:
            if _r_get_net.match(str(opts.kernel)) is None and os.path.isfile(opts.kernel) is False:
                raise KssCommandOptException('ERROR: The specified kernel image path does not exist. - %s' % opts.kernel)
        else:
            raise KssCommandOptException('ERROR: %s option is required.' % '-k or --kernel')

        if opts.initrd:
            if _r_get_net.match(str(opts.initrd)) is None and os.path.isfile(opts.initrd) is False:
                raise KssCommandOptException('ERROR: The specified initrd image path does not exist. - %s' % opts.initrd)
        else:
            raise KssCommandOptException('ERROR: %s option is required.' % '-i or --initrd')

class CreateGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_interface_format(opts.interface_format)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                raise KssCommandException('Guest already exists. - dom=%s' % (opts.name))

            self.up_progress(10)
            inactive_storage_pools = conn.list_inactive_storage_pool()
            active_storage_pools = conn.list_active_storage_pool()
            if not (opts.storage_pool in active_storage_pools or opts.storage_pool in inactive_storage_pools):
                raise KssCommandException('Storage pool does not exist. - pool=%s' % (opts.storage_pool))

            # TODO
            #if conn.get_storage_volume(opts.storage_pool, opts.uuid) is None:
            #    raise KssCommandException('Specified storage volume does not exist. - pool=%s, vol=%s'
            #                              % (opts.storage_pool, opts.uuid))

            try:
                self.up_progress(10)
                if not conn.create_guest(name=opts.name,
                                         type=opts.type.lower(),
                                         ram=opts.mem_size,
                                         disk=opts.disk,
                                         disksize=opts.disk_size,
                                         mac=opts.mac,
                                         uuid=opts.uuid,
                                         kernel=opts.kernel,
                                         initrd=opts.initrd,
                                         iso=opts.iso,
                                         graphics=opts.graphics_port,
                                         vcpus=opts.vcpus,
                                         extra=opts.extra,
                                         keymap=opts.keymap,
                                         bus=opts.bus,
                                         disk_format=opts.disk_format,
                                         storage_pool=opts.storage_pool,
                                         storage_volume=opts.storage_volume,
                                         ) is True:
                    raise KssCommandException('Failed to create guest. - dom=%s' % (opts.name))

            except Exception, e:
                self.logger.error('Failed to create guest. - dom=%s - detail %s' % (opts.name, str(e.args)))
                print >>sys.stderr, _('Failed to create guest. - dom=%s - detail %s') % (opts.name, str(e.args))
                raise e

            self.up_progress(40)
            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if not (opts.name in active_guests or opts.name in inactive_guests):
                raise KssCommandException('Guest OS is not recognized. - dom=%s' % (opts.name))

            self.logger.info('Created guest. - dom=%s' % (opts.name))
            print >>sys.stdout, 'Created guest. - dom=%s' % opts.name
            return True

        finally:
            conn.close()

if __name__ == "__main__":
    target = CreateGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = create_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    optp.add_option('-c', '--cidr', dest='cidr', help=_('Bridge IP address'), default=None)
    optp.add_option('-s', '--dhcp-start', dest='dhcp_start', help=_('DHCP start address'), default=None)
    optp.add_option('-e', '--dhcp-end', dest='dhcp_end', help=_('DHCP end address'), default=None)
    optp.add_option('-f', '--forward-dev', dest='forward_dev', help=_('Forward device'), default=None)
    optp.add_option('-m', '--forward-mode', dest='forward_mode', help=_('Forward mode'), default=None)
    optp.add_option('-b', '--bridge-name', dest='bridge_name', help=_('Bridge name'), default=None)
    optp.add_option('-a', '--autostart', dest='autostart', help=_('Autostart'), default="yes")
    return optp.parse_args()

def chkopts(opts):
    if opts.name is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.cidr is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-c or --cidr')

    if opts.dhcp_start is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-s or --dhcp-start')

    if opts.dhcp_end is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-e or --dhcp-end')

    if opts.bridge_name is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-b or --bridge_name')

class CreateNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            forward = {"dev" : opts.forward_dev,
                       "mode": opts.forward_mode,
                       }
            bridge  = opts.bridge_name

            if opts.autostart == "yes":
                autostart = True
            else:
                autostart = False

            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()

            self.up_progress(10)
            if opts.name in active_networks or opts.name in inactive_networks:
                raise KssCommandException('network already exists. - net=%s' % (opts.name))

            self.up_progress(10)
            try:
                conn.create_network(opts.name, opts.cidr, opts.dhcp_start, opts.dhcp_end, forward, bridge, autostart=autostart)
            except:
                raise KssCommandException('Failed to create network. - net=%s' % (opts.name))

            self.up_progress(40)
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if not (opts.name in active_networks or opts.name in inactive_networks):
                raise KssCommandException('Failed to create the network. - net=%s' % (opts.name))

            self.logger.info('Created network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Created network. - net=%s') % (opts.name)
            self.up_progress(10)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = CreateNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = create_storage_pool
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, get_pwd_info, get_grp_info
    from karesansui.lib.const import STORAGE_POOL_TYPE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name',        dest='name',        help=_('Name'),                           default=None)
    optp.add_option('-t', '--type',        dest='type',        help=_('Pool Type (dir or iscsi or fs)'), default=None)
    optp.add_option('-p', '--target_path', dest='target_path', help=_('Target path (dir, fs)'),          default=None)
    #optp.add_option('-a', '--allocation',  dest='allocation',  help=_('Allocation'),                     default=0, type="int")
    #optp.add_option('-v', '--available',   dest='available',   help=_('Available'),                      default=0, type="int")
    #optp.add_option('-c', '--capacity',    dest='capacity',    help=_('Capacity'),                       default=0, type="int")
    optp.add_option('-b', '--host_name',   dest='host_name',   help=_('Host name (iscsi)'),              default=None)
    optp.add_option('-d', '--device_path', dest='device_path', help=_('Device path (iscsi, fs)'),        default=None)
    optp.add_option('-g', '--group',       dest='group',       help=_('Permission group'),               default=None)
    optp.add_option('-l', '--label',       dest='label',       help=_('Permission label'),               default=None)
    optp.add_option('-m', '--mode',        dest='mode',        help=_('Permission mode'),                default=None)
    optp.add_option('-o', '--owner',       dest='owner',       help=_('Permission owner'),               default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.type:
        if opts.type not in STORAGE_POOL_TYPE.values():
            raise KssCommandOptException('ERROR: Type is not available. type=%s' % opts.type)
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --type')

    if opts.type == STORAGE_POOL_TYPE["TYPE_DIR"]:
        # type:dir
        if not opts.target_path:
            raise KssCommandOptException('ERROR: %s option is required.' % '-p or --target_path')

    elif opts.type == STORAGE_POOL_TYPE["TYPE_ISCSI"]:
        # type:iscsi
        if not opts.host_name:
            raise KssCommandOptException('ERROR: %s option is required.' % '-b or --host_name')
        if not opts.device_path:
            raise KssCommandOptException('ERROR: %s option is required.' % '-d or --device_path')

    elif opts.type == STORAGE_POOL_TYPE["TYPE_FS"]:
        # type:fs
        if not opts.target_path:
            raise KssCommandOptException('ERROR: %s option is required.' % '-p or --target_path')
        if not opts.device_path:
            raise KssCommandOptException('ERROR: %s option is required.' % '-d or --device_path')

    else:
        raise KssCommandOptException('ERROR: The type that does not exist. type=%s' % opts.type)

    if opts.label:
        if reg.search(opts.label):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-l or --label', opts.label))

    reg = re.compile("[^0-9]")
    if opts.owner:
        if reg.search(opts.owner):
            if opts.owner not in [user[0] for user in get_pwd_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. owner=%s' % (opts.owner))
        else:
            if int(opts.owner) not in [user[2] for user in get_pwd_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. owner=%s' % (opts.owner))

    if opts.group:
        if reg.search(opts.group):
            if opts.group not in [group[0] for group in get_grp_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. group=%s' % (opts.group))
        else:
            if int(opts.group) not in [group[2] for group in get_grp_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. group=%s' % (opts.group))

    reg = re.compile("^[0-9]{3,4}$")
    if opts.mode:
        if not reg.match(opts.mode):
            raise KssCommandOptException('ERROR: Illigal permission mode. mode=%s' % (opts.mode))

class CreateStoragePool(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            inactive_storage_pools = conn.list_inactive_storage_pool()
            active_storage_pools = conn.list_active_storage_pool()

            self.up_progress(10)

            if opts.name in active_storage_pools or opts.name in inactive_storage_pools:
                raise KssCommandException('Storage pool already exists. - pool=%s' % opts.name)

            try:
                if opts.type == STORAGE_POOL_TYPE["TYPE_DIR"]:
                    if conn.create_storage_pool(opts.name, opts.type,
                                                opts.target_path,
                                                #allocation=opts.allocation, available=opts.available,
                                                #capacity=opts.capacity,
                                                target_p_group=opts.group, target_p_label=opts.label,
                                                target_p_mode=opts.mode, target_p_owner=opts.owner,
                                                ) is False:
                        raise KssCommandException('Failed to create storage pools. - pool=%s' \
                                                  % opts.name)

                elif opts.type == STORAGE_POOL_TYPE["TYPE_ISCSI"]:
                    if conn.create_storage_pool(opts.name, opts.type,
                                                target_path="/dev/disk/by-path",
                                                source_h_name=opts.host_name,
                                                source_dev_path=opts.device_path,
                                                #allocation=opts.allocation, available=opts.available,
                                                #capacity=opts.capacity,
                                                target_p_group=opts.group, target_p_label=opts.label,
                                                target_p_mode=opts.mode, target_p_owner=opts.owner,
                                                ) is False:
                        raise KssCommandException('Failed to create storage pools. - pool=%s' \
                                                  % opts.name)

                elif opts.type == STORAGE_POOL_TYPE["TYPE_FS"]:
                    if conn.create_storage_pool(opts.name, opts.type,
                                                opts.target_path,
                                                source_dev_path=opts.device_path,
                                                #allocation=opts.allocation, available=opts.available,
                                                #capacity=opts.capacity,
                                                target_p_group=opts.group, target_p_label=opts.label,
                                                target_p_mode=opts.mode, target_p_owner=opts.owner,
                                                ) is False:
                        raise KssCommandException('Failed to create storage pools. - pool=%s' \
                                                  % opts.name)

                else:
                    raise KssCommandOptException('ERROR: The type that does not exist. type=%s' \
                                                 % opts.type)

                self.up_progress(20)
                # pool check
                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()

                if not (opts.name in active_storage_pools or opts.name in inactive_storage_pools):
                    raise KssCommandException(
                        'Failed to create storage pools. (Unexplained) - pool=%s' \
                        % opts.name)

                self.up_progress(20)
                # pool autostart check
                flag = True # autostart on
                if conn.autostart_storage_pool(flag) is False:
                    raise KssCommandException(
                        'Failed to autostart storage pool(libvirt). - pool=%s'
                        % (opts.name))

                ret = conn.is_autostart_storage_pool()
                if not (ret is flag):
                    raise KssCommandException(
                        'Auto-start failed to set the storage pool. - pool=%s, autostart=%s' \
                        % (opts.name, str(ret)))

                self.logger.info('Created storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Created storage pool. - pool=%s') % (opts.name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = CreateStoragePool()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = create_storage_volume
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, get_pwd_info, get_grp_info
    from karesansui.lib.const import STORAGE_POOL_TYPE, STORAGE_VOLUME_FORMAT, \
        STORAGE_VOLUME_SIZE_MIN_LENGTH, STORAGE_VOLUME_SIZE_MAX_LENGTH, STORAGE_VOLUME_UNIT, \
        DISK_USES

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name',             dest='name',             help=_('Domain Name'),      default=None)
    optp.add_option('-p', '--pool_name',        dest='pool_name',        help=_('Pool Name'),        default=None)
    optp.add_option('-v', '--volume_name',      dest='volume_name',      help=_('Volume Name'),      default=None)
    optp.add_option('-f', '--format',           dest='format',           help=_('Format'),           default=None)
    optp.add_option('-a', '--allocation',       dest='allocation',       help=_('Allocation'),       default=0, type="int")
    optp.add_option('-c', '--capacity',         dest='capacity',         help=_('Capacity'),         default=0, type="int")
    optp.add_option('-u', '--unit',             dest='unit',             help=_('Volume Size Unit'), default="")
    optp.add_option('-o', '--permission_owner', dest='permission_owner', help=_('Permission Owner'), default=None)
    optp.add_option('-g', '--permission_group', dest='permission_group', help=_('Permission Group'), default=None)
    optp.add_option('-m', '--permission_mode',  dest='permission_mode',  help=_('Permission Mode'),  default=None)
    optp.add_option('-U', '--use',              dest='use',              help=_('Disk usage."images" or "disk"'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.pool_name:
        if reg.search(opts.pool_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool_name', opts.pool_name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --pool_name')

    if opts.volume_name:
        if reg.search(opts.pool_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool_name', opts.pool_name))

    if opts.format:
        if reg.search(opts.format):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-f or --format', opts.format))

        if opts.format not in STORAGE_VOLUME_FORMAT.values():
            raise KssCommandOptException('ERROR: Format is not available. '
                                         'raw or qcow2... is available. format=%s' % opts.format)
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-f or format')

    if opts.unit:
        if opts.unit not in STORAGE_VOLUME_UNIT.keys():
            raise KssCommandOptException('ERROR: Volume size unit is not available. '
                                         'K or M... is available. unit=%s' % opts.unit)

    reg = re.compile("[^0-9]")
    if opts.permission_owner:
        if reg.search(opts.permission_owner):
            if opts.permission_owner not in [user[0] for user in get_pwd_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. owner=%s' % (opts.permission_owner))
        else:
            if int(opts.permission_owner) not in [user[2] for user in get_pwd_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. owner=%s' % (opts.permission_owner))

    if opts.permission_group:
        if reg.search(opts.permission_group):
            if opts.permission_group not in [group[0] for group in get_grp_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. group=%s' % (opts.permission_group))
        else:
            if int(opts.permission_group) not in [group[2] for group in get_grp_info()]:
                raise KssCommandOptException('ERROR: Permission user not found. group=%s' % (opts.permission_group))

    reg = re.compile("^[0-9]{3,4}$")
    if opts.permission_mode:
        if not reg.match(opts.permission_mode):
            raise KssCommandOptException('ERROR: Illigal permission mode. mode=%s' % (opts.permission_mode))

    if opts.use:
        if opts.use not in DISK_USES.values():
            raise KssCommandOptException('ERROR: Disk usage is not available. '
                                         'images or disk is available. use=%s' % opts.use)

        if opts.use == DISK_USES["IMAGES"]:
            if not opts.volume_name:
                raise KssCommandOptException('ERROR: %s option is required.' % '-v or --volume_name')

class CreateStorageVolume(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)

        try:
            try:
                #inactive_storage_pools = conn.list_inactive_storage_pool()
                inactive_storage_pools = []
                active_storage_pools = conn.list_active_storage_pool()
                if not (opts.pool_name in active_storage_pools or \
                        opts.pool_name in inactive_storage_pools):
                    raise KssCommandException('Storage pool does not exist. Alternatively, the storage pool is not started. - pool=%s'
                                              % opts.pool_name)

                if conn.get_storage_volume(opts.pool_name, opts.volume_name) is not None:
                    raise KssCommandException(
                        'We already have a storage volume. - pool=%s, vol=%s'
                        % (opts.pool_name, opts.volume_name))

                pool_obj = conn.search_kvn_storage_pools(opts.pool_name)[0]
                pool_info = pool_obj.get_info()
                if not pool_info['allocation'] or pool_info['allocation'] == 0:
                    storage_volume_allocation_max_size = STORAGE_VOLUME_SIZE_MAX_LENGTH
                else:
                    storage_volume_allocation_max_size = long(pool_info['allocation']) / STORAGE_VOLUME_UNIT.get(opts.unit, 1)
                    if pool_info['type'] == 'dir' or pool_info['type'] == 'fs':
                        storage_volume_allocation_max_size = long(pool_info["available"]) / STORAGE_VOLUME_UNIT.get(opts.unit, 1)
                if not pool_info['capacity'] or pool_info['capacity'] == 0:
                    storage_volume_capacity_max_size = STORAGE_VOLUME_SIZE_MAX_LENGTH
                else:
                    storage_volume_capacity_max_size = long(pool_info['capacity']) / STORAGE_VOLUME_UNIT.get(opts.unit, 1)

                if opts.allocation < STORAGE_VOLUME_SIZE_MIN_LENGTH or storage_volume_allocation_max_size < opts.allocation:
                    raise KssCommandException('Allocation "%s%s" is out of available range. available=%s-%s%s'
                                              % (opts.allocation, opts.unit, STORAGE_VOLUME_SIZE_MIN_LENGTH, storage_volume_allocation_max_size, opts.unit))
                if opts.capacity < STORAGE_VOLUME_SIZE_MIN_LENGTH or storage_volume_capacity_max_size < opts.capacity:
                    raise KssCommandException('Capacity "%s%s" is out of available range. available=%s-%s%s'
                                              % (opts.capacity, opts.unit, STORAGE_VOLUME_SIZE_MIN_LENGTH, storage_volume_capacity_max_size, opts.unit))

                if conn.create_storage_volume(opts.name,
                                              opts.pool_name,
                                              opts.format,
                                              use=opts.use,
                                              volume_name=opts.volume_name,
                                              capacity=opts.capacity,
                                              allocation=opts.allocation,
                                              c_unit=opts.unit,
                                              t_p_owner=opts.permission_owner,
                                              t_p_group=opts.permission_group,
                                              t_p_mode=opts.permission_mode,
                                           ) is False:
                    raise KssCommandException('Failed to create storage volume. (libvirt) - pool=%s, vol=%s'
                                              % (opts.pool_name, opts.volume_name))

                self.up_progress(40)

                vol_path = conn.get_storage_volume_path(opts.pool_name, opts.volume_name)
                if vol_path is None:
                    raise KssCommandException(
                        'Could not get the normal storage pool or storage volume. - pool=%s, vol=%s' \
                        % (opts.pool, opts.volume_name))

                if os.path.isfile(vol_path) is False:
                    raise KssCommandException(
                        'File does not exist in the path of a storage volume. - pool=%s, vol=%s' \
                        % (opts.pool, opts.volume_name))

                vol_obj = conn.get_storage_volume(opts.pool_name, opts.volume_name)
                if vol_obj is None:
                    raise KssCommandException(
                        'Could not get the normal storage pool or storage volume. - pool=%s, vol=%s' \
                        % (opts.pool, opts.volume_name))

                vol_link = "%s/%s" % (pool_info['target']['path'], vol_obj.name())
                if os.path.islink(vol_link) is False:
                    raise KssCommandException(
                        'Symbolic link does not exist in the path of a storage volume. - pool=%s, vol=%s' \
                        % (opts.pool, opts.volume_name))

                self.logger.info('Created storage volume. - vol=%s' % (opts.volume_name))
                print >>sys.stdout, _('Created storage volume. - vol=%s') % (opts.volume_name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = CreateStorageVolume()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_bonding
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
import fcntl
import string
import copy
import re
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command, get_ifconfig_info, \
        is_writable, create_file, move_file, remove_file, get_bridge_info
    from karesansui.lib.dict_op import DictOp
    from karesansui.lib.parser.ifcfg import ifcfgParser
    from karesansui.lib.parser.modprobe_conf import modprobe_confParser
    from karesansui.lib.const import BONDING_MODE, BONDING_CONFIG_MII_DEFAULT, \
        VENDOR_DATA_BONDING_EVACUATION_DIR, NETWORK_IFCFG_DIR, NETWORK_COMMAND, \
        SYSTEM_COMMAND_REMOVE_MODULE, NETWORK_IFDOWN_COMMAND, NETWORK_BRCTL_COMMAND

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-d', '--dev', dest='dev', help=_('Bonding target device name'), default=None)
    optp.add_option('-s', '--succession', dest='succession', action="store_true", help=_('Succeed IP address settings of the primary device.'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9]")

    if opts.dev:
        if reg.search(opts.dev):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-d or --dev', opts.dev))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-d or --dev')

class DeleteBonding(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        exist_bond_list = get_ifconfig_info("regex:^bond")
        if opts.dev not in exist_bond_list:
            raise KssCommandOptException('Target bonding device not found. target=%s' % opts.dev)

        self.up_progress(10)
        dop = DictOp()
        ifcfg_parser = ifcfgParser()
        dop.addconf("ifcfg", ifcfg_parser.read_conf())
        if dop.getconf("ifcfg") == {}:
            raise KssCommandException('Failure read network config file.')

        if dop.get("ifcfg", opts.dev) is False:
            raise KssCommandException('Target device ifcfg file not found.')

        self.up_progress(10)
        restore_dev_list = []
        for dev in dop.getconf("ifcfg").keys():
            if dop.get("ifcfg", [dev, "MASTER"]) == opts.dev:
                restore_dev_list.append(dev)

        self.up_progress(10)
        if opts.succession is True:
            bond_bridge = dop.get("ifcfg", [opts.dev, "BRIDGE"])
            bond_dev = opts.dev
            if bond_bridge:
                bond_dev = bond_bridge

            ipaddr = dop.get("ifcfg",  [bond_dev, "IPADDR"])
            netmask = dop.get("ifcfg", [bond_dev, "NETMASK"])
            gateway = dop.get("ifcfg", [bond_dev, "GATEWAY"])
            bonding_opts = dop.get("ifcfg", [opts.dev, "BONDING_OPTS"])
            bonding_opts = bonding_opts.strip('"')
            primary_dev = None
            for combination in bonding_opts.split(" "):
                if re.match("primary", combination):
                    (key,val) = combination.split("=")
                    val = val.strip()
                    primary_dev = val

        self.up_progress(10)
        for restore_dev in restore_dev_list:
            if move_file("%s/ifcfg-%s" % (VENDOR_DATA_BONDING_EVACUATION_DIR, restore_dev), NETWORK_IFCFG_DIR) is False:
                raise KssCommandException('Failure restore ifcfg file.')
            if os.path.isfile("%s/ifcfg-p%s" % (VENDOR_DATA_BONDING_EVACUATION_DIR, restore_dev)):
                if move_file("%s/ifcfg-p%s" % (VENDOR_DATA_BONDING_EVACUATION_DIR, restore_dev), NETWORK_IFCFG_DIR) is False:
                    raise KssCommandException('Failure restore ifcfg file.')

        self.up_progress(10)
        if opts.succession is True and primary_dev is not None:
            dop = DictOp()
            ifcfg_parser = ifcfgParser()
            dop.addconf("ifcfg", ifcfg_parser.read_conf())
            if dop.getconf("ifcfg") == {}:
                raise KssCommandException('Failure read network config file.')

            if ipaddr:
                dop.set("ifcfg", [primary_dev, "IPADDR"],  ipaddr)
            if netmask:
                dop.set("ifcfg", [primary_dev, "NETMASK"], netmask)
            if gateway:
                dop.set("ifcfg", [primary_dev, "GATEWAY"], gateway)

            if ifcfg_parser.write_conf(dop.getconf("ifcfg")) is False:
                raise KssCommandException('Failure write network config file.')

        self.up_progress(10)
        remove_file("%s/ifcfg-%s" % (NETWORK_IFCFG_DIR, opts.dev))

        self.up_progress(10)
        dop = DictOp()
        modprobe_parser = modprobe_confParser()
        dop.addconf("modprobe_conf", modprobe_parser.read_conf())
        if dop.getconf("modprobe_conf") == {}:
            raise KssCommandException('Failure read modprobe config file.')

        dop.unset("modprobe_conf", ["alias", opts.dev])

        if modprobe_parser.write_conf(dop.getconf("modprobe_conf")) is False:
            raise KssCommandException('Failure write modprobe config file.')

        self.up_progress(10)

        #
        # Delete bridge device
        #
        bridge_list = get_bridge_info()
        bond_bridge = None

        for bridge in bridge_list:
            if opts.dev in bridge_list[bridge]:
                bond_bridge = bridge

        if bond_bridge:
            ifdown_cmd = (NETWORK_IFDOWN_COMMAND,
                          bond_bridge,
                          )
            (ifdown_rc, ifdown_res) = execute_command(ifdown_cmd)
            if ifdown_rc != 0:
                raise KssCommandException('Failure stop interface. interface:%s' % (dev))

            for brif in bridge_list[bond_bridge]:
                brctl_delif_cmd = (NETWORK_BRCTL_COMMAND,
                                   "delif",
                                   bond_bridge,
                                   brif,
                                   )
                (brctl_rc, brctl_res) = execute_command(brctl_delif_cmd)
                if brctl_rc != 0:
                    raise KssCommandException('Failure delete bridge port. bridge:%s port:%s' % (dev, brif))

            brctl_delbr_cmd = (NETWORK_BRCTL_COMMAND,
                               "delbr",
                               bond_bridge,
                               )
            (brctl_rc, brctl_res) = execute_command(brctl_delbr_cmd)
            if brctl_rc != 0:
                raise KssCommandException('Failure delete bridge. bridge:%s' % (dev, brif))

            remove_file("%s/ifcfg-%s" % (NETWORK_IFCFG_DIR, bond_bridge))

        #
        # Unload bonding module
        #
        remove_bonding_cmd = (SYSTEM_COMMAND_REMOVE_MODULE,
                              "bonding",
                              )
        (rmmod_rc, rmmod_res) = execute_command(remove_bonding_cmd)
        if rmmod_rc != 0:
            raise KssCommandException('Failure remove bonding module.')

        #
        # Restart network
        #
        network_restart_cmd = (NETWORK_COMMAND,
                               "restart",
                               )
        (net_rc, net_res) = execute_command(network_restart_cmd)
        if net_rc != 0:
            raise KssCommandException('Failure restart network.')

        self.logger.info("Deleted bonding device. - bond=%s dev=%s" % (opts.dev, ','.join(restore_dev_list)))
        print >>sys.stdout, _("Deleted bonding device. - bond=%s dev=%s" % (opts.dev, ','.join(restore_dev_list)))

        return True

if __name__ == "__main__":
    target = DeleteBonding()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_disk
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
except ImportError:
    print >>sys.stderr, "[Error] karesansui package was not found."
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-t', '--target', dest='target', help=_('Device target'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')
    if not opts.target:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --target')

class DeleteDisk(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            self.up_progress(10)
            conn.guest.delete_disk(opts.target)
            self.up_progress(40)
            self.logger.info('Deleted disk device. - dom=%s target=%s' % (opts.name,opts.target))
            print >>sys.stdout, _('Deleted disk device. - dom=%s target=%s') % (opts.name, opts.target)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteDisk()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_export_data
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import shutil
import glob
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.utils import load_locale, is_uuid
    from karesansui.lib.virt.config_export import ExportConfigParam
    from karesansui.lib.virt.config import ConfigParam

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-u', '--uuid',  dest='uuid',  help=_('Export Data UUID'))

    return optp.parse_args()

def chkopts(opts):
    if opts.uuid:
        if not is_uuid(opts.uuid):
            raise KssCommandOptException('ERROR: Illigal UUID. uuid=%s' % (opts.uuid))
    else:
        raise KssCommandOptException('ERROR: -u or --uuid option is required.')

class DeleteExportData(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        kvc = KaresansuiVirtConnection()
        # #1 libvirt process
        try:
            #inactive_pool = kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            export = []
            for pool_name in pools:
                pool = kvc.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]
                if os.path.exists(path):
                    for _afile in glob.glob("%s/*/info.dat" % (path,)):
                        e_param = ExportConfigParam()
                        e_param.load_xml_config(_afile)

                        if e_param.get_uuid() != opts.uuid:
                            continue

                        e_name = e_param.get_domain()
                        _dir = os.path.dirname(_afile)

                        param = ConfigParam(e_name)

                        path = "%s/%s.xml" % (_dir, e_name)
                        if os.path.isfile(path) is False:
                            raise KssCommandException(
                                'Export corrupt data.(file not found) - path=%s' % path)

                        param.load_xml_config(path)

                        if e_name != param.get_domain_name():
                            raise KssCommandException(
                                'Export corrupt data.(The name does not match) - info=%s, xml=%s' \
                                % (e_name, param.get_name()))

                        _dir = os.path.dirname(_afile)

                        export.append({"dir" : _dir,
                                       "pool" : pool_name,
                                       "uuid" : e_param.get_uuid(),
                                       "name" : e_name,
                                       })

            if len(export) < 1:
                # refresh pool.
                conn = KaresansuiVirtConnection(readonly=False)
                try:
                    conn.refresh_pools()
                finally:
                    conn.close()
                raise KssCommandException('libvirt data did not exist. - uuid=%s' % opts.uuid)
            else:
                export = export[0]

        finally:
            kvc.close()

        self.up_progress(30)
        # #2 physical process
        if os.path.isdir(export['dir']) is False:
            raise KssCommandException(_("Failed to delete export data. - %s") % (_("Export data directory not found. [%s]") % (export['dir'])))

        uuid = os.path.basename(export['dir'])
        pool_dir = os.path.dirname(export['dir'])

        if not is_uuid(export['uuid']):
            raise KssCommandException(_("Failed to delete export data. - %s") % (_("'%s' is not valid export data directory.") % (export['dir'])))

        shutil.rmtree(export['dir'])

        for _afile in glob.glob("%s*img" % (export['dir'])):
            os.remove(_afile)

        self.up_progress(30)
        # refresh pool.
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            try:
                conn.refresh_pools()
            finally:
                conn.close()
        except:
            pass

        self.logger.info('Deleted export data. - uuid=%s' % (opts.uuid))
        print >>sys.stdout, _('Deleted export data. - uuid=%s') % (opts.uuid)
        return True

if __name__ == "__main__":
    target = DeleteExportData()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
import traceback
from optparse import OptionParser
import shutil

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
    from karesansui.db.access.machine import findby1uniquekey, deleteby1uniquekey
    from karesansui.db.access.machine2jobgroup import deleteby1machine
    from karesansui.lib.const import XEN_VIRT_CONFIG_DIR, KVM_VIRT_CONFIG_DIR, \
                    VIRT_XML_CONFIG_DIR

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-p', '--pool', dest='pool', help=_('Storage Pool Name'))
    optp.add_option('-v', '--volume', dest='volume', help=_('Storage Volume Name'))
    #optp.add_option('-f', '--force', dest='force', action="store_true", default=False, help=_('To remove the storage volume even more.'))

    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

    if not opts.pool:
        raise KssCommandOptException('ERROR: -p or --pool option is required.')

class DeleteGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            uuid = conn.domname_to_uuid(opts.name)
            try: # physical
                conn.set_domain_name(opts.name)
                conn.delete_guest(opts.name, opts.pool, opts.volume)
                self.up_progress(20)
            except Exception, e:
                print >>sys.stderr, '[Warn] Failed to delete the guest OS physical. - dom=%s - detail : %s' \
                      % (opts.name, str(e.args))
                self.logger.warn('Failed to delete the guest OS physical. - dom=%s - detail : %s' \
                                 % (opts.name, str(e.args)))

            # Check the presence of residual files
            try:
                self.up_progress(10)
                # /etc
                config = ""
                hypervisor = conn.get_hypervisor_type()
                if hypervisor == "XEN":
                    config = "%s/%s" % (XEN_VIRT_CONFIG_DIR, opts.name,)
                elif hypervisor == "KVM" or hypervisor == "QEMU":
                    config = "%s/%s" % (KVM_VIRT_CONFIG_DIR, opts.name,)
                if os.path.isfile(config) is True:
                    os.remove(config)
                    self.logger.info("physical config remove. - path=%s" % config)

                self.up_progress(5)

                xml_config = '%s/%s.xml' % (VIRT_XML_CONFIG_DIR, opts.name)
                if os.path.isfile(xml_config) is True:
                    os.remove(xml_config)
                    self.logger.info("physical xml config remove. - path=%s" % xml_config)

                self.up_progress(5)

                self.logger.info('To remove the storage volume even more.')

                tmp_pool = conn.get_storage_pool_name_bydomain(opts.name, 'os')
                if tmp_pool:
                    domains_dir = conn.get_storage_pool_targetpath(tmp_pool[0])
                else:
                    domains_dir = conn.get_storage_pool_targetpath(opts.pool)

                disk_image = '%s/%s/images/%s.img' % (domains_dir, opts.name, opts.name,)
                if os.path.isfile(disk_image) is True or os.path.islink(disk_image) is True:
                    os.remove(disk_image)
                    self.logger.info("physical disk image remove. - path=%s" % disk_image)

                self.up_progress(5)
                if 0 < len(opts.name.split()): # double check
                    snapshot_dir = '%s/%s/snapshot' % (domains_dir, opts.name,)
                    if os.path.isdir(snapshot_dir) is True:

                        for root, dirs, files in os.walk(snapshot_dir):
                            for fname in files:
                                file_path = os.path.join(root, fname)
                                os.remove(file_path)
                                self.logger.info("physical snapshots file remove. - file=%s" % file_path)

                        os.removedirs(snapshot_dir)
                        self.logger.info("physical snapshots directory remove. - dir=%s" % snapshot_dir)

                self.up_progress(5)
                if 0 < len(opts.name.split()): # double check
                    disk_dir = '%s/%s/disk' % (domains_dir, opts.name,)
                    if os.path.isdir(disk_dir) is True:

                        for root, dirs, files in os.walk(disk_dir):
                            for fname in files:
                                file_path = os.path.join(root, fname)
                                os.remove(file_path)
                                self.logger.info("physical disk file remove. - file=%s" % file_path)

                        os.removedirs(disk_dir)
                        self.logger.info("physical disk directory remove. - dir=%s" % disk_dir)
                self.up_progress(5)

                # Delete GuestOS directory
                domain_dir = "%s/%s" % (domains_dir, opts.name)
                if os.path.isdir(domain_dir) is True:
                    shutil.rmtree(domain_dir)

                self.up_progress(5)

            except Exception, e:
                print >>sys.stderr, '[Warn] Failed to remove the residual file.. - dom=%s - detail : %s' \
                      % (opts.name, str(e.args))
                self.logger.warn('Failed to remove the residual file.. - dom=%s - detail : %s' \
                                 % (opts.name, str(e.args)))

            # database
            try:
                if uuid == '':
                    raise KssCommandException('UUID did not get that.')

                # rollback - machine
                self.up_progress(5)
                deleteby1uniquekey(self.kss_session, u"%s" % uuid)
                self.up_progress(5)
            except KssCommandException, e:
                print >>sys.stderr, '[Warn] Failed to delete the guest OS database. - dom=%s - detail : %s' \
                      % (opts.name, str(e.args))
                self.logger.warn('Failed to delete the guest OS database. - dom=%s - detail : %s' \
                                 % (opts.name, str(e.args)))

            self.logger.info('deleted guestos. - dom=%s' % opts.name)
            print >>sys.stdout, 'deleted guestos. - dom=%s' % opts.name
            return True

        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command
    from karesansui.lib.const import ISCSI_CMD, ISCSI_CMD_OPTION_MODE, \
        ISCSI_CMD_OPTION_MODE_NODE, ISCSI_CMD_OPTION_OPERATOR, ISCSI_CMD_OPTION_OPERATOR_DELETE, \
        ISCSI_CMD_OPTION_TARGETNAME, ISCSI_CMD_OPTION_PORTAL

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-t', '--target', dest='host', help=_('Target host name'), default=None)
    optp.add_option('-i', '--iqn', dest='iqn', help=_('Target IQN'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\._:-]")

    if opts.iqn:
        if reg.search(opts.iqn):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-i or --iqn', opts.iqn))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-i or --iqn')

    if opts.host:
        if reg.search(opts.host):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-t or --target', opts.host))

class DeleteIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        delete_command_args = [
            ISCSI_CMD,
            ISCSI_CMD_OPTION_MODE,
            ISCSI_CMD_OPTION_MODE_NODE,
            ISCSI_CMD_OPTION_OPERATOR,
            ISCSI_CMD_OPTION_OPERATOR_DELETE,
            ISCSI_CMD_OPTION_TARGETNAME,
            opts.iqn,
            ]
        if opts.host:
            delete_command_args.append(ISCSI_CMD_OPTION_PORTAL)
            delete_command_args.append(opts.host)

        (delete_rc,delete_res) = execute_command(delete_command_args)
        self.up_progress(50)

        if delete_rc != 0:
            raise KssCommandException('Failed to delete iSCSI. - host=%s iqn=%s message=%s' % (opts.host, opts.iqn, delete_res))

        self.logger.info("Delete iSCSI node successful. - host=%s iqn=%s" % (opts.host, opts.iqn))
        print >>sys.stdout, _("Delete iSCSI node successful. - host=%s iqn=%s") % (opts.host, opts.iqn)

        return True

if __name__ == "__main__":
    target = DeleteIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class DeleteNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if not (opts.name in active_networks or opts.name in inactive_networks):
                raise KssCommandException('Could not find the specified network. - net=%s' % (opts.name))

            self.up_progress(10)
            try:
                conn.delete_network(opts.name)
            except:
                raise KssCommandException('Failed to delete network. - net=%s' % (opts.name))

            self.up_progress(20)
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if opts.name in active_networks or opts.name in inactive_networks:
                raise KssCommandException('Failed to delete the network. - net=%s' % (opts.name))

            self.logger.info('Deleted network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Deleted network. - net=%s') % (opts.name)
            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_nic
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-m', '--mac', dest='mac', help=_('MAC Address'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')
    if not opts.mac:
        KssCommandOptException('ERROR: %s option is required.' % '-m or --mac')

class DeleteNIC(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)
            conn.guest.delete_interface(opts.mac)
            self.up_progress(50)

            self.logger.info('Deleted interface device. - dom=%s mac=%s' % (opts.name,opts.mac))
            print >>sys.stdout, _('Deleted interface device. - dom=%s mac=%s') % (opts.name, opts.mac)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteNIC()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<description>

@file:   delete_snapshot.py
@author: Taizo ITO <taizo.ito@karesansui-project.info>
@copyright:    

<comment-ja>
ゲストOSの指定したスナップショットを削除する

 使用方法: delete_snapshot.py [オプション]

  オプション:
    --version             プログラムのバージョンを表示
    -h, --help            使用方法を表示
    -n NAME, --name=NAME  ドメイン名を指定
    -i ID, --id=ID        スナップショットのIDを指定
</comment-ja>
<comment-en>
Delete a snapshot from the domain.

 usage: delete_snapshot.py [options]

  options:
    --version             show program's version number and exit
    -h, --help            show this help message and exit
    -n NAME, --name=NAME  Domain name
    -i ID, --id=ID        Snapshot serial ID
</comment-en>
"""

import os
import os.path
import sys
import logging
import traceback
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-i', '--id', dest='id', help=_('Snapshot serial ID'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

    if not opts.id:
        raise KssCommandOptException('ERROR: -i or --id option is required.')

class DeleteSnapshot(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        kvs = KaresansuiVirtSnapshot(readonly=False)
        try:
            self.up_progress(10)
            try:
                domain = kvs.whichDomain(opts.id)
                if len(domain) == 0:
                    msg = _("Snapshot '%s' not found in domain '%s'.") % (opts.id,opts.name,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                if not opts.name in domain:
                    msg = _("Snapshot '%s' not found in domain '%s'.") % (opts.id,opts.name,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                ret = kvs.deleteSnapshot(opts.id)
                if ret is False:
                    msg = _("Can't delete snapshot '%s'.") % (opts.id,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

                self.up_progress(50)

                msg = _("Domain snapshot '%s' deleted.") % (opts.id,)
                self.logger.info(msg)
                print >>sys.stdout, msg

            except KssCommandException, e:
                raise KssCommandException(''.join(e.args))
            except Exception, e:
                msg = _("Failed to delete snapshot '%s'.") % (opts.id,)
                msg += ": detail %s" % ''.join(e.args)
                self.logger.error(msg)
                raise KssCommandException(msg)

        finally:
            kvs.finish()

        return True

if __name__ == "__main__":
    target = DeleteSnapshot()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_storage_pool
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
    from karesansui.lib.const import VIRT_STORAGE_CONFIG_DIR

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Storage pool name'), default=None)
    optp.add_option('-f', '--force', dest='force', action="store_true",
                    help=_('Force to remove the storage pool'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class DeleteStoragePool(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            inactive_storage_pools = conn.list_inactive_storage_pool()
            active_storage_pools = conn.list_active_storage_pool()
            self.up_progress(10)
            if not (opts.name in active_storage_pools or \
                   opts.name in inactive_storage_pools):
                raise KssCommandException('Storage pool does not exist. - pool=%s'
                                          % (opts.name))
            try:
                self.up_progress(30)
                if opts.force is True and opts.name in conn.list_active_storage_pool():
                    if conn.destroy_storage_pool(opts.name) is False:
                        raise KssCommandException("Failed to stop the storage pool. - pool=%s" \
                                                  % (opts.name))

                if opts.name in conn.list_active_storage_pool():
                    raise KssCommandException(
                        "Could not delete storage pool: internal error storage pool is still active' pool=%s" \
                        % opts.name)

                if conn.delete_storage_pool(opts.name, False) is False:
                    raise KssCommandException("Failed to remove the storage pool. - pool=%s" \
                                              % (opts.name))
                self.up_progress(30)

                # pool check
                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()
                if opts.name in active_storage_pools or \
                       opts.name in inactive_storage_pools:
                    raise KssCommandException('Could not remove a storage pool. - pool=%s' \
                                              % (opts.name))

                # .xml
                path = "%s/%s.xml" % (VIRT_STORAGE_CONFIG_DIR, opts.name)
                if os.path.isfile(path) is True:
                    raise KssCommandException(
                        "Could not delete the configuration file. - pool=%s, path=%s" \
                        % (opts.name, path))

                self.logger.info('Deleted storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Deleted storage pool. - pool=%s') % (opts.name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteStoragePool()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = delete_storage_volume
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
    from karesansui.lib.const import DISK_USES

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Storage volume name'), default=None)
    optp.add_option('-p', '--pool_name', dest='pool_name', help=_('Storage pool name'), default=None)
    optp.add_option('-U', '--use', dest='use',
                    help=_('Use of disk usage."images" or "disk"'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.pool_name:
        if reg.search(opts.pool_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool_name', opts.pool_name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --pool_name')

    if opts.use:
        if opts.use not in DISK_USES.values():
            raise KssCommandOptException('ERROR: Disk usage is not available. '
                                         'images or disk is available. use=%s' % opts.use)

class DeleteStorageVolume(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            inactive_storage_pools = conn.list_inactive_storage_pool()
            active_storage_pools = conn.list_active_storage_pool()
            self.up_progress(10)

            if not (opts.pool_name in active_storage_pools or \
                   opts.pool_name in inactive_storage_pools):
                raise KssCommandException('Storage pool does not exist. - pool=%s'
                                          % opts.name)

            pool_dir = conn.get_storage_pool_targetpath(opts.pool_name)
            #image_path = os.path.realpath("%s/%s/images/%s.img" % (pool_dir, opts.name, opts.name))
            #vol = conn.get_storage_volume_symlink(image_path)
            #if not vol:
            #    raise KssCommandException("Storage volume could not be found.")
            #else:
            #    vol = vol[0]

            if conn.get_storage_volume(opts.pool_name, opts.name) is None:
                raise KssCommandException(
                    'Specified storage volume does not exist. - pool=%s, vol=%s'
                    % (opts.pool_name, opts.name))

            try:
                self.up_progress(30)
                if conn.delete_storage_volume(opts.pool_name,
                                              opts.name,
                                              opts.use,
                                              True) is False:
                    KssCommandException("Failed to destroy storage volume. (libvirt)- pool=%s, vol=%s" \
                                        % (opts.pool_name, opts.name))

                self.up_progress(30)
                self.logger.info('Deleted storage volume. - pool=%s, vol=%s' % (opts.pool_name, opts.name))
                print >>sys.stdout, _('Deleted storage volume. - pool=%s, vol=%s') % (opts.pool_name, opts.name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = DeleteStorageVolume()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = destroy_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                 VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTDOWN
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

class DestroyGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.destroy_guest()
                    self.up_progress(40)
                except Exception, e:
                    self.logger.error('Failed to destroy guest. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to destroy guest. - dom=%s') % (opts.name)
                    raise e

                status = conn.guest.status()

                self.up_progress(10)

                if status == VIR_DOMAIN_SHUTOFF or status == VIR_DOMAIN_SHUTDOWN:
                    self.logger.info('Succeeded to destroy guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Succeeded to destroy guest. - dom=%s') % (opts.name)

            else:
                raise KssCommandException(
                    'Guest not found. - dom=%s' % (opts.name))

            return True
        finally:
            conn.close()


if __name__ == "__main__":
    target = DestroyGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = destroy_storage_pool
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Storage pool name'))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class DestroyStoragePool(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            try:
                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()
                self.up_progress(10)
                if not (opts.name in active_storage_pools or \
                        opts.name in inactive_storage_pools):
                    raise KssCommandException('Storage pool does not exist. - pool=%s'
                                          % (opts.name))
                self.up_progress(30)

                if opts.name in conn.list_active_storage_pool():
                    if conn.destroy_storage_pool(opts.name) is False:
                        KssCommandException("Failed to stop the storage pool. - pool=%s"
                                            % (opts.name))
                else:
                    raise KssCommandException('Storage pool is not active. - pool=%s'
                                          % (opts.name))

                self.up_progress(30)

                # check
                if not (opts.name in conn.list_inactive_storage_pool()):
                    KssCommandException("Failed to stop the storage pool. - pool=%s"
                                        % (opts.name))

                self.logger.info('Stop storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Stop storage pool. - pool=%s') % (opts.name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = DestroyStoragePool()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = export_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import re
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.utils import load_locale, preprint_r, base64_decode
    from karesansui.db.access.machine import findby1uniquekey
    from karesansui.lib.utils import string_from_uuid     as StrFromUUID
    from karesansui.lib.utils import generate_uuid        as GenUUID
    from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
    from karesansui.db.access.snapshot import findbyname_guestby1 as s_findbyname_guestby1

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-p', '--pool', dest='pool', help=_('Storage pool name'))
    #optp.add_option('-d', '--dir',  dest='dir',  help=_('Directory name'))
    optp.add_option('-t', '--title',dest='title',default='', help=_('Export title'))
    optp.add_option('-q', '--quiet',dest='verbose', action="store_false", default=True, help=_("don't print status messages"))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if opts.pool:
        if reg.search(opts.pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool', opts.pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --pool')

    #if not opts.pool and not opts.dir:
    #    raise KssCommandOptException('ERROR: -p/--pool or -d/--dir options are required.')

class ExportGuest(KssCommand):

    def __grab_stdout(self, flag):
        if flag:
                self.stdout = sys.stdout
                sys.stdout = os.fdopen(sys.stdout.fileno(), "w", 0)
                logf = open("/dev/null", "a")
                os.dup2(logf.fileno(), 1)
                logf.close()
        else:
                os.dup2(sys.stdout.fileno(), 1)
                sys.stdout = self.stdout
                del self.stdout

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            try:
                src_pool = conn.get_storage_pool_name_bydomain(opts.name, "os")
                if not src_pool:
                    raise KssCommandException("Source storage pool not found. domain=%s" % (opts.name))
                if conn.get_storage_pool_type(src_pool) == 'dir':
                    raise KssCommandException("Storage pool type 'dir' is not. domain=%s" % (opts.name))

                src_path = conn.get_storage_pool_targetpath(src_pool[0])
                self.domain_dir  = "%s/%s" % (src_path, opts.name,)

                if os.path.isdir(self.domain_dir) is False:
                    raise KssCommandException(
                        'domain directory is not found or not directory. - %s' % (self.domain_dir))

                # Model
                virt_uuid = conn.domname_to_uuid(opts.name)
                model = findby1uniquekey(self.kss_session, virt_uuid)
                if not model:
                    raise KssCommandException("Export data does not exist in the database.")

                database = {}
                database['attribute'] = model.attribute
                database['hypervisor'] = model.hypervisor
                database['icon'] = model.icon
                database['name'] = model.name
                database['notebook'] = {"title" : model.notebook.title,
                                        "value" : model.notebook.value,
                                        }
                tags = []
                for _tag in model.tags:
                    tags.append(_tag.name)

                database['tags'] = ",".join(tags)
                database['uniq_key'] = model.uniq_key

                # Snapshot
                snapshots = []
                kvs = KaresansuiVirtSnapshot(readonly=False)
                try:
                    guest_id = model.id
                    snapshot_list = kvs.listNames(opts.name)[opts.name]
                    if len(snapshot_list) > 0:
                        for snapshot in snapshot_list:
                            s_model = s_findbyname_guestby1(self.kss_session, snapshot, guest_id)
                            if s_model is not None:
                                name  = s_model.name
                                title = s_model.notebook.title
                                value = s_model.notebook.value
                                snapshots.append({"name":name, "title":title, "value":value,})
                except:
                    raise KssCommandException("Cannot fetch the information of snapshots correctly.")
                kvs.finish()

                # Pool
                target_dir = ""
                if opts.pool:
                    inactive_storage_pools = conn.list_inactive_storage_pool()
                    active_storage_pools = conn.list_active_storage_pool()
                    if not (opts.pool in active_storage_pools or opts.pool in inactive_storage_pools):
                        raise KssCommandException('Target storage pool does not exist. - pool=%s' % (opts.pool))

                    pool = conn.search_kvn_storage_pools(opts.pool)
                    storage_info = pool[0].get_info()
                    if storage_info["type"] == "dir" and storage_info["target"]["path"] != "":
                        target_dir = storage_info["target"]["path"]
                    else:
                        raise KssCommandException("Target storage pool type is not 'dir'. pool=%s" % (opts.pool))
                elif opts.dir:
                    target_dir = opts.dir

                self.up_progress(10)
                progresscb = None
                if opts.verbose:
                    try:
                        from karesansui.lib.progress import ProgressMeter
                        progresscb = ProgressMeter(command_object=self)
                    except:
                        pass
                else:
                    try:
                        from karesansui.lib.progress import ProgressMeter
                        progresscb = ProgressMeter(command_object=self,quiet=True)
                    except:
                        pass

                if opts.title[0:4] == "b64:":
                    title = base64_decode(opts.title[4:])
                else:
                    title = opts.title

                uuid = StrFromUUID(GenUUID())
                conn.export_guest(uuid=uuid,
                                  name=opts.name,
                                  directory=target_dir,
                                  database=database,
                                  realicon=model.realicon(),
                                  title=title,
                                  snapshots=snapshots,
                                  progresscb=progresscb)

                self.up_progress(40)
                self.logger.info('Export guest completed. - pool=%s, uuid=%s' % (opts.pool, uuid))
                print >>sys.stdout, _('Export guest completed. - pool=%s, uuid=%s' % (opts.pool, uuid))
                return True

            except KaresansuiVirtException, e:
                raise KssCommandException('Failed to export guest. - %s to %s [%s]' \
                                          % (opts.name,target_dir, ''.join(e.args)))

            except KssCommandException:
                raise

            except:
                raise KssCommandException('Failed to export guest. - %s to %s' \
                                          % (opts.name,target_dir))
        finally:
            conn.close()

if __name__ == "__main__":
    target = ExportGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = get_cpu_usage
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import time
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import gettimeofday
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

class GetCpuUsage(KssCommand):

    def process(self):
        conn = KaresansuiVirtConnection()
        try:
            guests = conn.search_guests()
    
            infos = []
            for guest in guests:
              id = guest.ID()
              if id > -1:
                name = guest.name()
                info = guest.info()
        
                now = gettimeofday()
                sec = now[0]
                usec = now[1]
                infos.append({"id": id, "cpu_time": info[4], "real_time_sec": long(sec), "real_time_usec": long(usec)})
    
            #print infos
            time.sleep(1.1)
    
            cnt = 0
            for guest in guests:
              id = guest.ID()
              if id > -1:
                name = guest.name()
                print name
                info = guest.info()
    
                now = gettimeofday()
                sec = now[0]
                usec = now[1]
    
                # calculate the usage of cpu
                #print infos[cnt]
                cpu_diff = (info[4] - infos[cnt]["cpu_time"]) / 10000
                #print info[4]
                #print infos[cnt]["cpu_time"]
                #print cpu_diff
    
                #real_diff = 1000 *(long(sec) - infos[cnt]["real_time_sec"]) + (usec - infos[cnt]["real_time_usec"])
                real_diff = ((long(sec) - infos[cnt]["real_time_sec"]) * 1000) + ((usec - infos[cnt]["real_time_usec"]) / 1000);
    
                #real_diff = 1000 *(sec - infos[cnt]["real_time_sec"])
                #real_diff2 = (usec - infos[cnt]["real_time_usec"])
    
                #print "realTime.tv_sec:%10ld" % sec
                #print "infos.real_time.tv_sec:%10ld" % infos[cnt]["real_time_sec"]
                #print "realTime.tv_usec:%10ld" % usec
                #print "infos.real_time.tv_usec:%10ld" % infos[cnt]["real_time_usec"]
                #print "real_diff:%10ld" % real_diff
                #print "cpu_diff:%10ld" % cpu_diff
    
                usage = cpu_diff / float(real_diff);  
                print "%.3f%%" % usage
     
                # print the results
                #printf("%d\t%.3f%\t%lu\t%lu\t%hu\t%0X\t%s\n", id, usage, info.memory / 1024,  
                #info.maxMem / 1024, info.nrVirtCpu, info.state, virDomainGetName(dom));  
                cnt = cnt + 1

                return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = GetCpuUsage()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = get_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command
    from karesansui.lib.iscsi import iscsi_parse_node, iscsi_parse_session, iscsi_print_format_node, \
        iscsi_check_node_status, iscsi_check_node_autostart, iscsi_get_auth_type, iscsi_get_auth_user
    from karesansui.lib.const import ISCSI_CMD, ISCSI_CMD_OPTION_MODE, \
        ISCSI_CMD_OPTION_MODE_NODE, ISCSI_CMD_OPTION_MODE_SESSION, ISCSI_CMD_RES_NO_NODE, \
        ISCSI_CMD_RES_NO_ACTIVE_SESSION

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-i', '--iqn', dest='iqn', help=_('IQN'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\._:-]")

    if opts.iqn:
        if reg.search(opts.iqn):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-i or --iqn', opts.iqn))

class GetIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        node_command_args = (ISCSI_CMD,
                             ISCSI_CMD_OPTION_MODE,
                             ISCSI_CMD_OPTION_MODE_NODE
                             )

        (node_rc, node_res) = execute_command(node_command_args)
        if node_rc != 0:
            for node_line in node_res:
                if node_line.lower().find(ISCSI_CMD_RES_NO_NODE) != -1:
                    self.logger.info("iSCSI node not found")
                    return True

            raise KssCommandException('Failed to get iSCSI node. message=%s' % (node_res))

        self.up_progress(20)
        session_command_args = (ISCSI_CMD,
                                ISCSI_CMD_OPTION_MODE,
                                ISCSI_CMD_OPTION_MODE_SESSION
                                )

        (session_rc, session_res) = execute_command(session_command_args)
        if session_rc != 0:
            raise KssCommandException('Failed to get iSCSI session. message=%s' % (session_res))

        self.up_progress(20)
        for node_line in node_res:
            if not node_line:
                continue

            try:
                node = iscsi_parse_node(node_line)
            except:
                self.logger.warn('Failed to parse iSCSI node command response. message="%s"' % (node_line))
                continue

            is_active = 0
            for session_line in session_res:
                if not session_line:
                    continue

                if session_line.find(ISCSI_CMD_RES_NO_ACTIVE_SESSION) != -1:
                    break

                try:
                    session = iscsi_parse_session(session_line)
                except:
                    self.logger.warn('Failed to parse iSCSI session command response. message="%s"' % (session_line))
                    continue

                if iscsi_check_node_status(node, session):
                    is_active = 1
                    break

            if iscsi_check_node_autostart(node):
                autostart = 0
            else:
                autostart = 1

            if opts.iqn is None:
                self.logger.info("%s %s %s" % (iscsi_print_format_node(node), is_active, autostart))
                print >>sys.stdout, _("%s %s %s") % (iscsi_print_format_node(node), is_active, autostart)
            else:
                if opts.iqn == node['iqn']:
                    auth = iscsi_get_auth_type(node)
                    user = iscsi_get_auth_user(node)

                    self.logger.info("%s %s %s %s %s" % (iscsi_print_format_node(node), is_active, autostart, auth, user))
                    print >>sys.stdout, _("%s %s %s %s %s") % (iscsi_print_format_node(node), is_active, autostart, auth, user)
                    break

        return True

if __name__ == "__main__":
    target = GetIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = get_memory_usage
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import time
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import gettimeofday
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

class GetMemoryUsage(KssCommand):

    def process(self):
        conn = KaresansuiVirtConnection()
        try:
            guests = conn.search_guests()
    
            nodeinfo = conn.get_nodeinfo()
            
            infos = []
            for guest in guests:
                id = guest.ID()
                if id > -1:
                    name = guest.name()
                    print name
                    info = guest.info()
                    maxMem = info[1]
                    memory = info[2]
                    
                    pcentCurrMem = memory * 100.0 / (nodeinfo["memory"]*1024)
                    pcentMaxMem  = maxMem * 100.0 / (nodeinfo["memory"]*1024)
                    
                    print "%.3f%%" % pcentCurrMem
                    #print pcentMaxMem
                    
            return True
        
        finally:
            conn.close()

if __name__ == "__main__":
    target = GetMemoryUsage()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = import_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import signal
import logging
from optparse import OptionParser
import glob

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.utils import load_locale
    from karesansui.lib.virt.config_export import ExportConfigParam

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-e', '--exportuuid',  dest='exportuuid',  help=_('Export UUID to import'))
    optp.add_option('-d', '--destuuid', dest='destuuid', help=_('Guest UUID to import'))
    optp.add_option('-q', '--quiet',dest='verbose', action="store_false", default=True, help=_("don't print status messages"))

    return optp.parse_args()

def chkopts(opts):
    if not opts.exportuuid:
        raise KssCommandOptException('ERROR: -e or --exportuuid option is required.')
    if not opts.destuuid:
        raise KssCommandOptException('ERROR: -d or --destuuid option is required.')

class ImportGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            progresscb = None
            if opts.verbose:
                try:
                    from karesansui.lib.progress import ProgressMeter
                    progresscb = ProgressMeter(command_object=self)
                except:
                    pass
            else:
                try:
                    from karesansui.lib.progress import ProgressMeter
                    progresscb = ProgressMeter(command_object=self,quiet=True)
                except:
                    pass

            try:
                #inactive_pool = conn.list_inactive_storage_pool()
                inactive_pool = []
                active_pool = conn.list_active_storage_pool()
                pools = inactive_pool + active_pool
                if not pools:
                    raise KssCommandException("Storage pool does not exist, or has been stopped.")
                pools.sort()

                export = []
                for pool_name in pools:
                    pool = conn.search_kvn_storage_pools(pool_name)
                    path = pool[0].get_info()["target"]["path"]
                    if os.path.exists(path):
                        for _afile in glob.glob("%s/*/info.dat" % (path,)):
                            e_param = ExportConfigParam()
                            e_param.load_xml_config(_afile)

                            if e_param.get_uuid() != opts.exportuuid:
                                continue

                            export.append({"dir" : os.path.dirname(_afile),
                                           "uuid" : opts.exportuuid,
                                           })

                if len(export) != 1:
                    raise KssCommandException("There are differences in the export data and real data. - uuid=%s" % opts.exportuuid)
                else:
                    export = export[0]

                if os.path.isdir(export["dir"]) is False:
                    raise KssCommandException("There is no real data. - dir=%s" % export["dir"])

                conn.import_guest(export["dir"], uuid=opts.destuuid, progresscb=progresscb)

                self.up_progress(40)
                self.logger.info('Import guest completed. - export=%s, dest=%s' % (opts.exportuuid, opts.destuuid))
                print >>sys.stdout, _('Import guest completed. - export=%s, dest=%s' % (opts.exportuuid, opts.destuuid))
                return True

            except KaresansuiVirtException, e:
                raise KssCommandException('Failed to import guest. - [%s]' \
                                      % (''.join(str(e.args))))
        finally:
            conn.close()

if __name__ == "__main__":
    target = ImportGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = initialize_collectd_conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import re
import time
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import copy_file
    from karesansui.lib.utils import execute_command
    from karesansui.lib.utils import preprint_r, base64_decode
    from karesansui.lib.collectd.config import initialize_collectd_settings, COLLECTD_PLUGINS
    from karesansui.lib.dict_op import DictOp

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()


"""
initialize_collectd_conf.py -T --post-command "/etc/init.d/collectd condrestart"
"""

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-q', '--quiet',dest='verbose', action="store_false", default=True, help=_("don't print status messages"))
    optp.add_option('-j', '--pre-command',  dest='pre_command',  default=None, help=_('Scriptlet to execute before writing.'))
    optp.add_option('-J', '--post-command',  dest='post_command',  default=None, help=_('Scriptlet to execute after writing.'))
    optp.add_option('-F', '--force',  dest='force',  action="store_true", default=False, help=_("Force to initialize. Reset to default value."))
    optp.add_option('-R', '--reverse',  dest='reverse',  action="store_true", default=False, help=_("Disable each plugin."))
    optp.add_option('-T', '--dry-run',  dest='dry_run',  action="store_true", default=False, help=_("Don't do anything, just test."))

    return optp.parse_args()

def chkopts(opts):
    pass

class InitializeCollectdConf(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(1)

        uniq_id = time.strftime("%Y%m%d%H%M%S", time.localtime())

        if opts.pre_command is not None:
            if opts.pre_command[0:4] == "b64:":
                command = base64_decode(opts.pre_command[4:])
            else:
                command = opts.pre_command
            self.logger.info("execute command - %s" % command)

            if opts.dry_run is True:
                print ""
                print ">>>Execute pre command: %s" % command
                print ""
            else:
                (_ret,_res) = execute_command(command.split())
                if _ret != 0:
                    error_msg = "execute error - %s" % command
                    self.logger.error(error_msg)
                    #raise KssCommandOptException("ERROR: %s" % error_msg)

        self.up_progress(5)

        from karesansui.lib.parser.collectd       import collectdParser
        from karesansui.lib.parser.collectdplugin import collectdpluginParser
        dop = DictOp()

        collectd_parser       = collectdParser()
        dop.addconf("collectd",collectd_parser.read_conf())

        collectdplugin_parser = collectdpluginParser()
        extra_args = {"include":"^(%s)$" % "|".join(COLLECTD_PLUGINS)}
        dop.addconf("collectdplugin",collectdplugin_parser.read_conf(extra_args=extra_args))

        initialize_collectd_settings(dop=dop,force=opts.force,reverse=opts.reverse)

        retval = collectd_parser.write_conf(dop.getconf("collectd"),dryrun=opts.dry_run)
        retval = collectdplugin_parser.write_conf(dop.getconf("collectdplugin"),extra_args=extra_args,dryrun=opts.dry_run)

        self.up_progress(30)

        if opts.post_command is not None:
            if opts.post_command[0:4] == "b64:":
                command = base64_decode(opts.post_command[4:])
            else:
                command = opts.post_command
            self.logger.info("execute command - %s" % command)

            if opts.dry_run is True:
                print ""
                print ">>>Execute post command: %s" % command
                print ""
            else:
                (_ret,_res) = execute_command(command.split())
                if _ret != 0:
                    error_msg = "execute error - %s" % command
                    self.logger.error(error_msg)
                    raise KssCommandOptException("ERROR: %s" % error_msg)

        self.up_progress(10)
        return True

if __name__ == "__main__":
    target = InitializeCollectdConf()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = karesansui_sysinfo
#!/usr/bin/env python
# -*- coding: utf-8 -*- 
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import time
import re
import os
import sys
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    import libvirt
    import libvirtmod
    from karesansui import __app__,__version__,__release__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import is_executable, execute_command
    from karesansui.lib.utils import available_virt_uris
    from karesansui.lib.utils import available_virt_mechs

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-a', '--all',  dest='all', action="store_true", help=_('Print all information'))
    optp.add_option('-i', '--node-info', action="store_true", dest='nodeinfo',help=_('Print node information'))
    optp.add_option('-l', '--list', action="store_true", dest='list',help=_('Print domain list'))
    optp.add_option('-n', '--net-list', action="store_true", dest='netlist',help=_('Print network list'))
    optp.add_option('-p', '--pool-list', action="store_true", dest='poollist',help=_('Print pool list'))
    return optp.parse_args()

COMMAND_VIRSH = "/usr/bin/virsh"
COMMAND_LIGHTTPD = "/usr/sbin/lighttpd"

prog_name = os.path.basename(__file__)

class SysInfo(KssCommand):

    def showKaresansuiVersion(self):
        print _("Using karesansui: %s %s.%s") %(__app__,__version__,__release__)
        (rc,res) = execute_command([COMMAND_LIGHTTPD,"-v"])
        if rc == 0:
            p = re.compile("lighttpd-([0-9\.]+) .*")
            if p.search(res[0]):
                lighttpdVersion = p.sub("\\1",res[0])
                print _("Using lighttpd: %s") %(lighttpdVersion)

        try:
            from pysilhouette import __app__      as pysilhouette_app
            from pysilhouette import __version__  as pysilhouette_ver
            from pysilhouette import __release__  as pysilhouette_rel
            print _("Using pysilhouette: %s %s.%s") %(pysilhouette_app,pysilhouette_ver,pysilhouette_rel)
        except:
            pass

    def process(self):
        (opts, args) = getopts()

        start_msg = _("Generated by %s on %s") % (prog_name,time.strftime("%Y/%m/%d %H:%M:%S", time.localtime()))
        print "# " + start_msg

        if is_executable(COMMAND_VIRSH):
            old_lang = os.environ.get('LANG')
            os.environ['LANG'] = "C"

            if opts.all is True or (opts.list is not True and opts.netlist is not True and opts.nodeinfo is not True and opts.poollist is not True):
                """ Show version """
                print ""
                print "## Version"
                (rc,res) = execute_command([COMMAND_VIRSH,"version"])
                if rc == 0:
                    for line in res:
                        if line != "":
                            print line
                self.showKaresansuiVersion()

            if opts.all is True:
                """ Show uri """
                print ""
                print "## URI"
                (rc,res) = execute_command([COMMAND_VIRSH,"uri"])
                if rc == 0:
                    print _("Connecting URI: %s") %(res[0])

                """ Show hostname """
                print ""
                print "## Hostname"
                (rc,res) = execute_command([COMMAND_VIRSH,"hostname"])
                if rc == 0:
                    print _("Hypervisor hostname: %s") %(res[0])

            if opts.all is True or opts.nodeinfo is True:
                """ Show nodeinfo """
                print ""
                print "## Node Information"
                (rc,res) = execute_command([COMMAND_VIRSH,"nodeinfo"])
                if rc == 0:
                    for line in res:
                        if line != "":
                            print line

            if opts.all is True or opts.list is True:
                """ Show dom list """
                print ""
                print "## Domain List"
                (rc,res) = execute_command([COMMAND_VIRSH,"list","--all"])
                if rc == 0:
                    for line in res:
                        if line != "":
                            print line

            if opts.all is True or opts.netlist is True:
                """ Show net list """
                print ""
                print "## Network List"
                (rc,res) = execute_command([COMMAND_VIRSH,"net-list","--all"])
                if rc == 0:
                    for line in res:
                        if line != "":
                            print line

            if opts.all is True or opts.poollist is True:
                """ Show pool list """
                print ""
                print "## Pool List"
                (rc,res) = execute_command([COMMAND_VIRSH,"pool-list","--all"])
                if rc == 0:
                    for line in res:
                        if line != "":
                            print line

            os.environ['LANG'] = old_lang
        else:
            try:
                conn = libvirt.openReadOnly(None)
                hypervisor = conn.getType()

                if opts.all is True or (opts.list is not True and opts.netlist is not True and opts.nodeinfo is not True and opts.poollist is not True):
                    """ Show version """
                    print ""
                    print "## Version"
                    ret = libvirtmod.virGetVersion(hypervisor)
                    libVersion = ret[0]
                    apiVersion = ret[1]

                    libVersion_major = libVersion / 1000000
                    libVersion %= 1000000
                    libVersion_minor = libVersion / 1000
                    libVersion_rel = libVersion % 1000
                    apiVersion_major = apiVersion / 1000000
                    apiVersion %= 1000000
                    apiVersion_minor = apiVersion / 1000
                    apiVersion_rel = apiVersion % 1000

                    print _("Using library: libvir %d.%d.%d") %(libVersion_major, libVersion_minor, libVersion_rel)
                    print _("Using API: %s %d.%d.%d") %(hypervisor, apiVersion_major, apiVersion_minor, apiVersion_rel)

                    try:
                        # See https://www.redhat.com/archives/libvir-list/2010-January/msg00723.html
                        ret = libvirtmod.virConnectGetVersion(conn._o)
                        hvVersion = ret
                        hvVersion_major = hvVersion / 1000000
                        hvVersion %= 1000000
                        hvVersion_minor = hvVersion / 1000
                        hvVersion_rel = hvVersion % 1000
                        print _("Running hypervisor: %s %d.%d.%d") %(hypervisor, hvVersion_major, hvVersion_minor, hvVersion_rel)
                    except:
                        if hypervisor == "QEMU":
                            (rc,res) = execute_command(["qemu","--version"])
                            if rc == 0:
                                p = re.compile("QEMU PC emulator version ([0-9\.]+),.*")
                                if p.search(res[0]):
                                    qemuVersion = p.sub("\\1",res[0])
                                    print _("Running hypervisor: %s %s") %(hypervisor, qemuVersion)

                    self.showKaresansuiVersion()

                if opts.all is True:
                    """ Show uri """
                    print ""
                    print "## URI"
                    uri = conn.getURI()
                    print _("Connecting URI: %s") %(uri)

                    """ Show hostname """
                    print ""
                    print "## Hostname"
                    hostname = conn.getHostname()
                    print _("Hypervisor hostname: %s") %(hostname)

                if opts.all is True or opts.nodeinfo is True:
                    """ Show nodeinfo """
                    print ""
                    print "## Node Information"
                    nodeInfo = conn.getInfo()
                    print "%-20s %s"    % (_("CPU model:")         ,nodeInfo[0])
                    print "%-20s %s"    % (_("CPU(s):")            ,nodeInfo[2])
                    print "%-20s %s MHz"% (_("CPU frequency:")     ,nodeInfo[3])
                    print "%-20s %s"    % (_("CPU socket(s):")     ,nodeInfo[5])
                    print "%-20s %s"    % (_("Core(s) per socket:"),nodeInfo[6])
                    print "%-20s %s"    % (_("Thread(s) per core:"),nodeInfo[7])
                    print "%-20s %s"    % (_("NUMA cell(s):")      ,nodeInfo[4])
                    print "%-20s %lu kB"% (_("Memory Size:")  ,(float)(nodeInfo[1])*1024)

                if opts.all is True or opts.list is True:
                    """ Show dom list """
                    print ""
                    print "## Domain List"
                    state_flags = [
                                  "no state",    # VIR_DOMAIN_NOSTATE
                                  "running",     # VIR_DOMAIN_RUNNING
                                  "idle",        # VIR_DOMAIN_BLOCKED
                                  "paused",      # VIR_DOMAIN_PAUSED
                                  "in shutdown", # VIR_DOMAIN_SHUTDOWN
                                  "shut off",    # VIR_DOMAIN_SHUTOFF
                                  "crashed",     # VIR_DOMAIN_CRASHED
                                  ]
                    #print "%3s %-20s %s" %(_("Id"), _("Name"), _("State"))
                    #print "----------------------------------"
                    print "%3s %-20s %-12s %-37s %-10s %-12s %-12s %-3s %-12s" %(_("Id"), _("Name"), _("State"), _("UUID"), _("Autostart"), _("MaxMem"), _("Memory"), _("Vcpus"), _("CPUTime"), )
                    print "---------------------------------------------------------------------------"

                    domains_ids = conn.listDomainsID()
                    for id in domains_ids:
                        dom = conn.lookupByID(id)
                        name    = dom.name()
                        domID   = id
                        domInfo = dom.info()
                        domUUID = dom.UUIDString()
                        domAutostart = dom.autostart()
                        if domAutostart == True:
                            locale_domAutostart = _("enable")
                        else:
                            locale_domAutostart = _("disable")
                        state = domInfo[0]
                        if domID == -1:
                            #print "%3s %-20s %s" %("-", name, state_flags[state])
                            print "%3s %-20s %-12s %-37s %-10s %-12ld %-12ld %-3d %-12ld" %("-", name, state_flags[state], domUUID, locale_domAutostart, domInfo[1], domInfo[2], domInfo[3], domInfo[4])
                        else:
                            #print "%3d %-20s %s" %(domID, name, state_flags[state])
                            print "%3d %-20s %-12s %-37s %-10s %-12ld %-12ld %-3d %-12ld" %(domID, name, state_flags[state], domUUID, locale_domAutostart, domInfo[1], domInfo[2], domInfo[3], domInfo[4])

                    defined_domains = conn.listDefinedDomains()
                    for name in defined_domains:
                        dom = conn.lookupByName(name)
                        #print dom.memoryStats()
                        domID   = dom.ID()
                        domInfo = dom.info()
                        domUUID = dom.UUIDString()
                        domAutostart = dom.autostart()
                        if domAutostart == True:
                            locale_domAutostart = _("enable")
                        else:
                            locale_domAutostart = _("disable")
                        state = domInfo[0]
                        if domID == -1:
                            #print "%3s %-20s %s" %("-", name, state_flags[state])
                            print "%3s %-20s %-12s %-37s %-10s %-12ld %-12ld %-3d %-12ld" %("-", name, state_flags[state], domUUID, locale_domAutostart, domInfo[1], domInfo[2], domInfo[3], domInfo[4])
                        else:
                            #print "%3d %-20s %s" %(domID, name, state_flags[state])
                            print "%3d %-20s %-12s %-37s %-10s %-12ld %-12ld %-3d %-12ld" %(domID, name, state_flags[state], domUUID, locale_domAutostart, domInfo[1], domInfo[2], domInfo[3], domInfo[4])

                if opts.all is True or opts.netlist is True:
                    """ Show net list """
                    print ""
                    print "## Network List"
                    #print "%-20s %-10s %-10s" %(_("Name"), _("State"), _("Autostart"))
                    #print "-----------------------------------------"
                    print "%-20s %-10s %-37s %-10s" %(_("Name"), _("State"), _("UUID"), _("Autostart"), )
                    print "--------------------------------------------------------------------------"
                    networks = conn.listNetworks()
                    for name in networks:
                        net = conn.networkLookupByName(name)
                        uuid = net.UUIDString()
                        autostart = net.autostart()
                        if autostart == True:
                            locale_autostart = _("yes")
                        else:
                            locale_autostart = _("no")

                        print "%-20s %-10s %-37s %-10s" %(name, _("Active"), uuid, locale_autostart)

                    defined_networks = conn.listDefinedNetworks()
                    for name in defined_networks:
                        net = conn.networkLookupByName(name)
                        uuid = net.UUIDString()
                        autostart = net.autostart()
                        if autostart == True:
                            locale_autostart = _("yes")
                        else:
                            locale_autostart = _("no")

                        print "%-20s %-10s %-37s %-10s" %(name, _("Inactive"), uuid, locale_autostart)

                if opts.all is True or opts.poollist is True:
                    """ Show pool list """
                    #taizoa
                    print ""
                    print "## Pool List"
                    print "%-20s %-10s %-37s %-10s" %(_("Name"), _("State"), _("UUID"), _("Autostart"), )
                    print "--------------------------------------------------------------------------"
                    pools = conn.listStoragePools()
                    for name in pools:
                        pool = conn.storagePoolLookupByName(name)
                        uuid = pool.UUIDString()
                        autostart = pool.autostart()
                        if autostart == True:
                            locale_autostart = _("yes")
                        else:
                            locale_autostart = _("no")

                        print "%-20s %-10s %-37s %-10s" %(name, _("Active"), uuid, locale_autostart)

                    defined_pools = conn.listDefinedStoragePools()
                    for name in defined_pools:
                        pool = conn.storagePoolLookupByName(name)
                        uuid = pool.UUIDString()
                        autostart = pool.autostart()
                        if autostart == True:
                            locale_autostart = _("yes")
                        else:
                            locale_autostart = _("no")

                        print "%-20s %-10s %-37s %-10s" %(name, _("Inactive"), uuid, locale_autostart)

            except:
                pass

        if opts.all is True:
            """ Show available uris """
            print ""
            print "## Available URIs"
            for mech,uri in available_virt_uris().iteritems():
               print uri

            """ Show available mechs """
            print ""
            print "## Available mechanisms"
            for mech in available_virt_mechs():
               print mech

            """ Show installed packages """
            print ""
            print "## Installed packages"
            (rc,res) = execute_command(["rpm","-qa",'--queryformat=%{NAME}\t%{VERSION}\t%{RELEASE}\t%{INSTALLTIME}\t%{BUILDHOST}\n'])
            if rc == 0:
                print "%-25s %-10s %-10s %-20s" %(_("Name"), _("Version"), _("Release"), _("InstallTime"), )
                print "------------------------------------------------------------------"
                p = re.compile("hde\.co\.jp")
                output = []
                for aline in res:
                    arr = aline.split("\t")
                    if p.search(arr[4]):
                        str = "%-25s %-10s %-10s %-20s" %(arr[0],arr[1],arr[2],time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(float(arr[3]))),)
                        output.append(str)
                print "\n".join(sorted(output))

        finish_msg = _("Completed on %s") % time.strftime("%Y/%m/%d %H:%M:%S", time.localtime())
        print ""
        print "# " + finish_msg

        return True

if __name__ == "__main__":
    target = SysInfo()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = ksscommand
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys
import os
import os.path
import traceback
import logging

from __cmd__ import karesansui_conf, search_path, pysilhouette_conf

# init -- read file
if os.path.isfile(karesansui_conf) is False:
    print >>sys.stderr, '[Error] karesansui : Initializing a database error - %s' % str(e)
    sys.exit(1)

for y in [x.strip() for x in search_path.split(',') if x]:
    if (y in sys.path) is False: sys.path.insert(0, y)

try:
    import karesansui
    import pysilhouette
except ImportError:
    print >>sys.stderr, '[Error] No libraries needed at runtime.(karesansui, pysilhouette)'
    sys.exit(1)

from pysilhouette.command import Command, CommandException
from os import environ as env

import karesansui.db
import karesansui.lib.log.logger
from karesansui.lib.file.k2v import K2V

class KssCommandException(CommandException):
    pass

class KssCommandOptException(KssCommandException):
    pass

class KssCommand(Command):

    def __init__(self):
        # --
        try:
            _k2v = K2V(karesansui_conf)
            karesansui.config = _k2v.read()
        except Exception, e:
            print >>sys.stderr, '[Error] Failed to load configuration file. - %s : msg=%s' % (karesansui_conf, str(e))
            sys.exit(1)

        karesansui.lib.log.logger.reload_conf(karesansui.config['application.log.config'])
        self.logger = logging.getLogger('karesansui.command')
        self.logger_trace = logging.getLogger('karesansui_trace.command')

        # PySilhouette - command.py#__init__()
        os.environ['PYSILHOUETTE_CONF'] = pysilhouette_conf
        Command.__init__(self)

        try:
            # Karesansui Database
            self.kss_db = karesansui.db.get_engine()
            self.kss_session = karesansui.db.get_session()
        except Exception, e:
            print >>sys.stderr, '[Error] KssCommand : Initializing a database error.'
            self.logger.error('Initializing a database error.')
            self.logger_trace.error(traceback.format_exc())
            sys.exit(1)

    def run(self):
        try:
            try:
                try:
                    if self._pre() is False:
                        raise KssCommandException("Error running in _pre().")
                    self.up_progress(10)

                    if self.process() is False:
                        raise KssCommandException("Error running in process().")
                    self.up_progress(10)

                    if self._post() is False:
                        raise KssCommandException("Error running in _post().")

                    self.up_progress(100)
                    return 0

                except KssCommandOptException, e:
                    self.logger.error("Karesansui : Command option error - %s" % str(e))
                    print >>sys.stderr, "Karesansui : Command option error - %s" % str(e)
                    return 2

                except KssCommandException, e:
                    self.logger.error("Karesansui : Command execution error - %s" % str(e))
                    print >>sys.stderr, "Karesansui : Command execution error - %s" % str(e)
                    raise

                except SystemExit, e:
                    self.session.rollback() # pysilhouette
                    self.kss_session.rollback()
                    return e.code

                except KeyboardInterrupt, e:
                    self.logger.error("Aborted by user request.")
                    print >> sys.stderr, _("Aborted by user request.")
                    raise

            except Exception, e:
                #logging.exception(e)
                self.session.rollback() # pysilhouette
                self.kss_session.rollback()
                print >> sys.stderr, str(e)
                self.logger_trace.error(traceback.format_exc())
                return 1

        finally:
            self.session.commit() # pysilhouette
            self.kss_session.commit()

########NEW FILE########
__FILENAME__ = ready_mount
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
import fcntl
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command, pipe_execute_command, generate_phrase, get_filesystem_info
    from karesansui.lib.const import KARESANSUI_TMP_DIR, MOUNT_CMD, UMOUNT_CMD, FORMAT_CMD, YES_CMD

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-d', '--dev', dest='dev', help=_('Target device'), default=None)
    optp.add_option('-t', '--type', dest='type', help=_('Format type'), default="ext3")
    optp.add_option('-f', '--format', dest='format', action="store_true", help=_('Format on mount failed'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.dev:
        if reg.search(opts.dev):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-d or --dev', opts.dev))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-d or --dev')

    if opts.type not in get_filesystem_info():
        raise KssCommandOptException('ERROR: Unknown format type. type=%s' % (opts.type))

class ReadyMount(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        try:
            tmp_dir_name = generate_phrase(12,'abcdefghijklmnopqrstuvwxyz')
            tmp_dir_path = "%s/%s" % (KARESANSUI_TMP_DIR, tmp_dir_name)
            os.mkdir(tmp_dir_path)
        except:
            raise KssCommandException('Failed to make tmpdir. path=%s' % (tmp_dir_path))

        try:
            self.up_progress(10)
            mount_command_args = (MOUNT_CMD,
                                  opts.dev,
                                  tmp_dir_path,
                                  )
            umount_command_args = (UMOUNT_CMD,
                                   tmp_dir_path,
                                   )

            is_mountable = False
            try:
                (mount_cmd_rc, mount_cmd_res) = execute_command(mount_command_args)
                if mount_cmd_rc == 0:
                    is_mountable = True
                else:
                    self.logger.debug('Failed to mount. dev=%s' % (opts.dev))
            finally:
                (umount_cmd_rc, umount_cmd_res) = execute_command(umount_command_args)

            self.up_progress(30)
            if is_mountable is False and opts.format is True:
                first_command_args = YES_CMD
                second_command_args = (FORMAT_CMD,
                                       "-t",
                                       opts.type,
                                       opts.dev,
                                       )
                format_command_args = (first_command_args,
                                       second_command_args,
                                       )

                (format_cmd_rc, format_cmd_res) = pipe_execute_command(format_command_args)
                if format_cmd_rc != 0:
                    raise KssCommandException('Failed to format. dev=%s type=%s res=%s' % (opts.dev, opts.type, format_cmd_res))

                try:
                    (mount_cmd_rc, mount_cmd_res) = execute_command(mount_command_args)
                    if mount_cmd_rc == 0:
                        is_mountable = True
                    else:
                        self.logger.debug('Failed to mount. dev=%s' % (opts.dev))
                finally:
                    (umount_cmd_rc, umount_cmd_res) = execute_command(umount_command_args)

            self.up_progress(40)

        finally:
            try:
                os.rmdir(tmp_dir_path)
            except:
                raise KssCommandException('Failed to delete tmpdir. path=%s' % (tmp_dir_path))

        if is_mountable is True:
            self.logger.info('Device "%s" is mountable.' % (opts.dev))
            print >>sys.stdout, _('Device "%s" is mountable.' % (opts.dev))
        else:
            self.logger.info('Device "%s" is not mountable.' % (opts.dev))
            print >>sys.stdout, _('Device "%s" is not mountable.' % (opts.dev))

        return is_mountable

if __name__ == "__main__":
    target = ReadyMount()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = read_conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import re
import time
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import preprint_r
    from karesansui.lib.dict_op import DictOp
    from karesansui.lib.file.configfile import ConfigFile
    from karesansui.lib.utils import python_dict_to_php_array

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-m', '--module', dest='module', help=_('Module name'))
    optp.add_option('-o', '--output-file',  dest='file',  help=_('Output file name'))
    optp.add_option('-R', '--raw',  dest='raw', action="store_true", default=False, help=_('Print by raw format'))
    optp.add_option('-P', '--php',  dest='php', action="store_true", default=False, help=_('Print by php format'))
    optp.add_option('-q', '--quiet',dest='verbose', action="store_false", default=True, help=_("don't print status messages"))
    optp.add_option('-H', '--host', dest='host', help=_('Host name'))
    optp.add_option('-U', '--auth-user',  dest='auth_user',  help=_('Auth user name'))
    optp.add_option('-W', '--auth-password-file',  dest='auth_password_file',  help=_('Read auth password from file'))
    optp.add_option('-I', '--include', dest='include', help=_('Include key'), default=None)

    return optp.parse_args()

def chkopts(opts):
    if not opts.module:
        raise KssCommandOptException("ERROR: -m or --module option is required.")

    modules = opts.module.split(":")
    for _mod in modules:
        try:
            exec("from karesansui.lib.parser.%s import %sParser" % (_mod,_mod,))
        except:
            raise KssCommandOptException("ERROR: module not found. - %s" % opts.module)

    if not opts.file:
        opts.file = "/dev/stdout"
        for _cnt in range(1,len(modules)):
            opts.file = "%s:/dev/stdout" % opts.file

    files = opts.file.split(":")

    if len(modules) != len(files):
        raise KssCommandOptException("ERROR: not same number of modules and files. - module:%d file:%d" % (len(modules),len(files),))

    if opts.raw is True and opts.php is True:
        raise KssCommandOptException("ERROR: cannot specify --raw and --php option at same time.")


class ReadConf(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(1)

        dop = DictOp()
        modules = opts.module.split(":")
        files   = opts.file.split(":")

        retval = True
        cnt = 0
        for _mod in modules:
            _file = files[cnt]
            try:
                exec("from karesansui.lib.parser.%s import %sParser as Parser" % (_mod,_mod,))

                self.up_progress(5)
                parser = Parser()

                self.up_progress(5)
                if opts.raw is True:
                    raw_str = "Config_Raw_%s = {}\n" % (_mod,)
                    for _src in parser.source_file():
                        raw_str = "%sConfig_Raw_%s['%s'] = \"\"\"%s\"\"\"\n" % (raw_str,_mod,_src,open(_src).read())
                    ConfigFile(_file).write(raw_str)

                else:
                    # 設定ファイルの読み込み
                    extra_args = {}
                    extra_args["include"] = opts.include
                    conf_arr = parser.read_conf(extra_args=extra_args)
                    dop.addconf(_mod,conf_arr)
                    #dop.preprint_r(_mod)

                    # 辞書配列ファイルに書き込み
                    _var = "Config_Dict_%s" % (_mod,)
                    if opts.php is True:
                        _str = python_dict_to_php_array(dop.getconf(_mod),_var)
                        ConfigFile(_file).write(_str)
                    else:
                        ConfigFile(_file).write("%s = %s\n" % (_var,str(dop.getconf(_mod)),))

            finally:
                cnt = cnt + 1

        self.up_progress(10)
        return True

if __name__ == "__main__":
    target = ReadConf()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = reboot_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import fcntl
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                                         KaresansuiVirtConnectionAuth, \
                                         VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTDOWN
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import uri_split, uri_join

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-c', '--connection', dest='uri', help=_('Connection URI'), default=None)
    optp.add_option('-w', '--passwd-file', dest='passwd_file', help=_('Password File for URI Connection'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

    if opts.passwd_file is not None and not os.path.exists(opts.passwd_file):
        raise KssCommandOptException('ERROR: %s is not found.' % opts.passwd_file)

    if opts.uri is not None:
        if uri_split(opts.uri)["scheme"] is None:
            raise KssCommandOptException('ERROR: uri %s is invalid.' % opts.uri)

class RebootGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        passwd = None
        if opts.passwd_file is not None and os.path.exists(opts.passwd_file):
            try:
                fp = open(opts.passwd_file, "r")
                try:
                    self.up_progress(10)
                    fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                    try:
                        passwd = fp.readline().strip("\n")
                    finally:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
                    self.up_progress(10)
                finally:
                    fp.close()

            except Exception, e:
                self.logger.error('Failed to read.- dom=%s passwd_file=%s' \
                      % (opts.name,opts.passwd_file))
                print >>sys.stderr,_('Failed to read.- dom=%s passwd_file=%s') \
                      % (opts.name,opts.passwd_file)
                raise e

            os.remove(opts.passwd_file)

        try:
            if passwd is None:
                if opts.uri is None:
                    conn = KaresansuiVirtConnection(readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnection(uri, readonly=False)

            else:
                if opts.uri is None:
                    conn = KaresansuiVirtConnectionAuth(creds=passwd,readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnectionAuth(uri,creds=passwd,readonly=False)

            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.reboot_guest()
                    self.up_progress(30)
                except Exception, e:
                    self.logger.error('Failed to reboot guest. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to reboot guest. - dom=%s') % (opts.name)
                    raise e

                self.up_progress(10)
                status = conn.guest.status()
                self.up_progress(10)
                if status != VIR_DOMAIN_SHUTOFF and status != VIR_DOMAIN_SHUTDOWN:
                    self.logger.info('Succeeded to reboot guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Succeeded to reboot guest. - dom=%s') % (opts.name)

            else:
                raise KssCommandException(
                    'guest not found. - dom=%s' % (opts.name))

            return True

        finally:
            if 'conn' in locals():
                conn.close()

if __name__ == "__main__":
    target = RebootGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = replicate_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
<comment-ja>
すべてのディスクがfile形式のみ実行可能です。
</comment-ja>
<comment-en>
The only executable file format all disks.
</comment-en>
"""

import os
import os.path
import sys
import re
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, is_uuid
    from karesansui.lib.const import PORT_MIN_NUMBER, PORT_MAX_NUMBER

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-s', '--src-name', dest='src_name', help=_('Source domain name'))
    optp.add_option('-d', '--dest-name', dest='name', help=_('Destination domain name'))
    optp.add_option('-v', '--graphics-port', dest='graphics_port', help=_('Graphics Port Number'), default=None)
    optp.add_option('-u', '--uuid', dest='uuid', help=_('UUID'), default=None)
    optp.add_option('-a', '--mac', dest='mac', help=_('MAC Address'), default=None)
    optp.add_option('-p', '--pool', dest='pool', help=_('Destination storage pool'))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-d or --dest-name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-d or --dest-name')

    if opts.src_name:
        if reg.search(opts.src_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-s or --src-name', opts.src_name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-s or --src-name')

    if opts.pool:
        if reg.search(opts.pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --pool', opts.pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --pool')

    if opts.graphics_port:
        reg = re.compile("^[0-9]{1,5}$")
        if not reg.match(opts.graphics_port):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-v or --graphics-port', opts.graphics_port))
        if int(opts.graphics_port) < PORT_MIN_NUMBER or PORT_MAX_NUMBER < int(opts.graphics_port):
            raise KssCommandOptException('ERROR: Illigal port number. port=%s' % (opts.graphics_port))

    if opts.mac:
        reg = re.compile("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$")
        if not reg.match(opts.mac):
            raise KssCommandOptException('ERROR: Illigal MAC address. mac=%s' % (opts.mac))

    if opts.uuid:
        if not is_uuid(opts.uuid):
            raise KssCommandOptException('ERROR: Illigal UUID. uuid=%s' % (opts.uuid))

class ReplicateGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            # dest storage pool
            dest_target_path = conn.get_storage_pool_targetpath(opts.pool)
            if not dest_target_path:
                raise KssCommandException(
                    "Could not get the target path of the storage pool. - path=%s" % dest_target_path)

            self.dest_disk = "%s/%s/images/%s.img" \
                             % (dest_target_path, opts.name,opts.name,)

            # source storage pool
            src_pool = conn.get_storage_pool_name_bydomain(opts.src_name, "os")
            if not src_pool:
                raise KssCommandException("Source storage pool is not found.")
            src_pool_type = conn.get_storage_pool_type(src_pool)
            if src_pool_type == 'dir':
                raise KssCommandException(
                    "Storage pool type 'dir' is not. - type=%s" % src_pool_type)

            src_target_path = conn.get_storage_pool_targetpath(src_pool[0])
            self.src_disk  = "%s/%s/images/%s.img" \
                             % (src_target_path, opts.src_name,opts.src_name,)

            if os.path.isfile(self.src_disk) is False:
                raise KssCommandException(
                    'source disk image is not found. - src=%s' % (self.src_disk))

            if os.path.isfile(self.dest_disk) is True:
                raise KssCommandException(
                    'destination disk image already exists. - dest=%s' % (self.dest_disk))

            self.up_progress(10)

            active_storage_pools = conn.list_active_storage_pool()
            self.up_progress(10)
            if not (opts.pool in active_storage_pools):
                raise KssCommandException('Storage pool does not exist. - pool=%s'
                                          % (opts.pool))

            try:
                active_guests = conn.list_active_guest()
                inactive_guests = conn.list_inactive_guest()
                # source guestos
                if not (opts.src_name in active_guests or opts.src_name in inactive_guests):
                    raise KssCommandException(
                        "Unable to get the source guest OS. - src_name=%s" % opts.src_name)

                if (opts.name in active_guests or opts.name in inactive_guests):
                    raise KssCommandException(
                        "Destination Guest OS is already there. - dest_name=%s" % opts.name)

                self.up_progress(10)

                conn.replicate_guest(opts.name,
                                     opts.src_name,
                                     opts.pool,
                                     opts.mac,
                                     opts.uuid,
                                     opts.graphics_port)
                self.up_progress(40)
            except:
                self.logger.error('Failed to replicate guest. - src=%s dom=%s' % (opts.src_name,opts.name))
                raise
        finally:
            conn.close()

        conn1 = KaresansuiVirtConnection(readonly=False)
        try:
            self.up_progress(10)
            active_guests = conn1.list_active_guest()
            inactive_guests = conn1.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                self.logger.info('Replicated guest. - src=%s dom=%s' % (opts.src_name,opts.name))
                print >>sys.stdout, _('Replicated guest. - src=%s dom=%s') % (opts.src_name,opts.name)
                return True
            else:
                raise KssCommandException(
                    'Replicate guest not found. - src=%s dom=%s' % (opts.src_name,opts.name))
        finally:
            conn1.close()

        return True

    """
    def sigusr1_handler(self, signum, frame):
        if os.path.exists(self.src_disk) and os.path.exists(self.dest_disk):
            s_size = os.path.getsize(self.src_disk)
            d_size = os.path.getsize(self.dest_disk)
            print int(d_size*100/s_size)
    """
    """
    def sigint_handler(self, signum, frame):
        if os.path.exists(self.dest_disk):
            os.unlink(self.dest_disk)
        self.logger.error('Aborted by user request.')
        print >> sys.stderr, _("Aborted by user request.")
        raise ""
    """

if __name__ == "__main__":
    target = ReplicateGuest()
    #signal.signal(signal.SIGUSR1, target.sigusr1_handler)
    #signal.signal(signal.SIGINT,  target.sigint_handler)
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = replicate_storage_volume
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
<comment-ja>
Volumeがfile形式のみ実行可能です。
</comment-ja>
<comment-en>
You can only file format the volume.
</comment-en>
"""

import os
import os.path
import sys
import re
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, chk_create_disk

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)

    #optp.add_option('-u', '--uuid', dest='uuid', help=_('Destination UUID'))
    optp.add_option('-n', '--orig_name', dest='orig_name', help=_('Original Domain Name'))
    optp.add_option('-p', '--orig_pool', dest='orig_pool', help=_('Original storage pool'))
    optp.add_option('-v', '--orig_volume', dest='orig_volume', help=_('Original storage volume'))
    optp.add_option('-N', '--dest_name', dest='dest_name', help=_('Destination Domain Name'))
    optp.add_option('-P', '--dest_pool', dest='dest_pool', help=_('Destination storage pool'))
    optp.add_option('-V', '--dest_volume', dest='dest_volume', help=_('Destination storage volume'))
    optp.add_option('-d', '--debug', dest='debug', action="store_true",help=_('Debug Option'))

    return optp.parse_args()

def chkopts(opts):
    #if not opts.uuid:
    #    raise KssCommandOptException('ERROR: -u or --uuid option is required.')

    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.orig_name:
        if reg.search(opts.orig_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --orig_name', opts.orig_name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --orig_name')

    if opts.orig_pool:
        if reg.search(opts.orig_pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-p or --orig_pool', opts.orig_pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-p or --orig_pool')

    if opts.orig_volume:
        if reg.search(opts.orig_volume):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-v or --orig_volume', opts.orig_volume))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-v or --orig_volume')

    if opts.dest_name:
        if reg.search(opts.dest_name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-N or --dest_name', opts.dest_name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-N or --dest_name')

    if opts.dest_pool:
        if reg.search(opts.dest_pool):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-P or --dest_pool', opts.dest_pool))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-P or --dest_pool')

    if opts.dest_volume:
        if reg.search(opts.dest_volume):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-V or --dest_volume', opts.dest_volume))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-V or --dest_volume')

class ReplicateStorageVolume(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            try:
                self.up_progress(10)
                progresscb = None
                if opts.debug is True:
                    try:
                        from karesansui.lib.progress import ProgressMeter
                        progresscb = ProgressMeter(command_object=self)
                    except:
                        pass
                else:
                    try:
                        from karesansui.lib.progress import ProgressMeter
                        progresscb = ProgressMeter(command_object=self,quiet=True)
                    except:
                        pass

                vol_obj = conn.get_storage_volume(opts.orig_pool, opts.orig_volume)
                if vol_obj is None:
                    raise KssCommandException(
                        'Specified storage volume does not exist. - pool=%s, vol=%s'
                        % (opts.orig_pool, opts.orig_volume))

                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()
                if not (opts.dest_pool in active_storage_pools or \
                            opts.dest_pool in inactive_storage_pools):
                    raise KssCommandException('Destination storage pool does not exist. - pool=%s'
                                              % (opts.dest_pool))

                vol_info = vol_obj.info()
                if vol_info[0] != 0:
                    raise KssCommandException(
                        'Specified storage volume does not "file" type. - pool=%s, vol=%s'
                        % (opts.orig_pool, opts.orig_volume))

                filesize = vol_info[1] / (1024 * 1024) # a unit 'MB'
                target_path = conn.get_storage_pool_targetpath(opts.dest_pool)
                if chk_create_disk(target_path, filesize) is False:
                    raise KssCommandException(
                        'Destination storage pool shortage capacity. - pool=%s'
                        % (opts.dest_pool))

                if conn.replicate_storage_volume(opts.orig_name,
                                                 opts.orig_pool,
                                                 opts.orig_volume,
                                                 opts.dest_name,
                                                 opts.dest_pool,
                                                 opts.dest_volume,
                                                 progresscb) is False:

                    raise KssCommandException(_("Failed to copy storage volume."))
                self.up_progress(40)
                self.logger.info('Replicate storage volume. - orig_pool=%s, orig_vol=%s, dest_pool=%s' % (opts.orig_pool, opts.orig_volume, opts.dest_pool))
                print >>sys.stdout, _('Replicate storage volume. - orig_pool=%s, orig_vol=%s, dest_pool=%s' % (opts.orig_pool, opts.orig_volume, opts.dest_pool))
                return True
            except Exception, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = ReplicateStorageVolume()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = restart_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.const import NETWORK_IFCONFIG_COMMAND, NETWORK_BRCTL_COMMAND
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import execute_command

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    optp.add_option('-f', '--force', dest='force', action="store_true", help=_('Do everything to bring up network'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class RestartNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if not (opts.name in active_networks or opts.name in inactive_networks):
                raise KssCommandException('Could not find the specified network. - net=%s' % (opts.name))

            self.up_progress(10)
            try:
                conn.stop_network(opts.name)
            except KaresansuiVirtException, e:
                if opt.force is not True:
                    raise KssCommandException('Could not stop the specified network. - net=%s' % (opts.name))

            self.up_progress(20)

            try:
                conn.start_network(opts.name)
            except KaresansuiVirtException, e:
                if opts.force is not True:
                    raise KssCommandException('Could not start the specified network. - net=%s' % (opts.name))

                # try to bring down existing bridge
                kvn = conn.search_kvn_networks(opts.name)[0]
                try:
                    bridge_name = kvn.get_info()['bridge']['name']
                except KeyError:
                    pass

                ret, res = execute_command([NETWORK_IFCONFIG_COMMAND, bridge_name, 'down'])
                ret, res = execute_command([NETWORK_BRCTL_COMMAND, 'delbr', bridge_name])

                # try again
                conn.start_network(opts.name)

            self.up_progress(10)
            if not (opts.name in conn.list_active_network()):
                raise KssCommandException('Failed to start network. - net=%s' % (opts.name))

            self.logger.info('Restarted network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Restarted network. - net=%s') % (opts.name)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = RestartNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = restart_network_interface
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
import fcntl
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command
    from karesansui.lib.const import NETWORK_COMMAND

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    return optp.parse_args()

def chkopts(opts):
    return True

class RestartNetworkInterface(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        network_restart_cmd = (NETWORK_COMMAND,
                               "restart",
                               )
        (rc, res) = execute_command(network_restart_cmd)
        if rc != 0:
            raise KssCommandException('Failure restart network.')

        return True

if __name__ == "__main__":
    target = RestartNetworkInterface()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = restart_service
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.service.config import ServiceConfigParam
    from karesansui.lib.service.sysvinit_rh import SysVInit_RH
    from karesansui.lib.const import SERVICE_XML_FILE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Service name'))
    return optp.parse_args()

def chkopts(opts):
    if opts.name is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class RestartService(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)
        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        service = config.findby1service(opts.name)
        self.up_progress(10)
        sysv = SysVInit_RH(service['system_name'], service['system_command'])

        if sysv.restart(force=False) is False:
            raise KssCommandException(str(sysv.error_msg))

        self.up_progress(50)
        self.logger.info('Restarted service. - service=%s' % (opts.name))
        print >>sys.stdout, _('Restarted service. - service=%s') % (opts.name)
        
        return True

if __name__ == "__main__":
    target = RestartService()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = restore_firewall
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.firewall.iptables import KaresansuiIpTables
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-a', '--action', dest='action', help=_('Action'), default=None)
    return optp.parse_args()

def chkopts(opts):
    pass

class RestoreFirewall(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        kit = KaresansuiIpTables()
        try:
            kit.firewall_xml__to__iptables_config()
            self.up_progress(10)
        except:
            self.logger.error("Cannot write '%s'." % (kit.iptables_conf_file))
            raise

        self.up_progress(10)
        if opts.action is not None:
            try:
                exec("func = kit.%s" % opts.action)
                self.up_progress(10)
                ret = func()
                if ret != 0:
                    return False
                self.up_progress(30)
            except:
                self.logger.error("Unknown action '%s'." % (opts.action))
                raise

        return True

if __name__ == "__main__":
    target = RestoreFirewall()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = resume_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                 VIR_DOMAIN_PAUSED
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

class ResumeGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)
            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.resume_guest()
                    self.up_progress(30)
                except Exception, e:
                    self.logger.error('Failed to resume guest. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to resume guest. - dom=%s') % (opts.name)
                    raise e

                self.up_progress(10)
                status = conn.guest.status()
                self.up_progress(10)
                if status != VIR_DOMAIN_PAUSED:
                    self.logger.info('Succeeded to resume guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Succeeded to resume guest. - dom=%s') % (opts.name)

            else:
                self.logger.error('Guest not found. - dom=%s' % (opts.name))
                print >>sys.stderr, _('Guest not found. - dom=%s') % (opts.name)
                return False

            return True

        finally:
            conn.close()

if __name__ == "__main__":
    target = ResumeGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = save_firewall
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.firewall.iptables import KaresansuiIpTables
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    return optp.parse_args()

def chkopts(opts):
    pass

class SaveFirewall(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        kit = KaresansuiIpTables()
        self.up_progress(20)
        kit.firewall_xml__from__iptables_config()
        self.up_progress(30)

        return True

if __name__ == "__main__":
    target = SaveFirewall()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = set_graphics
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
import fcntl
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale, generate_phrase
    from karesansui.lib.const import DEFAULT_KEYMAP

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-P', '--passwd', dest='passwd', help=_('Graphics Password'), default=None)
    optp.add_option('-w', '--passwd-file', dest='passwd_file', help=_('Graphics Password File'), default=None)
    optp.add_option('-W', '--random-passwd', dest='random_passwd', action="store_true", help=_('Set random Graphics password'))
    optp.add_option('-p', '--port', dest='port', help=_('Graphics Port Number'), default=None)
    optp.add_option('-l', '--listen', dest='listen', help=_('Graphics Listen Address'), default='0.0.0.0')
    optp.add_option('-k', '--keymap', dest='keymap', help=_('Graphics Keyboard Map'), default=DEFAULT_KEYMAP)
    optp.add_option('-t', '--type', dest='type', help=_('Graphics Service Type'), default='vnc')
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')
    if opts.passwd_file is not None and not os.path.exists(opts.passwd_file):
        raise KssCommandOptException('ERROR: %s is not found.' % opts.passwd_file)
    if opts.passwd != None and opts.passwd_file != None and opts.random_passwd != None:
        raise KssCommandOptException('ERROR: %s options are conflicted.' % '--passwd, --passwd-file and --random-passwd')

class SetGraphics(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            passwd = None
            if opts.passwd is not None:
                passwd = opts.passwd
            elif opts.passwd_file is not None and os.path.exists(opts.passwd_file):
                try:
                    fp = open(opts.passwd_file, "r")
                    try:
                        self.up_progress(10)
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                        try:
                            passwd = fp.readline().strip("\n")
                        finally:
                            fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)

                        self.up_progress(10)
                    finally:
                        fp.close()

                except Exception, e:
                    self.logger.error('Failed to read file. - dom=%s passwd_file=%s' \
                                      % (opts.name,opts.passwd_file))
                    print >>sys.stderr, _('Failed to read file. - dom=%s passwd_file=%s') \
                          % (opts.name,opts.passwd_file)
                    raise e

                os.remove(opts.passwd_file)
                self.up_progress(10)

            elif opts.random_passwd and opts.random_passwd is not None:
                passwd = generate_phrase(8,'23456789abcdefghijkmnpqrstuvwxyz')

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:

                try:
                    self.up_progress(10)
                    conn.guest.set_graphics(port=opts.port,
                                       listen=opts.listen,
                                       passwd=passwd,
                                       keymap=opts.keymap,
                                       type=opts.type)
                    self.up_progress(20)
                    info = conn.guest.get_graphics_info()
                    self.up_progress(10)

                    self.logger.info('Set graphics. - dom=%s type=%s port=%s listen=%s passwd=%s keymap=%s' \
                                     % (opts.name, info['setting']['type'], info['setting']['port'], info['setting']['listen'],"xxxxxx", info['setting']['keymap']))
                    print >>sys.stdout, _('Set graphics. - dom=%s type=%s port=%s listen=%s passwd=%s keymap=%s') \
                          % (opts.name, info['setting']['type'], info['setting']['port'], info['setting']['listen'],"xxxxxx", info['setting']['keymap'])

                except Exception, e:
                    self.logger.error('Failed to set graphics. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to set graphics. - dom=%s') % (opts.name)
                    raise e

            else:
                raise KssCommandException('guest not found. - dom=%s' % (opts.name))

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = SetGraphics()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = set_mac_address
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-f', '--from', dest='old', help=_('Original MAC Address'))
    optp.add_option('-t', '--to', dest='new', help=_('New MAC Address'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')
    if not opts.old:
        raise KssCommandOptException('ERROR: %s option is required.' % '-f or --from')
    if not opts.new:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --to')

class SetMAC(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)
            self.up_progress(10)
            conn.guest.modify_mac_address(opts.old,opts.new)
            self.up_progress(40)
            self.logger.info('Set MAC address. - dom=%s from=%s to=%s' % (opts.name,opts.old, opts.new))
            print >>sys.stdout, _('Set MAC address. - dom=%s from=%s to=%s') % (opts.name, opts.old, opts.new)
            return True

        finally:
            conn.close()

if __name__ == "__main__":
    target = SetMAC()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = set_memory
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-s', '--memory', dest='memory', help=_('Memory Size (MB)'), default=None)
    optp.add_option('-m', '--maxmem', dest='maxmem', help=_('Maximum Memory Size (MB)'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class SetMemory(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        if opts.maxmem:
            opts.maxmem = str(opts.maxmem) + 'm'
        if opts.memory:
            opts.memory = str(opts.memory) + 'm'

        self.up_progress(10)
        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.guest.set_memory(opts.maxmem,opts.memory)
                    self.up_progress(20)
                    info = conn.guest.get_info()
                    self.up_progress(10)

                    self.logger.info('Set memory size. - dom=%s max=%d mem=%d' \
                                     % (opts.name, info['maxMem'], info['memory']))
                    print >>sys.stdout, _('Set memory size. - dom=%s max=%d mem=%d') \
                          % (opts.name, info['maxMem'], info['memory'])

                except Exception, e:
                    self.logger.error('Failed to set memory size. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to set memory size. - dom=%s') % (opts.name)
                    raise e

            else:
                raise KssCommandException('guest not found. - dom=%s' % (opts.name))

            return True
        finally:
            conn.close()


if __name__ == "__main__":
    target = SetMemory()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = set_vcpus
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-c', '--vcpus', dest='vcpus', help=_('Number of virtual CPUs'), default=None)
    optp.add_option('-m', '--max-vcpus', dest='max_vcpus', help=_('Maximum number of virtual CPUs'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class SetVcpus(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.guest.set_vcpus(vcpus=opts.vcpus,max_vcpus=opts.max_vcpus)
                    self.up_progress(20)
                    info = conn.guest.get_vcpus_info()
                    self.up_progress(10)

                    self.logger.info('Set vcpus. - dom=%s vcpus=%s max_vcpus=%s bootup_vcpus=%s' \
                                     % (opts.name, info['vcpus'], info['max_vcpus'], info['bootup_vcpus']))
                    print >>sys.stdout, _('Set vcpus. - dom=%s vcpus=%s max_vcpus=%s bootup_vcpus=%s') \
                          % (opts.name, info['vcpus'], info['max_vcpus'], info['bootup_vcpus'])

                except Exception, e:
                    self.logger.error('Failed to set vcpus. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to set vcpus. - dom=%s') % (opts.name)
                    raise e

            else:
                raise KssCommandException('guest not found. - dom=%s' % (opts.name))

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = SetVcpus()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = shutdown_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import fcntl
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                                         KaresansuiVirtConnectionAuth, \
                                         VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTDOWN
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import uri_split, uri_join

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-f', '--force', dest='force', action="store_true", help=_('Do everything to bring up network'))
    optp.add_option('-c', '--connection', dest='uri', help=_('Connection URI'), default=None)
    optp.add_option('-w', '--passwd-file', dest='passwd_file', help=_('Password File for URI Connection'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

    if opts.passwd_file is not None and not os.path.exists(opts.passwd_file):
        raise KssCommandOptException('ERROR: %s is not found.' % opts.passwd_file)

    if opts.uri is not None:
        if uri_split(opts.uri)["scheme"] is None:
            raise KssCommandOptException('ERROR: uri %s is invalid.' % opts.uri)

class ShutdownGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        passwd = None
        if opts.passwd_file is not None and os.path.exists(opts.passwd_file):
            try:
                fp = open(opts.passwd_file, "r")
                try:
                    self.up_progress(10)
                    fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                    try:
                        passwd = fp.readline().strip("\n")
                    finally:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
                    self.up_progress(10)
                finally:
                    fp.close()

            except Exception, e:
                self.logger.error('Failed to read.- dom=%s passwd_file=%s' \
                      % (opts.name,opts.passwd_file))
                print >>sys.stderr,_('Failed to read.- dom=%s passwd_file=%s') \
                      % (opts.name,opts.passwd_file)
                raise e

            os.remove(opts.passwd_file)

        try:
            if passwd is None:
                if opts.uri is None:
                    conn = KaresansuiVirtConnection(readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnection(uri, readonly=False)

            else:
                if opts.uri is None:
                    conn = KaresansuiVirtConnectionAuth(creds=passwd,readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnectionAuth(uri,creds=passwd,readonly=False)

            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                if opts.force:
                    try:
                        self.up_progress(10)
                        conn.resume_guest()
                        self.up_progress(10)
                    except:
                        pass

                try:
                    self.up_progress(10)
                    conn.shutdown_guest()
                    self.up_progress(10)
                except Exception, e:
                    self.logger.error('Failed to shutdown guest. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to shutdown guest. - dom=%s') % (opts.name)
                    raise e

                self.up_progress(10)
                status = conn.guest.status()
                self.up_progress(10)
                if status == VIR_DOMAIN_SHUTOFF or status == VIR_DOMAIN_SHUTDOWN:
                    self.logger.info('Shutdown_guest hutdowned guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Shutdowned guest. - dom=%s') % (opts.name)

            else:
                self.logger.error('Guest not found. - dom=%s' % (opts.name))
                print >>sys.stderr, _('Guest not found. - dom=%s') % (opts.name)
                return False

            return True

        finally:
            if 'conn' in locals():
                conn.close()

if __name__ == "__main__":
    target = ShutdownGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = start_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import fcntl
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                                         KaresansuiVirtConnectionAuth, \
                                         VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTDOWN
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import uri_split, uri_join

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-c', '--connection', dest='uri', help=_('Connection URI'), default=None)
    optp.add_option('-w', '--passwd-file', dest='passwd_file', help=_('Password File for URI Connection'), default=None)
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

    if opts.passwd_file is not None and not os.path.exists(opts.passwd_file):
        raise KssCommandOptException('ERROR: %s is not found.' % opts.passwd_file)

    if opts.uri is not None:
        if uri_split(opts.uri)["scheme"] is None:
            raise KssCommandOptException('ERROR: uri %s is invalid.' % opts.uri)

class StartGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        passwd = None
        if opts.passwd_file is not None and os.path.exists(opts.passwd_file):
            try:
                fp = open(opts.passwd_file, "r")
                try:
                    self.up_progress(10)
                    fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                    try:
                        passwd = fp.readline().strip("\n")
                    finally:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
                    self.up_progress(10)
                finally:
                    fp.close()

            except Exception, e:
                self.logger.error('Failed to read.- dom=%s passwd_file=%s' \
                      % (opts.name,opts.passwd_file))
                print >>sys.stderr,_('Failed to read.- dom=%s passwd_file=%s') \
                      % (opts.name,opts.passwd_file)
                raise e

            os.remove(opts.passwd_file)

        try:
            if passwd is None:
                if opts.uri is None:
                    conn = KaresansuiVirtConnection(readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnection(uri, readonly=False)

            else:
                if opts.uri is None:
                    conn = KaresansuiVirtConnectionAuth(creds=passwd,readonly=False)
                else:
                    uri = uri_join(uri_split(opts.uri), without_auth=True)
                    conn = KaresansuiVirtConnectionAuth(uri,creds=passwd,readonly=False)

            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()
            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.start_guest()
                    self.up_progress(30)
                except Exception, e:
                    self.logger.error('Failed to start guest. - dom=%s' % (opts.name))
                    print >>sys.stderr, _('Failed to start guest. - dom=%s') % (opts.name)
                    raise e

                self.up_progress(10)
                status = conn.guest.status()
                self.up_progress(10)
                if status != VIR_DOMAIN_SHUTOFF and status != VIR_DOMAIN_SHUTDOWN:
                    self.logger.info('Succeeded to start guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Succeeded to start guest. - dom=%s') % (opts.name)

            else:
                raise KssCommandException(
                    'Guest not found. - dom=%s' % (opts.name))

            return True

        except Exception, e:
            self.logger.error('Failed to start guest. - dom=%s' % (opts.name))
            print >>sys.stderr, _('Failed to start guest. - dom=%s') % (opts.name)
            raise e

        finally:
            if 'conn' in locals():
                conn.close()

if __name__ == "__main__":
    target = StartGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = start_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command
    from karesansui.lib.iscsi import iscsi_parse_session
    from karesansui.lib.const import ISCSI_CMD, \
        ISCSI_CMD_OPTION_MODE,       ISCSI_CMD_OPTION_MODE_SESSION, \
        ISCSI_CMD_OPTION_MODE_NODE,  ISCSI_CMD_OPTION_TARGETNAME, \
        ISCSI_CMD_OPTION_PORTAL,     ISCSI_CMD_OPTION_LOGIN, \
        ISCSI_CMD_RES_NO_ACTIVE_SESSION

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-t', '--target', dest='host', help=_('Target host name'), default=None)
    optp.add_option('-i', '--iqn', dest='iqn', help=_('Target IQN'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\._:-]")

    if opts.iqn:
        if reg.search(opts.iqn):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-i or --iqn', opts.iqn))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-i or --iqn')

    if opts.host:
        if reg.search(opts.host):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-t or --target', opts.host))

class StartIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        already_exist = False

        session_command_args = (ISCSI_CMD,
                                ISCSI_CMD_OPTION_MODE,
                                ISCSI_CMD_OPTION_MODE_SESSION
                                )

        (session_rc, session_res) = execute_command(session_command_args)
        if session_rc != 0:
            raise KssCommandException('Failed to get iSCSI session. message=%s' % (session_res))

        for session_line in session_res:
            if not session_line:
                continue

            if session_line.find(ISCSI_CMD_RES_NO_ACTIVE_SESSION) != -1:
                break

            try:
                session = iscsi_parse_session(session_line)
            except:
                self.logger.warn('Failed to parse iSCSI session command response. message="%s"' % (session_line))
                continue

            if session['iqn'] == opts.iqn:
                if opts.host:
                    if opts.host != session['hostname']:
                        continue
                already_exist = True
                break

        if already_exist:
            self.logger.info("[target: %s]: already exists" % (opts.iqn))
            print >>sys.stdout, _("[target: %s]: already exists") % (opts.iqn)
        else:
            login_command_args = [ISCSI_CMD,
                                  ISCSI_CMD_OPTION_MODE,
                                  ISCSI_CMD_OPTION_MODE_NODE,
                                  ISCSI_CMD_OPTION_TARGETNAME,
                                  opts.iqn,
                                  ]
            if opts.host:
                login_command_args.append(ISCSI_CMD_OPTION_PORTAL)
                login_command_args.append(opts.host)

            login_command_args.append(ISCSI_CMD_OPTION_LOGIN)

            (login_rc,login_res) = execute_command(login_command_args)
            self.up_progress(50)

            if login_rc != 0:
                raise KssCommandException('Failed to login to iSCSI. - host=%s iqn=%s message=%s' % (opts.host, opts.iqn, login_res))

            for line in login_res:
                if not line:
                    continue

                self.logger.info("%s" % (line))
                print >>sys.stdout, _("%s") % (line)

        return True

if __name__ == "__main__":
    target = StartIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = start_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class StartNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if not (opts.name in active_networks or opts.name in inactive_networks):
                raise KssCommandException('network not found. - net=%s' % (opts.name))

            self.up_progress(10)
            conn.start_network(opts.name)
            self.up_progress(40)

            if not (opts.name in conn.list_active_network()):
                raise KssCommandException('Failed to start network. - net=%s' % (opts.name))

            self.logger.info('Started network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Started network. - net=%s') % (opts.name)
            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = StartNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = start_service
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.service.sysvinit_rh import SysVInit_RH
    from karesansui.lib.service.config import ServiceConfigParam
    from karesansui.lib.const import SERVICE_XML_FILE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Service name'))
    return optp.parse_args()

def chkopts(opts):
    if opts.name is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class StartService(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        service = config.findby1service(opts.name)
        if not service:
            raise KssCommandException("Could not find the service - name=%s" % opts.name)

        self.up_progress(10)
        sysv = SysVInit_RH(service['system_name'], service['system_command'])

        if sysv.start(force=False) is False:
            raise KssCommandException(str(sysv.error_msg))

        self.up_progress(50)
        self.logger.info('Started service. - service=%s' % (opts.name))
        print >>sys.stdout, _('Started service. - service=%s') % (opts.name)

        return True

if __name__ == "__main__":
    target = StartService()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = start_storage_pool
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale
    from karesansui.lib.const import STORAGE_POOL_TYPE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Storage pool name'))
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.name:
        if reg.search(opts.name):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-n or --name', opts.name))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class StartStoragePool(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            try:
                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()

                self.up_progress(10)

                if not (opts.name in active_storage_pools or opts.name in inactive_storage_pools):
                    raise KssCommandException(
                        'Specified storage pool does not exist. - pool=%s' % opts.name)

                if opts.name in active_storage_pools:
                    raise KssCommandException('Storage pool is already running. - pool=%s' % opts.name)

                self.up_progress(10)
                if conn.start_storage_pool(opts.name) is False:
                    raise KssCommandException(
                        'Failed to start storage pool. (libvirt) - pool=%s' % (opts.name))

                self.up_progress(40)

                inactive_storage_pools = conn.list_inactive_storage_pool()
                active_storage_pools = conn.list_active_storage_pool()
                if not (opts.name in active_storage_pools):
                    raise KssCommandException(
                        'Could not start the storage pool. - pool=%s' % (opts.name))

                self.logger.info('Start storage pool. - pool=%s' % (opts.name))
                print >>sys.stdout, _('Start storage pool. - pool=%s') % (opts.name)
                return True
            except KssCommandException, e:
                raise e
        finally:
            conn.close()

if __name__ == "__main__":
    target = StartStoragePool()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = stop_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command
    from karesansui.lib.const import ISCSI_CMD, ISCSI_CMD_OPTION_MODE, ISCSI_CMD_OPTION_MODE_NODE, \
        ISCSI_CMD_OPTION_TARGETNAME, ISCSI_CMD_OPTION_PORTAL, ISCSI_CMD_OPTION_LOGOUT

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-t', '--target', dest='host', help=_('Target host name'), default=None)
    optp.add_option('-i', '--iqn', dest='iqn', help=_('Target IQN'), default=None)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\._:-]")

    if opts.iqn:
        if reg.search(opts.iqn):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-i or --iqn', opts.iqn))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-i or --iqn')

    if opts.host:
        if reg.search(opts.host):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-t or --target', opts.host))

class StopIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        logout_command_args = [ISCSI_CMD,
                               ISCSI_CMD_OPTION_MODE,
                               ISCSI_CMD_OPTION_MODE_NODE,
                               ISCSI_CMD_OPTION_TARGETNAME,
                               opts.iqn,
                               ]
        if opts.host:
            logout_command_args.append(ISCSI_CMD_OPTION_PORTAL)
            logout_command_args.append(opts.host)

        logout_command_args.append(ISCSI_CMD_OPTION_LOGOUT)

        (logout_rc,logout_res) = execute_command(logout_command_args)
        self.up_progress(50)

        if logout_rc != 0:
            raise KssCommandException('Failed to logout iSCSI. - host=%s iqn=%s message=%s' % (opts.host, opts.iqn, logout_res))

        for line in logout_res:
            if not line:
                continue

            self.logger.info("%s" % (line))
            print >>sys.stdout, _("%s") % (line)

        return True

if __name__ == "__main__":
    target = StopIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = stop_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class StopNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            active_networks = conn.list_active_network()
            inactive_networks = conn.list_inactive_network()
            if not (opts.name in active_networks or opts.name in inactive_networks):
                raise KssCommandException('Network not found. - net=%s' % (opts.name))

            self.up_progress(10)
            conn.stop_network(opts.name)
            self.up_progress(40)

            if opts.name in conn.list_active_network():
                raise KssCommandException('Failed to stop network. - net=%s' % (opts.name))

            self.logger.info('Stopped network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Stopped network. - net=%s') % (opts.name)

            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = StopNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = stop_service
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.service.config import ServiceConfigParam
    from karesansui.lib.service.sysvinit_rh import SysVInit_RH
    from karesansui.lib.const import SERVICE_XML_FILE

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Service name'))
    return optp.parse_args()

def chkopts(opts):
    if opts.name is None:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

class StopService(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)
        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        service = config.findby1service(opts.name)
        self.up_progress(10)
        sysv = SysVInit_RH(service['system_name'], service['system_command'])

        if sysv.stop(force=False) is False:
            raise KssCommandException(str(sysv.error_msg))

        self.up_progress(50)
        self.logger.info('Stopped service. - service=%s' % (opts.name))
        print >>sys.stdout, _('Stopped service. - service=%s') % (opts.name)

        return True

if __name__ == "__main__":
    target = StopService()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = suspend_guest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
                 VIR_DOMAIN_PAUSED
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')

class SuspendGuest(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            conn.set_domain_name(opts.name)

            active_guests = conn.list_active_guest()
            inactive_guests = conn.list_inactive_guest()

            if opts.name in active_guests or opts.name in inactive_guests:
                try:
                    self.up_progress(10)
                    conn.suspend_guest()
                    self.up_progress(40)
                except:
                    raise KssCommandException('Failed to suspend guest. - dom=%s' % (opts.name))

                self.up_progress(10)
                status = conn.guest.status()
                self.up_progress(10)
                if status == VIR_DOMAIN_PAUSED:
                    self.logger.info('Succeeded to suspend guest. - dom=%s' % (opts.name))
                    print >>sys.stdout, _('Succeeded to suspend guest. - dom=%s') % (opts.name)

            else:
                raise KssCommandException(
                    'Could not find guest. - dom=%s' % (opts.name))

            return True

        finally:
            conn.close()


if __name__ == "__main__":
    target = SuspendGuest()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = take_snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import time
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import get_xml_parse        as XMLParse
    from karesansui.lib.utils import get_xml_xpath        as XMLXpath
    from karesansui.lib.utils import get_nums_xml_xpath   as XMLXpathNum

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Domain Name'))
    optp.add_option('-i', '--id', dest='id', help=_('Snapshot serial ID'))
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: -n or --name option is required.')
    #if not opts.id:
    #    raise KssCommandOptException('ERROR: -i or --id option is required.')

class TakeSnapshot(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        xml = None
        if opts.id:
            xml = "<domainsnapshot><name>%s</name></domainsnapshot>" % opts.id

        kvs = KaresansuiVirtSnapshot(readonly=False)
        try:
            self.up_progress(10)
            try:
                xmlDesc = kvs.createSnapshot(opts.name, xml)

                self.up_progress(50)
                if xmlDesc is not False:
                    doc = XMLParse(xmlDesc)
                    snapshot_name = XMLXpath(doc, '/domainsnapshot/name/text()')

                    msg = _("Domain snapshot '%s' created. - domain=%s") % (str(snapshot_name),opts.name,)
                    self.logger.info(msg)
                    print >>sys.stdout, msg
                else:
                    msg = _("Failed to create snapshot. - domain=%s") % (opts.name,)
                    self.logger.error(msg)
                    raise KssCommandException(msg)

            except KssCommandException, e:
                raise KssCommandException(''.join(e.args))
            except Exception, e:
                msg = _("Failed to create snapshot. - domain=%s") % (opts.name,)
                msg += ": detail %s" % ''.join(e.args)
                self.logger.error(msg)
                raise KssCommandException(msg)

        finally:
            kvs.finish()

        return True

if __name__ == "__main__":
    target = TakeSnapshot()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = update_iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import logging
import fcntl
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException
import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale, execute_command, is_readable
    from karesansui.lib.parser.iscsid import iscsidParser
    from karesansui.lib.dict_op import DictOp
    from karesansui.lib.iscsi import iscsi_get_config_path
    from karesansui.lib.const import ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE, \
        ISCSI_CONFIG_KEY_AUTH_METHOD, ISCSI_CONFIG_KEY_AUTH_USER, ISCSI_CONFIG_KEY_AUTH_PASSWORD, \
        ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_ON, ISCSI_CONFIG_VALUE_SATRTUP_OFF

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-t', '--target', dest='host', help=_('Target host name'), default=None)
    optp.add_option('-i', '--iqn', dest='iqn', help=_('Target IQN'), default=None)
    optp.add_option('-P', '--port', dest='port', help=_('Target port number'), default="3260")
    optp.add_option('-T', '--tpgt', dest='tpgt', help=_('Target TPGT'), default="1")
    optp.add_option('-a', '--auth', dest='auth', help=_('Authentication type'), default=None)
    optp.add_option('-u', '--user', dest='user', help=_('Authentication user name'), default=None)
    optp.add_option('-p', '--password', dest='password', help=_('Authentication password'), default=None)
    optp.add_option('-w', '--password-file', dest='password_file', help=_('Authentication password file'), default=None)
    optp.add_option('-s', '--autostart', dest='autostart', action="store_true", help=_('Autostart'), default=False)
    return optp.parse_args()

def chkopts(opts):
    reg = re.compile("[^a-zA-Z0-9\./_:-]")

    if opts.host:
        if reg.search(opts.host):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-t or --target', opts.host))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-t or --target')

    if opts.iqn:
        if reg.search(opts.iqn):
            raise KssCommandOptException('ERROR: Illigal option value. option=%s value=%s' % ('-i or --iqn', opts.iqn))
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-i or --iqn')

    if opts.auth:
        if not opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP and not opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE:
            raise KssCommandOptException('ERROR: %s option is require %s or %s.' % ('-a or --auth', ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE))
        if opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            if opts.user is None:
                raise KssCommandOptException('ERROR: %s option is required.' % '-u or --user')
            if opts.password is None and opts.password_file is None:
                raise KssCommandOptException('ERROR: %s option is required.' % '-p or --password or -w or --password-file')
            if opts.password_file is not None and not is_readable(opts.password_file):
                raise KssCommandOptException('ERROR: %s is not found.' % opts.password_file)
    else:
        raise KssCommandOptException('ERROR: %s option is required.' % '-a or --auth')

class UpdateIscsi(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        config_path = iscsi_get_config_path(opts.host, opts.iqn, opts.port, opts.tpgt)
        parser = iscsidParser()
        dop = DictOp()
        dop.addconf("new", parser.read_conf(config_path))

        self.up_progress(10)

        dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_METHOD, opts.auth)
        if opts.auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            password = ""
            if opts.password is not None:
                password = opts.password
            elif opts.password_file is not None and is_readable(opts.password_file):
                try:
                    fp = open(opts.password_file, "r")
                    try:
                        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
                        try:
                            password = fp.readline().strip("\n")
                        finally:
                            fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)

                        self.up_progress(10)
                    finally:
                        fp.close()

                except:
                    raise KssCommandException('Failed to read file. - target host=%s password_file=%s' \
                                                  % (opts.host,opts.password_file))

                try:
                    os.remove(opts.password_file)
                except:
                    raise KssCommandException('Failed to remove file. - target host=%s password_file=%s' \
                                                  % (opts.host,opts.password_file))

            dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_USER, opts.user)
            dop.cdp_set("new", ISCSI_CONFIG_KEY_AUTH_PASSWORD, password)
        else:
            dop.comment("new", ISCSI_CONFIG_KEY_AUTH_USER)
            dop.comment("new", ISCSI_CONFIG_KEY_AUTH_PASSWORD)

        self.up_progress(10)
        if opts.autostart:
            dop.cdp_set("new", ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_ON)
        else:
            dop.cdp_set("new", ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_OFF)

        self.up_progress(10)
        parser.write_conf(dop.getconf("new"), config_path)
        self.up_progress(30)

        self.logger.info("Updated iSCSI node. - host=%s iqn=%s" % (opts.host, opts.iqn))
        print >>sys.stdout, _("Updated iSCSI node. - host=%s iqn=%s") % (opts.host, opts.iqn)

        return True

if __name__ == "__main__":
    target = UpdateIscsi()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = update_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtException
    from karesansui.lib.const import NETWORK_IFCONFIG_COMMAND, NETWORK_BRCTL_COMMAND
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-n', '--name', dest='name', help=_('Network name'))
    optp.add_option('-c', '--cidr', dest='cidr', help=_('Bridge IP address'), default=None)
    optp.add_option('-s', '--dhcp-start', dest='dhcp_start', help=_('DHCP start IP address'), default=None)
    optp.add_option('-e', '--dhcp-end', dest='dhcp_end', help=_('DHCP end IP address'), default=None)
    optp.add_option('-f', '--forward-dev', dest='forward_dev', help=_('Forward device'), default=None)
    optp.add_option('-m', '--forward-mode', dest='forward_mode', help=_('Forward mode'), default=None)
    optp.add_option('-b', '--bridge-name', dest='bridge_name', help=_('Bridge name'), default=None)
    optp.add_option('-a', '--autostart', dest='autostart', help=_('Autostart'), default="yes")
    return optp.parse_args()

def chkopts(opts):
    if not opts.name:
        raise KssCommandOptException('ERROR: %s option is required.' % '-n or --name')

    if not (opts.cidr or opts.dhcp_start or opts.dhcp_end or opts.forward_dev or opts.forward_mode or opts.bridge_name):
        raise KssCommandOptException('ERROR: At least one option should be specified.')

class UpdateNetwork(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        conn = KaresansuiVirtConnection(readonly=False)
        try:
            forward = {"dev": opts.forward_dev,
                       "mode": opts.forward_mode,
                       }
            bridge  = opts.bridge_name

            if opts.autostart == "yes":
                autostart = True
            else:
                autostart = False

            self.up_progress(20)
            try:
                conn.update_network(opts.name, opts.cidr, opts.dhcp_start, opts.dhcp_end, forward, bridge, autostart=autostart)
            except:
                self.logger.error('Failed to update network. - net=%s' % (opts.name))
                raise

            # The network should be active now.
            # If not, we're going to start it up.
            active_networks = conn.list_active_network()
            if not (opts.name in active_networks):
                try:
                    conn.start_network(opts.name)
                except KaresansuiVirtException, e:
                    # try to bring down existing bridge
                    kvn = conn.search_kvn_networks(opts.name)[0]
                    try:
                        bridge_name = kvn.get_info()['bridge']['name']
                    except KeyError:
                        pass

                    ret, res = execute_command([NETWORK_IFCONFIG_COMMAND, bridge_name, 'down'])
                    ret, res = execute_command([NETWORK_BRCTL_COMMAND, 'delbr', bridge_name])

                    # try again
                    conn.start_network(opts.name)
                    self.up_progress(10)

            self.up_progress(10)
            active_networks = conn.list_active_network()
            if not (opts.name in active_networks):
                raise KssCommandException('Updated network but it\'s dead. - net=%s' % (opts.name))

            self.logger.info('Updated network. - net=%s' % (opts.name))
            print >>sys.stdout, _('Updated network. - net=%s') % (opts.name)
            return True
        finally:
            conn.close()

if __name__ == "__main__":
    target = UpdateNetwork()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = update_software
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<description>

@file:   update_software.py
@author: Kei Funagayama <kei@karesansui-project.info>
@copyright:    

<comment-ja>
Karesansuiパッケージをアップデートする。

 使用方法: update_software.py [オプション]

  オプション:
    --version             プログラムのバージョンを表示
    -h, --help            使用方法を表示
</comment-ja>
<comment-en>
</comment-en>
"""

import os
import sys
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.virt.virt import KaresansuiVirtConnection
    from karesansui.lib.utils import load_locale

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    return optp.parse_args()

def chkopts(opts):
    pass

class UpdateSoftware(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(10)

        import karesansui.plus.updater
        yu = karesansui.plus.updater.YumUpdater(karesansui.config)
        try:
            self.up_progress(20)
            yu.refresh()
            self.up_progress(20)
            ret = yu.update()
            self.up_progress(40)
        except:
            raise KssCommandException('failed to update software.')

        if ret:
            self.logger.info('Has been updated.')
            print >>sys.stdout, 'Has been updated.'
        else:
            self.logger.info('Which did not have to be updated..')
            print >>sys.stdout, 'Which did not have to be updated.'

        self.up_progress(10)

        return True

if __name__ == "__main__":
    target = UpdateSoftware()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = write_conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import sys
import re
import time
import signal
import logging
from optparse import OptionParser

from ksscommand import KssCommand, KssCommandException, KssCommandOptException

import __cmd__

try:
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import load_locale
    from karesansui.lib.utils import copy_file
    from karesansui.lib.utils import execute_command
    from karesansui.lib.utils import preprint_r, base64_decode
    from karesansui.lib.utils import php_array_to_python_dict
    from karesansui.lib.dict_op import DictOp

except ImportError, e:
    print >>sys.stderr, "[Error] some packages not found. - %s" % e
    sys.exit(1)

_ = load_locale()

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    optp.add_option('-m', '--module', dest='module', help=_('Module name'))
    optp.add_option('-i', '--input-file',  dest='file',  help=_('Input file name'))
    optp.add_option('-q', '--quiet',dest='verbose', action="store_false", default=True, help=_("don't print status messages"))
    optp.add_option('-D', '--delete',dest='delete', action="store_true", default=False, help=_("Remove the specified dict file after execution."))
    optp.add_option('-E', '--early-exit',dest='early_exit', action="store_true", default=False, help=_("Exit, once the module's write process is failed."))
    optp.add_option('-P', '--php',  dest='php', action="store_true", default=False, help=_('If the input file format is php script, this should be specified.'))
    optp.add_option('-j', '--pre-command',  dest='pre_command',  default=None, help=_('Execute scriptlet before writing.'))
    optp.add_option('-J', '--post-command',  dest='post_command',  default=None, help=_('Execute scriptlet after writing.'))
    optp.add_option('-I', '--include', dest='include', help=_('Include key'), default=None)

    return optp.parse_args()

def chkopts(opts):
    if not opts.module:
        raise KssCommandOptException("ERROR: -m or --module option is required.")

    modules = opts.module.split(":")
    for _mod in modules:
        try:
            exec("from karesansui.lib.parser.%s import %sParser" % (_mod,_mod,))
        except:
            raise KssCommandOptException("ERROR: module not found. - %s" % opts.module)

    if not opts.file:
        raise KssCommandOptException("ERROR: -i or --input-file option is required.")

    files = opts.file.split(":")
    for _file in files:
        if not os.path.exists(_file):
            raise KssCommandOptException("ERROR: file not found. - %s" % _file)


        if opts.php is True:
            try:
                _dict = php_array_to_python_dict(open(_file).read())
            except:
                raise
                raise KssCommandOptException("ERROR: file format is invalid. - %s" % _file)

        else:
            try:
                exec("%s" % open(_file).read())
            except:
                raise KssCommandOptException("ERROR: file format is invalid. - %s" % _file)

    if len(modules) != len(files):
        raise KssCommandOptException("ERROR: not same number of modules and files. - module:%d file:%d" % (len(modules),len(files),))


class WriteConf(KssCommand):

    def process(self):
        (opts, args) = getopts()
        chkopts(opts)
        self.up_progress(1)

        uniq_id = time.strftime("%Y%m%d%H%M%S", time.localtime())

        if opts.pre_command is not None:
            if opts.pre_command[0:4] == "b64:":
                command = base64_decode(opts.pre_command[4:])
            else:
                command = opts.pre_command
            self.logger.info("execute command - %s" % command)
            (_ret,_res) = execute_command(command.split())
            if _ret != 0:
                error_msg = "execute error - %s" % command
                self.logger.error(error_msg)
                #raise KssCommandOptException("ERROR: %s" % error_msg)

        dop = DictOp()
        modules = opts.module.split(":")
        files   = opts.file.split(":")

        source_files = []
        retval = True
        cnt = 0
        for _mod in modules:
            _file = files[cnt]
            try:
                exec("from karesansui.lib.parser.%s import %sParser as Parser" % (_mod,_mod,))

                self.up_progress(5)
                parser = Parser()

                # 辞書オペレータに追加
                self.up_progress(5)
                if opts.php is True:
                    conf_arr = php_array_to_python_dict(open(_file).read())
                else:
                    exec("conf_arr = %s" % open(_file).read())
                dop.addconf(_mod,conf_arr)

                """
                必要ならここで配列操作
                通常は、配列操作後の辞書が_fileに書き込まれているので必要ない
                dop.add   (_mod,"foo","bar")
                dop.delete(_mod,"foo")
                """

                # 設定ファイル一覧に作成（バックアップ用）
                self.up_progress(5)
                source_file = parser.source_file()
                for _afile in source_file:
                    _bak_afile = "%s.%s" % (_afile,uniq_id)
                    copy_file(_afile,_bak_afile)
                source_files = source_files + source_file

                # 辞書に戻す
                self.up_progress(5)
                conf_arr = dop.getconf(_mod)
                #dop.preprint_r(_mod)

                # 設定ファイルに書き込み
                self.up_progress(5)
                extra_args = {}
                extra_args["include"] = opts.include
                if opts.early_exit is True:
                    retval = retval and parser.write_conf(conf_arr,extra_args=extra_args)
                else:
                    retval = parser.write_conf(conf_arr,extra_args=extra_args) and retval

                if opts.delete is True:
                    os.unlink(_file)

            finally:
                cnt = cnt + 1

        if retval is False:
            for _afile in source_files:
                _bak_afile = "%s.%s" % (_afile,uniq_id)
                os.unlink(_afile)
                copy_file(_bak_afile,_afile)
                os.unlink(_bak_afile)
            raise KssCommandOptException("ERROR: write configure failure")

        for _afile in source_files:
            _bak_afile = "%s.%s" % (_afile,uniq_id)
            os.unlink(_bak_afile)

        if opts.post_command is not None:
            if opts.post_command[0:4] == "b64:":
                command = base64_decode(opts.post_command[4:])
            else:
                command = opts.post_command
            self.logger.info("execute command - %s" % command)
            (_ret,_res) = execute_command(command.split())
            if _ret != 0:
                error_msg = "execute error - %s" % command
                self.logger.error(error_msg)
                raise KssCommandOptException("ERROR: %s" % error_msg)

        self.up_progress(10)
        return True

if __name__ == "__main__":
    target = WriteConf()
    sys.exit(target.run())

########NEW FILE########
__FILENAME__ = __cmd__
#!/usr/bin/env python
# -*- coding: utf-8 -*-

karesansui_conf = '/etc/karesansui/application.conf'
pysilhouette_conf = '/etc/pysilhouette/silhouette.conf'
search_path = ''

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# karesansui documentation build configuration file, created by
# sphinx-quickstart on Wed Apr 18 12:17:11 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'karesansui'
copyright = u'2012, Karesansui Project'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '3.0'
# The full version, including alpha/beta/rc tags.
release = '3.0.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'karesansuidoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'karesansui.tex', u'Karesansui Documentation',
   u'taizo', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'karesansui', u'Karesansui Documentation',
     [u'taizo'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'karesansui', u'Karesansui Documentation',
   u'taizo', 'karesansui', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

locale_dirs = ["locale"]
language = "en"

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@author: Kei Funagayama <kei@karesansui-project.info>
"""

import sys
import os
import traceback
from os import environ as env
import logging

from prep import fcgi, built_in, chkconfig, have_privilege

# Initialization
if __name__ == "__main__":
    (config, opts, args) = built_in() # build-in server
    
elif env.has_key('FCGI') is True:
    (config, opts, args) = fcgi() # FastCGI server
    
else:
    pass

try:
    import karesansui
except ImportError, e:
    print >>sys.stderr, '[Error] There are not enough libraries. - %s' % ''.join(e.args)
    traceback.format_exc()
    sys.exit(1)
    
if not karesansui.config:
    print >>sys.stderr, '[Error] Failed to load configuration file.'
    sys.exit(1)

if chkconfig(karesansui.config) is False:
    sys.exit(1)

# Check privilege
if have_privilege() is not True:
    from lib.const import KARESANSUI_GROUP
    print >>sys.stderr, "[Error] Only users who belong to '%s' group are able to run this program." % KARESANSUI_GROUP
    sys.exit(1)

# Import
import karesansui.lib.log.logger

try:
    import web
    import mako
    import sqlalchemy
    if env.has_key('FCGI') is True:
        import flup
    import simplejson
    import libvirt
    # pysilhouette module
    import pysilhouette
except ImportError, e:
    print >>sys.stderr, '[Error] There are not enough libraries. - %s' % ''.join(e.args)
    traceback.format_exc()
    sys.exit(1)

# pysilhouette config read.
from pysilhouette.prep import readconf
karesansui.sheconf = readconf(karesansui.config['pysilhouette.conf.path'])

if karesansui.sheconf is None:
    print >>sys.stderr, '[Error] Failed to load configuration file. (PySilhouette)'
    sys.exit(1)
    
import pysilhouette.prep
if pysilhouette.prep.parse_conf(karesansui.sheconf) is False:
    sys.exit(1)

# URL structure
import karesansui.urls
urls = karesansui.urls.urls


def main():
    """<comment-ja>
    Web Application 起動処理
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # logging load
    karesansui.lib.log.logger.reload_conf(karesansui.config['application.log.config'])
    if karesansui.lib.log.logger.is_ready() is False:
        raise  karesansui.lib.log.logger.KaresansuiLogError("""Warning!!
        Logging set initial startup failed.
        example : Does the log configuration file exist?
        The present file path : %s
        """ % karesansui.config['application.log.config'])

    logger = logging.getLogger('karesansui.app')
    logger_trace = logging.getLogger('karesansui_trace.app')

    if not os.popen("ps -eo cmd | grep -e ^libvirtd -e ^/usr/sbin/libvirtd").read():
        logger.error('libvirtd not running."/etc/init.d/libvirtd start" Please start.')
        print >>sys.stderr, '[Error] libvirtd not running."/etc/init.d/libvirtd start" Please start.'
        sys.exit(1)
    
    if web.wsgi._is_dev_mode() is True and env.has_key('FCGI') is False:
        logger.info('Start Mode [development]')
        app = web.application(urls, globals(), autoreload=True)
        app.internalerror = web.debugerror
        sys.argv = [] # argv clear
    else:
        logger.info('Start Mode [fastcgi]')
        web.config.debug = False
        app = web.application(urls, globals(), autoreload=False)
        #sys.argv = [] # argv clear
        
    # load processor!
    #  - karesansui database!
    app.add_processor(load_sqlalchemy_karesansui)
    logger.info('The load was added. - load_sqlalchemy_karesansui')
    #  - pysilhouette database!
    app.add_processor(load_sqlalchemy_pysilhouette)
    logger.info('The load was added. - load_sqlalchemy_pysilhouette')

    # http://domain/(../..)/hoge
    if karesansui.config['application.url.prefix']:
        mapping = (karesansui.config['application.url.prefix'],  app)
        app = web.subdir_application(mapping)
        
    try:
        if (not opts is None) and opts.shell is True: # shell mode!!
            shell()
        else:
            app.run() # Web Application Start!
    except Exception, e:
        logger_trace.critical(traceback.format_exc())
        print >>sys.stderr, "[ERROR] %s" % str(e.args)
        print >>sys.stderr, traceback.format_exc()
        return 1

# webpy - processor
def load_sqlalchemy_karesansui(handler):
    """<comment-ja>
    リクエストスコープ単位にKaresansuiデータベースのセッションを割り当てる。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    import karesansui.db
    web.ctx.orm = karesansui.db.get_session()
    
    logger = logging.getLogger("karesansui.processor.karesansui")

    logger.debug('Karesansui database session scope [start] - %s' % web.ctx.orm)
    try:
        ret = handler()
        web.ctx.orm.commit()
        logger.debug('Karesansui database session scope [commit] - %s' % web.ctx.orm)
        return ret 
    except web.HTTPError:
        if web.ctx.status[:1] in ['2', '3']:
            web.ctx.orm.commit()
            logger.debug('Karesansui database session scope [commit] : HTTP Status=%s - %s' % (web.ctx.status, web.ctx.orm))
            raise
        else:
            web.ctx.orm.rollback()
            logger.debug('Karesansui database session scope [rollback] : HTTP Status=%s - %s' % (web.ctx.orm, web.ctx.status))
            raise
    except:
        web.ctx.orm.rollback()
        logger.debug('Karesansui database session scope [rollback] - %s' % web.ctx.orm)
        raise

def load_twophase_sqlalchemy(handler):
    """<comment-ja>
    KaresansuiとPysilhouetteデータベースの2フェーズセッションをWeb Applicationに割り当てる。
    sqiteが2フェーズに対応していないのでVersion1.xでは未対応。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    #: <= 2.0
    # sqlite not supported.
    Session = sqlalchemy.orm.sessionmaker(twophase=True)
    Session.configure(binds={karesansui.db.get_metadata():karesansui.db.get_engine(),
                             karesansui.db._2pysilhouette.get_metadata():karesansui.db._2pysilhouette.get_engine(),
                             })
    session = Session()

def load_sqlalchemy_pysilhouette(handler):
    """<comment-ja>
    リクエストスコープ単位にPysilhouetteデータベースのセッションを割り当てる。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    import karesansui.db._2pysilhouette
    from web.utils import Storage
    web.ctx.pysilhouette = Storage()
    web.ctx.pysilhouette.orm = karesansui.db._2pysilhouette.get_session()
    
    logger = logging.getLogger("karesansui.processor.pysilhouette")
    
    try:
        ret = handler()
        web.ctx.pysilhouette.orm.commit()
        logger.debug('Pysilhouette database session scope [commit] - %s' % web.ctx.orm)
        return ret 
    except web.HTTPError:
        if web.ctx.status[:1] in ['2', '3']:
            web.ctx.pysilhouette.orm.commit()
            logger.debug('Pysilhouette database session scope [commit] : HTTP Status=%s - %s' % (web.ctx.status, web.ctx.orm))
            raise
        else:
            web.ctx.pysilhouette.orm.rollback()
            logger.debug('Pysilhouette database session scope [rollback] : HTTP Status=%s - %s' % (web.ctx.orm, web.ctx.status))
            raise
    except:
        web.ctx.pysilhouette.orm.rollback()
        logger.debug('Karesansui database session scope [commit] - %s' % web.ctx.orm)
        raise


def shell():
    """<comment-ja>
    IPythonを利用したKaresansui コマンドライン
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    try:
        from IPython.Shell import IPShellEmbed
    except ImportError, e:
        print >>sys.stderr, '[Error] Shell function requires IPython. - %s' % ''.join(e.args)
        traceback.format_exc()
        sys.exit(1)

    # karesansui database
    import karesansui.db
    kss_engine = karesansui.db.get_engine()
    kss_metadata = karesansui.db.get_metadata()
    kss_session = karesansui.db.get_session()
    # pysilhouette
    import karesansui.db._2pysilhouette 
    pyshe_engine = karesansui.db._2pysilhouette.get_engine()
    pyshe_metadata = karesansui.db._2pysilhouette.get_metadata()
    pyshe_session = karesansui.db._2pysilhouette.get_session()
    
    ipshell = IPShellEmbed()
    return ipshell()

if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception, e:
        print >>sys.stderr, traceback.format_exc()
        sys.exit(1)

########NEW FILE########
__FILENAME__ = machine
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from sqlalchemy import and_, or_

from karesansui.lib.const import MACHINE_ATTRIBUTE
from karesansui.db.model.machine import Machine
from karesansui.db.access import dbsave, dbupdate, dbdelete

# -- all
def findbyall(session, is_deleted=False):
    return session.query(Machine).filter(
        Machine.is_deleted == is_deleted).all()

def findby1(session, machine_id, is_deleted=False):
    return session.query(Machine).filter(
        Machine.id == machine_id).filter(
        Machine.is_deleted == is_deleted).first()

def findby1name(session, machine_name, is_deleted=False):
    return session.query(Machine).filter(
        Machine.name == machine_name).filter(
        Machine.is_deleted == is_deleted).first()

def findbyalluniquekey(session, uniq_key):
    return session.query(Machine).filter(
        Machine.uniq_key == uniq_key).all()

def findby1uniquekey(session, uniq_key, is_deleted = False):
    return session.query(Machine).filter(
        Machine.uniq_key == uniq_key).filter(
        Machine.is_deleted == is_deleted).first()

def findby1hostname(session, hostname, is_deleted=False):
    return session.query(Machine).filter(
        Machine.hostname == hostname).filter(
        Machine.is_deleted == is_deleted).first()

# -- host
def findbyhostall(session, is_deleted=False):
    return session.query(Machine).filter(
        or_(Machine.attribute == MACHINE_ATTRIBUTE['HOST'], Machine.attribute == MACHINE_ATTRIBUTE['URI'])).filter(
        Machine.is_deleted == is_deleted).all()

def findbyhost1(session, machine_id, is_deleted=False):
    return session.query(Machine).filter(
        Machine.id == machine_id).filter(
        or_(Machine.attribute == MACHINE_ATTRIBUTE['HOST'], Machine.attribute == MACHINE_ATTRIBUTE['URI'])).filter(
        Machine.is_deleted == is_deleted).first()

def is_findbyhost1(session, machine_id, is_deleted=False):
    """<comment-ja>
    指定したホストレコードが存在するか。
     - 0 : 存在しない
     - 1 : 存在する
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    return session.query(Machine).filter(
        Machine.id == machine_id).filter(
        or_(Machine.attribute == MACHINE_ATTRIBUTE['HOST'], Machine.attribute == MACHINE_ATTRIBUTE['URI'])).filter(
        Machine.is_deleted == is_deleted).count()


# -- guest
def findbyhost1guestall(session, host_id, is_deleted=False):
    return session.query(Machine).filter(
        Machine.parent_id == host_id).filter( 
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST']).filter(
        Machine.is_deleted == is_deleted).all()

def findbyguestall(session, is_deleted=False):
    return session.query(Machine).filter(
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST']).filter(
        Machine.is_deleted == is_deleted).all()

def findbyguest1(session, guest_id, is_deleted=False):
    return session.query(Machine).filter(
        Machine.id == guest_id).filter(
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST']).filter(
        Machine.is_deleted == is_deleted).first()

def is_findbyguest1(session, guest_id, host_id=None, is_deleted=False):
    """<comment-ja>
    指定したゲストレコードが存在するか。
     - 0 : 存在しない
     - 1 : 存在する
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    query = session.query(Machine).filter(
        Machine.id == guest_id).filter(
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST']).filter(
        Machine.is_deleted == is_deleted)
    if host_id:
        query.filter(Machine.parent_id == host_id)

    return query.count()

# custom
def deleteby1uniquekey(session, uniq_key, is_deleted=False):
    guest = session.query(Machine).filter(
        Machine.uniq_key == uniq_key).one()

    return logical_delete(session, guest)

@dbupdate
def logical_delete(session, machine):
    if machine.attribute == MACHINE_ATTRIBUTE['HOST']:
        machine.hostname = None

    if machine.attribute == MACHINE_ATTRIBUTE['URI']:
        machine.hostname = None

    machine.is_deleted = True
    return session.add(machine)

@dbsave
def save(session, machine):
    session.add(machine)

@dbupdate
def update(session, machine):
    session.add(machine)
    
@dbdelete
def delete(session, machine):
    session.delete(machine)

# new instance
new = Machine

########NEW FILE########
__FILENAME__ = machine2jobgroup
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.const import MACHINE_ATTRIBUTE
from karesansui.db.access import dbsave, dbupdate, dbdelete
from karesansui.db.model.machine2jobgroup import Machine2Jobgroup
from karesansui.db.access._2pysilhouette import jobgroup_findbyuniqkey

# -- all
def findbyall(session):
    return session.query(Machine2Jobgroup).all()

# -- one
def findby1(session, id):
    return session.query(
        Machine2Jobgroup).filter(
        Machine2Jobgroup.id == id).first()

# -- machine1
def findby1machine(session, machine_id):
    return session.query(
        Machine2Jobgroup).filter(
        Machine2Jobgroup.machine_id == machine_id).all()

# -- jobgroup1
def findby1jobgroup(session, jobgroup_id):
    return session.query(
        Machine2Jobgroup).filter(
        Machine2Jobgroup.jobgroup_id == jobgroup_id).all()

@dbdelete
def deleteby1machine(session, machine_id):
    return session.query(Machine2Jobgroup).filter(
        Machine2Jobgroup.machine_id == machine_id).delete()

@dbsave
def save(session, machine2jobgroup):
    session.add(machine2jobgroup)
    
@dbupdate
def update(session, machine2jobgroup):
    session.add(machine2jobgroup)
    
@dbdelete
def delete(session, machine2jobgroup):
    session.delete(machine2jobgroup)
    
# new instance
new = Machine2Jobgroup

########NEW FILE########
__FILENAME__ = machine_machine2jobgroup
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.const import MACHINE_ATTRIBUTE
from karesansui.db.model.machine import Machine
from karesansui.db.model.machine2jobgroup import Machine2Jobgroup
from sqlalchemy import or_, and_

def findbyall(session, machine_name=None, created_start=None,
              created_end=None, created_user_id=None, desc=False):

    query = session.query(Machine).add_entity(Machine2Jobgroup).join(Machine2Jobgroup)

    if machine_name:
        query = query.filter(Machine.name.like(u"%%%s%%" % machine_name))

    if not created_user_id is None:
        query = query.filter(Machine2Jobgroup.created_user_id.in_(created_user_id))

    if created_start and created_end:
        query = query.filter(Machine2Jobgroup.created.between(created_start, created_end))
        
    elif created_start and (created_end is None):
        query = query.filter(created_start <= Machine2Jobgroup.created)
        
    elif (not created_start) and created_end:
        query = query.filter(Machine2Jobgroup.created <= created_end)
        
    if desc is True:
        return query.order_by(Machine2Jobgroup.id.desc()).all()
    else:
        return query.order_by(Machine2Jobgroup.id.asc()).all()


def findbyhost(session, host_id, created_start=None,
              created_end=None, created_user_id=None, desc=False):

    query = session.query(Machine).add_entity(Machine2Jobgroup).join(Machine2Jobgroup)

    query = query.filter(
                or_(
                    and_(Machine.parent_id == host_id, Machine.attribute == MACHINE_ATTRIBUTE['GUEST']),
                    and_(Machine.id == host_id, Machine.attribute == MACHINE_ATTRIBUTE['HOST']),
                    and_(Machine.id == host_id, Machine.attribute == MACHINE_ATTRIBUTE['URI'])
                )
            )

    #if created_user_id:
    if not created_user_id is None:
        query = query.filter(Machine2Jobgroup.created_user_id.in_(created_user_id))

    if created_start and created_end:
        query = query.filter(Machine2Jobgroup.created.between(created_start, created_end))
        
    elif created_start and (created_end is None):
        query = query.filter(created_start <= Machine2Jobgroup.created)
        
    elif (not created_start) and created_end:
        query = query.filter(Machine2Jobgroup.created <= created_end)
        
    if desc is True:
        return query.order_by(Machine2Jobgroup.id.desc()).all()
    else:
        return query.order_by(Machine2Jobgroup.id.asc()).all()

def findbyguest(session, guest_id, created_start=None,
              created_end=None, created_user_id=None, desc=False):

    query = session.query(Machine).add_entity(Machine2Jobgroup).join(Machine2Jobgroup)

    query = query.filter(
        Machine.id == guest_id).filter(
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST'])

    #if created_user_id:
    if not created_user_id is None:
        query = query.filter(Machine2Jobgroup.created_user_id.in_(created_user_id))

    if created_start and created_end:
        query = query.filter(Machine2Jobgroup.created.between(created_start, created_end))
        
    elif created_start and (created_end is None):
        query = query.filter(created_start <= Machine2Jobgroup.created)
        
    elif (not created_start) and created_end:
        query = query.filter(Machine2Jobgroup.created <= created_end)
        
    if desc is True:
        return query.order_by(Machine2Jobgroup.id.desc()).all()
    else:
        return query.order_by(Machine2Jobgroup.id.asc()).all()


def findbyjobgroup_id1(session, jobgroup_id):
    if jobgroup_id:
        query = session.query(Machine).add_entity(Machine2Jobgroup).join(Machine2Jobgroup)
        query = query.filter(Machine2Jobgroup.jobgroup_id == jobgroup_id)
        return query.first()
    else:
        return None

def findbyjobgroupor(session, jobgroup_ids, desc=False):
    if jobgroup_ids:
        query = session.query(Machine).add_entity(
            Machine2Jobgroup).join(
            Machine2Jobgroup)
        
        jg_id_list = jobgroup_ids.split()
        or_clause = or_()
        for id in jg_id_list:
            or_clause.append(Machine2Jobgroup.jobgroup_id.like("%"+id+"%"))

        if desc is True:
            return query.filter(or_clause).order_by(
                Machine2Jobgroup.jobgroup_id.desc()).all()
        else:
            return query.filter(or_clause).order_by(
                Machine2Jobgroup.jobgroup_id.asc()).all()
    else:
        return None

########NEW FILE########
__FILENAME__ = notebook
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.db.model.notebook import Notebook
from karesansui.db.access import dbsave, dbupdate, dbdelete

# -- all
def findbyall(session):
    return session.query(Notebook).all()

def findby1(session, notebook_id):
    if notebook_id:
        return session.query(Notebook).filter(Notebook.id == notebook_id).first()
    else:
        return None

@dbsave
def save(session, notebook):
    session.add(notebook)

@dbupdate
def update(session, notebook):
    session.add(notebook)
    
@dbdelete
def delete(session, notebook):
    session.delete(notebook)

# new instance
new = Notebook

########NEW FILE########
__FILENAME__ = option
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.db.model.option import Option
from karesansui.db.access import dbsave, dbupdate, dbdelete

# -- all
def findbyall(session):
    return session.query(Option).all()

def findby1(session, option_id):
    return session.query(Option).filter(Option.id == option_id).first()

def findby1key(session, key):
    return session.query(Option).filter(
        Option.key == key).first()

@dbdelete
def delete(session, mailtemplate):
    session.delete()

@dbsave
def save(session, option):
    session.add(option)

@dbupdate
def update(session, option):
    session.add(option)
    
# new instance
new = Option

def test(session):
    from karesansui.db.access.user import findby1 as user_findby1
    user = user_findby1(session, 1)
    import os
    option = Option(created_user=user,
                  modified_user=user,
                  key='key_%s' % str(os.getpid()),
                  value='hogehoge',
                  )
    import pdb; pdb.set_trace()
    
    save(session, option)
    session.commit()
    _all = findbyall(session)
    _findby1 = findby1(session, option.id)
    _findby1key = findby1key(session, option.key)
    import pdb; pdb.set_trace()

if __name__ == '__main__':
    test()

########NEW FILE########
__FILENAME__ = search
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from sqlalchemy import and_, or_

from karesansui.lib.utils import detect_encoding

def findbyand(session, query, model, attr, desc=False):
    """
    <comment-ja>
    指定したテーブルとテーブル属性で、
    指定した検索文字列でAND検索を行い、
    検索結果を返却します。

    @param session: セッション
    @param query: 検索文字列のリスト
    @param model: 検索するテーブルのオブジェクト
    @param attr: 検索するテーブル属性のオブジェクト
    @return: 検索結果のリスト
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    query = query.split()

    and_clause = and_()
    for q in query:
        #q = unicode(q, detect_encoding(q))
        or_clause = or_()
        for a in attr:
            or_clause.append(a.like("%"+q+"%"))
        and_clause.append(or_clause)
    
    if desc is True:
        return session.query(model).filter(and_clause).order_by(model.id.desc()).all()
    else:
        return session.query(model).filter(and_clause).order_by(model.id.asc()).all()

def findbyor(session, query, model, attrs, desc=False):
    or_clause = or_()
    for x in attrs:
        or_clause.append(x.like("%"+query+"%"))

    if desc is True:
        return session.query(model).filter(or_clause).order_by(model.id.desc()).all()
    else:
        return session.query(model).filter(or_clause).order_by(model.id.asc()).all()

########NEW FILE########
__FILENAME__ = snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.db.model.snapshot import Snapshot
from karesansui.db.access import dbsave, dbupdate, dbdelete

# -- all
def findbyall(session, is_deleted=False):
    return session.query(Snapshot).filter(
        Snapshot.is_deleted == is_deleted).all()

def findby1(session, snapshot_id, is_deleted=False):
    return session.query(Snapshot).filter(
        Snapshot.id == snapshot_id).filter(
        Snapshot.is_deleted == is_deleted).first()


def is_findby1_guestby1(session, snapshot_id, guest_id, is_deleted=False):
    return session.query(Snapshot).filter(
        Snapshot.id == snapshot_id).filter(
        Snapshot.machine_id == guest_id).filter(
        Snapshot.is_deleted == is_deleted).count()

def findbyname(session, name, is_deleted=False):
    return session.query(Snapshot).filter(
        Snapshot.name == name).filter(
        Snapshot.is_deleted == is_deleted).first()

def findbyname_guestby1(session, name, guest_id, is_deleted=False):
    return session.query(Snapshot).filter(
        Snapshot.name == name).filter(
        Snapshot.machine_id == guest_id).filter(
        Snapshot.is_deleted == is_deleted).first()

def logical_delete(session, snapshot):
    snapshot.is_deleted = True
    return update(session, snapshot)

@dbsave
def save(session, snapshot):
    session.add(snapshot)

@dbupdate
def update(session, snapshot):
    session.add(snapshot)
    
@dbdelete
def delete(session, snapshot):
    session.delete(snapshot)

# new instance
new = Snapshot

########NEW FILE########
__FILENAME__ = tag
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.const import MACHINE_ATTRIBUTE
from karesansui.db.model.tag import Tag
from karesansui.db.model.machine import Machine
from karesansui.db.access import dbsave, dbupdate, dbdelete
from karesansui.db.access.search import findbyand as _findbyand

# -- all
def findbyall(session):
    """<comment-ja>
    すべてのタグ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @rtype: karesansui.db.model.tag.Tag
    @return: Tag Class
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return session.query(Tag).all()

def findby1(session, tag_id):
    """<comment-ja>
    タグIDを元にタグ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param tag_id: Tag ID
    @type tag_id: int
    @rtype: karesansui.db.model.tag.Tag
    @return: Tag Class    
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if tag_id:
        return session.query(Tag).filter(Tag.id == tag_id).first()
    else:
        return None

def findby1name(session, tag_name):
    """<comment-ja>
    タグ名を指定して1件のタグ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param tag_name: タグ名条件
    @type tag_name: string
    @return: karesansui.db.model.tag.Tag
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if tag_name:
        return session.query(Tag).filter(Tag.name == tag_name).first()
    else:
        return None

def findbyand(session, query):
    """<comment-ja>
    クエリー条件のAND検索で、多数のユーザ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param query: クエリー条件
    @type query: list
    @return: karesansui.db.model.user.User
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return _findbyand(session, query, Tag, [Tag.name])

# -- host
def findbyhostall(session, is_deleted=False):
    return session.query(Tag).join("machine").filter(
        Machine.attribute == MACHINE_ATTRIBUTE['HOST']).filter(
        Machine.is_deleted == is_deleted).all()

# -- guest
def findbyhost1guestall(session, host_id, is_deleted=False):
    return session.query(Tag).join("machine").filter(
        Machine.parent_id == host_id).filter(
        Machine.attribute == MACHINE_ATTRIBUTE['GUEST']).filter(
        Machine.is_deleted == is_deleted).all()

def samecount(session, tag_name):
    return session.query(Tag).filter(Tag.name == tag_name).count()

@dbsave
def save(session, tag):
    session.add(tag)

@dbupdate
def update(session, tag):
    session.add(tag)
    
@dbdelete
def delete(session, tag):
    session.delete(tag)

def new(name = None):
    return Tag(name) 
    

# new instance
new = Tag

########NEW FILE########
__FILENAME__ = user
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from sqlalchemy.orm.exc import NoResultFound

from karesansui.lib.crypt import sha1compare
from karesansui.db.model.user import User
from karesansui.db.access import dbsave, dbupdate, dbdelete
from karesansui.db.access.search import findbyand as _findbyand

from karesansui import KaresansuiDBException

def findbyall(session):
    """<comment-ja>
    ユーザを全て取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return session.query(User).all()

def findby1(session, id):
    """<comment-ja>
    ユーザIDを指定して1件のユーザ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param id: ユーザID
    @type id: int
    @return: karesansui.db.model.user.User
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return session.query(User).filter(User.id == id).first()

# -- email
def findby1email(session, email):
    """<comment-ja>
    メールアドレスを指定して1件のユーザ情報を取得します
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param email: メールアドレス
    @type email: str
    @return: karesansui.db.model.user.User
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return session.query(User).filter(User.email == email).first()

def findbyname_BM(session, nickname):
    """<comment-ja>
    ニックネームを部分一致で検索します。
    @param
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return session.query(User).filter(User.nickname.like("%%%s%%" % nickname)).all()
    

def findbyand(session, query):
    """<comment-ja>
    クエリー条件のAND検索で、多数のユーザ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param query: クエリー条件
    @type query: list
    @return: karesansui.db.model.user.User
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return _findbyand(session, query, User, [User.nickname, User.email])

@dbsave
def save(session, user):
    session.add(user)

@dbupdate
def update(session, user):
    session.add(user)
    
@dbdelete
def delete(session, user):
    session.delete(user)

def new(email, password, salt, nickname, languages=None):
    return User(email, password, salt, nickname, languages)

# -- process method
def login(session, email, password):
    """<comment-ja>
    ログイン情報からユーザ情報を取得します。
    @param session: Session
    @type session: sqlalchemy.orm.session.Session
    @param email: e-mail
    @type email: str
    @param password: パスワード
    @type password: str
    @return: karesansui.db.model.user.User
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if email and password:
        _r = session.query(User).filter(User.email == email).first()
        if _r is None:
            return None

        if sha1compare(_r.password, password, _r.salt) is True:
            return _r
        else:
            return None
    return None

if __name__ == '__main__':
    import sqlalchemy.orm
    from karesansui.db.model.user import User, get_user_table
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name, encoding="utf8", echo=True)
    metadata = sqlalchemy.MetaData(bind=engine)
    t_user = get_user_table(metadata)
    sqlalchemy.orm.mapper(User, t_user)
    #metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()
    # --
    """
    u = User('pass', 'hoge@example.com', 'karesansui', 'ja-JP')
    save(session, u)
    ua = findbyall(session)
    print ua    
    u = findby1(session, ua[0].id)
    print u
    u.password = 'update password'
    update(session, u)
    u = findby1(session, ua[0].id)
    print u
    delete(session, u)
    u = findbyall(session)
    print u
    """
    # process method
    u = User('pass', 'hoge@example.com', 'karesansui', 'ja-JP')
    if save(session, u):
        u = login(session, 'karesansui', 'pass')
        print u

########NEW FILE########
__FILENAME__ = watch
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from sqlalchemy import and_, or_

from karesansui.db.model.watch import Watch
from karesansui.db.model.machine import Machine
from karesansui.db.access import dbsave, dbupdate, dbdelete
from karesansui.db.access.search import findbyand as _findbyand, \
     findbyor as _findbyor

# -- all
def findbyall(session, is_deleted=False):
    return session.query(Watch).filter(
        Watch.is_deleted == is_deleted).all()

def findby1(session, watch_id, is_deleted=False):
    return session.query(Watch).filter(
        Watch.id == watch_id).filter(
        Watch.is_deleted == is_deleted).first()

def findbyallmachine(session, machine, is_deleted=False):
    return session.query(Watch).filter(
        Watch.machine_id == machine.id).filter(
        Watch.is_deleted == is_deleted).all()

def findbyallplugin(session, plugin, is_deleted=False):
    return session.query(Watch).filter(
        Watch.plugin == plugin).filter(
        Watch.is_deleted == is_deleted).all()

def findby1name(session, name, is_deleted=False):
    return session.query(Watch).filter(
        Watch.name == name).filter(
        Watch.is_deleted == is_deleted).first()

def findbyand(session, query):
    return _findbyand(session, query, Watch, [Watch.name])

def findbyname_or_plugin(session, query):
    ret = _findbyor(session, query, Watch, [Watch.name, Watch.plugin])
    return ret 

def is_uniq_duplication(session, machine, plugin, plugin_selector, is_deleted=False):
    and_clause = and_()
    and_clause.append(Watch.machine_id == machine.id)
    and_clause.append(Watch.plugin == plugin)
    and_clause.append(Watch.plugin_selector == plugin_selector)
    and_clause.append(Watch.is_deleted == is_deleted)

    ret = session.query(Watch).filter(and_clause).all()

    if 1 <= len(ret):
        return True
    else:
        return False


@dbupdate
def logical_delete(session, watch):
    watch.is_deleted = True
    return session.add(watch)

@dbsave
def save(session, watch):
    session.add(watch)

@dbupdate
def update(session, watch):
    session.add(watch)
    
# new instance
new = Watch

def test(session):
    from karesansui.db.access.user import findby1 as user_findby1
    user = user_findby1(session, 1)
    from karesansui.db.access.machine import findby1 as machine_findby1
    machine = machine_findby1(session, 1)

    plugin_selector = """<Match>
plugin hoge
</Match>"""

    warning_mail_body = """To: to@example.com
From: spam <from@example.com>
Subject: warning mail!!
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit

warning
"""
    failure_mail_body = """To: to@example.com
From: spam <from@example.com>
Subject: warning mail!!
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit

warning
"""
    okay_mail_body = """To: to@example.com
From: spam <from@example.com>
Subject: warning mail!!
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit

warning
"""
    import os
    watch = Watch(created_user=user,
                  modified_user=user,
                  machine=machine,
                  name='dummy_watch_%s' % str(os.getpid()),
                  plugin='cpu',
                  plugin_selector=plugin_selector,
                  karesansui_version='1.2.0',
                  collectd_version='4.9.1',
                  continuation_count=1,
                  prohibition_period=1,
                  warning_value="warning_value",
                  is_warning_percentage=True,
                  is_warning_script=False,
                  warning_script="warning_script",
                  is_warning_mail=True,
                  warning_mail_body=warning_mail_body,
                  failure_value="failure_value",
                  is_failure_percentage=True,
                  is_failure_script=True,
                  failure_script="failure_script",
                  is_failure_mail=True,
                  failure_mail_body=failure_mail_body,
                  is_okay_script=True,
                  okay_script="okay_script",
                  is_okay_mail=True,
                  okay_mail_body=okay_mail_body,
                  notify_mail_to='to@example.com',
                  notify_mail_from='from@example.com',
                  is_deleted=False,
                  )

    save(session, watch)
    session.commit()
    _all = findbyall(session)
    _findby1 = findby1(session, watch.id)
    _findbyallmachine = findbyallmachine(session, watch.machine)
    _findbyallplugin = findbyallplugin(session, watch.plugin)
    _findby1name = findby1name(session, watch.name)
    _findbyname_or_plugin = findbyname_or_plugin(session, 'mmy')
    _is_uniq_duplication = is_uniq_duplication(session, 'dummy_watch_13161', 'cpu', machine)
    import pdb; pdb.set_trace()
    print ''

if __name__ == '__main__':
    test()

########NEW FILE########
__FILENAME__ = _2pysilhouette
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import time
import logging

from pysilhouette.db.access import \
    jobgroup_findbyall, jobgroup_findbyall_limit, jobgroup_findbystatus, \
    jobgroup_findbyuniqkey, jobgroup_findbyid, jobgroup_update, \
    job_findbyjobgroup_id, job_update, job_result_action, job_result_rollback, \
    get_progress, up_progress, \
    save as jg_save, update as jg_update, delete as jg_delete

from pysilhouette.db.model import JOBGROUP_TYPE

from karesansui.db.model._2pysilhouette import Job, JobGroup, JOBGROUP_STATUS
from karesansui.db.access import dbsave, dbupdate, dbdelete
import karesansui.db.access.search
import karesansui.db.access.machine2jobgroup

logger = logging.getLogger('karesansui.db.access._2pysilhouette')

def jg_findbyall(session, jobgroup_ids=None, status=None, desc=False):

    query = session.query(JobGroup)

    if not jobgroup_ids is None:
        query = query.filter(JobGroup.id.in_(jobgroup_ids))

    if not status is None:
        query = query.filter(JobGroup.status == status)

    if desc is True:
        return query.order_by(JobGroup.id.desc()).all()
    else:
        return query.order_by(JobGroup.id.asc()).all()


def jg_findby1(session, jobgroup_id):
    return session.query(JobGroup).filter(JobGroup.id == jobgroup_id).first()

def jg_findbyalltype(session, _type,
                     jobgroup_ids=None, status=None,
                     desc=False):
    query = session.query(JobGroup)

    if not jobgroup_ids is None:
        query = query.filter(JobGroup.id.in_(jobgroup_ids))

    if not status is None:
        query = query.filter(JobGroup.status == status)

    if _type == JOBGROUP_TYPE["SERIAL"]:
        query = query.filter(JobGroup.type == JOBGROUP_TYPE["SERIAL"])
    elif _type == JOBGROUP_TYPE["PARALLEL"]:
        query = query.filter(JobGroup.type == JOBGROUP_TYPE["PARALLEL"])

    if desc is True:
        return query.order_by(JobGroup.id.desc()).all()
    else:
        return query.order_by(JobGroup.id.asc()).all()

def jg_findbylimit(session, limit, desc=False):
    if desc is True:
        return session.query(JobGroup).order_by(JobGroup.id.desc()).all()[:limit]
    else:
        return session.query(JobGroup).order_by(JobGroup.id.asc()).all()[:limit]

def jg_findbyserial_limit(session, limit, desc=False):
    if desc is True:
        return session.query(JobGroup).filter(
            JobGroup.type == JOBGROUP_TYPE["SERIAL"]).order_by(
            JobGroup.id.desc()).limit(limit).all()
    else:
        return session.query(JobGroup).filter(
            JobGroup.type == JOBGROUP_TYPE["SERIAL"]).order_by(
            JobGroup.id.asc()).limit(limit).all()

def jobgroup_findbyuniqkey_limit(session, uniq_key, limit, desc=False):
    if uniq_key:
        if desc is True:
            return session.query(JobGroup).filter(JobGroup.uniq_key == uniq_key).order_by(JobGroup.id.desc()).all()[:limit]
        else:
            return session.query(JobGroup).filter(JobGroup.uniq_key == uniq_key).order_by(JobGroup.id.asc()).all()[:limit]
    else:
        return None

def save_job_collaboration(karesansui_session,
                           pysilhouette_session,
                           machine2jobgroup,
                           jobgroup):
    """<comment-ja>
    ジョブの登録を行う。
      - Pysilhouette:JobgroupテーブルとKaresansui:machine2jobgroupテーブルに
      登録を行います。
    @param karesansui_session: Karesansui Database Session
    @type karesansui_session: Session
    @param pysilhouette_session: Pysilhouette Database Session
    @type pysilhouette_session: Session
    @param machine2jobgroup: Table Model(Karesansui)
    @type machine2jobgroup: karesansui.db.model.machine2jobgroup.Machine2Jobgroup
    @param jobgroup: Table Model(PySilhouette)
    @type jobgroup: pysilhouette.db.model.JobGroup
    @return 
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # JobGroup INSERT
    jg_save(pysilhouette_session, jobgroup)
    pysilhouette_session.commit()
    
    # Machine2JobGroup INSERT
    try:
        machine2jobgroup.jobgroup_id = jobgroup.id
        karesansui.db.access.machine2jobgroup.save(karesansui_session, machine2jobgroup)
        karesansui_session.commit()
    except:
        try:
            jg_delete(pysilhouette_session, jobgroup)
            pysilhouette_session.commit()
        except:
            # rollback(jobgroup)
            logger.critical('Failed to register the JobGroup. #6 - jobgroup id=%d' \
                              % jobgroup.id)
        raise # throw

def corp(karesansui_session,
          pysilhouette_session,
          machine2jobgroup,
          jobgroup,
          waittime=1,
          timeout=20):
    """<comment-ja>
    Pysilhouette経由で権限昇格によるコマンド実行を行います。
    </comment-ja>
    <comment-en>
    Can only reading (parallel)
    </comment-en>
    """
    save_job_collaboration(karesansui_session, pysilhouette_session, machine2jobgroup, jobgroup)

    timeout = int(timeout)
    waittime = int(waittime)

    start_time = time.time()
    res = False
    while True:
        if (int(time.time() - start_time)) <= timeout:
            pysilhouette_session.refresh(jobgroup)
            logger.debug('Reading JobGroup info - id=%d, status=%s' \
                         % (jobgroup.id, jobgroup.status))
            if jobgroup.status == JOBGROUP_STATUS['OK']:
                res = True
                break
        else:
            res = False # TimeOut
            logger.warn('Reading JobGroup - Result=Read Timeout, id=%d, status=%s' \
                                 % (jobgroup.id, jobgroup.status))
            break
        time.sleep(waittime)

    print 'Reading JobGroup - runtime=%d' % (int(time.time() - start_time))
    logger.fatal('Reading JobGroup - runtime=%d' % (int(time.time() - start_time)))
    return res


if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = machine
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation, backref
import karesansui
import karesansui.db.model
import karesansui.db.model.notebook
import karesansui.db.model.user
import karesansui.db.model.tag
import karesansui.db.model.machine2tag
from karesansui.lib.const import ICON_DIR_TPL, DEFAULT_LANGS


def get_machine_table(metadata, now):
    """<comment-ja>
    マシン(Machine)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('machine', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('parent_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('machine.id'),
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('notebook_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('notebook.id'),
                                              ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('uniq_key', sqlalchemy.Unicode(36),
                                              nullable=False,
                                              unique=True,
                                              ),
                            sqlalchemy.Column('name', sqlalchemy.String(256),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('attribute', sqlalchemy.SmallInteger,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('hypervisor', sqlalchemy.SmallInteger,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('hostname', sqlalchemy.String(256),
                                              nullable=True,
                                              unique=True,
                                              ),
                            sqlalchemy.Column('icon', sqlalchemy.String(256),
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_deleted', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Machine(karesansui.db.model.Model):
    """<comment-ja>
    machineテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    #def __init__(self):
        #pass
    
    def __init__(self, created_user, modified_user, \
                 uniq_key, name, attribute, hypervisor,
                 notebook, tags=[], hostname=None, icon=None, \
                 is_deleted=False, parent=None):
        """<comment-ja>
        @param created_user: 作成者
        @type created_user: User
        @param modified_user: 最終更新者
        @type modified_user: User
        @param uniq_key: ユニークキー
        @type uniq_key: str example) u'00000000-1111-2222-3333-444444444444'
        @param name: マシン名
        @type name: str
        @param attribute: 属性(ホスト or ゲスト...)
        @type attribute: ATTRIBUTE
        @param hypervisor: ハイパーバイザ
        @type hypervisor: HYPERVISOR
        @param notebook: ノートブック
        @type notebook: Notebook
        @param tag: タグリスト
        @type tag: [Tag...]
        @param hostname: ホスト名
        @type hostname: str
        @param icon: ファイル名
        @type icon: String
        @param is_deleted: 削除フラグ
        @type is_deleted: bool 
        @param parent: 親マシン
        @type parent: Machine
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.created_user = created_user
        self.modified_user = modified_user
        self.uniq_key = uniq_key
        self.name = name
        self.attribute = attribute
        self.hypervisor = hypervisor
        self.notebook = notebook
        self.tags = tags
        self.hostname = hostname
        self.icon = icon
        self.is_deleted = is_deleted
        self.parent = parent


    def webicon(self):
        if self.icon is None:
            return None
        else:
            import web
            return ICON_DIR_TPL % (web.ctx.homepath, self.icon)
    
    def realicon(self):
        if self.icon is None:
            return None
        else:
            return ICON_DIR_TPL % (karesansui.dirname, self.icon)

    def get_json(self, languages):
        import web
        ret = {}
        ret["id"] = self.id
        #ret["icon"] = "%s/data/icon/machine/%d"  % (web.ctx.homepath, self.id)
        ret["icon"] = self.webicon()
        ret["attribute"] = self.attribute
        ret["hostname"] = self.hostname
        try:
            ret["created"] = self.created.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["created"] = ""

        ret["created_user_id"] = self.created_user_id
        ret["is_deleted"] = self.is_deleted
        try:
            ret["modified"] = self.modified.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["modified"] = ""

        ret["modified_user_id"] = self.modified_user_id
        ret["name"] = self.name
        ret["notebook_id"] = self.notebook_id
        ret["parent_id"] = self.parent_id
        ret["uniq_key"] = self.uniq_key
        ret["hypervisor"] = self.hypervisor

        try:
            ret["created_user"] = self.created_user.get_json(languages)
            ret["modified_user"] = self.modified_user.get_json(languages)
            ret["notebook"] = self.notebook.get_json(languages)
        except:
            ret["created_user"] = ""
            ret["modified_user"] = ""
            ret["notebook"] = ""
        
        #if  self.parent:
        #    ret["parent"] = self.parent.get_json()
        #else:
        #    ret["parent"] = None
        
        ret["children"] = []
        if self.children:
            for x in self.children:
                if not x.is_deleted:
                    ret["children"].append(x.get_json(languages))
        
        ret["tags"] = []
        if self.tags:
            for x in self.tags:
                ret["tags"].append(x.get_json(languages))
            
        return ret

    def __repr__(self):
        return "Machine<'%s, %s, %s'>" % (self.uniq_key,
                                   self.name,
                                   self.is_deleted)
        
def reload_mapper(metadata, now):
    """<comment-ja>
    Machine(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_machine = get_machine_table(metadata, now)
    t_machine_tag = metadata.tables['machine2tag']
    t_user = metadata.tables['user']
    
    mapper(Machine, t_machine, properties={
        'children' : relation(Machine,
                              backref=backref('parent',
                                              remote_side=[t_machine.c.id])),
        'notebook' : relation(karesansui.db.model.notebook.Notebook),
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_machine.c.created_user_id==t_user.c.id),
        'modified_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_machine.c.modified_user_id==t_user.c.id),
        'tags' : relation(karesansui.db.model.tag.Tag,
                         secondary=t_machine_tag,
                         backref="machine"),
        })
    

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )
    
    metadata = sqlalchemy.MetaData(bind=engine)

    # relation
    karesansui.db.model.notebook.reload_mapper(metadata)
    karesansui.db.model.user.reload_mapper(metadata)
    karesansui.db.model.tag.reload_mapper(metadata)

    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()
    print ""
    # INSERT
    # SELECT One
    # UPDATE
    # DELETE


########NEW FILE########
__FILENAME__ = machine2jobgroup
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation
import karesansui.db.model
import karesansui.db.model.user
import karesansui.db.model.machine

def get_machine2jobgroup_table(metadata, now):
    """<comment-ja>
    (Machine2jobgroup)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('machine2jobgroup', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('machine_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('machine.id'),
                                              ),
                            sqlalchemy.Column('jobgroup_id', sqlalchemy.Integer,
                                              nullable=False,
                                              ),
                            # PySilhouette 
                            sqlalchemy.Column('uniq_key', sqlalchemy.Unicode(36),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'), 
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'), 
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Machine2Jobgroup(karesansui.db.model.Model):
    """<comment-ja>
    machine2jobgroupテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, machine, jobgroup_id, uniq_key, created_user, modified_user):
        """<comment-ja>
        @param machine_id: マシン
        @type machine_id: Machine
        @param jobgroup_id : ジョブグループID
        @type jobgroup_id: int
        @param uniq_key: ユニークキー PySilhouette
        @type uniq_key: str
        @param created_user_id: 作成者
        @type created_user_id: User
        @param created_user_id: 最終更新者
        @type created_user_id: User
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.machine = machine
        self.jobgroup_id = jobgroup_id
        self.uniq_key = uniq_key
        self.created_user = created_user
        self.modified_user = modified_user
        
    def __repr__(self):
        return "Machine2Jobgroup<'%d, %d, %s'>" % (self.machine.id, self.jobgroup_id, self.uniq_key)

def reload_mapper(metadata, now):
    """<comment-ja>
    Machine2Jobgroup(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_machine2jobgroup = get_machine2jobgroup_table(metadata, now)
    t_machine = metadata.tables["machine"]
    t_user = metadata.tables["user"]
    mapper(Machine2Jobgroup, t_machine2jobgroup, properties={
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_machine2jobgroup.c.created_user_id==t_user.c.id),
        
        'modified_user' : relation(karesansui.db.model.user.User,
                                   primaryjoin=t_machine2jobgroup.c.modified_user_id==t_user.c.id),
        
        'machine' : relation(karesansui.db.model.machine.Machine,
                             primaryjoin=t_machine2jobgroup.c.machine_id==t_machine.c.id,
                             ),
        })
    
if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )   
    
    metadata = sqlalchemy.MetaData(bind=engine)
    # relation
    karesansui.db.model.machine.reload_mapper(metadata)
    karesansui.db.model.notebook.reload_mapper(metadata)
    karesansui.db.model.user.reload_mapper(metadata)
    karesansui.db.model.tag.reload_mapper(metadata)

    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = machine2tag
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers
import karesansui.db.model

def get_machine2tag_table(metadata, now):
    """<comment-ja>
    Machine2tagのテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('machine2tag', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('tag_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('tag.id'),
                                              ),
                            sqlalchemy.Column('machine_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('machine.id'),
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Machine2Tag(karesansui.db.model.Model):
    """<comment-ja>
    machine2tagテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, tag_id, machine_id):
        """<comment-ja>
        @param tag_id: タグID
        @type tag_id: int
        @param machine_id: マシンID
        @type machine_id: int
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.tag_id = tag_id
        self.machine_id = machine_id

    def __repr__(self):
        return "Machine2tag<'%d, %s, %s'>" % (self.id, self.tag_id, self.machine_id)

def reload_mapper(metadata, now):
    """<comment-ja>
    machine2tag(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_machine2tag = get_machine2tag_table(metadata, now)

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', #DEBUG
                                      echo=True,
                                      echo_pool=True
                                      )
    
    metadata = sqlalchemy.MetaData(bind=engine)
    t_machine = get_machine_table(metadata)
    sqlalchemy.orm.mapper(Machine, t_machine)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE


########NEW FILE########
__FILENAME__ = mailtemplate
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation
import karesansui
import karesansui.db.model
import karesansui.db.model.machine
from karesansui.lib.const import DEFAULT_LANGS

def get_mailtemplate_table(metadata, now):
    """<comment-ja>
    メールテンプレート(Mailtemplate)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('mailtemplate', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('name', sqlalchemy.String(256),
                                              nullable=False,
                                              unique=True,
                                              ),
                            sqlalchemy.Column('encoding', sqlalchemy.String(12),
                                              nullable=False,
                                              default='ascii'
                                              ),
                            sqlalchemy.Column('mail_to', sqlalchemy.Text,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('mail_from', sqlalchemy.Text,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('mail', sqlalchemy.Text,
                                              nullable=False,
                                              ),
                            # 256(FQDN) + 1(":") + 5(65535) = 262
                            sqlalchemy.Column('mta', sqlalchemy.String(262),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('cc', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('bcc', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Mailtemplate(karesansui.db.model.Model):
    """<comment-ja>
    MailTemplateテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, created_user, modified_user,
                 name, mail_to, mail_from, mail, mta,
                 cc=None, bcc=None, encoding=None):
        """<comment-ja>
        @param created_user: 作成者
        @type created_user: User
        @param modified_user: 最終更新者
        @type modified_user: User
        @param name: メールテンプレート名
        @type name: str
        @param mail_to: 宛先メールアドレス
        @type mail_to: str
        @param mail_from: 差出人メールアドレス
        @type mail_from: str
        @param mail: 本文
        @type mail: str
        @param mta: SMTPサーバー
        @type mta: str
        @param cc: Cc
        @type cc: str
        @param bcc: Bcc
        @type bcc: str
        @param encoding: Encoding
        @type encoding: str
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.created_user = created_user
        self.modified_user = modified_user
        self.name = name
        self.mail_to = mail_to
        self.mail_from = mail_from
        self.mail = mail
        self.mta = mta
        self.cc = cc
        self.bcc = bcc
        self.encoding = encoding

    def get_json(self, languages):
        ret = {}
        ret["id"] = self.id

        ret["name"] = self.name
        ret["mail_to"] = self.mail_to
        ret["mail_from"] = self.mail_from
        ret["mail"] = self.mail
        ret["mta"] = self.mta
        ret["cc"] = self.cc
        ret["bcc"] = self.bcc
        ret["encoding"] = self.encoding

        ret["created_user_id"] = self.created_user_id
        ret["created_user"] = self.created_user.get_json(languages)

        ret["modified_user_id"] = self.modified_user_id
        ret["modified_user"] = self.modified_user.get_json(languages)

        ret["created"] = self.created.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        ret["modified"] = self.modified.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])

        return ret
    
    def __repr__(self):
        return "MailTemplate<'%s, from=%s, to=%s'>" \
               % (self.name, self.mail_from, self.mail_to)

def reload_mapper(metadata, now):
    """<comment-ja>
    MailTemplate(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_mailtemplate = get_mailtemplate_table(metadata, now)
    t_user = metadata.tables['user']

    mapper(Mailtemplate, t_mailtemplate, properties={
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_mailtemplate.c.created_user_id==t_user.c.id),
        'modified_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_mailtemplate.c.modified_user_id==t_user.c.id),
        })

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )   
       
    metadata = sqlalchemy.MetaData(bind=engine)
    if metadata.bind.name == 'sqlite':
        _now = sqlalchemy.func.datetime('now', 'localtime')
    else:
        _now = sqlalchemy.func.now()
                            
    reload_mapper(metadata, _now)
    import pdb; pdb.set_trace()
    
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = notebook
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers
import karesansui
import karesansui.db.model
import karesansui.db.model.machine
from karesansui.lib.const import DEFAULT_LANGS

def get_notebook_table(metadata, now):
    """<comment-ja>
    ノートブック(Notebook)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('notebook', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('title', sqlalchemy.String(64),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('value', sqlalchemy.Text,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Notebook(karesansui.db.model.Model):
    """<comment-ja>
    notebookテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, title, value):
        """<comment-ja>
        @param : タイトル
        @type : str
        @param : ノート
        @type : str
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.title = title
        self.value = value

    def get_json(self, languages):
        ret = {}
        ret["id"] = self.id
        ret["title"] = self.title
        ret["value"] = self.value
        try:
            ret["created"] = self.created.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["created"] = "unknown"
        try:
            ret["modified"] = self.modified.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["modified"] = "unknown"
        return ret
    
    def __repr__(self):
        return "Notebook<%s'>" % (self.title)

def reload_mapper(metadata, now):
    """<comment-ja>
    Notebook(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_notebook = get_notebook_table(metadata, now)
    mapper(Notebook, t_notebook)

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )   
       
    metadata = sqlalchemy.MetaData(bind=engine)
    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = option
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation
import karesansui
import karesansui.db.model
from karesansui.lib.const import DEFAULT_LANGS

def get_option_table(metadata, now):
    """<comment-ja>
    Option のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('option', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('key', sqlalchemy.String(12),
                                              nullable=False,
                                              unique=True,
                                              ),
                            sqlalchemy.Column('value', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Option(karesansui.db.model.Model):
    """<comment-ja>
    Optionテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, created_user, modified_user,
                 key, value=None):
        """<comment-ja>
        @param created_user: 作成者
        @type created_user: User
        @param modified_user: 最終更新者
        @type modified_user: User
        @param key: option key
        @type key: str
        @param value: option value
        @type value: str(Text)
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.created_user = created_user
        self.modified_user = modified_user
        self.key = key
        self.value = value

    def get_json(self, languages):
        ret = {}
        ret["id"] = self.id

        ret["key"] = self.key
        ret["value"] = self.value

        ret["created_user_id"] = self.created_user_id
        ret["created_user"] = self.created_user.get_json(languages)

        ret["modified_user_id"] = self.modified_user_id
        ret["modified_user"] = self.modified_user.get_json(languages)

        try:
            ret["created"] = self.created.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["created"] = "unknown"
        try:
            ret["modified"] = self.modified.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["modified"] = "unknown"

        return ret
    
    def __repr__(self):
        return "Option<'key=%s, value=%s>" \
               % (self.key, self.value)

def reload_mapper(metadata, now):
    """<comment-ja>
    Option(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_option = get_option_table(metadata, now)
    t_user = metadata.tables['user']

    mapper(Option, t_option, properties={
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_option.c.created_user_id==t_user.c.id),
        'modified_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_option.c.modified_user_id==t_user.c.id),
        })

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )   
       
    metadata = sqlalchemy.MetaData(bind=engine)
    if metadata.bind.name == 'sqlite':
        _now = sqlalchemy.func.datetime('now', 'localtime')
    else:
        _now = sqlalchemy.func.now()
                            
    reload_mapper(metadata, _now)
    import pdb; pdb.set_trace()
    
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation, backref
import karesansui
import karesansui.db.model
import karesansui.db.model.notebook
import karesansui.db.model.machine
import karesansui.db.model.user
from karesansui.lib.const import DEFAULT_LANGS

def get_snapshot_table(metadata, now):
    """<comment-ja>
    スナップショット(Snapshot)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('snapshot', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('parent_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey("snapshot.id"),
                                              ),
                            sqlalchemy.Column('machine_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('machine.id'),
                                              ),
                            sqlalchemy.Column('notebook_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('notebook.id'),
                                             ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('name', sqlalchemy.String(256),
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_deleted', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Snapshot(karesansui.db.model.Model):
    """<comment-ja>
    snapshotテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, machine, name, created_user,  modified_user,
                 notebook, parent=None, is_deleted=False):
        """<comment-ja>
        @param machine: マシン
        @type machine: Machine
        @param name: スナップショット名
        @type name: str
        @param created_user: 作成者
        @type created_user: User
        @param modified_user: 最終更新者 
        @type modified_user: User
        @param notebook: ノートブック
        @type notebook: Notebook
        @param parent: 親スナップショット
        @type parent: Snapshot
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.machine = machine
        self.name = name
        self.created_user = created_user
        self.modified_user = modified_user
        self.notebook = notebook
        self.parent = parent
        self.is_deleted = is_deleted

    def get_json(self, languages):
        ret = {}
        ret["id"] = self.id
        ret["parent_id"] = self.parent_id
        ret["created"] = self.created.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        
        ret["created_user_id"] = self.created_user_id
        ret["machine_id"] = self.machine_id
        ret["modified"] = self.modified.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        
        ret["modified_user_id"] = self.modified_user_id
        ret["is_deleted"] = self.is_deleted
        ret["name"] = self.name
        ret["notebook_id"] = self.notebook_id
        
        ret["machine"] = self.machine.get_json(languages)
        ret["modified_user"] = self.modified_user.get_json(languages)
        ret["created_user"] = self.created_user.get_json(languages)
        ret["notebook"] = self.notebook.get_json(languages)

        #if self.parent:
        #    ret["parent"] = self.parent.get_json()
        #else:
        #    ret["parent"] = None

        ret["children"] = []
        if self.children:
            for x in self.children:
                ret["children"].append(x.get_json(languages))

        return ret
    
    def __repr__(self):
        return "Snapshot<'%s'>" % (self.name)

def reload_mapper(metadata, now):
    """<comment-ja>
    Snapshot(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_snapshot = get_snapshot_table(metadata, now)
    t_machine = metadata.tables['machine']
    t_user = metadata.tables['user']

    mapper(Snapshot, t_snapshot, properties={
        'children' : relation(Snapshot,
                              backref=backref('parent',
                                              remote_side=[t_snapshot.c.id])),
                                   
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_snapshot.c.created_user_id==t_user.c.id),
        
        'modified_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_snapshot.c.modified_user_id==t_user.c.id),
        
        'machine' : relation(karesansui.db.model.machine.Machine,
                             primaryjoin=t_snapshot.c.machine_id==t_machine.c.id,
                             ),
        'notebook' : relation(karesansui.db.model.notebook.Notebook),
        })

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', #DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )
    metadata = sqlalchemy.MetaData(bind=engine)    # relation
    karesansui.db.model.machine.reload_mapper(metadata)
    karesansui.db.model.notebook.reload_mapper(metadata)
    karesansui.db.model.user.reload_mapper(metadata)
    karesansui.db.model.tag.reload_mapper(metadata)
    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = tag
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation
import karesansui
import karesansui.db.model
from karesansui.lib.const import DEFAULT_LANGS  

def get_tag_table(metadata, now):
    """<comment-ja>
    タグ(Tag)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('tag', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
#                            sqlalchemy.Column('notebook_id', sqlalchemy.Integer,
#                                              sqlalchemy.ForeignKey('notebook.id'),
#                                              ),
                            sqlalchemy.Column('name', sqlalchemy.String(24),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),

                            )

class Tag(karesansui.db.model.Model):
    """<comment-ja>
    tagテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
#    def __init__(self, name, notebook):
    def __init__(self, name):
        """<comment-ja>
        @param name: タグ名
        @type name: str
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.name = name
#        self.notebook = notebook

    def get_json(self, languages):
        ret = {} 
        ret["id"] = self.id
#        ret["notebook_id"] = self.notebook_id
        ret["name"] = self. name
        try:
            ret["created"] = self.created.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["created"] = "unknown"
        try:
            ret["modified"] = self.modified.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["modified"] = "unknown"
        
        return ret
      
    def __repr__(self):
        return "Tag<'%s'>" % (self.name)

def reload_mapper(metadata, now):
    """<comment-ja>
    Tag(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_tag = get_tag_table(metadata, now)
    mapper(Tag, t_tag, properties={
#        'notebook' : relation(karesansui.db.model.notebook.Notebook),
    })

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', #DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )   
    
    metadata = sqlalchemy.MetaData(bind=engine)
    # relation
#    karesansui.db.model.notebook.reload_mapper(metadata)
    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    # SELECT One
    # UPDATE
    # DELETE

########NEW FILE########
__FILENAME__ = user
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers

import karesansui
import karesansui.db.model
from karesansui.lib.const import DEFAULT_LANGS

def get_user_table(metadata, now):
    """<comment-ja>
    ユーザ(User)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('user', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('email', sqlalchemy.String(256),
                                              unique=True,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('password', sqlalchemy.String(40),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('salt', sqlalchemy.Unicode(16),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('nickname', sqlalchemy.Unicode(16),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('languages', sqlalchemy.Unicode(6),
                                              default=u'ja_JP',
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class User(karesansui.db.model.Model):
    """<comment-ja>
    ユーザテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, email, password, salt, nickname, languages=None):
        """<comment-ja>
        @param email: E-mail
        @type email: str
        @param password: パスワード
        @type password: str
        @param salt: salt
        @type salt: str
        @param nickname: ニックネーム
        @type nickname: str
        @param languages: 言語
        @type languages str
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.password = password
        self.salt = salt
        self.email = email
        self.nickname = nickname
        self.languages = languages

    def get_json(self, languages):
        ret = {}
        ret["id"] = self.id 
        ret["email"] = self.email
        #ret["password"] = self.password
        #ret["salt"] = self.salt
        ret["nickname"] = self.nickname
        ret["languages"] = self.languages
        try:
            ret["created"] = self.created.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["created"] = "unknown"
        try:
            ret["modified"] = self.modified.strftime(
                DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        except:
            ret["modified"] = "unknown"
        
        return ret
    
    def __repr__(self):
        return "User<'%s, %s'>" % (
            self.email, self.languages)

def reload_mapper(metadata, now):
    """<comment-ja>
    User(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_user = get_user_table(metadata, now)
    mapper(User, t_user)

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )
    
    metadata = sqlalchemy.MetaData(bind=engine)
    reload_mapper(metadata)
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()

    # INSERT
    from karesansui.lib.crypt import sha1encrypt
    (password, salt) = sha1encrypt(u'password')
    from karesansui.lib.utils import uni_force
    _m_u = User(u'hoge@localhost', uni_force(password), unicode(salt, 'utf-8'), u'ja', u'ja_JP')
    session.add(_m_u)
    session.commit()
    # SELECT One
    u = session.query(User).filter(User.email == u'hoge@localhost').one()
    
    print _m_u.__repr__()
    # UPDATE
    _m_u.email = u'foo@localhost'
    session.add(_m_u)
    session.commit()
    # DELETE
    _m_u = session.query(User).filter(User.email == u'foo@localhost').one()
    session.delete(_m_u)
    session.commit()

########NEW FILE########
__FILENAME__ = watch
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sqlalchemy
from sqlalchemy.orm import mapper, clear_mappers, relation, backref
import karesansui
import karesansui.db.model
from karesansui.lib.const import DEFAULT_LANGS

def get_watch_table(metadata, now):
    """<comment-ja>
    監視(watch)のテーブル定義を返却します。
    @param metadata: MetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    @return: sqlalchemy.schema.Table
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return sqlalchemy.Table('watch', metadata,
                            sqlalchemy.Column('id', sqlalchemy.Integer,
                                              primary_key=True,
                                              autoincrement=True,
                                              ),
                            sqlalchemy.Column('machine_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('machine.id'),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('created_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('modified_user_id', sqlalchemy.Integer,
                                              sqlalchemy.ForeignKey('user.id'),
                                              ),
                            sqlalchemy.Column('name', sqlalchemy.String(256),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('plugin', sqlalchemy.String(256),
                                              nullable=False,
                                              ),                                              
                            sqlalchemy.Column('plugin_selector', sqlalchemy.Text,
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('continuation_count', sqlalchemy.Integer,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('prohibition_period', sqlalchemy.Integer,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('warning_value', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_warning_percentage', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('is_warning_script', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('warning_script', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_warning_mail', sqlalchemy.Boolean,
                                              default=True,
                                              ),
                            sqlalchemy.Column('warning_mail_body', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('failure_value', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_failure_percentage', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('is_failure_script', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('failure_script', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_failure_mail', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('failure_mail_body', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_okay_script', sqlalchemy.Boolean,
                                              default=True,
                                              ),
                            sqlalchemy.Column('okay_script', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('is_okay_mail', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('okay_mail_body', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('notify_mail_to', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('notify_mail_from', sqlalchemy.Text,
                                              nullable=True,
                                              ),
                            sqlalchemy.Column('karesansui_version', sqlalchemy.String(12),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('collectd_version', sqlalchemy.String(12),
                                              nullable=False,
                                              ),
                            sqlalchemy.Column('is_deleted', sqlalchemy.Boolean,
                                              default=False,
                                              ),
                            sqlalchemy.Column('created', sqlalchemy.DateTime,
                                              default=now,
                                              ),
                            sqlalchemy.Column('modified', sqlalchemy.DateTime,
                                              default=now,
                                              onupdate=now,
                                              ),
                            )

class Watch(karesansui.db.model.Model):
    """<comment-ja>
    watchテーブルモデルクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, created_user, modified_user,
                 name,
                 plugin,
                 plugin_selector,
                 karesansui_version,
                 collectd_version,
                 machine,
                 continuation_count=None,
                 prohibition_period=None,
                 warning_value=None,
                 is_warning_percentage=False,
                 is_warning_script=False,
                 warning_script=None,
                 is_warning_mail=True,
                 warning_mail_body=None,
                 failure_value=None,
                 is_failure_percentage=False,
                 is_failure_script=False,
                 failure_script=None,
                 is_failure_mail=False,
                 failure_mail_body=None,
                 is_okay_script=False,
                 okay_script=None,
                 is_okay_mail=False,
                 okay_mail_body=None,
                 notify_mail_to=None,
                 notify_mail_from=None,
                 is_deleted=False,
                 ):
        """<comment-ja>
        @param created_user: 作成者
        @type  created_user: User
        @param modified_user: 最終更新者
        @type  modified_user: User
        @param name: 名前
        @type  name: str
        @param plugin: プラグイン名
        @type  plugin: str
        @param plugin_selector: プラグインセレクタ
        @type  plugin_selector: str(Text)
        @param karesansui_version: 作成したKaresansuiのバージョン
        @type  karesansui_version: str
        @param collectd_version: 作成したcollectdのバージョン
        @type  collectd_version: str
        @param machine: 監視実行マシン
        @type  machine: machine ID
        @param continuation_count: 異常検出の許容回数
        @type  continuation_count: int
        @param prohibition_period: 再アクション禁止時間
        @type  prohibition_period: int
        @param warning_value: Warningになる閾値
        @type  warning_value: str(Text)
        @param is_warning_percentage: warning_valueを%として使うか
        @type  is_warning_percentage: bool
        @param is_warning_script: Warningでスクリプトを実行するか
        @type  is_warning_script: bool
        @param warning_script: Warningで実行するスクリプト
        @type  warning_script: str(Text)
        @param is_warning_mail: Warningでメールを送信するか
        @type  is_warning_mail: bool
        @param warning_mail_body: Warningで送信するメール本体
        @type  warning_mail_body:
        @param failure_value: Failureになる閾値
        @type  failure_value: str(Text)
        @param is_failure_percentage: failure_valueを%として使うか
        @type  is_failure_percentage: bool
        @param is_failure_script: Failureでスクリプトを実行するか
        @type  is_failure_script: bool
        @param failure_script: Failureで実行するスクリプト
        @type  failure_script: str(Text)
        @param is_failure_mail: Failureでメールを送信するか
        @type  is_failure_mail: bool
        @param failure_mail_body: Failureで送信するメール本体
        @type  failure_mail_body:
        @param is_okay_script: Okayでスクリプトを実行するか
        @type  is_okay_script: bool
        @param okay_script: Okayで実行するスクリプト
        @type  okay_script: str(Text)
        @param is_okay_mail: Okayでメールを送信するか
        @type  is_okay_mail: bool
        @param okay_mail_body: Okayで送信するメール本体
        @type  okay_mail_body:
        @param notify_mail_from: 通知メールのFrom
        @type  notify_mail_from: str(Text)
        @param notify_mail_to: 通知メールのTo
        @type  notify_mail_to: str(Text)
        @param is_deleted: 削除フラグ
        @type  is_deleted: bool
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.created_user = created_user
        self.modified_user = modified_user
        self.name = name
        self.plugin = plugin
        self.plugin_selector = plugin_selector
        self.karesansui_version = karesansui_version
        self.collectd_version = collectd_version
        self.machine = machine
        self.continuation_count = continuation_count
        self.prohibition_period = prohibition_period
        self.warning_value = warning_value
        self.is_warning_percentage = is_warning_percentage
        self.is_warning_script = is_warning_script
        self.warning_script = warning_script
        self.is_warning_mail = is_warning_mail
        self.warning_mail_body = warning_mail_body
        self.failure_value = failure_value
        self.is_failure_percentage = is_failure_percentage
        self.is_failure_script = is_failure_script
        self.failure_script = failure_script
        self.is_failure_mail = is_failure_mail
        self.failure_mail_body = failure_mail_body
        self.is_okay_script = is_okay_script
        self.okay_script = okay_script
        self.is_okay_mail = is_okay_mail
        self.okay_mail_body = okay_mail_body
        self.notify_mail_to = notify_mail_to
        self.notify_mail_from = notify_mail_from
        self.is_deleted = is_deleted

    def get_json(self, languages):
        import web
        ret = {}
        ret["id"] = self.id
        ret["machine"] = self.machine.get_json(languages)

        ret["name"] = self.name
        ret["plugin"] = self.plugin
        ret["plugin_selector"] = self.plugin_selector
        ret["karesansui_version"] = self.karesansui_version
        ret["collectd_version"] = self.collectd_version
        ret["machine"] = self.machine.get_json(languages)
        ret["continuation_count"] = self.continuation_count
        ret["prohibition_period"] = self.prohibition_period
        ret["warning_value"] = self.warning_value
        ret["is_warning_percentage"] = self.is_warning_percentage
        ret["is_warning_script"] = self.is_warning_script
        ret["warning_script"] = self.warning_script
        ret["is_warning_mail"] = self.is_warning_mail
        ret["warning_mail_body"] = self.warning_mail_body
        ret["failure_value"] = self.failure_value
        ret["is_failure_percentage"] = self.is_failure_percentage
        ret["is_failure_script"] = self.is_failure_script
        ret["failure_script"] = self.failure_script
        ret["is_failure_mail"] = self.is_failure_mail
        ret["failure_mail_body"] = self.failure_mail_body
        ret["is_okay_script"] = self.is_okay_script
        ret["okay_script"] = self.okay_script
        ret["is_okay_mail"] = self.is_okay_mail
        ret["okay_mail_body"] = self.okay_mail_body
        ret["notify_mail_to"] = self.notify_mail_to
        ret["notify_mail_from"] = self.notify_mail_from

        ret["created_user"] = self.created_user.get_json(languages)
        ret["modified_user"] = self.modified_user.get_json(languages)
        ret["created"] = self.created.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        ret["created_user_id"] = self.created_user_id
        ret["modified"] = self.modified.strftime(
            DEFAULT_LANGS[languages]['DATE_FORMAT'][1])
        ret["modified_user_id"] = self.modified_user_id
        ret["is_deleted"] = self.is_deleted
        return ret

    def __repr__(self):
        return "Watch<'%s, %s'>" % (self.name,
                                        self.plugin,
                                        )
        
def reload_mapper(metadata, now):
    """<comment-ja>
    Watch(Model)のマッパーをリロードします。
    @param metadata: リロードしたいMetaData
    @type metadata: sqlalchemy.schema.MetaData
    @param now: now
    @type now: Datatime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    t_watch = get_watch_table(metadata, now)
    t_user = metadata.tables['user']
    t_machine = metadata.tables['machine']
    
    mapper(Watch, t_watch, properties={
        'created_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_watch.c.created_user_id==t_user.c.id),
        'modified_user' : relation(karesansui.db.model.user.User,
                                  primaryjoin=t_watch.c.modified_user_id==t_user.c.id),
        'machine' : relation(karesansui.db.model.machine.Machine,
                             primaryjoin=t_watch.c.machine_id==t_machine.c.id),
        })

if __name__ == '__main__':
    import sqlalchemy.orm
    bind_name = 'sqlite:///:memory:'
    engine = sqlalchemy.create_engine(bind_name,
                                      encoding="utf-8",
                                      convert_unicode=True,
                                      #assert_unicode='warn', # DEBUG
                                      echo=True,
                                      echo_pool=False
                                      )
    
    metadata = sqlalchemy.MetaData(bind=engine)

    # relation
    karesansui.db.model.user.reload_mapper(metadata)

    reload_mapper(metadata)
    import pdb; pdb.set_trace()
    metadata.drop_all()
    metadata.create_all()
    Session = sqlalchemy.orm.sessionmaker(bind=engine, autoflush=False)
    session = Session()
    print ""
    # INSERT
    # SELECT One
    # UPDATE
    # DELETE


########NEW FILE########
__FILENAME__ = _2pysilhouette
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from pysilhouette.db.model import *

logger = logging.getLogger('karesansui.db.model._2pysilhouette')

if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = _2pysilhouette
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import logging

from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker, mapper, scoped_session
from sqlalchemy.pool import SingletonThreadPool, QueuePool

import karesansui

from pysilhouette.db.model import *
from pysilhouette.db import Database

# private
__db = None
#__engine = None
#__metadata = None


# function
def get_engine():
    """<comment-ja>
    Databaseを返却します。(Optimistic Singleton)
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    global __db
    if __db is None:
        logger = logging.getLogger("karesansui.pysilhouette.db.engine")
        echo = True
        echo_pool = True

        if karesansui.sheconf['database.url'][:6].strip() == 'sqlite':
            __db = Database(karesansui.sheconf['database.url'],
                          encoding="utf-8",
                          convert_unicode=True,
                          #assert_unicode='warn', # DEBUG
                          echo = echo,
                          echo_pool = echo_pool,
                          )
        else:
            if int(karesansui.sheconf['database.pool.status']) == 0:
                __db = Database(karesansui.sheconf['database.url'],
                              encoding="utf-8",
                              convert_unicode=True,
                              #assert_unicode='warn', # DEBUG
                              poolclass=SingletonThreadPool,
                              #echo = opts.verbose,
                              #echo_pool = opts.verbose,
                              echo=echo,
                              echo_pool=echo_pool
                              )
            else:
                __db = Database(karesansui.sheconf['database.url'],
                              encoding="utf-8",
                              convert_unicode=True,
                              #assert_unicode='warn', # DEBUG
                              poolclass=QueuePool,
                              pool_size=int(karesansui.sheconf['database.pool.size']),
                              max_overflow=int(karesansui.sheconf['database.pool.max.overflow']),
                              #echo = opts.verbose,
                              #echo_pool = opts.verbose,
                              echo=echo,
                              echo_pool=echo_pool
                              )

        __engine = __db.get_engine()

        # mapper!!
        mapper(__db.get_metadata())

        logger.debug('[pysilhouette] engine.name=%s - pool=%s' % (__engine.name, __engine.pool.__class__))
    return __db.get_engine()


def get_metadata(engine=None):
    """<comment-ja>
    Pysilhouetteのメタデータを取得します。
    @param engine: データベースエンジン
    @type engine: SQLAlchemy#Engine
    @rtype: SQLAlchemy#MetaData
    @return: メタデータ
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    global __db
    if __db is None:
        engine = get_engine()
    # mapper!! 
    return __db.get_metadata()    

def mapper(metadata):
    """<comment-ja>
    関連するテーブル情報等々をマッピングします。
    @param metadata: メタデータ
    @type metadata: SQLAlchemy#MetaData
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    reload_mappers(metadata)

def get_session():
    """<comment-ja>
    thread-localでセッションを取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # thread-local Customize!
    #return sessionmaker(bind=get_engine(), autoflush=False)
    return scoped_session(
        sessionmaker(bind=get_engine(), autoflush=False))

if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = about
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui import __version__, __release__
from karesansui.lib.rest import Rest

class About(Rest):

    def _GET(self, *param, **params):
        self.view.version = __version__
        self.view.release = __release__
        return True

urls = ('/about/?(\.part)$', About,)

########NEW FILE########
__FILENAME__ = console
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import os
import socket

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.merge import MergeGuest
from karesansui.lib.utils import get_xml_xpath as XMLXpath, get_xml_parse as XMLParse

from karesansui.db.access.machine import findbyguest1, findbyhost1
from karesansui.lib.const import KVM_BRIDGE_PREFIX

def _get_applet_source_path():
    path = ""
    sources = ['/usr/lib/tightvnc/classes/VncViewer.jar',
               '/usr/share/tightvnc-java/VncViewer.jar',
              ]
    for source in sources:
        if os.path.exists(source):
            path = source
    return path

class Console(Rest):

    @auth
    def _GET(self, *param, **params):

        java_dir = karesansui.dirname + '/static/java'
        self.view.applet_dst_path = java_dir + '/VncViewer.jar'
        self.view.applet_src_path = _get_applet_source_path()
        self.view.found_applet_located = os.path.exists(self.view.applet_dst_path)

        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        model = findbyguest1(self.orm, guest_id)
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()

            dom = kvc.search_guests(domname)[0]

            document = XMLParse(dom.XMLDesc(1))

            self.view.graphics_port = XMLXpath(document,
                                          '/domain/devices/graphics/@port')
            self.view.xenname = XMLXpath(document,
                                         '/domain/name/text()')
        finally:
            kvc.close()

        h_model = findbyhost1(self.orm, host_id)
        try:
            from karesansui.lib.utils import get_ifconfig_info
            device = KVM_BRIDGE_PREFIX + "0"
            self.view.host_ipaddr = get_ifconfig_info(device)[device]["ipaddr"]
        except:
            try:
                self.view.host_ipaddr = h_model.hostname.split(":")[0].strip()
            except:
                self.view.host_ipaddr = socket.gethostbyname(socket.gethostname())

        return True

urls = (
    '/host/(\d+)/guest/(\d+)/console/?(\.part)$', Console,)

########NEW FILE########
__FILENAME__ = data
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth

class Data(Rest):

    @auth
    def _GET(self, *param, **params):
        self.__template__.dir = 'data/'+param[0]
        self.__template__.file = param[1]
        self.__template__.media = param[2]
        return True

#urls = ('/data/(.+)/(.+)\.(js)', Data,)
urls = ('/data/(js)/(.+)\.(js)', Data,)

########NEW FILE########
__FILENAME__ = guest
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import pwd
import os.path
import glob
import time

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import ICON_DIR_TPL, \
     VIRT_COMMAND_CREATE_GUEST, VIRT_COMMAND_REPLICATE_GUEST, \
     VIRT_COMMAND_DELETE_GUEST, \
     GRAPHICS_PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
     MEMORY_MIN_SIZE, DISK_MIN_SIZE, \
     VIRT_DOMAINS_DIR, DEFAULT_KEYMAP

from karesansui.lib.const import XEN_KEYMAP_DIR, KVM_KEYMAP_DIR, KVM_BRIDGE_PREFIX

from karesansui.lib.utils import comma_split, \
     generate_mac_address, is_param, \
     next_number, generate_uuid, string_from_uuid, uniq_sort, \
     uni_force, get_partition_info, chk_create_disk, json_dumps, \
     get_ifconfig_info, get_keymaps, available_virt_mechs, \
     available_virt_uris, is_iso9660_filesystem_format, \
     get_dom_list, get_dom_type, base64_encode, \
     uri_split, uri_join, dict_search

from karesansui.lib.utils import get_xml_parse as XMLParse
from karesansui.lib.utils import get_xml_xpath as XMLXpath
from karesansui.lib.utils import get_nums_xml_xpath as XMLXpathNum
from karesansui.lib.file.configfile import ConfigFile

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_ONLYSPACE, \
    CHECK_MIN, CHECK_MAX, CHECK_EXIST

from karesansui.lib.const import \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    GRAPHICS_PORT_MIN_NUMBER, GRAPHICS_PORT_MAX_NUMBER, \
    HYPERVISOR_MIN_SIZE, HYPERVISOR_MAX_SIZE, \
    MEMORY_MIN_SIZE, DISK_MIN_SIZE, \
    DOMAIN_NAME_MIN_LENGTH, DOMAIN_NAME_MAX_LENGTH, \
    MACHINE_HYPERVISOR, MACHINE_ATTRIBUTE, \
    DISK_QEMU_FORMAT, DISK_NON_QEMU_FORMAT, \
    VIRT_COMMAND_CREATE_STORAGE_VOLUME, \
    VIRT_COMMAND_DELETE_STORAGE_VOLUME, STORAGE_VOLUME_PWD, \
    DISK_USES

from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtConnectionAuth
from karesansui.lib.virt.config_export import ExportConfigParam

from karesansui.lib.merge import  MergeGuest, MergeHost

from karesansui.db.access.machine import \
     findbyhost1guestall, findbyhost1, \
     findbyguest1, \
     new as m_new, save as m_save, delete as m_delete

from karesansui.db.access.machine2jobgroup import new as m2j_new, save as m2j_save
from karesansui.db.access.notebook import new as n_new
#from karesansui.db.access.tag import new as t_new, samecount as t_count, findby1name as t_name
from karesansui.db.access.tag import new as t_new, samecount as t_count, findby1name as t_name
from karesansui.db.access._2pysilhouette import jg_save, jg_delete
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

def validates_guest_add(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'm_name'):
        check = False
        checker.add_error(_('Parameter m_name does not exist.'))
    else:
        check = checker.check_string(
                    _('Machine Name'),
                    obj.input.m_name,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = MACHINE_NAME_MIN_LENGTH,
                    max = MACHINE_NAME_MAX_LENGTH,
            ) and check

    if is_param(obj.input, 'note_title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.note_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'note_value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.note_value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    if is_param(obj.input, 'tags'):
        for tag in comma_split(obj.input.tags):
            check = checker.check_string(
                        _('Tag'),
                        tag,
                        CHECK_LENGTH | CHECK_ONLYSPACE,
                        None,
                        min = TAG_MIN_LENGTH,
                        max = TAG_MAX_LENGTH,
                    ) and check


    if not is_param(obj.input, 'm_hypervisor'):
        check = False
        checker.add_error(_('Parameter m_hypervisor does not exist.'))
    else:
        check = checker.check_hypervisor(
                _('Hypervisor'),
                obj.input.m_hypervisor,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                HYPERVISOR_MIN_SIZE,
                HYPERVISOR_MAX_SIZE,
            ) and check

    if not is_param(obj.input, 'domain_name'):
        check = False
        checker.add_error(_('Parameter domain_name does not exist.'))
    else:
        check = checker.check_string(
                _('Domain Name'),
                obj.input.domain_name,
                CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH | CHECK_ONLYSPACE,
                '[^-a-zA-Z0-9_\.]+',
                DOMAIN_NAME_MIN_LENGTH,
                DOMAIN_NAME_MAX_LENGTH,
            ) and check

        if obj.input.domain_name in get_dom_list():
            dom_type = get_dom_type(obj.input.domain_name)
            checker.add_error(_("The same domain name already exists for hypervisor '%s'.") % dom_type.upper())
            check = False

    if is_param(obj.input, 'vm_mem_size'):
        check = checker.check_number(
                _('Memory Size (MB)'),
                obj.input.vm_mem_size,
                CHECK_VALID | CHECK_MIN | CHECK_EMPTY,
                MEMORY_MIN_SIZE,
                None,
            ) and check

    if is_param(obj.input, 'pool_type'):
        if obj.input.pool_type != "block":
            if is_param(obj.input, 'vm_disk_size'):
                check = checker.check_number(
                        _('Disk Size (MB)'),
                        obj.input.vm_disk_size,
                        CHECK_VALID | CHECK_MIN | CHECK_EMPTY,
                        DISK_MIN_SIZE,
                        None,
                ) and check

    if not is_param(obj.input, 'boot_image'):
        check = False
        checker.add_error(_('Parameter boot_image does not exist.'))
    else:
        if obj.input.boot_image == "kernel":
            if not is_param(obj.input, 'vm_kernel'):
                check = False
                checker.add_error(_('Parameter vm_kernel does not exist.'))
            else:
                check = checker.check_startfile(
                        _('Kernel Image'),
                        obj.input.vm_kernel,
                        CHECK_EMPTY | CHECK_VALID | CHECK_EXIST,
                    ) and check

            if not is_param(obj.input, 'vm_initrd'):
                check = False
                checker.add_error(_('Parameter vm_initrd does not exist.'))
            else:
                check = checker.check_startfile(
                        _('Initrd Image'),
                        obj.input.vm_initrd,
                        CHECK_EMPTY | CHECK_VALID | CHECK_EXIST,
                    ) and check

        if obj.input.boot_image == "iso":
            if not is_param(obj.input, 'vm_iso'):
                check = False
                checker.add_error(_('Parameter vm_iso does not exist.'))
            else:
                check = checker.check_startfile(
                        _('ISO Image'),
                        obj.input.vm_iso,
                        CHECK_EMPTY | CHECK_VALID | CHECK_EXIST,
                    ) and check
                if check:
                    check = is_iso9660_filesystem_format(obj.input.vm_iso)
                    checker.add_error(_('"%s" is not valid ISO 9660 CD-ROM filesystem data.') % obj.input.vm_iso)

    if not is_param(obj.input, 'keymap'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Graphics Keymap'))
    else:
        hypervisor = "KVM"
        if int(obj.input.m_hypervisor) == MACHINE_HYPERVISOR['XEN']:
            hypervisor = "XEN"
        elif int(obj.input.m_hypervisor) == MACHINE_HYPERVISOR['KVM']:
            hypervisor = "KVM"
        check = checker.check_keymap(
                _('Graphics Keymap'),
                obj.input.keymap,
                CHECK_EMPTY | CHECK_EXIST,
                hypervisor
                ) and check

    if not is_param(obj.input, 'vm_graphics_port'):
        check = False
        checker.add_error(_('Parameter vm_graphics_port does not exist.'))
    else:
        check = checker.check_number(
                _('Graphics Port Number'),
                obj.input.vm_graphics_port,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                GRAPHICS_PORT_MIN_NUMBER,
                GRAPHICS_PORT_MAX_NUMBER,
            ) and check

    if not is_param(obj.input, 'vm_mac'):
        check = False
        checker.add_error(_('Parameter vm_mac does not exist.'))
    else:
        check = checker.check_macaddr(
                _('MAC Address'),
                obj.input.vm_mac,
                CHECK_EMPTY | CHECK_VALID,
            ) and check

    obj.view.alert = checker.errors
    return check


# public method
def make_storage_volume_job(uuid, name, pool_name, format,
                            capacity, allocation, unit, order):
    cmdname = u"Create Storage Volume"
    cmd = VIRT_COMMAND_CREATE_STORAGE_VOLUME

    options = {}
    options['volume_name'] = uuid
    options['name'] = name
    options['pool_name'] = pool_name
    options['format'] = format
    options['capacity'] = capacity
    options['allocation'] = allocation
    options['unit'] = unit
    options['permission_owner'] = pwd.getpwnam(STORAGE_VOLUME_PWD["OWNER"])[2]
    options['permission_group'] = pwd.getpwnam(STORAGE_VOLUME_PWD["GROUP"])[2]
    options['permission_mode'] = STORAGE_VOLUME_PWD["MODE"]
    options['use'] = DISK_USES["IMAGES"]

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    rollback_options = {}
    #rollback_options["name"] = name
    rollback_options["name"] = uuid
    rollback_options["pool_name"] = pool_name
    rollback_options["use"] = DISK_USES["IMAGES"]

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_VOLUME),
        rollback_options)

    _job = Job('%s command' % cmdname, order, _cmd)
    # delete_guestコマンドが削除まで担当してくれるので、ここではロールバックコマンドを設定しない。
    #_job.rollback_command = rollback_cmd
    return _job

def regist_guest(obj, _guest, icon_filename,
                  cmd, options, cmdname, rollback_options, is_create=False):

    if icon_filename:
        _guest.icon = icon_filename

    if (karesansui.sheconf.has_key('env.uniqkey') is False) \
           or (karesansui.sheconf['env.uniqkey'].strip('') == ''):
        raise 

    action_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd),
        options)

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_GUEST),
        rollback_options)

    _jobgroup = JobGroup(cmdname[0], karesansui.sheconf['env.uniqkey'])

    # create volume job
    order = 0
    if is_create is True:
        _volume_job = make_storage_volume_job(options["uuid"],
                                              options["storage-volume"],
                                              options["storage-pool"],
                                              options["disk-format"],
                                              options["disk-size"],
                                              options["disk-size"],
                                              'M',
                                              order
                                              )

        order += 1
        _jobgroup.jobs.append(_volume_job)


    _job = Job('%s command' % cmdname[1], order, action_cmd)
    _job.rollback_command = rollback_cmd
    _jobgroup.jobs.append(_job)

    # GuestOS INSERT
    try:
        m_save(obj.orm, _guest)
        obj.orm.commit()
    except:
        obj.logger.error('Failed to register the Guest OS. #1 - guest name=%s' \
                          % _guest.name)
        raise # throw

    # JobGroup INSERT
    try:
        jg_save(obj.pysilhouette.orm, _jobgroup)
        obj.pysilhouette.orm.commit()
    except:
        # rollback(machine)
        obj.logger.error('Failed to register the JobGroup. #2 - jobgroup name=%s' \
                          % _jobgroup.name)

        try:
            m_delete(obj.orm, _guest)
            obj.orm.commit()
            obj.logger.error('#3 Rollback successful. - guest id=%d' % _guest.id)
        except:
            obj.logger.critical('#4 Rollback failed. - guest id=%d' % _guest.id)
            raise

        raise # throw

    # Machine2JobGroup INSERT
    try:
        _m2j = m2j_new(machine=_guest,
                       jobgroup_id=_jobgroup.id,
                       uniq_key=karesansui.sheconf['env.uniqkey'],
                       created_user=obj.me,
                       modified_user=obj.me,
                       )
        m2j_save(obj.orm, _m2j)
        obj.orm.commit()
    except:
        # rollback(machine, jobgroup)
        try:
            m_delete(obj.orm, _guest)
            obj.orm.commit()
        except:
            # rollback(machine)
            obj.logger.critical('Failed to register the Machine. #5 - guest id=%d' \
                              % _guest.id)
        try:
            jg_delete(obj.pysilhouette.orm, _jobgroup)
            obj.pysilhouette.orm.commit()
        except:
            # rollback(jobgroup)
            obj.logger.critical('Failed to register the JobGroup. #6 - jobgroup id=%d' \
                              % _jobgroup.id)
        raise # throw

    return True

class Guest(Rest):

    def _post(self, f):
        ret = Rest._post(self, f)
        if hasattr(self, "kvc") is True:
            self.kvc.close()
        return ret

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)
        uris = available_virt_uris()

        #import pdb; pdb.set_trace()
        if model.attribute == MACHINE_ATTRIBUTE["URI"]:
            uri_guests = []
            uri_guests_status = {}
            uri_guests_kvg = {}
            uri_guests_info = {}
            uri_guests_name = {}
            segs = uri_split(model.hostname)
            uri = uri_join(segs, without_auth=True)
            creds = ''
            if segs["user"] is not None:
                creds += segs["user"]
                if segs["passwd"] is not None:
                    creds += ':' + segs["passwd"]

            # Output .part
            if self.is_mode_input() is not True:
                try:
                    self.kvc = KaresansuiVirtConnectionAuth(uri,creds)
                    host = MergeHost(self.kvc, model)
                    for guest in host.guests:

                        _virt = self.kvc.search_kvg_guests(guest.info["model"].name)
                        if 0 < len(_virt):
                            for _v in _virt:
                                uuid = _v.get_info()["uuid"]
                                uri_guests_info[uuid] = guest.info
                                uri_guests_kvg[uuid] = _v
                                uri_guests_name[uuid] = guest.info["model"].name.encode("utf8")

                    for name in sorted(uri_guests_name.values(),key=str.lower):
                        for uuid in dict_search(name,uri_guests_name):
                            uri_guests.append(MergeGuest(uri_guests_info[uuid]["model"], uri_guests_kvg[uuid]))
                            uri_guests_status[uuid]  = uri_guests_info[uuid]['virt'].status()

                finally:
                    self.kvc.close()

                # .json
                if self.is_json() is True:
                    guests_json = []
                    for x in uri_guests:
                        guests_json.append(x.get_json(self.me.languages))

                    self.view.uri_guests = json_dumps(guests_json)
                else:
                    self.view.uri_guests = uri_guests
                    self.view.uri_guests_status = uri_guests_status

        self.kvc = KaresansuiVirtConnection()
        try: # libvirt connection scope -->

            # Storage Pool
            #inactive_pool = self.kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = self.kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            if not pools:
                return web.badrequest('One can not start a storage pool.')

            # Output .input
            if self.is_mode_input() is True:
                self.view.pools = pools
                pools_info = {}
                pools_vols_info = {}
                pools_iscsi_blocks = {}
                already_vols = []
                guests = []

                guests += self.kvc.list_inactive_guest()
                guests += self.kvc.list_active_guest()
                for guest in guests:
                    already_vol = self.kvc.get_storage_volume_bydomain(domain=guest,
                                                                       image_type=None,
                                                                       attr='path')
                    if already_vol:
                        already_vols += already_vol.keys()

                for pool in pools:
                    pool_obj = self.kvc.search_kvn_storage_pools(pool)[0]
                    if pool_obj.is_active() is True:
                        pools_info[pool] = pool_obj.get_info()

                        blocks = None
                        if pools_info[pool]['type'] == 'iscsi':
                            blocks = self.kvc.get_storage_volume_iscsi_block_bypool(pool)
                            if blocks:
                                pools_iscsi_blocks[pool] = []
                        vols_obj = pool_obj.search_kvn_storage_volumes(self.kvc)
                        vols_info = {}

                        for vol_obj in vols_obj:
                            vol_name = vol_obj.get_storage_volume_name()
                            vols_info[vol_name] = vol_obj.get_info()
                            if blocks:
                                if vol_name in blocks and vol_name not in already_vols:
                                    pools_iscsi_blocks[pool].append(vol_obj.get_info())

                        pools_vols_info[pool] = vols_info

                self.view.pools_info = pools_info
                self.view.pools_vols_info = pools_vols_info
                self.view.pools_iscsi_blocks = pools_iscsi_blocks

                bridge_prefix = {
                    "XEN":"xenbr",
                    "KVM":KVM_BRIDGE_PREFIX,
                    }
                self.view.host_id = host_id
                self.view.DEFAULT_KEYMAP = DEFAULT_KEYMAP
                self.view.DISK_NON_QEMU_FORMAT = DISK_NON_QEMU_FORMAT
                self.view.DISK_QEMU_FORMAT = DISK_QEMU_FORMAT

                self.view.hypervisors = {}
                self.view.mac_address = {}
                self.view.keymaps = {}
                self.view.phydev = {}
                self.view.virnet = {}

                used_ports = {}

                for k,v in MACHINE_HYPERVISOR.iteritems():
                    if k in available_virt_mechs():
                        self.view.hypervisors[k] = v
                        uri = uris[k]
                        mem_info = self.kvc.get_mem_info()
                        active_networks = self.kvc.list_active_network()
                        used_graphics_ports = self.kvc.list_used_graphics_port()
                        bus_types = self.kvc.bus_types
                        self.view.bus_types = bus_types
                        self.view.max_mem = mem_info['host_max_mem']
                        self.view.free_mem = mem_info['host_free_mem']
                        self.view.alloc_mem = mem_info['guest_alloc_mem']

                        self.view.mac_address[k] = generate_mac_address(k)
                        self.view.keymaps[k] = eval("get_keymaps(%s_KEYMAP_DIR)" % k)

                        # Physical device
                        phydev = []
                        phydev_regex = re.compile(r"%s" % bridge_prefix[k])
                        for dev,dev_info in get_ifconfig_info().iteritems():
                            try:
                                if phydev_regex.match(dev):
                                    phydev.append(dev)
                            except:
                                pass
                        if len(phydev) == 0:
                            phydev.append("%s0" % bridge_prefix[k])
                        phydev.sort()
                        self.view.phydev[k] = phydev # Physical device

                        # Virtual device
                        self.view.virnet[k] = sorted(active_networks)
                        used_ports[k] = used_graphics_ports


                exclude_ports = []
                for k, _used_port in used_ports.iteritems():
                    exclude_ports = exclude_ports + _used_port
                    exclude_ports = sorted(exclude_ports)
                    exclude_ports = [p for p, q in zip(exclude_ports, exclude_ports[1:] + [None]) if p != q]
                self.view.graphics_port = next_number(GRAPHICS_PORT_MIN_NUMBER,
                                                 PORT_MAX_NUMBER,
                                                 exclude_ports)

            else: # .part
                models = findbyhost1guestall(self.orm, host_id)
                guests = []
                if models:
                    # Physical Guest Info
                    self.view.hypervisors = {}
                    for model in models:
                        for k,v in MACHINE_HYPERVISOR.iteritems():
                            if k in available_virt_mechs():
                                self.view.hypervisors[k] = v
                                uri = uris[k]
                                if hasattr(self, "kvc") is not True:
                                    self.kvc = KaresansuiVirtConnection(uri)
                                domname = self.kvc.uuid_to_domname(model.uniq_key)
                                #if not domname: return web.conflict(web.ctx.path)
                                _virt = self.kvc.search_kvg_guests(domname)
                                if 0 < len(_virt):
                                    guests.append(MergeGuest(model, _virt[0]))
                                else:
                                    guests.append(MergeGuest(model, None))

                # Exported Guest Info
                exports = {}
                for pool_name in pools:
                    files = []

                    pool = self.kvc.search_kvn_storage_pools(pool_name)
                    path = pool[0].get_info()["target"]["path"]

                    if os.path.exists(path):
                        for _afile in glob.glob("%s/*/info.dat" % (path,)):
                            param = ExportConfigParam()
                            param.load_xml_config(_afile)

                            _dir = os.path.dirname(_afile)

                            uuid = param.get_uuid()
                            name = param.get_domain()
                            created = param.get_created()
                            title = param.get_title()
                            if title != "":
                                title = re.sub("[\r\n]","",title)
                            if title == "":
                                title = _('untitled')

                            if created != "":
                                created_str = time.strftime("%Y/%m/%d %H:%M:%S", \
                                                            time.localtime(float(created)))
                            else:
                                created_str = _("N/A")

                            files.append({"dir": _dir,
                                          "pool" : pool_name,
                                          #"b64dir" : base64_encode(_dir),
                                          "uuid" : uuid,
                                          "name" : name,
                                          "created" : int(created),
                                          "created_str" : created_str,
                                          "title" : title,
                                          "icon" : param.get_database()["icon"],
                                          })

                    exports[pool_name] = files

                # .json
                if self.is_json() is True:
                    guests_json = []
                    for x in guests:
                        guests_json.append(x.get_json(self.me.languages))

                    self.view.guests = json_dumps(guests_json)
                else:
                    self.view.exports = exports
                    self.view.guests = guests

            return True
        except:
            pass
        finally:
            #self.kvc.close()
            pass # libvirt connection scope --> Guest#_post()

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)
        if model.attribute == 0 and model.hypervisor == MACHINE_HYPERVISOR["XEN"]:
            uri = uris["XEN"]
        elif model.attribute == 0 and model.hypervisor == MACHINE_HYPERVISOR["KVM"]:
            uri = uris["KVM"]
        else:
            uri = None

        if not validates_guest_add(self):
            return web.badrequest(self.view.alert)

        try:
            try:
                self.kvc = KaresansuiVirtConnection(uri)
                active_guests = self.kvc.list_active_guest()
                inactive_guests = self.kvc.list_inactive_guest()
                used_graphics_ports = self.kvc.list_used_graphics_port()
                used_mac_addrs = self.kvc.list_used_mac_addr()
                mem_info = self.kvc.get_mem_info()

                if is_param(self.input, "vm_mem_size"):
                    if mem_info['host_free_mem'] < int(self.input.vm_mem_size):
                        return web.badrequest(_("Space not enough to allocate guest memory."))

                if is_param(self.input, "pool_type") and \
                       self.input.pool_type != "block" and \
                       is_param(self.input, "pool_dir"):
                    target_path = self.kvc.get_storage_pool_targetpath(self.input.pool_dir)
                    if target_path: # disk
                        if not chk_create_disk(target_path, self.input.vm_disk_size):
                            partition = get_partition_info(target_path, header=False)
                            return web.badrequest(_("No space available to create disk image in '%s' partition.") % partition[5][0])
            except:
                raise
        finally:
            del self.kvc

        # Check on whether value has already been used
        # Guest OS
        if (self.input.domain_name in active_guests) \
               or (self.input.domain_name in inactive_guests):
            return web.conflict(web.ctx.path, "Guest OS is already there.")
        # Graphics Port Number
        if(int(self.input.vm_graphics_port) in used_graphics_ports):
            return web.conflict(web.ctx.path, "Graphics Port is already there.")
        # MAC Address
        if(self.input.vm_mac in used_mac_addrs):
            return web.conflict(web.ctx.path, "MAC Address is already there.")

        uuid = string_from_uuid(generate_uuid())

        options = {}
        options['uuid'] = uuid

        if is_param(self.input, "domain_name"):
            options['name'] = self.input.domain_name
        if is_param(self.input, "vm_mem_size"):
            options['mem-size'] = self.input.vm_mem_size
        if is_param(self.input, "vm_kernel"):
            options['kernel'] = self.input.vm_kernel
        if is_param(self.input, "vm_initrd"):
            options['initrd'] = self.input.vm_initrd
        if is_param(self.input, "vm_iso"):
            options['iso'] = self.input.vm_iso
        if is_param(self.input, "keymap"):
            options['keymap'] = self.input.keymap

        is_create = False
        if is_param(self.input, "pool_type"):
            if is_param(self.input, "bus_type"):
                options['bus'] = self.input.bus_type

            if self.input.pool_type == "dir" or self.input.pool_type == "fs": # create volume
                is_create = True
                options['disk-format'] = self.input.disk_format
                options["storage-pool"] = self.input.pool_dir
                options["storage-volume"] = options['name'] # default domain name
                options['disk-size'] = self.input.vm_disk_size

            elif self.input.pool_type == "block": # iscsi block device
                (iscsi_pool, iscsi_volume) = self.input.pool_dir.split("/", 2)
                options["storage-pool"] = iscsi_pool
                options["storage-volume"] = iscsi_volume
            else:
                return web.badrequest()
        else:
            return web.badrequest()

        if is_param(self.input, "vm_graphics_port"):
            options['graphics-port'] = self.input.vm_graphics_port
        if is_param(self.input, "vm_mac"):
            options['mac'] = self.input.vm_mac
        if is_param(self.input, "vm_extra"):
            options['extra'] = self.input.vm_extra
        if is_param(self.input, "nic_type"):
            if self.input.nic_type == "phydev":
                options['interface-format'] = "b:" + self.input.phydev
            elif self.input.nic_type == "virnet":
                options['interface-format'] = "n:" + self.input.virnet

        if int(self.input.m_hypervisor) == MACHINE_HYPERVISOR['XEN']:
            i_hypervisor = MACHINE_HYPERVISOR['XEN']
            options['type'] = u"XEN"
        elif int(self.input.m_hypervisor) == MACHINE_HYPERVISOR['KVM']:
            i_hypervisor = MACHINE_HYPERVISOR['KVM']
            options['type'] = u"KVM"
        else:
            return web.badrequest("This is not the hypervisor.")

        host = findbyhost1(self.orm, host_id)

        # notebook
        note_title = None
        if is_param(self.input, "note_title"):
            note_title = self.input.note_title

        note_value = None
        if is_param(self.input, "note_value"):
            note_value = self.input.note_value

        _notebook = n_new(note_title, note_value)

        # tags
        _tags = None
        if is_param(self.input, "tags"):
            _tags = []
            tag_array = comma_split(self.input.tags)
            tag_array = uniq_sort(tag_array)
            for x in tag_array:
                if t_count(self.orm, x) == 0:
                    _tags.append(t_new(x))
                else:
                    _tags.append(t_name(self.orm, x))

        # Icon
        icon_filename = None
        if is_param(self.input, "icon_filename", empty=True):
            icon_filename = self.input.icon_filename

        _guest = m_new(created_user=self.me,
                       modified_user=self.me,
                       uniq_key=uni_force(uuid),
                       name=self.input.m_name,
                       attribute=MACHINE_ATTRIBUTE['GUEST'],
                       hypervisor=i_hypervisor,
                       notebook=_notebook,
                       tags=_tags,
                       icon=icon_filename,
                       is_deleted=False,
                       parent=host,
                       )

        ret =  regist_guest(self,
                            _guest,
                            icon_filename,
                            VIRT_COMMAND_CREATE_GUEST,
                            options,
                            ('Create Guest', 'Create Guest'),
                            {"name": options['name'],
                             "pool" : options["storage-pool"],
                             "volume" : options["uuid"],
                             },
                            is_create,
                            )
        if ret is True:
            return web.accepted()
        else:
            return False

urls = (
    '/host/(\d+)/guest/?(\.part|\.json)$', Guest,
    )

########NEW FILE########
__FILENAME__ = guestby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os

import web
from web.utils import Storage

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.utils import \
    comma_split, uniq_sort, is_param, json_dumps

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_LENGTH, CHECK_ONLYSPACE

from karesansui.lib.const import \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    VIRT_COMMAND_DELETE_GUEST, VIRT_COMMAND_DELETE_STORAGE_VOLUME, \
    DISK_USES

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.merge import MergeGuest

from karesansui.db.access.machine import \
     findbyguest1, findby1name, logical_delete, \
     update as m_update, delete as m_delete

from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.tag import \
     new as t_new, samecount as t_count, findby1name as t_name

from karesansui.db.model._2pysilhouette import Job, JobGroup

from karesansui.gadget.guestby1diskby1 import delete_storage_volume, delete_disk_job
from pysilhouette.command import dict2command

def validates_guest_edit(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'm_name'):
        check = False
        checker.add_error(_('Parameter m_name does not exist.'))
    else:
        check = checker.check_string(
                    _('Machine Name'),
                    obj.input.m_name,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = MACHINE_NAME_MIN_LENGTH,
                    max = MACHINE_NAME_MAX_LENGTH,
            ) and check

    if is_param(obj.input, 'note_title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.note_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'note_value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.note_value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check


    if is_param(obj.input, 'tags'):
        for tag in comma_split(obj.input.tags):
            check = checker.check_string(
                        _('Tag'),
                        tag,
                        CHECK_LENGTH | CHECK_ONLYSPACE,
                        None,
                        min = TAG_MIN_LENGTH,
                        max = TAG_MAX_LENGTH,
                    ) and check

    obj.view.alert = checker.errors
    return check

class GuestBy1(Rest):

    def _post(self, f):
        ret = Rest._post(self, f)
        if hasattr(self, "kvc") is True:
            self.kvc.close()
        return ret

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)

        if self.input.has_key('job_id') is True:
            self.view.job_id = self.input.job_id
        else:
            self.view.job_id = None

        if guest_id is None:
            return web.notfound()

        model = findbyguest1(self.orm, guest_id)

        self.kvc = KaresansuiVirtConnection()
        if self.is_mode_input() is True:
            try:
                domname = self.kvc.uuid_to_domname(model.uniq_key)
                if not domname:
                    return web.notfound()

                virt = self.kvc.search_kvg_guests(domname)[0]
                guest = MergeGuest(model, virt)
                self.view.model = guest.info["model"]
                return True
            except:
                self.kvc.close()
                raise
        else:
            try:
                domname = self.kvc.uuid_to_domname(model.uniq_key)
                if not domname:
                    return web.notfound()

                virt = self.kvc.search_kvg_guests(domname)[0]

                guest = MergeGuest(model, virt)

                guest_info = guest.info["virt"].get_info()
                info = {}
                info['memory'] = guest_info["memory"]
                info['cpu'] = guest_info["cpuTime"]
                info['os'] = guest_info["OSType"]
                info['hypervisor'] = guest_info["hypervisor"]
                info['type'] = guest_info["VMType"]
                info['hv_version'] = guest_info["hv_version"]

                disk_info = guest.info["virt"].get_disk_info()
                interface_info = guest.info["virt"].get_interface_info()
                net_info = guest.info["virt"].get_netinfo()
                graphics_info = guest.info["virt"].get_graphics_info()
                vcpu_info = guest.info["virt"].get_vcpus_info()

                pool_info = []
                pool_vols_info = []
                already_vols = []
                pools = self.kvc.get_storage_pool_name_bydomain(domname)
                if len(pools) > 0:
                    for pool in pools:
                        pool_obj = self.kvc.search_kvn_storage_pools(pool)[0]
                        if pool_obj.is_active() is True:
                            pool_info = pool_obj.get_info()

                            vols_obj = pool_obj.search_kvn_storage_volumes(self.kvc)
                            vols_info = {}

                            for vol_obj in vols_obj:
                                vol_name = vol_obj.get_storage_volume_name()
                                vols_info[vol_name] = vol_obj.get_info()

                            pool_vols_info = vols_info

                if self.__template__["media"] == 'json':
                    json_guest = guest.get_json(self.me.languages)
                    self.view.data = json_dumps(
                        {
                            "model": json_guest["model"],
                            "virt": json_guest["virt"],
                            "autostart": guest.info["virt"].autostart(),
                            "info": info,
                            "disk_info": disk_info,
                            "net_info": net_info,
                            "interface_info": interface_info,
                            "pool_info": pool_info,
                            "pool_vols_info": pool_vols_info,
                            "graphics_info": graphics_info,
                            "vcpu_info": vcpu_info,
                        }
                    )
                else:
                    self.view.model = guest.info["model"]
                    self.view.virt = guest.info["virt"]
                    self.view.autostart = guest.info["virt"].autostart()
                    self.view.info = info
                    self.view.disk_info = disk_info
                    self.view.net_info = net_info
                    self.view.interface_info = interface_info
                    self.view.pool_info = pool_info
                    self.view.pool_vols_info = pool_vols_info
                    self.view.graphics_info = graphics_info
                    self.view.vcpu_info = vcpu_info
            except:
                self.kvc.close()
                raise

            return True

    @auth
    def _PUT(self, *param, **params):

        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None:
            return web.notfound()

        if not validates_guest_edit(self):
            self.logger.debug("Update Guest OS is failed, Invalid input value.")
            return web.badrequest(self.view.alert)

        guest = findbyguest1(self.orm, guest_id)

        # notebook
        if is_param(self.input, "note_title"):
            guest.notebook.title = self.input.note_title
        if is_param(self.input, "note_value"):
            guest.notebook.value = self.input.note_value

        if is_param(self.input, "m_name"):
            guest.name = self.input.m_name

        # Icon
        icon_filename = None
        if is_param(self.input, "icon_filename", empty=True):
            guest.icon = self.input.icon_filename

        # tag UPDATE
        if is_param(self.input, "tags"):
            _tags = []
            tag_array = comma_split(self.input.tags)
            tag_array = uniq_sort(tag_array)
            for x in tag_array:
                if t_count(self.orm, x) == 0:
                    _tags.append(t_new(x))
                else:
                    _tags.append(t_name(self.orm, x))
            guest.tags = _tags

        guest.modified_user = self.me

        m_update(self.orm, guest)
        return web.seeother(web.ctx.path)


    @auth
    def _DELETE(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None:
            return web.notfound()

        model = findbyguest1(self.orm, guest_id)

        self.kvc = KaresansuiVirtConnection()
        try:
            domname = self.kvc.uuid_to_domname(model.uniq_key)
            if not domname:
                self.logger.info("Did not exist in libvirt. - guestid=%s" % model.id)
                logical_delete(self.orm, model)
                # TODO ファイルシステムにゴミが残るので、delete_guest.pyを実行する必要がある。
                self.orm.commit()
                return web.nocontent()

            kvg_guest = self.kvc.search_kvg_guests(domname)
            if not kvg_guest:
                return web.badrequest(_("Guest not found. - name=%s") % domname)
            else:
                kvg_guest = kvg_guest[0]

            if kvg_guest.is_active():
                return web.badrequest(_("Can not delete a running guest OS. - name=%s") % domname)

            # jobs order
            order = 0

            jobs = []
            os_storage = {}
            for disk in kvg_guest.get_disk_info():
                if disk['type'] == 'file': # type="dir"
                    # delete_storage_volume
                    pool = self.kvc.get_storage_pool_name_byimage(disk['source']['file'])
                    if not pool:
                        return web.badrequest(_("Can not find the storage pool image. - target=%s") % (disk['source']['file']))
                    else:
                        pool = pool[0]

                    disk_volumes = self.kvc.get_storage_volume_bydomain(domname, 'disk', 'key')
                    volume = None
                    for key in disk_volumes.keys():
                        if disk['source']['file'] == os.path.realpath(disk_volumes[key]):
                            volume = key # disk image

                    use = DISK_USES['DISK']
                    if volume is None: # os image
                        os_volume = self.kvc.get_storage_volume_bydomain(domname, 'os', 'key')
                        if not os_volume:
                            return web.badrequest(_("OS storage volume for guest could not be found. domname=%s") % domname)

                        if disk['source']['file'] == os.path.realpath(os_volume.values()[0]):
                            use = DISK_USES['IMAGES']
                            volume = os_volume.keys()[0]
                            os_storage["pool"] = pool
                            os_storage["volume"] = volume
                            continue # OS delete command to do "VIRT_COMMAND_DELETE_GUEST" image.

                    jobs.append(delete_storage_volume(self,
                                                      volume,
                                                      pool,
                                                      order,
                                                      use))
                    order += 1

                    # delete_disk
                    jobs.append(delete_disk_job(self,
                                               domname,
                                               disk["target"]["dev"],
                                               order))
                    order += 1

                elif disk['type'] == 'block': # type="iscsi"

                    pool = self.kvc.get_storage_pool_name_byimage(disk['source']['dev'])
                    if not pool:
                        return web.badrequest(_("Can not find the storage pool image. - target=%s") % disk['source']['dev'])
                    else:
                        pool = pool[0]

                    os_volume = self.kvc.get_storage_volume_bydomain(domname, 'os', 'key')
                    if not os_volume:
                        return web.badrequest(_("OS storage volume for guest could not be found. domname=%s") % domname)
                    else:
                        volume = os_volume.values()[0]
                        if disk['source']['dev'] == volume:
                            os_storage["pool"] = pool
                            os_storage["volume"] = volume
                            continue # OS delete command to do "VIRT_COMMAND_DELETE_GUEST" image.

                    # delete_disk
                    jobs.append(delete_disk_job(self,
                                               domname,
                                               disk["target"]["dev"],
                                               order))
                    order += 1
                else:
                    return web.internalerror(
                        _("Not expected storage type. type=%") % disk['type'])


            # DELETE GUEST
            cmdname = "Delete Guest"
            _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
            _jobgroup.jobs = jobs # Set Disk
            action_cmd = dict2command(
                "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_GUEST),
                {"name" : domname,
                 "pool" : os_storage["pool"],
                 "volume" : os_storage["volume"],
                 }
                )

            _job = Job('%s command' % cmdname, order, action_cmd)
            _jobgroup.jobs.append(_job)

            logical_delete(self.orm, model)

            _machine2jobgroup = m2j_new(machine=model,
                                        jobgroup_id=-1,
                                        uniq_key=karesansui.sheconf['env.uniqkey'],
                                        created_user=self.me,
                                        modified_user=self.me,
                                        )

            save_job_collaboration(self.orm,
                                   self.pysilhouette.orm,
                                   _machine2jobgroup,
                                   _jobgroup,
                                   )

            return web.accepted(url = web.ctx.path)
        finally:
            #self.kvc.close() GuestBy1#_post
            pass

urls = (
    '/host/(\d+)/guest/(\d+)/?(\.html|\.part|\.json)?$', GuestBy1,
    )

########NEW FILE########
__FILENAME__ = guestby1cpu
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.const import VIRT_COMMAND_SET_VCPUS, VCPUS_MIN_SIZE
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.utils import is_int, is_param, is_empty
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access.machine import findbyguest1
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command


def validates_cpu(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'max_vcpus'):
        check = checker.check_number(
                _('Maximum Allocatable Virtual CPUs'),
                obj.input.max_vcpus,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                min = VCPUS_MIN_SIZE,
                ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Maximum Allocatable Virtual CPUs'))

    if is_param(obj.input, 'vcpus'):
        check = checker.check_number(
                _("Number of Virtual CPUs to Allocate"),
                obj.input.vcpus,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                min = VCPUS_MIN_SIZE,
                ) and check;

    obj.view.alert = checker.errors
    return check



class GuestBy1Cpu(Rest):
    
    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()

            virt = kvc.search_kvg_guests(domname)[0]

            vcpus_info = virt.get_vcpus_info()
            self.view.max_vcpus_limit = kvc.get_max_vcpus()
            self.view.max_vcpus       = vcpus_info['bootup_vcpus']
            self.view.vcpus_limit     = vcpus_info['max_vcpus']
            self.view.vcpus           = vcpus_info['vcpus']

            self.view.cpuTime = virt.get_info()['cpuTime']
            self.view.hypervisor = virt.get_info()['hypervisor']

            self.view.guest = model
        finally:
            kvc.close()
            
        return True


    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        Japanese Comment
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if not validates_cpu(self):
            return web.badrequest(self.view.alert)
        
        if is_param(self.input, 'vcpus'):
            vcpus = int(self.input.vcpus)
        else:
            vcpus = None
        max_vcpus = int(self.input.max_vcpus)

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]

            vcpus_info = virt.get_vcpus_info()
            max_vcpus_limit = kvc.get_max_vcpus()
            vcpus_limit     = vcpus_info['max_vcpus']
        finally:
            kvc.close()
                
        if max_vcpus_limit < max_vcpus:
            return web.badrequest("%s is greater than the maximum number supported for guest. - max_vcpus_limit=%d max_vcpus=%d" \
                % (_('Maximum Number of Virtual CPUs'), self.input.max_vcpus_limit,self.input.max_vcpus,))

        if vcpus is not None:
            if vcpus_limit < vcpus:
                return web.badrequest("%s is greater than the maximum number supported for guest. - vcpus_limit=%d vcpus=%d" \
                    % (_('Number of Virtual CPUs'), self.input.vcpus_limit,self.input.vcpus,))

        options = {}
        options["name"] = domname
        if vcpus is not None:
            options["vcpus"] = vcpus
        options["max-vcpus"] = max_vcpus
        
        _cmd = dict2command("%s/%s" % (karesansui.config['application.bin.dir'],
                                       VIRT_COMMAND_SET_VCPUS),
                            options)
        
        cmdname = "Set CPU"
        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname, 0, _cmd))
        
        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return web.accepted()
            

urls = ('/host/(\d+)/guest/(\d+)/cpu/?(\.part)$', GuestBy1Cpu,)

########NEW FILE########
__FILENAME__ = guestby1currentsnapshot
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import VIRT_COMMAND_APPLY_SNAPSHOT
from karesansui.lib.utils import is_param, is_int

from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot

from karesansui.db.access.machine  import findbyguest1
from karesansui.db.access.snapshot import findbyname_guestby1 as s_findbyname_guestby1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from karesansui.db.model._2pysilhouette import Job, JobGroup
from pysilhouette.command import dict2command

class GuestBy1CurrentSnapshot(Rest):

    @auth
    def _PUT(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_param(self.input, 'id') is False \
            or is_int(self.input.id) is False:
            return web.badrequest("Request data is invalid.")

        snapshot_id = str(self.input.id)

        snapshot = s_findbyname_guestby1(self.orm, snapshot_id, guest_id)
        if snapshot is None:
            pass
            # ignore snapshots that is not in database.
            #return web.badrequest("Request data is invalid.")

        model = findbyguest1(self.orm, guest_id)

        kvs = KaresansuiVirtSnapshot(readonly=False)
        snapshot_list = []
        try:
            domname = kvs.kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()
            self.view.is_creatable = kvs.isSupportedDomain(domname)
            try:
                snapshot_list = kvs.listNames(domname)[domname]
            except:
                pass

        finally:
            kvs.finish()

        if not snapshot_id in snapshot_list:
            self.logger.debug(_("The specified snapshot does not exist in database. - %s") % snapshot_id)
            # ignore snapshots that is not in database.
            #return web.notfound()

        action_cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'],
                       VIRT_COMMAND_APPLY_SNAPSHOT),
            {"name" : domname, "id" : snapshot_id})

        cmdname = 'Apply Snapshot'

        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _job = Job('%s command' % cmdname, 0, action_cmd)
        _jobgroup.jobs.append(_job)

        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )        

        self.view.currentsnapshot = snapshot

        return web.accepted(url=web.ctx.path)

urls = (
    '/host/(\d+)/guest/(\d+)/currentsnapshot/?(\.part)?$', GuestBy1CurrentSnapshot,
    )

########NEW FILE########
__FILENAME__ = guestby1device
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import os
import pwd

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.merge import MergeGuest
from karesansui.lib.utils import get_ifconfig_info, generate_mac_address, is_param, \
     generate_uuid, string_from_uuid

from karesansui.gadget.guestby1disk import create_disk_job, validates_disk, \
     create_storage_volume_dir, exec_disk_job

from karesansui.gadget.guestby1nic import create_nic_job, validates_nic

from karesansui.gadget.hostby1networkstorage import get_iscsi_cmd

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

from karesansui.lib.const import DISK_QEMU_FORMAT, DISK_NON_QEMU_FORMAT, \
     STORAGE_VOLUME_PWD, DISK_USES, \
     VIRT_COMMAND_DELETE_STORAGE_VOLUME, VIRT_COMMAND_CREATE_STORAGE_VOLUME

from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
     CHECK_STARTROOT, CHECK_EXIST, CHECK_ISDIR

class GuestBy1Device(Rest):

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        bridge_prefix = {
                          "XEN":"xenbr",
                          "KVM":"br|bondbr",
                          #"KVM":"eth|bondbr",
                        }

        model = findbyguest1(self.orm, guest_id)

        # virt
        self.kvc = KaresansuiVirtConnection()
        try:
            domname = self.kvc.uuid_to_domname(model.uniq_key)
            if not domname:
                return web.notfound()
            virt = self.kvc.search_kvg_guests(domname)[0]
            guest = MergeGuest(model, virt)
            self.view.guest = guest

            # Output .input
            if self.is_mode_input() is True:
                try:
                    VMType = guest.info["virt"].get_info()["VMType"].upper()
                except:
                    VMType = "KVM"

                self.view.VMType = VMType

                # Network
                phydev = []
                phydev_regex = re.compile(r"%s" % bridge_prefix[VMType])

                for dev,dev_info in get_ifconfig_info().iteritems():
                    try:
                        if phydev_regex.match(dev):
                            phydev.append(dev)
                    except:
                        pass
                if len(phydev) == 0:
                    phydev.append("%s0" % bridge_prefix[VMType])

                phydev.sort()
                self.view.phydev = phydev # Physical device
                self.view.virnet = sorted(self.kvc.list_active_network()) # Virtual device
                self.view.mac_address = generate_mac_address() # new mac address

                # Disk
                inactive_pool = []
                active_pool = self.kvc.list_active_storage_pool()
                pools = inactive_pool + active_pool
                pools.sort()

                if not pools:
                    return web.badrequest('One can not start a storage pool.')

                pools_info = {}
                pools_vols_info = {}
                pools_iscsi_blocks = {}
                already_vols = []
                guests = []

                guests += self.kvc.list_inactive_guest()
                guests += self.kvc.list_active_guest()
                for guest in guests:
                    already_vol = self.kvc.get_storage_volume_bydomain(domain=guest,
                                                                       image_type=None,
                                                                       attr='path')
                    if already_vol:
                        already_vols += already_vol.keys()

                for pool in pools:
                    pool_obj = self.kvc.search_kvn_storage_pools(pool)[0]
                    if pool_obj.is_active() is True:
                        pools_info[pool] = pool_obj.get_info()

                        blocks = None
                        if pools_info[pool]['type'] == 'iscsi':
                            blocks = self.kvc.get_storage_volume_iscsi_block_bypool(pool)
                            if blocks:
                                pools_iscsi_blocks[pool] = []
                        vols_obj = pool_obj.search_kvn_storage_volumes(self.kvc)
                        vols_info = {}

                        for vol_obj in vols_obj:
                            vol_name = vol_obj.get_storage_volume_name()
                            vols_info[vol_name] = vol_obj.get_info()
                            if blocks:
                                if vol_name in blocks and vol_name not in already_vols:
                                    pools_iscsi_blocks[pool].append(vol_obj.get_info())

                        pools_vols_info[pool] = vols_info

                self.view.pools = pools
                self.view.pools_info = pools_info
                self.view.pools_vols_info = pools_vols_info
                self.view.pools_iscsi_blocks = pools_iscsi_blocks

                if VMType == "KVM":
                    self.view.DISK_FORMATS = DISK_QEMU_FORMAT
                else:
                    self.view.DISK_FORMATS = DISK_NON_QEMU_FORMAT

                self.view.bus_types = self.kvc.bus_types

            else: # .part
                self.view.ifinfo = virt.get_interface_info() # interface info
                self.view.disk_info = virt.get_disk_info() # Disk info

        finally:
            self.kvc.close()

        return True

    @auth
    def _POST(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            nic_info = virt.get_interface_info()

            # -- Nic
            if self.input.device_type == "nic":
                if not validates_nic(self):
                    return web.badrequest(self.view.alert)

                f_chk = True
                for x in nic_info:
                    if x['mac']['address'] == self.input.mac_address:
                        f_chk = False
                        break
                if f_chk is False:
                    return web.badrequest(_('Specified MAC address is already defined.'))

                mac = self.input.mac_address
                bridge = None
                network = None
                if self.input.nic_type == "phydev":
                    bridge = self.input.phydev
                elif self.input.nic_type == "virnet":
                    network = self.input.virnet

                self.logger.debug('spinning off create_nic_job dom=%s, mac=%s, bridge=%s, network=%s' \
                                  % (domname, mac, bridge, network))

                create_nic_job(self,model,domname,mac,bridge,network)
                return web.accepted()

            # -- Disk
            elif self.input.device_type == "disk":
                if not validates_disk(self):
                    return web.badrequest(self.view.alert)

                volume_job = None
                order = 0
                if self.input.pool_type == "dir" or self.input.pool_type == "fs": # create(dir)
                    disk_type = 'file'
                    pool_name = self.input.pool_dir
                    volume_name = string_from_uuid(generate_uuid())
                    volume_job = create_storage_volume_dir(self,
                                                           model,
                                                           domname,
                                                           volume_name,
                                                           self.input.pool_dir,
                                                           self.input.disk_format,
                                                           self.input.disk_size,
                                                           self.input.disk_size,
                                                           'M',
                                                           order)
                    order += 1

                elif self.input.pool_type == "block": # create(iscsi block)
                    disk_type = 'iscsi'
                    (iscsi_pool, iscsi_volume) = self.input.pool_dir.split("/", 2)
                    pool_name = iscsi_pool
                    volume_name = iscsi_volume

                else:
                    return badrequest(_("No storage type specified."))

                # add disk
                disk_job = create_disk_job(self,
                                           guest=model,
                                           domain_name=domname,
                                           pool=pool_name,
                                           volume=volume_name,
                                           bus=self.input.bus_type,
                                           format=self.input.disk_format,
                                           type=disk_type,
                                           order=order)
                order += 1

                if exec_disk_job(obj=self,
                                 guest=model,
                                 disk_job=disk_job,
                                 volume_job=volume_job,
                                 order=order
                                 ) is True:
                    return web.accepted()
                else:
                    return False

            else: # Not Found
                return False
        finally:
            kvc.close()

urls = (
    '/host/(\d+)/guest/(\d+)/device/?(\.part|\.html)?$', GuestBy1Device,
    )

########NEW FILE########
__FILENAME__ = guestby1disk
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import pwd

import karesansui
from karesansui.lib.const import VIRT_COMMAND_ADD_DISK, DISK_MIN_SIZE, \
     STORAGE_VOLUME_PWD, DISK_USES, \
     VIRT_COMMAND_DELETE_STORAGE_VOLUME, VIRT_COMMAND_CREATE_STORAGE_VOLUME

from karesansui.lib.utils import uniq_filename, is_param, chk_create_disk
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

# lib public
def validates_disk(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    """ TODO
    # sparse

    # disk
    if is_param(obj.input, 'disk_size'):
        check = checker.check_number(_('Disk Size (MB)'),
                                     obj.input.disk_size,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                     min = DISK_MIN_SIZE,
                                     ) and check

    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Disk Size (MB)'))

    """
    obj.view.alert = checker.errors

    return check

def create_storage_volume_dir(obj, guest, domname, volume_name, pool_name, format,
                            capacity, allocation, unit, order):
    """<comment-ja>
    dir形式のストレージボリュームを利用して、ディスク追加を行います。
    </comment-ja>
    <comment-en>
    TODO: To include comments in English
    </comment-en>
    """
    # create volume
    cmdname = u"Create Storage Volume"
    cmd = VIRT_COMMAND_CREATE_STORAGE_VOLUME

    options = {}

    options['name'] = domname
    options['pool_name'] = pool_name
    options['format'] = format
    options['capacity'] = capacity
    options['allocation'] = allocation
    options['unit'] = unit
    options['permission_owner'] = pwd.getpwnam(STORAGE_VOLUME_PWD["OWNER"])[2]
    options['permission_group'] = pwd.getpwnam(STORAGE_VOLUME_PWD["GROUP"])[2]
    options['permission_mode'] = STORAGE_VOLUME_PWD["MODE"]
    options['use'] = DISK_USES["DISK"]
    options['volume'] = volume_name

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    rollback_options = {}
    rollback_options["name"] = domname
    rollback_options["pool_name"] = pool_name
    rollback_options["use"] = DISK_USES["IMAGES"]

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'],
                   VIRT_COMMAND_DELETE_STORAGE_VOLUME),
        rollback_options)

    _job = Job('%s command' % cmdname, order, _cmd)
    _job.rollback_command = rollback_cmd
    return _job

def create_disk_job(obj, guest, domain_name, pool, volume,
                    bus, format, type, target=None, order=0):
    """<comment-ja>
    ディスク追加ジョブを作成します。
    </comment-ja>
    <comment-en>
    TODO: To include comments in English
    </comment-en>
    """
    cmdname = u"Add Disk"
    cmd = VIRT_COMMAND_ADD_DISK

    options = {}
    options['name'] = domain_name
    options['pool'] = pool
    options['volume'] = volume
    options['bus'] = bus
    options['type'] = type
    if target is not None:
        options['target'] = target

    if type != 'iscsi':
        options['format'] = format

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    job = Job('%s command' % cmdname, order, _cmd)
    return job

def exec_disk_job(obj,
                  guest,
                  disk_job,
                  volume_job=None,
                  order=0):
    """<comment-ja>
    ゲストOSにディスクを追加するジョブを登録します。
    </comment-ja>
    <comment-en>
    TODO: To include comments in English
    </comment-en>
    """
    cmdname = u"Add Disk"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    if volume_job is not None:
        _jobgroup.jobs.append(volume_job)

    _jobgroup.jobs.append(disk_job)

    _machine2jobgroup = m2j_new(machine=guest,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )
    return True

########NEW FILE########
__FILENAME__ = guestby1diskby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.const import VIRT_COMMAND_DELETE_DISK, \
     DISK_USES, VIRT_COMMAND_DELETE_STORAGE_VOLUME
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.merge import MergeGuest
from karesansui.lib.utils import is_int

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

# lib public
def delete_storage_volume(obj, volume, pool, order, use=DISK_USES["DISK"]):
    cmdname = u"Delete Storage Volume"
    cmd = VIRT_COMMAND_DELETE_STORAGE_VOLUME

    options = {}

    options['name'] = volume
    options['pool'] = pool
    options['use'] = use

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    job = Job('%s command' % cmdname, order, _cmd)
    return job

def delete_disk_job(obj, name, target, order, options={}):
    options['name'] = name
    options['target'] = target

    cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_DISK), options)

    job = Job('Delete disk', order, cmd)
    return job

def setexec_delete_disk(obj, guest, disk_job, volume_job):
    jobgroup = JobGroup('Delete disk', karesansui.sheconf['env.uniqkey'])
    order = 0
    if volume_job is not None:
        jobgroup.jobs.append(volume_job)
    jobgroup.jobs.append(disk_job)

    _machine2jobgroup = m2j_new(machine=guest,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           jobgroup,
                           )
    return True



class GuestBy1DiskBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.badrequest()

        disk_id = int(param[2])

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()

        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()

            virt = kvc.search_kvg_guests(domname)[0]

            guest = MergeGuest(model, virt)
            self.view.guest = guest
            self.view.disk_info = virt.get_disk_info()[disk_id]
        finally:
            kvc.close()

        return True

    """
    @auth
    def _PUT(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.badrequest()

        disk_id = int(param[2])

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            guest = MergeGuest(model, virt)
        finally:
            kvc.close()

        return web.accepted()
    """

    @auth
    def _DELETE(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.badrequest()

        disk_id = int(param[2])

        model = findbyguest1(self.orm, guest_id)
        if not model: return web.notfound()

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)

            virt = kvc.search_kvg_guests(domname)[0]
            guest = MergeGuest(model, virt)
            disk_info = virt.get_disk_info()[disk_id]

            if disk_info['source'].has_key('file'):
                pool_type = 'file'
                volume_rpath = disk_info['source']['file']
            elif disk_info['source'].has_key('dev'):
                pool_type = 'iscsi'
                volume_rpath = disk_info['source']['dev']

            disk_type = disk_info['type']
            disk_device = disk_info['device']

            if disk_device != "cdrom":
                pool_name = kvc.get_storage_pool_name_byimage(volume_rpath)
                if not pool_name:
                    return web.badrequest(_("Storage pool not found."))
                else:
                    pool_name = pool_name[0]
                pool_type = kvc.get_storage_pool_type(pool_name)

            order = 0
            volume_job = None
            if pool_type != 'iscsi' and disk_type != "block":
                disk_volumes = kvc.get_storage_volume_bydomain(domname, 'disk', 'key')
                volume = None

                for key in disk_volumes.keys():
                    if volume_rpath == os.path.realpath(disk_volumes[key]):
                        volume = key

                if volume is None:
                    return web.badrequest(_("Storage volume can not be found."))

                volume_job = delete_storage_volume(self,
                                                   key,
                                                   pool_name,
                                                   order,
                                                   use=DISK_USES["DISK"]
                                                   )
                order += 1
        finally:
            kvc.close()

        target = disk_info["target"]["dev"]
        self.logger.debug('spinning off delete_disk_job dom=%s, target=%s' % (domname, target))

        disk_job = delete_disk_job(self, domname, target, order)
        if setexec_delete_disk(self, model, disk_job, volume_job) is True:
            return web.accepted()
        else:
            return False

urls = (
    '/host/(\d+)/guest/(\d+)/disk/(\d+)/?(\.part|\.json)?$', GuestBy1DiskBy1,
    )

########NEW FILE########
__FILENAME__ = guestby1graphics
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.const import VIRT_COMMAND_SET_GRAPHICS, \
     GRAPHICS_PORT_MIN_NUMBER, GRAPHICS_PORT_MAX_NUMBER, ENABLE_GRAPHICS_TYPE
from karesansui.lib.const import XEN_KEYMAP_DIR, KVM_KEYMAP_DIR

from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.utils import is_int, is_param, get_keymaps
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX, CHECK_EXIST

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access.machine import findbyguest1
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command


def validates_graphics(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'port'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Graphics Port Number'))
    else:
        check = checker.check_number(
                _('Graphics Port Number'),
                obj.input.port,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                min = GRAPHICS_PORT_MIN_NUMBER,
                max = GRAPHICS_PORT_MAX_NUMBER,
            ) and check

    if not is_param(obj.input, 'listen'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Graphics Listen Address'))
    else:
        check = checker.check_empty(
                _('Graphics Listen Address'), 
                obj.input.listen
            ) and check

        if check is True:
            if not obj.input.listen in ["0.0.0.0", "127.0.0.1"]:
                checker.add_error(_('%s is in invalid format.') % (_('Graphics Listen Address')))
                check = False
            else:
                check = True

    if not is_param(obj.input, 'change_passwd'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Graphics Password'))
    else:
        check = checker.check_empty(
                _('Graphics Password'), 
                obj.input.change_passwd
            ) and check

        if check is True:
            if not obj.input.change_passwd in ["random", "empty", "keep"]:
                checker.add_error(_('%s is in invalid format.') % (_('Graphics Password')))
                check = False
            else:
                check = True

    hypervisor = "KVM"
    if obj.input.VMType == 'XEN':
        hypervisor = "XEN"
    elif obj.input.VMType == 'KVM':
        hypervisor = "KVM"

    if not is_param(obj.input, 'keymap'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Graphics Keymap'))
    else:
        check = checker.check_keymap(
                _('Graphics Keymap'),
                obj.input.keymap,
                CHECK_EMPTY | CHECK_EXIST,
                hypervisor) and check

    obj.view.alert = checker.errors
    return check
    

class GuestBy1Graphics(Rest):

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()
            virt = kvc.search_kvg_guests(domname)[0]

            info = virt.get_graphics_info()
            self.view.checked_listen_all = ""
            self.view.checked_listen_lo = "checked"
            try:
                if info["setting"]["listen"] == "0.0.0.0":
                    self.view.checked_listen_all = "checked"
                    self.view.checked_listen_lo = ""
            except:
                pass

            self.view.VMType = virt.get_info()['VMType']
            self.view.keymaps = eval("get_keymaps(%s_KEYMAP_DIR)" % self.view.VMType.upper())
            self.view.info = info
            self.view.guest = model

            self.view.checked_graphics_type = {}
            self.view.graphics_type = ENABLE_GRAPHICS_TYPE
            for _type in self.view.graphics_type:
               self.view.checked_graphics_type[_type] = ''
               if info["info"]["type"] == _type:
                   self.view.checked_graphics_type[_type] = 'checked'

        finally:
            kvc.close()
            
        return True


    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        Japanese Comment
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if not validates_graphics(self):
            return web.badrequest(self.view.alert)

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            info = virt.get_graphics_info()["setting"]

            used_ports = kvc.list_used_graphics_port()
            origin_port = info["port"]

        finally:
            kvc.close()

        options = {}
        options["name"] = domname
        if self.input.change_passwd == "random":
            options["random-passwd"] = None
        elif self.input.change_passwd == "empty":
            options["passwd"] = ""
        options["port"] = self.input.port
        options["listen"] = self.input.listen
        options["keymap"] = self.input.keymap
        options["type"] = self.input.graphics_type

        if int(self.input.port) != origin_port and int(self.input.port) in used_ports:
            return web.badrequest("Graphics port number has been already used by other service. - port=%s" % (self.input.port,))

        _cmd = dict2command("%s/%s" % (karesansui.config['application.bin.dir'],
                                       VIRT_COMMAND_SET_GRAPHICS),
                            options)

        cmdname = "Set Graphics"
        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname, 0, _cmd))
        
        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return web.created(None)
            

urls = ('/host/(\d+)/guest/(\d+)/graphics/?(\.part)$', GuestBy1Graphics,)

########NEW FILE########
__FILENAME__ = guestby1job
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.search import validates_jobsearch
from karesansui.lib.rest import Rest, auth
from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.utils import str2datetime, is_param, is_empty
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection

from karesansui.lib.checker import Checker,\
    CHECK_EMPTY, CHECK_VALID, \
    CHECK_LENGTH, CHECK_ONLYSPACE,\
    CHECK_MIN, CHECK_MAX
from karesansui.lib.const import JOB_LIST_RANGE, DEFAULT_LANGS,\
    USER_MIN_LENGTH, USER_MAX_LENGTH,\
    ID_MIN_LENGTH, ID_MAX_LENGTH, \
    MACHINE_HYPERVISOR

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access._2pysilhouette import jg_findbyalltype
from karesansui.db.access.machine_machine2jobgroup import findbyguest as m2mj_findbyguest
from karesansui.db.access.user import findbyname_BM
from karesansui.db.model._2pysilhouette import JOBGROUP_STATUS, JOBGROUP_TYPE

class GuestBy1Job(Rest):

    @auth
    def _GET(self, *param, **params):

        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()
        
        model = findbyguest1(self.orm, guest_id)
        # virt
        self.kvc = KaresansuiVirtConnection()
        try:
            domname = self.kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()
        finally:
            self.kvc.close()


        (check, edit) = validates_jobsearch(self)
        if check is False:
            return web.badrequest(self.view.alert)

        if edit is True:
            # user search
            users = findbyname_BM(self.orm, self.input.user)
            users_id = []

            for user in users:
                users_id.append(user.id)
            if is_empty(self.input.start):
                start = None
            else:
                start = str2datetime(self.input.start,
                                     DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
            if is_empty(self.input.end):
                end = None
            else:
                end = str2datetime(self.input.end,
                                   DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0],True)

            # machine search
            m_m2js = m2mj_findbyguest(self.orm,
                           guest_id,
                           start,
                           end,
                           users_id,
                           )
            if not m_m2js:
                self.logger.debug("Search m_m2js failed. "
                                  "Did not exist m_m2js that in accord with these query. "
                                  "guest_id %s, start %s, end %s, users_id %s" % (guest_id, start, end, users_id))
                return web.nocontent()
            
            self.view.m_m2js = m_m2js
            self.view.user   = self.input.user
            self.view.status = self.input.status
            self.view.start  = self.input.start
            self.view.end    = self.input.end

            jobgroup_ids = []
            for m_m2j in m_m2js:
                jobgroup_ids.append(m_m2j[1].jobgroup_id)

            jobgroup_status = self.input.status
            if is_empty(jobgroup_status):
                jobgroup_status = None
            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                                         jobgroup_ids, jobgroup_status, desc=True)
            if not jobgroups:
                self.logger.debug("Search jobgroups failed. "
                                  "Did not exist jobgroups that in accord with these query."
                                  "jobgroup_ids %s, jobgroup_status %s" % (jobgroup_ids, jobgroup_status))
                return web.nocontent()
        else:
            m_m2js = m2mj_findbyguest(self.orm, guest_id)

            self.view.m_m2js = m_m2js
            self.view.user   = ''
            self.view.status = ''
            self.view.start  = ''
            self.view.end    = ''

            jobgroup_ids = []
            for m_m2j in m_m2js:
                 jobgroup_ids.append(m_m2j[1].jobgroup_id)

            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                         jobgroup_ids, desc=True)

        self.view.JOBGROUP_STATUS = JOBGROUP_STATUS
        self.view.HYPERVISOR = MACHINE_HYPERVISOR

        if self.input.has_key('p') is True:
            if validates_page(self) is True:
                start = int(self.input.p)
            else:
                return web.badrequest(self.view.alert)

        else:
            start = 0
        self.view.date_format = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][1]
        self.view.pager = Pager(jobgroups, start, JOB_LIST_RANGE)

        return True

urls = (
    '/host/(\d+)/guest/(\d+)/job/?(\.part)$', GuestBy1Job,
    )

########NEW FILE########
__FILENAME__ = guestby1memory
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.const import VIRT_COMMAND_SET_MEMORY
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection

from karesansui.lib.utils import is_param

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access.machine import findbyguest1
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

class GuestBy1Memory(Rest):
    
    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()
        
        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()

        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()
            virt = kvc.search_kvg_guests(domname)[0]
            self.view.info = virt.get_info()
            #self.view.mem_info = kvc.get_mem_info()
            self.view.nodeinfo = kvc.get_nodeinfo()
            self.view.guest = model
            self.view.hypervisor = self.view.info['hypervisor']
        finally:
            kvc.close()
            
        return True

    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        Japanese Comment
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_param(self.input, 'memory'):
            memory = int(self.input.memory)
        else:
            memory = None
        max_memory = int(self.input.max_memory)

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            info = virt.get_info()
            #maxMem = info["maxMem"]
            now_memory = info["memory"]
            mem_info = kvc.get_mem_info()
            nodeinfo = kvc.get_nodeinfo()
        finally:
            kvc.close()
            
        # valid
        #if (mem_info["host_free_mem"] + (now_memory / 1024)) < memory:
        #    return web.badrequest("Memory value is greater than the maximum memory value. - memory=%s" % self.input.memory)

        options = {}
        options["name"] = domname
        options["maxmem"] = max_memory
        if memory is None:
            options["memory"] = max_memory
        else:
            options["memory"] = memory
        _cmd = dict2command("%s/%s" % (karesansui.config['application.bin.dir'],
                                       VIRT_COMMAND_SET_MEMORY),
                            options)
        cmdname = "Set Memory"
        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname, 0, _cmd))
        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return  web.accepted(url=web.ctx.path)

urls = (
    '/host/(\d+)/guest/(\d+)/memory/?(\.part)?$', GuestBy1Memory,
    )

########NEW FILE########
__FILENAME__ = guestby1nic
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.const import VIRT_COMMAND_ADD_NIC
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID
from karesansui.lib.utils import is_param
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

# lib public 
def validates_nic(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []
    
    # nic_type - [phydev, virnet]
    if is_param(obj.input, 'nic_type'):
        if (obj.input.nic_type in ['phydev', 'virnet']) is False:
            check = False
            checker.add_error(_(""))
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Interface Type'))
            
    # mac_address
    if is_param(obj.input, 'mac_address'):
        check = checker.check_macaddr(
            _('MAC Address'),
            obj.input.mac_address,
            CHECK_EMPTY | CHECK_VALID
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('MAC Address'))

    obj.view.alert = checker.errors

    return check

def create_nic_job(obj, guest, name, mac, bridge, network, options={}):
    options['name'] = name
    options['mac'] = mac
    if bridge is not None:
        options['bridge'] = bridge
    if network is not None:
        options['network'] = network

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_ADD_NIC), options)

    cmdname = u"Create NIC"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job('%s command' % cmdname, 0, _cmd))
    
    _machine2jobgroup = m2j_new(machine=guest,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )        

########NEW FILE########
__FILENAME__ = guestby1nicby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.const import VIRT_COMMAND_SET_MAC_ADDRESS, \
                                 VIRT_COMMAND_DELETE_NIC
from karesansui.lib.virt.virt import KaresansuiVirtException, \
                                     KaresansuiVirtConnection
from karesansui.lib.merge import MergeGuest
from karesansui.lib.utils import is_int, is_param

from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

# validate

def validates_nicby1(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []
    
    # mac_address
    if is_param(obj.input, 'mac_address'):
        check = checker.check_macaddr(
            _('MAC Address'),
            obj.input.mac_address,
            CHECK_EMPTY | CHECK_VALID
            ) and check
    

    obj.view.alert = checker.errors

    return check

class GuestBy1NicBy1(Rest):
    
    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.notfound()       

        nic_id = int(param[2])

        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()

        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.notfound()
            virt = kvc.search_kvg_guests(domname)[0]
            
            guest = MergeGuest(model, virt)
            self.view.guest = guest
            if_info =  virt.get_interface_info()
            if len(if_info) <= nic_id:
                return web.notfound()

            self.view.nic_info = if_info[nic_id]
            
        finally:
            kvc.close()
            
        return True

    @auth
    def _PUT(self, *param, **params):

        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.notfound()       
        nic_id = int(param[2])


        if not validates_nicby1(self):
            return web.badrequest(self.view.alert)

        model = findbyguest1(self.orm, guest_id)
        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            guest = MergeGuest(model, virt)
            old_mac = virt.get_interface_info()[nic_id]['mac']['address']
            nic_info = virt.get_interface_info()
        finally:
            kvc.close()

        new_mac = self.input.mac_address

        if old_mac != new_mac:
            f_chk = True
            for x in nic_info:
                if x['mac']['address'] == new_mac:
                    f_chk = False
                    break
            if f_chk is False:
                return web.badrequest(_('Specified MAC address is already defined.'))

            self.logger.debug('spinning off change_mac_job dom=%s, from_mac=%s, to_mac=%s' % (domname, old_mac, new_mac))
            if change_mac_job(self, model, domname, old_mac, new_mac) is True:
                return web.accepted(url=web.ctx.path)
            else:
                return False

        else:
            return web.accepted(url=web.ctx.path)
            #return web.nocontent()

    @auth
    def _DELETE(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if is_int(param[2]) is False:
            return web.notfound()       

        nic_id = int(param[2])

        model = findbyguest1(self.orm, guest_id)
        
        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            guest = MergeGuest(model, virt)
            nic_info = virt.get_interface_info()[nic_id]
        finally:
            kvc.close()

        mac = nic_info["mac"]["address"]
        self.logger.debug('spinning off delete_nic_job dom=%s, mac=%s' % (domname, mac))
        if delete_nic_job(self,model,domname,mac) is True:
            return web.accepted()
        else:
            return False
# -- lib
def change_mac_job(obj, guest, name, old_mac, new_mac, options={}):
    options['name'] = name
    options['from'] = old_mac
    options['to']   = new_mac

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_SET_MAC_ADDRESS), options)

    cmdname = u"Change MAC Address"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % cmdname, 0, _cmd))


    _machine2jobgroup = m2j_new(machine=guest,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )        
    return True

# -- lib
def delete_nic_job(obj, guest, name, mac, options={}):
    options['name'] = name
    options['mac']  = mac

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_NIC), options)

    cmdname = u"Delete NIC"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % cmdname, 0, _cmd))
    
    _machine2jobgroup = m2j_new(machine=guest,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )        
    return True
    #return web.accepted()
    
urls = (
    '/host/(\d+)/guest/(\d+)/nic/(\d+)/?(\.part|\.json)?$', GuestBy1NicBy1,
    )

########NEW FILE########
__FILENAME__ = guestby1snapshot
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import stat
import time

import web
import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import \
     VIRT_COMMAND_TAKE_SNAPSHOT, \
     NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH,\
     VIRT_XML_CONFIG_DIR
from karesansui.lib.utils import is_param
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX, \
     CHECK_LENGTH, CHECK_ONLYSPACE

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access.notebook import new as new_notebook
from karesansui.db.access.snapshot import new as new_snapshot, \
     save as save_snapshot, \
     findbyname_guestby1 as s_findbyname_guestby1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

def validates_snapshot(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []
    
    if is_param(obj.input, 'title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    obj.view.alert = checker.errors
    
    return check

class GuestBy1Snapshot(Rest):

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        guest = findbyguest1(self.orm, guest_id)

        kvs = KaresansuiVirtSnapshot(readonly=False)
        try:
            domname = kvs.kvc.uuid_to_domname(guest.uniq_key)
            if not domname: return web.notfound()

            if self.is_mode_input():
                virt = kvs.kvc.search_kvg_guests(domname)[0]
                if virt.is_active() is True:
                    return web.badrequest(_("Guest is running. Please stop and try again. name=%s" % domname))

            self.view.is_creatable = kvs.isSupportedDomain(domname)

            self.view.snapshot_error_msg = ''
            if self.view.is_creatable is not True and len(kvs.error_msg) > 0:
                self.view.snapshot_error_msg = ", ".join(kvs.error_msg)

            try:
                snapshot_list = kvs.listNames(domname)[domname]
            except:
                pass

            current_snapshot = kvs.getCurrentSnapshotName(domname)

        finally:
            kvs.finish()

        snapshots = []
        if snapshot_list:
            snapshot_list.sort(reverse = True)
            for snapshot in snapshot_list:
                model = s_findbyname_guestby1(self.orm, snapshot,guest_id)
                if model is None:
                    name           = snapshot
                    notebook_title = ""
                    created_user   = _("N/A")
                    created        = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(int(snapshot)))
                else:
                    name           = model.name
                    notebook_title = model.notebook.title
                    created_user   = model.created_user.nickname
                    created        = model.created

                current = False
                if snapshot == current_snapshot:
                    current = True

                snapshots.append((name,
                                  notebook_title,
                                  domname,
                                  created_user,
                                  created,
                                  current
                                  ))

        self.view.snapshots = snapshots
        self.view.guest = guest
            
        return True

    @auth
    def _POST(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if not validates_snapshot(self): 
            return web.badrequest(self.view.alert)
        
        guest = findbyguest1(self.orm, guest_id)

        kvs = KaresansuiVirtSnapshot(readonly=False)
        try:
            domname = kvs.kvc.uuid_to_domname(guest.uniq_key)
            if not domname: return web.conflict(web.ctx.path)

            virt = kvs.kvc.search_kvg_guests(domname)[0]
            if virt.is_active() is True:
                return web.badrequest(_("Guest is running. Please stop and try again. name=%s" % domname))

        finally:
            kvs.finish()

        id = int(time.time())
        notebook = new_notebook(self.input.title, self.input.value)
        snapshot = new_snapshot(guest, id, self.me, self.me, notebook)
        save_snapshot(self.orm, snapshot)

        options = {}
        options['name'] = domname
        options['id'] = id

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_TAKE_SNAPSHOT),
            options)

        cmdname = 'Take Snapshot'
        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname, 0, _cmd))

        _machine2jobgroup = m2j_new(machine=guest,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        
        
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return web.accepted()

urls = (
    '/host/(\d+)/guest/(\d+)/snapshot/?(\.part)?$', GuestBy1Snapshot,
    )

########NEW FILE########
__FILENAME__ = guestby1snapshotby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import time

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import VIRT_COMMAND_DELETE_SNAPSHOT, \
     ID_MIN_LENGTH, ID_MAX_LENGTH, \
     NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH

from karesansui.lib.utils import is_param, json_dumps
from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX, \
    CHECK_LENGTH, CHECK_ONLYSPACE

from karesansui.db.access.notebook import new as new_notebook
from karesansui.db.access.snapshot import new as new_snapshot

from karesansui.db.access.machine  import findbyguest1 as m_findbyguest1
from karesansui.db.access.snapshot import findby1 as s_findby1, \
     findbyname_guestby1 as s_findbyname_guestby1, \
     logical_delete, save as save_snapshot

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from karesansui.db.model._2pysilhouette import Job, JobGroup
from pysilhouette.command import dict2command

def validates_snapshot(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    obj.view.alert = checker.errors

    return check
    
def validates_param_id(obj, snapshot_id):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    check = checker.check_number(
            _('Snapshot ID'),
            snapshot_id,
            CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
            min = ID_MIN_LENGTH,
            max = ID_MAX_LENGTH,
        ) and check
    
    obj.view.alert = checker.errors

    return check

class GuestBy1SnapshotBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()
        
        snapshot_id = param[2]
        if not validates_param_id(self, snapshot_id):
            return web.notfound(self.view.alert)

        guest = m_findbyguest1(self.orm, guest_id)
        if not guest:
            return web.notfound()

        kvs = KaresansuiVirtSnapshot(readonly=False)
        snapshot_list = []
        try:
            domname = kvs.kvc.uuid_to_domname(guest.uniq_key)
            if not domname: return web.notfound()
            self.view.is_creatable = kvs.isSupportedDomain(domname)
            try:
                snapshot_list = kvs.listNames(domname)[domname]
            except:
                pass

            parent_name  = kvs.getParentName(snapshot_id,domain=domname)
            if parent_name is None:
                parent_name = _('None')
            children_names = kvs.getChildrenNames(snapshot_id,domain=domname)
            if len(children_names) == 0:
                children_name = _('None')
            else:
                children_name = ",".join(children_names)

            model = s_findbyname_guestby1(self.orm, snapshot_id, guest_id)
            if model is None:
                name           = snapshot_id
                notebook_title = ""
                notebook_value = ""
                created_user   = _("N/A")
                created        = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(int(snapshot_id)))
                modified_user  = _("N/A")
                modified       = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(int(snapshot_id)))
            else:
                name           = model.name
                notebook_title = model.notebook.title
                notebook_value = model.notebook.value
                created_user   = model.created_user.nickname
                created        = model.created
                modified_user  = model.modified_user.nickname
                modified       = model.modified

            current_snapshot = kvs.getCurrentSnapshotName(domname)

            current = False
            if snapshot_id == current_snapshot:
                current = True

        finally:
            kvs.finish()

        if not snapshot_id in snapshot_list:
            self.logger.error(_("The specified snapshot does not exist. - %s") % snapshot_id)
            return web.notfound()

        if self.__template__["media"] == 'json':
            self.view.snapshot = json_dumps((
                                  snapshot_id,
                                  notebook_title,
                                  notebook_value,
                                  domname,
                                  created_user,
                                  created,
                                  modified_user,
                                  modified,
                                  current,
                                  parent_name,
                                  children_name,
                                 ))
        else:
            self.view.snapshot = (snapshot_id,
                                  notebook_title,
                                  notebook_value,
                                  domname,
                                  created_user,
                                  created,
                                  modified_user,
                                  modified,
                                  current,
                                  parent_name,
                                  children_name,
                                  )
        return True

    @auth
    def _PUT(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        snapshot_id = param[2]
        if not validates_param_id(self, snapshot_id):
            return web.notfound(self.view.alert)

        if not validates_snapshot(self):
            return web.badrequest(self.view.alert)

        guest = m_findbyguest1(self.orm, guest_id)
        if not guest:
            return web.notfound()

        snapshot = s_findbyname_guestby1(self.orm, snapshot_id, guest_id)
        if not snapshot:
            notebook = new_notebook(self.input.title, self.input.value)
            snapshot = new_snapshot(guest, int(snapshot_id), self.me, self.me, notebook)
            save_snapshot(self.orm, snapshot)
        else:
            snapshot.notebook.title = self.input.title
            snapshot.notebook.value = self.input.value

        return web.seeother(web.ctx.path)
    
    @auth
    def _DELETE(self, *param, **params):
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        snapshot_id = param[2]
        if not validates_param_id(self, snapshot_id):
            return web.notfound(self.view.alert)

        guest = m_findbyguest1(self.orm, guest_id)
        if not guest:
            return web.notfound()

        kvs = KaresansuiVirtSnapshot(readonly=False)
        snapshot_list = []
        try:
            domname = kvs.kvc.uuid_to_domname(guest.uniq_key)
            if not domname: return web.notfound()
            self.view.is_creatable = kvs.isSupportedDomain(domname)
            try:
                snapshot_list = kvs.listNames(domname)[domname]
            except:
                pass

            current_snapshot = kvs.getCurrentSnapshotName(domname)

        finally:
            kvs.finish()

        if not snapshot_id in snapshot_list:
            self.logger.error(_("The specified snapshot does not exist. - %s") % snapshot_id)
            return web.notfound()

        # delete
        action_cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'],
                       VIRT_COMMAND_DELETE_SNAPSHOT),
            {"name" : domname, "id" : snapshot_id})

        cmdname = "Delete Snapshot"
        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _job = Job('%s command' % cmdname, 0, action_cmd)
        _jobgroup.jobs.append(_job)
        
        _machine2jobgroup = m2j_new(machine=guest,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )        

        snapshot = s_findbyname_guestby1(self.orm, snapshot_id, guest_id)
        if snapshot:
            logical_delete(self.orm, snapshot)

        return web.accepted()

urls = (
    '/host/(\d+)/guest/(\d+)/snapshot/(\d+)/?(\.part|\.json)?$', GuestBy1SnapshotBy1,
    )

########NEW FILE########
__FILENAME__ = guestby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection, KaresansuiVirtGuest
from karesansui.lib.const import VIRT_COMMAND_START_GUEST, \
     VIRT_COMMAND_SHUTDOWN_GUEST, VIRT_COMMAND_SUSPEND_GUEST, \
     VIRT_COMMAND_RESUME_GUEST, VIRT_COMMAND_REBOOT_GUEST, \
     VIRT_COMMAND_DESTROY_GUEST, VIRT_COMMAND_AUTOSTART_GUEST
from karesansui.lib.utils import json_dumps, is_param
from karesansui.lib.checker import \
    Checker, CHECK_EMPTY, CHECK_VALID

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration

from pysilhouette.command import dict2command 
from karesansui.db.model._2pysilhouette import Job, JobGroup

GUEST_ACTION_CREATE = 0
GUEST_ACTION_SHUTDOWN = 1
GUEST_ACTION_DESTROY = 2
GUEST_ACTION_SUSPEND = 3
GUEST_ACTION_RESUME = 4
GUEST_ACTION_REBOOT = 5
GUEST_ACTION_ENABLE_AUTOSTART = 6
GUEST_ACTION_DISABLE_AUTOSTART = 7

def validates_guest_status(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'status'):
        check = checker.check_status(
                _('Status'),
                obj.input.status,
                CHECK_EMPTY | CHECK_VALID,
                [GUEST_ACTION_CREATE, 
                GUEST_ACTION_SHUTDOWN,
                GUEST_ACTION_DESTROY,
                GUEST_ACTION_SUSPEND,
                GUEST_ACTION_RESUME,
                GUEST_ACTION_REBOOT,
                GUEST_ACTION_ENABLE_AUTOSTART,
                GUEST_ACTION_DISABLE_AUTOSTART]
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Status'))

    obj.view.alert = checker.errors

    return check


class GuestBy1Status(Rest):
    
    @auth
    def _GET(self, *param, **params):
        """<comment-ja>
        virDomainState
         - VIR_DOMAIN_NOSTATE = 0
         - VIR_DOMAIN_RUNNING = 1
         - VIR_DOMAIN_BLOCKED = 2
         - VIR_DOMAIN_PAUSED = 3
         - VIR_DOMAIN_SHUTDOWN = 4
         - VIR_DOMAIN_SHUTOFF = 5
         - VIR_DOMAIN_CRASHED = 6
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()
        
        model = findbyguest1(self.orm, guest_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)
            
            if self.__template__["media"] == 'json':
                self.view.status = json_dumps(virt[0].status())
            else:
                self.view.status = virt[0].status()
                
        finally:
            kvc.close()

        #self.__template__.dir = 'guestby1'
        return True

    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        ステータス更新
         - param
           - create = 0
           - shutdown = 1
           - destroy = 2
           - suspend = 3
           - resume = 4
           - reboot = 5
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        (host_id, guest_id) = self.chk_guestby1(param)
        if guest_id is None: return web.notfound()

        if not validates_guest_status(self):
            return web.badrequest(self.view.alert)

        status = int(self.input.status)

        model = findbyguest1(self.orm, guest_id)
        
        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)

            if status == GUEST_ACTION_CREATE:
                # -- Create
                cmdname = ["Start Guest", "start guest"]
                if virt[0].is_creatable() is True:
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_START_GUEST),
                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_START_GUEST
                else:
                    self.logger.error("Create Action:The state can not run. - %d" % virt[0].status())
                
            elif status == GUEST_ACTION_SHUTDOWN:
                cmdname = ["Shutdown Guest", "shutdown guest"]
                if virt[0].is_shutdownable() is True:
                    # -- Shutdown
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_SHUTDOWN_GUEST),
                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_SHUTDOWN_GUEST
                else:
                    self.logger.error("Shutdown Action:The state can not run. - %d" % virt[0].status())
            
            elif status == GUEST_ACTION_DESTROY:
                cmdname = ["Destroy Guest", "Destroy guest"]
                if virt[0].is_destroyable() is True:
                    # -- destroy
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_DESTROY_GUEST),
                                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_DESTROY_GUEST
                else:
                    self.logger.error("Destroy Action:The state can not run. - %d" % virt[0].status())
                    
            elif status == GUEST_ACTION_SUSPEND:
                cmdname = ["Suspend Guest", "suspend guest"]
                if virt[0].is_suspendable() is True:
                    # -- Suspend
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_SUSPEND_GUEST),
                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_SUSPEND_GUEST
                else:
                    self.logger.error("Destroy Action:The state can not run. - %d" % virt[0].status())
                    
            elif status == GUEST_ACTION_RESUME:
                cmdname = ["Resume Guest", "resume guest"]
                if virt[0].is_resumable() is True:
                    # -- Resume
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_RESUME_GUEST),
                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_RESUME_GUEST
                else:
                    self.logger.error("Resume Action:The state can not run. - %d" % virt[0].status())

            elif status == GUEST_ACTION_REBOOT:
                cmdname = ["Reboot Guest", "reboot guest"]
                if virt[0].is_shutdownable() is True:
                    # -- Reboot
                    _cmd = dict2command(
                        "%s/%s" % (karesansui.config['application.bin.dir'],
                                   VIRT_COMMAND_REBOOT_GUEST),
                        {"name":domname})
                    
                    self.view.status = VIRT_COMMAND_REBOOT_GUEST
                else:
                    self.logger.error("Reboot Action:The state can not run. - %d" % virt[0].status())

            elif status == GUEST_ACTION_ENABLE_AUTOSTART:
                cmdname = ["Enable Autostart Guest", "enable autostart guest"]
                # -- Enable autostart guest
                _cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'],
                               VIRT_COMMAND_AUTOSTART_GUEST),
                    {"name":domname, "enable":None})
                    
                self.view.status = VIRT_COMMAND_AUTOSTART_GUEST

            elif status == GUEST_ACTION_DISABLE_AUTOSTART:
                cmdname = ["Disable Autostart Guest", "disable autostart guest"]
                # -- Disable autostart guest
                _cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'],
                               VIRT_COMMAND_AUTOSTART_GUEST),
                    {"name":domname, "disable":None})
                    
                self.view.status = VIRT_COMMAND_AUTOSTART_GUEST

            else:
                self.logger.error("Action:Bad Request. - request status=%d" % status)
                return web.badrequest()

        finally:
            kvc.close()

        # Job Register
        _jobgroup = JobGroup(cmdname[0], karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname[1], 0, _cmd))
        
        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )
        
        # INSERT
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return web.accepted(url="/host/%d/guest/%d.part" % (host_id, guest_id))

urls = (
    '/host/(\d+)/guest/(\d+)/status/?(\.part|\.json)?$', GuestBy1Status,
    )

########NEW FILE########
__FILENAME__ = guestexport
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import glob
import time

import web
import simplejson as json

import karesansui
from karesansui.gadget.guest import regist_guest
from karesansui.lib.rest import Rest, auth

from karesansui.lib.utils import chk_create_disk, json_dumps, is_param, base64_encode, get_partition_info
from karesansui.lib.const import \
    VIRT_COMMAND_EXPORT_GUEST, \
    ID_MIN_LENGTH, ID_MAX_LENGTH, \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.virt.config_export import ExportConfigParam

from karesansui.db.access.machine import findbyguest1
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_ONLYSPACE, \
    CHECK_MIN, CHECK_MAX

def validates_guest_export(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'export_title'):
        check = False
        checker.add_error(_('Parameter export_title does not exist.'))
    else:
        check = checker.check_string(
                    _('Title'),
                    obj.input.export_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    obj.view.alert = checker.errors
    return check

def validates_sid(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'sid'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Copy Source'))
    else:
        check = checker.check_number(_('Copy Source'),
                                     obj.input.sid,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     ID_MIN_LENGTH,
                                     ID_MAX_LENGTH
                                     ) and check

        obj.view.alert = checker.errors
    return check


class GuestExport(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        kvc = KaresansuiVirtConnection()
        try:
            # Storage Pool
            #inactive_pool = kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            if self.is_mode_input() is True: # (*.input)
                if not validates_sid(self):
                    return web.badrequest(self.view.alert)

                sid = self.input.sid
                model = findbyguest1(self.orm, sid)
                if not model:
                    return web.badrequest()

                domname = kvc.uuid_to_domname(model.uniq_key)

                src_pools = kvc.get_storage_pool_name_bydomain(domname)
                if not src_pools:
                    return web.badrequest(_("Source storage pool is not found."))

                for src_pool in  src_pools :
                    src_pool_type = kvc.get_storage_pool_type(src_pool)
                    if src_pool_type != 'dir':
                        return web.badrequest(_("'%s' disk contains the image.") % src_pool_type)

                virt = kvc.search_kvg_guests(domname)[0]

                if virt.is_active() is True:
                    return web.badrequest(_("Guest is running. Please stop and try again. name=%s" % domname))

                self.view.domname = virt.get_domain_name()

                non_iscsi_pool = []
                for pool in pools:
                    if kvc.get_storage_pool_type(pool) != 'iscsi':
                        non_iscsi_pool.append(pool)
                self.view.pools = non_iscsi_pool
                self.view.sid = sid
                return True

            # Exported Guest Info (*.json)
            exports = {}
            for pool_name in pools:
                files = []
                pool = kvc.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]

                if os.path.exists(path):
                    for _afile in glob.glob("%s/*/info.dat" % (path,)):
                        param = ExportConfigParam()
                        param.load_xml_config(_afile)

                        _dir = os.path.dirname(_afile)

                        uuid = param.get_uuid()
                        name = param.get_domain()
                        created = param.get_created()
                        title = param.get_title()
                        if title != "":
                            title = re.sub("[\r\n]","",title)
                        if title == "":
                            title = _('untitled')

                        if created != "":
                            created_str = time.strftime("%Y/%m/%d %H:%M:%S", \
                                                        time.localtime(float(created)))
                        else:
                            created_str = _("N/A")

                        files.append({"dir": _dir,
                                      "pool" : pool_name,
                                      #"b64dir" : base64_encode(_dir),
                                      "uuid" : uuid,
                                      "name" : name,
                                      "created" : int(created),
                                      "created_str" : created_str,
                                      "title" : title,
                                      })

                exports[pool_name] = files

                # .json
                if self.is_json() is True:
                    self.view.exports = json_dumps(exports)
                else:
                    self.view.exports = exports

            return True

        finally:
            kvc.close()

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_guest_export(self):
            return web.badrequest(self.view.alert)

        if not validates_sid(self):
            return web.badrequest(self.view.alert)

        model = findbyguest1(self.orm, self.input.sid)
        if not model:
            return web.badrequest()

        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(model.uniq_key)
            if not domname: return web.conflict(web.ctx.path)

            src_pools = kvc.get_storage_pool_name_bydomain(domname)
            if not src_pools:
                return web.badrequest(_("Source storage pool is not found."))

            for src_pool in  src_pools :
                src_pool_type = kvc.get_storage_pool_type(src_pool)
                if src_pool_type != 'dir':
                    return web.badrequest(_("'%s' disk contains the image.") % src_pool_type)

            virt = kvc.search_kvg_guests(domname)[0]
            options = {}
            options["name"] = virt.get_domain_name()
            if is_param(self.input, "pool"):
                # disk check
                src_pool = kvc.get_storage_pool_name_bydomain(domname, 'os')[0]
                src_path = kvc.get_storage_pool_targetpath(src_pool)
                src_disk = "%s/%s/images/%s.img" \
                           % (src_path, options["name"], options["name"])

                dest_path = kvc.get_storage_pool_targetpath(self.input.pool)
                s_size = os.path.getsize(src_disk) / (1024 * 1024) # a unit 'MB'

                if os.access(dest_path, os.F_OK):
                    if chk_create_disk(dest_path, s_size) is False:
                        partition = get_partition_info(dest_path, header=False)
                        return web.badrequest(
                            _("No space available to create disk image in '%s' partition.") \
                                % partition[5][0])

                #else: # Permission denied
                    #TODO:check disk space for root

                options["pool"] = self.input.pool

            if is_param(self.input, "export_title"):
                #options["title"] = self.input.export_title
                options["title"] = "b64:" + base64_encode(self.input.export_title)
            options["quiet"] = None

        finally:
            kvc.close()

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_EXPORT_GUEST), options)

        # Job Register
        cmdname = ["Export Guest", "export guest"]
        _jobgroup = JobGroup(cmdname[0], karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmdname[1], 0, _cmd))

        _machine2jobgroup = m2j_new(machine=model,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        # INSERT
        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        self.logger.debug("(%s) Job group id==%s" % (cmdname[0],_jobgroup.id))
        url = '%s/job/%s.part' % (web.ctx.home, _jobgroup.id)
        self.logger.debug('Returning Location: %s' % url)

        return web.accepted()

urls = (
    '/host/(\d+)/guestexport/?(\.part|\.json)$', GuestExport,
    )

########NEW FILE########
__FILENAME__ = guestexportby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os.path
import re
import glob
import time

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.virt.config import ConfigParam
from karesansui.lib.virt.config_export import ExportConfigParam

from karesansui.lib.const import VIRT_COMMAND_DELETE_EXPORT_DATA

from karesansui.lib.utils import json_dumps

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access.notebook import findby1 as n_findby1
from karesansui.db.access.machine  import findbyhost1

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

class GuestExportBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        # valid
        self.view.uuid = param[1]

        kvc = KaresansuiVirtConnection()
        try: # libvirt connection scope -->
            # Storage Pool
            #inactive_pool = kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            export = []
            for pool_name in pools:
                pool = kvc.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]
                if os.path.exists(path):
                    for _afile in glob.glob("%s/*/info.dat" % (path,)):
                        e_param = ExportConfigParam()
                        e_param.load_xml_config(_afile)

                        if e_param.get_uuid() != self.view.uuid:
                            continue

                        e_name = e_param.get_domain()
                        _dir = os.path.dirname(_afile)

                        param = ConfigParam(e_name)

                        path = "%s/%s.xml" % (_dir, e_name)
                        if os.path.isfile(path) is False:
                            self.logger.error('Export corrupt data.(file not found) - path=%s' % path)
                            return web.internalerror()

                        param.load_xml_config(path)

                        if e_name != param.get_domain_name():
                            self.logger.error('Export corrupt data.(The name does not match) - info=%s, xml=%s' \
                                              % (e_name, param.get_name()))
                            return web.internalerror()

                        _dir = os.path.dirname(_afile)

                        title = e_param.get_title()
                        if title != "":
                            title = re.sub("[\r\n]","",title)
                        if title == "":
                            title = _('untitled')

                        created = e_param.get_created()
                        if created != "":
                            created_str = time.strftime("%Y/%m/%d %H:%M:%S", \
                                                        time.localtime(float(created)))
                        else:
                            created_str = _("N/A")

                        export.append({"info" : {"dir" : _dir,
                                                 "pool" : pool_name,
                                                 "uuid" : e_param.get_uuid(),
                                                 "name" : e_name,
                                                 "created" : int(created),
                                                 "created_str" : created_str,
                                                 "title" : title,
                                                  },
                                       "xml" : {"on_reboot" : param.get_behavior('on_reboot'),
                                                "on_poweroff" : param.get_behavior('on_poweroff'),
                                                "on_crash" : param.get_behavior('on_crash'),
                                                "boot_dev" : param.get_boot_dev(),
                                                #"bootloader" : param.get_bootloader(),
                                                #"commandline" : param.get_commandline(),
                                                #"current_snapshot" : param.get_current_snapshot(),
                                                'disk' : param.get_disk(),
                                                "domain_name" : param.get_domain_name(),
                                                "domain_type" : param.get_domain_type(),
                                                "features_acpi" : param.get_features_acpi(),
                                                "features_apic" : param.get_features_apic(),
                                                "features_pae" : param.get_features_pae(),
                                                #"initrd" : param.get_initrd(),
                                                "interface" : param.get_interface(),
                                                #"kernel" : param.get_kernel(),
                                                "max_memory" : param.get_max_memory(),
                                                'max_vcpus' : param.get_max_vcpus(),
                                                "max_vcpus_limit" : param.get_max_vcpus_limit(),
                                                "memory" : param.get_memory(),
                                                "uuid" : param.get_uuid(),
                                                "vcpus" : param.get_vcpus(),
                                                "vcpus_limit" : param.get_vcpus_limit(),
                                                "graphics_autoport" : param.get_graphics_autoport(),
                                                "keymap" : param.get_graphics_keymap(),
                                                "graphics_listen" : param.get_graphics_listen(),
                                                "graphics_passwd" : param.get_graphics_passwd(),
                                                "graphics_port" : param.get_graphics_port(),
                                                },
                                       "pool" : pool[0].get_info(),
                                       })

            if len(export) != 1:
                self.logger.info("Export does not exist. - uuid=%s" % self.view.uuid)
                return web.badrequest()

            # .json
            if self.is_json() is True:
                self.view.export = json_dumps(export[0])
            else:
                self.view.export = export

            return True
        finally:
            kvc.close() 

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        # valid
        self.view.uuid = param[1]

        kvc = KaresansuiVirtConnection()
        try:
            # Storage Pool
            #inactive_pool = kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            export = []
            for pool_name in pools:
                pool = kvc.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]
                if os.path.exists(path):
                    for _afile in glob.glob("%s/*/info.dat" % (path,)):
                        e_param = ExportConfigParam()
                        e_param.load_xml_config(_afile)

                        if e_param.get_uuid() != self.view.uuid:
                            continue

                        e_name = e_param.get_domain()
                        _dir = os.path.dirname(_afile)

                        param = ConfigParam(e_name)

                        path = "%s/%s.xml" % (_dir, e_name)
                        if os.path.isfile(path) is False:
                            self.logger.error('Export corrupt data.(file not found) - path=%s' % path)
                            return web.internalerror()

                        param.load_xml_config(path)

                        if e_name != param.get_domain_name():
                            self.logger.error('Export corrupt data.(The name does not match) - info=%s, xml=%s' \
                                              % (e_name, param.get_name()))
                            return web.internalerror()

                        _dir = os.path.dirname(_afile)

                        export.append({"dir" : _dir,
                                       "pool" : pool_name,
                                       "uuid" : e_param.get_uuid(),
                                       "name" : e_name,
                                       })

            if len(export) != 1:
                self.logger.info("Export does not exist. - uuid=%s" % self.view.uuid)
                return web.badrequest()
        finally:
            kvc.close()

        export = export[0]
        if os.path.exists(export['dir']) is False or os.path.isdir(export['dir']) is False:
            self.logger.error('Export data is not valid. [%s]' % export_dir)
            return web.badrequest('Export data is not valid.')

        host = findbyhost1(self.orm, host_id)

        options = {}
        options['uuid'] = export["uuid"]

        _cmd = dict2command("%s/%s" % (karesansui.config['application.bin.dir'], \
                                       VIRT_COMMAND_DELETE_EXPORT_DATA), options)

        # Job Registration
        _jobgroup = JobGroup('Delete Export Data', karesansui.sheconf['env.uniqkey'])

        _jobgroup.jobs.append(Job('Delete Export Data', 0, _cmd))

        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        self.logger.debug('(Delete export data) Job group id==%s', _jobgroup.id)
        url = '%s/job/%s.part' % (web.ctx.home, _jobgroup.id)
        self.logger.debug('Returning Location: %s' % url)

        return web.accepted()

urls = (
    '/host/(\d+)/guestexport/([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12})/?(\.json)$', GuestExportBy1,
    )

########NEW FILE########
__FILENAME__ = guestimport
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os.path
import re
import glob
import time

import web
import simplejson as json

import karesansui
from karesansui.gadget.guest import regist_guest
from karesansui.lib.rest import Rest, auth

from karesansui.lib.utils import chk_create_disk, json_dumps, is_param, \
  base64_encode, base64_decode, get_dom_list, get_dom_type, \
  string_from_uuid, generate_uuid, comma_split, uniq_sort, get_partition_info

from karesansui.lib.const import \
    VIRT_COMMAND_IMPORT_GUEST

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.virt.config import ConfigParam
from karesansui.lib.virt.config_export import ExportConfigParam

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

from karesansui.db.access.machine  import new as m_new, findby1uniquekey as m_findby1uniquekey
from karesansui.db.access.notebook import new as n_new
from karesansui.db.access.tag      import new as t_new
from karesansui.db.access.machine  import findby1 as m_findby1
from karesansui.db.access.notebook import findby1 as n_findby1
from karesansui.db.access.tag      import findby1 as t_findby1
from karesansui.db.access.tag      import samecount   as t_count
from karesansui.db.access.tag      import findby1name as t_name

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_ISDIR, CHECK_STARTROOT, CHECK_EXIST

from karesansui.lib.utils import get_xml_parse        as XMLParse
from karesansui.lib.utils import get_xml_xpath        as XMLXpath
from karesansui.lib.utils import get_nums_xml_xpath   as XMLXpathNum
from karesansui.lib.file.configfile import ConfigFile

def validates_guest_import(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []
    # TODO UUID check

    obj.view.alert = checker.errors
    return check


class GuestImport(Rest):

    #@auth
    #def _GET(self, *param, **params):
    #    return web.seeother()

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)

        if not validates_guest_import(self):
            return web.badrequest(self.view.alert)

        uuid = self.input.uuid
        kvc = KaresansuiVirtConnection()
        try:
            # Storage Pool
            #inactive_pool = kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            export = []
            for pool_name in pools:
                pool = kvc.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]
                if os.path.exists(path):
                    for _afile in glob.glob("%s/*/info.dat" % (path,)):
                        e_param = ExportConfigParam()
                        e_param.load_xml_config(_afile)

                        if e_param.get_uuid() != uuid:
                            continue

                        e_name = e_param.get_domain()
                        _dir = os.path.dirname(_afile)

                        param = ConfigParam(e_name)

                        path = "%s/%s.xml" % (_dir, e_name)
                        if os.path.isfile(path) is False:
                            self.logger.error('Export corrupt data.(file not found) - path=%s' % path)
                            return web.internalerror()

                        param.load_xml_config(path)

                        if e_name != param.get_domain_name():
                            self.logger.error('Export corrupt data.(The name does not match) - info=%s, xml=%s' \
                                              % (e_name, param.get_name()))
                            return web.internalerror()

                        _dir = os.path.dirname(_afile)

                        title = e_param.get_title()
                        if title != "":
                            title = re.sub("[\r\n]","",title)
                        if title == "":
                            title = _('untitled')

                        created = e_param.get_created()
                        if created != "":
                            created_str = time.strftime("%Y/%m/%d %H:%M:%S", \
                                                        time.localtime(float(created)))
                        else:
                            created_str = _("N/A")

                        export.append({"info" : {"dir" : _dir,
                                                 "pool" : pool_name,
                                                 "uuid" : e_param.get_uuid(),
                                                 "name" : e_param.get_domain(),
                                                 "created" : int(created),
                                                 "created_str" : created_str,
                                                 "title" : title,
                                                 "database" : {"name" : e_param.database["name"],
                                                               "tags" : e_param.database["tags"],
                                                               "attribute" : e_param.database["attribute"],
                                                               "notebook" : {"title" : e_param.database["notebook"]["title"],
                                                                             "value" : e_param.database["notebook"]["value"],
                                                                             },
                                                               "uniq_key" : e_param.database["uniq_key"],
                                                               "hypervisor" : e_param.database["hypervisor"],
                                                               "icon" : e_param.database["icon"],
                                                               },
                                                  },
                                       "xml" : {"on_reboot" : param.get_behavior('on_reboot'),
                                                "on_poweroff" : param.get_behavior('on_poweroff'),
                                                "on_crash" : param.get_behavior('on_crash'),
                                                "boot_dev" : param.get_boot_dev(),
                                                #"bootloader" : param.get_bootloader(),
                                                #"commandline" : param.get_commandline(),
                                                #"current_snapshot" : param.get_current_snapshot(),
                                                'disk' : param.get_disk(),
                                                "domain_name" : param.get_domain_name(),
                                                "domain_type" : param.get_domain_type(),
                                                "features_acpi" : param.get_features_acpi(),
                                                "features_apic" : param.get_features_apic(),
                                                "features_pae" : param.get_features_pae(),
                                                #"initrd" : param.get_initrd(),
                                                "interface" : param.get_interface(),
                                                #"kernel" : param.get_kernel(),
                                                "max_memory" : param.get_max_memory(),
                                                'max_vcpus' : param.get_max_vcpus(),
                                                "max_vcpus_limit" : param.get_max_vcpus_limit(),
                                                "memory" : param.get_memory(),
                                                "uuid" : param.get_uuid(),
                                                "vcpus" : param.get_vcpus(),
                                                "vcpus_limit" : param.get_vcpus_limit(),
                                                "graphics_autoport" : param.get_graphics_autoport(),
                                                "keymap" : param.get_graphics_keymap(),
                                                "graphics_listen" : param.get_graphics_listen(),
                                                "graphics_passwd" : param.get_graphics_passwd(),
                                                "graphics_port" : param.get_graphics_port(),
                                                },
                                       "pool" : pool[0].get_info(),
                                       })
            if len(export) != 1:
                self.logger.info("Export does not exist. - uuid=%s" % self.view.uuid)
                return web.badrequest()
            else:
                export = export[0]
        finally:
            kvc.close()

        # Pool running?
        if export['pool']['is_active'] is False:
            return web.badrequest("The destination, the storage pool is not running.")

        dest_domname = export['xml']['domain_name']
        dest_uniqkey = export['info']['database']['uniq_key']
        # Same guest OS is already running.
        if m_findby1uniquekey(self.orm, dest_uniqkey) is not None:
            self.logger.info(_("guest '%s' already exists. (DB) - %s") % (dest_domname, dest_uniqkey))
            return web.badrequest(_("guest '%s' already exists.") % dest_domname)

        dest_dir = "%s/%s" % (export['pool']['target']['path'], export['xml']['domain_name'])
        if os.path.exists(dest_dir) is True:
            self.logger.info(_("guest '%s' already exists. (FS) - %s") % (dest_domname, dest_dir))
            return  web.badrequest(_("guest '%s' already exists.") % dest_domname)

        # disk check
        try:
            src_disk = "%s/%s/images/%s.img" \
                       % (export["info"]["dir"], export["info"]["name"], export["info"]["name"])

            if os.path.exists(src_disk):
                s_size = os.path.getsize(src_disk) / (1024 * 1024) # a unit 'MB'
                if chk_create_disk(export["info"]["dir"], s_size) is False:
                    partition = get_partition_info(export["info"]["dir"], header=False)
                    return web.badrequest(
                        _("No space available to create disk image in '%s' partition.") \
                        % partition[5][0])
        except:
            pass

        extra_uniq_key = string_from_uuid(generate_uuid())
        options = {}
        options["exportuuid"] = export["info"]["uuid"]
        options["destuuid"] = extra_uniq_key
        options["quiet"] = None

        # Database Notebook
        try:
            _notebook = n_new(
                export["info"]["database"]["notebook"]["title"],
                export["info"]["database"]["notebook"]["value"],
                )
        except:
            _notebook = None

        # Database Tag
        _tags = []
        try:
            tag_array = comma_split(export["info"]["database"]["tags"])
            tag_array = uniq_sort(tag_array)
            for x in tag_array:
                if t_count(self.orm, x) == 0:
                    _tags.append(t_new(x))
                else:
                    _tags.append(t_name(self.orm, x))
        except:
            _tags.append(t_new(""))

        parent = m_findby1(self.orm, host_id)
        dest_guest = m_new(created_user=self.me,
                           modified_user=self.me,
                           uniq_key=extra_uniq_key,
                           name=export["info"]["database"]["name"],
                           attribute=int(export["info"]["database"]["attribute"]),
                           hypervisor=int(export["info"]["database"]["hypervisor"]),
                           notebook=_notebook,
                           tags=_tags,
                           icon=export["info"]["database"]["icon"],
                           is_deleted=False,
                           parent=parent,
                           )

        ret = regist_guest(self,
                           _guest=dest_guest,
                           icon_filename=export["info"]["database"]["icon"],
                           cmd=VIRT_COMMAND_IMPORT_GUEST,
                           options=options,
                           cmdname=['Import Guest', 'Import Guest'],
                           rollback_options={"name" : export["xml"]["domain_name"]},
                           is_create=False
                           )

        if ret is True:
            return web.accepted()
        else:
            return False

urls = (
    '/host/(\d+)/guestimport/?(\.part)$', GuestImport,
    )

########NEW FILE########
__FILENAME__ = guestreplicate
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os

import web
import simplejson as json

import karesansui
#from karesansui.gadget.guest import regist_guest
from karesansui.gadget.guestby1disk import create_disk_job

from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import \
    VIRT_COMMAND_REPLICATE_GUEST, \
    GRAPHICS_PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    ID_MIN_LENGTH, ID_MAX_LENGTH, MACHINE_ATTRIBUTE

from karesansui.lib.utils import comma_split, generate_uuid, \
    string_from_uuid, is_param, uni_force, \
    next_number, generate_mac_address, chk_create_disk, get_partition_info
from karesansui.db.access.machine import findbyguest1, new as m_new
from karesansui.db.access.tag import new as t_new
from karesansui.db.access.notebook import new as n_new
from karesansui.lib.virt.virt import KaresansuiVirtConnection

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_ONLYSPACE, \
    CHECK_MIN, CHECK_MAX

from karesansui.lib.const import \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    GRAPHICS_PORT_MIN_NUMBER, GRAPHICS_PORT_MAX_NUMBER, \
    DOMAIN_NAME_MIN_LENGTH, DOMAIN_NAME_MAX_LENGTH, \
    VIRT_COMMAND_DELETE_GUEST, VIRT_COMMAND_REPLICATE_STORAGE_VOLUME, \
    DISK_USES, VIRT_COMMAND_DELETE_STORAGE_VOLUME

from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import jg_save, jg_delete
from karesansui.db.model._2pysilhouette import Job, JobGroup
from karesansui.db.access.machine import \
     findbyhost1guestall, findbyhost1, \
     findbyguest1, \
     new as m_new, save as m_save, delete as m_delete

from karesansui.db.access.machine2jobgroup import new as m2j_new, save as m2j_save

from pysilhouette.command import dict2command

def validates_guest_replicate(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'm_name'):
        check = False
        checker.add_error(_('Parameter m_name does not exist.'))
    else:
        check = checker.check_string(
                    _('Machine Name'),
                    obj.input.m_name,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = MACHINE_NAME_MIN_LENGTH,
                    max = MACHINE_NAME_MAX_LENGTH,
            ) and check

    if is_param(obj.input, 'note_title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.note_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'note_value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.note_value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    if is_param(obj.input, 'tags'):
        for tag in comma_split(obj.input.tags):
            check = checker.check_string(
                        _('Tag'),
                        tag,
                        CHECK_LENGTH | CHECK_ONLYSPACE,
                        None,
                        min = TAG_MIN_LENGTH,
                        max = TAG_MAX_LENGTH,
                    ) and check

    if not is_param(obj.input, 'domain_dest_name'):
        check = False
        checker.add_error(_('Parameter domain_dest_name does not exist.'))
    else:
        check = checker.check_string(
                _('Destination Domain Name'),
                obj.input.domain_dest_name,
                CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                '[^-a-zA-Z0-9_\.]+',
                DOMAIN_NAME_MIN_LENGTH,
                DOMAIN_NAME_MAX_LENGTH,
            ) and check

    if not is_param(obj.input, 'vm_graphics_port'):
        check = False
        checker.add_error(_('Parameter vm_graphics_port does not exist.'))
    else:
        check = checker.check_number(
                _('Graphics Port Number'),
                obj.input.vm_graphics_port,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                GRAPHICS_PORT_MIN_NUMBER,
                GRAPHICS_PORT_MAX_NUMBER,
            ) and check

    if not is_param(obj.input, 'vm_mac'):
        check = False
        checker.add_error(_('Parameter vm_mac does not exist.'))
    else:
        check = checker.check_macaddr(
                _('MAC Address'),
                obj.input.vm_mac,
                CHECK_EMPTY | CHECK_VALID,
            ) and check

    obj.view.alert = checker.errors
    return check


def validates_src_id(obj):
    """<comment-ja>
    ゲストOSコピー元のチェッカー
    @param obj: karesansui.lib.rest.Rest オブジェクト
    @type obj: karesansui.lib.rest.Rest
    @return: check
    @rtype: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'src_id'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Copy Source'))
    else:
        check = checker.check_number(_('Copy Source'),
                                     obj.input.src_id,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     ID_MIN_LENGTH,
                                     ID_MAX_LENGTH
                                     ) and check

        obj.view.alert = checker.errors
    return check


def replicate_storage_volume(obj, orig_name, orig_pool, orig_volume,
                             dest_name, dest_pool, dest_volume,
                             order):
    """
    <comment-ja>
    ゲストOSに登録されているディスク(ストレージボリューム)のコピージョブを作成します。
    </comment-ja>
    <comment-en>
    TODO: English Documents(en)
    </comment-en>
    """
    cmdname = u"Replicate Storage_Volume %s" % dest_name
    cmd = VIRT_COMMAND_REPLICATE_STORAGE_VOLUME

    options = {}

    options["orig_name"] = orig_name
    options["orig_pool"] = orig_pool
    options["orig_volume"] = orig_volume
    options["dest_name"] = dest_name
    options["dest_pool"] = dest_pool
    options["dest_volume"] = dest_volume

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    rollback_options = {}

    rollback_options["name"] = dest_volume
    rollback_options["pool_name"] = dest_pool
    rollback_options["use"] = DISK_USES["DISK"]

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_VOLUME),
        rollback_options)

    job = Job('%s command' % cmdname, order, _cmd)
    job.rollback_command = rollback_cmd
    return job

def replicate_guest(obj, guest, cmd, options, cmdname, rollback_options, order):
    if (karesansui.sheconf.has_key('env.uniqkey') is False) \
           or (karesansui.sheconf['env.uniqkey'].strip('') == ''):
        raise

    action_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd),
        options)

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_GUEST),
        rollback_options)

    job = Job(cmdname, order, action_cmd)
    job.rollback_command = rollback_cmd
    return job

def exec_replicate_guest(obj, _guest, icon_filename, cmdname,
                         guest_job, disk_jobs, volume_jobs):

    if icon_filename:
        _guest.icon = icon_filename

    if (karesansui.sheconf.has_key('env.uniqkey') is False) \
           or (karesansui.sheconf['env.uniqkey'].strip('') == ''):
        raise

    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])

    _jobgroup.jobs.extend(volume_jobs)
    _jobgroup.jobs.append(guest_job)
    _jobgroup.jobs.extend(disk_jobs)

    # GuestOS INSERT
    try:
        m_save(obj.orm, _guest)
        obj.orm.commit()
    except:
        obj.logger.error('Failed to register the Guest OS. #1 - guest name=%s' \
                          % _guest.name)
        raise # throw

    # JobGroup INSERT
    try:
        jg_save(obj.pysilhouette.orm, _jobgroup)
        obj.pysilhouette.orm.commit()
    except:
        # rollback(machine)
        obj.logger.error('Failed to register the JobGroup. #2 - jobgroup name=%s' \
                          % _jobgroup.name)

        try:
            m_delete(obj.orm, _guest)
            obj.orm.commit()
            obj.logger.error('#3 Rollback successful. - guest id=%d' % _guest.id)
        except:
            obj.logger.critical('#4 Rollback failed. - guest id=%d' % _guest.id)
            raise

        raise # throw

    # Machine2JobGroup INSERT
    try:
        _m2j = m2j_new(machine=_guest,
                       jobgroup_id=_jobgroup.id,
                       uniq_key=karesansui.sheconf['env.uniqkey'],
                       created_user=obj.me,
                       modified_user=obj.me,
                       )
        m2j_save(obj.orm, _m2j)
        obj.orm.commit()
    except:
        # rollback(machine, jobgroup)
        try:
            m_delete(obj.orm, _guest)
            obj.orm.commit()
        except:
            # rollback(machine)
            obj.logger.critical('Failed to register the Machine. #5 - guest id=%d' \
                              % _guest.id)
        try:
            jg_delete(obj.pysilhouette.orm, _jobgroup)
            obj.pysilhouette.orm.commit()
        except:
            # rollback(jobgroup)
            obj.logger.critical('Failed to register the JobGroup. #6 - jobgroup id=%d' \
                              % _jobgroup.id)
        raise # throw

    return True

class GuestReplicate(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_src_id(self):
            self.view.alert = "Failed to get the id of source domain."
            self.logger.debug(self.view.alert)
            return web.badrequest(self.view.alert)

        src_id = self.input.src_id
        if self.is_mode_input() is False:
            return web.nomethod()

        self.view.src_id = src_id
        self.view.mac_address = generate_mac_address()

        src_guest = findbyguest1(self.orm, src_id)
        if not src_guest:
            self.view.alert = "Failed to get the data of source domain."
            self.logger.debug(self.view.alert)
            return web.badrequest(self.view.alert)

        kvc = KaresansuiVirtConnection()
        try:
            # Storage Pool
            #inactive_pool = self.kvc.list_inactive_storage_pool()
            inactive_pool = []
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            domname = kvc.uuid_to_domname(src_guest.uniq_key)

            # TODO 対応するストレージボリュームにiscsiがあった場合はエラーにする
            src_pools = kvc.get_storage_pool_name_bydomain(domname)
            if not src_pools:
                self.view.alert = _("Source storage pool is not found.")
                self.logger.debug(self.view.alert)
                return web.badrequest(self.view.alert)

            for src_pool in  src_pools :
                src_pool_type = kvc.get_storage_pool_type(src_pool)
                if src_pool_type != 'dir':
                    self.view.alert = _("'%s' disk contains the image.") % (src_pool_type)
                    self.logger.debug(self.view.alert)
                    return web.badrequest(self.view.alert)

            non_iscsi_pool = []
            for pool in pools:
                if kvc.get_storage_pool_type(pool) != 'iscsi':
                    non_iscsi_pool.append(pool)
            self.view.pools = non_iscsi_pool

            virt = kvc.search_kvg_guests(domname)[0]
            if virt.is_active() is True:
                self.view.alert = _("Guest is running. Please stop and try again. name=%s" % domname)
                self.logger.debug(self.view.alert)
                return web.badrequest(self.view.alert)

            self.view.domain_src_name = virt.get_domain_name()
            used_ports = kvc.list_used_graphics_port()
            self.view.graphics_port = next_number(GRAPHICS_PORT_MIN_NUMBER,PORT_MAX_NUMBER,used_ports)
        finally:
            kvc.close()

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_guest_replicate(self):
            self.logger.debug(self.view.alert)
            return web.badrequest(self.view.alert)

        uuid = string_from_uuid(generate_uuid())

        # TODO dest_pool valid
        if not validates_src_id(self):
            self.logger.debug(self.view.alert)
            return web.badrequest(self.view.alert)

        src_guest = findbyguest1(self.orm, self.input.src_id)
        if not src_guest:
            self.view.alert = "Failed to get the data of source domain."
            self.logger.debug(self.view.alert)
            return web.badrequest(self.view.alert)

        # Note
        note_title = None
        if is_param(self.input, "note_title"):
            note_title = self.input.note_title

        note_value = None
        if is_param(self.input, "note_value"):
            note_value = self.input.note_value

        _notebook = n_new(note_title, note_value)

        # Tag
        _tags = None
        if is_param(self.input, "tags"):
            _tags = []
            for x in comma_split(self.input.tags):
                _tags.append(t_new(x))

        # Icon
        icon_filename = None
        if is_param(self.input, "icon_filename", empty=True):
            icon_filename = self.input.icon_filename

        dest_guest = m_new(created_user=self.me,
                           modified_user=self.me,
                           uniq_key=uni_force(uuid),
                           name=self.input.m_name,
                           attribute=MACHINE_ATTRIBUTE['GUEST'],
                           hypervisor=src_guest.hypervisor,
                           notebook=_notebook,
                           tags=_tags,
                           icon=icon_filename,
                           is_deleted=False,
                           parent=src_guest.parent,
                           )


        kvc = KaresansuiVirtConnection()
        try:
            domname = kvc.uuid_to_domname(src_guest.uniq_key)
            if not domname: return web.conflict(web.ctx.path)
            virt = kvc.search_kvg_guests(domname)[0]
            options = {}
            options["src-name"] = virt.get_domain_name()
            if is_param(self.input, "dest_pool"):
                options["pool"] = self.input.dest_pool
            if is_param(self.input, "domain_dest_name"):
                options["dest-name"] = self.input.domain_dest_name
            if is_param(self.input, "vm_graphics_port"):
                options["graphics-port"] = self.input.vm_graphics_port
            if is_param(self.input, "vm_mac"):
                options["mac"] = self.input.vm_mac

            options["uuid"] = uuid

            src_pools = kvc.get_storage_pool_name_bydomain(domname)
            if not src_pools:
                self.view.alert = _("Source storage pool is not found.")
                self.logger.debug(self.view.alert)
                return web.badrequest(self.view.alert)

            for src_pool in  src_pools :
                src_pool_type = kvc.get_storage_pool_type(src_pool)
                if src_pool_type != 'dir':
                    self.view.alert = _("'%s' disk contains the image.") % src_pool_type
                    self.logger.debug(self.view.alert)
                    return web.badrequest(self.view.alert)

            # disk check
            target_pool = kvc.get_storage_pool_name_bydomain(domname, 'os')[0]
            target_path = kvc.get_storage_pool_targetpath(target_pool)
            src_disk = "%s/%s/images/%s.img" % \
                                      (target_path, options["src-name"], options["src-name"])

            s_size = os.path.getsize(src_disk) / (1024 * 1024) # a unit 'MB'

            if os.access(target_path, os.F_OK):
                if chk_create_disk(target_path, s_size) is False:
                    partition = get_partition_info(target_path, header=False)
                    self.view.alert = _("No space available to create disk image in '%s' partition.") % partition[5][0]
                    self.logger.debug(self.view.alert)
                    return web.badrequest(self.view.alert)

            #else: # Permission denied
                #TODO:check disk space for root

            active_guests = kvc.list_active_guest()
            inactive_guests = kvc.list_inactive_guest()
            used_graphics_ports = kvc.list_used_graphics_port()
            used_mac_addrs = kvc.list_used_mac_addr()

            conflict_location = "%s/host/%d/guest/%d.json" \
                                % (web.ctx.homepath, src_guest.parent_id, src_guest.id)
            # source guestos
            if not (options["src-name"] in active_guests or options["src-name"] in inactive_guests):
                return web.conflict(conflict_location, "Unable to get the source guest.")

            # Check on whether value has already been used
            # destination guestos
            if (options["dest-name"] in active_guests or options["dest-name"] in inactive_guests):
                return web.conflict(conflict_location, "Destination guest %s is already there." % options["dest-name"])
            # Graphics Port Number
            if(int(self.input.vm_graphics_port) in used_graphics_ports):
                return web.conflict(conflict_location, "Graphics port %s is already used." % self.input.vm_graphics_port)
            # MAC Address
            if(self.input.vm_mac in used_mac_addrs):
                return web.conflict(conflict_location, "MAC address %s is already used." % self.input.vm_mac)

            # Replicate Guest
            order = 0 # job order
            disk_jobs = [] # Add Disk
            volume_jobs = [] # Create Storage Volume
            for disk in virt.get_disk_info():
                if disk['type'] != 'file':
                    self.view.alert = _("The type of the storage pool where the disk is to be added must be 'file'. dev=%s") % disk['target']['dev']
                    self.logger.debug(self.view.alert)
                    return web.badrequest(self.view.alert)

                disk_pool = kvc.get_storage_pool_name_byimage(disk['source']['file'])
                if not disk_pool:
                    self.view.alert = _("Can not find the storage pool.")
                    self.logger.debug(self.view.alert)
                    return web.badrequest(self.view.alert)
                else:
                    disk_pool = disk_pool[0]

                disk_volumes = kvc.get_storage_volume_bydomain(domname, 'disk', 'key')
                volume = None
                for key in disk_volumes.keys():
                    if disk['source']['file'] == os.path.realpath(disk_volumes[key]):
                        volume = key # disk image

                if volume is None: # os image
                    continue

                disk_uuid = string_from_uuid(generate_uuid())

                volume_jobs.append(replicate_storage_volume(self,
                                                     domname,
                                                     disk_pool,
                                                     volume,
                                                     self.input.domain_dest_name,
                                                     #self.input.dest_pool,
                                                     disk_pool, # orig
                                                     disk_uuid,
                                                     order))
                order += 1

                disk_jobs.append(create_disk_job(self,
                                                 dest_guest,
                                                 self.input.domain_dest_name,
                                                 disk_pool,
                                                 disk_uuid,
                                                 bus=disk['target']['bus'],
                                                 format=disk['driver']['type'],
                                                 type=disk['type'],
                                                 target=disk['target']['dev'],
                                                 order=-1))

        finally:
            kvc.close()


        # replicate guest
        guest_job = replicate_guest(self,
                                    dest_guest,
                                    VIRT_COMMAND_REPLICATE_GUEST,
                                    options,
                                    'Replicate Guest',
                                    {"name" : options['dest-name'],
                                     "pool" : options["pool"],
                                     },
                                    order,
                                    )
        order += 1
        for disk_job in disk_jobs:
            disk_job.order = order
            order += 1

        ret = exec_replicate_guest(self,
                                   dest_guest,
                                   icon_filename,
                                   'Replicate Guest',
                                   guest_job,
                                   disk_jobs,
                                   volume_jobs,
                                   )

        if ret is True:
            return web.accepted()
        else:
            return False

urls = (
    '/host/(\d+)/guest/replicate/?$', GuestReplicate,
    )

########NEW FILE########
__FILENAME__ = guesttag
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_CHAR
from karesansui.lib.utils import is_param, json_dumps
from karesansui.db.access.tag import findbyhost1guestall

class GuestTag(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        tags = findbyhost1guestall(self.orm, host_id)
        if not tags:
            self.logger.debug("No tags is found.")
            return web.notfound()

        if self.is_part() is True:
            self.view.tags = tags

            machine_ids = {}
            for tag in tags:
                tag_id = str(tag.id)

                machine_ids[tag_id] = []
                for machine in tag.machine:
                    if not machine.is_deleted:
                        machine_ids[tag_id].append("tag_machine%s"%  machine.id)

                machine_ids[tag_id]  = " ".join(machine_ids[tag_id])

            self.view.machine_ids = machine_ids

            return True

        elif self.is_json() is True:
            tags_json = []
            for tag in tags:
                tags_json.append(tag.get_json(self.me.languages))

            self.view.tags = json_dumps(tags_json)

            return True
        
        else:
            return web.nomethod()
urls = (
    '/host/(\d+)/guest/tag/?(\.part|\.json)$', GuestTag,
    )

########NEW FILE########
__FILENAME__ = host
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui import config
from karesansui.lib.rest import Rest, auth
from karesansui.lib.utils import generate_uuid, string_from_uuid, \
     uni_force, is_param, comma_split, uniq_sort, uri_split, uri_join

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_LENGTH, CHECK_ONLYSPACE, CHECK_VALID, \
    CHECK_MIN, CHECK_MAX

from karesansui.lib.const import \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    FQDN_MIN_LENGTH, FQDN_MAX_LENGTH, \
    PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    MACHINE_ATTRIBUTE, MACHINE_HYPERVISOR, \
    USER_MIN_LENGTH, USER_MAX_LENGTH

from karesansui.db.access.machine import \
     findbyhostall, findby1uniquekey, findby1hostname, \
     new as m_new, save as m_save, update as m_update
from karesansui.db.access.tag import new as t_new, \
     samecount as t_count, findby1name as t_name
from karesansui.db.access.notebook import new as n_new

def validates_host_add(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'm_name'):
        check = False
        checker.add_error(_('Parameter m_name does not exist.'))
    else:
        check = checker.check_string(
                    _('Machine Name'),
                    obj.input.m_name,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = MACHINE_NAME_MIN_LENGTH,
                    max = MACHINE_NAME_MAX_LENGTH,
            ) and check


    if not is_param(obj.input, 'm_connect_type'):
        check = False
        checker.add_error(_('Parameter m_connect_type does not exist.'))
    else:
        if obj.input.m_connect_type == "karesansui":

            if not is_param(obj.input, 'm_hostname'):
                check = False
                checker.add_error(_('"%s" is required.') % _('FQDN'))
            else:
                m_hostname_parts = obj.input.m_hostname.split(":")
                if len(m_hostname_parts) > 2:
                    check = False
                    checker.add_error(_('%s contains too many colon(:)s.') % _('FQDN'))
                else:
                    check = checker.check_domainname(
                                _('FQDN'),
                                m_hostname_parts[0],
                                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                                min = FQDN_MIN_LENGTH,
                                max = FQDN_MAX_LENGTH,
                                ) and check
                    try:
                        check = checker.check_number(
                                    _('Port Number'),
                                    m_hostname_parts[1],
                                    CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                    PORT_MIN_NUMBER,
                                    PORT_MAX_NUMBER,
                                    ) and check
                    except IndexError:
                        # when reach here, 'm_hostname' has only host name
                        pass

            if not is_param(obj.input, 'm_uuid'):
                check = False
                checker.add_error(_('"%s" is required.') % _('Unique Key'))
            else:
                check = checker.check_unique_key(
                            _('Unique Key'),
                            obj.input.m_uuid,
                            CHECK_EMPTY | CHECK_VALID
                            ) and check

        if obj.input.m_connect_type == "libvirt":

            if not is_param(obj.input, 'm_uri'):
                check = False
                checker.add_error(_('"%s" is required.') % _('URI'))
            else:
                pass

            if is_param(obj.input, 'm_auth_user') and obj.input.m_auth_user != "":

                check = checker.check_username(
                    _('User Name'),
                    obj.input.m_auth_user,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    min = USER_MIN_LENGTH,
                    max = USER_MAX_LENGTH,
                    ) and check

    if is_param(obj.input, 'note_title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.note_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'note_value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.note_value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    if is_param(obj.input, 'tags'):
        for tag in comma_split(obj.input.tags):
            check = checker.check_string(
                        _('Tag'),
                        tag,
                        CHECK_LENGTH | CHECK_ONLYSPACE,
                        None,
                        min = TAG_MIN_LENGTH,
                        max = TAG_MAX_LENGTH,
                    ) and check

    obj.view.alert = checker.errors
    return check

class Host(Rest):

    @auth
    def _GET(self, *param, **params):

        if self.is_mode_input():
            return True
        else:
            self.view.hosts = findbyhostall(self.orm)
            self.view.application_uniqkey = karesansui.config['application.uniqkey']
            if self.input.has_key('job_id') is True:
                self.view.job_id = self.input.job_id
            else:
                self.view.job_id = None
            
            return True

    @auth
    def _POST(self, *param, **params):
        if not validates_host_add(self):
            return web.badrequest(self.view.alert)

        if self.input.m_connect_type == "karesansui":

            uniq_key_check = findby1uniquekey(self.orm, self.input.m_uuid)
            if uniq_key_check is not None and config['application.uniqkey'] != self.input.m_uuid:
                return web.conflict(web.ctx.path)

            hostname_check = findby1hostname(self.orm, self.input.m_hostname)
            if hostname_check is not None:
                return web.conflict(web.ctx.path)

        # notebook
        note_title = None
        if is_param(self.input, "note_title"):
            note_title = self.input.note_title

        note_value = None
        if is_param(self.input, "note_value"):
            note_value = self.input.note_value
            
        _notebook = n_new(note_title, note_value)

        # tags
        _tags = None
        if is_param(self.input, "tags"):
            _tags = []
            tag_array = comma_split(self.input.tags)
            tag_array = uniq_sort(tag_array)
            for x in tag_array:
                if t_count(self.orm, x) == 0:
                    _tags.append(t_new(x))
                else:
                    _tags.append(t_name(self.orm, x))

        name = self.input.m_name

        if self.input.m_connect_type == "karesansui":
            uniq_key = self.input.m_uuid
            attribute = MACHINE_ATTRIBUTE['HOST']
            if is_param(self.input, "m_hostname"):
                hostname = self.input.m_hostname

        if self.input.m_connect_type == "libvirt":
            uniq_key = string_from_uuid(generate_uuid())
            attribute = MACHINE_ATTRIBUTE['URI']
            if is_param(self.input, "m_uri"):
                segs = uri_split(self.input.m_uri)
                if is_param(self.input, "m_auth_user") and self.input.m_auth_user:
                    segs["user"] = self.input.m_auth_user
                    if is_param(self.input, "m_auth_passwd") and self.input.m_auth_passwd:
                        segs["passwd"] = self.input.m_auth_passwd
                hostname = uri_join(segs)

        model = findby1uniquekey(self.orm, uniq_key, is_deleted = True)
        if model is None:
            host = m_new(created_user=self.me,
                         modified_user=self.me,
                         uniq_key=uni_force(uniq_key),
                         name=name,
                         hostname=hostname,
                         attribute=attribute,
                         hypervisor=MACHINE_HYPERVISOR['REAL'],
                         notebook=_notebook,
                         tags=_tags,
                         icon=None,
                         is_deleted=False)

            m_save(self.orm, host)
            return web.created(None)
        else:
            model.name = name
            model.hostname = hostname
            model.uniq_key = uniq_key
            model.notebook.title = note_title
            model.notebook.value = note_value
            model.tags = _tags
            model.is_deleted = False
            m_update(self.orm, model)
            return web.created(None)

urls = ('/host/?(\.html|\.part)$', Host)

########NEW FILE########
__FILENAME__ = hostby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.db.access.machine import \
     findbyhost1, findby1name, findby1hostname, \
     update as m_update, delete as m_delete, logical_delete

from karesansui.lib.merge import MergeHost
from karesansui.lib.virt.virt import KaresansuiVirtConnection, KaresansuiVirtConnectionAuth
from karesansui.lib.utils import \
    comma_split, uniq_sort, is_param, json_dumps, \
    get_proc_cpuinfo, get_proc_meminfo, get_partition_info, \
    available_virt_uris, uri_split, uri_join

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_LENGTH, CHECK_ONLYSPACE, CHECK_VALID,\
    CHECK_MIN, CHECK_MAX

from karesansui.lib.const import \
    NOTE_TITLE_MIN_LENGTH, NOTE_TITLE_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    FQDN_MIN_LENGTH, FQDN_MAX_LENGTH, \
    PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    MACHINE_ATTRIBUTE, MACHINE_HYPERVISOR, \
    USER_MIN_LENGTH, USER_MAX_LENGTH, \
    VENDOR_DATA_DIR

from karesansui.db.access.tag import \
    new as t_new, samecount as t_count, findby1name as t_name


def validates_host_edit(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'm_name'):
        check = False
        checker.add_error(_('Parameter m_name does not exist.'))
    else:
        check = checker.check_string(
                    _('Machine Name'),
                    obj.input.m_name,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = MACHINE_NAME_MIN_LENGTH,
                    max = MACHINE_NAME_MAX_LENGTH,
            ) and check

    if not is_param(obj.input, 'm_connect_type'):
        check = False
        checker.add_error(_('Parameter m_connect_type does not exist.'))
    else:
        if obj.input.m_connect_type == "karesansui":

            if not is_param(obj.input, 'm_hostname'):
                check = False
                checker.add_error(_('"%s" is required.') % _('FQDN'))
            else:
                m_hostname_parts = obj.input.m_hostname.split(":")
                if len(m_hostname_parts) > 2:
                    check = False
                    checker.add_error(_('%s contains too many colon(:)s.') % _('FQDN'))
                else:
                    check = checker.check_domainname(
                                _('FQDN'),
                                m_hostname_parts[0],
                                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                                min = FQDN_MIN_LENGTH,
                                max = FQDN_MAX_LENGTH,
                                ) and check
                    try:
                        check = checker.check_number(
                                    _('Port Number'),
                                    m_hostname_parts[1],
                                    CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                    PORT_MIN_NUMBER,
                                    PORT_MAX_NUMBER,
                                    ) and check
                    except IndexError:
                        # when reach here, 'm_hostname' has only host name
                        pass

        if obj.input.m_connect_type == "libvirt":

            if not is_param(obj.input, 'm_uri'):
                check = False
                checker.add_error(_('"%s" is required.') % _('URI'))
            else:
                pass

            if is_param(obj.input, 'm_auth_user') and obj.input.m_auth_user != "":

                check = checker.check_username(
                    _('User Name'),
                    obj.input.m_auth_user,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    min = USER_MIN_LENGTH,
                    max = USER_MAX_LENGTH,
                    ) and check


    if is_param(obj.input, 'note_title'):
        check = checker.check_string(
                    _('Title'),
                    obj.input.note_title,
                    CHECK_LENGTH | CHECK_ONLYSPACE,
                    None,
                    min = NOTE_TITLE_MIN_LENGTH,
                    max = NOTE_TITLE_MAX_LENGTH,
                ) and check

    if is_param(obj.input, 'note_value'):
        check = checker.check_string(
                    _('Note'),
                    obj.input.note_value,
                    CHECK_ONLYSPACE,
                    None,
                    None,
                    None,
                ) and check

    if is_param(obj.input, 'tags'):
        for tag in comma_split(obj.input.tags):
            check = checker.check_string(
                        _('Tag'),
                        tag,
                        CHECK_LENGTH | CHECK_ONLYSPACE,
                        None,
                        min = TAG_MIN_LENGTH,
                        max = TAG_MAX_LENGTH,
                    ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1(Rest):

    def _post(self, f):
        ret = Rest._post(self, f)
        if hasattr(self, "kvc") is True:
            self.kvc.close()
        return ret

    @auth
    def _GET(self, *param, **params):

        if self.input.has_key('job_id') is True:
            self.view.job_id = self.input.job_id
        else:
            self.view.job_id = None

        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)

        uris = available_virt_uris()
        if model.attribute == 0 and model.hypervisor == 1:
            uri = uris["XEN"]
        elif model.attribute == 0 and model.hypervisor == 2:
            uri = uris["KVM"]
        else:
            uri = None

        # other_url
        other_url = "%s://%s%s/" % (self.view.ctx.protocol, model.hostname, karesansui.config['application.url.prefix'])

        if self.is_mode_input() is False:
            if karesansui.config["application.uniqkey"] == model.uniq_key:
                # My host
                host_cpuinfo = get_proc_cpuinfo()
                cpuinfo = {}
                cpuinfo["number"] = len(host_cpuinfo)
                cpuinfo["vendor"] = host_cpuinfo[0]["vendor_id"]
                cpuinfo["model"] = host_cpuinfo[0]["model name"]
                cpuinfo["frequency"] = host_cpuinfo[0]["cpu MHz"]

                host_meminfo = get_proc_meminfo()
                meminfo = {}
                meminfo["total"] = host_meminfo["MemTotal"][0]
                meminfo["free"] = host_meminfo["MemFree"][0]
                meminfo["buffers"] = host_meminfo["Buffers"][0]
                meminfo["cached"] = host_meminfo["Cached"][0]

                host_diskinfo = get_partition_info(VENDOR_DATA_DIR)
                diskinfo = {}
                diskinfo["total"] = host_diskinfo[1]
                diskinfo["free"] = host_diskinfo[3]

                self.kvc = KaresansuiVirtConnection(uri)
                try:
                    host = MergeHost(self.kvc, model)
                    if self.is_json() is True:
                        json_host = host.get_json(self.me.languages)
                        self.view.data = json_dumps({"model": json_host["model"], 
                                                     "cpuinfo": cpuinfo,
                                                     "meminfo": meminfo,
                                                     "diskinfo": diskinfo,
                                                     })
                    else:
                        self.view.model = host.info["model"]
                        self.view.virt = host.info["virt"]
                finally:
                    self.kvc.close()

            else:
                # other uri
                if model.attribute == 2:
                    segs = uri_split(model.hostname)
                    uri = uri_join(segs, without_auth=True)
                    creds = ''
                    if segs["user"] is not None:
                        creds += segs["user"]
                        if segs["passwd"] is not None:
                            creds += ':' + segs["passwd"]

                    try:
                        self.kvc = KaresansuiVirtConnectionAuth(uri,creds)

                        host = MergeHost(self.kvc, model)
                        if self.is_json() is True:
                            json_host = host.get_json(self.me.languages)
                            self.view.data = json_dumps({"model": json_host["model"],
                                                         "uri"  : uri,
                                                         "num_of_guests"  : len(host.guests),
                                                     })
                        else:
                            self.view.model = host.info["model"]
                            self.view.virt = host.info["virt"]
                            self.view.uri = uri
                            try:
                                self.view.auth_user = segs["user"]
                            except:
                                self.view.auth_user = ""
                            try:
                                self.view.auth_passwd = segs["passwd"]
                            except:
                                self.view.auth_passwd = ""

                    except:
                        pass

                    finally:
                        #if 'kvc' in dir(locals()["self"])
                        if 'kvc' in dir(self):
                            self.kvc.close()

                # other host
                else:
                    if self.is_json() is True:
                        self.view.data = json_dumps({
                            "model": model.get_json(self.me.languages),
                            "other_url" : other_url,
                            })
                    else:
                        self.view.model = model
                        self.view.virt = None
                        self.view.other_url = other_url

            return True
        else:
            # mode=input
            if model.attribute == 2:
                segs = uri_split(model.hostname)
                uri = uri_join(segs, without_auth=True)
                creds = ''
                if segs["user"] is not None:
                    creds += segs["user"]
                    if segs["passwd"] is not None:
                        creds += ':' + segs["passwd"]

                self.view.model = model
                self.view.uri = uri
                try:
                    self.view.auth_user = segs["user"]
                except:
                    self.view.auth_user = ""
                try:
                    self.view.auth_passwd = segs["passwd"]
                except:
                    self.view.auth_passwd = ""

            else:
                self.kvc = KaresansuiVirtConnection(uri)
                try:
                    host = MergeHost(self.kvc, model)
                    self.view.model = host.info["model"]
                finally:
                    self.kvc.close()

            self.view.application_uniqkey = karesansui.config['application.uniqkey']

            return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        
        if not validates_host_edit(self):
            self.logger.debug("Update Host OS is failed, Invalid input value.")
            return web.badrequest(self.view.alert)

        host = findbyhost1(self.orm, host_id)

        cmp_host = findby1name(self.orm, self.input.m_name)
        if cmp_host is not None and int(host_id) != cmp_host.id:
            self.logger.debug("Update Host OS is failed, "
                              "Already exists name"
                              "- %s, %s" % (host, cmp_host))
            return web.conflict(web.ctx.path)

        if self.input.m_connect_type == "karesansui":
            hostname_check = findby1hostname(self.orm, self.input.m_hostname)
            if hostname_check is not None and int(host_id) != hostname_check.id:
                return web.conflict(web.ctx.path)

        if self.input.m_connect_type == "karesansui":
            host.attribute = MACHINE_ATTRIBUTE['HOST']
            if is_param(self.input, "m_hostname"):
                host.hostname = self.input.m_hostname

        if self.input.m_connect_type == "libvirt":
            host.attribute = MACHINE_ATTRIBUTE['URI']
            if is_param(self.input, "m_uri"):
                segs = uri_split(self.input.m_uri)
                if is_param(self.input, "m_auth_user") and self.input.m_auth_user:
                    segs["user"] = self.input.m_auth_user
                    if is_param(self.input, "m_auth_passwd") and self.input.m_auth_passwd:
                        segs["passwd"] = self.input.m_auth_passwd
                host.hostname = uri_join(segs)

        if is_param(self.input, "note_title"):
            host.notebook.title = self.input.note_title
        if is_param(self.input, "note_value"):
            host.notebook.value = self.input.note_value
        if is_param(self.input, "m_name"):
            host.name = self.input.m_name
    
        # Icon
        icon_filename = None
        if is_param(self.input, "icon_filename", empty=True):
            host.icon = self.input.icon_filename

        # tag UPDATE
        if is_param(self.input, "tags"):
            _tags = []
            tag_array = comma_split(self.input.tags)
            tag_array = uniq_sort(tag_array)
            for x in tag_array:
                if t_count(self.orm, x) == 0:
                    _tags.append(t_new(x))
                else:
                    _tags.append(t_name(self.orm, x))
            host.tags = _tags

        host.modified_user = self.me

        m_update(self.orm, host)

        return web.seeother(web.ctx.path)

    @auth
    def _DELETE(self, *param, **params):

        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        host = findbyhost1(self.orm, host_id)

        logical_delete(self.orm, host)

        return web.seeother(url = "/")

urls = (
    '/host/(\d+)/?(\.html|\.part|\.json)?$', HostBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1firewall
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import time
import re
import os

import web
from web.utils import Storage

from karesansui.lib.rest import Rest, auth
from karesansui.lib.firewall.iptables import KaresansuiIpTables
from karesansui.gadget.hostby1firewallrule import validates_rule
from karesansui.lib.utils import get_ifconfig_info, dict_ksort

class HostBy1Firewall(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        
        kit = KaresansuiIpTables()
        
        if os.path.exists(kit.firewall_xml_file) is False:
            self.view.have_config = False
        else:
            kit.firewall_xml = kit.read_firewall_xml()
            # --
            self.view.iptables = Storage(
                is_running=kit.is_running(),
                is_configured=kit.is_configured(),
                )
            self.view.have_config = True

            if self.is_mode_input() is True:

                self.view.default_rule_id = len(kit.get_rules()) + 1
                self.view.targets = kit.basic_targets['filter']
                self.view.protocols = kit.chain_protos
                devtype_regexs = {
                    "phy":"^(lo|eth)",
                    "vir":"^(xenbr|virbr|vif|veth)",
                    }
                devtype_phy_regex = re.compile(r"%s" % devtype_regexs['phy'])
                devtype_vir_regex = re.compile(r"%s" % devtype_regexs['vir'])
                
                devs = {}
                devs['phy'] = []
                devs['vir'] = []
                devs['oth'] = []
                cidrs = []
                ips = []
                for dev,dev_info in get_ifconfig_info().iteritems():
                    try:
                        if devtype_phy_regex.match(dev):
                            devs['phy'].append(dev)
                        elif devtype_vir_regex.match(dev):
                            devs['vir'].append(dev)
                        else:
                            devs['oth'].append(dev)
                        
                        if dev_info['ipaddr'] is not None:
                            if not dev_info['ipaddr'] in ips:
                                ips.append(dev_info['ipaddr'])
                        if dev_info['cidr'] is not None:
                            if not dev_info['cidr'] in cidrs:
                                cidrs.append(dev_info['cidr'])
                    except:
                        pass
                devs['phy'].sort()
                devs['vir'].sort()
                devs['oth'].sort()
                self.view.devs = [{'Physical' : devs['phy']},
                                  {'Virtual' : devs['vir']},
                                  {'Other' : devs['oth']},
                                  ]
                
                self.view.cidrs = cidrs
                self.view.ips = ips

        # --
        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_rule(self, is_newrule=True):
            return web.badrequest(self.view.alert)
        
        kit = KaresansuiIpTables()
        kit.firewall_xml = kit.read_firewall_xml()
        
        rule_info = {"target" : self.input.target,
                     "protocol" : self.input.protocol,
                     "source" : self.input.source,
                     "destination" : self.input.destination,
                     "source-port" : self.input.sport,
                     "destination-port" : self.input.dport,
                     "in-interface" : self.input.inif,
                     "out-interface" : self.input.outif,
                     }

        if self.input.rule_id == "":
            rule_id = kit.add_rule(rule_info)
        else:
            rule_id = kit.insert_rule(int(self.input.rule_id),rule_info)

        kit.write_firewall_xml()
        
        self.view.host_id = host_id
        
        return web.created('%s/%d' % (web.ctx.path, rule_id,))


urls = (
    '/host/(\d+)/firewall/?(\.part)$', HostBy1Firewall,
    )

########NEW FILE########
__FILENAME__ = hostby1firewallpolicy
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import time

import web
from web.utils import Storage

from karesansui.lib.rest import Rest, auth
from karesansui.lib.firewall.iptables import KaresansuiIpTables
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_CHAR
from karesansui.lib.utils import is_param

def validates_policy(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'input_policy'):
        check = False
        checker.add_error(_('"%s" is required.') % _('INPUT Chain'))
    else:
        check = checker.check_firewall_policy(
                _('INPUT Chain'),
                obj.input.input_policy,
                CHECK_EMPTY | CHECK_VALID
                ) and check

    if not is_param(obj.input, 'output_policy'):
        check = False
        checker.add_error(_('"%s" is required.') % _('OUTPUT Chain'))
    else:
        check = checker.check_firewall_policy(
                _('OUTPUT Chain'),
                obj.input.output_policy,
                CHECK_EMPTY | CHECK_VALID
                ) and check

    if not is_param(obj.input, 'forward_policy'):
        check = False
        checker.add_error(_('"%s" is required.') % _('FORWARD Chain'))
    else:
        check = checker.check_firewall_policy(
                _('FORWARD Chain'),
                obj.input.input_policy,
                CHECK_EMPTY | CHECK_VALID
                ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1FirewallPolicy(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        
        self.view.host_id = host_id

        kit = KaresansuiIpTables()

        if os.path.exists(kit.firewall_xml_file) is False:
            self.view.have_config = False
        else:
            self.view.have_config = True
            kit.firewall_xml = kit.read_firewall_xml()

            for chain in kit.basic_chains['filter']:
                try:
                    policy = kit.firewall_xml['filter'][chain]['policy']
                except:
                    policy = 'ACCEPT'
                chain = chain.lower()
                exec("self.view.%s_policy_ACCEPT_checked = ''" % chain)
                exec("self.view.%s_policy_DROP_checked = ''" % chain)
                exec("self.view.%s_policy_REJECT_checked = ''" % chain)
                if policy == 'REJECT':
                    exec("self.view.%s_policy = 'REJECT'" % chain)
                    exec("self.view.%s_policy_REJECT_checked = 'checked'" % chain)
                elif policy == 'DROP':
                    exec("self.view.%s_policy = 'DROP'" % chain)
                    exec("self.view.%s_policy_DROP_checked = 'checked'" % chain)
                    self.view.base_policy_DROP_checked = 'checked';
                else:
                    exec("self.view.%s_policy = 'ACCEPT'" % chain)
                    exec("self.view.%s_policy_ACCEPT_checked = 'checked'" % chain)

            self.view.iptables = Storage(
                is_running=kit.is_running(),
                is_configured=kit.is_configured(),
            )

            self.view.targets = kit.basic_targets['filter']

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        kit = KaresansuiIpTables()
        kit.firewall_xml = kit.read_firewall_xml()
        
        if not validates_policy(self):
            self.logger.debug("Create account is failed, Invalid input value")
            return web.badrequest(self.view.alert)
        
        kit.modify_policy("INPUT",  self.input.input_policy)
        kit.modify_policy("OUTPUT", self.input.output_policy)
        kit.modify_policy("FORWARD",self.input.forward_policy)
        kit.write_firewall_xml()

        for chain in kit.basic_chains['filter']:
            try:
                policy = kit.firewall_xml['filter'][chain]['policy']
            except:
                policy = 'ACCEPT'
            chain = chain.lower()
            exec("self.view.%s_policy_ACCEPT_checked = ''" % chain)
            exec("self.view.%s_policy_DROP_checked = ''" % chain)
            exec("self.view.%s_policy_REJECT_checked = ''" % chain)
            if policy == 'REJECT':
                exec("self.view.%s_policy = 'REJECT'" % chain)
                exec("self.view.%s_policy_REJECT_checked = 'checked'" % chain)
            elif policy == 'DROP':
                exec("self.view.%s_policy = 'DROP'" % chain)
                exec("self.view.%s_policy_DROP_checked = 'checked'" % chain)
                self.view.base_policy_DROP_checked = 'checked';
            else:
                exec("self.view.%s_policy = 'ACCEPT'" % chain)
                exec("self.view.%s_policy_ACCEPT_checked = 'checked'" % chain)

        return web.seeother(web.ctx.path)

urls = ('/host/(\d+)/firewall/policy/?(\.part)$', HostBy1FirewallPolicy,)

########NEW FILE########
__FILENAME__ = hostby1firewallrule
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import time
import re
import os

import web
from web.utils import Storage

from karesansui.lib.rest import Rest, auth
from karesansui.lib.firewall.iptables import KaresansuiIpTables
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_CHAR, CHECK_MIN, CHECK_MAX,\
     CHECK_EXIST
from karesansui.lib.utils import dict_ksort, is_param
from karesansui.lib.const import ID_MIN_LENGTH,\
     PORT_MIN_NUMBER, PORT_MAX_NUMBER

def validates_rule(obj, is_newrule=False):
    checker = Checker()
    check = True
          
    _ = obj._ 
    checker.errors = []

    obj.view.error_msg = checker.errors

    if is_newrule: 
        kit = KaresansuiIpTables()
        rule_id_max_length = 1
        if os.path.exists(kit.firewall_xml_file) is False:
            check = False
            checker.add_error(_('Has not been initialized. Please initialize.'))
        else:
            kit.firewall_xml = kit.read_firewall_xml()
            rule_id_max_length += len(kit.get_rules())

        if not is_param(obj.input, 'rule_id'):
            check = False
            checker.add_error(_('"%s" is required.') % _('ID'))
        else:
            check = checker.check_number(
                    _('ID'),
                    obj.input.rule_id,
                    CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    min = ID_MIN_LENGTH,
                    max = rule_id_max_length,
                    ) and check

    if not is_param(obj.input, 'target'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Target'))
    else:
        check = checker.check_firewall_policy(
                _('Target'),
                obj.input.target,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'protocol'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Protocol'))
    else:
        check = checker.check_firewall_protocol(
                _('Protocol'),
                obj.input.protocol,
                CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'source'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Source Address'))
    else:
        check = checker.check_ipaddr(
                _('Source Address'),
                obj.input.source,
                CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'sport'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Source Port'))
    else:
        if obj.input.protocol == 'tcp' or obj.input.protocol == 'udp':
            check = checker.check_number(
                    _('Source Port'),
                    obj.input.sport,
                    CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    min = PORT_MIN_NUMBER,
                    max = PORT_MAX_NUMBER,
                    ) and check

    if not is_param(obj.input, 'destination'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Destination Address'))
    else:
        check = checker.check_ipaddr(
                _('Destination Address'),
                obj.input.destination,
                CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'dport'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Destination Port'))
    else:
        if obj.input.protocol == 'tcp' or obj.input.protocol == 'udp':
            check = checker.check_number(
                    _('Destination Port'),
                    obj.input.dport,
                    CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    min = PORT_MIN_NUMBER,
                    max = PORT_MAX_NUMBER,
                    ) and check

    if not is_param(obj.input, 'inif'):
        check = False
        checker.add_error(_('"%s" is required.') % _('In Interface'))
    else:
        check = checker.check_firewall_if(
                _('In Interface'),
                obj.input.inif,
                CHECK_EXIST,
                ) and check

    if not is_param(obj.input, 'outif'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Out Interface'))
    else:
        check = checker.check_firewall_if(
                _('Out Interface'),
                obj.input.outif,
                CHECK_EXIST,
                ) and check
    
    obj.view.alert = checker.errors

    return check

class HostBy1FirewallRule(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        kit = KaresansuiIpTables()

        if os.path.exists(kit.firewall_xml_file) is False:
            self.view.have_config = False

        else:
            kit.firewall_xml = kit.read_firewall_xml()
            self.view.base_policy = 'ACCEPT'
            self.view.rules = kit.get_rules()
            self.view.have_config = True

        return True

urls = (
    '/host/(\d+)/firewall/rule/?(\.part)$', HostBy1FirewallRule,
    )

########NEW FILE########
__FILENAME__ = hostby1firewallruleby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import time
import re

import web

from karesansui.gadget.hostby1firewallrule import validates_rule
from karesansui.lib.rest import Rest, auth
from karesansui.lib.firewall.iptables import KaresansuiIpTables
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_CHAR, \
     CHECK_MIN, CHECK_MAX
from karesansui.lib.const import \
     ID_MIN_LENGTH, ID_MAX_LENGTH


from karesansui.lib.utils import get_ifconfig_info

def validates_param_id(obj, rule_id):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    check = checker.check_number(
            _('Firewall Rule ID'),
            rule_id,
            CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
            min = ID_MIN_LENGTH,
            max = ID_MAX_LENGTH,
        ) and check

    obj.view.alert = checker.errors

    return check
     
class HostBy1FirewallRuleby1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        rule_id = param[1]
        if not validates_param_id(self, rule_id):
            return web.notfound(self.view.alert)

        kit = KaresansuiIpTables()
        kit.firewall_xml = kit.read_firewall_xml()

        rules = kit.get_rules()
        cnt = 1
        for rule in rules:
            if cnt == int(rule_id):
                self.view.rule = rule
                break
            cnt = cnt + 1

        if self.is_mode_input():
            self.view.targets = kit.basic_targets['filter']
            self.view.protocols = kit.chain_protos
            self.view.netinfo = get_ifconfig_info()
            devtype_regexs = {
                "phy":"^(lo|eth)",
                "vir":"^(xenbr|virbr|vif|veth)",
                }
            devtype_phy_regex = re.compile(r"%s" % devtype_regexs['phy'])
            devtype_vir_regex = re.compile(r"%s" % devtype_regexs['vir'])

            devs = {}
            devs['phy'] = []
            devs['vir'] = []
            devs['oth'] = []
            cidrs = []
            ips = []
            for dev,dev_info in get_ifconfig_info().iteritems():
                try:
                    if devtype_phy_regex.match(dev):
                        devs['phy'].append(dev)
                    elif devtype_vir_regex.match(dev):
                        devs['vir'].append(dev)
                    else:
                        devs['oth'].append(dev)
                    if dev_info['ipaddr'] is not None:
                        if not dev_info['ipaddr'] in ips:
                            ips.append(dev_info['ipaddr'])
                    if dev_info['cidr'] is not None:
                        if not dev_info['cidr'] in cidrs:
                            cidrs.append(dev_info['cidr'])
                except:
                    pass
            devs['phy'].sort()
            devs['vir'].sort()
            devs['oth'].sort()
            self.view.devs = [{'Physical' : devs['phy']},
                              {'Virtual' : devs['vir']},
                              {'Other' : devs['oth']},
                              ]
            self.view.cidrs = cidrs
            self.view.ips = ips
            return True
        else:
            return web.nomethod()

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        
        if not validates_rule(self):
            return web.badrequest(self.view.alert)

        rule_id = int(param[1])
        if not validates_param_id(self, rule_id):
            return web.notfound(self.view.alert)


        self.view.host_id = host_id

        kit = KaresansuiIpTables()
        kit.firewall_xml = kit.read_firewall_xml()

        rule_info = {"target" : self.input.target,
                     "protocol" : self.input.protocol,
                     "source" : self.input.source,
                     "destination" : self.input.destination,
                     "source-port" : self.input.sport,
                     "destination-port" : self.input.dport,
                     "in-interface" : self.input.inif,
                     "out-interface" : self.input.outif,
                     }
        rule_id = kit.modify_rule(rule_id,rule_info)
        kit.write_firewall_xml()
        
        return web.seeother("%s?mode=input" % web.ctx.path)


    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        rule_id = param[1]
        if not validates_param_id(self, rule_id):
            return web.notfound(self.view.alert)


        new_rules = []

        kit = KaresansuiIpTables()
        kit.firewall_xml = kit.read_firewall_xml()
        kit.delete_rule(int(rule_id))
        kit.write_firewall_xml()
        return web.seeother("%s.part" % web.ctx.path[:web.ctx.path.rfind('/')])

urls = (
    '/host/(\d+)/firewall/rule/(\d+)/?(\.part)$', HostBy1FirewallRuleby1,
    )

########NEW FILE########
__FILENAME__ = hostby1firewallstatus
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import simplejson as json
import web

import karesansui
from karesansui.lib.const import FIREWALL_COMMAND_SAVE_FIREWALL, \
                                 FIREWALL_COMMAND_RESTORE_FIREWALL
from karesansui.lib.rest import Rest, auth
from karesansui.lib.firewall.iptables import KaresansuiIpTables
from karesansui.lib.utils import is_param
from karesansui.lib.checker import \
    Checker, CHECK_EMPTY, CHECK_VALID

from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jg_save
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

FIREWALL_ACTION_INIT  = 0
FIREWALL_ACTION_START = 1<<0
FIREWALL_ACTION_STOP  = 1<<1

FIREWALL_STATUS = {
    "READ":0, 
    "START":1, 
    "STOP":2, 
    "RESTART":3
}

# lib public
def firewall_restore(obj, model, action='',options={}):
    if action != "":
        options['action'] = action

    if action == "restart":
        action_msg = "Restart Firewall"
    elif action == "start":
        action_msg = "Start Firewall"
    elif action == "stop":
        action_msg = "Stop Firewall"
    else:
        action_msg = "Restore Firewall"

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], FIREWALL_COMMAND_RESTORE_FIREWALL), options)
        
    _jobgroup = JobGroup(action_msg, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % action_msg, 0, _cmd))
    
    _machine2jobgroup = m2j_new(machine=model,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

    return True

def firewall_save(obj, model, options={}):

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], FIREWALL_COMMAND_SAVE_FIREWALL), options)

    cmdname = u"Initialize Firewall"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % cmdname, 0, _cmd))
    
    _machine2jobgroup = m2j_new(machine=model,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

    return True

def validates_fw_status(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'status'):
        check = checker.check_status(
                _('Status'),
                obj.input.status,
                CHECK_EMPTY | CHECK_VALID,
                FIREWALL_STATUS.values()
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Status'))

    obj.view.alert = checker.errors

    return check

class HostBy1FirewallStatus(Rest):
    
    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        ステータス更新
         - param
           - read = 0
           - start = 1
           - stop = 2
           - restart = 3
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_fw_status(self):
            return web.badrequest(self.view.alert)

        status = int(self.input.status)

        kit = KaresansuiIpTables()

        model = findbyhost1(self.orm, host_id)

        ret = False
        if status == FIREWALL_ACTION_INIT:
            ret = firewall_save(self, model)
        elif status & FIREWALL_ACTION_STOP and status & FIREWALL_ACTION_START:
            kit.firewall_xml = kit.read_firewall_xml()
            ret = firewall_restore(self, model, 'restart')

        elif status & FIREWALL_ACTION_STOP:
            kit.firewall_xml = kit.read_firewall_xml()
            ret = firewall_restore(self, model, 'stop')

        elif status & FIREWALL_ACTION_START:
            kit.firewall_xml = kit.read_firewall_xml()
            ret = firewall_restore(self, model, 'start')

        if ret is True:
            return web.accepted(url=web.ctx.path)
        else:
            return False

urls = (
    '/host/(\d+)/firewall/status/?(\.part)$', HostBy1FirewallStatus,
    )

########NEW FILE########
__FILENAME__ = hostby1iptables
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import time
import web

from karesansui.lib.rest import Rest, auth
from karesansui.db.access.machine import findbyhost1
from karesansui.lib.utils import get_ifconfig_info, dict_ksort, is_param
from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.iptables import iptables_lint_contents

from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID

def validates_iptables_save(obj, host):
    checker = Checker() 
    check = True

    _ = obj._
    checker.errors = []
    
    if not is_param(obj.input, 'iptables_save'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Rule'))
    else:

        check = checker.check_string(
                _('Rule'),
                obj.input.iptables_save,
                CHECK_EMPTY | CHECK_VALID,
                '[^-a-zA-Z0-9_\,\.\@\$\%\!\#\*\[\]\:\/\r\n\+ ]+',
                None,
                None,
            ) and check

        if check is True:
            ret = iptables_lint_contents(obj.input.iptables_save, obj, host)
            if str(ret) != "":
                check = False
                checker.add_error(ret)
                """
                m = re.match(".* line (?P<line>[0-9]+).*",str(ret))
                if m:
                    checker.add_error("LINE:"+m.group("line"))
                """

    obj.view.alert = checker.errors

    return check


class HostBy1Iptables(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        self.view.current = get_ifconfig_info()

        modules = ["iptables"]

        host = findbyhost1(self.orm, host_id)
        dop = read_conf(modules, self, host)
        if dop is False:
            return web.internalerror('Internal Server Error. (Timeout)')

        config = dop.get("iptables",["config"])
        status = dop.get("iptables",["status"])
        lint   = dop.get("iptables",["lint"])

        policies = {}
        for _aline in status:
            m = re.match("\*(?P<table>[a-z]+)",_aline.rstrip())
            if m:
                table = m.group("table")
                policies[table] = {}
            else:
                m = re.match(":(?P<chain>[A-Z]+) +(?P<policy>[A-Z]+)",_aline.rstrip())
                if m:
                    chain  = m.group("chain")
                    policy = m.group("policy")
                    policies[table][chain] = policy

        self.view.config   = "\n".join(config)
        self.view.status   = "\n".join(status)
        self.view.lint     = lint
        self.view.policies = policies
        self.view.result_js  = ""

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        host = findbyhost1(self.orm, host_id)
        if not validates_iptables_save(self, host):
            return web.badrequest(self.view.alert)

        from karesansui.lib.dict_op import DictOp
        dop = DictOp()
        dop.addconf("iptables", {})
        dop.set("iptables",["config"],self.input.iptables_save.split("\r\n"))
        retval = write_conf(dop, self, host)
        if retval is False:
            return web.internalerror('Internal Server Error. (Adding Task)')

        return web.accepted(url=web.ctx.path)


urls = (
    '/host/(\d+)/iptables/?(\.part)$', HostBy1Iptables,
    )

########NEW FILE########
__FILENAME__ = hostby1iptablesstatus
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import simplejson as json
import web

import karesansui
from karesansui.lib.const import IPTABLES_COMMAND_CONTROL
from karesansui.lib.rest import Rest, auth
from karesansui.lib.utils import is_param
from karesansui.lib.checker import \
    Checker, CHECK_EMPTY, CHECK_VALID

from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jg_save
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

IPTABLES_ACTION_START = 1<<0
IPTABLES_ACTION_STOP  = 1<<1

IPTABLES_STATUS = {
    "START"   :1, 
    "STOP"    :2, 
    "RESTART" :3
}

# lib public
def iptables_control(obj, model, action='',options={}):
    if action != "":
        options['action'] = action

    if action == "restart":
        action_msg = "Restart iptables"
    elif action == "start":
        action_msg = "Start iptables"
        msg = "Start iptables"
    elif action == "stop":
        action_msg = "Stop iptables"

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], IPTABLES_COMMAND_CONTROL), options)
        
    _jobgroup = JobGroup(action_msg, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % action_msg, 0, _cmd))
    
    _machine2jobgroup = m2j_new(machine=model,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

    return True

def validates_iptables_status(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'status'):
        check = checker.check_status(
                _('Status'),
                obj.input.status,
                CHECK_EMPTY | CHECK_VALID,
                IPTABLES_STATUS.values()
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Status'))

    obj.view.alert = checker.errors

    return check

class HostBy1IptablesStatus(Rest):
    
    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        ステータス更新
         - param
           - read = 0
           - start = 1
           - stop = 2
           - restart = 3
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_iptables_status(self):
            return web.badrequest(self.view.alert)

        status = int(self.input.status)

        model = findbyhost1(self.orm, host_id)

        ret = False
        if status & IPTABLES_ACTION_STOP and status & IPTABLES_ACTION_START:
            ret = iptables_control(self, model, 'restart')

        elif status & IPTABLES_ACTION_STOP:
            ret = iptables_control(self, model, 'stop')

        elif status & IPTABLES_ACTION_START:
            ret = iptables_control(self, model, 'start')

        if ret is True:
            return web.accepted(url=web.ctx.path)
        else:
            return False

urls = (
    '/host/(\d+)/iptables/status/?(\.part)$', HostBy1IptablesStatus,
    )

########NEW FILE########
__FILENAME__ = hostby1job
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.search import validates_jobsearch
from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.utils import str2datetime, is_param, is_empty
from karesansui.lib.const import JOB_LIST_RANGE, DEFAULT_LANGS,\
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH,\
    USER_MIN_LENGTH, USER_MAX_LENGTH,\
    ID_MIN_LENGTH, ID_MAX_LENGTH, DEFAULT_LANGS, \
    MACHINE_HYPERVISOR
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_LENGTH, CHECK_DICTVALUE, CHECK_VALID, CHECK_ONLYSPACE,\
    CHECK_MIN, CHECK_MAX
from karesansui.db.access.user import findbyname_BM
from karesansui.db.access._2pysilhouette import jg_findbyalltype
from karesansui.db.access.machine_machine2jobgroup import findbyhost as m2mj_findbyhost, \
    findbyall as m2mj_findbyall
from karesansui.db.model._2pysilhouette import \
     JOBGROUP_STATUS, JOBGROUP_TYPE

class HostBy1Job(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        
        (check, edit) = validates_jobsearch(self)
        if check is False:
            return web.badrequest(self.view.alert)

        if edit is True:
            users = findbyname_BM(self.orm, self.input.user)
            users_id = []
            for user in users:
                users_id.append(user.id)

            machine_name = self.input.name.strip()
            
            if is_empty(machine_name):
                machine_name = None

            if is_empty(self.input.start):
                start = None
            else:
                start = str2datetime(self.input.start,
                                     DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])

            if is_empty(self.input.end):
                end = None
            else:
                end = str2datetime(self.input.end,
                                   DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0],True)

            m_m2js = m2mj_findbyall(self.orm,
                            machine_name,
                            start,
                            end,
                            users_id,
                            True
                           )
            if not m_m2js:
                self.logger.debug("Search m_m2js failed. "
                                  "Did not exist m_m2js that in accord with these query. "
                                  "name %s, user_id %s, start %s, end %s" % (machine_name, users_id, start, end))
                return web.nocontent()

            self.view.m_m2js = m_m2js
            self.view.name = self.input.name
            self.view.user = self.input.user
            self.view.status = self.input.status
            self.view.start = self.input.start
            self.view.end = self.input.end
            
            jobgroup_ids = []
            for m_m2j in m_m2js:
                jobgroup_ids.append(m_m2j[1].jobgroup_id)

            jobgroup_status = self.input.status
            if is_empty(jobgroup_status):
                jobgroup_status = None

            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                                         jobgroup_ids, jobgroup_status, desc=True)
            if not jobgroups:
                self.logger.debug("Search jobgroups failed. "
                                  "Did not exist jobgroups that in accord with these query. "
                                  "jobgroup_ids %s, jobgroup_status %s" % (jobgroup_ids, jobgroup_status))
                return web.nocontent()
        else:
            m_m2js = m2mj_findbyhost(self.orm, host_id)

            self.view.m_m2js = m_m2js
            self.view.name   = ''
            self.view.user   = ''
            self.view.status = ''
            self.view.start  = ''
            self.view.end    = ''

            jobgroup_ids = []
            for m_m2j in m_m2js:
                 jobgroup_ids.append(m_m2j[1].jobgroup_id)

            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                                         jobgroup_ids, desc=True)

        self.view.JOBGROUP_STATUS = JOBGROUP_STATUS
        self.view.HYPERVISOR = MACHINE_HYPERVISOR

        if self.input.has_key('p') is True:
            if validates_page(self) is True:
                start = int(self.input.p)
            else:
                return web.badrequest(self.view.alert)
        else:
            start = 0

        self.view.date_format = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][1]
        self.view.pager = Pager(jobgroups, start, JOB_LIST_RANGE)
        return True

urls = (
    '/host/(\d+)/job/?(\.part)$', HostBy1Job,
    )

########NEW FILE########
__FILENAME__ = hostby1log
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import os
import web
import socket

from karesansui.lib.rest import Rest, auth
from karesansui.lib.log.config import LogViewConfigParam
from karesansui.lib.const import LOG_VIEW_XML_FILE

class HostBy1Log(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        self.view.host_id = host_id

        config = LogViewConfigParam(LOG_VIEW_XML_FILE)
        config.load_xml_config()
        self.view.apps = config.get_applications()
        return True

urls = ('/host/(\d+)/log?(\.part)$', HostBy1Log,)

########NEW FILE########
__FILENAME__ = hostby1logby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import os
import web
import socket

from karesansui.lib.rest import Rest, auth
from karesansui.lib.log.config import LogViewConfigParam
from karesansui.lib.const import LOG_VIEW_XML_FILE,DEFAULT_LANGS
from karesansui.lib.utils import json_dumps, is_param, str2datetime, create_epochsec
from karesansui.lib.log.viewer import read_all_log

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID

def validates_log(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 's'):
        check = checker.check_datetime_string(_('Start Date'),
                                              obj.input.s,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'e'):
        check = checker.check_datetime_string(_('End Date'),
                                              obj.input.e,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'st'):
        check = checker.check_time_string(_('Start Time'),
                                          obj.input.st,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    if is_param(obj.input, 'et'):
        check = checker.check_time_string(_('End Time'),
                                          obj.input.et,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1LogBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        self.__template__.dir = "hostby1logby1appby1"
        self.__template__.file = "hostby1logby1appby1"
        self.__template__.media = "part"

        appname = param[1]
        log_config = None

        if not validates_log(self):
            self.logger.debug("Get log failed. Did not validate.")
            return web.badrequest(self.view.alert)

        config = LogViewConfigParam(LOG_VIEW_XML_FILE)
        config.load_xml_config()
        app = config.findby1application(appname)

        lines = []
        param_value = {}
        if self.input.has_key("k"):
            param_value["k"] = self.input.k
        else:
            param_value["k"] = ""

        start_day = str2datetime(self.input.s,
                                 DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
        end_day = str2datetime(self.input.e,
                                 DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])

        (start_hour, start_minute) = self.input.st.split(':', 2)
        (end_hour, end_minute) = self.input.et.split(':', 2)

        start_time = create_epochsec(start_day.year,
                                     start_day.month,
                                     start_day.day,
                                     int(start_hour),
                                     int(start_minute),
                                     )

        end_time = create_epochsec(end_day.year,
                                   end_day.month,
                                   end_day.day,
                                   int(end_hour),
                                   int(end_minute),
                                   )
        if int(start_time) > int(end_time):
            self.logger.error("Getting reports failed. Start time > end time.")
            return web.badrequest(_('Getting reports failed. Start time > end time.'))

        param_value["start_datetime"] = "%s %s" % (start_day.strftime("%Y/%m/%d"), self.input.st)
        param_value["end_datetime"] = "%s %s" % (end_day.strftime("%Y/%m/%d"), self.input.et)

        lines = read_all_log(app,
                             int(self.input.m),
                             param_value["start_datetime"],
                             param_value["end_datetime"],
                             param_value["k"])
        self.view.log_json = json_dumps(lines)
        return True

urls = ('/host/(\d+)/log/([0-9a-zA-Z\-]+)/$', HostBy1LogBy1,)

########NEW FILE########
__FILENAME__ = hostby1logby1appby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import os
import web
import socket

from karesansui.lib.rest import Rest, auth
from karesansui.lib.log.config import LogViewConfigParam
from karesansui.lib.const import LOG_VIEW_XML_FILE, DEFAULT_LANGS
from karesansui.lib.utils import json_dumps, is_param, str2datetime, create_epochsec
from karesansui.lib.log.viewer import read_log, read_log_with_rotate

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID

def validates_log(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 's'):
        check = checker.check_datetime_string(_('Start Date'),
                                              obj.input.s,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'e'):
        check = checker.check_datetime_string(_('End Date'),
                                              obj.input.e,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'st'):
        check = checker.check_time_string(_('Start Time'),
                                          obj.input.st,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    if is_param(obj.input, 'et'):
        check = checker.check_time_string(_('End Time'),
                                          obj.input.et,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1LogBy1AppBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        self.__template__.dir = "hostby1logby1appby1"
        self.__template__.file = "hostby1logby1appby1"
        self.__template__.media = "part"

        appname = param[1]
        filename = param[2]
        log_config = None

        if not validates_log(self):
            self.logger.debug("Get log failed. Did not validate.")
            return web.badrequest(self.view.alert)

        config = LogViewConfigParam(LOG_VIEW_XML_FILE)
        config.load_xml_config()
        app = config.findby1application(appname)

        for log in app['logs']:
            if log['filename'] == filename:
                log_config = log

        lines = []
        param_value = {}

        if is_param(self.input, 'k'):
            param_value["k"] = self.input.k
        else:
            param_value["k"] = ""

        start_day = str2datetime(self.input.s,
                                 DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
        end_day = str2datetime(self.input.e,
                                 DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])

        (start_hour, start_minute) = self.input.st.split(':', 2)
        (end_hour, end_minute) = self.input.et.split(':', 2)

        start_time = create_epochsec(start_day.year,
                                     start_day.month,
                                     start_day.day,
                                     int(start_hour),
                                     int(start_minute),
                                     )

        end_time = create_epochsec(end_day.year,
                                   end_day.month,
                                   end_day.day,
                                   int(end_hour),
                                   int(end_minute),
                                   )
        if int(start_time) > int(end_time):
            self.logger.error("Getting reports failed. Start time > end time.")
            return web.badrequest(_('Getting reports failed. Start time > end time.'))

        param_value["start_datetime"] = "%s %s" % (start_day.strftime("%Y/%m/%d"), self.input.st)
        param_value["end_datetime"] = "%s %s" % (end_day.strftime("%Y/%m/%d"), self.input.et)

        if log_config['view_rotatelog']:
            try:
                lines = read_log_with_rotate(filename,
                                             self.input.m,
                                             log_config,
                                             param_value["start_datetime"],
                                             param_value["end_datetime"],
                                             param_value["k"])
                if lines is False:
                    return web.notfound()
            except Exception, e:
                self.logger.warning("log file open error: %s" % e)
        else:
            if log_config['dir'] is None:
                log_dir = "/var/log"
            else:
                if log_config['dir'][0] == "/":
                    log_dir = log_config['dir']
                else:
                    log_dir = "/var/log/%s" % log_config['dir']
            try:
                lines = read_log("%s/%s" % (log_dir, log_config['filename']),
                                 self.input.m,
                                 log_config,
                                 param_value["start_datetime"],
                                 param_value["end_datetime"],
                                 param_value["k"])
                if lines is False:
                    return web.notfound()
            except Exception, e:
                self.logger.warning("log file open error: %s" % e)

        self.view.log_json = json_dumps(lines)
        return True

urls = ('/host/(\d+)/log/([0-9a-zA-Z\-]+)/([0-9a-zA-Z\-\.]+)$', HostBy1LogBy1AppBy1,)

########NEW FILE########
__FILENAME__ = hostby1network
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import VIRT_COMMAND_CREATE_NETWORK
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jobgroup_findbyuniqkey
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE, \
    CHECK_UNIQUE

from karesansui.lib.utils import is_param, is_empty, available_virt_uris

def validates_network(obj, network_name=None):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'name'):
        check = False
        checker.add_error(_('Specify network name.'))
    else:
        check = checker.check_network_name(
            _('Network Name'),
            obj.input.name,
            CHECK_EMPTY | CHECK_VALID,
            ) and check

    if not is_param(obj.input, 'cidr'):
        check = False
        checker.add_error(_('Specify bridge IP address for the network.'))
    else:
        check = checker.check_ipaddr(
                _('Bridge IP Address/Netmask'),
                obj.input.cidr,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'bridge'):
        check = False
        checker.add_error(_('Specify bridge name to create for the network.'))
    else:
        check = checker.check_netdev_name(
                _('Bridge Device Name'),
                obj.input.bridge,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    A = is_param(obj.input, 'dhcp_start')
    B = is_param(obj.input, 'dhcp_end')
    #if not ( ((not A) and (not B)) or (A and B)):
    if not (A and B):
        check = False
        checker.add_error(_('Specify both %s and %s') % (_('DHCP Start Address'), _('DHCP End Address')))

    if is_param(obj.input, 'dhcp_start'):
        check = checker.check_ipaddr(
                _('DHCP Start Address'),
                obj.input.dhcp_start,
                CHECK_EMPTY | CHECK_ONLYSPACE | CHECK_VALID,
                ) and check

    if is_param(obj.input, 'dhcp_end'):
        check = checker.check_ipaddr(
                _('DHCP End Address'),
                obj.input.dhcp_end,
                CHECK_EMPTY | CHECK_ONLYSPACE | CHECK_VALID,
                ) and check

    check = checker.check_if_ips_are_in_network(
                            [ _('DHCP Start Address'), _('DHCP End Address'), _('Bridge IP Address/Netmask')],
                            [obj.input.dhcp_start, obj.input.dhcp_end],
                            obj.input.cidr,
                            CHECK_VALID | CHECK_UNIQUE) and check

    check = checker.check_ip_range(
                            [ _('DHCP Start Address'), _('DHCP End Address'), _('Bridge IP Address/Netmask')],
                            [obj.input.dhcp_start, obj.input.dhcp_end, obj.input.cidr],
                            CHECK_VALID) and check

    check = checker.check_virt_network_address_conflict(
                            _('Bridge IP Address/Netmask'),
                            obj.input.cidr,
                            [network_name],   # names to ignore
                            CHECK_VALID) and check

    if is_param(obj.input, 'forward_mode'):
        check = checker.check_forward_mode(
                _('Forward Mode'),
                obj.input.forward_mode,
                CHECK_VALID,
                ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1Network(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)

        uris = available_virt_uris()
        if model.attribute == 0 and model.hypervisor == 1:
            uri = uris["XEN"]
        elif model.attribute == 0 and model.hypervisor == 2:
            uri = uris["KVM"]
        else:
            uri = None

        # if input mode then return empty form
        if self.is_mode_input():
            self.view.host_id = host_id
            self.view.network = dict(name='', cidr='',
                                     dhcp_start='', dhcp_end='',
                                     forward_dev='', forward_mode='',
                                     bridge='')
            return True
        else:
            kvc = KaresansuiVirtConnection(uri)
            try:
                labelfunc = (('active', kvc.list_active_network),
                             ('inactive', kvc.list_inactive_network),
                             )
                # networks = {'active': [], 'inactive': []}
                networks = []
                for label, func in labelfunc:
                    for name in func():
                        try:
                            network = kvc.search_kvn_networks(name)[0] # throws KaresansuiVirtException
                            info = network.get_info()
                            # networks[label].append(info)
                            if info['is_active']:
                                info['activity'] = 'Active'
                            else:
                                info['activity'] = 'Inactive'
                            networks.append(info)
                        except KaresansuiVirtException, e:
                            # network not found
                            pass
            finally:
                kvc.close()

            self.view.networks = networks
            return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        model = findbyhost1(self.orm, host_id)

        uris = available_virt_uris()
        if model.attribute == 0 and model.hypervisor == 1:
            uri = uris["XEN"]
        elif model.attribute == 0 and model.hypervisor == 2:
            uri = uris["KVM"]
        else:
            uri = None

        if not validates_network(self):
            self.logger.debug("Network creation failed. Did not validate.")
            return web.badrequest(self.view.alert)

        name       = self.input.name
        cidr       = self.input.cidr
        dhcp_start = self.input.dhcp_start
        dhcp_end   = self.input.dhcp_end
        bridge     = self.input.bridge

        # We support only 'nat' for forward-mode.
        forward_mode = ''
        if is_param(self.input, 'forward_mode'):
            if self.input.forward_mode == 'nat':
                forward_mode = 'nat'

        try:
            autostart = self.input.autostart
        except:
            autostart = "no"

        # Check if the name is available (not already used).
        kvc = KaresansuiVirtConnection(uri)
        try:
            try:
                kvc.search_kvn_networks(name)
                self.logger.debug("Network name '%s' already used." % name)
                url = '%s/%s/%s.part' % (web.ctx.home, web.ctx.path, name)
                self.logger.debug("Returning url %s as Location." % url)
                return web.conflict(url)
            except KaresansuiVirtException, e:
                # OK
                pass
        finally:
            kvc.close()

        # spin off create job
        options = {'dhcp-start': dhcp_start,
                   'dhcp-end'  : dhcp_end,
                   'bridge-name'    : bridge,
                   'forward-mode'   : forward_mode,
                   'autostart' : autostart,
                  }

        self.logger.debug('spinning off network_create_job name=%s, cidr=%s, options=%s' % (name, cidr, options))
        host = findbyhost1(self.orm, host_id)
        #network_create_job(self, name, cidr, host, options)

        options['name'] = name
        options['cidr'] = cidr

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_CREATE_NETWORK), options)

        # Job Registration
        _jobgroup = JobGroup('Create Network: %s' % name, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('Create Network', 0, _cmd))
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        self.logger.debug('(Create network) Job group id==%s', _jobgroup.id)
        url = '%s/job/%s.part' % (web.ctx.home, _jobgroup.id)
        self.logger.debug('Returning Location: %s' % url)

        return web.accepted()

urls = (
    '/host/(\d+)/network[/]?(\.html|\.part|\.json)?$', HostBy1Network,
    )


########NEW FILE########
__FILENAME__ = hostby1networkby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import VIRT_COMMAND_DELETE_NETWORK, VIRT_COMMAND_UPDATE_NETWORK
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jobgroup_findbyuniqkey
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command
from karesansui.db.model._2pysilhouette import Job, JobGroup

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE, \
    CHECK_UNIQUE

from karesansui.lib.utils import is_param, is_empty, available_virt_uris

def validates_network(obj, network_name=None):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not network_name:
        check = False
        checker.add_error(_('Specify network name.'))

    if not is_param(obj.input, 'cidr'):
        check = False
        checker.add_error(_('Specify bridge IP address for the network.'))
    else:
        check = checker.check_ipaddr(
                _('Bridge IP Address/Netmask'),
                obj.input.cidr,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'bridge'):
        check = False
        checker.add_error(_('Specify bridge name to create for the network.'))
    else:
        check = checker.check_netdev_name(
                _('Bridge Device Name'),
                obj.input.bridge,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    A = is_param(obj.input, 'dhcp_start')
    B = is_param(obj.input, 'dhcp_end')
    #if not ( ((not A) and (not B)) or (A and B)):
    if not (A and B):
        check = False
        checker.add_error(_('Specify both %s and %s') % (_('DHCP Start Address'), _('DHCP End Address')))

    if is_param(obj.input, 'dhcp_start'):
        check = checker.check_ipaddr(
                _('DHCP Start Address'),
                obj.input.dhcp_start,
                CHECK_EMPTY | CHECK_ONLYSPACE | CHECK_VALID,
                ) and check

    if is_param(obj.input, 'dhcp_end'):
        check = checker.check_ipaddr(
                _('DHCP End Address'),
                obj.input.dhcp_end,
                CHECK_EMPTY | CHECK_ONLYSPACE | CHECK_VALID,
                ) and check

    check = checker.check_if_ips_are_in_network(
                            [ _('DHCP Start Address'), _('DHCP End Address'), _('Bridge IP Address/Netmask')],
                            [obj.input.dhcp_start, obj.input.dhcp_end],
                            obj.input.cidr,
                            CHECK_VALID | CHECK_UNIQUE) and check

    check = checker.check_ip_range(
                            [ _('DHCP Start Address'), _('DHCP End Address'), _('Bridge IP Address/Netmask')],
                            [obj.input.dhcp_start, obj.input.dhcp_end, obj.input.cidr],
                            CHECK_VALID) and check

    check = checker.check_virt_network_address_conflict(
                            _('Bridge IP Address/Netmask'),
                            obj.input.cidr,
                            [network_name],   # names to ignore
                            CHECK_VALID) and check

    if is_param(obj.input, 'forward_mode'):
        check = checker.check_forward_mode(
                _('Forward Mode'),
                obj.input.forward_mode,
                CHECK_VALID,
                ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        network_name = param[1]
        if not (network_name and host_id):
            return web.badrequest()

        kvc = KaresansuiVirtConnection()
        try:
            try:
                network = kvc.search_kvn_networks(network_name)[0] # throws KaresansuiVirtException
                info = network.get_info()
            except KaresansuiVirtException, e:
                # network not found
                self.logger.debug("Network not found. name=%s" % network_name)
                return web.notfound()
        finally:
            kvc.close()

        cidr = '%s/%s' % (info['ip']['address'], info['ip']['netmask'])
        network = dict(name=info['name'],
                       cidr=cidr,
                       dhcp_start=info['dhcp']['start'],
                       dhcp_end=info['dhcp']['end'],
                       forward_dev=info['forward']['dev'],
                       forward_mode=info['forward']['mode'],
                       bridge=info['bridge']['name'],
                       )
        self.view.info = info
        self.view.network = network
        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        network_name = param[1]
        if not network_name:
            self.logger.debug("Network update failed. Network not found.")
            return web.notfound("Network not found.")

        if not validates_network(self, network_name=network_name):
            self.logger.debug("Network update failed. Did not validate.")
            return web.badrequest(self.view.alert)

        cidr       = self.input.cidr
        dhcp_start = self.input.dhcp_start
        dhcp_end   = self.input.dhcp_end
        bridge     = self.input.bridge
        forward_mode = getattr(self.input, 'forward_mode', '')

        try:
            autostart = self.input.autostart
        except:
            autostart = "no"

        #
        # spin off update job
        #
        options = {'name' : network_name,
                   'cidr': cidr,
                   'dhcp-start': dhcp_start,
                   'dhcp-end' : dhcp_end,
                   'bridge-name' : bridge,
                   'forward-mode' : forward_mode,
                   'autostart' : autostart,
                   }

        self.logger.debug('spinning off network_update_job options=%s' % (options))

        host = findbyhost1(self.orm, host_id)

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_UPDATE_NETWORK), options)

        # Job Registration
        _jobgroup = JobGroup('Update network: %s' % network_name, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('Update network', 0, _cmd))

        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        self.logger.debug('(Update network) Job group id==%s', _jobgroup.id)
        url = '%s/job/%s.part' % (web.ctx.home, _jobgroup.id)
        self.logger.debug('Returning Location: %s' % url)

        return web.accepted(url=url)

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        network_name = param[1]
        if not network_name:
            self.logger.debug("Network delete failed. Network not found.")
            return web.notfound("Network not found.")

        if network_name == 'default':
            self.logger.debug('Network delete failed. Target network is "default".')
            return web.badrequest('Target network "default" can not deleted.')

        host = findbyhost1(self.orm, host_id)

        options = {}
        options['name'] = network_name
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_NETWORK), options)

        # Job Registration
        _jobgroup = JobGroup('Delete network: %s' % network_name, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('Delete network', 0, _cmd))

        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        self.logger.debug('(Delete network) Job group id==%s', _jobgroup.id)
        url = '%s/job/%s.part' % (web.ctx.home, _jobgroup.id)
        self.logger.debug('Returning Location: %s' % url)

        return web.accepted()

urls = (
    '/host/(\d+)/network/([^\./]+)[/]?(\.html|\.part|\.json)?$', HostBy1NetworkBy1,
    )


########NEW FILE########
__FILENAME__ = hostby1networkby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection
from karesansui.lib.utils import json_dumps, is_param
from karesansui.lib.checker import \
    Checker, CHECK_EMPTY, CHECK_VALID

from pysilhouette.command import dict2command

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.model._2pysilhouette import Job, JobGroup

NETWORK_ACTIVE = 1
NETWORK_INACTIVE = 0

def validates_nw_status(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'status'):
        status = int(obj.input.status)
        check = checker.check_status(
                _('Status'),
                status,
                CHECK_EMPTY | CHECK_VALID,
                [NETWORK_ACTIVE, NETWORK_INACTIVE]
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Status'))

    obj.view.alert = checker.errors

    return check

class HostBy1NetworkBy1Status(Rest):
    @auth
    def _GET(self, *param, **params):
        """<comment-ja>
        ネットワークがアクティブかどうかのステータス
         - inactive = 0
         - active = 1
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        # TODO valid
        network_name =param[1]
        if not network_name:
            return web.badrequest()

        kvc = KaresansuiVirtConnection()
        try:
            kvn = kvc.search_kvn_networks(network_name)[0]
            status = NETWORK_INACTIVE
            if kvn.is_active():
                status = NETWORK_ACTIVE

            if self.__template__["media"] == 'json':
                self.view.status = json_dumps(status)
            else:
                self.view.status = status

            self.__template__.dir = 'hostby1networkby1'
        finally:
            kvc.close()

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        # TODO valid
        network_name = param[1]
        if not network_name:
            return web.notfound()

        if validates_nw_status(self) is False:
            return web.badrequest(self.view.alert)

        status = int(self.input.status)

        kvc = KaresansuiVirtConnection()
        try:
            kvn = kvc.search_kvn_networks(network_name)[0]
            if status == NETWORK_INACTIVE:
                # Stop network
                network_start_stop_job(self, host_id, network_name, 'stop')
                return web.accepted("/host/%s/network/%s.%s" % (host_id, network_name, self.__template__['media']))
            elif status == NETWORK_ACTIVE:
                # Start network
                network_start_stop_job(self, host_id, network_name, 'start')
                return web.accepted("/host/%s/network/%s.%s" % (host_id, network_name, self.__template__['media']))
            else:
                return web.badrequest()
        finally:
            kvc.close()

def network_start_stop_job(obj, host_id, network_name, action):
    """
    Register start/stop network job into pysilhouette
    @param obj: Rest object
    @param network_name: Name of network to start or stop
    @type network_name: string
    @param action: 'start' or 'stop'
    @type action: string
    """

    if not network_name:
        raise KaresansuiException

    if (karesansui.sheconf.has_key('env.uniqkey') is False) \
           or (karesansui.sheconf['env.uniqkey'].strip('') == ''):
        raise KaresansuiException

    if not (action == 'start' or action == 'stop'):
        raise KaresansuiException

    host = findbyhost1(obj.orm, host_id)

    _cmd = None
    _jobgroup = None
    if action == 'start':
        cmdname = ["Start Network", "start network"]
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], 'restart_network.py'),
            dict(name=network_name, force=None))
    else:
        cmdname = ["Stop Network", "stop network"]
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], 'stop_network.py'),
            dict(name=network_name))

    # Job Register
    _jobgroup = JobGroup(cmdname[0], karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job('%s command' % cmdname[1], 0, _cmd))

    _machine2jobgroup = m2j_new(machine=host,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    # INSERT
    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )


urls = (
    '/host/(\d+)/network/([^/]+)/status?(\.part|\.json)?$', HostBy1NetworkBy1Status,
    )

########NEW FILE########
__FILENAME__ = hostby1networksettings
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.model._2pysilhouette import Job, JobGroup
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command

from karesansui.lib.utils import get_ifconfig_info, get_bonding_info, dict_ksort, available_virt_mechs, is_param
from karesansui.lib.const import BONDING_COMMAND_ADD, NETWORK_COMMAND_RESTART, BONDING_MODE

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID

NETWORK_RESTART = 1

def validates_bonding(obj, target_regex):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    count = 0
    for input in obj.input:
        m = target_regex.match(input)
        if m:
            count += 1
            check = checker.check_netdev_name(_('Target Device Name'),
                                              m.group('dev'),
                                              CHECK_EMPTY | CHECK_VALID,
                                              ) and check
    if count < 2:
        check = False
        checker.add_error(_('Not enough target devices for bonding.'))

    if is_param(obj.input, 'bonding_target_dev_primary'):
        check = checker.check_netdev_name(_('Primary Device Name'),
                                          obj.input.bonding_target_dev_primary,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Primary Device Name'))

    if is_param(obj.input, 'bonding_mode'):
        if obj.input.bonding_mode not in BONDING_MODE:
            check = False
            checker.add_error(_('Unknown bonding mode.'))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Bonding Mode'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkSettings(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        bond_list = get_bonding_info()

        if self.is_mode_input() is True:
            exist_bond_max_num = -1
            exist_bond_list = get_ifconfig_info("regex:^bond")
            for bond_name in exist_bond_list.keys():
                try:
                    num = int(bond_name.replace("bond",""))
                except ValueError:
                    continue

                if exist_bond_max_num < num:
                    exist_bond_max_num = num

            self.view.create_bond_name = "bond%s" % (exist_bond_max_num + 1)
            dev_list = get_ifconfig_info("regex:^eth")
            for bond in bond_list:
                for slave in bond_list[bond]['slave']:
                    if slave in dev_list:
                        dev_list[slave]['bond'] = bond

            #pysical_dev_list = get_ifconfig_info("regex:^peth")
            pysical_dev_list = get_ifconfig_info("regex:^br")
            for pysical_dev in pysical_dev_list:
                if pysical_dev[1:] in dev_list:
                    dev_list[pysical_dev[1:]]['bridge'] = pysical_dev

            self.view.bond_target_dev = dev_list
            self.view.hypervisors = available_virt_mechs()
            return True

        dev_list = get_ifconfig_info()

        for bond in bond_list:
            if bond in dev_list:
                dev_list[bond]['bond'] = True
                for slave in bond_list[bond]['slave']:
                    for dev in dev_list:
                        if dev == slave:
                            dev_list[dev]['bond'] = True

        self.view.current = dev_list
        self.view.bond_list = bond_list

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        target_regex = re.compile(r"^bonding_target_dev_select_(?P<dev>eth[0-9]+)")

        if not validates_bonding(self, target_regex):
            self.logger.debug("Add bonding failed. Did not validate.")
            return web.badrequest(self.view.alert)

        target_dev = []
        for input in self.input:
            m = target_regex.match(input)
            if m:
                target_dev.append(m.group('dev'))

        primary = self.input.bonding_target_dev_primary
        mode    = self.input.bonding_mode

        cmdname = u"Add Bonding Setting"
        cmd = BONDING_COMMAND_ADD
        options = {}

        options['dev'] = ','.join(target_dev)
        options["primary"] = primary
        options["mode"] = mode

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _job = Job('%s command' % cmdname, 0, _cmd)
        _jobgroup.jobs.append(_job)

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        return web.accepted()

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id

        host = findbyhost1(self.orm, host_id)

        status = int(self.input.status)
        if status != NETWORK_RESTART:
            return web.badrequest()

        cmdname = u"Restart Network"
        cmd = NETWORK_COMMAND_RESTART
        options = {}

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _job = Job('%s command' % cmdname, 0, _cmd)
        _jobgroup.jobs.append(_job)

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        return web.accepted()

urls = (
    '/host/(\d+)/networksettings/?(\.part)$', HostBy1NetworkSettings,
    )

########NEW FILE########
__FILENAME__ = hostby1networksettingsgeneral
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import time
import web

from karesansui.lib.rest import Rest, auth

from karesansui.db.access.machine import findbyhost1
from karesansui.lib.utils import get_ifconfig_info, dict_ksort, is_param
from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.const import FQDN_MIN_LENGTH, \
    FQDN_MAX_LENGTH

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH

def validates_general(obj):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'gateway'):
        check = checker.check_ipaddr(_('Default Gateway'),
                                     obj.input.gateway,
                                     CHECK_EMPTY | CHECK_VALID,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Default Gateway'))

    if is_param(obj.input, 'fqdn'):
        check = checker.check_domainname(_('FQDN'),
                                         obj.input.fqdn,
                                         CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                                         FQDN_MIN_LENGTH,
                                         FQDN_MAX_LENGTH,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('FQDN'))

    if is_param(obj.input, 'nameserver'):
        nameservers = obj.input.nameserver.strip().split()
        if len(nameservers) != 0:
            for name_server in nameservers:
                if name_server == "":
                    continue
                check = checker.check_ipaddr(_('Nameserver'),
                                             name_server,
                                             CHECK_VALID,
                                             ) and check
        else:
            check = False
            checker.add_error(_('"%s" is required.') %_('Nameserver'))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Nameserver'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkSettingsGeneral(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        self.view.current = get_ifconfig_info()

        modules = ["network","resolv","hosts"]

        host = findbyhost1(self.orm, host_id)
        dop = read_conf(modules, self, host)
        if dop is False:
            return web.internalerror('Internal Server Error. (Timeout)')

        self.view.gateway    = dop.get("network",["GATEWAY"])
        self.view.search     = dop.get("resolv" ,["search"])

        self.view.nameserver = dop.get("resolv" ,["nameserver"])
        if self.view.nameserver is False:
            self.view.nameserver = []
        if type(self.view.nameserver) == str:
            self.view.nameserver = [self.view.nameserver]
        self.view.nameserver = "\n".join(self.view.nameserver)

        self.view.domainname  = dop.get("resolv" ,["domain"])
        if self.view.domainname is False:
            self.view.domainname = dop.get("network" ,["DOMAINNAME"])
        if self.view.domainname is False:
            self.view.domainname = re.sub("^[^\.]+\.","",os.uname()[1])

        self.view.hostname = dop.get("network" ,["HOSTNAME"])
        if self.view.hostname is False:
            self.view.hostname = os.uname()[1]

        self.view.hostname_short = re.sub("\.%s$" % (self.view.domainname), "", self.view.hostname)

        # --
        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_general(self):
            self.logger.debug("Change network general failed. Did not validate.")
            return web.badrequest(self.view.alert)

        modules = ["network","resolv","hosts"]

        host = findbyhost1(self.orm, host_id)
        dop = read_conf(modules, self, host)
        if dop is False:
            self.logger.error("Change network general failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read Conf)')

        gateway  = self.input.gateway
        hostname = self.input.fqdn
        nameservers = self.input.nameserver.strip().split()

        domainname     = re.sub("^[^\.]+\.","",hostname)
        hostname_short = re.sub("\.%s$" % (domainname), "", hostname)

        old_domainname  = dop.get("resolv" ,["domain"])
        if old_domainname is False:
            old_domainname = dop.get("network" ,["DOMAINNAME"])
        if old_domainname is False:
            old_domainname = re.sub("^[^\.]+\.","",os.uname()[1])

        old_hostname = dop.get("network" ,["HOSTNAME"])
        if old_hostname is False:
            old_hostname = os.uname()[1]

        old_hostname_short = re.sub("\.%s$" % (old_domainname), "", old_hostname)

        # hosts
        hosts_arr = dop.getconf("hosts")
        for _k,_v in hosts_arr.iteritems():
            _host = dop.get("hosts",[_k])
            _value   = _host[0]
            _comment = _host[1]
            _values  = _value.strip().split()
            new_values = []
            for _entry in _values:
                if _entry == old_hostname:
                    _entry = hostname
                elif _entry == old_hostname_short:
                    _entry = hostname_short
                new_values.append(_entry)
            new_value = " ".join(new_values)
            dop.set("hosts" ,[_k] ,[new_value,_comment])

        dop.set("network" ,["GATEWAY"]    ,gateway)
        dop.set("resolv"  ,["nameserver"] ,nameservers)
        dop.set("resolv"  ,["domain"]     ,domainname)
        dop.set("network" ,["DOMAINNAME"] ,domainname)
        dop.set("network" ,["HOSTNAME"]   ,hostname)

        retval = write_conf(dop, self, host)
        if retval is False:
            self.logger.error("Change network general failed. Failed write conf.")
            return web.internalerror('Internal Server Error. (Write Conf)')

        return web.accepted(url=web.ctx.path)

urls = (
    '/host/(\d+)/networksettings/general/?(\.part)?$', HostBy1NetworkSettingsGeneral,
    )

########NEW FILE########
__FILENAME__ = hostby1networksettingsnicby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import re
import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.model._2pysilhouette import Job, JobGroup
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command

from karesansui.lib.utils import get_ifconfig_info, dict_ksort, get_bonding_info, is_param
from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.networkaddress import NetworkAddress
from karesansui.lib.const import BONDING_COMMAND_DELETE

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID

def validates_nic(obj):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'bootproto'):
        if obj.input.bootproto == "static":
            if is_param(obj.input, 'ipaddr'):
                check = checker.check_ipaddr(_('IP Address'),
                                             obj.input.ipaddr,
                                             CHECK_EMPTY | CHECK_VALID,
                                             ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('IP Address'))

            if is_param(obj.input, 'netmask'):
                check = checker.check_netmask(_('Netmask'),
                                              obj.input.netmask,
                                              CHECK_EMPTY | CHECK_VALID,
                                              ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('Netmask'))

        else:
            if is_param(obj.input, 'ipaddr'):
                check = checker.check_ipaddr(_('IP Address'),
                                             obj.input.ipaddr,
                                             CHECK_VALID,
                                             ) and check

            if is_param(obj.input, 'netmask'):
                check = checker.check_netmask(_('Netmask'),
                                              obj.input.netmask,
                                              CHECK_VALID,
                                              ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Boot-time Protocol'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkSettingsNicBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        self.view.current = get_ifconfig_info()
        self.view.device = param[1]

        modules = ["ifcfg"]

        host = findbyhost1(self.orm, host_id)
        dop = read_conf(modules,self,host)
        if dop is False:
            self.logger.error("Get nic info failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read conf)')

        self.view.bootproto = dop.get("ifcfg",[self.view.device,"BOOTPROTO"])
        if self.view.bootproto is False:
            self.view.bootproto = "static"

        self.view.onboot    = dop.get("ifcfg",[self.view.device,"ONBOOT"])
        if self.view.onboot is False:
            self.view.onboot = "yes"

        self.view.ipaddr    = dop.get("ifcfg",[self.view.device,"IPADDR"])
        if self.view.ipaddr is False:
            self.view.ipaddr = ""

        self.view.netmask   = dop.get("ifcfg",[self.view.device,"NETMASK"])
        if self.view.netmask is False:
            self.view.netmask = ""

        self.view.network   = dop.get("ifcfg",[self.view.device,"NETWORK"])
        if self.view.network is False:
            net = NetworkAddress("%s/%s" % (self.view.ipaddr,self.view.netmask))
            if net.valid_addr(self.view.ipaddr) is True and net.valid_addr(self.view.netmask) is True:
                self.view.network = net.network
            else:
                self.view.network = ""

        self.view.broadcast = dop.get("ifcfg",[self.view.device,"BROADCAST"])
        if self.view.broadcast is False:
            net = NetworkAddress("%s/%s" % (self.view.ipaddr,self.view.netmask))
            if net.valid_addr(self.view.ipaddr) is True and net.valid_addr(self.view.netmask) is True:
                self.view.broadcast = net.broadcast
            else:
                self.view.broadcast = ""

        self.view.master    = dop.get("ifcfg",[self.view.device,"MASTER"])
        if self.view.master is False:
            self.view.master = ""

        self.view.c_ipaddr    = self.view.current[self.view.device]["ipaddr"]
        if self.view.c_ipaddr is None:
            self.view.c_ipaddr = ""

        self.view.c_netmask   = self.view.current[self.view.device]["mask"]
        if self.view.c_netmask is None:
            self.view.c_netmask = ""

        if self.view.current[self.view.device]["cidr"] is None:
            self.view.c_network = ""
        else:
            self.view.c_network = re.sub("\/.*","",self.view.current[self.view.device]["cidr"])

        self.view.c_broadcast = self.view.current[self.view.device]["bcast"]
        if self.view.c_broadcast is None:
            net = NetworkAddress("%s/%s" % (self.view.c_ipaddr,self.view.c_netmask))
            if net.valid_addr(self.view.c_ipaddr) is True and net.valid_addr(self.view.c_netmask) is True:
                self.view.c_broadcast = net.broadcast
            else:
                self.view.c_broadcast = ""

        self.view.c_hwaddr = self.view.current[self.view.device]["hwaddr"]
        if self.view.c_hwaddr is None:
            self.view.c_hwaddr = ""

        self.view.bond_info = get_bonding_info()

        self.view.c_master = ""
        for bond in self.view.bond_info:
            for slave in self.view.bond_info[bond]['slave']:
                if self.view.device == slave:
                    self.view.c_master = bond

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        uni_device = param[1]
        if uni_device is None: return web.notfound()
        device = uni_device.encode("utf-8")

        if not validates_nic(self):
            self.logger.debug("Change nic failed. Did not validate.")
            return web.badrequest(self.view.alert)

        host = findbyhost1(self.orm, host_id)

        modules = ["ifcfg"]
        dop = read_conf(modules, self, host)
        if dop is False:
            self.logger.error("Change nic failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read conf)')

        ipaddr = ""
        if is_param(self.input, ipaddr):
            if self.input.ipaddr:
                ipaddr = self.input.ipaddr

        netmask = ""
        if is_param(self.input, netmask):
            if self.input.netmask:
                netmask = self.input.netmask

        bootproto = self.input.bootproto
        onboot = "no"
        if is_param(self.input, 'onboot'):
            onboot = "yes"

        net = NetworkAddress("%s/%s" % (ipaddr,netmask))
        network   = net.network
        broadcast = net.broadcast

        if not dop.get("ifcfg", device):
            self.logger.error("Change nic failed. Target config not found.")
            return web.internalerror('Internal Server Error. (Get conf)')

        dop.set("ifcfg",[device,"ONBOOT"]   ,onboot)
        dop.set("ifcfg",[device,"BOOTPROTO"],bootproto)
        dop.set("ifcfg",[device,"IPADDR"]   ,ipaddr)
        dop.set("ifcfg",[device,"NETMASK"]  ,netmask)
        if network is not None:
            dop.set("ifcfg",[device,"NETWORK"]  ,network)
        if broadcast is not None:
            dop.set("ifcfg",[device,"BROADCAST"],broadcast)

        retval = write_conf(dop, self, host)
        if retval is False:
            self.logger.error("Change nic failed. Failed write conf.")
            return web.internalerror('Internal Server Error. (Adding Task)')

        return web.accepted(url=web.ctx.path)

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        device = param[1]
        if device is None: return web.notfound()

        cmdname = u"Delete Bonding Setting"
        cmd = BONDING_COMMAND_DELETE
        options = {}

        options['dev'] = device
        options["succession"] = None

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

        _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        _job = Job('%s command' % cmdname, 0, _cmd)
        _jobgroup.jobs.append(_job)

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )
        return web.accepted()

urls = (
    '/host/(\d+)/networksettings/nic/([^\./]+)/?(\.part|\.json)?$', HostBy1NetworkSettingsNicBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1networkstorage
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import string
import re

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.model._2pysilhouette import Job, JobGroup, JOBGROUP_TYPE
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jg_findby1, jg_save, corp
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command

from karesansui.lib.utils import is_param, generate_phrase, create_file, \
    get_filelist, symlink2real
from karesansui.lib.const import ISCSI_COMMAND_GET, ISCSI_COMMAND_ADD, \
    ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    CHAP_USER_MIN_LENGTH,                CHAP_USER_MAX_LENGTH, \
    CHAP_PASSWORD_MIN_LENGTH,            CHAP_PASSWORD_MAX_LENGTH, \
    ISCSI_DEVICE_DIR,                    ISCSI_DEVICE_NAME_TPL

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_MIN, CHECK_MAX


def get_network_storages(data):
    network_storages = []
    dev_symlink_list = get_filelist(ISCSI_DEVICE_DIR)
    dev_symlink_list.sort()
    unmountable_regexp = re.compile("-part[0-9]+$")
    for line in data.split('\n'):
        if not line:
            continue

        (host,port,tpgt,iqn,activity,autostart) = line.split(' ', 6)
        node = {
            'type'      : "iSCSI",
            'hostname'  : host,
            'port'      : port,
            'tpgt'      : tpgt,
            'iqn'       : iqn,
            'activity'  : string.atoi(activity),
            'autostart' : string.atoi(autostart),
            'disk_list' : [],
            }

        if activity == '1':
            disk_list = []
            symlink_regexp = re.compile("^%s" % (re.escape(ISCSI_DEVICE_NAME_TPL % (host, port, iqn))))
            unmountable_flag = {}
            for sym_link in dev_symlink_list:
                if symlink_regexp.search(sym_link):
                    real_path = symlink2real("%s/%s" % (ISCSI_DEVICE_DIR, sym_link))
                    is_blockable = True
                    if unmountable_regexp.search(sym_link):
                        is_blockable = False
                        unmountable_flag[unmountable_regexp.sub("", sym_link)] = True

                    disk_list.append({'symlink_name'     : sym_link,
                                      'realpath_list'    : real_path,
                                      'is_blockable'     : is_blockable,
                                      'is_partitionable' : False,
                                      })

            for disk in disk_list:
                for key in unmountable_flag.keys():
                    if disk['symlink_name'] == key:
                        disk['is_partitionable'] = True

            node['disk_list'] = disk_list

        network_storages.append(node)
    return network_storages

def get_iscsi_cmd(obj, host_id):
    cmd_name = u'Get iSCSI List'
    jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
    jobgroup.jobs.append(Job('%s command' % cmd_name, 0, "%s/%s" \
                             % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_GET)))
    jobgroup.type = JOBGROUP_TYPE['PARALLEL']

    host = findbyhost1(obj.orm, host_id)
    _machine2jobgroup = m2j_new(machine=host,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )
    if corp(obj.orm, obj.pysilhouette.orm,_machine2jobgroup, jobgroup) is False:
        return False

    ret = jobgroup.jobs[0].action_stdout
    network_storages = get_network_storages(ret)
    return network_storages

def validates_network_storage(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'network_storage_host_name'):
        check = checker.check_domainname(_('Target Hostname'),
                                         obj.input.network_storage_host_name,
                                         CHECK_EMPTY | CHECK_VALID,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target Hostname'))

    if is_param(obj.input, 'network_storage_port_number'):
        check = checker.check_number(_('Target Port Number'),
                                     obj.input.network_storage_port_number,
                                     CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     PORT_MIN_NUMBER,
                                     PORT_MAX_NUMBER,
                                     ) and check

    if is_param(obj.input, 'network_storage_authentication'):
        check = checker.check_empty(_('iSCSI Authentication Type'),
                                     obj.input.network_storage_authentication,
                                     ) and check

        if obj.input.network_storage_authentication == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            if is_param(obj.input, 'network_storage_user'):
                check = checker.check_username_with_num(_('iSCSI Authentication User'),
                                                        obj.input.network_storage_user,
                                                        CHECK_VALID | CHECK_LENGTH,
                                                        CHAP_USER_MIN_LENGTH,
                                                        CHAP_USER_MAX_LENGTH,
                                                        ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('iSCSI Authentication User'))


            if is_param(obj.input, 'network_storage_password'):
                check = checker.check_password(_('iSCSI Authentication Password'),
                                               obj.input.network_storage_password,
                                               obj.input.network_storage_password,
                                               CHECK_LENGTH,
                                               CHAP_PASSWORD_MIN_LENGTH,
                                               CHAP_PASSWORD_MAX_LENGTH,
                                               ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('iSCSI Authentication Password'))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('iSCSI Authentication Type'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkStorage(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if self.is_mode_input() is True:
            self.view.host_id = host_id
            self.view.info = {
                'type' : "iSCSI",
                'hostname' : "",
                'port' : "3260",
                'tpgt' : "",
                'iqn'  : "",
                'activity' : "",
                'autostart' : "",
                'auth' : "",
                'user' : "",
                }

            return True

        network_storages = get_iscsi_cmd(self, host_id)
        if network_storages is False:
            self.logger.debug("Get iSCSI List command failed. Return to timeout")
            #return web.internalerror('Internal Server Error. (Timeout)')

        self.view.network_storages = network_storages
        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_network_storage(self):
            self.logger.debug("Network storage add failed. Did not validate.")
            return web.badrequest(self.view.alert)

        hostname = self.input.network_storage_host_name
        port = self.input.network_storage_port_number
        auth = self.input.network_storage_authentication
        user = self.input.network_storage_user
        password = self.input.network_storage_password
        auto_start = False
        if is_param(self.input, 'network_storage_auto_start'):
            auto_start = True

        options = {'auth' : auth}
        if port:
            options['target'] = "%s:%s" % (hostname, port)
        else:
            options['target'] = hostname

        if auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            options['user'] =  user
            try:
                password_file_name = '/tmp/' + generate_phrase(12,'abcdefghijklmnopqrstuvwxyz')
                create_file(password_file_name, password)
                options['password-file'] = password_file_name
            except Exception, e:
                self.logger.error('Failed to create tmp password file. - file=%s' % (password_file_name))
                options['password'] = password

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_ADD), options)

        if auto_start:
            _cmd = _cmd + " --autostart"

        cmd_name = u'Add iSCSI'
        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               jobgroup,
                               )

        return web.accepted()

urls = (
    '/host/(\d+)/networkstorage[/]?(\.part)?$', HostBy1NetworkStorage,
    )


########NEW FILE########
__FILENAME__ = hostby1networkstorageby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import string
import re

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.model._2pysilhouette import Job, JobGroup, JOBGROUP_TYPE
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jg_findby1, jg_save, corp
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.utils import is_param, generate_phrase, create_file, \
    get_filelist, symlink2real
from karesansui.lib.const import ISCSI_COMMAND_GET, ISCSI_COMMAND_UPDATE, \
    ISCSI_COMMAND_DELETE,     ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP, \
    PORT_MIN_NUMBER,          PORT_MAX_NUMBER, \
    CHAP_USER_MIN_LENGTH,     CHAP_USER_MAX_LENGTH, \
    CHAP_PASSWORD_MIN_LENGTH, CHAP_PASSWORD_MAX_LENGTH, \
    ISCSI_DEVICE_DIR,         ISCSI_DEVICE_NAME_TPL, \
    VIRT_COMMAND_DESTROY_STORAGE_POOL, VIRT_COMMAND_DELETE_STORAGE_POOL

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_MIN, CHECK_MAX

def validates_network_storage(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'network_storage_host_name'):
        check = checker.check_domainname(_('Target Hostname'),
                                         obj.input.network_storage_host_name,
                                         CHECK_EMPTY | CHECK_VALID,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target Hostname'))

    if is_param(obj.input, 'network_storage_port_number'):
        check = checker.check_number(_('Target Port Number'),
                                     obj.input.network_storage_port_number,
                                     CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     PORT_MIN_NUMBER,
                                     PORT_MAX_NUMBER,
                                     ) and check

    if is_param(obj.input, 'network_storage_authentication'):
        check = checker.check_empty(_('iSCSI Authentication Type'),
                                     obj.input.network_storage_authentication,
                                     ) and check

        if obj.input.network_storage_authentication == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            if is_param(obj.input, 'network_storage_user'):
                check = checker.check_username_with_num(_('iSCSI Authentication User'),
                                                        obj.input.network_storage_user,
                                                        CHECK_VALID | CHECK_LENGTH,
                                                        CHAP_USER_MIN_LENGTH,
                                                        CHAP_USER_MAX_LENGTH,
                                                        ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('iSCSI Authentication User'))


            if is_param(obj.input, 'network_storage_password'):
                check = checker.check_password(_('iSCSI Authentication Password'),
                                               obj.input.network_storage_password,
                                               obj.input.network_storage_password,
                                               CHECK_LENGTH,
                                               CHAP_PASSWORD_MIN_LENGTH,
                                               CHAP_PASSWORD_MAX_LENGTH,
                                               ) and check
            else:
                check = False
                checker.add_error(_('"%s" is required.') %_('iSCSI Authentication Password'))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('iSCSI Authentication Type'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkStorageBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if self.is_mode_input() is True:
            self.view.host_id = host_id

        iqn = self.input.iqn
        options = {'iqn' : iqn}

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_GET), options)

        cmd_name = u'Get iSCSI Detail'
        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))
        jobgroup.type = JOBGROUP_TYPE['PARALLEL']

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        if corp(self.orm, self.pysilhouette.orm,_machine2jobgroup, jobgroup) is False:
            self.logger.debug("%s command failed. Return to timeout" % (cmd_name))
            return web.internalerror('Internal Server Error. (Timeout)')

        cmd_res = jobgroup.jobs[0].action_stdout

        if not cmd_res:
            self.view.info = {
                'type'      : "iSCSI",
                'hostname'  : "",
                'port'      : "",
                'tpgt'      : "",
                'iqn'       : "",
                'activity'  : "",
                'autostart' : "",
                'auth'      : "",
                'user'      : "",
                'disk_list' : [],
                }

            return True

        (host,port,tpgt,iqn,activity,autostart,auth,user) = cmd_res.strip("\n").split(' ', 8)
        info = {
            'type'      : "iSCSI",
            'hostname'  : host,
            'port'      : port,
            'tpgt'      : tpgt,
            'iqn'       : iqn,
            'activity'  : string.atoi(activity),
            'autostart' : string.atoi(autostart),
            'auth'      : auth,
            'user'      : user,
            'disk_list' : [],
            }

        dev_symlink_list = get_filelist(ISCSI_DEVICE_DIR)
        if activity == '1':
            disk_list = []
            symlink_regexp = re.compile("^%s" % (re.escape(ISCSI_DEVICE_NAME_TPL % (host, port, iqn))))
            for sym_link in dev_symlink_list:
                if symlink_regexp.match(sym_link):
                    real_path = symlink2real("%s/%s" % (ISCSI_DEVICE_DIR, sym_link))
                    disk_list.append({'symlink_name' : sym_link,
                                      'realpath_list' : real_path,
                                      })
            info['disk_list'] = disk_list

        self.view.info = info
        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_network_storage(self):
            self.logger.debug("Network storage update failed. Did not validate.")
            return web.badrequest(self.view.alert)

        hostname = self.input.network_storage_host_name
        port = self.input.network_storage_port_number
        iqn = self.input.network_storage_iqn
        auth = self.input.network_storage_authentication
        user = self.input.network_storage_user
        password = self.input.network_storage_password
        auto_start = False
        if is_param(self.input, 'network_storage_auto_start'):
            auto_start = True

        options = {'auth' : auth,
                   'iqn' : iqn,
                   'target' : hostname}
        if port:
            options['port'] = port

        if auth == ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP:
            options['user'] =  user
            try:
                password_file_name = '/tmp/' + generate_phrase(12,'abcdefghijklmnopqrstuvwxyz')
                create_file(password_file_name, password)
                options['password-file'] = password_file_name
            except Exception, e:
                self.logger.error('Failed to create tmp password file. - file=%s' % (password_file_name))
                options['password'] = password

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_UPDATE), options)

        if auto_start:
            _cmd = _cmd + " --autostart"

        cmd_name = u'Update iSCSI'
        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               jobgroup,
                               )

        return web.accepted()

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        host = findbyhost1(self.orm, host_id)

        if is_param(self.input, "iqn"):
            iqn = self.input.iqn
        else:
            self.logger.debug("Network storage delete failed. Target IQN not found.")
            return web.badrequest()

        options = {'iqn' : iqn}
        job_order = 0
        cmd_name = u'Delete iSCSI'
        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])

        if is_param(self.input, "host") and is_param(self.input, "port"):
            host = self.input.host
            port = self.input.port
            used_pool = []
            active_used_pool = []

            kvc = KaresansuiVirtConnection()
            try:
                dev_symlink_list = get_filelist(ISCSI_DEVICE_DIR)
                dev_symlink_list.sort()
                symlink_regexp = re.compile("^%s/%s" % (re.escape(ISCSI_DEVICE_DIR), re.escape(ISCSI_DEVICE_NAME_TPL % (host, port, iqn))))

                pools = kvc.list_active_storage_pool() + kvc.list_inactive_storage_pool()
                for pool in pools:
                    pool_type = kvc.get_storage_pool_type(pool)
                    if pool_type == "iscsi":
                        if iqn == kvc.get_storage_pool_sourcedevicepath(pool):
                            used_pool.append(pool)
                            pool_objs = kvc.search_kvn_storage_pools(pool)
                            if pool_objs[0].is_active():
                                active_used_pool.append(pool)

                    elif pool_type == "fs":
                        if symlink_regexp.match(kvc.get_storage_pool_sourcedevicepath(pool)):
                            used_pool.append(pool)
                            pool_objs = kvc.search_kvn_storage_pools(pool)
                            if pool_objs[0].is_active():
                                active_used_pool.append(pool)

            finally:
                kvc.close()

            for pool in active_used_pool:
                stop_pool_cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DESTROY_STORAGE_POOL),
                    {"name" : pool})
                stop_pool_cmdname = "Stop Storage Pool"
                jobgroup.jobs.append(Job('%s command' % stop_pool_cmdname, 0, stop_pool_cmd))
                job_order = 1

            for pool in used_pool:
                delete_pool_cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_POOL),
                    {"name" : pool})
                delete_pool_cmdname = "Delete Storage Pool"
                jobgroup.jobs.append(Job('%s command' % delete_pool_cmdname, job_order, delete_pool_cmd))
                job_order = 2

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_DELETE), options)

        jobgroup.jobs.append(Job('%s command' % cmd_name, job_order, _cmd))

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               jobgroup,
                               )

        return web.accepted()

urls = (
    '/host/(\d+)/networkstorage/([^\./]+)[/]?(\.part)?$', HostBy1NetworkStorageBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1networkstorageby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import re

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.model._2pysilhouette import Job, JobGroup, JOBGROUP_TYPE
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import jg_findby1, jg_save
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new

from pysilhouette.command import dict2command

from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.utils import is_param, get_filelist, uniq_sort
from karesansui.lib.const import ISCSI_COMMAND_START, ISCSI_COMMAND_STOP, \
    ISCSI_DEVICE_NAME_TPL, ISCSI_DEVICE_DIR, \
    VIRT_COMMAND_DESTROY_STORAGE_POOL, VIRT_COMMAND_START_STORAGE_POOL, \
    PORT_MIN_NUMBER, PORT_MAX_NUMBER

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID, \
    CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE

NETWORK_STORAGE_START = "0"
NETWORK_STORAGE_STOP = "1"

def validates_network_storage(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'iqn'):
        check = checker.check_string(_('Target IQN'),
                                     obj.input.iqn,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     None,
                                     None,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target IQN'))

    if is_param(obj.input, 'status'):
        check = checker.check_empty(_('Action Status'),
                                     obj.input.status,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Action Status'))

    if is_param(obj.input, 'host'):
        check = checker.check_domainname(_('Target Hostname'),
                                         obj.input.host,
                                         CHECK_EMPTY | CHECK_VALID,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target Hostname'))

    if is_param(obj.input, 'port'):
        check = checker.check_number(_('Target Port Number'),
                                     obj.input.port,
                                     CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     PORT_MIN_NUMBER,
                                     PORT_MAX_NUMBER,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target Port Number'))

    obj.view.alert = checker.errors
    return check

class HostBy1NetworkStorageBy1Status(Rest):
    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_network_storage(self):
            self.logger.debug("Network storage change status failed. Did not validate.")
            return web.badrequest(self.view.alert)

        host = findbyhost1(self.orm, host_id)

        if is_param(self.input, "iqn"):
            iqn = self.input.iqn
        else:
            self.logger.debug("Network storage change status failed. Target IQN not found.")
            return web.badrequest()

        options = {'iqn' : iqn}
        job_order = 0

        if is_param(self.input, "status"):
            status = self.input.status
        else:
            self.logger.debug("Network storage change status failed. Status type not found.")
            return web.badrequest()

        if is_param(self.input, "host") and is_param(self.input, "port"):
            host = self.input.host
            port = self.input.port
        else:
            self.logger.debug("Network storage change status failed. Target host and port not found.")
            return web.badrequest()

        active_used_pool = []
        inactive_used_pool = []

        kvc = KaresansuiVirtConnection()
        try:
            dev_symlink_list = get_filelist(ISCSI_DEVICE_DIR)
            dev_symlink_list.sort()
            symlink_regexp = re.compile("^%s/%s" % (re.escape(ISCSI_DEVICE_DIR), re.escape(ISCSI_DEVICE_NAME_TPL % (host, port, iqn))))

            active_pools = kvc.list_active_storage_pool()
            inactive_pools = kvc.list_inactive_storage_pool()
            now_pools = active_pools + inactive_pools
            for pool in now_pools:
                pool_type = kvc.get_storage_pool_type(pool)
                if pool_type == "iscsi":
                    if iqn == kvc.get_storage_pool_sourcedevicepath(pool):
                        if pool in active_pools:
                            active_used_pool.append(pool)
                        if pool in inactive_pools:
                            inactive_used_pool.append(pool)
                elif pool_type == "fs":
                    if symlink_regexp.match(kvc.get_storage_pool_sourcedevicepath(pool)):
                        if pool in active_pools:
                            active_used_pool.append(pool)
                        if pool in inactive_pools:
                            inactive_used_pool.append(pool)

            if status == NETWORK_STORAGE_STOP:
                for pool in active_used_pool:
                    if kvc.is_used_storage_pool(name=pool, active_only=True) is True:
                        self.logger.debug("Stop iSCSI failed. Target iSCSI is used by guest.")
                        return web.badrequest("Target iSCSI is used by guest.")
        finally:
            kvc.close()

        if status == NETWORK_STORAGE_START:
            network_storage_cmd = ISCSI_COMMAND_START
            cmd_name = u'Start iSCSI'
            jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])

            for pool in inactive_used_pool:
                pool_cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_START_STORAGE_POOL),
                    {"name" : pool})
                pool_cmdname = "Start Storage Pool"
                jobgroup.jobs.append(Job('%s command' % pool_cmdname, 1, pool_cmd))
                job_order = 0

        elif status == NETWORK_STORAGE_STOP:
            network_storage_cmd = ISCSI_COMMAND_STOP
            cmd_name = u'Stop iSCSI'
            jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])

            for pool in active_used_pool:
                pool_cmd = dict2command(
                    "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DESTROY_STORAGE_POOL),
                    {"name" : pool})
                pool_cmdname = "Stop Storage Pool"
                jobgroup.jobs.append(Job('%s command' % pool_cmdname, 0, pool_cmd))
                job_order = 1

        else:
            return web.internalerror('Internal Server Error. (Param)')

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], network_storage_cmd), options)

        jobgroup.jobs.append(Job('%s command' % cmd_name, job_order, _cmd))

        host = findbyhost1(self.orm, host_id)
        _machine2jobgroup = m2j_new(machine=host,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=self.me,
                                    modified_user=self.me,
                                    )

        save_job_collaboration(self.orm,
                               self.pysilhouette.orm,
                               _machine2jobgroup,
                               jobgroup,
                               )

        return web.accepted()

urls = (
    '/host/(\d+)/networkstorage/([^\./]+)/status/?(\.part)?$', HostBy1NetworkStorageBy1Status,
    )

########NEW FILE########
__FILENAME__ = hostby1report
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui
from karesansui.lib.rest import Rest, auth

class HostBy1Report(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        return True

urls = (
    '/host/(\d+)/report/?(\.part)$', HostBy1Report,
    )

########NEW FILE########
__FILENAME__ = hostby1reportby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import re

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.rrd.rrd import RRD
from karesansui.lib.utils import is_param, is_empty, \
    str2datetime, create_epochsec, get_proc_cpuinfo, \
    get_fs_info, get_hdd_list, get_ifconfig_info, \
    get_dom_list

from karesansui.lib.const import DEFAULT_LANGS, COLLECTD_DF_RRPORT_BY_DEVICE

class HostBy1ReportBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        self.view.host_id = host_id

        target = param[1]
        if target is None: return web.notfound()
        self.view.target = target

        group_display = False
        dev_list = []
        graph_type = []
        rrd = RRD()
        if target == "cpu":
            for dev in range(0, len(get_proc_cpuinfo())):
                if rrd.check_rrd_file_exist("cpu", dev):
                    dev_list.append(dev)
            graph_type = ['default']
        elif target == "memory":
            dev_list = ['default']
            graph_type = ['default']
        elif target == "df":
            df_list = get_fs_info()
            for fs in df_list:
                if COLLECTD_DF_RRPORT_BY_DEVICE is True:
                    dev = fs['Filesystem']
                    dev = re.sub(r'^/dev/', '', dev)
                    dev = re.sub(r'/', '_', dev)
                else:
                    dev = fs['Mounted']
                    if dev == "/":
                        dev = "root"
                    else:
                        dev = re.sub(r'^/', '', dev)
                        dev = re.sub(r'/', '_', dev)
                if rrd.check_rrd_file_exist("df", dev):
                    dev_list.append(dev)
            graph_type = ['default']

        elif target == "disk":
            group_display = True
            disk_list = get_hdd_list()
            for disk in disk_list:
                dev = disk
                dev = re.sub(r'^/dev/', '', dev)
                if rrd.check_rrd_file_exist("disk", dev):
                    dev_list.append(dev)
            graph_type = ['merged', 'octets', 'ops', 'time']

        elif target == "interface":
            group_display = True
            if_list = get_ifconfig_info().keys()
            for dev in if_list:
                if rrd.check_rrd_file_exist("interface", dev):
                    dev_list.append(dev)
            graph_type = ['packets', 'octets', 'errors']

        elif target == "load":
            dev_list = ['default']
            graph_type = ['default']
        elif target == "uptime":
            dev_list = ['default']
            graph_type = ['default']
        elif target == "users":
            dev_list = ['default']
            graph_type = ['default']
        elif target == "libvirt":
            virt_cpu_type = ['default']
            virt_disk_type = ['octets', 'ops']
            virt_interface_type = ['packets', 'octets', 'errors', 'dropped']
            virt_list = {}
            virt_file_exist = {}

            try:
                kvc = KaresansuiVirtConnection()

                for domname in get_dom_list():
                    virt_list[domname] = {}

                    if rrd.set_rrd_dir_host(domname) is False:
                        virt_file_exist[domname] = False
                        continue

                    try:
                        virt = kvc.search_kvg_guests(domname)[0]
                    except:
                        virt_file_exist[domname] = False
                        continue

                    virt_list[domname]['vcpu'] = {}
                    if rrd.check_rrd_file_exist("libvirt", "total", "vcpu"):
                        virt_list[domname]['vcpu']['total'] = virt_cpu_type
                    for i in range(virt.get_vcpus_info()['max_vcpus']):
                        if rrd.check_rrd_file_exist("libvirt", i, "vcpu"):
                            virt_list[domname]['vcpu'][i] = virt_cpu_type

                    virt_list[domname]['disk'] = {}
                    for disk in virt.get_disk_info():
                        if rrd.check_rrd_file_exist("libvirt", disk['target']['dev'], "disk"):
                            virt_list[domname]['disk'][disk['target']['dev']] = virt_disk_type

                    virt_list[domname]['interface'] = {}
                    for net_dev in virt.get_interface_info():
                        if rrd.check_rrd_file_exist("libvirt", net_dev['target']['dev'], "interface"):
                            virt_list[domname]['interface'][net_dev['target']['dev']] = virt_interface_type

                    if virt_list[domname]['vcpu'] == {} and \
                            virt_list[domname]['disk'] == {} and \
                            virt_list[domname]['interface'] == {}:
                        virt_list[domname] = {}
                        virt_file_exist[domname] = False
                    else:
                        virt_file_exist[domname] = True

            finally:
                kvc.close()

            self.view.virt_list = virt_list
            self.view.virt_file_exist = virt_file_exist

        self.view.group_display = group_display
        dev_list.sort()
        self.view.dev_list = dev_list
        self.view.graph_type = graph_type

        return True

urls = (
    '/host/(\d+)/report/([a-zA-Z0-9]+)/?(\.part)$', HostBy1ReportBy1,
    )


########NEW FILE########
__FILENAME__ = hostby1reportby1by1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import datetime
import time

import karesansui
from karesansui.lib.rest import Rest, auth, OUTPUT_TYPE_FILE
from karesansui.lib.utils import is_param, is_empty, \
    str2datetime, create_epochsec, remove_file
from karesansui.lib.rrd.rrd import RRD
from karesansui.lib.const import DEFAULT_LANGS

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID

def validates_report(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'report_start_day'):
        check = checker.check_datetime_string(_('Start Date'),
                                              obj.input.report_start_day,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'report_end_day'):
        check = checker.check_datetime_string(_('End Date'),
                                              obj.input.report_end_day,
                                              CHECK_EMPTY | CHECK_VALID,
                                              obj.me.languages,
                                              ) and check

    if is_param(obj.input, 'report_start_time'):
        check = checker.check_time_string(_('Start Time'),
                                          obj.input.report_start_time,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    if is_param(obj.input, 'report_end_time'):
        check = checker.check_time_string(_('End Time'),
                                          obj.input.report_end_time,
                                          CHECK_EMPTY | CHECK_VALID,
                                          ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1ReportBy1By1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        target = param[1]
        if target is None: return web.notfound()

        dev = param[2]
        if dev is None: return web.notfound()

        if not validates_report(self):
            self.logger.debug("Get report failed. Did not validate.")
            return web.badrequest(self.view.alert)

        today = datetime.datetime.today()

        if is_param(self.input, 'report_start_day') and not is_empty(self.input.report_start_day):
            start_day = str2datetime(self.input.report_start_day,
                                     DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
        else:
            start_day = today - datetime.timedelta(1)

        if is_param(self.input, 'report_start_time') and not is_empty(self.input.report_start_time):
            (start_hour, start_minute) = self.input.report_start_time.split(':',2)
            start_hour = int(start_hour)
            start_minute = int(start_minute)
        else:
            start_hour = today.hour
            start_minute = today.minute

        if is_param(self.input, 'report_end_day') and not is_empty(self.input.report_end_day):
            end_day = str2datetime(self.input.report_end_day,
                                     DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
        else:
            end_day = today

        if is_param(self.input, 'report_end_time') and not is_empty(self.input.report_end_time):
            (end_hour, end_minute) = self.input.report_end_time.split(':', 2)
            end_hour = int(end_hour)
            end_minute = int(end_minute)

        else:
            end_hour = today.hour
            end_minute = today.minute

        start_time = create_epochsec(start_day.year,
                                     start_day.month,
                                     start_day.day,
                                     start_hour,
                                     start_minute,
                                     )

        end_time = create_epochsec(end_day.year,
                                   end_day.month,
                                   end_day.day,
                                   end_hour,
                                   end_minute,
                                   )
        if int(start_time) > int(end_time):
            self.logger.error("Getting reports failed. Start time > end time.")
            return web.badrequest(_('Getting reports failed. Start time > end time.'))

        if is_param(self.input, 'type') and not is_empty(self.input.type):
            type = self.input.type
        else:
            type = "default"

        if is_param(self.input, 'host') and not is_empty(self.input.host):
            host = self.input.host
        else:
            host = None

        if is_param(self.input, 'libvirt_target') and not is_empty(self.input.libvirt_target):
            libvirt_target = self.input.libvirt_target
        else:
            libvirt_target = None

        rrd = RRD(self._, self.me.languages)
        if host is not None:
            if rrd.set_rrd_dir_host(host) is False:
                self.logger.debug("Get report failed. Target host not found.")
                return web.notfound()

        filepath = rrd.create_graph(target, dev, type, start_time, end_time, libvirt_target)

        if filepath != "":
            self.download.type = OUTPUT_TYPE_FILE
            self.download.file = filepath
            self.download.once = True

        return True

urls = (
    '/host/(\d+)/report/([a-zA-Z0-9]+)/([a-zA-Z0-9_\.\-]+)(\.png)$', HostBy1ReportBy1By1,
    )

########NEW FILE########
__FILENAME__ = hostby1service
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import SERVICE_XML_FILE
from karesansui.lib.service.config import ServiceConfigParam, ServiceXMLGenerator
from karesansui.lib.service.sysvinit_rh import SysVInit_RH

class HostBy1Service(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        displays = []
        for service in config.get_services():
            sysv = SysVInit_RH(service['system_name'], service['system_command'])
            display = {
                'name' : service['system_name'],
                'readonly': service['system_readonly'],
                'display_name' : service['display_name'],
                'description' : service['display_description'],
                'status' : sysv.status(),
                'autostart' : sysv.onboot(),
                }

            displays.append(display)

            self.view.services = displays

        return True

urls = (
    '/host/(\d+)/service/?(\.part)$', HostBy1Service,
    )

########NEW FILE########
__FILENAME__ = hostby1serviceby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.utils import is_param
from karesansui.lib.const import SERVICE_XML_FILE
from karesansui.lib.service.config import ServiceConfigParam
from karesansui.lib.service.sysvinit_rh import SysVInit_RH

class HostBy1ServiceBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()

        service = config.findby1service(param[1])
        if not service:
            self.logger.debug("Get service info failed. Service not found.")
            return web.notfound("Service not found")

        sysv = SysVInit_RH(service['system_name'], service['system_command'])
        display = {
            'name' : service['system_name'],
            'display_name' : service['display_name'],
            'description' : service['display_description'],
            'status' : sysv.status(),
            'autostart' : sysv.onboot(),
            }
        self.view.service = display

        return True

urls = (
    '/host/(\d+)/service/([a-zA-z\-]{4,32})/?(\.part)$', HostBy1ServiceBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1serviceby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from web.utils import Storage

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.utils import is_param, json_dumps

from karesansui.lib.const import SERVICE_XML_FILE, \
     SERVICE_COMMAND_START, SERVICE_COMMAND_STOP, \
     SERVICE_COMMAND_RESTART, SERVICE_COMMAND_AUTOSTART

from karesansui.lib.service.config import ServiceConfigParam
from karesansui.lib.service.sysvinit_rh import SysVInit_RH

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

SERVICE_START = 0
SERVICE_STOP = 1
SERVICE_RESTART = 2
SERVICE_ENABLE = 3
SERVICE_DISABLE = 4

class HostBy1ServiceBy1Status(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id

        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()
        service = config.findby1service(param[1])
        if not service:
            self.logger.debug("Get service status failed. Service not found.")
            return web.notfound("Service not found")

        sysv = SysVInit_RH(service['system_name'], service['system_command'])
        status = {"status":sysv.status(),
                  "autostart":sysv.onboot(),
                  "readonly":service["system_readonly"],
                  }

        if self.__template__["media"] == 'json':
            self.view.status = json_dumps(status)
        else:
            self.view.status = status

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id

        host = findbyhost1(self.orm, host_id)

        name = param[1]
        config = ServiceConfigParam(SERVICE_XML_FILE)
        config.load_xml_config()
        service = config.findby1service(name)
        if not service:
            self.logger.debug("Set service status failed. Service not found.")
            return web.notfound("Service not found")

        if not is_param(self.input, 'status'):
            self.logger.error("Set service status failed. Missing request param.")
            return web.badrequest("Missing request param.")

        status = int(self.input.status)
        if status == SERVICE_START:
            service_job(self, host, name, "start")
        elif status == SERVICE_STOP:
            service_job(self, host, name, "stop")
        elif status == SERVICE_RESTART:
            service_job(self, host, name, "restart")
        elif status == SERVICE_ENABLE:
            service_job(self, host, name, "enable")
        elif status == SERVICE_DISABLE:
            service_job(self, host, name, "disable")
        else:
            self.logger.error("Set service status failed. Invalid request param.")
            return web.badrequest("Invalid request param")

        return web.accepted()

def service_job(obj, host, name, status):

    if status == 'start':
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], SERVICE_COMMAND_START),
            {"name" : name})
        cmdname = "Start Service"
    elif status == 'stop':
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], SERVICE_COMMAND_STOP),
            {"name" : name})
        cmdname = "Stop Service"
    elif status == 'restart':
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], SERVICE_COMMAND_RESTART),
            {"name" : name})
        cmdname = "Restart Service"
    elif status == 'enable':
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], SERVICE_COMMAND_AUTOSTART),
            {"name" : name, "enable": None})
        cmdname = "Enable Autostart Service"
    elif status == 'disable':
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], SERVICE_COMMAND_AUTOSTART),
            {"name" : name, "disable": None})
        cmdname = "Disable Autostart Service"
    else:
        raise

    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _job = Job(cmdname, 0, _cmd)
    _jobgroup.jobs.append(_job)

    _machine2jobgroup = m2j_new(machine=host,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

urls = (
    '/host/(\d+)/service/([a-zA-z\-]{4,32})/status/?(\.json)$', HostBy1ServiceBy1Status,
    )

########NEW FILE########
__FILENAME__ = hostby1setting
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.rest import Rest, auth

class Hostby1Setting(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        self.view.host_id = host_id
        return True

urls = ('/host/(\d+)/setting/?(\.part)?$', Hostby1Setting)

########NEW FILE########
__FILENAME__ = hostby1settingby1mail
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import os
import web
import socket

from karesansui.lib.rest import Rest, auth
from karesansui.lib.file.k2v import K2V
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX, CHECK_LENGTH
from karesansui.lib.const import PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH
from karesansui.lib.utils import is_param

def validates_mail(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'hostname'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Server Name'))
    else:
        check_server = checker.check_domainname(_('Server Name'),
                        obj.input.hostname,
                        CHECK_VALID,
                       ) or \
                       checker.check_ipaddr(_('Server Name'),
                        obj.input.hostname,
                        CHECK_VALID,
                       )
        check = check_server and check

    if not is_param(obj.input, 'port'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Port Number'))
    else:
        check = checker.check_number(_('Port Number'),
                    obj.input.port,
                    CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    PORT_MIN_NUMBER,
                    PORT_MAX_NUMBER,
                    ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1SettingBy1Mail(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        try:
            conf = os.environ.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
            self.view.config = config
        except (IOError, KaresansuiGadgetException), kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge

        if self.is_mode_input() is True:
            pass

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_mail(self):
            self.logger.debug("Update mail setting failed. Did not validate.")
            return web.badrequest(self.view.alert)

        hostname = self.input.hostname
        port     = self.input.port
        if not port:
            port = "25"

        if hostname:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            try:
                sock.connect((hostname, int(port)))
            except Exception, e:
                self.logger.error("Could not connect to specified MTA \n%s" % e)
                """
                TRANSLATORS:
                MTA設定の際に実際に指定したホスト名/ポート番号に接続ができる
                かチェックし、接続できなかった。
                """
                return web.badrequest(_("Could not connect to specified MTA \n%s" % e))

        try:
            conf = os.environ.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
            config['application.mail.server'] = hostname
            config['application.mail.port'] = port
            _K2V.write(config)
            self.view.config = config
            return True

        except IOError, kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge

urls = ('/host/(\d+)/setting/mail?(\.input|\.part)$', HostBy1SettingBy1Mail,)

########NEW FILE########
__FILENAME__ = hostby1settingby1proxy
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import os
import web
import socket

from karesansui.lib.rest import Rest, auth
from karesansui.lib.file.k2v import K2V
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, \
    CHECK_MIN, CHECK_MAX, CHECK_LENGTH, \
    CHECK_ONLYSPACE
from karesansui.lib.const import PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    PROXY_ENABLE, PROXY_DISABLE
from karesansui.lib.utils import is_param
from karesansui import KaresansuiGadgetException, KaresansuiDBException, \
    config, sheconf

def validates_proxy(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'proxy_status'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Proxy Settings'))
    else:
        if obj.input.proxy_status == PROXY_ENABLE:
            if not is_param(obj.input, 'proxy_server'):
                check = False
                checker.add_error(_('"%s" is required.') % _('Proxy Server'))
            else:
                check = checker.check_domainname(
                                _('Proxy Server'),
                                obj.input.proxy_server,
                                CHECK_EMPTY | CHECK_VALID,
                                None,
                                None,
                                ) and check
            if not is_param(obj.input, 'proxy_port'):
                check = False
                checker.add_error(_('"%s" is required.') % _('Proxy Port Number'))
            else:
                check = checker.check_number(
                                _('Port Number'),
                                obj.input.proxy_port,
                                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                PORT_MIN_NUMBER,
                                PORT_MAX_NUMBER,
                                ) and check
            if not is_param(obj.input, 'proxy_user'):
                check = False
                checker.add_error(_('"%s" is required.') % _('Proxy User Name'))
            else:
                check = checker.check_username(
                                _('Proxy User Name'),
                                obj.input.proxy_user,
                                CHECK_VALID | CHECK_ONLYSPACE,
                                None,
                                None,
                                ) and check
            if not is_param(obj.input, 'proxy_password'):
                check = False
                checker.add_error(_('"%s" is required.') % _('Proxy Password'))
            else:
                check = checker.check_password(
                                _('Proxy Password'),
                                obj.input.proxy_password,
                                obj.input.proxy_password,
                                CHECK_VALID,
                            ) and check;

        elif obj.input.proxy_status == PROXY_DISABLE:
            check = True and check
        else:
            check = False
            checker.add_error(_('"%s" is in invalid format.') % _('Proxy Status'))

    obj.view.alert = checker.errors
    return check

class HostBy1SettingBy1Proxy(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        try:
            conf = os.environ.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
            self.view.config = config
        except (IOError, KaresansuiGadgetException), kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge

        if self.is_mode_input() is True:
            self.view.enable = ""
            self.view.disable = ""
            if config['application.proxy.status'] == PROXY_ENABLE:
                self.view.enable = "checked"
            else:
                self.view.disable = "checked"

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_proxy(self):
            self.logger.debug("Update proxy setting failed. Did not validate.")
            return web.badrequest(self.view.alert)

        if self.input.proxy_status == PROXY_ENABLE:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            try:
                sock.connect((self.input.proxy_server, int(self.input.proxy_port)))
            except Exception, e:
                self.logger.error("Could not connect to specified proxy server\n%s" % e)
                """
                TRANSLATORS:
                プロキシ設定の際に実際に指定したプロキシのホスト名/ポート番号
                に接続ができるかチェックし、接続できなかった。
                """
                return web.badrequest(_("Could not connect to specified proxy server\n%s" % e))

        try:
            conf = os.environ.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()

            config['application.proxy.status'] = self.input.proxy_status
            if self.input.proxy_status == PROXY_ENABLE:
                config['application.proxy.server'] = self.input.proxy_server
                config['application.proxy.port'] = self.input.proxy_port
                config['application.proxy.user'] = self.input.proxy_user
                config['application.proxy.password'] = self.input.proxy_password
            _K2V.write(config)
        except (IOError, KaresansuiGadgetException), kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge
        return web.accepted(url=web.ctx.path)

urls = ('/host/(\d+)/setting/proxy?(\.input|\.part)$', HostBy1SettingBy1Proxy,)

########NEW FILE########
__FILENAME__ = hostby1staticroute
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re

import web
import simplejson as json

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.db.access.machine import findbyhost1

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE, \
    CHECK_UNIQUE

from karesansui.lib.utils import is_param, is_empty, preprint_r, \
    base64_encode, get_ifconfig_info

from karesansui.lib.networkaddress import NetworkAddress
from karesansui.lib.parser.staticroute import staticrouteParser as Parser
from karesansui.lib.conf import read_conf, write_conf

def validates_staticroute(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'target'):
        check = False
        checker.add_error(_('Specify target address for the route.'))
    else:
        check = checker.check_ipaddr(
                _('Target'), 
                obj.input.target,
                CHECK_EMPTY | CHECK_VALID,
                ) and check

    if not is_param(obj.input, 'gateway'):
        check = False
        checker.add_error(_('Specify gateway address for the route.'))
    else:
        check = checker.check_ipaddr(
                _('Gateway'), 
                obj.input.gateway,
                CHECK_VALID,
                ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1StaticRoute(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        host = findbyhost1(self.orm, host_id)

        self.view.host_id = host_id

        # unremovable entries
        excludes = {
                   "device": ["^peth","^virbr","^sit","^xenbr","^lo","^br"],
                   "ipaddr": ["^0\.0\.0\.0$", "^169\.254\.0\.0$"],
                   }

        devices = []
        phydev_regex = re.compile(r"^eth[0-9]+")
        for dev,dev_info in get_ifconfig_info().iteritems():
            if phydev_regex.match(dev):
                try:
                    if dev_info['ipaddr'] is not None:
                        devices.append(dev)
                        net = NetworkAddress("%s/%s" % (dev_info['ipaddr'],dev_info['mask'],))
                        excludes['ipaddr'].append(net.network)
                except:
                    pass

        self.view.devices = devices

        parser = Parser()
        status = parser.do_status()
        routes = {}
        for _k,_v in status.iteritems():
            for _k2,_v2 in _v.iteritems():
                name = base64_encode("%s@%s" % (_k2,_k,))
                routes[name] = {}
                routes[name]['name']    = name
                routes[name]['device']  = _k
                routes[name]['gateway'] = _v2['gateway']
                routes[name]['flags']   = _v2['flags']
                routes[name]['ref']     = _v2['ref']
                routes[name]['use']     = _v2['use']
                net = NetworkAddress(_k2)
                routes[name]['ipaddr']  = net.ipaddr
                routes[name]['netlen']  = net.netlen
                routes[name]['netmask'] = net.netmask

                removable = True
                for _ex_key,_ex_val in excludes.iteritems():
                    ex_regex = "|".join(_ex_val)
                    mm = re.search(ex_regex,routes[name][_ex_key])
                    if mm:
                        removable = False

                routes[name]['removable'] = removable

        self.view.routes = routes

        if self.is_mode_input():
            pass

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        host = findbyhost1(self.orm, host_id)

        if not validates_staticroute(self):
            return web.badrequest(self.view.alert)

        modules = ["staticroute"]

        dop = read_conf(modules, self, host)
        if dop is False:
            return web.internalerror('Internal Server Error. (Timeout)')

        target  = self.input.target
        net = NetworkAddress(target)
        ipaddr  = net.ipaddr
        netmask = net.netmask
        netlen  = net.netlen
        network = net.network
        target = "%s/%s" % (ipaddr,netlen,)
        gateway = self.input.gateway
        device  = self.input.device

        dop.set("staticroute", [device,target], gateway)

        from karesansui.lib.parser.staticroute import PARSER_COMMAND_ROUTE
        if net.netlen == 32:
            command = "%s add -host %s gw %s dev %s" % (PARSER_COMMAND_ROUTE,ipaddr,gateway,device,)
            command = "%s add -host %s dev %s" % (PARSER_COMMAND_ROUTE,ipaddr,device,)
        else:
            command = "%s add -net %s netmask %s gw %s dev %s" % (PARSER_COMMAND_ROUTE,network,netmask,gateway,device,)
        extra_args = {"post-command": command}

        retval = write_conf(dop, self, host, extra_args=extra_args)
        if retval is False:
            return web.internalerror('Internal Server Error. (Adding Task)')

        return web.accepted(url=web.ctx.path)

urls = (
    '/host/(\d+)/staticroute[/]?(\.html|\.part|\.json)?$', HostBy1StaticRoute,
    )


########NEW FILE########
__FILENAME__ = hostby1staticrouteby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import simplejson as json

#import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.db.access.machine import findbyhost1

from karesansui.lib.utils import preprint_r, base64_encode, base64_decode

from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.parser.staticroute import staticrouteParser as Parser
from karesansui.lib.networkaddress import NetworkAddress

from karesansui.gadget.hostby1staticroute import validates_staticroute

from karesansui.lib.checker import *

class HostBy1StaticRouteBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        b64name = param[1]
        if not (b64name and host_id):
            return web.badrequest()

        name = base64_decode(str(b64name))

        (target, device) = name.split("@")

        net = NetworkAddress(target)
        ipaddr  = net.ipaddr
        netmask = net.netmask
        netlen  = net.netlen

        gateway = _('N/A')
        flags   = _('N/A')
        ref     = _('N/A')
        use     = _('N/A')
        metric  = _('N/A')

        parser = Parser()
        status = parser.do_status()
        for _k,_v in status.iteritems():
            for _k2,_v2 in _v.iteritems():
                if name == "%s@%s" % (_k2,_k,):
                    gateway = _v2['gateway']
                    flags   = _v2['flags']
                    ref     = _v2['ref']
                    use     = _v2['use']
                    metric  = _v2['metric']

        route = dict(name=name,
                       ipaddr=ipaddr,
                       netmask=netmask,
                       netlen=netlen,
                       device=device,
                       gateway=gateway,
                       flags=flags,
                       ref=ref,
                       use=use,
                       metric=metric,
                       )

        self.view.route = route
        return True

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()
        
        b64name = param[1]
        if not (b64name and host_id):
            return web.badrequest()

        host = findbyhost1(self.orm, host_id)

        name = base64_decode(str(b64name))

        (target, device) = name.split("@")

        net = NetworkAddress(target)
        ipaddr  = net.ipaddr
        netmask = net.netmask
        netlen  = net.netlen
        target = "%s/%s" % (ipaddr,netlen,)

        modules = ["staticroute"]

        dop = read_conf(modules, self, host)
        if dop is False:
            return web.internalerror('Internal Server Error. (Timeout)')

        dop.delete("staticroute", [device,target])

        from karesansui.lib.parser.staticroute import PARSER_COMMAND_ROUTE
        if net.netlen == 32:
            command = "%s del -host %s dev %s" % (PARSER_COMMAND_ROUTE,ipaddr,device,)
        else:
            command = "%s del -net %s netmask %s dev %s" % (PARSER_COMMAND_ROUTE,ipaddr,netmask,device,)
        extra_args = {"post-command": command}

        retval = write_conf(dop, self, host, extra_args=extra_args)
        if retval is False:
            return web.internalerror('Internal Server Error. (Adding Task)')

        return web.accepted()

urls = (
    '/host/(\d+)/staticroute/([a-zA-Z0-9\=]{2,})/?(\.html|\.part|\.json)?$', HostBy1StaticRouteBy1,

    )


########NEW FILE########
__FILENAME__ = hostby1storagepool
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import pwd

import web
from web.utils import Storage

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.const import STORAGE_POOL_TYPE, \
     VIRT_COMMAND_CREATE_STORAGE_POOL, STORAGE_VOLUME_FORMAT, \
     VIRT_COMMAND_DELETE_STORAGE_POOL, STORAGE_POOL_PWD, \
     ISCSI_DEVICE_DIR, ISCSI_COMMAND_READY_MOUNT, VENDOR_DATA_ISCSI_MOUNT_DIR

from karesansui.lib.utils import get_system_user_list

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from karesansui.gadget.hostby1networkstorage import get_iscsi_cmd
from pysilhouette.command import dict2command

from karesansui.lib.utils import is_param
from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_ONLYSPACE, CHECK_STARTROOT, \
    CHECK_NOTROOT

# validate
def validates_pool_dir(obj, now_pools):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'pool_name'):
        check = checker.check_string(_('Storage Pool Name'),
                                     obj.input.pool_name,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     ) and check
        if obj.input.pool_name in now_pools:
            check = False
            checker.add_error(_('%s "%s" already exists.') % (_('Storage Pool Name'), obj.input.pool_name))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Storage Pool Name'))

    if is_param(obj.input, 'pool_target_path'):
        check = checker.check_directory(_('Directory Path'),
                                        obj.input.pool_target_path,
                                        CHECK_EMPTY | CHECK_STARTROOT | CHECK_NOTROOT
                                        ) and check
        try:
            kvc = KaresansuiVirtConnection()

            for pool_name in now_pools:
                target_path = kvc.get_storage_pool_targetpath(pool_name)
                if obj.input.pool_target_path == target_path:
                    check = False
                    checker.add_error(_('Storagepool target path "%s" is already being used.') % (obj.input.pool_target_path))
        finally:
            kvc.close()

    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Directory Path'))

    obj.view.alert = checker.errors
    return check

def validates_pool_iscsi(obj, now_pools):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'pool_name'):
        check = checker.check_string(_('Storage Pool Name'),
                                     obj.input.pool_name,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     ) and check
        if obj.input.pool_name in now_pools:
            check = False
            checker.add_error(_('%s "%s" already exists.') % (_('Storage Pool Name'), obj.input.pool_name))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Storage Pool Name'))

    if is_param(obj.input, 'pool_target_iscsi'):
        check = checker.check_string(_('iSCSI Target'),
                                        obj.input.pool_target_iscsi,
                                        CHECK_EMPTY | CHECK_ONLYSPACE,
                                        None,
                                        ) and check
        try:
            kvc = KaresansuiVirtConnection()

            for pool_name in now_pools:
                pool_iqn = kvc.get_storage_pool_sourcedevicepath(pool_name)
                if obj.input.pool_target_iscsi == pool_iqn:
                    check = False
                    checker.add_error(_('Storagepool iSCSI target IQN "%s" is already being used.') % (obj.input.pool_target_iscsi))
        finally:
            kvc.close()

    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('iSCSI Target'))

    obj.view.alert = checker.errors
    return check

# create job
def create_pool_dir_job(obj, machine, name, type_, target_path,
                        options={}, rollback_options={}):
    cmdname = u"Create Storage Pool"
    cmd = VIRT_COMMAND_CREATE_STORAGE_POOL

    options['name'] = name
    options["type"] = type_
    options["target_path"] = target_path
    options["mode"] = STORAGE_POOL_PWD["MODE"]
    options["group"] = pwd.getpwnam(STORAGE_POOL_PWD["GROUP"])[2]
    options["owner"] = pwd.getpwnam(STORAGE_POOL_PWD["OWNER"])[2]

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)


    rollback_options["name"] = name

    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_POOL),
        rollback_options)

    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _job = Job('%s command' % cmdname, 0, _cmd)

    _job.rollback_command = rollback_cmd
    _jobgroup.jobs.append(_job)

    _machine2jobgroup = m2j_new(machine=machine,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )
    return True

# create job
def create_pool_iscsi_job(obj, machine, name, type_, host_name, device_path, automount_list,
                          options={}, rollback_options={}):
    cmdname = u"Create Storage Pool"
    cmd = VIRT_COMMAND_CREATE_STORAGE_POOL

    options['name'] = name
    options["type"] = type_
    options["host_name"] = host_name
    options["device_path"] = device_path

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], cmd), options)

    rollback_options["name"] = name
    rollback_options["force"] = None
    rollback_cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_POOL),
        rollback_options)

    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _job = Job('%s command' % cmdname, 0, _cmd)
    _job.rollback_command = rollback_cmd
    _jobgroup.jobs.append(_job)

    _machine2jobgroup = m2j_new(machine=machine,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

    automount_options = {}
    automount_options["type"] = STORAGE_POOL_TYPE['TYPE_FS']

    for disk in automount_list:
        readymount_options = {}
        readymount_options["dev"] = "%s/%s" % (ISCSI_DEVICE_DIR, disk['symlink_name'])
        if "is_format" in disk:
            readymount_options["format"] = None

        automount_options["name"] = disk['symlink_name']
        automount_options["device_path"] = "%s/%s" % (ISCSI_DEVICE_DIR, disk['symlink_name'])
        automount_options["target_path"] = "%s/%s" % (VENDOR_DATA_ISCSI_MOUNT_DIR, disk['symlink_name'])

        readymount_cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_READY_MOUNT), readymount_options)
        readymount_job = Job('Check mount command', 0, readymount_cmd)

        automount_cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], cmd), automount_options)
        automount_job = Job('%s command' % cmdname, 1, automount_cmd)

        jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(readymount_job)
        jobgroup.jobs.append(automount_job)

        machine2jobgroup = m2j_new(machine=machine,
                                    jobgroup_id=-1,
                                    uniq_key=karesansui.sheconf['env.uniqkey'],
                                    created_user=obj.me,
                                    modified_user=obj.me,
                                    )

        save_job_collaboration(obj.orm,
                               obj.pysilhouette.orm,
                               machine2jobgroup,
                               jobgroup,
                               )

    return True

class HostBy1StoragePool(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id

        # Pool
        try:
            kvc = KaresansuiVirtConnection()
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            self.view.pools = pools
            pools_info = []
            for pool in pools:
                pool_obj = kvc.search_kvn_storage_pools(pool)[0]
                pools_info.append(pool_obj.get_info())
                if pool_obj.is_active() is True:
                    vols_obj = pool_obj.search_kvn_storage_volumes(kvc)

                    vols_info = []
                    for vol_obj in vols_obj:
                        vols_info.append(vol_obj.get_info())
        finally:
            kvc.close()

        self.view.pools_info = pools_info

        if self.is_mode_input() is True:
            # .input
            try:
                kvc = KaresansuiVirtConnection()

                already_iqn = []
                for pool in pools:
                    pool_iqn = kvc.get_storage_pool_sourcedevicepath(pool)
                    if pool_iqn:
                        already_iqn.append(pool_iqn)
            finally:
                kvc.close()

            network_storages = get_iscsi_cmd(self, host_id)
            if network_storages is False:
                self.logger.debug("Get iSCSI command failed. Return to timeout")
                return web.internalerror('Internal Server Error. (Timeout)')

            available_network_storages = []
            for i in range(len(network_storages)):
                if network_storages[i]['iqn'] not in already_iqn and network_storages[i]['activity'] == 1:
                    available_network_storages.append(network_storages[i])

            self.view.network_storages = available_network_storages
            self.view.pool_types = (STORAGE_POOL_TYPE["TYPE_DIR"],
                                    STORAGE_POOL_TYPE["TYPE_ISCSI"])

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id

        model = findbyhost1(self.orm, host_id)

        # virt
        kvc = KaresansuiVirtConnection()
        try:
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
        finally:
            kvc.close()

        now_pools = inactive_pool + active_pool
        if self.input.pool_type == STORAGE_POOL_TYPE["TYPE_DIR"]:
            if not validates_pool_dir(self, now_pools):
                return web.badrequest(self.view.alert)

            extra_opts = {}
            if create_pool_dir_job(self,
                                   model,
                                   self.input.pool_name,
                                   self.input.pool_type,
                                   self.input.pool_target_path,
                                   extra_opts) is True:
                self.logger.debug("Create dir storage pool success.")
                return web.accepted()
            else:
                self.logger.debug("Failed create DIR storage pool job.")
                return False
        elif self.input.pool_type == STORAGE_POOL_TYPE["TYPE_ISCSI"]:
            if not validates_pool_iscsi(self, now_pools):
                return web.badrequest(self.view.alert)
            extra_opts = {}
            network_storages = get_iscsi_cmd(self, host_id)
            if network_storages is False:
                self.logger.debug("Get iSCSI command failed. Return to timeout")
                return web.internalerror('Internal Server Error. (Timeout)')

            pool_host_name = None
            pool_device_path = None
            for iscsi in network_storages:
                if self.input.pool_target_iscsi == iscsi["iqn"]:
                    pool_host_name = iscsi["hostname"]
                    pool_device_path = iscsi["iqn"]
                    disk_list = iscsi["disk_list"]
                    break

            if pool_host_name is None or pool_device_path is None:
                self.logger.debug("Failed create iSCSI storage pool. Target iSCSI device not found.")
                return web.badrequest()

            automount_list = []
            for disk in disk_list:
                if is_param(self.input, "iscsi-disk-use-type-%s" % (disk['symlink_name'])):
                    if self.input["iscsi-disk-use-type-%s" % (disk['symlink_name'])] == "mount" and disk['is_partitionable'] is False:
                        if is_param(self.input, "iscsi-disk-format-%s" % (disk['symlink_name'])):
                            if self.input["iscsi-disk-format-%s" % (disk['symlink_name'])] == "true":
                                disk["is_format"] = True
                        automount_list.append(disk)

            if create_pool_iscsi_job(self,
                                     model,
                                     self.input.pool_name,
                                     self.input.pool_type,
                                     pool_host_name,
                                     pool_device_path,
                                     automount_list,
                                     extra_opts) is True:
                self.logger.debug("Create iSCSI storage pool success. name=%s" % (self.input.pool_name))
                return web.accepted()
            else:
                self.logger.debug("Failed create iSCSI storage pool job. name=%s" % (self.input.pool_name))
                return False
        else:
            self.logger.debug("Non-existent type. type=%s" % self.input.pool_type)
            return web.badrequest("Non-existent type. type=%s" % self.input.pool_type)

urls = (
    '/host/(\d+)/storagepool/?(\.part)$', HostBy1StoragePool,
    )

########NEW FILE########
__FILENAME__ = hostby1storagepoolby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from web.utils import Storage

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.const import VIRT_COMMAND_DELETE_STORAGE_POOL

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID


def validates_storage_pool(obj, uuid=None):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if uuid:
        check = checker.check_unique_key(_('Target UUID'),
                                         uuid,
                                         CHECK_EMPTY | CHECK_VALID,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target UUID'))

    obj.view.alert = checker.errors
    return check

def delete_storage_pool_job(obj, host, name, options={}):
    #:TODO
    options['name'] = name

    _cmd = dict2command(
        "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DELETE_STORAGE_POOL), options)

    cmdname = u"Delete Storage Pool"
    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])
    _jobgroup.jobs.append(Job("%s command" % cmdname, 0, _cmd))

    _machine2jobgroup = m2j_new(machine=host,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )
    return True

class HostBy1StoragePoolBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        uuid = param[1]

        if not validates_storage_pool(self, uuid):
            self.logger.debug("Get storage pool info failed. Did not validate.")
            return web.badrequest(self.view.alert)

        try:
            kvc = KaresansuiVirtConnection()
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            self.view.pools = pools
            pools_obj = kvc.get_storage_pool_UUIDString2kvn_storage_pool(uuid)
            if len(pools_obj) <= 0:
                self.logger.debug("Get storage pool info failed. Target storage pool not found.")
                return web.notfound()

            pool_obj = pools_obj[0]
            pool_info = pool_obj.get_info()
            vols_info = []
            if pool_obj.is_active() is True:
                vols_obj = pool_obj.search_kvn_storage_volumes(kvc)
                for vol_obj in vols_obj:
                    vols_info.append(vol_obj.get_info())

        finally:
            kvc.close()

        self.view.pool_info = pool_info
        self.view.vols_info = vols_info

        return True

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        uuid = param[1]

        if not validates_storage_pool(self, uuid):
            self.logger.debug("Delete storage pool failed. Did not validate.")
            return web.badrequest(self.view.alert)

        # Pool
        try:
            kvc = KaresansuiVirtConnection()
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            self.view.pools = pools

            pools_obj = kvc.get_storage_pool_UUIDString2kvn_storage_pool(uuid)
            if len(pools_obj) <= 0:
                return web.notfound()

            if kvc.is_used_storage_pool(pools_obj[0].get_storage_name()) is True:
                self.logger.debug("Delete storage pool failed. Target storage pool is used by guest.")
                return web.badrequest("Target storage pool is used by guest.")
        finally:
            kvc.close()

        model = findbyhost1(self.orm, host_id)

        if delete_storage_pool_job(self,model,pools_obj[0].get_storage_name()) is True:
            self.logger.debug("Delete storage pool success. name=%s" % (pools_obj[0].get_storage_name()))
            return web.accepted()
        else:
            self.logger.debug("Failed delete storage pool. name=%s" % (pools_obj[0].get_storage_name()))
            return False

urls = (
    '/host/(\d+)/storagepool/([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12})/?(\.part)$', HostBy1StoragePoolBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1storagepoolby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from web.utils import Storage

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.const import VIRT_COMMAND_START_STORAGE_POOL, \
    VIRT_COMMAND_DESTROY_STORAGE_POOL, ISCSI_COMMAND_START

from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.model._2pysilhouette import JobGroup, Job

from pysilhouette.command import dict2command

from karesansui.lib.checker import Checker, CHECK_EMPTY, CHECK_VALID

# storage pool status
STORAGE_POOL_START = 0;
STORAGE_POOL_STOP = 1;

def validates_storage_pool(obj, uuid=None):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if uuid:
        check = checker.check_unique_key(_('Target UUID'),
                                         uuid,
                                         CHECK_EMPTY | CHECK_VALID,
                                         ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Target UUID'))

    obj.view.alert = checker.errors
    return check

class HostBy1StoragePoolBy1Status(Rest):

    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        uuid = param[1]

        if not validates_storage_pool(self, uuid):
            self.logger.debug("Get storage pool status failed. Did not validate.")
            return web.badrequest(self.view.alert)

        # Pool
        try:
            kvc = KaresansuiVirtConnection()
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            self.view.pools = pools

            pools_obj = kvc.get_storage_pool_UUIDString2kvn_storage_pool(uuid)
            if len(pools_obj) <= 0:
                self.logger.debug("Get storage pool status failed. Target storage pool not found.")
                return web.notfound()

            status = STORAGE_POOL_STOP
            if pools_obj[0].is_active() is True:
                status = STORAGE_POOL_START

            if self.__template__["media"] == 'json':
                self.view.status = json_dumps(status)
            else:
                self.view.status = status

            return True
        finally:
            kvc.close()

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        self.view.host_id = host_id
        uuid = param[1]

        if not validates_storage_pool(self, uuid):
            self.logger.debug("Set storage pool status failed. Did not validate.")
            return web.badrequest(self.view.alert)

        model = findbyhost1(self.orm, host_id)

        # Pool
        try:
            kvc = KaresansuiVirtConnection()
            inactive_pool = kvc.list_inactive_storage_pool()
            active_pool = kvc.list_active_storage_pool()
            pools = inactive_pool + active_pool
            pools.sort()

            self.view.pools = pools

            pools_obj = kvc.get_storage_pool_UUIDString2kvn_storage_pool(uuid)
            if len(pools_obj) <= 0:
                self.logger.debug("Set storage pool status failed. Target storage pool not found.")
                return web.notfound()

            status = int(self.input.status)
            if status == STORAGE_POOL_START:
                storagepool_start_stop_job(self, model, pools_obj[0], 'start')
            elif status == STORAGE_POOL_STOP:
                if kvc.is_used_storage_pool(name=pools_obj[0].get_storage_name(),
                                            active_only=True) is True:
                    self.logger.debug("Stop storage pool failed. Target storage pool is used by guest.")
                    return web.badrequest("Target storage pool is used by guest.")
                else:
                    storagepool_start_stop_job(self, model, pools_obj[0], 'stop')
            else:
                self.logger.debug("Set storage pool status failed. Unknown status type.")
                return web.badrequest()

            return web.accepted()
        finally:
            kvc.close()

def storagepool_start_stop_job(obj, host, pool_obj, status):
    _iscsi_job = None

    if status == 'start':
        pool_info = pool_obj.get_info()
        if pool_info['type'].lower() == "iscsi":
            _cmd = dict2command(
                "%s/%s" % (karesansui.config['application.bin.dir'], ISCSI_COMMAND_START),
                {"iqn" : pool_info['source']['dev_path']})
            cmdname = "Start iSCSI"
            _iscsi_job = Job('%s command' % cmdname, 0, _cmd)

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_START_STORAGE_POOL),
            {"name" : pool_obj.get_storage_name()})
        cmdname = "Start Storage Pool"
    else:
        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'], VIRT_COMMAND_DESTROY_STORAGE_POOL),
            {"name" : pool_obj.get_storage_name()})
        cmdname = "Stop Storage Pool"

    _jobgroup = JobGroup(cmdname, karesansui.sheconf['env.uniqkey'])

    if _iscsi_job:
        _jobgroup.jobs.append(_iscsi_job)
        _job = Job('%s command' % cmdname, 1, _cmd)
    else:
        _job = Job('%s command' % cmdname, 0, _cmd)

    _jobgroup.jobs.append(_job)

    _machine2jobgroup = m2j_new(machine=host,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=obj.me,
                                modified_user=obj.me,
                                )

    save_job_collaboration(obj.orm,
                           obj.pysilhouette.orm,
                           _machine2jobgroup,
                           _jobgroup,
                           )

urls = (
    '/host/(\d+)/storagepool/([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12})/status/?(\.part)$', HostBy1StoragePoolBy1Status,
    )

########NEW FILE########
__FILENAME__ = hostby1watch
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import string
import re
import karesansui

from karesansui.lib.rest import Rest, auth
from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.search import validates_query

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_ONLYSPACE, \
    CHECK_LENGTH, CHECK_MIN, CHECK_MAX

from karesansui.db.access.watch import \
    findbyall as w_findbyall, findby1 as w_findby1, \
    findby1name as w_findby1name, findbyname_or_plugin as w_findbyname_or_plugin, \
    new as w_new, is_uniq_duplication as w_is_uniq_duplication, save as w_save

from karesansui.db.access.machine import \
     findby1 as m_findby1

from karesansui.lib.utils import is_param, get_karesansui_version, \
    get_proc_cpuinfo, get_proc_meminfo, get_hdd_list, \
    get_partition_info, get_ifconfig_info, get_fs_info

from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.collectd.config import set_threshold
from karesansui.db.access.machine import findbyhost1 as m_findbyhost1, \
	findbyguest1 as m_findbyguest1

from karesansui.lib.collectd.utils import  create_plugin_selector, \
     get_collectd_version, create_threshold_value

from karesansui.lib.const import WATCH_LIST_RANGE, WATCH_PLUGINS, \
    COLLECTD_PLUGIN_CPU,           COLLECTD_PLUGIN_DF, \
    COLLECTD_PLUGIN_INTERFACE,     COLLECTD_PLUGIN_LIBVIRT, \
    COLLECTD_PLUGIN_MEMORY,        COLLECTD_PLUGIN_LOAD, \
    COLLECTD_CPU_TYPE,             COLLECTD_CPU_TYPE_INSTANCE, \
    COLLECTD_CPU_DS,               COLLECTD_MEMORY_TYPE, \
    COLLECTD_MEMORY_TYPE_INSTANCE, COLLECTD_MEMORY_DS,\
    COLLECTD_DF_TYPE,              COLLECTD_DF_DS, \
    COLLECTD_INTERFACE_TYPE,       COLLECTD_INTERFACE_DS, \
    COLLECTD_LIBVIRT_TYPE,         COLLECTD_LOAD_TYPE, \
    COLLECTD_LOAD_DS,              DEFAULT_LANGS, \
    CONTINUATION_COUNT_MIN,        CONTINUATION_COUNT_MAX, \
    PROHIBITION_PERIOD_MIN,        PROHIBITION_PERIOD_MAX, \
    FQDN_MIN_LENGTH,               FQDN_MAX_LENGTH, \
    PORT_MIN_NUMBER,               PORT_MAX_NUMBER, \
    EMAIL_MIN_LENGTH,              EMAIL_MAX_LENGTH, \
    THRESHOLD_VAL_MIN, \
    DEFAULT_ALERT_TRIGGER_COUNT, DEFAULT_SLIENT_PERIOD

def validates_watch(obj):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'watch_name'):
        check = checker.check_string(_('Name'),
                                     obj.input.watch_name,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Name'))

    if is_param(obj.input, 'watch_target'):
        check = checker.check_string(_('Watch Target'),
                                     obj.input.watch_target,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     ) and check
        if obj.input.watch_target not in WATCH_PLUGINS.values():
            check = False
            # TRANSLATORS:
            #  %sは監視対象ではありません。
            checker.add_error(_('"%s" is not watch target.') %_(obj.input.watch_target))
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Watch Target'))

    if is_param(obj.input, 'continuation_count'):
        check = checker.check_number(_('Alert Trigger Count'),
                                     obj.input.continuation_count,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     CONTINUATION_COUNT_MIN,
                                     CONTINUATION_COUNT_MAX,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Alert Trigger Count'))

    if is_param(obj.input, 'prohibition_period'):
        check = checker.check_number(_('Silent Period'),
                                     obj.input.prohibition_period,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     PROHIBITION_PERIOD_MIN,
                                     PROHIBITION_PERIOD_MAX,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Silent Period'))

    if is_param(obj.input, 'threshold_fraction'):
        fraction = int(obj.input.threshold_fraction)
    else:
        fraction = 0

    if is_param(obj.input, 'threshold_val1'):
        if fraction == 0:
            check = checker.check_number(_('Threshold Value'),
                                         obj.input.threshold_val1,
                                         CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                         THRESHOLD_VAL_MIN,
                                         None,
                                         ) and check
        else:
            check = checker.check_fraction(_('Threshold Value'),
                                           obj.input.threshold_val1,
                                           CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                           THRESHOLD_VAL_MIN,
                                           None,
                                           fraction,
                                           ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Value'))

    if is_param(obj.input, 'threshold_val2'):
        if fraction == 0:
            check = checker.check_number(_('Threshold Value'),
                                         obj.input.threshold_val2,
                                         CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                         THRESHOLD_VAL_MIN,
                                         None,
                                         ) and check
        else:
            check = checker.check_fraction(_('Threshold Value'),
                                           obj.input.threshold_val2,
                                           CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                           THRESHOLD_VAL_MIN,
                                           None,
                                           fraction,
                                           ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Value'))

    if not is_param(obj.input, 'threshold_type'):
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Type'))

    if is_param(obj.input, 'notify_mail_to'):
        if obj.input.notify_mail_to != "":
            check = checker.check_mailaddress(_('Mail To'),
                                              obj.input.notify_mail_to,
                                              CHECK_LENGTH | CHECK_VALID,
                                              EMAIL_MIN_LENGTH,
                                              EMAIL_MAX_LENGTH,
                                              ) and check

    if is_param(obj.input, 'notify_mail_from'):
        if obj.input.notify_mail_from != "":
            check = checker.check_mailaddress(_('Mail From'),
                                              obj.input.notify_mail_from,
                                              CHECK_LENGTH | CHECK_VALID,
                                              EMAIL_MIN_LENGTH,
                                              EMAIL_MAX_LENGTH,
                                              ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1Watch(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if self.is_mode_input() is True:
            self.view.plugins = WATCH_PLUGINS
            self.view.cpu_type_instance = COLLECTD_CPU_TYPE_INSTANCE
            self.view.memory_type_instance = COLLECTD_MEMORY_TYPE_INSTANCE
            self.view.df_ds = COLLECTD_DF_DS
            self.view.interface_type = COLLECTD_INTERFACE_TYPE
            self.view.interface_ds = COLLECTD_INTERFACE_DS
            self.view.load_ds = COLLECTD_LOAD_DS

            cpu_logical_number = len(get_proc_cpuinfo())
            self.view.cpu_logical_number = range(1, cpu_logical_number+1)
            self.view.memory_size = string.atol(get_proc_meminfo()["MemTotal"][0]) / 1024
            self.view.df_list = get_fs_info()
            self.view.interface_list = get_ifconfig_info().keys()

            ## guest os list
            from karesansui.lib.utils import get_dom_list
            from karesansui.lib.virt.virt import KaresansuiVirtConnection
            from karesansui.lib.merge import MergeGuest
            self.view.dom_list = get_dom_list()

            dom_info = {}
            for domname in get_dom_list():
                kvc = KaresansuiVirtConnection()
                virt = kvc.search_kvg_guests(domname)[0]
                dom_info[domname] = {}
                dom_info[domname]['network'] = []
                dom_info[domname]['disk'] = []
                dom_info[domname]['disk_size'] = {}
                for net_dev in virt.get_interface_info():
                    dom_info[domname]['network'].append(net_dev['target']['dev'])
                for disk in virt.get_disk_info():
                    dom_info[domname]['disk'].append(disk['target']['dev'])
                    dom_info[domname]['disk_size'][disk['target']['dev']] = disk['source']['size']

                dom_info[domname]['vcpu'] = virt.get_vcpus_info()['max_vcpus']
                kvc.close()
            self.view.dom_info = dom_info

            ## disk info 
            self.view.disk_size_info = {}
            for disk_data in get_fs_info():
                self.view.disk_size_info[disk_data['Filesystem']] = disk_data['1048576-blocks']

            self.view.processer_num = len(get_proc_cpuinfo().keys())
            self.view.supported_langs = DEFAULT_LANGS.keys()
            self.view.myaddress = self.me.email
            self.view.mta = "%s:%s" % (karesansui.config['application.mail.server'],
                                       karesansui.config['application.mail.port'])
            self.view.alert_trigger_count = DEFAULT_ALERT_TRIGGER_COUNT;
            self.view.slient_period = DEFAULT_SLIENT_PERIOD;
            return True

        if not validates_query(self):
            self.logger.debug("Show watch is failed, "
                              "Invalid query value "
                              "- query=%s" % self.input.q)
            return web.badrequest(self.view.alert)

        if not validates_page(self):
            self.logger.debug("Show watch is failed, "
                              "Invalid page value - page=%s" % self.input.p)
            return web.badrequest(self.view.alert)

        if is_param(self.input, 'q') is True:
            watchs = w_findbyname_or_plugin(self.orm, self.input.q)
            if not watchs:
                self.logger.debug("Show watch is failed, "
                                  "Could not find watch "
                                  "- query=%s" % self.input.q)
                return web.nocontent()
            self.view.search_value = self.input.q
        else:
            watchs = w_findbyall(self.orm)
            self.view.search_value = ""

        if is_param(self.input, 'p') is True:
            start = int(self.input.p)
        else:
            start = 0

        pager = Pager(watchs, start, WATCH_LIST_RANGE)
        if not pager.exist_now_page() and is_param(self.input, 'p') is True:
            self.logger.debug("Show watch is failed, "
                              "Could not find page - page=%s" % self.input.p)
            return web.nocontent()

        self.view.pager = pager
        self.view.input = self.input

        return True

    @auth
    def _POST(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        if not validates_watch(self):
            self.logger.debug("Set watch failed. Did not validate.")
            return web.badrequest(self.view.alert)

        plugin = self.input.watch_target
        plugin_instance = None
        type = None
        type_instance = None
        plugin_ds = None
        libvirt_host = None

        if plugin == COLLECTD_PLUGIN_CPU:
            #cpu method
            plugin_instance = string.atoi(self.input.logical_cpu_number) - 1
            type_instance = self.input.cpu_status
            type = COLLECTD_CPU_TYPE
            plugin_ds = COLLECTD_CPU_DS

        elif plugin == COLLECTD_PLUGIN_MEMORY:
            #memory method
            type_instance = self.input.memory_status
            type = COLLECTD_MEMORY_TYPE
            plugin_ds = COLLECTD_MEMORY_DS

        elif plugin == COLLECTD_PLUGIN_DF:
            #df method
            type = COLLECTD_DF_TYPE
            type_instance = self.input.df_target_fs
            type_instance = re.sub(r'^/dev/', '', type_instance)
            type_instance = re.sub(r'/', '_', type_instance)
            plugin_ds = self.input.df_disk_status

        elif plugin == COLLECTD_PLUGIN_INTERFACE:
            #interface method
            type = self.input.network_status
            type_instance = self.input.network_target_interface
            plugin_ds = self.input.network_direction

        elif plugin == COLLECTD_PLUGIN_LIBVIRT:
            #libvirt method
            libvirt_host = self.input.libvirt_target_machine
            if self.input.libvirt_target == "cpu":
                if self.input.libvirt_vcpu_target == "total":
                    type = COLLECTD_LIBVIRT_TYPE['CPU_TOTAL']
                else:
                    type = COLLECTD_LIBVIRT_TYPE['VCPU']
                    type_instance = self.input.libvirt_vcpu_target

                plugin_ds = COLLECTD_CPU_DS

            elif self.input.libvirt_target == "disk":
                type = COLLECTD_LIBVIRT_TYPE['DISK_OCTETS']
                type_instance = self.input.libvirt_disk_target
                plugin_ds = self.input.libvirt_disk_value_type

            elif self.input.libvirt_target == "network":
                type = "if_" + self.input.libvirt_network_status
                type_instance = self.input.libvirt_target_interface
                plugin_ds = self.input.libvirt_network_direction

        elif plugin == COLLECTD_PLUGIN_LOAD:
            #load method
            type = COLLECTD_LOAD_TYPE
            plugin_ds = self.input.load_term

        else:
            self.logger.debug("Set watch failed. Unknown plugin type.")
            return web.badrequest()

        plugin_selector = create_plugin_selector(plugin_instance, type, type_instance, plugin_ds, libvirt_host)

        ## text
        continuation_count = self.input.continuation_count
        prohibition_period = self.input.prohibition_period
        threshold_val1     = self.input.threshold_val1
        threshold_val2     = self.input.threshold_val2
        threshold_type     = self.input.threshold_type
        if is_param(self.input, 'warning_script'):
            warning_script = self.input.warning_script
        else:
            warning_script = ""
        if is_param(self.input, 'warning_mail_body'):
            warning_mail_body = self.input.warning_mail_body
        else:
            warning_mail_body = ""
        if is_param(self.input, 'failure_script'):
            failure_script = self.input.failure_script
        else:
            failure_script = ""
        if is_param(self.input, 'failure_mail_body'):
            failure_mail_body = self.input.failure_mail_body
        else:
            failure_mail_body = ""
        if is_param(self.input, 'okay_script'):
            okay_script = self.input.okay_script
        else:
            okay_script = ""
        if is_param(self.input, 'okay_mail_body'):
            okay_mail_body = self.input.okay_mail_body
        else:
            okay_mail_body = ""
        if is_param(self.input, 'notify_mail_to'):
            notify_mail_to = self.input.notify_mail_to
        else:
            notify_mail_to = ""
        if is_param(self.input, 'notify_mail_from'):
            notify_mail_from = self.input.notify_mail_from
        else:
            notify_mail_from = ""

        ## bool
        bool_input_key = ["use_percentage", "enable_warning_mail",
                          "enable_failure_mail", "enable_okay_mail",
                          "enable_warning_script", "enable_failure_script",
                          "enable_okay_script"]
        bool_values = {}
        for key in bool_input_key:
            if self.input.has_key(key):
                bool_values.update({key:True})
            else:
                bool_values.update({key:False})

        if threshold_type == "max":
            warning_value = create_threshold_value(min_value=None, max_value=threshold_val1)
            failure_value = create_threshold_value(min_value=None, max_value=threshold_val2)
        elif threshold_type == "min":
            warning_value = create_threshold_value(min_value=threshold_val2, max_value=None)
            failure_value = create_threshold_value(min_value=threshold_val1, max_value=None)
        else:
            self.logger.debug("Set watch failed. Unknown threshold type.")
            return web.badrequest()

        machine = m_findby1(self.orm, host_id)

        if w_is_uniq_duplication(self.orm, machine, plugin, plugin_selector) is True:
            self.logger.debug("Set watch failed. Duplicate watch DB.")
            return web.badrequest("Set watch failed. Duplication watch")

        _watch = w_new(created_user          = self.me,
                       modified_user         = self.me,
                       name                  = self.input.watch_name,
                       plugin                = plugin,
                       plugin_selector       = plugin_selector,
                       karesansui_version    = get_karesansui_version(),
                       collectd_version      = get_collectd_version(),
                       machine               = machine,
                       continuation_count    = continuation_count,
                       prohibition_period    = prohibition_period,
                       warning_value         = warning_value,
                       is_warning_percentage = bool_values.get("use_percentage"),
                       is_warning_script     = bool_values.get("enable_warning_script"),
                       warning_script        = warning_script,
                       is_warning_mail       = bool_values.get("enable_warning_mail"),
                       warning_mail_body     = warning_mail_body,
                       failure_value         = failure_value,
                       is_failure_percentage = bool_values.get("use_percentage"),
                       is_failure_script     = bool_values.get("enable_failure_script"),
                       failure_script        = failure_script,
                       is_failure_mail       = bool_values.get("enable_failure_mail"),
                       failure_mail_body     = failure_mail_body,
                       is_okay_script        = bool_values.get("enable_okay_script"),
                       okay_script           = okay_script,
                       is_okay_mail          = bool_values.get("enable_okay_mail"),
                       okay_mail_body        = okay_mail_body,
                       notify_mail_to        = notify_mail_to,
                       notify_mail_from      = notify_mail_from,
                       is_deleted            = False,
                       )
        w_save(self.orm, _watch)

        modules = ["collectdplugin"]

        host = m_findbyhost1(self.orm, host_id)
        extra_args = {'include':'^threshold_'}
        #extra_args = {}
        dop = read_conf(modules, webobj=self, machine=host, extra_args=extra_args)
        if dop is False:
            self.logger.debug("Set watch failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read Conf)')

        params = {}
        if threshold_type == "max":
            params['WarningMax'] = str(threshold_val1)
            params['FailureMax'] = str(threshold_val2)
        elif threshold_type == "min":
            params['WarningMin'] = str(threshold_val2)
            params['FailureMin'] = str(threshold_val1)

        params['Percentage'] = str(bool_values.get("use_percentage")).lower()
        params['Persist']    = "true"
        set_threshold(plugin,plugin_selector,params,dop=dop,webobj=self, host=host)

        extra_args = {}
        command = "/etc/init.d/collectd condrestart"
        extra_args = {"post-command": command}
        retval = write_conf(dop,  webobj=self, machine=host, extra_args=extra_args)
        if retval is False:
            self.logger.debug("Set watch failed. Failed write conf.")
            return web.internalerror('Internal Server Error. (Write Conf)')

        return web.created(None)

urls = (
    '/host/(\d+)/watch/?(\.part)$', HostBy1Watch,
    )

########NEW FILE########
__FILENAME__ = hostby1watchby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import string
import re
import karesansui

from karesansui.lib.rest import Rest, auth
from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.search import validates_query

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_ONLYSPACE, \
    CHECK_LENGTH, CHECK_MIN, CHECK_MAX

from karesansui.db.access.watch import \
    findby1 as w_findby1, \
    logical_delete as w_delete, \
    update as w_update

from karesansui.db.access.machine import \
    findbyhost1 as m_findbyhost1

from karesansui.lib.utils import is_param, get_karesansui_version, \
    get_proc_cpuinfo, get_proc_meminfo, get_hdd_list, \
    get_partition_info, get_ifconfig_info, get_fs_info

from karesansui.lib.conf import read_conf, write_conf

from karesansui.lib.collectd.utils import plugin_selector_to_dict, \
    create_threshold_value, threshold_value_to_dict

from karesansui.lib.collectd.config import delete_threshold, \
    set_threshold

from karesansui.lib.const import COLLECTD_PLUGIN_CPU, \
    COLLECTD_PLUGIN_DF,      COLLECTD_PLUGIN_INTERFACE, \
    COLLECTD_PLUGIN_LIBVIRT, COLLECTD_PLUGIN_MEMORY, \
    COLLECTD_PLUGIN_LOAD,    COLLECTD_LIBVIRT_TYPE, \
    COLLECTD_INTERFACE_TYPE, DEFAULT_LANGS, \
    CONTINUATION_COUNT_MIN,  CONTINUATION_COUNT_MAX, \
    PROHIBITION_PERIOD_MIN,  PROHIBITION_PERIOD_MAX, \
    FQDN_MIN_LENGTH,         FQDN_MAX_LENGTH, \
    PORT_MIN_NUMBER,         PORT_MAX_NUMBER, \
    EMAIL_MIN_LENGTH,        EMAIL_MAX_LENGTH, \
    THRESHOLD_VAL_MIN,	     WATCH_INTERVAL, \
    WATCH_PLUGINS

def validates_watch(obj):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'watch_name'):
        check = checker.check_string(_('Watch Name'),
                                     obj.input.watch_name,
                                     CHECK_EMPTY | CHECK_ONLYSPACE,
                                     None,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Watch Name'))

    if is_param(obj.input, 'continuation_count'):
        check = checker.check_number(_('Alert Trigger Count'),
                                     obj.input.continuation_count,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     CONTINUATION_COUNT_MIN,
                                     CONTINUATION_COUNT_MAX,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Alert Trigger Count'))
    if is_param(obj.input, 'prohibition_period'):
        check = checker.check_number(_('Silent Period'),
                                     obj.input.prohibition_period,
                                     CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                                     PROHIBITION_PERIOD_MIN,
                                     PROHIBITION_PERIOD_MAX,
                                     ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Silent Period'))

    if is_param(obj.input, 'threshold_fraction'):
        fraction = int(obj.input.threshold_fraction)
    else:
        fraction = 0

    if is_param(obj.input, 'threshold_val1'):
        if fraction == 0:
            check = checker.check_number(_('Threshold Value'),
                                         obj.input.threshold_val1,
                                         CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                         THRESHOLD_VAL_MIN,
                                         None,
                                         ) and check
        else:
            check = checker.check_fraction(_('Threshold Value'),
                                           obj.input.threshold_val1,
                                           CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                           THRESHOLD_VAL_MIN,
                                           None,
                                           fraction,
                                           ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Value'))

    if is_param(obj.input, 'threshold_val2'):
        if fraction == 0:
            check = checker.check_number(_('Threshold Value'),
                                         obj.input.threshold_val2,
                                         CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                         THRESHOLD_VAL_MIN,
                                         None,
                                         ) and check
        else:
            check = checker.check_fraction(_('Threshold Value'),
                                           obj.input.threshold_val2,
                                           CHECK_EMPTY | CHECK_VALID | CHECK_MIN,
                                           THRESHOLD_VAL_MIN,
                                           None,
                                           fraction,
                                           ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Value'))

    if not is_param(obj.input, 'threshold_type'):
        check = False
        checker.add_error(_('"%s" is required.') %_('Threshold Type'))

    if is_param(obj.input, 'notify_mail_to'):
        if obj.input.notify_mail_to != "":
            check = checker.check_mailaddress(_('Mail To'),
                                              obj.input.notify_mail_to,
                                              CHECK_LENGTH | CHECK_VALID,
                                              EMAIL_MIN_LENGTH,
                                              EMAIL_MAX_LENGTH,
                                              ) and check

    if is_param(obj.input, 'notify_mail_from'):
        if obj.input.notify_mail_from != "":
            check = checker.check_mailaddress(_('Mail From'),
                                              obj.input.notify_mail_from,
                                              CHECK_LENGTH | CHECK_VALID,
                                              EMAIL_MIN_LENGTH,
                                              EMAIL_MAX_LENGTH,
                                              ) and check

    obj.view.alert = checker.errors
    return check

class HostBy1WatchBy1(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        watch_id = param[1]
        if watch_id is None: return web.notfound()

        watch = w_findby1(self.orm, watch_id)
        self.view.watch = watch
        self.view.plugins = WATCH_PLUGINS

        plugin_selector = plugin_selector_to_dict(watch.plugin_selector)
        self.view.plugin_selector = plugin_selector

        if watch.plugin == COLLECTD_PLUGIN_LIBVIRT:
            libvirt_type = ""
            if plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['VCPU']:
                libvirt_type = "vcpu"
            elif plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['CPU_TOTAL']:
                libvirt_type = "cpu_total"
            elif plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['DISK_OPS'] or \
                    plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['DISK_OCTETS']:
                libvirt_type = "disk"
            elif plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['IF_OCTETS'] or \
                    plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['IF_PACKETS'] or \
                    plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['IF_ERRORS'] or \
                    plugin_selector['type'] == COLLECTD_LIBVIRT_TYPE['IF_DROPPED']:
                libvirt_type = "interface"

            self.view.libvirt_type = libvirt_type

        if self.is_mode_input() is True:
            warning_value = threshold_value_to_dict(watch.warning_value)
            failure_value = threshold_value_to_dict(watch.failure_value)
            self.view.threshold_value_1 = warning_value.values()[0]
            self.view.threshold_value_2 = failure_value.values()[0]
            self.view.threshold_type = failure_value.keys()[0]
            self.view.use_percentage = watch.is_failure_percentage

            self.view.supported_langs = DEFAULT_LANGS.keys()

        self.view.memory_size = string.atol(get_proc_meminfo()["MemTotal"][0]) / 1024
        ## disk info 
        self.view.disk_size_info = {}
        for disk_data in get_fs_info():
            disk_target = re.sub(r'^/dev/', '', disk_data['Filesystem'])
            disk_target = re.sub(r'/', '_', disk_target)
            self.view.disk_size_info[disk_target] = disk_data['1048576-blocks']
        self.view.interface_type = COLLECTD_INTERFACE_TYPE
        self.view.processer_num = len(get_proc_cpuinfo().keys())
        self.view.mta = "%s:%s" % (karesansui.config['application.mail.server'],
                                   karesansui.config['application.mail.port'])
        self.view.watch_interval = WATCH_INTERVAL

        return True

    @auth
    def _PUT(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        watch_id = param[1]
        if watch_id is None: return web.notfound()

        if not validates_watch(self):
            self.logger.debug("Change watch failed. Did not validate.")
            return web.badrequest(self.view.alert)

        watch = w_findby1(self.orm, watch_id)

        ## text
        watch.name               = self.input.watch_name
        watch.continuation_count = self.input.continuation_count
        watch.prohibition_period = self.input.prohibition_period
        if is_param(self.input, 'warning_script'):
            watch.warning_script = self.input.warning_script
        else:
            watch.warning_script = ""
        if is_param(self.input, 'warning_mail_body'):
            watch.warning_mail_body = self.input.warning_mail_body
        else:
            watch.warning_mail_body = ""
        if is_param(self.input, 'failure_script'):
            watch.failure_script = self.input.failure_script
        else:
            watch.failure_script = ""
        if is_param(self.input, 'failure_mail_body'):
            watch.failure_mail_body = self.input.failure_mail_body
        else:
            watch.failure_mail_body = ""
        if is_param(self.input, 'okay_script'):
            watch.okay_script = self.input.okay_script
        else:
            watch.okay_script = ""
        if is_param(self.input, 'okay_mail_body'):
            watch.okay_mail_body = self.input.okay_mail_body
        else:
            watch.okay_mail_body = ""
        if is_param(self.input, 'notify_mail_to'):
            watch.notify_mail_to = self.input.notify_mail_to
        else:
            watch.notify_mail_to = ""
        if is_param(self.input, 'notify_mail_from'):
            watch.notify_mail_from = self.input.notify_mail_from
        else:
            watch.notify_mail_from = ""

        threshold_val1 = self.input.threshold_val1
        threshold_val2 = self.input.threshold_val2
        threshold_type = self.input.threshold_type
        if threshold_type == "max":
            warning_value = create_threshold_value(min_value=None, max_value=threshold_val1)
            failure_value = create_threshold_value(min_value=None, max_value=threshold_val2)
        elif threshold_type == "min":
            warning_value = create_threshold_value(min_value=threshold_val2, max_value=None)
            failure_value = create_threshold_value(min_value=threshold_val1, max_value=None)
        else:
            self.logger.debug("Update watch failed. Unknown threshold type.")
            return web.badrequest()

        watch.warning_value = warning_value
        watch.failure_value = failure_value

        ## bool
        bool_input_key = ["use_percentage", "enable_warning_mail",
                          "enable_failure_mail", "enable_okay_mail",
                          "enable_warning_script", "enable_failure_script",
                          "enable_okay_script"]
        bool_values = {}
        for key in bool_input_key:
            if self.input.has_key(key):
                bool_values.update({key:True})
            else:
                bool_values.update({key:False})

        watch.is_warning_percentage = bool_values.get("use_percentage")
        watch.is_warning_script     = bool_values.get("enable_warning_script")
        watch.is_warning_mail       = bool_values.get("enable_warning_mail")
        watch.is_failure_percentage = bool_values.get("use_percentage")
        watch.is_failure_script     = bool_values.get("enable_failure_script")
        watch.is_failure_mail       = bool_values.get("enable_failure_mail")
        watch.is_okay_script        = bool_values.get("enable_okay_script")
        watch.is_okay_mail          = bool_values.get("enable_okay_mail")

        w_update(self.orm, watch)

        plugin = watch.plugin
        plugin_selector = watch.plugin_selector
        modules = ["collectdplugin"]

        host = m_findbyhost1(self.orm, host_id)
        extra_args = {'include':'^threshold_'}
        #extra_args = {}
        dop = read_conf(modules, webobj=self, machine=host, extra_args=extra_args)
        if dop is False:
            self.logger.debug("Change watch failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read Conf)')

        params = {}
        if threshold_type == "max":
            params['WarningMax'] = str(threshold_val1)
            params['FailureMax'] = str(threshold_val2)
        elif threshold_type == "min":
            params['WarningMin'] = str(threshold_val2)
            params['FailureMin'] = str(threshold_val1)

        params['Percentage'] = str(bool_values.get("use_percentage")).lower()
        params['Persist']    = "true"
        delete_threshold(plugin, plugin_selector, dop=dop, webobj=self, host=host)
        set_threshold(plugin,plugin_selector,params,dop=dop,webobj=self, host=host)

        extra_args = {}
        command = "/etc/init.d/collectd condrestart"
        extra_args = {"post-command": command}
        retval = write_conf(dop,  webobj=self, machine=host, extra_args=extra_args)
        if retval is False:
            self.logger.debug("Change watch failed. Failed write conf.")
            return web.internalerror('Internal Server Error. (Write Conf)')

        return web.accepted()

    @auth
    def _DELETE(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        watch_id = param[1]
        if watch_id is None: return web.notfound()

        watch = w_findby1(self.orm, watch_id)
        w_delete(self.orm, watch)

        # delete setting file
        plugin = watch.plugin
        plugin_selector = watch.plugin_selector
        modules = ["collectdplugin"]
        host_id = self.chk_hostby1(param)
        host = m_findbyhost1(self.orm, host_id)

        ## read config and delete threashold
        extra_args = {'include':'^threshold_'}
        dop = read_conf(modules, webobj=self, machine=host, extra_args=extra_args)
        if dop is False:
            self.logger.debug("Delete watch failed. Failed read conf.")
            return web.internalerror('Internal Server Error. (Read Conf)')
        delete_threshold(plugin, plugin_selector, dop=dop, webobj=self, host=host)

        ## apply setting and collectd restart
        command = "/etc/init.d/collectd condrestart"
        extra_args = {"post-command": command}
        retval = write_conf(dop, webobj=self, machine=host, extra_args=extra_args)
        if retval is False:
            self.logger.debug("Delete watch failed. Failed write conf.")
            return web.internalerror('Internal Server Error. (Write Conf)')

        return web.accepted()

urls = (
    '/host/(\d+)/watch/(\d+)/?(\.part)$', HostBy1WatchBy1,
    )

########NEW FILE########
__FILENAME__ = hostby1watchtemplate
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.utils import read_file, json_dumps
from karesansui.lib.const import TEMPLATE_DIR, \
    MAIL_TEMPLATE_COLLECTD_WARNING, \
    MAIL_TEMPLATE_COLLECTD_FAILURE, \
    MAIL_TEMPLATE_COLLECTD_OKAY, \
    WATCH_PLUGINS, DEFAULT_LANGS

from karesansui.lib.checker import Checker

def validates_watch(obj, target, lang):
    checker = Checker()
    check = True
    _ = obj._
    checker.errors = []

    if target not in WATCH_PLUGINS.values():
        check = False
        checker.add_error(_('"%s" is not watch target.') %_(target))

    if lang not in DEFAULT_LANGS:
        check = False
        checker.add_error(_('"%s" is not supported language.') %_(lang))

    obj.view.alert = checker.errors
    return check

class HostBy1WatchTemplate(Rest):
    @auth
    def _GET(self, *param, **params):
        host_id = self.chk_hostby1(param)
        if host_id is None: return web.notfound()

        target = param[1]
        if target is None: return web.notfound()

        lang = param[2]
        if lang is None: return web.notfound()

        if not validates_watch(self, target, lang):
            self.logger.debug("Get watch mail template failed. Did not validate.")
            return web.badrequest(self.view.alert)

        template_dir = "%s/%s" % (TEMPLATE_DIR,lang[0:2],)

        mail_template_warning = read_file("%s/%s" % (template_dir,MAIL_TEMPLATE_COLLECTD_WARNING[target]))
        mail_template_failure = read_file("%s/%s" % (template_dir,MAIL_TEMPLATE_COLLECTD_FAILURE[target]))
        mail_template_okay = read_file("%s/%s" % (template_dir,MAIL_TEMPLATE_COLLECTD_OKAY[target]))

        data = {
            "mail_template_warning" : mail_template_warning,
            "mail_template_failure" : mail_template_failure,
            "mail_template_okay" : mail_template_okay,
            }

        self.view.data = json_dumps(data)
        return True

urls = (
    '/host/(\d+)/watch/([a-zA-Z0-9]+)/([a-z]{2}|[a-z]{2}_[A-Z]{2})?(\.json)$', HostBy1WatchTemplate,
    )

########NEW FILE########
__FILENAME__ = hosttag
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.checker import Checker, \
     CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_CHAR
from karesansui.lib.utils import is_param, json_dumps
from karesansui.db.access.tag import findbyhostall, findbyhostall

class HostTag(Rest):
    @auth
    def _GET(self, *param, **params):
        tags = findbyhostall(self.orm)
        if not tags:
            return web.notfound(self._("No tag"))

        if self.is_part() is True:
            self.view.tags = tags
            machine_ids = {} 
            for tag in tags:
                tag_id = str(tag.id)

                machine_ids[tag_id] = []
                for machine in tag.machine:
                    machine_ids[tag_id].append("tag_machine%s"%  machine.id)

                machine_ids[tag_id]  = " ".join(machine_ids[tag_id])

            self.view.machine_ids = machine_ids

            return True

        elif self.is_json() is True:
            tags_json = []
            for tag in tags:
                tags_json.append(tag.get_json(self.me.languages))

            self.view.tags = json_dumps(tags_json)

            return True
        
        else:
            return web.nomethod()

urls = (
    '/host/tag/?(\.part|\.json)$', HostTag,
    )

########NEW FILE########
__FILENAME__ = icon
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import os.path
import imghdr

import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_MIN, CHECK_MAX
from karesansui.lib.const import ICON_DIR_TPL
from karesansui.lib.utils import \
    create_file, remove_file, uniq_filename, is_param, is_path

def validates_icon(obj):
    checker = Checker()
    check = True
          
    _ = obj._ 
    checker.errors = []

    if is_param(obj.input, 'multi_icon'):
        check = checker.check_image(
                    _('Machine Icon'),
                    obj.input.multi_icon.value,
                    CHECK_EMPTY | CHECK_VALID,
                    None,
                    None,
            ) and check

    obj.view.alert = checker.errors
    return check

def add_prefix(msg, prefix):
    if isinstance(msg, str):
        msg = [msg]

    for i in xrange(len(msg)):
        msg[i] =  prefix + ":" + msg[i]
    return msg

class Icon(Rest):
    @auth
    def _POST(self, *param, **params):
        if not validates_icon(self):
            self.logger.debug("Create Icon is failed, Invalid input value")
            return web.badrequest(add_prefix(self.view.alert, "400"))

        icon_filevalue = self.input.multi_icon.value
        icon_filename = "%s.%s" % (uniq_filename(), imghdr.what(None, icon_filevalue))

        if is_path(icon_filename) is True:
            return web.badrequest("Not to include the path.")

        icon_realpath = ICON_DIR_TPL % (karesansui.dirname, icon_filename)
        icon_webpath = ICON_DIR_TPL % (web.ctx.homepath, icon_filename)

        if os.path.exists(icon_realpath):
            web.conflict(icon_webpath, add_prefix("icon already exists", "409"))

        try:
            create_file(icon_realpath, icon_filevalue)
        except IOError, ioe:
            self.logger.error("Failed to write icon file. - filename=%s" % icon_filename)
            return web.internalerror(add_prefix("Failed to create icon file.", "500"))

        return web.created(icon_webpath, icon_filename)

class IconBy1(Rest):
    @auth
    def _DELETE(self, *param, **params):
        icon_filename = param[0]
        if is_path(icon_filename) is True:
            return web.badrequest("Not to include the path.")

        icon_realpath = ICON_DIR_TPL % (karesansui.dirname, icon_filename)

        if not os.path.exists(icon_realpath):
            return web.notfound("icon not exists")

        try:
            remove_file(icon_realpath)
        except OSError, ose:
            self.logger.error("Failed to remove icon file. - filename=%s" % icon_filename)
            raise  # return 500(Internal Server Error)

        return web.seeother("/")

urls = (
    '/icon/(.+)/?$', IconBy1,
    '/icon/?$', Icon,
    )

########NEW FILE########
__FILENAME__ = index
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from karesansui.lib.rest import Rest, auth
import karesansui.gadget.host

class Index(Rest):
    @auth
    def _GET(self, *param, **params):
        return True

urls = ('/', karesansui.gadget.host.Host)

########NEW FILE########
__FILENAME__ = init
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import socket
import karesansui
import web
from karesansui.lib.rest import Rest, auth

from karesansui.lib.utils import is_uuid, is_int, karesansui_database_exists
from karesansui.lib.utils import generate_phrase, generate_uuid, string_from_uuid

from karesansui.lib.file.k2v import K2V
from karesansui.lib.crypt import sha1encrypt, sha1compare
from karesansui.lib.const import MACHINE_ATTRIBUTE, MACHINE_HYPERVISOR
from karesansui.db import get_engine, get_metadata, get_session
from karesansui.db.model.user import User
from karesansui.db.model.notebook import Notebook
from karesansui.db.model.tag import Tag
from karesansui.db.model.machine import Machine

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE
from karesansui.lib.const import \
    DEFAULT_LANGS, USER_LIST_RANGE, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    USER_MIN_LENGTH, USER_MAX_LENGTH, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    PASSWORD_MIN_LENGTH, PASSWORD_MAX_LENGTH, \
    LANGUAGES_MIN_LENGTH, LANGUAGES_MAX_LENGTH, \
    ID_MIN_LENGTH, ID_MAX_LENGTH

from karesansui.lib.utils import is_param, is_empty

def validates_user(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'nickname'):
        check = False
        checker.add_error(_('"%s" is required.') % _('User Name'))
    else:
        check = checker.check_username(
                _('User Name'),
                obj.input.nickname,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                min = USER_MIN_LENGTH,
                max = USER_MAX_LENGTH,
                ) and check

    if not is_param(obj.input, 'email'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Mail Address'))
    else:
        check = checker.check_mailaddress(
                _('Mail Address'),
                obj.input.email,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                min = EMAIL_MIN_LENGTH,
                max = EMAIL_MAX_LENGTH,
                ) and check

    _password_flag = True
    if not is_param(obj.input, 'password'):
        check = False
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('Password'))
    if not is_param(obj.input, 'retype'):
        check = False
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('Retype'))

    if _password_flag == True:
        if not is_empty(obj.input.password) or \
           not is_empty(obj.input.retype):
            check = checker.check_password(
                    _('Password'),
                    obj.input.password,
                    obj.input.password,
                    CHECK_EMPTY | CHECK_LENGTH,
                    min = PASSWORD_MIN_LENGTH,
                    max = PASSWORD_MAX_LENGTH,
                    ) and check

    check = checker.check_languages(
            _('Language'),
            obj.input.languages,
            CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
            min = LANGUAGES_MIN_LENGTH,
            max = LANGUAGES_MAX_LENGTH,
            ) and check

    obj.view.alert = checker.errors
    return check

class Init(Rest):

    def _GET(self, *param, **params):

        self.view.database_bind = karesansui.config['database.bind'] 
        self.view.default_locale = karesansui.config['application.default.locale'] 
        self.view.locales = DEFAULT_LANGS.keys()

        if karesansui_database_exists() is True:
            return web.tempredirect("/", absolute=False)

        if self.is_mode_input():
            return True
        else:
            return True
 
        return True

    def _POST(self, *param, **params):

        if not validates_user(self):
            return web.badrequest(self.view.alert)

        engine = get_engine()
        metadata = get_metadata()
        session = get_session()

        try:
            metadata.drop_all()   
            metadata.tables['machine2jobgroup'].create()
            metadata.create_all()   
        except Exception, e:
            traceback.format_exc()
            raise Exception('Initializing/Updating a database error - %s' % ''.join(e.args))

        (password, salt) = sha1encrypt(self.input.password)

        user  = User(u"%s" % self.input.email,
                              unicode(password),
                              unicode(salt),
                              u"%s" % self.input.nickname,
                              u"%s" % self.input.languages,
                              )
        session.add(user)
        session.commit()

        # Tag Table set.
        tag = Tag(u"default")
        session.add(tag)
        session.commit()
        
        # Machine Table set.
        #user = session.query(User).filter(User.email == self.input.email).first()
        uuid = string_from_uuid(generate_uuid())
        fqdn = socket.gethostname() 
        notebook = Notebook(u"", u"")
        machine  = Machine(user,
                       user,
                       u"%s" % uuid,
                       u"%s" % fqdn,
                       MACHINE_ATTRIBUTE['HOST'],
                       MACHINE_HYPERVISOR['REAL'],
                       notebook,
                       [tag],
                       u"%s" % fqdn,
                       u'icon-guest1.png',
                       False,
                       None,
                      )
        session.add(machine)
        session.commit()

        session.close()

        return web.created(None)

urls = ('/init/?(\.part)?$', Init,)

########NEW FILE########
__FILENAME__ = job
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import karesansui
import simplejson as json
from karesansui.lib.rest import Rest, auth
from karesansui.lib.search import validates_jobsearch
from karesansui.lib.const import JOB_LIST_RANGE, DEFAULT_LANGS, MACHINE_HYPERVISOR
from karesansui.lib.pager import Pager
from karesansui.lib.utils import str2datetime, is_param, is_empty
from karesansui.db.access._2pysilhouette import jg_findbyalltype, jg_findby1

from karesansui.db.access.machine_machine2jobgroup import \
     findbyall as m2mj_findbyall, findbyjobgroup_id1 as m2mj_findby1

from karesansui.db.access.user import findbyname_BM

from karesansui.db.model._2pysilhouette import \
     Job, JobGroup, JOBGROUP_STATUS, JOBGROUP_TYPE

class Job(Rest):

    @auth
    def _GET(self, *param, **params):
        (check, edit) = validates_jobsearch(self)
        if check is False:
            return web.badrequest(self.view.alert)

        if edit is True:
            # user search
            users = findbyname_BM(self.orm, self.input.user)
            users_id = []
            for user in users:
                users_id.append(user.id)

            machine_name = self.input.name.strip()
            if is_empty(machine_name):
                machine_name = None
            
            if is_empty(self.input.start):
                start = None
            else:
                start = str2datetime(self.input.start,
                                     DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0])
            if is_empty(self.input.end):
                end = None
            else:
                end = str2datetime(self.input.end,
                                   DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][0],True)

            # machine search
            m_m2js = m2mj_findbyall(self.orm,
                           machine_name,
                           start,
                           end,
                           users_id,
                           True
                           )
            if not m_m2js:
                self.logger.debug("Search m_m2js failed. "
                                  "Did not exist m_m2js that in accord with these query. "
                                  "name %s, user_id %s, start %s, end %s" % (machine_name, users_id, start, end))
                return web.nocontent()
            
            self.view.m_m2js = m_m2js
            self.view.name = self.input.name
            self.view.user = self.input.user
            self.view.status = self.input.status
            self.view.start = self.input.start
            self.view.end = self.input.end

            jobgroup_ids = []
            for m_m2j in m_m2js:
                 jobgroup_ids.append(m_m2j[1].jobgroup_id)
            jobgroup_status = self.input.status
            if is_empty(jobgroup_status):
                jobgroup_status = None

            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                                         jobgroup_ids, jobgroup_status, desc=True)
            if not jobgroups:
                self.logger.debug("Search jobgroups failed. "
                                  "Did not exist jobgroups that in accord with these query. "
                                  "jobgroup_ids %s, jobgroup_status %s" % (jobgroup_ids, jobgroup_status))
                return web.nocontent()
            
        else:
            m_m2js = m2mj_findbyall(self.orm)
            self.view.m_m2js = m_m2js
            self.view.name   = ''
            self.view.user   = ''
            self.view.status = ''
            self.view.start  = ''
            self.view.end    = ''

            self.view.m_m2js = m_m2js

            jobgroup_ids = []
            for m_m2j in m_m2js:
                 jobgroup_ids.append(m_m2j[1].jobgroup_id)
                 
            jobgroups = jg_findbyalltype(self.pysilhouette.orm, JOBGROUP_TYPE["SERIAL"],
                                         jobgroup_ids, desc=True)
        
        self.view.JOBGROUP_STATUS = JOBGROUP_STATUS
        self.view.HYPERVISOR = MACHINE_HYPERVISOR
 
        if self.input.has_key('p') is True:
            start = int(self.input.p)
        else:
            start = 0
        self.view.date_format = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][1] 
        self.view.pager = Pager(jobgroups, start, JOB_LIST_RANGE)

        return True


class JobBy1(Rest):
    
    @auth
    def _GET(self, *param, **params):
        jg_id = param[0]
        jg = jg_findby1(self.pysilhouette.orm, jg_id)
        if jg is None:
            return web.notfound()
        m2mj = m2mj_findby1(self.orm, jg.id)

        self.view.jg = jg
        self.view.m2mj = m2mj
        self.view.JOBGROUP_STATUS = JOBGROUP_STATUS
        self.view.HYPERVISOR = MACHINE_HYPERVISOR
        self.view.date_format = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][1] 
        self.view.job_count = len(jg.jobs)

        return True

urls = (
    '/job/(\d+)/?(\.part)$', JobBy1,
    '/job/?(\.part)$', Job,
    )

########NEW FILE########
__FILENAME__ = logout
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.rest import Rest

class Logout(Rest):

    def _GET(self, *param, **params):
        return True

urls = ('/logout/?$', Logout,)

########NEW FILE########
__FILENAME__ = mail
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
@authors: Kazuya Hayashi <kazuya@karesansui-project.info>
"""

import os.path
from os import environ as env 

import web

from karesansui import KaresansuiGadgetException
from karesansui.lib.file.k2v import K2V
from karesansui.lib.rest import Rest, auth
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX, CHECK_LENGTH
from karesansui.lib.const import PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH
from karesansui.lib.utils import is_param

def validates_mail(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'server'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Mail Server Name'))
    else:
        check_server = checker.check_domainname(_('Mail Server Name'),
                        obj.input.server,
                        CHECK_EMPTY | CHECK_VALID,
                       ) or \
                       checker.check_ipaddr(_('Mail Server Name'),
                        obj.input.server,
                        CHECK_EMPTY | CHECK_VALID,
                       ) 
        check = check_server and check
    
    if not is_param(obj.input, 'port'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Port Number'))
    else:
        check = checker.check_number(_('Port Number'),
                    obj.input.port,
                    CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    PORT_MIN_NUMBER,
                    PORT_MAX_NUMBER,
                    ) and check
    
    if not is_param(obj.input, 'email'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Recipient Mail Address'))
    else:
        check = checker.check_mailaddress(_('Recipient Mail Address'),
                    obj.input.email,
                    CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                    min = EMAIL_MIN_LENGTH,
                    max = EMAIL_MAX_LENGTH
                    ) and check

    obj.view.alert = checker.errors
    return check

def get_view_mail(config):
    mail = {'server' : config['application.mail.server'],
            'port' : config['application.mail.port'],
            'email' : config['application.mail.email']}
    return mail

class Mail(Rest):
 
    @auth
    def _GET(self, *param, **params):
        try:
            conf = env.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
            self.view.mail = get_view_mail(config)
            return True
        
        except IOError, kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge

    
    @auth
    def _PUT(self, *param, **params):
        if not validates_mail(self):
            return web.badrequest(self.view.alert)

        try:
            conf = env.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
            config['application.mail.server'] = self.input.server
            config['application.mail.port'] = self.input.port
            config['application.mail.email'] = self.input.email
            _K2V.write(config)
            self.view.mail = get_view_mail(config)
            return True

        except IOError, kge:
            self.logger.debug(kge)
            raise KaresansuiGadgetException, kge


urls = ('/setting/mail/?(\.input|\.part)?$', Mail,)

########NEW FILE########
__FILENAME__ = me
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE
from karesansui.db.access.user import findby1, update as dba_update, findby1email
from karesansui.lib.crypt import sha1encrypt, sha1compare
from karesansui.lib.const import \
    DEFAULT_LANGS, LOGOUT_FILE_PREFIX, \
    ID_MIN_LENGTH, ID_MAX_LENGTH, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    USER_MIN_LENGTH, USER_MAX_LENGTH, \
    PASSWORD_MIN_LENGTH, PASSWORD_MAX_LENGTH, \
    LANGUAGES_MIN_LENGTH, LANGUAGES_MAX_LENGTH
from karesansui.lib.utils import is_param, is_empty, create_file
from karesansui.gadget.userby1 import compare_password

def validates_me(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    _password_flag = True
    if not is_param(obj.input, 'password'):
        _password_flag = False
        check = False
        checker.add_error(_('"%s" is required.') % _('Password'))
    if not is_param(obj.input, 'new_password'):
        _password_flag = False
        check = False
        checker.add_error(_('"%s" is required.') % _('New Password'))
    if not is_param(obj.input, 'retype'):
        _password_flag = False
        check = False
        checker.add_error(_('"%s" is required.') % _('Retype'))

    if _password_flag == True:
        if not is_empty(obj.input.password) or \
           not is_empty(obj.input.new_password) or \
           not is_empty(obj.input.retype):
            check = checker.check_password(
                        _('Password'),
                        obj.input.password,
                        obj.input.password,
                        CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                        min = PASSWORD_MIN_LENGTH,
                        max = PASSWORD_MAX_LENGTH,
                        ) and check
            
            check = checker.check_password(
                        _('Password'),
                        obj.input.new_password,
                        obj.input.retype,
                        CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                        min = PASSWORD_MIN_LENGTH,
                        max = PASSWORD_MAX_LENGTH,
                        ) and check

    if not is_param(obj.input, 'id'):
        check = False
        checker.add_error(_('"%s" is required.') % _('ID'))
    else:
        check = checker.check_number(
                    _('ID'),
                    obj.input.id,
                    CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                    min = ID_MIN_LENGTH,
                    max = ID_MAX_LENGTH,
                    ) and check

    if not is_param(obj.input, 'email'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Mail Address'))
    else:
        check = checker.check_mailaddress(
                    _('Mail Address'),
                    obj.input.email,
                    CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                    min = EMAIL_MIN_LENGTH,
                    max = EMAIL_MAX_LENGTH,
                    ) and check

    if not is_param(obj.input, 'nickname'):
        check = False
        checker.add_error(_('"%s" is required.') % _('User Name'))
    else:
        check = checker.check_username(
                    _('User Name'),
                    obj.input.nickname,
                    CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                    min = USER_MIN_LENGTH,
                    max = USER_MAX_LENGTH,
                    ) and check

    if not is_param(obj.input, 'languages'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Language'))
    else:
        check = checker.check_languages(
                    _('Language'),
                    obj.input.languages,
                    CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
                    min = LANGUAGES_MIN_LENGTH,
                    max = LANGUAGES_MAX_LENGTH,
                    ) and check

    obj.view.alert = checker.errors
    return check

class Me(Rest):
    @auth
    def _GET(self, *param, **params):
        if self.is_mode_input():
            self.view.locales = DEFAULT_LANGS.keys()
        return True

    @auth
    def _PUT(self, *param, **params):
        if not validates_me(self):
            return web.badrequest(self.view.alert)
        
        if self.me.id != int(self.input.id):
            self.logger.info("Update account is failed, "
                             "posted ID parameter is different from me ID "
                             "- posted ID %s, me ID %s" % (self.input.id, self.me.id))
            return web.badrequest(_('ID is wrong. Your ID is not %s.') % self.input.id)

        me = findby1(self.orm, self.input.id)
        if not me:
            self.logger.debug("Update account is failed, "
                              "Did not exist account - id=%s" % self.input.id)
            return web.notfound()

        cmp_user = findby1email(self.orm, self.input.email)
        if not cmp_user is None:
            if me.id != cmp_user.id:
                self.logger.info("Update account is failed, "
                                 "Already exists mail address "
                                 "- %s, %s" % (me, cmp_user))
                return web.conflict(web.ctx.path) 

        if self.input.password:
            if compare_password(self, self.me) is False:
                return web.badrequest(self.view.alert)
            (password, salt) = sha1encrypt(self.input.new_password)
            me.password = password
            me.salt = salt
        me.email = self.input.email
        me.languages = self.input.languages 
        me.nickname = self.input.nickname
        dba_update(self.orm, me)
        self.me = me
        return web.seeother(web.ctx.path)

    @auth
    def _DELETE(self, *param, **params):
        fname = '%s%s' % (LOGOUT_FILE_PREFIX, self.me.email,)

        try:
            create_file(fname, "")
        except IOError, ioe:
            self.logger.error("Logout failed, Failed to create logout file. - filename=%s" % fname)
            raise # return 500(Internal Server Error)

        return web.seeother('%s/logout' % web.ctx.home)

urls = ('/me/?(\.part)$', Me,)
 

########NEW FILE########
__FILENAME__ = msg
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui import sheconf
from karesansui.lib.rest import Rest, auth
from karesansui.lib.const import MSG_LIMIT, DEFAULT_LANGS
from karesansui.lib.template import total_progress
from karesansui.db.model._2pysilhouette import JOBGROUP_STATUS
from karesansui.db.access._2pysilhouette import jg_findbyserial_limit
from karesansui.db.access.machine2jobgroup import findby1jobgroup as m2j_find

class Msg(Rest):

    @auth
    def _GET(self, *param, **params):
        uniq_key = sheconf['env.uniqkey']
        jgs = jg_findbyserial_limit(self.pysilhouette.orm,
                            MSG_LIMIT,
                            True)
        msgs = []
        for jg in jgs:
            msg = {}
            m2j = m2j_find(self.orm, jg.id)
            msg['id'] = jg.id
            msg['name'] = jg.name
            msg['machine_id'] = "--"
            msg['machine_parent_id'] = "--"
            if m2j == []:
                msg['machine_name'] = None
                msg['user_name'] = None
            else:
                try:
                    msg['machine_id'] = m2j[0].machine.id
                except:
                    msg['machine_id'] = "Unknown"

                try:
                    msg['machine_parent_id'] = m2j[0].machine.parent_id
                except:
                    msg['machine_parent_id'] = "Unknown"

                try:
                    msg['machine_name'] = m2j[0].machine.name
                except:
                    msg['machine_name'] = "Unknown"

                try:
                    msg['machine_attr'] = m2j[0].machine.attribute
                except:
                    msg['machine_attr'] = "Unknown"

                try:
                    msg['user_name'] = m2j[0].machine.created_user.nickname
                except:
                    msg['user_name'] = "Unknown"

            msg['status'] = jg.status
            msg['progress'] = total_progress(jg.jobs)
            msg['created'] = jg.created
            msg['modified'] = jg.modified
            msgs.append(msg)

        self.view.msgs = msgs
        self.view.JOBGROUP_STATUS = JOBGROUP_STATUS
        self.view.date_format = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT'][1]
        return True

urls = (
    '/msg/?(\.part)$', Msg
    )

########NEW FILE########
__FILENAME__ = static
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from karesansui.lib.rest import Rest, auth

class Static(Rest):
    def _GET(self, *param, **params):
        self.__template__.dir = 'static/'+param[0]
        self.__template__.file = param[1]
        self.__template__.media = param[2]
        return True

urls = ('/static/(.+)/(.+)\.(js|css|png|gif|jpg|jpeg|ico|jar)', Static,)

########NEW FILE########
__FILENAME__ = tag
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

from karesansui.lib.rest import Rest, auth
from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.search import validates_query
from karesansui.lib.const import \
    TAG_LIST_RANGE, TAG_MIN_LENGTH, TAG_MAX_LENGTH, \
    ID_MIN_LENGTH, ID_MAX_LENGTH

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, \
    CHECK_LENGTH, CHECK_MIN, CHECK_MAX

from karesansui.db.access.tag import \
    findbyall, findby1, \
    findby1name, findbyand,\
    update, delete, save, new
from karesansui.lib.utils import is_param

def validates_tag(obj):
    checker = Checker()
    check = True
          
    _ = obj._ 
    checker.errors = []

    check = check and checker.check_length(
            _('Tag'),
            obj.input.name,
            TAG_MIN_LENGTH,
            TAG_MAX_LENGTH,
            ) 

    obj.view.alert = checker.errors
    return check

def validates_param_id(obj, tag_id):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    check = checker.check_number(
            _('Tag ID'),
            tag_id,
            CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
            min = ID_MIN_LENGTH,
            max = ID_MAX_LENGTH,
            ) and check

    obj.view.alert = checker.errors
    return check

class Tag(Rest):
    @auth
    def _GET(self, *param, **params):
        if not validates_query(self):
            self.logger.debug("Failed to get tags. The value of query is invalid.")
            return web.badrequest(self.view.alert)

        if not validates_page(self):
            self.logger.debug("Failed to get tags. The value of page is invalid.")
            return web.badrequest(self.view.alert)

        if is_param(self.input, 'q') is True:
            tags = findbyand(self.orm, self.input.q)
            if not tags:
                self.logger.debug("Failed to get tags. No such tag - query=%s" % self.input.q)
                return web.nocontent()
            self.view.search_value = self.input.q
        else:
            tags = findbyall(self.orm)
            self.view.search_value = ""
            if not tags:
                self.logger.debug("Failed to get tag. No tags found.")
                return web.notfound()

        if is_param(self.input, 'p') is True:
            start = int(self.input.p)
        else:
            start = 0

        pager = Pager(tags, start, TAG_LIST_RANGE)
        if not pager.exist_now_page():
            self.logger.debug("Failed to get tag. Could not find page - page=%s" % self.input.p)
            return web.nocontent()

        self.view.pager = pager

        if self.is_mode_input():
            self.view.tag = new('')

        self.view.input = self.input
        return True

    @auth
    def _POST(self, *param, **params):
        if not validates_tag(self):
            self.logger.debug("Failed to create tag. The value of input is invalid.")
            return web.badrequest(self.view.alert)

        tag = findby1name(self.orm, self.input.name)
        if tag:
            self.logger.debug("Failed to create tag. The same tag already exist - id='%s'" % (tag.id))
            return web.conflict(web.ctx.path)

        new_tag = new(self.input.name)

        save(self.orm, new_tag)
        return web.created(None)


class TagBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        tag_id = param[0]
        if not validates_param_id(self, tag_id):
            self.logger.debug("Failed to get tag. The value of parameter is invalid.")
            return web.badrequest(self.view.alert)

        tag = findby1(self.orm, tag_id)
        if not tag:
            self.logger.debug("Failed to get tag. No such tag - id=%s" % tag_id)
            return web.notfound()
        self.view.tag = tag
        
        return True

    @auth
    def _PUT(self, *param, **params):
        tag_id = param[0]
        if not validates_param_id(self, tag_id):
            self.logger.debug("Failed to update tag. The value of parameter is invalid.")
            return web.badrequest(self.view.alert)

        if not validates_tag(self):
            self.logger.debug("Failed to update tag. The value of input is invalid.")
            return web.badrequest(self.view.alert)

        tag = findby1(self.orm, tag_id)
        if not tag:
            self.logger.debug("Failed to update tag. No such tag - id=%s" % tag_id)
            return web.notfound() 

        cmp_tag = findby1name(self.orm, self.input.name)
        if not cmp_tag is None:
            if cmp_tag.id != tag.id:
                self.logger.debug("Failed to update tag. The same tag already exist - id='%s'" % (cmp_tag.id))
                return web.conflict(web.ctx.path)

        tag.name = self.input.name

        update(self.orm, tag)
        return web.seeother(web.ctx.path)

    @auth
    def _DELETE(self, *param, **params):
        tag_id = param[0]
        if not validates_param_id(self, tag_id):
            self.logger.debug("Failed to delete tag. The value of parameter is invalid.")
            return web.badrequest(self.view.alert)

        tag = findby1(self.orm, tag_id)
        if not tag:
            self.logger.debug("Failed to delete tag. No such tag - id=%s" % tag_id)
            return web.notfound() 

        delete(self.orm, tag)
        return web.seeother("/%s.%s" % ("tag", "part"))

urls = (
    '/tag/(\d+)/?(\.part)$', TagBy1,
    '/tag/?(\.part)$', Tag,
    )

########NEW FILE########
__FILENAME__ = tree
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from os import environ as env

import web

from karesansui import KaresansuiGadgetException
from karesansui.lib.rest import Rest, auth
from karesansui.lib.net.http import is_ssl
from karesansui.lib.file.k2v import K2V
from karesansui.lib.virt.virt import KaresansuiVirtConnection, \
     KaresansuiVirtException
from karesansui.lib.merge import MergeHost
from karesansui.db.access.machine import findbyhostall
from karesansui.lib.utils import available_virt_uris

class Tree(Rest):

    def _post(self, f):
        ret = Rest._post(self, f)
        if hasattr(self, "kvc") is True:
            self.kvc.close()
        return ret

    @auth
    def _GET(self, *param, **params):
        models = findbyhostall(self.orm)
        uris = available_virt_uris()

        try:
            conf = env.get('KARESANSUI_CONF')
            _K2V = K2V(conf)
            config = _K2V.read()
        except (IOError, KaresansuiGadgetException):
            raise KaresansuiGadgetException

        self.view.application_uniqkey = config['application.uniqkey']

        port_number = 443

        try:
            hosts = []
            for model in models:
                if model.attribute == 0 and model.hypervisor == 1:
                    uri = uris["XEN"]
                elif model.attribute == 0 and model.hypervisor == 2:
                    uri = uris["KVM"]
                else:
                    uri = None
                self.kvc = KaresansuiVirtConnection(uri)
                host = MergeHost(self.kvc, model)
                host.info['model'].is_ssl = is_ssl(host.info['model'].hostname)
                #host.info['model'].is_ssl = is_ssl(host.info['model'].hostname,port_number)
                host.info['model'].port_number = port_number
                hosts.append(host)

            self.view.machines = hosts
        except KaresansuiVirtException:
            if hasattr(self, "kvc") is True:
                self.kvc.close()
            raise KaresansuiGadgetException

        return True

urls = (
    '/tree/?(\.part)$' , Tree,
)

########NEW FILE########
__FILENAME__ = uriguestby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import web

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.lib.utils import \
    comma_split, uniq_sort, is_param, json_dumps, \
    uri_split, uri_join

from karesansui.lib.virt.virt import KaresansuiVirtConnectionAuth

from karesansui.lib.merge import MergeGuest, MergeHost
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access._2pysilhouette import save_job_collaboration
from karesansui.db.model._2pysilhouette import Job, JobGroup

from pysilhouette.command import dict2command

class UriGuestBy1(Rest):

    def _post(self, f):
        ret = Rest._post(self, f)
        if hasattr(self, "kvc") is True:
            self.kvc.close()
        return ret

    @auth
    def _GET(self, *param, **params):

        if self.input.has_key('job_id') is True:
            self.view.job_id = self.input.job_id
        else:
            self.view.job_id = None

        host_id =  param[0]
        host_id = self.chk_hostby1(param)
        if host_id is None:
            return web.notfound()

        uri_id =  param[1]
        if uri_id is None:
            return web.notfound()

        model = findbyhost1(self.orm, host_id)

        if self.is_mode_input() is False:
            if model.attribute == 2:
                info = {}
                segs = uri_split(model.hostname)
                uri = uri_join(segs, without_auth=True)
                creds = ''
                if segs["user"] is not None:
                    creds += segs["user"]
                    if segs["passwd"] is not None:
                        creds += ':' + segs["passwd"]
                self.kvc = KaresansuiVirtConnectionAuth(uri,creds)

                try:
                    host = MergeHost(self.kvc, model)
                    for guest in host.guests:
                        if not '__guest' in locals():
                            _virt = self.kvc.search_kvg_guests(guest.info["model"].name)
                            if 0 < len(_virt):
                                for _v in _virt:
                                    info = _v.get_info()
                                    if info["uuid"] == uri_id or (uri[0:5] == "test:"):
                                        __guest = MergeGuest(guest.info["model"],_v)
                                        autostart       = _v.autostart()
                                        status          = _v.status()
                                        is_creatable    = _v.is_creatable()
                                        is_shutdownable = _v.is_shutdownable()
                                        is_suspendable  = _v.is_suspendable()
                                        is_resumable    = _v.is_resumable()
                                        is_destroyable  = _v.is_destroyable()
                                        is_active       = _v.is_active()
                                        break

                    if self.is_json() is True:
                        json_host  = host.get_json(self.me.languages)
                        json_guest = __guest.get_json(self.me.languages)
                        self.view.data = json_dumps(
                            {
                                "parent_model": json_host["model"],
                                "parent_virt": json_host["virt"],
                                "model": json_guest["model"],
                                "virt": json_guest["virt"],
                                "info": info,
                                "autostart": autostart,
                                "status": status,
                                "is_creatable": is_creatable,
                                "is_shutdownable": is_shutdownable,
                                "is_suspendable": is_suspendable,
                                "is_resumable": is_resumable,
                                "is_destroyable": is_destroyable,
                                "is_active": is_active,
                            }
                        )
                    else:
                        self.view.parent_model = host.info["model"]
                        self.view.parent_virt = host.info["virt"]
                        self.view.model = __guest.info["model"]
                        self.view.virt = __guest.info["virt"]
                        self.view.info = info
                        self.view.autostart = autostart
                        self.view.status = status
                        self.view.is_creatable = is_creatable
                        self.view.is_shutdownable = is_shutdownable
                        self.view.is_suspendable = is_suspendable
                        self.view.is_resumable = is_resumable
                        self.view.is_destroyable = is_destroyable
                        self.view.is_active = is_active
                finally:
                    self.kvc.close()

        return True




urls = (
    '/host/(\d+)/uriguest/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/?(\.html|\.part|\.json)?', UriGuestBy1,
    )

########NEW FILE########
__FILENAME__ = uriguestby1console
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
import os
import socket

import karesansui
from karesansui.lib.rest import Rest, auth

from karesansui.db.access.machine import findbyhost1
from karesansui.lib.utils import uri_split, uri_join

def _prep_console():
    java_dir = karesansui.dirname + '/static/java'

    sources = ['/usr/lib/tightvnc/classes/VncViewer.jar',
               '/usr/share/tightvnc-java/VncViewer.jar',
              ]

    target = java_dir + '/VncViewer.jar'

    if not os.path.lexists(target):
        if not os.path.exists(java_dir):
            os.makedirs(java_dir)

        for source in sources:
          if os.path.exists(source):
            os.symlink(source,target) 

class UriGuestBy1Console(Rest):

    @auth
    def _GET(self, *param, **params):
        _prep_console()

        host_id =  param[0]
        host_id = self.chk_hostby1(param)
        if host_id is None:
            return web.notfound()

        uri_id =  param[1]
        if uri_id is None:
            return web.notfound()

        model = findbyhost1(self.orm, host_id)
        try:
            segs = uri_split(model.hostname)
            self.view.host_ipaddr = socket.gethostbyname(segs['host'])
#172.23.227.50
        except:
            self.view.host_ipaddr = socket.gethostbyname(socket.gethostname())

        return True

urls = (
    '/host/(\d+)/uriguest/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/console/?(\.part)?$', UriGuestBy1Console,
    )

########NEW FILE########
__FILENAME__ = uriguestby1status
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import web

import karesansui
from karesansui.lib.rest import Rest, auth
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnectionAuth, KaresansuiVirtGuest
from karesansui.lib.const import VIRT_COMMAND_START_GUEST, \
     VIRT_COMMAND_SHUTDOWN_GUEST, VIRT_COMMAND_SUSPEND_GUEST, \
     VIRT_COMMAND_RESUME_GUEST, VIRT_COMMAND_REBOOT_GUEST, \
     VIRT_COMMAND_DESTROY_GUEST, VIRT_COMMAND_AUTOSTART_GUEST
from karesansui.lib.const import KARESANSUI_TMP_DIR

from karesansui.lib.utils import \
    comma_split, uniq_sort, is_param, json_dumps, \
    uri_split, uri_join

from karesansui.lib.checker import \
    Checker, CHECK_EMPTY, CHECK_VALID

from karesansui.lib.merge import MergeGuest, MergeHost
from karesansui.db.access.machine import findbyhost1
from karesansui.db.access.machine2jobgroup import new as m2j_new
from karesansui.db.access._2pysilhouette import save_job_collaboration

from pysilhouette.command import dict2command 
from karesansui.db.model._2pysilhouette import Job, JobGroup

GUEST_ACTION_CREATE = 0
GUEST_ACTION_SHUTDOWN = 1
GUEST_ACTION_DESTROY = 2
GUEST_ACTION_SUSPEND = 3
GUEST_ACTION_RESUME = 4
GUEST_ACTION_REBOOT = 5
GUEST_ACTION_ENABLE_AUTOSTART = 6
GUEST_ACTION_DISABLE_AUTOSTART = 7

def validates_uriguest_status(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'status'):
        check = checker.check_status(
                _('Status'),
                obj.input.status,
                CHECK_EMPTY | CHECK_VALID,
                [GUEST_ACTION_CREATE, 
                GUEST_ACTION_SHUTDOWN,
                GUEST_ACTION_DESTROY,
                GUEST_ACTION_SUSPEND,
                GUEST_ACTION_RESUME,
                GUEST_ACTION_REBOOT,
                GUEST_ACTION_ENABLE_AUTOSTART,
                GUEST_ACTION_DISABLE_AUTOSTART]
            ) and check
    else:
        check = False
        checker.add_error(_('"%s" is required.') % _('Status'))

    obj.view.alert = checker.errors

    return check


class UriGuestBy1Status(Rest):
    
    @auth
    def _GET(self, *param, **params):
        """<comment-ja>
        virDomainState
         - VIR_DOMAIN_NOSTATE = 0
         - VIR_DOMAIN_RUNNING = 1
         - VIR_DOMAIN_BLOCKED = 2
         - VIR_DOMAIN_PAUSED = 3
         - VIR_DOMAIN_SHUTDOWN = 4
         - VIR_DOMAIN_SHUTOFF = 5
         - VIR_DOMAIN_CRASHED = 6
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        host_id =  param[0]
        host_id = self.chk_hostby1(param)
        if host_id is None:
            return web.notfound()

        uri_id =  param[1]
        if uri_id is None:
            return web.notfound()

        model = findbyhost1(self.orm, host_id)

        if self.is_mode_input() is False:
            if model.attribute == 2:
                info = {}
                segs = uri_split(model.hostname)
                uri = uri_join(segs, without_auth=True)
                creds = ''
                if segs["user"] is not None:
                    creds += segs["user"]
                    if segs["passwd"] is not None:
                        creds += ':' + segs["passwd"]
                self.kvc = KaresansuiVirtConnectionAuth(uri,creds)

                try:
                    host = MergeHost(self.kvc, model)
                    for guest in host.guests:
                        _virt = self.kvc.search_kvg_guests(guest.info["model"].name)
                        if 0 < len(_virt):
                            for _v in _virt:
                                info = _v.get_info()
                                if info["uuid"] == uri_id or (uri[0:5] == "test:"):
                                    __guest = MergeGuest(guest.info["model"],_v)
                                    status          = _v.status()
                                    break

                    if self.is_json() is True:
                        self.view.status = json_dumps(status)
                    else:
                        self.view.status = status
                finally:
                    self.kvc.close()

        return True

    @auth
    def _PUT(self, *param, **params):
        """<comment-ja>
        ステータス更新
         - param
           - create = 0
           - shutdown = 1
           - destroy = 2
           - suspend = 3
           - resume = 4
           - reboot = 5
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        host_id =  param[0]
        host_id = self.chk_hostby1(param)
        if host_id is None:
            return web.notfound()

        uri_id =  param[1]
        if uri_id is None:
            return web.notfound()

        if not validates_uriguest_status(self):
            return web.badrequest(self.view.alert)

        status = int(self.input.status)

        model = findbyhost1(self.orm, host_id)

        if model.attribute == 2:
            info = {}
            segs = uri_split(model.hostname)
            uri = uri_join(segs, without_auth=True)
            creds = ''
            if segs["user"] is not None:
                creds += segs["user"]
                if segs["passwd"] is not None:
                    creds += ':' + segs["passwd"]
            self.kvc = KaresansuiVirtConnectionAuth(uri,creds)

            try:
                host = MergeHost(self.kvc, model)
                for guest in host.guests:
                    _virt = self.kvc.search_kvg_guests(guest.info["model"].name)
                    if 0 < len(_virt):
                        for _v in _virt:
                            info = _v.get_info()
                            #uri = _v._conn.getURI()
                            if info["uuid"] == uri_id or (uri[0:5] == "test:"):

                                esc_name = "'%s'" % guest.info["model"].name
                                opts = {"name":esc_name,"connection":uri}

                                if creds != '':
                                    passwd_file = KARESANSUI_TMP_DIR + "/" + segs['host'] + ".auth"
                                    open(passwd_file, "w").write(creds)
                                    os.chmod(passwd_file, 0600)
                                    opts["passwd-file"] = passwd_file

                                if status == GUEST_ACTION_CREATE:
                                    # -- Create
                                    cmdname = ["Start Guest", "start guest"]
                                    if _v.is_creatable() is True:
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_START_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_START_GUEST
                                    else:
                                        self.logger.error("Create Action:The state can not run. - %d" % _v.status())
                                    
                                elif status == GUEST_ACTION_SHUTDOWN:
                                    cmdname = ["Shutdown Guest", "shutdown guest"]
                                    if _v.is_shutdownable() is True:
                                        # -- Shutdown
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_SHUTDOWN_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_SHUTDOWN_GUEST
                                    else:
                                        self.logger.error("Shutdown Action:The state can not run. - %d" % _v.status())
                                
                                elif status == GUEST_ACTION_DESTROY:
                                    cmdname = ["Destroy Guest", "Destroy guest"]
                                    if _v.is_destroyable() is True:
                                        # -- destroy
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_DESTROY_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_DESTROY_GUEST
                                    else:
                                        self.logger.error("Destroy Action:The state can not run. - %d" % _v.status())
                                        
                                elif status == GUEST_ACTION_SUSPEND:
                                    cmdname = ["Suspend Guest", "suspend guest"]
                                    if _v.is_suspendable() is True:
                                        # -- Suspend
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_SUSPEND_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_SUSPEND_GUEST
                                    else:
                                        self.logger.error("Destroy Action:The state can not run. - %d" % _v.status())
                                        
                                elif status == GUEST_ACTION_RESUME:
                                    cmdname = ["Resume Guest", "resume guest"]
                                    if _v.is_resumable() is True:
                                        # -- Resume
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_RESUME_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_RESUME_GUEST
                                    else:
                                        self.logger.error("Resume Action:The state can not run. - %d" % _v.status())
                    
                                elif status == GUEST_ACTION_REBOOT:
                                    cmdname = ["Reboot Guest", "reboot guest"]
                                    if _v.is_shutdownable() is True:
                                        # -- Reboot
                                        _cmd = dict2command(
                                            "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_REBOOT_GUEST),
                                            opts)
                                        
                                        self.view.status = VIRT_COMMAND_REBOOT_GUEST
                                    else:
                                        self.logger.error("Reboot Action:The state can not run. - %d" % _v.status())
                    
                                elif status == GUEST_ACTION_ENABLE_AUTOSTART:
                                    opts["enable"] = None
                                    cmdname = ["Enable Autostart Guest", "enable autostart guest"]
                                    # -- Enable autostart guest
                                    _cmd = dict2command(
                                        "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_AUTOSTART_GUEST),
                                        opts)
                                        
                                    self.view.status = VIRT_COMMAND_AUTOSTART_GUEST
                    
                                elif status == GUEST_ACTION_DISABLE_AUTOSTART:
                                    opts["disable"] = None
                                    cmdname = ["Disable Autostart Guest", "disable autostart guest"]
                                    # -- Disable autostart guest
                                    _cmd = dict2command(
                                        "%s/%s" % (karesansui.config['application.bin.dir'],VIRT_COMMAND_AUTOSTART_GUEST),
                                        opts)
                                        
                                    self.view.status = VIRT_COMMAND_AUTOSTART_GUEST

                                else:
                                    self.logger.error("Action:Bad Request. - request status=%d" % status)
                                    return web.badrequest()

                                break

            finally:
                self.kvc.close()


            # Job Register
            _jobgroup = JobGroup(cmdname[0], karesansui.sheconf['env.uniqkey'])
            _jobgroup.jobs.append(Job('%s command' % cmdname[1], 0, _cmd))
        
            _machine2jobgroup = m2j_new(machine=model,
                                        jobgroup_id=-1,
                                        uniq_key=karesansui.sheconf['env.uniqkey'],
                                        created_user=self.me,
                                        modified_user=self.me,
                                        )

            # INSERT
            save_job_collaboration(self.orm,
                                   self.pysilhouette.orm,
                                   _machine2jobgroup,
                                   _jobgroup,
                                   )

            return web.accepted(url="/host/%d/uriguest/%s.part" % (host_id, uri_id))

urls = (
    '/host/(\d+)/uriguest/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/status/?(\.part|\.json)?$', UriGuestBy1Status,
    )

########NEW FILE########
__FILENAME__ = user
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from karesansui.lib.rest import Rest, auth

from karesansui.db.access.user import \
    findbyall, findby1, findby1email, findbyand, \
    update, delete, save, new

from karesansui.lib.crypt import sha1encrypt, sha1compare
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE
from karesansui.lib.const import \
    DEFAULT_LANGS, USER_LIST_RANGE, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    USER_MIN_LENGTH, USER_MAX_LENGTH, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    PASSWORD_MIN_LENGTH, PASSWORD_MAX_LENGTH, \
    LANGUAGES_MIN_LENGTH, LANGUAGES_MAX_LENGTH

from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.search import validates_query
from karesansui.lib.utils import is_param, is_empty

def validates_user(obj):
    checker = Checker()
    check = True
          
    _ = obj._ 
    checker.errors = []

    if not is_param(obj.input, 'nickname'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Nickname'))
    else:
        check = checker.check_username(
                _('Nickname'),
                obj.input.nickname,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                min = USER_MIN_LENGTH,
                max = USER_MAX_LENGTH,
                ) and check

    if not is_param(obj.input, 'email'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Mail Address'))
    else:
        check = checker.check_mailaddress(
                _('Mail Address'), 
                obj.input.email,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                min = EMAIL_MIN_LENGTH,
                max = EMAIL_MAX_LENGTH,
                ) and check 
    
    _password_flag = True
    if not is_param(obj.input, 'new_password'):
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('New Password'))
    if not is_param(obj.input, 'retype'):
        check = False
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('Retype'))

    if _password_flag == True:
        check = checker.check_password(
                _('Password'),
                obj.input.new_password,
                obj.input.retype,
                CHECK_VALID | CHECK_LENGTH | CHECK_EMPTY,
                min = PASSWORD_MIN_LENGTH,
                max = PASSWORD_MAX_LENGTH,
                ) and check

    check = checker.check_languages(
            _('Language'),
            obj.input.languages,
            CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
            min = LANGUAGES_MIN_LENGTH,
            max = LANGUAGES_MAX_LENGTH,
            ) and check

    obj.view.alert = checker.errors
    return check

class User(Rest):
    @auth
    def _GET(self, *param, **params):
        if not validates_query(self):
            self.logger.debug("Failed to get account. the value of query is invalid. - query=%s" % self.input.q)
            return web.badrequest(self.view.alert)

        if not validates_page(self):
            self.logger.debug("Failed to get account. the value of page is invalid. - page=%s" % self.input.p)
            return web.badrequest(self.view.alert)

        if is_param(self.input, "q"):
            users = findbyand(self.orm, self.input.q)
            if not users:
                self.logger.debug("Failed to get account. No such account. - query=%s" % self.input.q)
                return web.nocontent()
            self.view.search_value = self.input.q
        else:
            users = findbyall(self.orm)
            self.view.search_value = ""
            if not users:
                self.logger.debug("Failed to get account. No accounts found.")
                return web.notfound()

        if is_param(self.input, "p"):
            start = int(self.input.p)
        else:
            start = 0

        pager = Pager(users, start, USER_LIST_RANGE)
        if not pager.exist_now_page():
            self.logger.debug("Failed to get account. Could not find page - page=%s" % self.input.p)
            return web.nocontent()

        self.view.pager = pager

        if self.is_mode_input():
            locales = DEFAULT_LANGS.keys()
            self.view.locales = locales
            self.view.user = new('', '', '', '', '')

        self.view.input = self.input
        return True

    @auth
    def _POST(self, *param, **params):
        if not validates_user(self):
            self.logger.debug("Failed to create account. the values of input are invalid.")
            return web.badrequest(self.view.alert)

        user = findby1email(self.orm, self.input.email)
        if user:
            self.logger.debug("Failed to create account. The same mail address '%s' already exist - user='%s'" % (self.input.email, user.nickname))
            return web.conflict(web.ctx.path)

        (password, salt) = sha1encrypt(self.input.new_password)

        new_user = new(self.input.email,
                       password,
                       salt,
                       self.input.nickname,
                       self.input.languages
                       )

        save(self.orm, new_user)
        return web.created(None)

urls = (
    '/user/?(\.part)$', User,
    )

########NEW FILE########
__FILENAME__ = userby1
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web
from karesansui.lib.rest import Rest, auth

from karesansui.db.access.user import \
    findbyall, findby1, findby1email, findbyand, \
    update, delete, save, new

from karesansui.lib.crypt import sha1encrypt, sha1compare
from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, \
    CHECK_CHAR, CHECK_MIN, CHECK_MAX, CHECK_ONLYSPACE
from karesansui.lib.const import \
    DEFAULT_LANGS, USER_LIST_RANGE, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    USER_MIN_LENGTH, USER_MAX_LENGTH, \
    EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH, \
    PASSWORD_MIN_LENGTH, PASSWORD_MAX_LENGTH, \
    LANGUAGES_MIN_LENGTH, LANGUAGES_MAX_LENGTH, \
    ID_MIN_LENGTH, ID_MAX_LENGTH

from karesansui.lib.pager import Pager, validates_page
from karesansui.lib.search import validates_query
from karesansui.lib.utils import is_param, is_empty

def validates_user(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not is_param(obj.input, 'nickname'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Nickname'))
    else:
        check = checker.check_username(
                _('Nickname'),
                obj.input.nickname,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_ONLYSPACE,
                min = USER_MIN_LENGTH,
                max = USER_MAX_LENGTH,
                ) and check

    if not is_param(obj.input, 'email'):
        check = False
        checker.add_error(_('"%s" is required.') % _('Mail Address'))
    else:
        check = checker.check_mailaddress(
                _('Mail Address'),
                obj.input.email,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                min = EMAIL_MIN_LENGTH,
                max = EMAIL_MAX_LENGTH,
                ) and check

    _password_flag = True
    if not is_param(obj.input, 'password'):
        check = False
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('Password'))
    if not is_param(obj.input, 'new_password'):
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('New Password'))
    if not is_param(obj.input, 'retype'):
        check = False
        _password_flag = False
        checker.add_error(_('"%s" is required.') % _('Retype'))

    if _password_flag == True:
        if not is_empty(obj.input.password) or \
           not is_empty(obj.input.new_password) or \
           not is_empty(obj.input.retype):
            check = checker.check_password(
                    _('Password'),
                    obj.input.password,
                    obj.input.password,
                    CHECK_EMPTY | CHECK_LENGTH,
                    min = PASSWORD_MIN_LENGTH,
                    max = PASSWORD_MAX_LENGTH,
                    ) and check

            check = checker.check_password(
                    _('Password'),
                    obj.input.new_password,
                    obj.input.retype,
                    CHECK_VALID | CHECK_LENGTH,
                    min = PASSWORD_MIN_LENGTH,
                    max = PASSWORD_MAX_LENGTH,
                    ) and check

    check = checker.check_languages(
            _('Language'),
            obj.input.languages,
            CHECK_EMPTY | CHECK_VALID | CHECK_LENGTH,
            min = LANGUAGES_MIN_LENGTH,
            max = LANGUAGES_MAX_LENGTH,
            ) and check

    obj.view.alert = checker.errors
    return check

def validates_param_id(obj, user_id):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    check = checker.check_number(
            _('User ID'),
            user_id,
            CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
            min = ID_MIN_LENGTH,
            max = ID_MAX_LENGTH,
            ) and check

    obj.view.alert = checker.errors
    return check

def compare_password(obj, user):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if not sha1compare(user.password, obj.input.password, user.salt):
        check = False
        checker.add_error(_('%s is mismatched.') % _('Current Password'))

    obj.view.alert = checker.errors
    return check

class UserBy1(Rest):

    @auth
    def _GET(self, *param, **params):
        user_id = param[0]
        if not validates_param_id(self, user_id):
            self.logger.debug("Failed to update account. the value of parameter is invalid.")
            return web.notfound(self.view.alert)

        user = findby1(self.orm, user_id)
        if not user:
            self.logger.debug("Failed to get account - id=%s" % user_id)
            return web.notfound()
        self.view.user = user

        if self.is_mode_input():
            locales = DEFAULT_LANGS.keys()
            self.view.locales = locales
        return True

    @auth
    def _PUT(self, *param, **params):
        user_id = param[0]
        if not validates_param_id(self, user_id):
            self.logger.debug("Failed to update account. the value of parameter is invalid.")
            return web.notfound(self.view.alert)

        if not validates_user(self):
            self.logger.debug("Failed to update account. the value of input is invalid.")
            return web.badrequest(self.view.alert)

        user = findby1(self.orm, user_id)
        if not user:
            self.logger.debug("Failed to update account. No such account - id=%s" % user_id)
            return web.notfound()

        cmp_user = findby1email(self.orm, self.input.email)
        if not cmp_user is None:
            if int(user_id) != cmp_user.id:
                self.logger.debug("Failed to update account. The same mail address '%s' already exist - user='%s'" % (self.input.email, cmp_user.nickname))
                return web.conflict(web.ctx.path)

        user.nickname = self.input.nickname
        user.email = self.input.email
        user.languages = self.input.languages

        if not is_empty(self.input.new_password):
            if compare_password(self, user) == False:
                return web.badrequest(self.view.alert)

            (password, salt) = sha1encrypt(self.input.new_password)
            user.password = password
            user.salt = salt

        update(self.orm, user)
        return web.seeother(web.ctx.path)

    @auth
    def _DELETE(self, *param, **params):
        user_id = param[0]
        if not validates_param_id(self, user_id):
            self.logger.debug("Failed to delete account. the value of parameter is invalid.")
            return web.notfound(self.view.alert)

        user = findby1(self.orm, user_id)
        if not user:
            self.logger.debug("Failed to delete account. No such account - id=%s" % user_id)
            return web.notfound()

        users = findbyall(self.orm)

        if len(users) <= 1:
            self.view.alert = "In case that Karesansui has one account only, It does not allow to delete account."
            return web.badrequest(self.view.alert)

        delete(self.orm, user)
        return web.seeother("/%s.%s" % ("user", "part"))

urls = (
    '/user/(\d+)/?(\.part)$', UserBy1,
    )

########NEW FILE########
__FILENAME__ = checker
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""<description>
<comment-ja>
HTMLフォームのバリデーションクラスを定義する
</comment-ja>
<comment-en>
Define the class for HTML Form Validation
</comment-en>

@file:   checker.py
@author: Taizo ITO <taizo@karesansui-project.info>
@copyright:    
"""

import sys
import re
import os
import os.path
import gettext
import imghdr
import karesansui
from karesansui.lib.const import DEFAULT_LANGS, IMAGE_EXT_LIST, MACHINE_HYPERVISOR
from karesansui.lib.const import XEN_KEYMAP_DIR, KVM_KEYMAP_DIR

from karesansui.lib.utils import str2datetime, is_int, is_ascii, is_uuid, \
     get_ifconfig_info
from karesansui.lib.networkaddress import NetworkAddress
from karesansui.db.model._2pysilhouette import JOBGROUP_STATUS
from karesansui.lib.virt.virt import KaresansuiVirtConnection
from karesansui.lib.firewall.iptables import KaresansuiIpTables

CHECK_EMPTY     = 1<<0   #フォームが空でないか
CHECK_VALID     = 1<<1   # 値が正当か
CHECK_NOTROOT   = 1<<2   # "/"でないか(ルートディレクトリではまずい場合)
CHECK_STARTROOT = 1<<3   # "/"で始まっているか(絶対パスでないとまずい場合)
CHECK_MIN       = 1<<4   # 数値の最小値(UID,GID,Portなど)
CHECK_MAX       = 1<<5   # 数値の最大値(UID,GID,Portなど)
ALLOW_REGEX     = 1<<6   # 正規表現を許す(ディレクトリなど)
CHECK_LENGTH    = 1<<7   # whether the length of string is long enough
CHECK_ONLYINT   = 1<<8   # whether value consists of the integer only
CHECK_ONLYSPACE = 1<<9   # whether value consists of the space char only
CHECK_EXIST     = 1<<10  # 存在するか(ファイルなど)
CHECK_MAKEDIR   = 1<<11  # 存在しないディレクトリを自動生成
CHECK_ISDIR     = 1<<12  # ディレクトリかどうか
CHECK_LENGTH    = 1<<13  # 長さが十分かどうか(パスワード)
WARN_LENGTH     = 1<<14  # 長さが十分かどうか(パスワード)常にtrueを返す
CHECK_CHAR      = 1<<15  # 数字だけではないか
CHECK_DICTVALUE = 1<<16  # 辞書の値と一致するかどうか
CHECK_DICTKEY   = 1<<17  # 辞書のキーと一致するかどうか
CHECK_UNIQUE    = 1<<18  # 一意であるか

try:
  t = gettext.translation('messages', karesansui.dirname + "/locale")
except:
  os.environ['LANG'] = "en_US" # Sets default language.
  t = gettext.translation('messages', karesansui.dirname + "/locale")

_ = t.ugettext
#_ = t.gettext

class Checker(object):
    """<comment-ja>
    HTMLフォームの入力チェッククラス
    </comment-ja>
    <comment-en>
    The class to validate input value of HTML form
    </comment-en>
    """

    def __init__(self):
        self.errors = []

    def add_error(self, msg):
        self.errors.append(unicode(msg))

    def check_empty(self, name, value):
        """<comment-ja>
        値が空文字列でないかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする文字列
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether a specified string is empty

        @param name: Item name
        @param value: string
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if value.strip() == "":
            ret_val = False
            self.add_error(_('%s is missing.') % (name,))

        return ret_val

    def check_length(self, name, value, min=None, max=None):
        """<comment-ja>
        文字列の長さが指定範囲内であるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする文字列
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether the length of string is in specified range.

        @param name: Item name
        @param value: string
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if max != None and len(value) > max:
            ret_val = False
            self.add_error(_('%s must be shorter than %d characters.') % (name, max))
        if min != None and len(value) < min:
            ret_val = False
            self.add_error(_('%s must be longer than %d characters.') % (name, min))

        return ret_val

    def check_string(self, name, value, check, regex, min=None, max=None):
        """<comment-ja>
        文字列が指定したフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする文字列
        @param check: チェックする条件
        @param regex: 不正文字列を示す
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether specified string is valid format.

        @param name: Item name
        @param value: string
        @param check: condition to determine
        @param regex: regular expression that stands for invalid strings
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
      
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if (check & CHECK_VALID) and regex:
            regex_str = "(?P<match>%s)" % regex
            m = re.compile(regex_str).search(value)
            if m:
                ret_val = False
                self.add_error(_('%s includes invalid character[s] %s.') % (name, m.group("match")))

        if check & CHECK_ONLYSPACE:
            regex_str = "\s+"
            if re.compile(r"""^\s+$""").search(value):
                ret_val = False
                self.add_error(_('%s must not consist of only blank characters.') % (name,))

        return ret_val

    def check_number(self, name, value, check, min=None, max=None):
        """<comment-ja>
        指定した整数値が正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする整数値
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether number is valid format or in specified range.

        @param name: Item name
        @param value: interger
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if value!="" and ret_val:
            if check & CHECK_VALID:
                if not re.compile("^[-+]?[0-9]+$").match(value):
                  ret_val = False
                  self.add_error(_('%s is not numerical value.') % (name,))

            if ret_val and (check & CHECK_MIN):
                value = int(value)
                if value < min:
                    ret_val = False
                    self.add_error(_('%s must be greater than %d.') % (name, min))
 
            if ret_val and (check & CHECK_MAX):
                value = int(value)
                if value > max:
                    ret_val = False
                    self.add_error(_('%s must be smaller than %d.') % (name, max))

        return ret_val

    def check_directory(self, name, value, check):
        """<comment-ja>
        指定したディレクトリが正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするディレクトリパス
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether directory is valid format or exists.

        @param name: Item name
        @param value: path of directory
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ( not(check & CHECK_EMPTY) and value) or ret_val:
            if check & CHECK_VALID:
                if check & ALLOW_REGEX:
                    args = ']*{}[?'
                else:
                    args = ""

                ret_val = self.check_string(name, value, check,
                                    "[^%s+\._\(\)\'&@a-zA-Z0-9\/-]" % args)
                if ret_val is False:
                    self.add_error(_('Available characters are'))
                    self.add_error(_('0-9 a-z A-Z @ & ( ) + - . _ %s') % (args,))
 
            if check & CHECK_ISDIR:
                if os.path.exists(value) and not os.path.isdir(value):
                    ret_val = False
                    self.add_error(_('%s is not a directory.') % (value,))

            if check & CHECK_STARTROOT:
                if not re.compile("^[\"\']?/").match(value):
                    ret_val = False
                    self.add_error(_('%s must start with /.') % (name,))

            if check & CHECK_NOTROOT:
                if re.compile(r"^[\"\' \t]*/[\"\' \t]*$", re.VERBOSE).match(value):
                    ret_val = False
                    self.add_error(_('%s must not be root directory.') % (name,))

            if check & CHECK_EXIST:
                if not os.path.exists(value):
                    ret_val = False
                    self.add_error(_('No such %s [%s].') % (name, value))

        return ret_val

    def check_username(self, name, value, check, min=None, max=None):
        """<comment-ja>
        指定したユーザー名が正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするユーザー名
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether username is valid format.

        @param name: Item name
        @param value: user name
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if value and ret_val:
            if check & CHECK_VALID:

                m1 = re.compile(r'^[a-z]').search(value)
                m2 = re.compile(r'^[a-z][-_\.0-9a-z]*$').search(value)
                if not m1:
                    ret_val = False
                    self.add_error(_('%s must begin with alphabet.') % (name,))
                elif not m2:
                    ret_val = self.check_string(name, value, check,
                                    "[^-_.0-9a-z]", min, max)
                    ret_val = False
                    self.add_error(_('Available characters are'))
                    self.add_error(_('0-9 a-z - . _'))

        if check & CHECK_ONLYSPACE:
            regex_str = "\s+"
            if re.compile(r"""^\s+$""").search(value):
                ret_val = False
                self.add_error(_('%s must not consist of only blank characters.') % (name,))

        return ret_val

    def check_username_with_num(self, name, value, check, min=None, max=None):
        """<comment-ja>
        指定したユーザー名が正しいフォーマットであるかどうかをチェックする
        （ユーザー名の先頭は数値でも可）

        @param name: 入力項目名
        @param value: チェックするユーザー名
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether username is valid format.
        (username can begin with NUMBER)

        @param name: Item name
        @param value: user name
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if ( not(check & CHECK_EMPTY) and value) or ret_val:
            if check & CHECK_VALID:

                m1 = re.compile(r'^[a-zA-Z0-9]').search(value)
                m2 = re.compile(r'^[a-zA-Z0-9][-_\.0-9a-z]*$').search(value)
                if not m1:
                    ret_val = False
                    self.add_error(_('%s must begin with alphabet or number.') % (name,))
                elif not m2:
                    ret_val = False
                    self.add_error(_('%s is in invalid format.') % (name,))
                    self.add_error(_('Available characters are'))
                    self.add_error(_('0-9 a-z - . _'))

        return ret_val

    def check_domainname(self, name, value, check, min=None, max=None, extra_args=None):
        """<comment-ja>
        指定したドメイン名が正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするドメイン名
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether domainname is valid format.

        @param name: Item name
        @param value: domain name
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if extra_args:
            domain = extra_args
        else:
            domain = "your.domain.name"

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if value and ret_val:
            if check & CHECK_VALID:
                if value != "localhost" and not re.compile(r'.*\.').match(value):

                    ret_val = False
                    self.add_error(_('%s must include at least one dot . character.') % (name,))

                if re.compile(r'(^\.|.*\.$|.*\.\.|.*-\.|.*\.-|^-|.*-$)', re.VERBOSE).match(value):
                    ret_val = False
                    self.add_error(_('%s must be specified like %s.') % (name, domain))

                ret_val = self.check_string(name, value, check, "[^-a-zA-Z0-9\.]+") and ret_val
                if ret_val is False:
                    self.add_error(_('Available characters are'))
                    self.add_error(_('a-z A-Z 0-9 . -'))

        return ret_val 

    def check_hostname(self, name, value, check, min=None ,max=None):
        """<comment-ja>
        指定したホスト名が正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするホスト名
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether hostname is valid format. (not FQDN)

        @param name: Item name
        @param value: host name
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if value and ret_val:
            if check & CHECK_VALID:

                if re.compile(r".*\.", re.VERBOSE).match(value):
                    ret_val = False
                    self.add_error(_('%s must not include dot . character.') % (name,))

                if re.compile(r"(^-|.*-$)", re.VERBOSE).match(value):
                    ret_val = False
                    self.add_error(_('%s cannot begin or end with a hyphen.') % (name,))

                ret_val = self.check_string(name, value, check, "[^-a-zA-Z0-9]")
                if ret_val is False:
                    self.add_error(_('Available characters are'))
                    self.add_error(_('a-z A-Z 0-9 -'))

        return ret_val 

    def check_mailaddress(self, name, value, check, min=None, max=None, extra_args=None):
        """<comment-ja>
        指定したメールアドレスが正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするメールアドレス
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether mail address is valid format.

        @param name: Item name
        @param value: mail address
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if extra_args:
            domain = extra_args
        else:
            domain = "your.domain.name"

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if value and ret_val:
            if check & CHECK_VALID:

                regex = "^(?P<localpart>[^@]+)@(?P<domainpart>.+)?$"
                m = re.compile(regex).search(value)
                if m:
                  tstr1 = m.group("localpart")
                  tstr2 = m.group("domainpart")
                  ret_val = ret_val and self.check_username_with_num(name, tstr1, check, 1, 64)
                  ret_val = ret_val and self.check_domainname(_('Domain name part of %s') % (name,), tstr2, CHECK_EMPTY|check, 4, 255, domain)
                else:
                  ret_val = False
                  self.add_error(_('%s is in an invalid format.') % (name,))
                  self.add_error(_('Please specify like username@%s.') % (domain,))

        return ret_val

    def check_ipaddr(self, name, value, check):
        """<comment-ja>
        指定したIPアドレスが正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするIPアドレス
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether IP address is valid format.

        @param name: Item name
        @param value: IP address
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if value and ret_val:
            if check & CHECK_VALID:
                from karesansui.lib.networkaddress import NetworkAddress

                if not NetworkAddress(value).valid_addr():
                    ret_val = False
                    self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_macaddr(self, name, value, check):
        """<comment-ja>
        指定したMACアドレスが正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするMACアドレス
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether MAC address is valid format.

        @param name: Item name
        @param value: MAC address
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and (check & CHECK_VALID) and len(value) > 0:
            regex = '^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$'
            m = re.compile(regex).search(value)
            if not m:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_netmask(self, name, value, check):
        """<comment-ja>
        指定したネットマスクが正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするネットマスク
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether netmask is valid format.

        @param name: Item name
        @param value: netmask
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if value and ret_val:
            if check & CHECK_VALID:
                from karesansui.lib.networkaddress import NetworkAddress

                if not NetworkAddress().valid_netmask(value):
                    ret_val = False
                    self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_cidr(self, name, value, check):
        """<comment-ja>
        指定したネットワークアドレス（CIDR）が正しいフォーマットであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするネットワークアドレス
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether cidr-style network address is valid format.

        @param name: Item name
        @param value: network address
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if value and ret_val:
            if check & CHECK_VALID:
                from karesansui.lib.networkaddress import NetworkAddress

                if not NetworkAddress(value).valid_addr():
                    ret_val = False
                    self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_netdev_name(self, name, value, check):
        """<comment-ja>
        指定したネットワークデバイス名が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするネットワークデバイス名
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether network device name is in valid format.

        @param name: Item name
        @param value: Network device name
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and (check & CHECK_VALID):
            regex = "^[a-z][a-z0-9\.\:]{1,12}$" # what is a valid net dev name in linux?
            m = re.compile(regex).search(value)
            if not m:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_network_name(self, name, value, check):
        """<comment-ja>
        指定したネットワーク名が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするネットワーク名
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether network name is in valid format.

        @param name: Item name
        @param value: Network name
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and (check & CHECK_VALID):
            # Depend on maximum length of pid file name for dnsmasq.
            # len("<network_name>.pid") <= 256
            # libvirt allow space or other special chars,
            # but virsh command cannot parse space-included name.
            regex = "^[a-zA-Z0-9][a-zA-Z0-9\_\.\:\-]{0,251}$"
            m = re.compile(regex).search(value)
            if not m:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_password(self, name, pass1, pass2, check, min=None, max=None):
        """<comment-ja>
        指定したパスワードが正しいかどうかをチェックする

        @param name: 入力項目名
        @param pass1: チェックするパスワード
        @param pass2: チェックするパスワード（再入力）
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether two passwords is valid format or same.

        @param name: Item name
        @param pass1: password
        @param pass2: password (retype)
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(pass1, int):
            pass1 = str(pass1)

        if isinstance(pass2, int):
            pass2 = str(pass2)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, pass1)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, pass1, min, max)

        if pass1 != "" or pass2 != "":
            if ret_val and (check & CHECK_VALID):
                if pass1 != pass2:
                    ret_val = False
                    self.add_error(_('%s is mismatched.') % (name,))
                if not is_ascii(pass1):
                    ret_val = False
                    self.add_error(_('%s includes invalid character[s].') % (name))

            if ret_val and (check & WARN_LENGTH):
                if len(pass1) < min or len(pass2) < min:
                    ret_val = False
                    self.add_error(_('WARNING: %s is too short.') % (name,))

            if ret_val and (check & CHECK_CHAR):
                m = re.compile(r'^[0-9]+$').search(pass1)
                if m:
                    ret_val = False
                    self.add_error(_('%s must not consist of only numbers.') % (name,))

        return ret_val

    def check_unique_key(self, name, value, check):
        ret_val = True

        if is_int(value):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
        if ret_val:
            if check & CHECK_VALID: 
                if not is_uuid(value):
                    ret_val = False
                    self.add_error(_('%s is invalid format.') % (name,))
        return ret_val

    def check_datetime_string(self, name, value, check, languages):
        """<comment-ja>
        指定した日付を示す文字列が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: 日時を示す文字列
        @param check: チェックする条件
        @param languages: 言語
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether datetime string is valid format.

        @param name: Item name
        @param value: string of datetime
        @param check: condition to determine
        @param languages: languages
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if is_int(value):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if check & CHECK_VALID:
            try:
                str2datetime(value, DEFAULT_LANGS[languages]['DATE_FORMAT'][0])
             
            except (TypeError, ValueError):
                ret_val = False
                self.add_error(_('%s is invalid format.') % (name,))

        return ret_val

    def check_dictionary(self, name, value, check, extra_args):
        """<comment-ja>
        指定した辞書が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする辞書
        @param check: チェックする条件
        @param extra_args: 調査するキー、値を要素とする配列
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether specified dictionary is valid.

        @param name: Item name
        @param value: dictionary
        @param check: condition to determine
        @param extra_args: array includes the searched value.
        @return: result
        @rtype: boolean
        </comment-en>
        """
        # ret_val is False. Because, suppose that the dictionary does not have the value
        ret_val = False
        empty_val = True

        if is_int(value):
            value = str(value)

        if check & CHECK_EMPTY:
            empty_val = self.check_empty(name, value)
        ret_val = ret_val and empty_val

        if empty_val is True:
            if check & CHECK_DICTVALUE:
                if value in str(extra_args.values()):
                    ret_val = True
                if not ret_val:
                    self.add_error(_('%s is in invalid format.') % (name,))

            if check & CHECK_DICTKEY:
                if extra_args.has_key(value):
                    ret_val = True
                if not ret_val:
                    self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_uri(self, name, value, check):
        """<comment-ja>
        指定したURIが正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするURI
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether uri is valid format.

        @param name: Item name
        @param value: uri
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and (check & CHECK_VALID):
            regex = '^(http|ftp):\/\/[\w.]+\/(\S*)'
            m = re.compile(regex).search(value)
            if not m:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val
          
    def check_languages(self, name, value, check, min=None, max=None):
        """<comment-ja>
        指定した言語が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする言語名
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine language name is valid.

        @param name: Item name
        @param value: language name
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)

        if value.strip() != "":
            if ret_val and (check & CHECK_VALID):
                if not value in DEFAULT_LANGS.keys():
                    ret_val = False
                    self.add_error(_('%s is mismatched.') % (name,))

        return ret_val

    def check_image(self, name, value, check, min=None, max=None):
        """<comment-ja>
        画像データが正しいかどうかをチェックする。

        @param name: 入力項目名
        @param value: チェックする画像データ
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether image data is valid.

        @param name: Item name
        @param value: image data
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        """
        # TODO Image size check
        if ret_val and check & CHECK_LENGTH:
            ret_val = self.check_length(name, value, min, max)
        """

        if ret_val and (check & CHECK_VALID):
                if not value == "":
                    if not imghdr.what(None, value) in IMAGE_EXT_LIST:
                        ret_val = False
                        self.add_error(_('%s is in invalid format.') % (name,))

        return ret_val

    def check_hypervisor(self, name, value, check, min=None, max=None):
        """<comment-ja>
        指定したハイパーバイザーの値が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするハイパーバイザーの値
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine hypervisor name is valid.

        @param name: Item name
        @param value: hypervisor value
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and (check & CHECK_MIN):
            ret_val = self.check_number(name, value, CHECK_MIN, min, max)

        if ret_val and (check & CHECK_MAX):
            ret_val = self.check_number(name, value, CHECK_MAX, min, max)

        if ret_val and (check & CHECK_VALID):
            value = int(value)
            if not value in MACHINE_HYPERVISOR.values():
                ret_val = False
                self.add_error(_('%s is mismatch.') % (name,))

        return ret_val

 
    def check_status(self, name, value, check, status_list = []):
        """<comment-ja>
        状態値が正しい値かチェックする

        @param name: 入力項目名
        @param value: チェックするステータスの値
        @param check: チェックする条件
        @param status_list: 突き合わせるステータスのリスト
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether status data is valid.

        @param name: Item name
        @param value: status value
        @param check: condition to determine
        @param status_list: status value list
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = False
        empty_val = True

        if isinstance(value, int):
            value = str(value)
        if check & CHECK_EMPTY:
            empty_val = self.check_empty(name , value)

        if (empty_val is True) and (check & CHECK_VALID):
            for elem in status_list:
                if value == str(elem): 
                    ret_val = True

            if ret_val is False:
                self.add_error(_('%s is invalid format.') % (name,))

        ret_val = ret_val and empty_val
        return ret_val

    def check_startfile(self, name, value, check):
        """<comment-ja>
        指定した起動ファイル(vmlinuz, initrd)のパスが正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする起動ファイル(vmlinuz, initrd)のパス
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether start file(vmlinuz, initrd) path is valid format.

        @param name: Item name
        @param value: start file(vmlinuz, initrd) path
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ( not(check & CHECK_EMPTY) and value) or ret_val:

            _http_flag = False
            _file_flag = False
            if check & CHECK_VALID:

                regex = '^(http|ftp):\/\/[\w.\-]+\/(\S*)'
                m = re.compile(regex).search(value)
                if m:
                    _http_flag = True

                if re.compile("^[\"\']?/").match(value):
                    _file_flag = True

                if _http_flag is False and _file_flag is False:
                    ret_val = False
                    self.add_error(_('%s is in invalid format.') % (name,))

            if ret_val and (check & CHECK_EXIST):
                # TODO http path exist valid
                if _file_flag is True:
                    if not os.path.exists(value):
                        ret_val = False
                        self.add_error(_('No such %s [%s].') % (name, value))

            return ret_val

    def check_uniqueness(self, names, values, check):
        """<comment-ja>
        与えられた値が一意であるかを確認する。

        @param names: 入力項目名の配列
        @param value: 値の配列
        @param check: チェックする条件(CHECK_UNIQUEのみサポート)
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether values are unique.

        @param names: List of item names.
        @param value: List of values.
        @param check: Condition to check. (supports only CHECK_UNIQUE)
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True
        if len(values) != len(set(values)):
            ret_val = False
            self.add_error(_('Values for %s should be unique.') % (','.join(names),))

        return ret_val

    def check_if_ips_are_in_network(self, names, ips, network, check):
        """<comment-ja>
        与えられたIPアドレス値がネットワークに含まれるかどうかを確認する。
        CHECK_UNIQUEを与えることで、ipsとnetworkを通して各値が一意であるかどうかも確認することができる。

        @param names: 入力項目名の配列
        @param ips: IPアドレス値の配列（'192.168.0.1','192.168.0.1/24'表記。ネットマスクは無視される。）
        @param network: ネットワークアドレスを計算するための文字列（'192.168.0.1/24', '192.168.0.1/255.255.255.0'等）
        @param check: チェックする条件(CHECK_VALID, CHECK_UNIQUEをサポート)
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether IP address are in Network.
        Also checks uniqueness between ips and network when CHECK_UNIQUE provided.

        @param names: List of item names.
        @param ips: List of IP address (strings as '192.168.0.1' or '192.168.0.1/24'. Netmask part will be ignored)
        @param network: String to calculate network address ('192.168.0.1/24', '192.168.0.1/255.255.255.0')
        @param check: Condition to check. (supports CHECK_VALID, CHECK_UNIQUE)
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True
        na = NetworkAddress(network)
        if check & CHECK_VALID:
            for i in range(0, len(ips)):
                ip = ips[i]; name = names[i]
                if not na.network_includes_address(ip):
                    ret_val = False
                    self.add_error(_('%(ip)s for %(name)s is not in network %(cidr)s') % {'ip':ip, 'name':name, 'cidr':na.cidr})

        if check & CHECK_UNIQUE: 
            if len(ips) != len(set(ips)):
                ret_val = False
                self.add_error( _('IP address for %s should be unique.')  % (','.join(names)))

        return ret_val

    def check_ip_range(self, names, ips, check):
        """<comment-ja>
        与えられたIPアドレス値が正しく範囲を表しているかどうかを確認する。

        @param names: 入力項目名の配列
        @param ips: [開始値, 終了値, 独立値]形式の配列。独立値は範囲に含まれない値を表し、省略可能。　
        @param check: チェックする条件（CHECK_VALIDをサポート）
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether IP address are in valid range.

        @param names: List of item names.
        @param ips: List of IP address as [ start_ip, end_ip, individual_ip ]. individual_ip which can be omitted, stands for an IP address not in the range between start_ip and end_ip.
        @param check: Condition to check. (supports CHECK_VALID)
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if check & CHECK_VALID:
            start_ip = NetworkAddress(ips[0]).get('ipaddr', 'num')
            end_ip   = NetworkAddress(ips[1]).get('ipaddr', 'num')

            if not (end_ip > start_ip):
                ret_val = False
                self.add_error( _('IP address range %s to %s is not valid.') % (ips[0], ips[1]) )

            if len(ips) > 2:
                # Perform individual IP check
                ind_ip = NetworkAddress(ips[2]).get('ipaddr', 'num')
                if not((ind_ip < start_ip) or (end_ip < ind_ip)):
                    ret_val = False
                    self.add_error( _('IP address %s should not be in range %s to %s') % (ips[2], ips[0], ips[1]))

        return ret_val

    def check_virt_network_address_conflict(self, name, cidr, ignore_names, check):
        """<comment-ja>
        与えられたネットワークIPアドレス範囲がlibvirt上の他のネットワークアドレス範囲
        と競合しないかどうか（ネットワークアドレス範囲の重なり合いが無いか）を確認する。

        @param name: 入力項目名
        @param cidr: '192.168.0.1/24', '192.168.0.1/255.255.255.0'形式でのネットワークアドレス指定。
        @param ignore_names: 衝突をチェックしない／無視するネットワーク名の配列。
        @param check: チェックする条件（CHECK_VALIDをサポート）
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether a network IP address range does not conflict with other libvirt network.

        @param names: Item name
        @param cidr: Network address specification in '192.168.0.1/24' or '192.168.0.1/255.255.255.0' format.
        @param ignore_names: List of name of networks to ignore/do not perform check.
        @param check: Condition to check. (supports CHECK_VALID)
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        new_na = NetworkAddress(cidr)

        if check & CHECK_VALID:
            try:
                kvc = KaresansuiVirtConnection()
                networks = kvc.search_kvn_networks()
                for network in networks:
                    if network.get_network_name() in ignore_names:
                        pass
                    else:
                        info = network.get_info()
                        existing_na_cidr = '%s/%s' % (info['ip']['address'], info['ip']['netmask'])
                        existing_na = NetworkAddress(existing_na_cidr)

                        conflict = False
                        # New-one in existing-one
                        if existing_na.network_includes_address(new_na.network): conflict = True
                        # Existing-one in new-one
                        if new_na.network_includes_address(existing_na.network): conflict = True
                        if conflict:
                            ret_val = False
                            self.add_error( _('Network address %s for %s is used by other network (%s)') % (cidr, name, network.get_network_name()))
            finally:
                kvc.close()

        return ret_val

    def check_forward_mode(self, name, value, check):
        """<comment-ja>
        指定した転送モード(networkの)が正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする転送モード
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether network forward mode is in a valid format.

        @param name: Item name
        @param value: Forward mode
        @param check: Condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;
        if check & CHECK_VALID:
            if value == 'nat' or value == '':
                ret_val = True
            else:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name))
        return ret_val

    def check_firewall_policy(self, name, value, check):
        """<comment-ja>
        指定したポリシーが正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするポリシー
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether firewall policy is valid format.

        @param name: Item name
        @param value: firewall policy
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """

        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and (check & CHECK_VALID):
            if not value in KaresansuiIpTables().basic_targets['filter']:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name))

        return ret_val
    
    def check_firewall_protocol(self, name, value, check):
        """<comment-ja>
        指定したプロトコルが正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするプロトコル
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether firewall policy is valid format.

        @param name: Item name
        @param value: firewall protocol
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """

        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)
 
        if ret_val and value and (check & CHECK_VALID):
            if not value in KaresansuiIpTables().chain_protos:
                ret_val = False
                self.add_error(_('%s is in invalid format.') % (name))

        return ret_val

    def check_firewall_if(self, name, value, check): 
        """<comment-ja>
        指定したインターフェースが実在するものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするプロトコル
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether firewall policy is valid format.

        @param name: Item name
        @param value: firewall protocol
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """

        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and value and (check & CHECK_EXIST):
            devtype_regexs = {
                "phy":"^(lo|eth)",
                "vir":"^(xenbr|virbr|vif|veth)",
                }
            devtype_phy_regex = re.compile(r"%s" % devtype_regexs['phy'])
            devtype_vir_regex = re.compile(r"%s" % devtype_regexs['vir'])
            
            devs = {}
            interfaces = []
            devs['phy'] = []
            devs['vir'] = []
            devs['oth'] = []
            cidrs = []
            ips = []
            for dev,dev_info in get_ifconfig_info().iteritems():
                try:
                    if devtype_phy_regex.match(dev):
                        devs['phy'].append(dev)
                    elif devtype_vir_regex.match(dev):
                        devs['vir'].append(dev)
                    else:
                        devs['oth'].append(dev)
                    if dev_info['ipaddr'] is not None:
                        if not dev_info['ipaddr'] in ips:
                            ips.append(dev_info['ipaddr'])
                    if dev_info['cidr'] is not None:
                        if not dev_info['cidr'] in cidrs:
                            cidrs.append(dev_info['cidr'])
                except:
                    pass
            for devlist in devs.itervalues():
                interfaces.extend(devlist)

            if not value in interfaces:
                ret_val = False
                self.add_error(_('No such %s [%s].') % (name, value))

        return ret_val


    def check_keymap(self, name, value, check, domain_type="xen"):
        """<comment-ja>
        指定したキーマップが実在するものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックするキーマップ
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether keymap is valid format.

        @param name: Item name
        @param value: keymap
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if ret_val and value and (check & CHECK_EXIST):
            exec("keymap_dir = %s_KEYMAP_DIR" % domain_type.upper())
            if not os.path.exists(keymap_dir + '/' + value):
                ret_val = False
                self.add_error(_('No such %s [%s].') % (name, value))

        return ret_val

    def check_fraction(self, name, value, check, min=None, max=None, precision=None):
        """<comment-ja>
        指定した実数値が正しいものであるかどうかをチェックする

        @param name: 入力項目名
        @param value: チェックする実数値
        @param check: チェックする条件
        @param min: 最小値
        @param max: 最大値
        @param precision: 小数点以下の桁数
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether fraction is valid format or in specified range.

        @param name: Item name
        @param value: interger
        @param check: condition to determine
        @param min: the minimum length
        @param max: the maximum length
        @param precision: Number of decimal places
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True;

        if isinstance(value, int):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if value!="" and ret_val:
            arr_dp = re.compile("^([-+]?[0-9]+)\.([0-9]+)$").match(value)

            if arr_dp:
                integer = arr_dp.group(1)
                fraction = arr_dp.group(2)
            else:
                integer = value
                fraction = "0"

            if check & CHECK_VALID:
                if not re.compile("^[-+]?[0-9]+$").match(integer) or not re.compile("^[0-9]+$").match(fraction):
                    ret_val = False
                    self.add_error(_('%s is not integer or decimal fraction.') % (name,))
                elif len(fraction) > precision:
                    ret_val = False
                    self.add_error(_('(%s) Length of figures after point must be equal or less than %s.') % (name,str(precision)))

            if ret_val and (check & CHECK_MIN):
                value = float(value)
                if value < min:
                    ret_val = False
                    self.add_error(_('%s must be greater than %d.') % (name, min))

            if ret_val and (check & CHECK_MAX):
                value = float(value)
                if value > max:
                    ret_val = False
                    self.add_error(_('%s must be smaller than %d.') % (name, max))

        return ret_val

    def check_time_string(self, name, value, check):
        """<comment-ja>
        時刻を示す文字列が正しいかどうかをチェックする

        @param name: 入力項目名
        @param value: 時刻を示す文字列
        @param check: チェックする条件
        @return: チェック結果
        @rtype: boolean
        </comment-ja>
        <comment-en>
        Determine whether time string is valid format.

        @param name: Item name
        @param value: string of datetime
        @param check: condition to determine
        @return: result
        @rtype: boolean
        </comment-en>
        """
        ret_val = True

        if is_int(value):
            value = str(value)

        if check & CHECK_EMPTY:
            ret_val = self.check_empty(name, value)

        if check & CHECK_VALID:
            time_regex = re.compile("^([0-1][0-9]|[2][0-3]|[0-9]):[0-5][0-9]$")
            if not time_regex.match(value):
                ret_val = False
                self.add_error(_('%s is invalid format.') % (name,))

        return ret_val

########NEW FILE########
__FILENAME__ = log
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
karesansui 警告ログを書き込む

引数2：ログ文字列
引数3：ログのレベルの重要度
"""

import os
import time
from karesansui.lib.collectd.utils import append_line
from karesansui.lib.const import COLLECTD_LOG_DIR

TIMESTAMP_FORMAT = "syslog"
TIMESTAMP_FORMAT = "Y-m-d"

COLLECTD_ALERT_LOG = "%s/alert.log" % COLLECTD_LOG_DIR

if TIMESTAMP_FORMAT == "syslog":
    COLLECTD_ALERT_LOG_TIMESTAMP_FORMAT = "%b %d %H:%M:%S"
else:
    COLLECTD_ALERT_LOG_TIMESTAMP_FORMAT = "%Y-%m-%d %H:%M:%S:"

def write_log(string,priority="WARNING"):

    priorities = [
              "DEBUG",
              "INFO",
              "OKAY",
              "WARNING",
              "FAILURE",
              ]

    rotate_log()

    # ログの書き込み
    msg = "%s [%s] %s" % (time.strftime(COLLECTD_ALERT_LOG_TIMESTAMP_FORMAT,time.localtime(time.time())),priority,string,)
    append_line(COLLECTD_ALERT_LOG,msg)

    return

def rotate_log(number=10,size=1024000):

    return


########NEW FILE########
__FILENAME__ = mail
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
collectdの通知メールを送信する

引数１：宛先メールアドレス
引数２：差出人メールアドレス
引数３：SMTPサーバー名
引数４：SMTPポート名
引数５：本文
引数６：拡張メッセージ
引数７：監視項目名
引数８：ログファイル

"""

DEFAULT_SUBJECT = "[Karesansui notification] '%{watch_name}' threshold exceeded"
DEFAULT_SENDER  = "root@localhost"

import os, sys, re

from karesansui.lib.collectd.utils import append_line
from karesansui.lib.net.mail       import MAIL_LIB, MAIL_LIB_Exception
from karesansui.lib.utils          import preprint_r, ucfirst
from karesansui.lib.parser.eml     import emlParser

from karesansui import __version__, __release__, __app__
AppName = "%s %s" % (ucfirst(__app__),__version__,)

def send_mail(recipient=None, sender=None, server="localhost", port=25, message="", extra_message="", watch_name="", logfile="/dev/null"):
    retval = False

    func_name = sys._getframe(0).f_code.co_name
    append_line(logfile,"[%s] Entering function '%s'." % (func_name,func_name,))

    smtp_server = server.split(":")[0]
    try:
        smtp_port = int(port)
    except:
        smtp_port = 25

    try:
        socket_timeout
    except:
        socket_timeout = 30

    if recipient is not None:

        append_line(logfile,"[%s] Connecting SMTP server" % (func_name,))
        append_line(logfile,"[%s] smtp_server :%s" % (func_name,smtp_server,))
        append_line(logfile,"[%s] smtp_port   :%s" % (func_name,smtp_port,))

        mail = MAIL_LIB(smtp_server,smtp_port)

        if socket_timeout is None:
            socket_timeout = 30
        mail.set_timeout(int(socket_timeout))

        mail.set_verbosity(0)

        if sender is None:
            mail.set_sender(DEFAULT_SENDER)
        else:
            mail.set_sender(sender)

        mail.encoding   = "utf-8"

        mail.set_recipients(recipient.split(","))
        append_line(logfile,"[%s] recipient   :%s" % (func_name,recipient,))

        # デフォルトのヘッダをセット
        headers = {}
        headers['Subject'] = re.sub("\%\{watch_name\}",watch_name,DEFAULT_SUBJECT)

        # カテゴリ用のヘッダとボディを上書きでセット
        rawbody = ""
        try:
            append_line(logfile,"[%s] message   :%s" % (func_name,message,))
            try:
                del headers["Content-Transfer-Encoding"]
                message = message.encode('utf-8')
                message = str(message)
            except:
                pass
            append_line(logfile,"[%s] lang %s" % (func_name,os.environ['LANG']))
            extra_args = {"message":message}
            eml = emlParser().read_conf(extra_args=extra_args)
            parse_ret = preprint_r(eml,return_var=True)
            append_line(logfile,"[%s] parse_ret   :%s" % (func_name,parse_ret,))

            header  = eml['@message']['value']['header']['value']
            rawbody += eml['@message']['value']['rawbody']['value']
            for _k,_v in header.iteritems():
                headers[_k] = _v['value']
        except:
            pass
        try:
            extra_message = extra_message.encode('utf-8')
        except:
            pass
        rawbody += "\n\n" + extra_message

        # Add footer
        rawbody += "\n\n" + "(brought to you by %s)" % AppName

        append_line(logfile,"[%s] rawbody   :%s" % (func_name,rawbody,))

        mail.set_body(rawbody)

        # 一旦メッセージを生成
        mail.create_message()

        #preprint_r(mail.msg._headers)
        for _k,_v in headers.iteritems():
            append_line(logfile,"[%s] Headers %-12s: %s" % (func_name,_k,_v))
            try:
                del mail.msg[_k]
            except:
                pass
            if _k == "Subject":
                try:
                    mail.set_subject(_v.encode('utf_8'))
                except:
                    mail.set_subject(_v)
            else:
                mail.msg[_k] = _v

        try:
            del mail.msg["Content-Transfer-Encoding"]
            mail.msg["Content-Transfer-Encoding"] = "base64"
        except:
            pass

        for _header in mail.msg._headers:
            append_line(logfile,"[%s] Header %-12s: %s" % (func_name,_header[0],_header[1]))
        #sys.exit()

        try:
            mail.send()
            retval = True
        except MAIL_LIB_Exception, msg:
            append_line(logfile,"[%s] Error: %s" % (func_name,str(msg),))
        except Exception:
            append_line(logfile,"[%s] Error: failed to send mail." % (func_name,))

    else:
        append_line(logfile,"[%s] Error: recipient is not set." % (func_name,))

    append_line(logfile,"[%s] Leaving function '%s'." % (func_name,func_name,))
    return retval

if __name__ == '__main__':
    """Testing
    """
    recipient = "taizo@localhost"
    recipient = "root@localhost"
    sender    = None
    server = "localhost"
    logfile = "/dev/stdout"
    watch_name = u'\u30e1\u30e2\u30ea\u4f7f\u7528\u91cf\u3067\u3059'

    message = """Message-ID: <67147291.1.1231874007256.JavaMail.taizo@karesansui-project.info>
Subject: Hello, World!!
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="----=_Part_0_22060966.1231404007271"

------=_Part_0_22060966.1231404007271
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

E-Mail created by Application
------=_Part_0_22060966.1231404007271
Content-Type: application/pdf; name=HelloWorld_007.pdf
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=HelloWorld_007.pdf
Content-ID: Attachment

JVBERi0xLjMgCiXi48/TIAo3IDAgb2JqCjw8Ci9Db250ZW50cyBbIDggMCBSIF0gCi9QYXJlbnQg

------=_Part_0_22060966.1231404007271--
    """

    message = """Message-ID: <67147291.1.1231874007256.JavaMail.taizo@karesansui-project.info>
Subject: Hello, World!!
MIME-Version: 1.0

Hello World!!
    """
    message = """From: 
To: 
Subject: 
Content-Type: text/plain; charset=ISO-2022-JP
Content-Transfer-Encoding: 7bit

ほげ
Failure

    """

    message = """Subject: [Karesansui Notifier] 危険値を越えました。CPU - %{type_instance}
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

レポート時刻: %{current_time}

ホスト %{hostname} の CPU %{type_instance} が危険値を越えました。

危険値は、%{failure_max} に設定されています。
現在の値は、 %{current_value} です。

    """

    extra_message = u'\u30e1\u30e2\u30ea\u4f7f\u7528\u91cf\u3067\u3059'
    send_mail(recipient=recipient,sender=sender,server=server,message=message,extra_message=extra_message,watch_name=watch_name,logfile=logfile)
    pass


########NEW FILE########
__FILENAME__ = script
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
シェルスクリプトを実行する

引数１：スクリプトの内容
引数２：実行ユーザー
引数３：メッセージ
引数４：監視項目名
引数５：ログファイル

"""

import os, sys, pwd, re, fcntl, tempfile

from karesansui.lib.const import KARESANSUI_PREFIX, KARESANSUI_DATA_DIR, \
                                 KARESANSUI_USER, KARESANSUI_GROUP
from karesansui.lib.utils import execute_command, r_chmod, r_chown, r_chgrp
from karesansui.lib.collectd.utils import append_line

def exec_script(script="",user="root",msg="",watch_name="",logfile="/dev/null"):
    retval = False

    func_name = sys._getframe(0).f_code.co_name
    append_line(logfile,"[%s] Entering function '%s'." % (func_name,func_name,))

    # スクリプトの一時保存ディレクトリを作成
    SCRIPT_TMP_DIR = "%s/tmp/.script" % (KARESANSUI_DATA_DIR,)
    if not os.path.exists(SCRIPT_TMP_DIR):
        os.makedirs(SCRIPT_TMP_DIR)
        r_chmod(SCRIPT_TMP_DIR,0770)
        r_chown(SCRIPT_TMP_DIR,KARESANSUI_USER)
        r_chgrp(SCRIPT_TMP_DIR,KARESANSUI_GROUP)
        append_line(logfile,"[%s] Create directory '%s'." % (func_name,SCRIPT_TMP_DIR,))

    try:
       user_id = int(user)
    except:
       user_id = pwd.getpwnam(user)[2]

    # スクリプトファイルの生成
    fname = None
    try:
        fd, fname  = tempfile.mkstemp(suffix="",prefix="script_",dir=SCRIPT_TMP_DIR)
        append_line(logfile,"[%s] Create script '%s'." % (func_name,fname,))
        fp = os.fdopen(fd,"w")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_EX)
        script = re.sub("%{watch_name}",watch_name.encode('utf_8'),script)
        script = re.sub("%{msg}"       ,msg.encode('utf_8')       ,script)
        fp.write(script)
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
        os.chmod(fname,0700)
        os.chown(fname,user_id,-1)

    except:
        append_line(logfile,"[%s] Error: failed to create script." % (func_name,))
        if fname is not None and os.path.exists(fname):
            os.unlink(fname)

    if fname is not None and os.path.exists(fname):

        # マジッククッキーを調べる
        magic_cookie = open(fname).readline().rstrip()
        if magic_cookie[-8:] == "bin/perl":
            interpreter = "perl"
        elif magic_cookie[-10:] == "bin/python" or \
             magic_cookie[-10:] == "env python":
            interpreter = "python"
        elif magic_cookie[-7:] == "bin/php":
            interpreter = "php"
        elif magic_cookie[-8:] == "bin/ruby":
            interpreter = "ruby"
        elif magic_cookie[-8:] == "bin/tcsh":
            interpreter = "tcsh"
        elif magic_cookie[-7:] == "bin/csh":
            interpreter = "csh"
        else:
            interpreter = "sh"

        # コマンド文字列の作成
        if os.getuid() != user_id:
            command_args = ["su","-s", "/bin/bash", user, fname]
        else:
            command_args = [interpreter,fname]

        # コマンドの実行
        append_line(logfile,"[%s] Execute command '%s'." % (func_name," ".join(command_args),))
        (rc,res) = execute_command(command_args)
        new_res = []
        for _aline in res:
            append_line(logfile,"[%s] output> %s" % (func_name,_aline,))
            _aline = re.sub("^%s:[ \t]+" % fname, "", _aline)
            new_res.append(_aline)
            pass
        append_line(logfile,"[%s] command return value = %d" % (func_name,rc,))

        os.unlink(fname)

        retval = [rc,new_res]
    else:
        append_line(logfile,"[%s] Error: cannot create script file." % (func_name,))

    append_line(logfile,"[%s] Leaving function '%s'." % (func_name,func_name,))
    return retval

if __name__ == '__main__':
    """Testing
    """

    script = """#!/usr/bin/env python
import time
print time.strftime("%c", time.localtime(time.time()))
print '%{watch_name}'
print '%{msg}'
"""

    script = """#!/bin/sh

logfile="/tmp/exec_script.log"
whoami                >${logfile}
id                   >>${logfile}
echo '%{watch_name}' >>${logfile}
echo '%{msg}'        >>${logfile}
exit 0
"""
    user       = "kss"
    watch_name = u'\u30e1\u30e2\u30ea\u4f7f\u7528\u91cf\u3067\u3059'
    alert_msg  = u"foo blahhh"
    logfile = "/dev/stdout"

    exec_script(script=script,user=user,msg=alert_msg,watch_name=watch_name,logfile=logfile)
    pass


########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import types

from karesansui.lib.conf import read_conf, write_conf
from karesansui.lib.utils import uniq_sort
from karesansui.lib.utils import preprint_r
from karesansui.lib.collectd.utils import create_plugin_selector, plugin_selector_to_dict
from karesansui.lib.const import VENDOR_PREFIX, KARESANSUI_PREFIX, \
                                 VENDOR_DATA_DIR, \
                                 COUNTUP_DATABASE_PATH, COLLECTD_LOG_DIR, \
                                 COLLECTD_DF_RRPORT_BY_DEVICE

from karesansui.lib.parser.collectdplugin import PARSER_COLLECTD_PLUGIN_DIR

MODULE = "collectd"

DictOp = None

DEFAULT_KARESANSUI_CONF = "/etc/karesansui/application.conf"

COLLECTD_PLUGIN_DIR = "%s/lib64/collectd" % VENDOR_PREFIX
if os.path.exists(COLLECTD_PLUGIN_DIR):
    COLLECTD_PLUGIN_DIR = "%s/lib/collectd" % VENDOR_PREFIX

COLLECTD_SHARE_DIR         = "%s/share/collectd" % VENDOR_PREFIX
KARESANSUI_PYTHON_PATH     = "%s/lib/python" % KARESANSUI_PREFIX
COLLECTD_PYTHON_MODULE_DIR = "%s/karesansui/lib/collectd" % KARESANSUI_PYTHON_PATH

COLLECTD_DATA_DIR          = "%s/collectd" % VENDOR_DATA_DIR
COLLECTD_PID_FILE          = "/var/run/collectd.pid"

#COLLECTD_PLUGINS = ["cpu", "df", "disk", "exec", "interface", "iptables", "libvirt", "load", "logfile", "memory", "network", "python", "rrdcached", "rrdtool", "sensors", "snmp", "syslog", "tail", "uptime", "users"]
#COLLECTD_PLUGINS = ["cpu", "df", "disk", "interface", "libvirt", "load", "logfile", "memory", "python", "rrdcached", "rrdtool", "sensors", "syslog"]
COLLECTD_PLUGINS = ["cpu", "df", "disk", "interface", "libvirt", "load", "logfile", "memory", "python", "rrdtool"]

def _get_collectd_config(webobj=None, host=None):
    modules = ["collectd","collectdplugin"]

    dop = read_conf(modules, webobj, host)
    if dop is False:
        return False

    return dop

DictOp = _get_collectd_config()

def get_collectd_param(param=None, section=None, dop=None, webobj=None, host=None):
    global DictOp
    retval = None

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    if section is None:
        if dop.cdp_isset("collectd",[param]) is True:
            return dop.cdp_get("collectd",[param])
    else:
        if not "collectdplugin" in dop.ModuleNames:
            dop.addconf("collectdplugin",{})

        from karesansui.lib.parser.collectdplugin import collectdpluginParser
        if dop.cdp_isset("collectdplugin",[section,"Plugin",section],multiple_file=True) is False:
            extra_args = {"include":"^(%s)$" % section}
            new_conf_arr =  collectdpluginParser().read_conf(extra_args)

            for _k,_v in new_conf_arr.iteritems():
                if _k[0:1] != "@":
                    dop.set("collectdplugin",[_k],_v['value'])

        if dop.cdp_isset("collectdplugin",[section,"Plugin",section,param],multiple_file=True) is True:
            return dop.cdp_get("collectdplugin",[section,"Plugin",section,param],multiple_file=True)

def plugin_list(webobj=None, host=None, dop=None):
    global DictOp
    retval = []

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    try:
        load_plugins = dop.query("collectd",["LoadPlugin"])
        if load_plugins is False:
            load_plugins = []
    except:
        load_plugins = []

    try:
        plugins = dop.getconf("collectdplugin")
        for _k,_v in plugins.iteritems():
            _load_plugins = dop.query("collectdplugin",[_k,"LoadPlugin"])
            if type(_load_plugins) is list or (_load_plugins is not False and len(_load_plugins) > 0):
                load_plugins = load_plugins + _load_plugins
        del plugins
    except:
        pass

    retval = uniq_sort(load_plugins)
    return retval

def active_plugin_list(webobj=None, host=None, dop=None):
    global DictOp
    retval = []

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    list = plugin_list(dop, webobj, host)
    #preprint_r(list)
    for plugin_name in list:
        iscomment = True
        if dop.isset("collectd",["LoadPlugin",plugin_name]) is True:
            iscomment = dop.iscomment("collectd",["LoadPlugin",plugin_name])

        if iscomment is True:
            plugins = dop.getconf("collectdplugin")
            for _k,_v in plugins.iteritems():
                if dop.isset("collectdplugin",[_k,"LoadPlugin",plugin_name]) is True:
                    iscomment = dop.iscomment("collectdplugin",[_k,"LoadPlugin",plugin_name])
                    break
            del plugins
        if iscomment is False:
            retval.append(plugin_name)

    return retval

def inactive_plugin_list(dop=None, webobj=None, host=None):
    global DictOp
    retval = []

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    list = plugin_list(dop, webobj, host)
    active = active_plugin_list(dop, webobj, host)
    for plugin_name in list:
        if not plugin_name in active:
            retval.append(plugin_name)

    return retval

def is_enabled_plugin(plugin_name, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    active = active_plugin_list(dop, webobj, host)
    if plugin_name in active:
        retval = True

    return retval

def enabled_plugin(plugin_name, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    active = active_plugin_list(dop, webobj, host)
    if not plugin_name in active:
        if dop.cdp_isset("collectd",["LoadPlugin",plugin_name]) is True:
            retval = dop.cdp_uncomment("collectd",["LoadPlugin",plugin_name])
        else:
            plugins = dop.getconf("collectdplugin")
            for _k,_v in plugins.iteritems():
                if dop.cdp_isset("collectdplugin",[_k,"LoadPlugin",plugin_name],multiple_file=True) is True:
                    retval = dop.cdp_uncomment("collectdplugin",[_k,"LoadPlugin",plugin_name],multiple_file=True)
                    break
            del plugins

    return retval

def disabled_plugin(plugin_name, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    active = active_plugin_list(dop, webobj, host)
    if plugin_name in active:
        if dop.cdp_isset("collectd",["LoadPlugin",plugin_name]) is True:
            retval = dop.cdp_comment("collectd",["LoadPlugin",plugin_name])
        else:
            plugins = dop.getconf("collectdplugin")
            for _k,_v in plugins.iteritems():
                if dop.cdp_isset("collectdplugin",[_k,"LoadPlugin",plugin_name],multiple_file=True) is True:
                    retval = dop.cdp_comment("collectdplugin",[_k,"LoadPlugin",plugin_name],multiple_file=True)
                    break
            del plugins

    return retval


def get_global_parameter(name, dop=None, webobj=None, host=None):
    global DictOp

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    retval = dop.cdp_get("collectd",[name])

    if retval is False:
        retval = dop.get("collectd",[name])

    return retval

def set_global_parameter(name, value, dop=None, webobj=None, host=None, is_cdp=True):
    global DictOp

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    if is_cdp is True:
        return dop.cdp_set("collectd",[name],value)
    else:
        return dop.set("collectd",[name],value)

def where_is_plugin(plugin_name, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    keyword = "LoadPlugin"
    keyword = "Plugin"

    if dop.cdp_isset("collectd",[keyword,plugin_name]) is True:
        retval = "@global"

    plugins = dop.getconf("collectdplugin")
    for _k,_v in plugins.iteritems():
        if dop.cdp_isset("collectdplugin",[_k,keyword,plugin_name]) is True:
            retval = _k
            break
    del plugins

    return retval

def switch_python_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "python"

    # まだ読み込まれていなければ読み込む
    from karesansui.lib.parser.collectdplugin import collectdpluginParser
    if dop.isset("collectdplugin",[configName]) is False:
        extra_args = {"include":"^(%s)$" % configName}
        new_conf_arr =  collectdpluginParser().read_conf(extra_args)
        for _k,_v in new_conf_arr.iteritems():
            if _k[0:1] != "@":
                dop.set("collectdplugin",[_k],_v['value'])

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","python","Globals"],"true",multiple_file=True)

    _keys = [configName,"Plugin","python"]

    keys = _keys + ["ModulePath"]
    value = "\"%s\"" % COLLECTD_PYTHON_MODULE_DIR
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Encoding"]
    value = "utf-8"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["LogTraces"]
    value = "true"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Interactive"]
    value = "false"
    dop.cdp_comment("collectdplugin",keys,multiple_file=True)
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Import"]
    value = "\"notification\""
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Module","notification","CountupDBPath"]
    value = "\"%s\"" % COUNTUP_DATABASE_PATH
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Module","notification","LogFile"]
    value = "\"%s/notification.log\"" % COLLECTD_LOG_DIR
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Module","notification","LogLevel"]
    value = "7"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Module","notification","Environ"]
    envs = []
    try:
        envs.append("LANG=%s" % os.environ["LANG"])
    except:
        pass
    try:
        envs.append("KARESANSUI_CONF=%s" % os.environ["KARESANSUI_CONF"])
    except:
        envs.append("KARESANSUI_CONF=%s" % DEFAULT_KARESANSUI_CONF)
        pass
    value = "\"" + "\" \"".join(envs) + "\""
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","python"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","python"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_python_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_python_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_python_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_python_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_syslog_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "syslog"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","syslog"],"syslog",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","syslog"]

    keys = _keys + ["LogLevel"]
    value = "\"info\""   # debug|info|notice|warning|err
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","syslog"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","syslog"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_syslog_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_syslog_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_syslog_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_syslog_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_logfile_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "logfile"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","logfile"],"logfile",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","logfile"]

    keys = _keys + ["LogLevel"]
    value = "\"debug\""   # debug|info|notice|warning|err
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Timestamp"]
    value = "true"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["File"]
    value = "\"%s/collectd.log\"" % COLLECTD_LOG_DIR
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["PrintSeverity"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","logfile"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","logfile"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_logfile_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_logfile_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_logfile_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_logfile_plugin(flag=False, dop=dop, webobj=webobj, host=host)



def switch_rrdtool_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "rrdtool"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","rrdtool"],"rrdtool",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","rrdtool"]

    keys = _keys + ["DataDir"]
    value = "\"%s\"" % COLLECTD_DATA_DIR
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["CacheTimeout"]
    value = "120"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["CacheFlush"]
    value = "900"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["RandomTimeout"]
    #value = "60"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["StepSize"]
    #value = "30"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["HeartBeat"]
    #value = "120"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["WritesPerSecond"]
    #value = "500"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["RRARows"]
    #value = "2400"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["RRATimespan"]
    #value = "144000"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    #keys = _keys + ["XFF"]
    #value = "0.1"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","rrdtool"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","rrdtool"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_rrdtool_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_rrdtool_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_rrdtool_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_rrdtool_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_rrdcached_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "rrdcached"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","rrdcached"],"rrdcached",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","rrdcached"]

    keys = _keys + ["DataDir"]
    value = "\"%s\"" % COLLECTD_DATA_DIR
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["DaemonAddress"]
    value = "\"unix:/var/run/rrdcached/rrdcached.sock\""
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["CreateFiles"]
    value = "true"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["CollectStatistics"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","rrdcached"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","rrdcached"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_rrdcached_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_rrdcached_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_rrdcached_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_rrdcached_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_memory_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "memory"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","memory"],"memory",multiple_file=True,is_opt_multi=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","memory"],recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","memory"],recursive=True,multiple_file=True)

def enable_memory_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_memory_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_memory_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_memory_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_cpu_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "cpu"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","cpu"],"cpu",multiple_file=True,is_opt_multi=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","cpu"],recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","cpu"],recursive=True,multiple_file=True)

def enable_cpu_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_cpu_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_cpu_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_cpu_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_disk_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "disk"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","disk"],"disk",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","disk"]

    keys = _keys + ["Disk"]
    value = "\"/^(([hs]|xv)d[a-f][0-9]?|([a-z]+\/)?c[0-9]d[0-9](p[0-9])?)$/\""
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["IgnoreSelected"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","disk"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","disk"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_disk_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_disk_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_disk_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_disk_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_df_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "df"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","df"],"df",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","df"]

    keys = _keys + ["ReportReserved"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["ReportInodes"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["ReportByDevice"]
    value = "%s" % str(COLLECTD_DF_RRPORT_BY_DEVICE).lower()
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["MountPoint"]
    #value = "\"/^\/(home|var|boot|usr)?/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全て対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    keys = _keys + ["Device"]
    #value = "192.168.0.2:/mnt/nfs"
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全て対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    keys = _keys + ["FSType"]
    #value = "\"/^(ext[234]|reiserfs|xfs|jfs)$/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全て対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    # 上記３つ(MountPoint,Device,FSType)で指定されたものを対象外にする場合はtrue
    keys = _keys + ["IgnoreSelected"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","df"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","df"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_df_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_df_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_df_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_df_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_interface_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "interface"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","interface"],"interface",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","interface"]

    keys = _keys + ["Interface"]
    #value = "\"/(eth[0-9]|lo|vif|virbr|xenbr)/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全て対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    # 上記Interfaceで指定されたものを対象外にする場合はtrue
    keys = _keys + ["IgnoreSelected"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","interface"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","interface"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_interface_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_interface_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_interface_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_interface_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_libvirt_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "libvirt"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","libvirt"],"libvirt",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","libvirt"]

    keys = _keys + ["HostnameFormat"]
    value = "name" # hostname|name|uuid
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    from karesansui.lib.utils import available_virt_mechs, available_virt_uris
    keys = _keys + ["Connection"]
    mech = available_virt_mechs()[0]
    value = "\"%s\"" % available_virt_uris()[mech]
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["Domain"]
    # 正規表現指定が可能
    #value = "\"/[^ ]+/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全てのドメインが対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    # 対象インターフェース指定(ドメイン名:デバイス名)
    keys = _keys + ["InterfaceDevice"]
    # 正規表現指定が可能
    #value = "\"/:eth[0-9\:]+/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全てのインターフェースが対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    # 対象ブロックデバイス指定(ドメイン名:デバイス名)
    keys = _keys + ["BlockDevice"]
    # 正規表現指定が可能
    #value = "\"/:(([hs]|xv)d[a-f][0-9]?|([a-z]+\/)?c[0-9]d[0-9](p[0-9])?)/\""
    #dop.cdp_set("collectdplugin",keys,value,multiple_file=True)
    # 指定しないときは、全てのインターフェースが対象になる
    dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    # 上記２つの対象デバイス指定で指定されたデバイスを対象外にする場合はtrue
    keys = _keys + ["IgnoreSelected"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    keys = _keys + ["RefreshInterval"]
    value = "60"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","libvirt"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","libvirt"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_libvirt_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_libvirt_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_libvirt_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_libvirt_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_sensors_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "sensors"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","sensors"],"sensors",multiple_file=True,is_opt_multi=True)

    _keys = [configName,"Plugin","sensors"]


    # 既存の設定を削除
    keys = _keys + ["Sensor"]
    if dop.cdp_isset("collectdplugin",keys,multiple_file=True) is True:
        for _k in dop.cdp_get("collectdplugin",keys,multiple_file=True).keys():
            keys = _keys + ["Sensor",_k]
            dop.cdp_delete("collectdplugin",keys,multiple_file=True)

    orders_key = _keys + ["Sensor","@ORDERS"]
    dop.cdp_unset("collectplugin",orders_key,multiple_file=True)
    orders = []

    #from karesansui.lib.utils import get_sensor_chip_name
    #chip_name = get_sensor_chip_name()
    chip_name = "it8712-isa-0290"

    # temperature
    for _temp in ["temp","temp1","temp2","temp3","temp4","temp5","temp6","temp7"]:
        sensor_id = "%s/temperature-%s" % (chip_name,_temp)
        value = "\"%s\"" % sensor_id
        keys = _keys + ["Sensor",value]
        dop.cdp_set("collectdplugin",keys,value,multiple_file=True,is_opt_multi=True)
        orders.append([value])

    # fanspeed
    for _fan in ["fan1","fan2","fan3","fan4","fan5","fan6","fan7"]:
        sensor_id = "%s/fanspeed-%s" % (chip_name,_fan)
        value = "\"%s\"" % sensor_id
        keys = _keys + ["Sensor",value]
        dop.cdp_set("collectdplugin",keys,value,multiple_file=True,is_opt_multi=True)
        orders.append([value])

    # voltage
    for _in in ["in0","in1","in2","in3","in4","in5","in6","in7","in8","in9","in10"]:
        sensor_id = "%s/voltage-%s" % (chip_name,_in)
        value = "\"%s\"" % sensor_id
        keys = _keys + ["Sensor",value]
        dop.cdp_set("collectdplugin",keys,value,multiple_file=True,is_opt_multi=True)
        orders.append([value])

    dop.cdp_set("collectplugin",orders_key,orders,multiple_file=True,is_opt_multi=True)

    # 上記で指定されたものを対象外にする場合はtrue
    keys = _keys + ["IgnoreSelected"]
    value = "false"
    dop.cdp_set("collectdplugin",keys,value,multiple_file=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","sensors"],recursive=True,multiple_file=True)
        dop.cdp_uncomment("collectdplugin",_keys,recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","sensors"],recursive=True,multiple_file=True)
        dop.cdp_comment("collectdplugin",_keys,recursive=True,multiple_file=True)

def enable_sensors_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_sensors_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_sensors_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_sensors_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_uptime_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "uptime"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","uptime"],"uptime",multiple_file=True,is_opt_multi=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","uptime"],recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","uptime"],recursive=True,multiple_file=True)

def enable_uptime_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_uptime_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_uptime_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_uptime_plugin(flag=False, dop=dop, webobj=webobj, host=host)


def switch_users_plugin(flag=True, dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "users"

    dop.cdp_set("collectdplugin",[configName,"LoadPlugin","users"],"users",multiple_file=True,is_opt_multi=True)

    if flag is True:
        dop.cdp_uncomment("collectdplugin",[configName,"LoadPlugin","users"],recursive=True,multiple_file=True)
    else:
        dop.cdp_comment("collectdplugin",[configName,"LoadPlugin","users"],recursive=True,multiple_file=True)

def enable_users_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_users_plugin(flag=True, dop=dop, webobj=webobj, host=host)

def disable_users_plugin(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    switch_users_plugin(flag=False, dop=dop, webobj=webobj, host=host)




def init_filter(dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    configName = "filter"

    load_plugins = ["match_regex","match_value","target_notification"]

    if dop.cdp_isset("collectdplugin",[configName,"@ORDERS"],multiple_file=True) is True:
        orders = dop.get("collectdplugin",[configName,"@ORDERS"])
    else:
        orders = []

    for plugin_name in load_plugins:
        if dop.cdp_isset("collectdplugin",[configName,"LoadPlugin",plugin_name],multiple_file=True) is False:
            dop.cdp_set("collectdplugin",[configName,"LoadPlugin",plugin_name],plugin_name,multiple_file=True,is_opt_multi=True)
            orders.append(["LoadPlugin",plugin_name])

    dop.set("collectdplugin",[configName,"@ORDERS"],orders)

def set_chain_rule(type,chain,rule,params,dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    init_filter(dop, webobj, host)

    configName = "filter"
    _keys = [configName,type,"\"%s\"" % chain]

    if dop.cdp_isset("collectdplugin", _keys, multiple_file=True) is False:
        dop.cdp_set("collectdplugin", _keys, chain, multiple_file=True, is_opt_multi=True)
        dop.cdp_set_pre_comment("collectdplugin", _keys, [''], multiple_file=True)

    _keys = [configName,"Chain",chain]

    try:
        plugin = "\"^%s$\"" % params["Plugin"]
        keys = _keys + ["Rule",rule,"Match","regex","Plugin"]
        dop.cdp_set("collectdplugin", keys, plugin, multiple_file=True)
    except:
        pass

    try:
        type_instance = "\"^%s$\"" % params["TypeInstance"]
        keys = _keys + ["Rule",rule,"Match","regex","TypeInstance"]
        dop.cdp_set("collectdplugin", keys, type_instance, multiple_file=True)
    except:
        pass

    try:
        min = params["Min"]
        keys = _keys + ["Rule",rule,"Match","value","Min"]
        dop.cdp_set("collectdplugin", keys, min, multiple_file=True)
    except:
        pass

    try:
        max = params["Max"]
        keys = _keys + ["Rule",rule,"Match","value","Max"]
        dop.cdp_set("collectdplugin", keys, max, multiple_file=True)
    except:
        pass

    try:
        invert = params["Invert"]
        keys = _keys + ["Rule",rule,"Match","value","Invert"]
        dop.cdp_set("collectdplugin", keys, invert, multiple_file=True)
    except:
        pass

    try:
        satisfy = "\"%s\"" % params["Satisfy"]
        keys = _keys + ["Rule",rule,"Match","value","Satisfy"]
        dop.cdp_set("collectdplugin", keys, satisfy, multiple_file=True)
    except:
        pass

    try:
        if params['Target'] == "notification":
            try:
                message = "\"%s\"" % params["Message"]
                keys = _keys + ["Rule",rule,"Target","notification","Message"]
                dop.cdp_set("collectdplugin", keys, message,multiple_file=True)
            except:
                pass

            try:
                severity = "\"%s\"" % params["Severity"]
                keys = _keys + ["Rule",rule,"Target","notification","Severity"]
                dop.cdp_set("collectdplugin", keys, severity,multiple_file=True)
            except:
                pass

        else:
            try:
                keys = _keys + ["Rule",rule,"Target",params['Target'],"Pass"]
                dop.cdp_set("collectdplugin", keys, "" ,multiple_file=True)
                dop.cdp_comment("collectdplugin", keys, multiple_file=True)
            except:
                pass
    except:
        pass

    #keys = _keys + ["Target"]
    #dop.cdp_set("collectdplugin", keys, "\"write\"", multiple_file=True)

def set_pre_cache_chain_rule(chain,rule,params,dop=None,webobj=None,host=None):
    global DictOp

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    set_chain_rule("PreCacheChain",chain,rule,params,dop,webobj,host)

def set_post_cache_chain_rule(chain,rule,params,dop=None,webobj=None,host=None):
    global DictOp

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    set_chain_rule("PostCacheChain",chain,rule,params,dop,webobj,host)


def create_threshold_config_name(plugin,selector):

    configName = "threshold"

    data = plugin_selector_to_dict(selector)
    config_name = "%s_%s" % (configName,plugin,)
    try:
        config_name += ":%s" % (data['plugin_instance'],)
    except:
        config_name += ":"
    try:
        config_name += ":%s" % (data['type'],)
    except:
        config_name += ":"
    try:
        config_name += ":%s" % (data['type_instance'],)
    except:
        config_name += ":"
    try:
        config_name += ":%s" % (data['ds'],)
    except:
        config_name += ":"
    try:
        config_name += ":%s" % (data['host'],)
    except:
        pass
        #config_name += ":"

    return config_name

def set_threshold(plugin,selector,params,dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    enable_python_plugin(dop=dop, webobj=webobj, host=host)

    config_name = create_threshold_config_name(plugin,selector)

    data = plugin_selector_to_dict(selector)
    try:
        plugin_instance = data['plugin_instance']
    except:
        plugin_instance = None
    try:
        type = data['type']
    except:
        type = None
    try:
        type_instance = data['type_instance']
    except:
        type_instance = None
    try:
        ds = data['ds']
    except:
        ds = None
    try:
        host = data['host']
        _keys = [config_name,"Threshold","","Host",host,"Plugin",plugin]
    except:
        host = None
        _keys = [config_name,"Threshold","","Plugin",plugin]

    if plugin_instance is not None:
        keys = _keys + ["Instance"]
        try:
            int(plugin_instance)
            _plugin_instance = "\"%d\"" % int(plugin_instance)
        except:
            _plugin_instance = plugin_instance
            pass
        dop.cdp_set("collectdplugin", keys, _plugin_instance, multiple_file=True)

    if type is not None:
        _keys = _keys + ["Type",type]

        if type_instance is not None:
            keys = _keys + ["Instance"]
            dop.cdp_set("collectdplugin", keys, "\"%s\"" % type_instance, multiple_file=True)

        if ds is not None:
            keys = _keys + ["DataSource"]
            dop.cdp_set("collectdplugin", keys, "\"%s\"" % ds, multiple_file=True)

        try:
            params['Message']
        except:
            msg_dict = {}
            for _param in ["plugin","plugin_instance","type","type_instance","ds","host"]:
                try:
                    exec("if %s is not None: msg_dict['%s'] = str(%s)" % (_param,_param,_param,))
                    exec("if %s is None: msg_dict['%s'] = '%%{%s}'" % (_param,_param,_param,))
                except:
                    pass

            for _param in ["WarningMax","WarningMin","FailureMax","FailureMin","Percentage","Persist","Hits","Hysteresis"]:
                try:
                    _name = re.sub("([a-z])([A-Z])","\\1_\\2",_param).lower()
                    exec("msg_dict['%s'] = params['%s']" % (_name,_param,))
                except:
                    pass

            params['Message'] = "\"%s\"" % str(msg_dict)


        for _param in ["WarningMax","WarningMin","FailureMax","FailureMin","Percentage","Persist","Hits","Hysteresis","Message"]:
            try:
                param_val = params[_param]
                keys = _keys + [_param]
                dop.cdp_set("collectdplugin", keys, param_val, multiple_file=True)
            except:
                pass

def disable_threshold(plugin,selector,dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    config_name = create_threshold_config_name(plugin,selector)
    keys = [config_name,"Threshold",""]

    dop.cdp_comment("collectdplugin", keys, multiple_file=True)

def enable_threshold(plugin,selector,dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    config_name = create_threshold_config_name(plugin,selector)
    keys = [config_name,"Threshold",""]

    dop.cdp_uncomment("collectdplugin", keys, recursive=True, multiple_file=True)

def delete_threshold(plugin,selector,dop=None, webobj=None, host=None):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    config_name = create_threshold_config_name(plugin,selector)
    keys = [config_name]

    dop.delete("collectdplugin", keys)


def initialize_collectd_settings(dop=None, webobj=None, host=None, force=False, reverse=False):
    global DictOp
    retval = False

    if dop is None:
        if isinstance(DictOp, types.InstanceType) and DictOp.__class__.__name__ == "DictOp":
            dop = DictOp
        else:
            dop = _get_collectd_config(webobj, host)

    # general settings
    if not "collectd" in dop.ModuleNames:
        from karesansui.lib.parser.collectd import collectdParser
        conf_arr =  collectdParser().read_conf()
        dop.addconf("collectd",conf_arr)

    default_params = {
              "Hostname"   :"\"localhost\"",
              "FQDNLookup" :"true",
              "BaseDir"    :"\"%s\"" % COLLECTD_DATA_DIR,
              "PIDFile"    :"\"%s\"" % COLLECTD_PID_FILE,
              "PluginDir"  :"\"%s\"" % COLLECTD_PLUGIN_DIR,
              "TypesDB"    :"\"%s/types.db\"" % COLLECTD_SHARE_DIR,
              "Include"    :"\"%s/*.conf\"" % PARSER_COLLECTD_PLUGIN_DIR,
              "Interval"   :"3",
              "ReadThreads":"5",
              }

    for _k,_v in default_params.iteritems():
        if dop.cdp_isset("collectd",[_k]) is False or force is True:
            # Include行は複数設定可(is_opt_multi)なのでis_opt_multi=Trueでset
            if _k == "Include":
                # 既存Include行を削除
                if dop.cdp_isset("collectd",[_k]) is True:
                    for _k2 in dop.cdp_get("collectd",[_k]).keys():
                        dop.cdp_delete("collectd",[_k,_k2])
                dop.cdp_set("collectd",[_k,_v] ,_v,is_opt_multi=True)
            else:
                dop.cdp_set("collectd",[_k]    ,_v)

    # each plugin settings
    from karesansui.lib.parser.collectdplugin import collectdpluginParser

    # まだ読み込まれていないプラグイン設定ファイルを読み込む
    includes = []
    for _plugin in COLLECTD_PLUGINS:
        if dop.isset("collectdplugin",_plugin) is False:
            includes.append(_plugin)
    if len(includes) != 0:
        extra_args = {"include":"^(%s)$" % "|".join(includes)}
        new_conf_arr =  collectdpluginParser().read_conf(extra_args)
        for _k,_v in new_conf_arr.iteritems():
            if _k[0:1] != "@":
                dop.set("collectdplugin",[_k],_v['value'])

    # コメントを外す
    for _plugin in COLLECTD_PLUGINS:
        if dop.isset("collectdplugin",[_plugin,"LoadPlugin"]) is True:
            loadplugins = dop.get("collectdplugin",[_plugin,"LoadPlugin"])
            for _k,_v in loadplugins.iteritems():
                if _v['comment'] is True:
                    if reverse is True:
                        disabled_plugin(_plugin, dop=dop, webobj=webobj, host=host)
                    else:
                        enabled_plugin(_plugin, dop=dop, webobj=webobj, host=host)

    # pythonプラグインの初期値設定
    if "python" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["python"]) is True:
        if reverse is True:
            disable_python_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_python_plugin(dop=dop, webobj=webobj, host=host)

    # syslogプラグインの初期値設定
    if "syslog" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["syslog"]) is True:
        if reverse is True:
            disable_syslog_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_syslog_plugin(dop=dop, webobj=webobj, host=host)

    # logfileプラグインの初期値設定
    if "logfile" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["logfile"]) is True:
        if reverse is True:
            disable_logfile_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_logfile_plugin(dop=dop, webobj=webobj, host=host)

    # rrdtoolプラグインの初期値設定
    if "rrdtool" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["rrdtool"]) is True:
        if reverse is True:
            disable_rrdtool_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_rrdtool_plugin(dop=dop, webobj=webobj, host=host)

    # rrdcachedプラグインの初期値設定
    if "rrdcached" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["rrdcached"]) is True:
        if reverse is True:
            disable_rrdcached_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_rrdcached_plugin(dop=dop, webobj=webobj, host=host)

    # memoryプラグインの初期値設定
    if "memory" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["memory"]) is True:
        if reverse is True:
            disable_memory_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_memory_plugin(dop=dop, webobj=webobj, host=host)

    # cpuプラグインの初期値設定
    if "cpu" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["cpu"]) is True:
        if reverse is True:
            disable_cpu_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_cpu_plugin(dop=dop, webobj=webobj, host=host)

    # diskプラグインの初期値設定
    if "disk" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["disk"]) is True:
        if reverse is True:
            disable_disk_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_disk_plugin(dop=dop, webobj=webobj, host=host)

    # dfプラグインの初期値設定
    if "df" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["df"]) is True:
        if reverse is True:
            disable_df_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_df_plugin(dop=dop, webobj=webobj, host=host)

    # interfaceプラグインの初期値設定
    if "interface" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["interface"]) is True:
        if reverse is True:
            disable_interface_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_interface_plugin(dop=dop, webobj=webobj, host=host)

    # libvirtプラグインの初期値設定
    if "libvirt" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["libvirt"]) is True:
        if reverse is True:
            disable_libvirt_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_libvirt_plugin(dop=dop, webobj=webobj, host=host)

    # sensorsプラグインの初期値設定
    if "sensors" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["sensors"]) is True:
        if reverse is True:
            disable_sensors_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_sensors_plugin(dop=dop, webobj=webobj, host=host)

    # uptimeプラグインの初期値設定
    if "uptime" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["uptime"]) is True:
        if reverse is True:
            disable_uptime_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_uptime_plugin(dop=dop, webobj=webobj, host=host)

    # usersプラグインの初期値設定
    if "users" in COLLECTD_PLUGINS and dop.isset("collectdplugin",["users"]) is True:
        if reverse is True:
            disable_users_plugin(dop=dop, webobj=webobj, host=host)
        else:
            enable_users_plugin(dop=dop, webobj=webobj, host=host)


"""
"""
if __name__ == '__main__':
    """Testing
    """

    # プラグインのリストを取得
    list = plugin_list()
    preprint_r(list)

    # 有効なプラグインの取得
    list = active_plugin_list(dop=DictOp)
    preprint_r(list)

    # 無効なプラグインの取得
    list = inactive_plugin_list(dop=DictOp)
    preprint_r(list)

    # プラグインが有効かどうか(syslog)
    plugin_name = "syslog"
    print is_enabled_plugin(plugin_name,dop=DictOp)

    # プラグインが有効かどうか(logfile)
    plugin_name = "logfile"
    print is_enabled_plugin(plugin_name,dop=DictOp)

    # プラグインを有効化(iptables)
    plugin_name = "iptables"
    enabled_plugin(plugin_name,dop=DictOp)
    # プラグインが有効かどうか(iptables)
    print is_enabled_plugin(plugin_name,dop=DictOp)

    # プラグインを無効化(logfile)
    plugin_name = "logfile"
    disabled_plugin(plugin_name,dop=DictOp)
    # プラグインが有効かどうか(logfile)
    print is_enabled_plugin(plugin_name,dop=DictOp)

    # Intervalパラメータの取得
    print get_global_parameter("Interval",dop=DictOp)

    # Intervalパラメータの変更
    print set_global_parameter("Interval","23",dop=DictOp)
    # Intervalパラメータの取得
    print get_global_parameter("Interval")

    # ここまでの設定内容を確認（メモリ上）
    #preprint_r(DictOp.getconf("collectdplugin"))

    # プラグイン設定がどのファイルに記述されているか(iptables)
    # xxxx.conf の xxxx の部分が返される
    plugin_name = "iptables"
    print where_is_plugin(plugin_name)

    #################################
    # Filterの設定
    #################################

    # ルールの作成 (ルール名:memory_cached_exceeded)
    # 数値も全て文字列にしてください
    rule_name = "memory_cached_exceeded"
    params = {}
    params['Plugin']   = "memory"
    params['TypeInstance'] = "cached"
    params['Min']      = "97000000"
    #params['Max']     = "1000000000"
    #params['Invert']  = "false"
    params['Satisfy']  = "Any"
    params['Target']   = "notification"
    params['Message']  = "Oops, the %{plugin} %{type_instance} memory_size is currently %{ds:value}!"
    params['Severity'] = "WARNING"
    set_post_cache_chain_rule("PostTestChain",rule_name,params)

    # ルールの作成 (ルール名:memory_used_exceeded)
    # 数値も全て文字列にしてください
    rule_name = "memory_used_exceeded"
    params = {}
    params['Plugin']   = "memory";
    params['TypeInstance'] = "used";
    params['Min']      = "550000000";
    #params['Max']     = "10000000000";
    #params['Invert']  = "false";
    params['Satisfy']  = "Any";
    params['Target']   = "notification";
    params['Message']  = "Oops, the %{plugin} %{type_instance} memory_size is currently %{ds:value}!";
    params['Severity'] = "WARNING";
    set_post_cache_chain_rule("PostTestChain",rule_name,params)

    # ルールの作成 (ルール名:cpu_exceeded)
    # 数値も全て文字列にしてください
    rule_name = "cpu_exceeded"
    params = {}
    params['Plugin']   = "cpu";
    #params['TypeInstance'] = "";
    params['Min']      = "0";
    params['Max']      = "80";
    params['Invert']  = "false";
    params['Satisfy']  = "All";
    params['Target']   = "notification";
    params['Message']  = "Oops, the %{plugin} %{type_instance} cpu is currently %{ds:value}!";
    params['Severity'] = "FAILURE";
    set_post_cache_chain_rule("PostTestChain",rule_name,params)

    ## dict_op の 個別テスト
    #DictOp.unset("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded"],is_cdp=True,multiple_file=True)
    #DictOp.delete("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded","Match"],is_cdp=True,multiple_file=True)
    #DictOp.comment("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded"],is_cdp=True,multiple_file=True)
    #DictOp.uncomment("collectdplugin",["filter","Chain","PostTestChain","Rule","cpub_exceeded"],is_cdp=True,multiple_file=True)
    #print DictOp.action("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded","Match"],is_cdp=True,multiple_file=True)
    print DictOp.unset("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded","Match"],is_cdp=True,multiple_file=True)
    print DictOp.isset("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded","Match"],is_cdp=True,multiple_file=True)
    print DictOp.cdp_isset("collectdplugin",["filter","Chain","PostTestChain","Rule","cpua_exceeded","Match"],multiple_file=True)


    #################################
    # Thresholdの設定
    #################################

    # スレッショルドの作成 (df)
    plugin_name     = "df"
    plugin_instance = None
    type            = "df"
    type_instance   = "boot"
    ds              = "used"

    # 数値も全て文字列にしてください
    selector = create_plugin_selector(plugin_instance, type, type_instance, ds)
    params = {}
    params['WarningMax'] = "10";
    params['FailureMax'] = "25";
    params['Percentage'] = "true";
    params['Persist']    = "true";
    params['Message']    =  "\"name:%{ds:name} val:%{ds:value} fmin:%{failure_min} fmax:%{failure_max} wmin:%{warning_min} wmax:%{warning_max}\""
    set_threshold(plugin_name,selector,params)


    # スレッショルドの作成 (load)
    plugin_name     = "load"
    plugin_instance = None
    type            = "load"
    type_instance   = None
    ds              = "shortterm"

    # 数値も全て文字列にしてください
    selector = create_plugin_selector(plugin_instance, type, type_instance, ds)
    params = {}
    params['WarningMax'] = "0.02";
    params['FailureMax'] = "1.5";
    params['Percentage'] = "false";
    params['Persist']    = "true";
    #params['Message']    =  "\"name:%{ds:name} val:%{ds:value} fmin:%{failure_min} fmax:%{failure_max} wmin:%{warning_min} wmax:%{warning_max}\""
    set_threshold(plugin_name,selector,params)

    # コメントで無効化
    disable_threshold(plugin_name,selector)

    # コメント外しで有効化
    enable_threshold(plugin_name,selector)

    # コメントで無効化
    disable_threshold(plugin_name,selector)

    # pythonプラグインの無効化
    disable_python_plugin()
    # pythonプラグインの有効化
    enable_python_plugin()


    """
    # df,disk,interface,libvirt,load......だけ読み込み
    from karesansui.lib.parser.collectdplugin import collectdpluginParser
    extra_args = {"include":"^(df|disk|interface|libvirt|load|logfile|memory|python|rrdcached|rrdtool|sensors|syslog)$"}
    DictOp.addconf("collectdplugin",collectdpluginParser().read_conf(extra_args=extra_args))
    # 各種プラグイン設定を初期化する(この時点でcpu設定は読み込まれていない)
    initialize_collectd_settings(dop=DictOp)
    """

    # ここまでの設定内容を確認（メモリ上）
    conf = DictOp.getconf("collectdplugin")
    preprint_r(conf)
    #preprint_r(conf["filter"])
    #preprint_r(conf["python"])

    # 設定書き込み（dryrun指定で標準出力のみ）
    from karesansui.lib.parser.collectdplugin import collectdpluginParser
    parser = collectdpluginParser()
    parser.write_conf(conf,dryrun=True)

    print get_collectd_param(param="BaseDir"     , section=None)
    print get_collectd_param(param="DataDir"     , section="rrdtool")
    print get_collectd_param(param="CacheTimeout", section="rrdtool")

    pass

########NEW FILE########
__FILENAME__ = countup
#/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import time
import types

from bsddb import hashopen, btopen
from karesansui.lib.const import COUNTUP_DATABASE_PATH, KARESANSUI_GROUP

"""
Berkeley DBにキーの値（カウント情報）を書き込む

キー：カテゴリー名(半角文字)
値  ：以下の要素を持つリスト配列のstrでキャストした文字列
       要素0: total        同一アラート抑制スパン(span)内の合計ヒット回数
                           (since + span)の期間に何回ヒットしたか
                           reset(attr="total")で初期化
                           up()でインクリメント
       要素1: hitcount     回数監視スパン(seconds)内のカテゴリーのヒット回数
                           (start + seconds)の期間に何回ヒットしたか
                           reset(attr="hitcount")で初期化
                           up()でインクリメント
       要素2: continuation 監視間隔(interval)での連続ヒット回数
                           reset(attr="continuation")で初期化
                           mtime + interval + 1 内にヒットすればカウント
                           以外なら、1でリセット
                           up(attr="continuation")でインクリメント
       要素3: since        初期データ投入時刻(Unixtime)
                           同一アラート抑制スパン制御のための開始時刻
                           reset(attr="total")で初期化
       要素4: start        hitcountのリセット時刻(Unixtime)
                           回数監視スパン制御のための開始時刻
                           reset(attr="hitcount")で初期化
       要素5: mtime        最終更新時刻(Unixtime)
                           最終ヒット時刻
       要素6: action       sinceからのアクション回数

Example:

>>> from karesansui.lib.collectd.countup import CountUp
>>> countup = CountUp()
>>> 
>>> countup.init("memory_used_exceeded")
>>> print countup.get("memory_used_exceeded")
[0, 0, 0, 1271224396.0812089, 1271224396.0812089, 1271224396.0812089, 0]
>>> countup.up("memory_used_exceeded")
>>> print countup.get("memory_used_exceeded")
[1, 1, 0, 1271224396.0812089, 1271224396.0812089, 1271224396.0870471, 1]
>>> countup.up("memory_used_exceeded")
>>> countup.reset("memory_used_exceeded",attr="hitcount")
>>> countup.reset("memory_used_exceeded")
>>> countup.finish()

"""

class CountUp:

    path = None

    def __init__(self, path=None):
        if path is None:
            self.path = COUNTUP_DATABASE_PATH
        else:
            self.path = path

        self.attrs = ["total","hitcount","continuation","since","start","mtime","action"]

        self._set_db_type("bt")     # B-Tree
        self._set_db_type("hash")   # Hash

        try:
            self.create()
        except:
            raise

    def _set_db_type(self,type="hash"):
        self.db_type = type

    def _open(self, flag="c", mode=0000):
        func = "%sopen" % self.db_type
        try:
            exec("ret = %s(self.path, flag, mode)" % func)
            return ret
        except:
            raise

    def _close(self):
        try:
            self.db.close()
        except:
            pass

    def create(self):
        if not os.path.exists(self.path):
            self.db = self._open("c")
            from karesansui.lib.utils import r_chmod, r_chgrp
            r_chgrp(self.path,KARESANSUI_GROUP)
            r_chmod(self.path,"g+rw")
        else:
            self.db = self._open("c")
        pass

    def destroy(self):
        self._close()
        if os.path.exists(self.path):
            os.unlink(self.path)

    def finish(self):
        self._close()

    def init(self,key):
        retval = False

        now = time.time()
        value = [0,0,0,now,now,now,0]

        try:
            self.db[key] = str(value)
            retval = True
        except:
            pass

        return retval

    def get(self,key,attr=None):
        retval = []

        if self.db.has_key(key) == 1:
            exec("retval = %s" % self.db[key])

            if attr is not None:
                if attr in self.attrs:
                    retval = retval[self.attrs.index(attr)]

        return retval

    def get_total(self,key):
        return self.get(key,attr="total")

    def get_hitcount(self,key):
        return self.get(key,attr="hitcount")

    def get_continuation(self,key):
        return self.get(key,attr="continuation")

    def get_since(self,key):
        return self.get(key,attr="since")

    def get_start(self,key):
        return self.get(key,attr="start")

    def get_mtime(self,key):
        return self.get(key,attr="mtime")

    def get_action(self,key):
        return self.get(key,attr="action")

    def set(self,key,value,attr=None):
        retval = False

        if self.db.has_key(key) == 1:

            exec("data = %s" % self.get(key))

            modified = False
            if attr is None:
                if type(value) is types.ListType:
                    data = value
                    modified = True
            else:
                if attr in self.attrs:
                    data[self.attrs.index(attr)] = value
                    modified = True

            if modified is True:
                try:
                    self.db[key] = str(data)
                    retval = True
                except:
                    pass

        else:
            if type(value) is types.ListType:
                try:
                    self.db[key] = str(value)
                    retval = True
                except:
                    pass

        return retval

    def up(self,key,attr=None):
        retval = False

        now = time.time()
        if self.db.has_key(key) == 1:
            data = self.get(key)
            try:
                total = int(data[self.attrs.index("total")])
            except:
                total = 0
            try:
                hitcount = int(data[self.attrs.index("hitcount")])
            except:
                hitcount = 0
            try:
                continuation = int(data[self.attrs.index("continuation")])
            except:
                continuation = 0
            try:
                action = int(data[self.attrs.index("action")])
            except:
                action = 0

            if attr is None:
                total += 1
                hitcount += 1
            elif attr == "total":
                total += 1
            elif attr == "hitcount":
                hitcount += 1
            elif attr == "continuation":
                continuation += 1
            elif attr == "action":
                action += 1

            data[0] = total
            data[1] = hitcount
            data[2] = continuation
            data[5] = now
            data[6] = action

        else:
            data = [1,1,1,now,now,now,0]

        try:
            self.set(key,data)
            retval = True
        except:
            pass

        return retval

    def reset(self,key,attr=None,value=0):
        retval = False

        now = time.time()
        if self.db.has_key(key) == 1:
            data = self.get(key)

            if attr is None:
                data[0] = value
                data[1] = value
                data[3] = now
                data[4] = now
            elif attr == "total":
                data[0] = value
                data[3] = now
            elif attr == "hitcount":
                data[1] = value
                data[4] = now
            elif attr == "continuation":
                data[3] = value
            elif attr == "action":
                data[6] = 0

        else:
            data = [value,value,value,now,now,now,0]

        try:
            self.set(key,data)
            retval = True
        except:
            pass

        return retval


if __name__ == '__main__':

  countup = CountUp()

  countup.init("memory_used_exceeded")
  print countup.get("memory_used_exceeded")

  countup.up("memory_used_exceeded")
  print countup.get("memory_used_exceeded")

  countup.up("memory_used_exceeded")
  print countup.get_hitcount("memory_used_exceeded")
  print countup.get_mtime("memory_used_exceeded")

  countup.reset("memory_used_exceeded",attr="hitcount")
  print countup.get("memory_used_exceeded")

  countup.up("memory_used_exceeded",attr="continuation")
  print countup.get("memory_used_exceeded")

  countup.up("memory_used_exceeded")
  print countup.get("memory_used_exceeded")

  countup.reset("memory_used_exceeded")
  print countup.get("memory_used_exceeded")

  countup.finish()


########NEW FILE########
__FILENAME__ = notification
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
collectdからデータを受け取り、アクションを起こすかどうか判断する

アクションあり：メール送信用、シェル実行用のモジュールへデータを投げる
アクションなし：そのまま終了(リターンいらない)

Example: collectd.d/python.conf
----- snip ----- snip ----- snip -----
# "LoadPlugin python" だけだと、システムのpythonライブラリが使用できない
# 下記のように"<LoadPlugin python>" でGlobalsパラメータの設定が必要
<LoadPlugin python>
        Globals true
</LoadPlugin>

<Plugin python>
        ModulePath "/usr/lib/python2.6/site-packages/karesansui/lib/collectd"
        Encoding utf-8
        LogTraces true
        #Interactive true
        Import "notification"

        <Module "notification">
                CountupDBPath "/var/lib/karesansui/notify_count.db"
                LogFile "/var/log/collectd/notification.log"
                # 0 none, 1 errors, 2 informations, 4 debug, 7 all
                LogLevel 1
                Environ "KARESANSUI_CONF=/etc/karesansui/application.conf" "
FOOBAR=foo:bar" "LANG=ja_JP.utf-8"
        </Module>
</Plugin>
----- snip ----- snip ----- snip -----

Example: collectd.d/filter.conf
----- snip ----- snip ----- snip -----
# Messageオプションの値をdictの文字列にすることで、pythonスクリプト側で
# exec()の展開をすると各種データが取得できるようになる。
LoadPlugin match_regex
LoadPlugin match_value
LoadPlugin target_notification

PostCacheChain     PostTestChain
<Chain "PostTestChain">
    Target "write"
    <Rule "memory_cached_exceeded">
        <Target "notification">
            #Message            "Oops, the %{plugin} %{type_instance} memory_size is currently %{ds:value}!"
            Message            "{'host':'%{host}','plugin':'%{plugin}','plugin_instance':'%{plugin_instance}','type':'%{type}','type_instance':'%{type_instance}','ds_value':'%{ds:value}','msg':'shikiichi wo koemashita!!'}"
            Severity           "WARNING"
        </Target>
        <Match "regex">
            TypeInstance       "^cached$"
            Plugin             "^memory$"
        </Match>
        <Match "value">
            Satisfy            "Any"
            Min                47000000
        </Match>
    </Rule>
</Chain>
----- snip ----- snip ----- snip -----

Example: collectd.d/threshold.conf
----- snip ----- snip ----- snip -----
# 閾値を越えるとnotificationプラグインには、以下のメッセージが送られる。
# Host %{host}, plugin %{plugin} type %{type} (instance {%type_instance}):
# Data source "{%ds.name}" is currently {%ds.value}.
# 1. That is (below|above) the (failure|warning) threshold of ({%threshold_min}|{%thresold_max})%?.
# 2. That is within the (failure|warning) region of {%threshold_min}%? and {%threshold_max}%?.
<Threshold>
    <Plugin "df">
        <Type "df">
            DataSource "used"
            WarningMax 10
            FailureMax 20
            Percentage true
            Persist true
        </Type>
    </Plugin>
    <Plugin "load">
        <Type "load">
            DataSource "shortterm"
            WarningMax    0.01
            FailureMax    0.40
            Persist true
        </Type>
    </Plugin>
</Threshold>
----- snip ----- snip ----- snip -----
"""

import collectd
import os, sys, types, time, os.path, re, fcntl

search_paths = ["/usr/lib/python2.6","/usr/lib/python2.6/site-packages"]
for _path in search_paths:
    if os.path.exists(_path):
        sys.path.insert(0, os.path.join(_path))

from karesansui import __version__, __release__, __app__
from karesansui.lib.const            import COUNTUP_DATABASE_PATH, \
                                            KARESANSUI_SYSCONF_DIR
from karesansui.lib.collectd.countup import CountUp
from karesansui.lib.utils            import ucfirst

NOTIF_FAILURE = 1<<0
NOTIF_WARNING = 1<<1
NOTIF_OKAY    = 1<<2

CHECK_CONTINUATION = 1<<0
CHECK_HITCOUNT     = 1<<1
CHECK_SPAN         = 1<<2
CHECK_ALL          = CHECK_CONTINUATION | CHECK_HITCOUNT | CHECK_SPAN

ACTION_LOG    = 1<<0
ACTION_MAIL   = 1<<1
ACTION_SCRIPT = 1<<2
ACTION_ALL    = ACTION_LOG | ACTION_MAIL | ACTION_SCRIPT

AppName = "%s %s-%s" % (ucfirst(__app__),__version__,__release__,)
optional_data = {
                'AppName' : AppName,
                }

"""
notifyオブジェクト(printの結果)
インスタンス名はプラグインによっては無い場合がある

type=%s
type_instance=%s
plugin=%s
plugin_instance=%s
host=%s
message=%s
severity=%i
time=%lu
"""

countup_db_path = COUNTUP_DATABASE_PATH
logfile         = "/dev/null"
loglevel        = 1
interval        = 10
environ         = {"KARESANSUI_CONF":"/etc/karesansui/application.conf"}
uniq_id         = None

mail_server     = "localhost"
mail_port       = 25

def config(cfg):
    global countup_db_path
    global logfile
    global loglevel
    global interval
    global environ

    for child in cfg.children:
        if child.key == "CountupDBPath":
            collectd.debug( "[config] config arg set key %s: %s" % ( child.key, child.values[0] ) )
            countup_db_path = child.values[0]

        if child.key == "LogFile":
            collectd.debug( "[config] config arg set key %s: %s" % ( child.key, child.values[0] ) )
            logfile = child.values[0]

        if child.key == "LogLevel":
            collectd.debug( "[config] config arg set key %s: %s" % ( child.key, child.values[0] ) )
            loglevel = int(child.values[0])

        if child.key == "Environ":
            for _value in child.values:
                collectd.debug( "[config] config arg set key %s: %s" % ( child.key, _value ) )
                pieces = _value.split("=",1)
                environ[pieces[0]] = pieces[1]

def init():
    global countup_db_path
    global logfile
    global interval
    global environ

    """
    if not os.path.exists(countup_db_path):
        collectd.error( "Can't find CountupDBPath at %s, disabling plugin" % (countup_db_path))
    """

    try:
        from karesansui.lib.conf import read_conf
        modules = ["collectd"]
        dop = read_conf(modules)
        interval = int(dop.cdp_get("collectd",["Interval"]))
    except:
        pass

def append_log(string,level=1):
    global logfile
    global loglevel
    global uniq_id

    try:
        string = "[%f] %s" % (uniq_id,str(string),)
    except:
        string = "[%f] %s" % (uniq_id,string,)

    from karesansui.lib.collectd.utils import append_line
    if loglevel & level:
        append_line(logfile,string)

def notification(notify=None, data=None):
    global countup_db_path
    global logfile
    global loglevel
    global interval
    global environ
    global uniq_id

    ########################################################
    # 拡張環境変数をセット
    ########################################################
    for _k,_v in environ.iteritems():
        os.environ[_k] = _v

    # 関数読み込み
    from karesansui.lib.collectd.utils import query_watch_data

    ########################################################
    # データを展開
    ########################################################
    if data is types.DictType:
        for _k,_v in data.iteritems():
            if _v is types.StringType:
                exec("%s = '%s'" % (_k,_v,))
            else:
                exec("%s = %s" % (_k,_v,))
    try:
        loglevel
    except:
        pass

    ########################################################
    # システムのログ
    ########################################################
    # logging
    uniq_id = time.time()

    append_log("###################################################",7)
    append_log("countup_db_path: %s" % (countup_db_path,) ,4)
    append_log("logfile        : %s" % (logfile,)         ,4)
    append_log("interval       : %d" % (interval,)        ,4)
    append_log("environ        : %s" % (environ,)         ,4)
    append_log("data           : %s" % (data,)            ,4)
    append_log("",4)


    ########################################################
    # notifyデータから各種値を取得
    ########################################################
    plugin           = notify.plugin
    plugin_instance  = notify.plugin_instance
    type             = notify.type
    type_instance    = notify.type_instance
    host             = notify.host
    severity         = notify.severity
    message          = notify.message
    now              = notify.time
    now_str = time.strftime("%c",time.localtime(now))

    # logging
    append_log("plugin         : %s" % (plugin,)           ,7)
    append_log("plugin_instance: %s" % (plugin_instance,)  ,7)
    append_log("type           : %s" % (type,)             ,7)
    append_log("type_instance  : %s" % (type_instance,)    ,7)
    append_log("host           : %s" % (host,)             ,7)
    append_log("severity       : %s" % (severity,)         ,7)
    append_log("message        : %s" % (message,)          ,7)
    append_log("now            : %s" % (now_str,)          ,4)
    append_log("",4)
    append_log("notify         : %s" % (str(dir(notify)),) ,4)
    """ comment
    append_log("collectd       : %s" % (str(dir(collectd)),)              ,4)
    append_log("collectd.Config: %s" % (str(dir(collectd.Config)),)       ,4)
    append_log("collectd.Notifi: %s" % (str(dir(collectd.Notification)),) ,4)
    append_log("collectd.Values: %s" % (str(dir(collectd.Values)),)       ,4)
    append_log("",4)
    """

    ########################################################
    # messageを展開、ds.xxxxをdata_valueとして取り出す
    ########################################################
    percentage = False

    # messageを展開、ds.xxxxをds_xxxとして取り出す
    # Filterの時はdict文字列をexec展開して抽出
    if message[0:2] == "{'":
        try:
            exec("ds_value = %s['ds_value']" % message)
            exec("msg      = %s['msg']"      % message)
            exec("extras   = %s['dict']"     % message)
        except:
            pass

        # dictの設定があれば extra_<key> = <value> で変数展開
        try:
            extras
            for _k,_v in extras.iteritems():
                exec("extra_%s = %s" % (_k,_v,))
        except:
            pass

    # messageを展開、ログからds_valueに取り出す
    # Thresholdの時はログの文字列から正規表現でデータを抽出
    else:
        msg = message
        regex  = "^Host (?P<host>.+), plugin (?P<plugin>.+)( \(instance (?P<plugin_instance>.+)\))? type (?P<type>.+)( \(instance (?P<type_instance>.+)\))?: "
        regex += "Data source \"(?P<ds_name>.+)\" is currently (?P<ds_value>.+)\. "
        regex += "That is (below|above) the (failure|warning) threshold of (?P<ts_value>[\-0-9\.]+)(?P<percent_flag>%?)\."

        m = re.match(regex,message)
        if m:
            ds_name  = m.group('ds_name')
            ds_value = m.group('ds_value')
            ts_value = m.group('ts_value')
            if m.group('percent_flag') == "%":
                percentage = True

        # メッセージの(msg 以下のdict文字列をparamsに展開する
        regex = ". \(msg (?P<msg_dict>{.+})"
        m = re.search(regex,message)
        if m:
            exec("params = %s" % m.group('msg_dict'))
            try:
                ds_name = params["ds"]
            except:
                pass

    # ds_valueが浮動小数点形式の文字列なら数値に変換
    try:
        from karesansui.lib.utils import float_from_string
        _ret = float_from_string(ds_value)
        if _ret is not False:
            ds_value = float(_ret)
        else:
            ds_value = float(ds_value)
    except:
        ds_value = None

    try:
        msg
    except:
        msg  = "Host %s, plugin %s type %s (instance %s)\): " % (host,plugin,type,type_instance,)
        msg += "Data source is currently %s\." % (ds_value)

    # logging
    append_log("msg            : %s" % (msg,)        ,4)
    try:
        append_log("ds_name        : %s" % (ds_name,),4)
        append_log("ds_value       : %f" % (ds_value,)   ,4)
        append_log("ts_value       : %f" % (ts_value,)   ,4)
    except:
        pass
    append_log("percentage     : %s" % (percentage,) ,4)
    append_log("",4)

    ########################################################
    # watchデータベースからマッチしたデータを取得
    ########################################################
    ########################################################
    # watchデータベースからマッチしたアクション条件を取得
    ########################################################

    """
    # !! テストデータ !!
    # 1分間に5回以上、または、連続５回ヒットしたらアクションを起こす例
    # かつ、1.5分間は同じアクションは起こさない
    checks = CHECK_ALL
    check_hitcount     = 5
    check_seconds      = 1   * 60
    check_continuation = 5
    check_span         = 1.5 * 60
    """

    checks = CHECK_CONTINUATION | CHECK_SPAN
    #check_hitcount     = 5
    #check_seconds      = 1   * 60
    check_continuation = 60
    check_span         = 60 * 60 * 6

    watch_data = query_watch_data(plugin,plugin_instance,type,type_instance,ds_name,host=host)
    append_log("watch_data     : %s" % (str(watch_data),) ,4)

    watch_column = [ 'name',
                     'check_continuation',
                     'check_span',
                     'warning_value',
                     'warning_script',
                     'warning_mail_body',
                     'is_warning_percentage',
                     'is_warning_script',
                     'is_warning_mail',
                     'failure_value',
                     'failure_script',
                     'failure_mail_body',
                     'is_failure_percentage',
                     'is_failure_script',
                     'is_failure_mail',
                     'okay_script',
                     'okay_mail_body',
                     'is_okay_script',
                     'is_okay_mail',
                     'notify_mail_from',
                     'notify_mail_to']
    try:
        for column_name in watch_column:
            exec("%s = watch_data[0]['%s']" % (column_name,column_name,))
            exec("_var = %s" % (column_name,))
            append_log("%s: %s"  % (column_name,_var)   ,4)
    except:
        append_log("Error: cannot get watch data." ,1)
        return
        #sys.exit(0)

    if severity == NOTIF_OKAY:
        watch_script    = okay_script
        watch_mail_body = okay_mail_body
        watch_is_script = is_okay_script
        watch_is_mail   = is_okay_mail
        severity_str    = "okay"
    elif severity == NOTIF_WARNING:
        watch_script    = warning_script
        watch_mail_body = warning_mail_body
        watch_is_script = is_warning_script
        watch_is_mail   = is_warning_mail
        severity_str    = "warning"
    elif severity == NOTIF_FAILURE:
        watch_script    = failure_script
        watch_mail_body = failure_mail_body
        watch_is_script = is_failure_script
        watch_is_mail   = is_failure_mail
        severity_str    = "failure"

    # logging
    append_log("watch_script    :%s" % (watch_script,)    ,4)
    append_log("watch_mail_body :%s" % (watch_mail_body,) ,4)
    append_log("watch_is_script :%s" % (watch_is_script,) ,4)
    append_log("watch_is_mail   :%s" % (watch_is_mail,)   ,4)
    append_log("",4)


    ########################################################
    # 前回のヒット時刻を取得(連続しているか判断するため)
    ########################################################
    gategory_key = "%s:%s:%s:%s@%s" % (plugin,plugin_instance,type,type_instance,host)
    countup = CountUp(countup_db_path)
    old_mtime = countup.get(gategory_key,attr="mtime")
    try:
        old_mtime_str = time.strftime("%c",time.localtime(float(old_mtime)))

        # logging
        append_log("old_mtime      : %s" % (old_mtime_str)  ,4)
        append_log("",4)
    except:
        old_mtime = 0
        pass

    ########################################################
    # カウントDBに記録
    ########################################################
    if severity != NOTIF_OKAY:
        countup.up(gategory_key)

        # 何回連続しているか調べる
        # 連続していれば、continuationをインクリメント 
        # いなければ、continuationをリセット
        try:
            old_mtime = int(old_mtime)
            # (インターバル+2)未満のヒットであればインクリメント
            if now < (old_mtime + interval + 2):
                countup.up(gategory_key,attr="continuation")
            else:
                countup.reset(gategory_key,attr="continuation")
        except:
            pass

        (total,hitcount,continuation,since,start,mtime,action) = countup.get(gategory_key)
        since_str = time.strftime("%c",time.localtime(since))
        start_str = time.strftime("%c",time.localtime(start))

        append_log("total          : %d" % (total,)        ,4)
        append_log("hitcount       : %d" % (hitcount,)     ,4)
        append_log("continuation   : %d" % (continuation,) ,4)
        append_log("",4)
        append_log("since          : %s" % (since_str,)    ,4)
        append_log(" sec from since: %d" % (now - since)   ,4)
        append_log("start          : %s" % (start_str,)    ,4)
        append_log(" sec from start: %d" % (now - start)   ,4)
        try:
            append_log("start + seconds: %d" % (start + check_seconds) ,4)
            append_log(" sec to now    : %d" % ((start + check_seconds) - now) ,4)
        except:
            pass
        append_log("since + span   : %d" % (since + check_span)         ,4)
        append_log(" sec to now    : %d" % ((since + check_span) - now) ,4)
        append_log("",4)
        append_log("action         : %d" % (action,) ,4)
        append_log("",4)

        ########################################################
        # アクションを起こすかどうかのチェック
        ########################################################
        do_action = False

        # 連続している回数が許容範囲内であるかチェック
        if checks & CHECK_CONTINUATION:
            if continuation >= check_continuation:
                do_action = True

        # 一定期間(seconds)内のヒット回数制限を超過していないかチェック
        if checks & CHECK_HITCOUNT:
            # 現在から遡って調べる秒数(seconds)の間に既にヒットしている場合
            if now <= (start + check_seconds):
                # ヒット回数と同じ場合 アクションを起こす
                if hitcount == check_hitcount:
                    do_action = True
                    countup.reset(gategory_key,attr="hitcount",value=0)

        # 再アクション禁止期間(span)内に既にアクションを起こしているかチェック
        # 再アクション禁止期間(span)内の場合
        if now <= (since + check_span):
            if do_action is True:
                # 既にアクションを起こしている場合はアクションを起こさない
                if action > 0:
                    do_action = False
        # 過ぎている場合は、totalをリセット
        else:
            countup.reset(gategory_key,attr="action",value=0)
            countup.reset(gategory_key,attr="total",value=0)

    # 正常値に戻ったとき(NOTIF_OKAY)は常にアクションを起こす
    else:
        (total,hitcount,continuation,since,start,mtime,action) = countup.get(gategory_key)
        # 既にアクションを起こしている場合だけアクションを起こす
        if action > 0:
            do_action = True

        # 正常値に戻ったときはhitcountとcontinuationもリセット
        countup.reset(gategory_key,attr="hitcount",value=0)
        countup.reset(gategory_key,attr="continuation")

    # アクションを起こす場合は、totalをリセット
    if do_action is True:
        countup.up(gategory_key,attr="action")
        countup.reset(gategory_key,attr="total")


    # カウントDB書き込み終わり
    countup.finish()

    append_log("do_action      : %s" % (do_action,)   ,4)
    append_log("",4)


    # アクションを起こさない場合は、ここで抜ける
    if do_action is not True:
        append_log("Notice: Action will be not executed. Aborted.",1)
        return
        #sys.exit(0)

    ########################################################
    # アクション呼出開始
    ########################################################

    actions = ACTION_LOG
    try:
        if watch_is_script is True and watch_script != "":
            actions |= ACTION_SCRIPT
    except:
        pass
    try:
        if watch_is_mail is True and watch_mail_body != "":
            actions |= ACTION_MAIL
    except:
        pass

    # 仮りに全てのアクションを例とする
    #actions = ACTION_ALL

    # メッセージを作成
    if severity == NOTIF_OKAY:
        alert_msg = "The value of %s is within normal range again." % (name,)
    elif severity == NOTIF_WARNING:
        alert_msg = "The value of %s (%f) is within the warning region." % (name,ds_value,)
    elif severity == NOTIF_FAILURE:
        alert_msg = "The value of %s (%f) is within the failure region." % (name,ds_value,)

    try:
        ts_value
        if percentage is True:
            alert_msg += " (threshold:%f%%)" % (float(ts_value),)
        else:
            alert_msg += " (threshold:%f)"   % (float(ts_value),)
    except:
        pass

    # ログ書き込み
    if actions & ACTION_LOG:
        from karesansui.lib.collectd.action.log import write_log

        if severity == NOTIF_OKAY:
            priority = "OKAY"
        elif severity == NOTIF_WARNING:
            priority = "WARNING"
        elif severity == NOTIF_FAILURE:
            priority = "FAILURE"

        write_log(alert_msg,priority=priority)
        write_log(msg      ,priority="INFO")
        pass

    # スクリプト実行
    if actions & ACTION_SCRIPT:
        from karesansui.lib.collectd.action.script import exec_script

        script = watch_script
        user   = "root"

        script_retval = False
        try:
            script_retval = exec_script(script=script,user=user,msg=alert_msg,watch_name=name,logfile=logfile)
        except:
            pass

    # メール送信
    if actions & ACTION_MAIL:
        from karesansui.lib.collectd.action.mail import send_mail
        from karesansui.lib.collectd.utils import get_karesansui_config

        try:
            karesansui_config = get_karesansui_config()
            smtp_server = karesansui_config['application.mail.server']
            smtp_port   = int(karesansui_config['application.mail.port'])
        except:
            smtp_server = mail_server
            smtp_port   = mail_port

        recipient   = notify_mail_to
        sender      = notify_mail_from

        try:
            lang = os.environ['LANG'].split('.',1)[0]
            lang = lang.split('_',1)[0]
        except:
            lang = "en"

        if watch_mail_body == "":
            NOTIF_MAIL_TMPL_DIR = KARESANSUI_SYSCONF_DIR + "/template"
            mail_template_file = "%s/%s/collectd_%s_%s.eml" % (NOTIF_MAIL_TMPL_DIR,lang,severity_str,plugin,)
            append_log("mail_template_file: %s" % mail_template_file,1)
            if os.path.exists(mail_template_file):
                watch_mail_body = open(mail_template_file).read()
        append_log("watch_mail_body: %s" % watch_mail_body,1)

        try:
            watch_mail_body = watch_mail_body.encode("UTF-8")
        except:
            pass

        script_result_message = ""
        CRLF = "\r\n"
        if actions & ACTION_SCRIPT:
            script_result_message += CRLF
            script_result_message += CRLF
            if script_retval is False:
                script_result_message += "Error: failed to execute the following script."
                script_result_message += CRLF
                script_result_message += script
                script_result_message += CRLF
            else:
                script_result_message += "Notice: The action script was executed."
                script_result_message += CRLF
                script_result_message += "script return value:%s" % script_retval[0]
                script_result_message += CRLF
                if len(script_retval[1]) > 0:
                    script_result_message += "[Script Output]"
                    script_result_message += CRLF
                    script_result_message += "%s" % CRLF.join(script_retval[1])
                    script_result_message += CRLF

        macros = {}
        macros['app_name']        = AppName
        macros['plugin']          = plugin
        macros['plugin_instance'] = plugin_instance
        macros['type']            = type
        macros['type_instance']   = type_instance
        macros['host']            = host
        macros['severity']        = severity_str
        macros['message']         = message
        macros['time']            = now_str
        macros['script_result_message'] = script_result_message
        try:
            macros['ds']              = ds_name
            macros['current_value']   = ds_value
            macros['threshold_value'] = ts_value
        except:
            pass
        try:
            params
            for _k,_v in params.iteritems():
                exec("macros['%s'] = '%s'" % (_k,str(_v),))
        except:
            pass

        from karesansui.lib.collectd.utils import evaluate_macro
        watch_mail_body = evaluate_macro(watch_mail_body,macros)

        send_mail(recipient=recipient,sender=sender,server=smtp_server,port=smtp_port,message=watch_mail_body,extra_message=script_result_message,watch_name=name,logfile=logfile)
        pass

    """ comment
    collectd.Values(type='cpu',type_instance='steal',
                    plugin='cpu',plugin_instance='0',
                    host='host.example.com',
                    message='Oops, the cpu steal cpu is currently 0!',
                    time=%lu,interval=%i)
    """

collectd.register_config(config)
collectd.register_init(init)
collectd.register_notification(notification,data=optional_data)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os, sys, fcntl

import karesansui
from karesansui import KaresansuiLibException

"""
Prepare for using orm (start)
"""
environ = {"KARESANSUI_CONF":"/etc/karesansui/application.conf"}
for _k,_v in environ.iteritems():
    os.environ[_k] = _v

from karesansui.lib.file.k2v import K2V
config_file = os.environ["KARESANSUI_CONF"]
if config_file: # read file
    _k2v = K2V(config_file)
    config = _k2v.read()

if config and config.has_key('application.search.path'):
    for y in [x.strip() for x in config['application.search.path'].split(',') if x]:
        if (y in sys.path) is False: sys.path.insert(0, y)

karesansui.config = config
if not karesansui.config:
    print >>sys.stderr, '[Error] Failed to load configuration file.'
    sys.exit(1)

"""
Prepare for using orm (end)
"""

def get_karesansui_config():
    return karesansui.config

def append_line(filename="/dev/null",string=""):
    try:
        fp = open(filename,"a")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_EX)
        try:
            fp.write("%s\n" % string.encode("utf_8"))
        except:
            fp.write("%s\n" % string)
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
    except:
        raise

def get_collectd_version():
    retval = False

    from karesansui.lib.const import VENDOR_SBIN_DIR
    from karesansui.lib.utils import execute_command

    collectd_command = "%s/collectd" % VENDOR_SBIN_DIR
    command_args = [collectd_command,"-h"]
    (rc,res) = execute_command(command_args)

    for _line in res:
        if _line[0:9] == "collectd ":
            retval = _line.split()[1]
            if retval[-1:] == ",":
                retval = retval[0:-1]
            break

    return retval


def create_plugin_selector(plugin_instance=None, type=None, type_instance=None, ds=None, host=None):
    selector = ""

    if plugin_instance is not None and plugin_instance != "":
        selector = '%splugin_instance:%s,' % (selector, plugin_instance)

    if type is not None and type != "":
        selector = '%stype:%s,' % (selector, type)

    if type_instance is not None and type_instance != "":
        selector = '%stype_instance:%s,' % (selector, type_instance)

    if ds is not None and ds != "":
        selector = '%sds:%s,' % (selector, ds)

    if host is not None and host != "":
        selector = '%shost:%s,' % (selector, host)

    selector = selector.rstrip(',')

    return str(selector)

def plugin_selector_to_dict(selector):
    from karesansui.lib.utils import comma_split
    selector_arr = comma_split(selector)
    selector_dict = dict()

    for select in selector_arr:
        (key, val) = select.split(':',2)
        selector_dict[key] = val

    return selector_dict

def create_threshold_value(min_value=None, max_value=None):
    value = ""

    if min_value is not None and min_value != "":
        value = '%smin:%s,' % (value, min_value)

    if max_value is not None and max_value != "":
        value = '%smax:%s,' % (value, max_value)

    value = value.rstrip(',')
    return value

def threshold_value_to_dict(value):
    from karesansui.lib.utils import comma_split
    value_arr = comma_split(value)
    value_dict = dict()

    for value in value_arr:
        (key, val) = value.split(':',2)
        value_dict[key] = val

    return value_dict

def query_watch_data(plugin,plugin_instance,type,type_instance,ds,host=None):
    import karesansui.db
    kss_engine   = karesansui.db.get_engine()
    kss_metadata = karesansui.db.get_metadata()
    kss_session  = karesansui.db.get_session()

    myhostname = os.uname()[1]
    if host == myhostname:
        host = None

    from karesansui.db.access.watch import    \
        findbyall       as w_findbyall,       \
        findby1         as w_findby1,         \
        findby1name     as w_findby1name,     \
        findbyallplugin as w_findbyallplugin, \
        findbyand       as w_findbyand

    retval = []

    plugin_selector = create_plugin_selector(plugin_instance,type,type_instance,ds,host)
    try:
        watchs = w_findbyallplugin(kss_session,plugin)
        for watch in watchs:
            if str(plugin_selector) == str(watch.plugin_selector):
                name  = watch.name

                check_continuation = watch.continuation_count
                check_span         = watch.prohibition_period

                warning_value     = threshold_value_to_dict(watch.warning_value)
                warning_script    = watch.warning_script
                warning_mail_body = watch.warning_mail_body
                is_warning_percentage = watch.is_warning_percentage
                is_warning_script     = watch.is_warning_script
                is_warning_mail       = watch.is_warning_mail

                failure_value     = threshold_value_to_dict(watch.failure_value)
                failure_script    = watch.failure_script
                failure_mail_body = watch.failure_mail_body
                is_failure_percentage = watch.is_failure_percentage
                is_failure_script     = watch.is_failure_script
                is_failure_mail       = watch.is_failure_mail

                okay_script    = watch.okay_script
                okay_mail_body = watch.okay_mail_body
                is_okay_script = watch.is_okay_script
                is_okay_mail   = watch.is_okay_mail

                notify_mail_from  = watch.notify_mail_from
                notify_mail_to    = watch.notify_mail_to

                data = {"name"                  :name,
                        "check_continuation"    :check_continuation,
                        "check_span"            :check_span,
                        "warning_value"         :warning_value,
                        "warning_script"        :warning_script,
                        "warning_mail_body"     :warning_mail_body,
                        "is_warning_percentage" :is_warning_percentage,
                        "is_warning_script"     :is_warning_script,
                        "is_warning_mail"       :is_warning_mail,
                        "failure_value"         :failure_value,
                        "failure_script"        :failure_script,
                        "failure_mail_body"     :failure_mail_body,
                        "is_failure_percentage" :is_failure_percentage,
                        "is_failure_script"     :is_failure_script,
                        "is_failure_mail"       :is_failure_mail,
                        "okay_script"           :okay_script,
                        "okay_mail_body"        :okay_mail_body,
                        "is_okay_script"        :is_okay_script,
                        "is_okay_mail"          :is_okay_mail,
                        "notify_mail_from"      :notify_mail_from,
                        "notify_mail_to"        :notify_mail_to,
                        }
                retval.append(data)
    except:
        pass

    return retval


def evaluate_macro(string,macros={}):
    from karesansui.lib.utils import array_replace

    lines = string.split("\n")

    pattern = []
    replace = []
    for _k,_v in macros.iteritems():
        pattern.append("%%{%s}" % _k)
        replace.append(str(_v))

    """
    ff = open("/tmp/replace-debug.log","a")
    ff.write(str(pattern)+"\n")
    ff.write(str(replace)+"\n")
    ff.close()
    """
    return "\n".join(array_replace(lines,pattern,replace,mode="g"))



if __name__ == '__main__':

    watch_column = [ 'name',
                     'check_continuation',
                     'check_span',
                     'warning_value',
                     'warning_script',
                     'warning_mail_body',
                     'is_warning_percentage',
                     'is_warning_script',
                     'is_warning_mail',
                     'failure_value',
                     'failure_script',
                     'failure_mail_body',
                     'is_failure_percentage',
                     'is_failure_script',
                     'is_failure_mail',
                     'okay_script',
                     'okay_mail_body',
                     'is_okay_script',
                     'is_okay_mail',
                     'notify_mail_from',
                     'notify_mail_to']

    plugin          = "cpu"
    plugin_instance = "0"
    type            = "cpu"
    type_instance   = "user"
    ds              = "value"
    host            = None
    host            = "foo.example.com"

    from karesansui.lib.utils import preprint_r
    watch_data = query_watch_data(plugin,plugin_instance,type,type_instance,ds,host=host)
    preprint_r(watch_data)
    try:
        for column_name in watch_column:
            exec("%s = watch_data[0]['%s']" % (column_name,column_name,))
            exec("_var = %s" % (column_name,))
            print "%s: %s"  % (column_name,_var)

        macros = {"host":"localhost.localdomain"}
        print evaluate_macro(okay_mail_body,macros)
    except:
        print "Error: cannot get watch data."
        sys.exit(0)

    pass 

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import time
import types

import karesansui

from karesansui.lib.const import KARESANSUI_PREFIX, KARESANSUI_DATA_DIR, \
                                 KARESANSUI_USER, KARESANSUI_GROUP, \
                                 CONFIGURE_COMMAND_READ, CONFIGURE_COMMAND_WRITE
from karesansui.lib.dict_op import DictOp
from karesansui.lib.utils import preprint_r, r_chmod, r_chown, r_chgrp, base64_encode

CONF_TMP_DIR = "%s/tmp/.conf" % (KARESANSUI_DATA_DIR,)

def read_conf(modules, webobj=None, machine=None, extra_args={}):
    """<comment-ja>
    設定ファイルパーサー（モジュール）により設定ファイルの内容を
    辞書配列操作クラスに渡し、そのオブジェクトを返す
    @param modules: モジュールのリスト配列
    @param webobj: 
    @param machine: 
    @type modules: list
    @rtype: object dict_op
    @return: 辞書配列操作オブジェクト
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    if type(modules) == str:
        modules = [modules]

    options = {"module" : ":".join(modules)}

    try:
        options['include'] = extra_args['include']
    except:
        pass

    #cmd_name = u"Get Settings - %s" % ":".join(modules)
    cmd_name = u"Get Settings"

    if type(webobj) == types.InstanceType:
        from karesansui.db.model._2pysilhouette import Job, JobGroup, \
                                                       JOBGROUP_TYPE
        from karesansui.db.access._2pysilhouette import jg_findby1, jg_save,corp
        from karesansui.db.access._2pysilhouette import save_job_collaboration
        from karesansui.db.access.machine2jobgroup import new as m2j_new
        from pysilhouette.command import dict2command

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'],
                       CONFIGURE_COMMAND_READ), options)

        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))
        jobgroup.type = JOBGROUP_TYPE['PARALLEL']

        _machine2jobgroup = m2j_new(machine=machine,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=webobj.me,
                                modified_user=webobj.me,
                                )

        if corp(webobj.orm, webobj.pysilhouette.orm,_machine2jobgroup, jobgroup) is False:
            webobj.logger.debug("%s command failed. Return to timeout" % (cmd_name))
            return False

        cmd_res = jobgroup.jobs[0].action_stdout

    else:
        from karesansui.lib.utils import execute_command

        opts_str = ""
        for x in options.keys():
            if options[x] is None:
                opts_str += "--%s " % x 
            else:
                opts_str += "--%s=%s " % (x, options[x])

        _cmd = "%s/bin/%s %s" % (KARESANSUI_PREFIX, CONFIGURE_COMMAND_READ, opts_str.strip(),)

        command_args = _cmd.strip().split(" ")
        (rc,res) = execute_command(command_args)
        if rc != 0:
            return False

        cmd_res = "\n".join(res)

    dop = DictOp()
    try:
        exec(cmd_res)
    except Exception:
        return False

    for module in modules:
        try:
            exec("dop.addconf('%s',Config_Dict_%s)" % (module,module,))
        except:
            pass

    return dop

def write_conf(dop, webobj=None, machine=None, modules=[], extra_args={}):
    """<comment-ja>
    @param dop: 辞書配列操作オブジェクト
    @param webobj: 
    @param machine: 
    @type dop: object dict_op
    @rtype: boolean
    @return: True or False
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from karesansui.lib.file.configfile import ConfigFile

    if isinstance(dop,karesansui.lib.dict_op.DictOp) is False:
        return False

    if not os.path.exists(CONF_TMP_DIR):
        os.makedirs(CONF_TMP_DIR)
        r_chmod(CONF_TMP_DIR,0770)
        r_chown(CONF_TMP_DIR,KARESANSUI_USER)
        r_chgrp(CONF_TMP_DIR,KARESANSUI_GROUP)

    serial = time.strftime("%Y%m%d%H%M%S",time.localtime())

    if len(modules) == 0:
        modules = dop.ModuleNames

    w_modules = []
    w_files   = []
    for _module in modules:
        if _module in dop.ModuleNames:
            filename = "%s/%s.%s" % (CONF_TMP_DIR,_module,serial,)
            data = preprint_r(dop.getconf(_module),return_var=True)
            ConfigFile(filename).write(data+"\n")
            r_chmod(filename,0660)
            r_chown(filename,KARESANSUI_USER)
            r_chgrp(filename,KARESANSUI_GROUP)
            w_modules.append(_module)
            w_files.append(filename)

    if len(w_modules) == 0:
        return False

    options = {
         "module"     : ":".join(w_modules),
         "input-file" : ":".join(w_files),
    }
    options["delete"] = None

    try:
        extra_args['pre-command']
        options['pre-command'] = "b64:" + base64_encode(extra_args['pre-command'])
    except:
        pass
    try:
        extra_args['post-command']
        options['post-command'] = "b64:" + base64_encode(extra_args['post-command'])
    except:
        pass

    try:
        options['include'] = extra_args['include']
    except:
        pass

    #cmd_name = u"Write Settings - %s" % ":".join(w_modules)
    cmd_name = u"Write Settings"

    if type(webobj) == types.InstanceType:
        from karesansui.db.model._2pysilhouette import Job, JobGroup, \
                                                       JOBGROUP_TYPE
        from karesansui.db.access._2pysilhouette import jg_findby1, jg_save,corp
        from karesansui.db.access._2pysilhouette import save_job_collaboration
        from karesansui.db.access.machine2jobgroup import new as m2j_new
        from pysilhouette.command import dict2command

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'],
                       CONFIGURE_COMMAND_WRITE), options)

        _jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        _jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))

        _machine2jobgroup = m2j_new(machine=machine,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=webobj.me,
                                modified_user=webobj.me,
                                )

        save_job_collaboration(webobj.orm,
                               webobj.pysilhouette.orm,
                               _machine2jobgroup,
                               _jobgroup,
                               )

        """
        _jobgroup.type = JOBGROUP_TYPE['PARALLEL']
        if corp(webobj.orm, webobj.pysilhouette.orm,_machine2jobgroup, _jobgroup) is False:
            webobj.logger.debug("%s command failed. Return to timeout" % (cmd_name))
            for filename in w_files:
                if os.path.exists(filename):
                    os.unlink(filename)
            return False

        cmd_res = jobgroup.jobs[0].action_stdout
        """

    else:
        from karesansui.lib.utils import execute_command

        opts_str = ""
        for x in options.keys():
            if options[x] is None:
                opts_str += "--%s " % x 
            else:
                opts_str += "--%s=%s " % (x, options[x])

        _cmd = "%s/bin/%s %s" % (KARESANSUI_PREFIX, CONFIGURE_COMMAND_WRITE, opts_str.strip(),)

        command_args = _cmd.strip().split(" ")
        (rc,res) = execute_command(command_args)
        if rc != 0:
            for filename in w_files:
                if os.path.exists(filename):
                    os.unlink(filename)
            return False

        cmd_res = "\n".join(res)

    """
    for filename in w_files:
        if os.path.exists(filename):
            os.unlink(filename)
    """

    return True

if __name__ == '__main__':
    """Testing
    """
    modules = ["ifcfg","resolv"]
    dop = read_conf(modules)

    ipaddr = dop.get("ifcfg",["eth0","IPADDR"])
    print ipaddr

    nameservers = dop.get("resolv",["nameserver"])
    if not "127.0.0.1" in nameservers:
        nameservers.append("127.0.0.1")
    dop.set("resolv",["nameserver"],nameservers)

    write_conf(dop)
    pass

########NEW FILE########
__FILENAME__ = const
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import math
import karesansui

DEFAULT_LANGS = {
    "ja_JP": {'DATE_FORMAT' : ("%Y/%m/%d", "%Y/%m/%d %H:%M:%S", "yy-mm-dd")},
    "en_US": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "de_DE": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "es_ES": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "fr_FR": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "it_IT": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "ko_KR": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "pt_BR": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "ru_RU": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
#    "zh_CN": {'DATE_FORMAT' : ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm-dd-yy")},
}

DEFAULT_DATE_FORMAT = ("%m/%d/%Y", "%m/%d/%Y %H:%M:%S", "mm/dd/yy", "%Y/%m/%d %H:%M")

# define karesansui paths & users
KARESANSUI_USER  = "kss"
KARESANSUI_GROUP = "kss"
KARESANSUI_PREFIX = "/var/lib/karesansui"
KARESANSUI_TMP_DIR     = KARESANSUI_PREFIX + "/tmp"
KARESANSUI_SYSCONF_DIR = "/etc/karesansui"
KARESANSUI_DATA_DIR    = "/var/lib/karesansui"

MACHINE_ATTRIBUTE = {'HOST':0,
                     'GUEST':1,
                     'URI':2,
                    }
MACHINE_HYPERVISOR = {'REAL':0,
                      'XEN':1,
                      'KVM':2,
                      'URI':3,
                     }

# define vendor paths
VENDOR_PREFIX      = "/usr"
VENDOR_BIN_DIR     = VENDOR_PREFIX + "/bin"
VENDOR_SBIN_DIR    = VENDOR_PREFIX + "/sbin"
VENDOR_SYSCONF_DIR = "/etc"
VENDOR_DATA_DIR    = "/var/lib"
VENDOR_DATA_ISCSI_DIR = "/var/lib/iscsi"
VENDOR_DATA_ISCSI_MOUNT_DIR = VENDOR_DATA_ISCSI_DIR + "/mount"
VENDOR_DATA_ISCSI_DOMAINS_DIR = VENDOR_DATA_ISCSI_DIR + "/domains"
VENDOR_DATA_BONDING_EVACUATION_DIR = "/var/lib/karesansui/ifcfg"
VENDOR_LIBVIRT_RUN_DIR = "/var/run/libvirt"
XEN_SYSCONF_DIR    = "/etc/xen"

#LOGOUT_FILE_PREFIX = "%s/logout." % karesansui.config['application.tmp.dir']
LOGOUT_FILE_PREFIX = KARESANSUI_TMP_DIR + "/logout."
ICON_DIR_TPL = "%s/static/icon/%s"
MSG_LIMIT = 5
TAG_CLIPPING_RANGE = 12
MACHINE_NAME_CLIPPING_RANGE = 20

DEFAULT_LIST_RANGE = 10
JOB_LIST_RANGE = DEFAULT_LIST_RANGE
USER_LIST_RANGE = DEFAULT_LIST_RANGE
TAG_LIST_RANGE = DEFAULT_LIST_RANGE
WATCH_LIST_RANGE = DEFAULT_LIST_RANGE
MAILTEMPLATE_LIST_RANGE = DEFAULT_LIST_RANGE

# use for virt library
VIRT_LIBVIRT_DATA_DIR    = "/var/lib/libvirt"
VIRT_XENDOMAINS_AUTO_DIR = XEN_SYSCONF_DIR + "/auto"

VIRT_LIBVIRT_SOCKET_RW = VENDOR_LIBVIRT_RUN_DIR + "/libvirt-sock";
VIRT_LIBVIRT_SOCKET_RO = VENDOR_LIBVIRT_RUN_DIR + "/libvirt-sock-ro";

# kvm
KVM_VIRTUAL_DISK_PREFIX = "hd"
KVM_VIRT_CONFIG_DIR  = "/etc/karesansui/virt/kvm"
#KVM_VIRT_URI_RW = "qemu+tls://127.0.0.1:16514/system?no_verify=1"
#KVM_VIRT_URI_RO = "qemu+tls://127.0.0.1:16514/system?no_verify=1"
KVM_VIRT_URI_RW = "qemu+tcp://127.0.0.1:16509/system"
KVM_VIRT_URI_RO = "qemu+tcp://127.0.0.1:16509/system"
KVM_KARESANSUI_TMP_DIR = KARESANSUI_TMP_DIR + "/kvm"
if os.path.exists('/usr/share/qemu-kvm/keymaps'):
    KVM_KEYMAP_DIR = '/usr/share/qemu-kvm/keymaps'
else:
    KVM_KEYMAP_DIR = '/usr/share/kvm/keymaps'
#KVM_BRIDGE_PREFIX = "(eth|bondbr)"
KVM_BRIDGE_PREFIX = "br"

# xen
XEN_VIRTUAL_DISK_PREFIX = "xvd"
XEN_VIRT_CONFIG_DIR  = "/etc/karesansui/virt/xen"
XEN_VIRT_URI_RW = "xen:///?socket=" + VIRT_LIBVIRT_SOCKET_RW
XEN_VIRT_URI_RO = "xen:///?socket=" + VIRT_LIBVIRT_SOCKET_RO
XEN_KARESANSUI_TMP_DIR = KARESANSUI_TMP_DIR + "/xen"
XEN_KEYMAP_DIR = '/usr/share/xen/qemu/keymaps'

VIRT_XML_CONFIG_DIR  = VENDOR_SYSCONF_DIR + "/libvirt/qemu"

VIRT_SYSCONF_DIR = VENDOR_SYSCONF_DIR + "/libvirt"
OLD_VIRT_DISK_DIR       = VIRT_LIBVIRT_DATA_DIR + "/disk"
OLD_VIRT_DISK_IMAGE_DIR = VIRT_LIBVIRT_DATA_DIR + "/images"
OLD_VIRT_BOOT_IMAGE_DIR = VIRT_LIBVIRT_DATA_DIR + "/boot"
OLD_VIRT_SNAPSHOT_DIR   = VIRT_LIBVIRT_DATA_DIR + "/snapshot"
VIRT_DOMAINS_DIR        = VIRT_LIBVIRT_DATA_DIR + "/domains"
VIRT_QEMU_DIR           = VIRT_LIBVIRT_DATA_DIR + "/qemu"
VIRT_SNAPSHOT_DIR       = VIRT_QEMU_DIR + "/snapshot"
VIRT_NETWORK_CONFIG_DIR = VIRT_SYSCONF_DIR + "/qemu/networks"
VIRT_AUTOSTART_CONFIG_DIR = VIRT_SYSCONF_DIR + "/qemu/autostart"
VIRT_LIBVIRTD_CONFIG_FILE = VIRT_SYSCONF_DIR + "/libvirtd.conf"
VIRT_STORAGE_CONFIG_DIR = VIRT_SYSCONF_DIR + "/storage"
VIRT_STORAGE_AUTOSTART_CONFIG_DIR = VIRT_SYSCONF_DIR + "/storage/autostart"

# virt command
VIRT_COMMAND_APPLY_SNAPSHOT = "apply_snapshot.py"
VIRT_COMMAND_CREATE_GUEST = "create_guest.py"
VIRT_COMMAND_DELETE_GUEST = "delete_guest.py"
VIRT_COMMAND_DELETE_SNAPSHOT = "delete_snapshot.py"
VIRT_COMMAND_GET_MEMORY_USAGE = "get_memory_usage.py"
VIRT_COMMAND_SET_MEMORY = "set_memory.py"
VIRT_COMMAND_START_GUEST = "start_guest.py"
VIRT_COMMAND_REBOOT_GUEST = "reboot_guest.py"
VIRT_COMMAND_DESTROY_GUEST = "destroy_guest.py"
VIRT_COMMAND_AUTOSTART_GUEST = "autostart_guest.py"
VIRT_COMMAND_CREATE_NETWORK = "create_network.py"
VIRT_COMMAND_DELETE_NETWORK = "delete_network.py"
VIRT_COMMAND_UPDATE_NETWORK = "update_network.py"
VIRT_COMMAND_REPLICATE_GUEST = "replicate_guest.py"
VIRT_COMMAND_EXPORT_GUEST = "export_guest.py"
VIRT_COMMAND_IMPORT_GUEST = "import_guest.py"
VIRT_COMMAND_DELETE_EXPORT_DATA = "delete_export_data.py"
VIRT_COMMAND_SET_VCPUS = "set_vcpus.py"
VIRT_COMMAND_SUSPEND_GUEST = "suspend_guest.py"
VIRT_COMMAND_ADD_DISK = "add_disk.py"
VIRT_COMMAND_APPEND_DISK = "append_disk.py"
VIRT_COMMAND_DELETE_DISK = "delete_disk.py"
VIRT_COMMAND_ADD_NIC = "add_nic.py"
VIRT_COMMAND_DELETE_NIC = "delete_nic.py"
VIRT_COMMAND_CPUTOP = "cputop.py"
VIRT_COMMAND_GET_CPU_USAGE = "get_cpu_usage.py"
VIRT_COMMAND_RESUME_GUEST = "resume_guest.py"
VIRT_COMMAND_SHUTDOWN_GUEST = "shutdown_guest.py"
VIRT_COMMAND_TAKE_SNAPSHOT = "take_snapshot.py"
VIRT_COMMAND_SET_MAC_ADDRESS = "set_mac_address.py"
VIRT_COMMAND_SET_GRAPHICS = "set_graphics.py"
FIREWALL_COMMAND_SAVE_FIREWALL = "save_firewall.py"
FIREWALL_COMMAND_RESTORE_FIREWALL = "restore_firewall.py"
UPDATE_COMMAND_SOFTWARE="update_software.py"
VIRT_COMMAND_CREATE_STORAGE_POOL = "create_storage_pool.py"
VIRT_COMMAND_DELETE_STORAGE_POOL = "delete_storage_pool.py"
VIRT_COMMAND_START_STORAGE_POOL = "start_storage_pool.py"
VIRT_COMMAND_DESTROY_STORAGE_POOL = "destroy_storage_pool.py"
VIRT_COMMAND_CREATE_STORAGE_VOLUME = "create_storage_volume.py"
VIRT_COMMAND_DELETE_STORAGE_VOLUME = "delete_storage_volume.py"
VIRT_COMMAND_REPLICATE_STORAGE_VOLUME = "replicate_storage_volume.py"
ISCSI_COMMAND_GET = "get_iscsi.py"
ISCSI_COMMAND_ADD = "add_iscsi.py"
ISCSI_COMMAND_DELETE = "delete_iscsi.py"
ISCSI_COMMAND_START = "start_iscsi.py"
ISCSI_COMMAND_STOP = "stop_iscsi.py"
ISCSI_COMMAND_UPDATE = "update_iscsi.py"
CONFIGURE_COMMAND_READ = "read_conf.py"
CONFIGURE_COMMAND_WRITE = "write_conf.py"
IPTABLES_COMMAND_CONTROL = "control_iptables.py"
SERVICE_COMMAND_START = "start_service.py"
SERVICE_COMMAND_STOP = "stop_service.py"
SERVICE_COMMAND_RESTART = "restart_service.py"
SERVICE_COMMAND_AUTOSTART = "autostart_service.py"
ISCSI_COMMAND_READY_MOUNT = "ready_mount.py"
BONDING_COMMAND_ADD = "add_bonding.py"
BONDING_COMMAND_DELETE = "delete_bonding.py"
NETWORK_COMMAND_RESTART = "restart_network_interface.py"

# use for firewall library
FIREWALL_XML_FILE  = KARESANSUI_SYSCONF_DIR + "/firewall.xml"
FIREWALL_USERCHAIN = "KARESANSUI-Firewall"
RH_USERCHAIN = "RH-Firewall-1-INPUT"

# Proxy Server use Status
PROXY_ENABLE = '1'
PROXY_DISABLE = '0'

# port number
PORT_MIN_NUMBER = 1
PORT_MAX_NUMBER = 65535
WELKNOWN_PORT_MIN_NUMBER = 1
WELKNOWN_PORT_MAX_NUMBER = 1024
UNKNOWN_PORT_MIN_NUMBER = 1025
UNKNOWN_PORT_MAX_NUMBER = 65535
GRAPHICS_PORT_MIN_NUMBER = 5900
GRAPHICS_PORT_MAX_NUMBER = PORT_MAX_NUMBER
ENABLE_GRAPHICS_TYPE = ['vnc','spice']

# input value length
ID_MIN_LENGTH = 1
ID_MAX_LENGTH = int(math.pow(2, 31)) - 1  # signed int max (2^31-1) SQLAlchemy SQLType.Integer
USER_MIN_LENGTH = 1
USER_MAX_LENGTH = 16
EMAIL_MIN_LENGTH = 1 + 1 + 4
EMAIL_MAX_LENGTH = 256
PASSWORD_MIN_LENGTH = 5
PASSWORD_MAX_LENGTH = 40
LANGUAGES_MIN_LENGTH = 1
LANGUAGES_MAX_LENGTH = 6
TAG_MIN_LENGTH = 1
TAG_MAX_LENGTH = 24
SEARCH_MIN_LENGTH = 0
SEARCH_MAX_LENGTH = 256
PAGE_MIN_SIZE = 0
PAGE_MAX_SIZE = int(math.pow(2, 31)) - 1  # signed int max (2^31-1)
MACHINE_NAME_MIN_LENGTH = 1
MACHINE_NAME_MAX_LENGTH = 256
HYPERVISOR_MIN_SIZE = 0
HYPERVISOR_MAX_SIZE = 2
MEMORY_MIN_SIZE = 64
DISK_MIN_SIZE = 1
CHECK_DISK_QUOTA = 0.95
DOMAIN_NAME_MIN_LENGTH = 1
DOMAIN_NAME_MAX_LENGTH = 256
NOTE_TITLE_MIN_LENGTH = 0
NOTE_TITLE_MAX_LENGTH = 64
IMAGE_EXT_LIST = ["gif", "png", "jpeg"]
VCPUS_MIN_SIZE = 1
FQDN_MIN_LENGTH = 0
FQDN_MAX_LENGTH = 256
CHAP_USER_MIN_LENGTH = 1
CHAP_USER_MAX_LENGTH = 256
CHAP_PASSWORD_MIN_LENGTH = 1
CHAP_PASSWORD_MAX_LENGTH = 256
STORAGE_VOLUME_SIZE_MIN_LENGTH = 0;
STORAGE_VOLUME_SIZE_MAX_LENGTH = 2147483647;
CONTINUATION_COUNT_MIN = 1;
CONTINUATION_COUNT_MAX = 2147483647;
PROHIBITION_PERIOD_MIN = 1;
PROHIBITION_PERIOD_MAX = 2147483647;
THRESHOLD_VAL_MIN = 0;

DEFAULT_KEYMAP = 'en-us'

# use for storagepool
STORAGE_POOL_TYPE = {"TYPE_DIR":"dir",
                     "TYPE_FS":"fs",
                     "TYPE_NETFS":"netfs",
                     "TYPE_LOGICAL":"logical",
                     "TYPE_DISK":"disk",
                     "TYPE_ISCSI":"iscsi",
                     "TYPE_SCSI":"scsi",
                     }

STORAGE_VOLUME_FORMAT = {"TYPE_RAW":"raw",
                  "TYPE_QCOW2":"qcow2",
                  #"TYPE_QCOW":"qcow",
                  #"TYPE_COW":"cow",
                  #"TYPE_VDI":"vdi",
                  #"TYPE_VMDK":"vmdk",
                  #"TYPE_VPC":"vpc",
                  #"TYPE_CLOOP":"cloop",
                  }

STORAGE_VOLUME_UNIT = {"B":1024**0,
                       "K":1024**1,
                       "M":1024**2,
                       "G":1024**3,
                       "T":1024**4,
                       "P":1024**5,
                       "E":1024**6,
                      }

# Disk format
DISK_QEMU_FORMAT = {"RAW" : "raw",
                    "QCOW2" : "qcow2",
                    #"QCOW" : "qcow",
                    #"COW" : "cow",
                    #"VMDK" : "vmdk",
                    }

DISK_NON_QEMU_FORMAT = {"RAW" : "raw",}

# use for iSCSI
ISCSI_DEVICE_DIR = "/dev/disk/by-path"
ISCSI_DEVICE_NAME_TPL = "ip-%s:%s-iscsi-%s"
ISCSI_DEFAULT_CONFIG_PATH = "/etc/iscsi/iscsid.conf"
ISCSI_DEFAULT_NODE_CONFIG_DIR = "/var/lib/iscsi/nodes"

ISCSI_CONFIG_KEY_AUTH_METHOD = "node.session.auth.authmethod"
ISCSI_CONFIG_KEY_AUTH_USER = "node.session.auth.username"
ISCSI_CONFIG_KEY_AUTH_PASSWORD = "node.session.auth.password"
ISCSI_CONFIG_KEY_SATRTUP = "node.startup"
ISCSI_CONFIG_VALUE_AUTH_METHOD_NONE = "None"
ISCSI_CONFIG_VALUE_AUTH_METHOD_CHAP = "CHAP"
ISCSI_CONFIG_VALUE_SATRTUP_ON = "automatic"
ISCSI_CONFIG_VALUE_SATRTUP_OFF = "manual"
ISCSI_DATA_DIR = VENDOR_DATA_DIR + "/iscsi"

ISCSI_CMD = "/sbin/iscsiadm"
ISCSI_CMD_OPTION_MODE = "--mode"
ISCSI_CMD_OPTION_MODE_NODE = "node"
ISCSI_CMD_OPTION_MODE_SESSION = "session"
ISCSI_CMD_OPTION_MODE_DISCOVERY = "discovery"
ISCSI_CMD_OPTION_TYPE = "--type"
ISCSI_CMD_OPTION_TYPE_SENDTARGETS = "sendtargets"
ISCSI_CMD_OPTION_OPERATOR = "--op"
ISCSI_CMD_OPTION_OPERATOR_DELETE = "delete"
ISCSI_CMD_OPTION_TARGETNAME = "--targetname"
ISCSI_CMD_OPTION_PORTAL = "--portal"
ISCSI_CMD_OPTION_LOGIN = "--login"
ISCSI_CMD_OPTION_LOGOUT = "--logout"
ISCSI_CMD_RES_NO_NODE = "no records found"
ISCSI_CMD_RES_NO_ACTIVE_SESSION = "No active sessions"

DEFAULT_KVM_DISK_FORMAT = "qcow2"
DEFAULT_XEN_DISK_FORMAT = "raw"

# use for log
LOG_EPOCH_REGEX = r"(^[0-9]+\.[0-9]+)"
LOG_SYSLOG_REGEX = r"(^[a-zA-Z]{3} [ 0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2})"

# use for collectd
COLLECTD_LOG_DIR  = "/var/log/collectd"
COLLECTD_DATA_DIR = "%s/collectd" % VENDOR_DATA_DIR

COLLECTD_PLUGIN_CPU = "cpu"
COLLECTD_PLUGIN_DF = "df"
COLLECTD_PLUGIN_DISK = "disk"
COLLECTD_PLUGIN_EXEC = "exec"
COLLECTD_PLUGIN_INTERFACE = "interface"
COLLECTD_PLUGIN_IPTABLES = "iptables"
COLLECTD_PLUGIN_LIBVIRT = "libvirt"
COLLECTD_PLUGIN_LOAD = "load"
COLLECTD_PLUGIN_LOGFILE = "logfile"
COLLECTD_PLUGIN_MEMORY = "memory"
COLLECTD_PLUGIN_NETWORK = "network"
COLLECTD_PLUGIN_PYTHON = "python"
COLLECTD_PLUGIN_RRDCACHED = "rrdcached"
COLLECTD_PLUGIN_RRDTOOL = "rrdtool"
COLLECTD_PLUGIN_SENSORS = "sensors"
COLLECTD_PLUGIN_SNMP = "SNMP"
COLLECTD_PLUGIN_SYSLOG = "syslog"
COLLECTD_PLUGIN_TAIL = "tail"
COLLECTD_PLUGIN_UPTIME = "uptime"
COLLECTD_PLUGIN_USERS = "users"

WATCH_PLUGINS = {"cpu"       : COLLECTD_PLUGIN_CPU,
                 "df"        : COLLECTD_PLUGIN_DF,
                 "interface" : COLLECTD_PLUGIN_INTERFACE,
                 "libvirt"   : COLLECTD_PLUGIN_LIBVIRT,
                 "load"      : COLLECTD_PLUGIN_LOAD,
                 "memory"    : COLLECTD_PLUGIN_MEMORY,
                 }

COLLECTD_CPU_TYPE = "cpu"
COLLECTD_CPU_TYPE_INSTANCE = {"IDLE" : "idle",
                              "NICE" : "nice",
                              "USER" : "user",
                              "WAIT" : "wait",
                              "INTERRUPT" : "interrupt",
                              "SOFTIRQ" : "softirq",
                              "STEAL" : "steal",
                              "SYSTEM" : "system",
                              }
COLLECTD_CPU_DS = "value"
COLLECTD_MEMORY_TYPE = "memory"
COLLECTD_MEMORY_TYPE_INSTANCE = {"FREE" : "free",
                                 "CACHED" : "cached",
                                 "BUFFERED" : "buffered",
                                 "USED" : "used",
                                 }
COLLECTD_MEMORY_DS = "value"
COLLECTD_DF_TYPE = "df"
COLLECTD_DF_DS = {"USED" : "used",
                  "FREE" : "free",
                  }
COLLECTD_DISK_TYPE = {"MERGED" : "disk_merged",
                      "OCTETS" : "disk_octets",
                      "OPS" : "disk_ops",
                      "TIME" : "disk_time",
                      }
COLLECTD_DISK_DS = {"READ" : "read",
                    "WRITE" : "write",
                    }
COLLECTD_INTERFACE_TYPE = {"ERRORS" : "if_errors",
                           "PACKETS" : "if_packets",
                           "OCTETS" : "if_octets",
                           }
COLLECTD_INTERFACE_DS = {"RX" : "rx",
                         "TX" : "tx",
                         }
COLLECTD_UPTIME_TYPE ="uptime"
COLLECTD_UPTIME_DS = "value"

COLLECTD_LOAD_TYPE = "load"
COLLECTD_LOAD_DS = {"SHORTTERM": "shortterm",
                    "MIDTERM"  : "midterm",
                    "LONGTERM" : "longterm",
                   }

COLLECTD_USERS_TYPE ="users"
COLLECTD_USERS_DS = "users"

COLLECTD_LIBVIRT_TYPE = {"CPU_TOTAL" : "virt_cpu_total",
                         "VCPU" : "virt_vcpu",
                         "DISK_OPS" : "disk_ops",
                         "DISK_OCTETS" : "disk_octets",
                         "IF_OCTETS" : "if_octets",
                         "IF_PACKETS" : "if_packets",
                         "IF_ERRORS" : "if_errors",
                         "IF_DROPPED" : "if_dropped",
                         }

COLLECTD_DF_RRPORT_BY_DEVICE = True

COUNTUP_DATABASE_PATH = KARESANSUI_DATA_DIR + "/notify_count.db"
VALUE_BOUNDS_UPPER = "1"
VALUE_BOUNDS_LOWER = "0"

HDD_TYPES_REGEX = ('sd[a-z]+[0-9]*',
                   'hd[a-z]+[0-9]*',
                   )

STORAGE_POOL_PWD = {"OWNER":"root",
                    "GROUP":"kss",
                    "MODE":"0770",
                    }

STORAGE_VOLUME_PWD = {"OWNER":"root",
                      "GROUP":"kss",
                      "MODE":"0660",
                      }

DISK_USES = {"IMAGES":"images",
             "DISK":"disk",
             }

# use for mail template
TEMPLATE_DIR = KARESANSUI_SYSCONF_DIR + "/template"
MAIL_TEMPLATE_DIR_JA = TEMPLATE_DIR + "/ja"
MAIL_TEMPLATE_DIR_EN = TEMPLATE_DIR + "/en"
MAIL_TEMPLATE_COLLECTD_WARNING = {COLLECTD_PLUGIN_CPU:"collectd_warning_cpu.eml",
                                  COLLECTD_PLUGIN_DF:"collectd_warning_df.eml",
                                  COLLECTD_PLUGIN_DISK:"collectd_warning_disk.eml",
                                  COLLECTD_PLUGIN_INTERFACE:"collectd_warning_interface.eml",
                                  COLLECTD_PLUGIN_LIBVIRT:"collectd_warning_libvirt.eml",
                                  COLLECTD_PLUGIN_LOAD:"collectd_warning_load.eml",
                                  COLLECTD_PLUGIN_MEMORY:"collectd_warning_memory.eml",
                                  COLLECTD_PLUGIN_UPTIME:"collectd_warning_uptime.eml",
                                  COLLECTD_PLUGIN_USERS:"collectd_warning_users.eml",
                                  }
MAIL_TEMPLATE_COLLECTD_FAILURE = {COLLECTD_PLUGIN_CPU:"collectd_failure_cpu.eml",
                                  COLLECTD_PLUGIN_DF:"collectd_failure_df.eml",
                                  COLLECTD_PLUGIN_DISK:"collectd_failure_disk.eml",
                                  COLLECTD_PLUGIN_INTERFACE:"collectd_failure_interface.eml",
                                  COLLECTD_PLUGIN_LIBVIRT:"collectd_failure_libvirt.eml",
                                  COLLECTD_PLUGIN_LOAD:"collectd_failure_load.eml",
                                  COLLECTD_PLUGIN_MEMORY:"collectd_failure_memory.eml",
                                  COLLECTD_PLUGIN_UPTIME:"collectd_failure_uptime.eml",
                                  COLLECTD_PLUGIN_USERS:"collectd_failure_users.eml",
                                  }
MAIL_TEMPLATE_COLLECTD_OKAY = {COLLECTD_PLUGIN_CPU:"collectd_okay_cpu.eml",
                                  COLLECTD_PLUGIN_DF:"collectd_okay_df.eml",
                                  COLLECTD_PLUGIN_DISK:"collectd_okay_disk.eml",
                                  COLLECTD_PLUGIN_INTERFACE:"collectd_okay_interface.eml",
                                  COLLECTD_PLUGIN_LIBVIRT:"collectd_okay_libvirt.eml",
                                  COLLECTD_PLUGIN_LOAD:"collectd_okay_load.eml",
                                  COLLECTD_PLUGIN_MEMORY:"collectd_okay_memory.eml",
                                  COLLECTD_PLUGIN_UPTIME:"collectd_okay_uptime.eml",
                                  COLLECTD_PLUGIN_USERS:"collectd_okay_users.eml",
                                  }

# use for service
SERVICE_XML_FILE  = KARESANSUI_SYSCONF_DIR + "/service.xml"

# use for Report
GRAPH_COMMON_PARAM = [
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--grid-dash", "1:0",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
    ]
# use for log viewer
LOG_VIEW_XML_FILE = KARESANSUI_SYSCONF_DIR + "/logview.xml"

GUEST_EXPORT_FILE = 'info.dat'

KVM_BUS_TYPES = ['ide',
                 #'scsi',
                 'virtio',
                 ]
XEN_BUS_TYPES = ['xen']

# use for mount check
MOUNT_CMD = "/bin/mount"
UMOUNT_CMD = "/bin/umount"
FORMAT_CMD = "/sbin/mkfs"
YES_CMD = ("echo", "y")

# interval of monitoring
# !! This interval value is dummy.
# !! Genuine value in collectd config file (/etc/collectd.conf).
WATCH_INTERVAL = 10

# use for network bonding
BONDING_MODE = {"0" : 0,
                "1" : 1,
                "2" : 2,
                "3" : 3,
                "4" : 4,
                "5" : 5,
                "6" : 6,
                }
BONDING_CONFIG_MII_DEFAULT = 100
NETWORK_IFCFG_DIR = "/etc/sysconfig/network-scripts"
NETWORK_COMMAND = "/etc/init.d/network"
SYSTEM_COMMAND_REMOVE_MODULE = "/sbin/rmmod"
NETWORK_IFDOWN_COMMAND = "/sbin/ifdown"
NETWORK_BRCTL_COMMAND = "/usr/sbin/brctl"
NETWORK_IFCONFIG_COMMAND = "/sbin/ifconfig"

DEFAULT_DECIMAL_POINT = 1

DEFAULT_ALERT_TRIGGER_COUNT = 3;
DEFAULT_SLIENT_PERIOD = 300;

########NEW FILE########
__FILENAME__ = crypt
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import random
try:
  from hashlib import sha1 as sha
except:
  import sha
  from sha import sha

def sha1encrypt(v):
    """<comment-ja>
    自動生成したsaltを加えた文字列をSHA1で暗号化します。
    @param v: SHA1で暗号化する文字列
    @type v: str
    @rtype: str, str
    @return: SHA1で暗号化された文字列, salt
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    salt = ''
    for x in xrange(0,16):
        salt += random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')

    r = sha(v+salt).hexdigest()
    return r, salt

def sha1compare(target, plain, salt=''):
    """<comment-ja>
    SHA1で暗号化された文字列と平文+saltを比較します。
    @param target: SHA1で暗号化された文字列
    @type target: str
    @param plain: 比較対象の平文
    @type plain: str
    @param salt: salt
    @type salt: str
    @rtype: bool
    @return: 一致すればTrue, 不一致ならばFalseを返却します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    x = sha(plain+salt).hexdigest()
    if target == x:
        return True
    else:
        return False

if __name__ == '__main__':
    """Testing
    """
    word = 'password'
    print 'word=' + word
    v, salt = sha1encrypt(word)
    print 'encrypt=' + v
    print 'salt=' + salt
    if sha1compare(v, word, salt) is True:
        print 'Success'
    else:
        print 'Failure'

########NEW FILE########
__FILENAME__ = dict_op
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.utils import preprint_r

"""
try:
    import odict
    Dict = odict.odict()
except:
    Dict = {}
"""

class DictOp:

    def __init__(self):

        self.ModuleNames = []
        self.ConfigArray = {}
        self.set_order_key()

    def set_order_key(self, string="@ORDERS"):
        self.orders_key = string

    def preprint_r(self, module, key=None ,indent=2,depth=None):
        import pprint
        pp = pprint.PrettyPrinter(indent=indent,depth=depth)
        if key is None:
            pp.pprint(self.getconf(module))
        else:
            pp.pprint(self.get(module,key))

    def addconf(self, module, conf_array={}):
        self.ModuleNames.append(module)
        self.ConfigArray[module] = conf_array
        return True

    def getconf(self, module):
        try:
            return self.ConfigArray[module]
        except:
            return {}

    def set(self, module, key, value, is_cdp=False, multiple_file=False):
        return self._set(module,key,value,action='set',is_cdp=is_cdp,multiple_file=multiple_file)

    def add(self, module, key, value, is_cdp=False, multiple_file=False):
        return self._set(module,key,value,action='add',is_cdp=is_cdp,multiple_file=multiple_file)

    def _set(self, module, key, value, action='set', is_cdp=False, multiple_file=False):

        try:
            self.ConfigArray[module]
        except:
            return False

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return False

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str  = "conf"
            cnt = 0
            for _k in key:
                _k = _k.replace("'","\\'")
                eval_str  = "%s['%s']" % (eval_str,_k,)
                try:
                    exec("%s" % (eval_str,))
                    try:
                        exec("%s['action'] = '%s'" % (eval_str,str(action)))
                    except:
                        pass
                except:
                    val_str = "{'value':{},'action':action,'comment':False}"
                    exec("%s = %s" % (eval_str,val_str))

                eval_str  = "%s['value']" % (eval_str,)
                try:
                    exec("%s" % (eval_str,))
                except:
                    val_str = "{}"
                    exec("%s = %s" % (eval_str,val_str))

            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            eval_str_value = "%s['value']" % eval_str

            #print "%s = value" % (eval_str_value,)
            exec("%s = value" % (eval_str_value,))

            self.ConfigArray[module] = conf

        else:
            k_len = len(new_key)
            is_dict = True
            eval_str_value  = "conf"

            if multiple_file is True:
                file_name = new_key.pop(0)
                eval_str         = eval_str_value + "['%s']" % file_name
                eval_str_value  += "['%s']['value']" % file_name
                try:
                    exec("%s" % (eval_str_value,))
                except:
                    try:
                        exec("%s" % (eval_str,))
                    except:
                        val_str = "{}"
                        exec("%s = %s" % (eval_str,val_str))
                    val_str = "{}"
                    exec("%s = %s" % (eval_str_value,val_str))

            cnt = 0
            for _k in new_key:
                eval_str_value  += "['%s']" % _k
                try:
                    exec("%s" % (eval_str_value,))
                except:
                    val_str = "{}"
                    exec("%s = %s" % (eval_str_value,val_str))

                eval_str_value_base  = eval_str_value
                eval_str_value  += "['value']"
                try:
                    exec("%s" % (eval_str_value,))
                except:
                    if is_dict is False:
                        val_str = "{'value':[{},[[],None]],'action':action,'comment':False}"
                    else:
                        val_str = "{'value':{},'action':action,'comment':False}"
                    exec("%s = %s" % (eval_str_value_base,val_str))

                if is_dict is False:
                    eval_str_value  += "[0]"
                    if cnt == k_len:
                        exec("%s = value" % (eval_str_value,))

                is_dict = not is_dict
                cnt = cnt + 1

            exec("%s = value" % (eval_str_value,))
            self.ConfigArray[module] = conf

        return True

    def unset(self, module, key, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return False

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)

            try:
                exec("del %s" % (eval_str,))
                return True
            except:
                return retval

        else:
            is_dict = True
            eval_str  = "conf"

            if multiple_file is True:
                eval_str  += "['%s']['value']" % new_key.pop(0)

            k_len = len(new_key)

            cnt = 0
            for _k in new_key:
                cnt = cnt + 1
                eval_str  += "['%s']" % _k
                if cnt == k_len:
                    break
                eval_str  += "['value']"
                if is_dict is False:
                    eval_str  += "[0]"
                is_dict = not is_dict

            try:
                exec("del %s" % (eval_str,))
                return True
            except:
                return retval


    def get(self, module, key, with_attr=False, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return retval

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            if with_attr is True:
                eval_str_value = "%s" % eval_str
            else:
                eval_str_value = "%s['value']" % eval_str

            try:
                exec("retval = %s" % (eval_str_value,))
                return retval
            except:
                return retval

        else:
            cnt = 0
            k_len = len(new_key)
            is_dict = True
            eval_str_value  = "conf"

            if multiple_file is True:
                eval_str_value  += "['%s']['value']" % new_key.pop(0)

            for _k in new_key:
                eval_str_value  += "['%s']" % _k
                cnt = cnt + 1
                if cnt < k_len:
                    eval_str_value  += "['value']"
                elif cnt == k_len:
                    if with_attr is False:
                        eval_str_value  += "['value']"
                if is_dict is False:
                    eval_str_value  += "[0]"
                is_dict = not is_dict

            try:
                exec("retval = %s" % (eval_str_value,))
                return retval
            except:
                return retval


    def delete(self, module, key, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return retval

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            eval_str_value = "%s['value']" % eval_str

            try:
                exec("%s" % (eval_str,))
                eval_str_action = "%s['action']" % eval_str
                exec("%s = 'delete'" % (eval_str_action,))
            except:
                pass

            self.ConfigArray[module] = conf

        else:
            is_dict = True
            eval_str  = "conf"

            if multiple_file is True:
                eval_str  += "['%s']['value']" % new_key.pop(0)

            k_len = len(new_key)
            cnt = 0
            for _k in new_key:
                cnt = cnt + 1
                eval_str  += "['%s']" % _k
                if cnt == k_len:
                    break
                eval_str  += "['value']"
                if is_dict is False:
                    eval_str  += "[0]"
                is_dict = not is_dict

            try:
                exec("%s" % (eval_str,))
                eval_str_action = "%s['action']" % eval_str
                exec("%s = 'delete'" % (eval_str_action,))
            except:
                pass

            self.ConfigArray[module] = conf

        return True

    def comment(self, module,   key, recursive=False, is_cdp=False, multiple_file=False):
        return self._comment(module,key,flag=True, recursive=recursive,is_cdp=is_cdp,multiple_file=multiple_file)

    def uncomment(self, module, key, recursive=False, is_cdp=False, multiple_file=False):
        return self._comment(module,key,flag=False,recursive=recursive,is_cdp=is_cdp,multiple_file=multiple_file)

    def _comment(self, module, key, flag=True, recursive=False, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return retval

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            eval_str_value = "%s['value']" % eval_str

            try:
                exec("%s" % (eval_str,))
                eval_str_comment = "%s['comment']" % eval_str
                exec("%s = flag" % (eval_str_comment,))
            except:
                pass

            self.ConfigArray[module] = conf

        else:
            is_dict = True
            eval_str  = "conf"

            if multiple_file is True:
                eval_str  += "['%s']['value']" % new_key.pop(0)

            k_len = len(new_key)
            cnt = 0
            for _k in new_key:
                cnt = cnt + 1
                eval_str  += "['%s']" % _k
                if cnt == k_len:
                    break
                eval_str  += "['value']"
                if is_dict is False:
                    eval_str  += "[0]"
                is_dict = not is_dict

            try:
                exec("%s" % (eval_str,))
                eval_str_comment = "%s['comment']" % eval_str
                exec("%s = %s" % (eval_str_comment,str(flag),))

                if recursive is True:
                    eval_str_value = "%s['value']" % eval_str
                    exec("_value = %s" % (eval_str_value,))
                    if type(_value) == list:
                        for _value2 in _value:
                            if type(_value2) == dict:
                                for _k2,_v2 in _value2.iteritems():
                                    r_key = key + [_k2]
                                    self._comment(module, r_key, flag, recursive, is_cdp, multiple_file)
                    elif type(_value) == dict:
                        for _k2,_v2 in _value.iteritems():
                            r_key = key + [_k2]
                            self._comment(module, r_key, flag, recursive, is_cdp, multiple_file)

            except:
                pass

            self.ConfigArray[module] = conf

        return True

    def forceset(self, module, key, value, is_cdp=False, multiple_file=False):
        retval1 = self._set(module,key,value,action='set',is_cdp=is_cdp,multiple_file=multiple_file)
        retval2 = self._comment(module,key,value,flag=False)
        return retval1 & retval2

    def query(self, module, key, regex=".*"):
        retval = self.get(module,key)
        if type(retval) is dict:
            new_retval = []
            for _k,_v in retval.iteritems():
                new_retval.append(_k)
            retval = new_retval

        if type(retval) is str:
            retval = [retval]

        if type(retval) is list:
            new_retval = []
            for _k in retval:
                if re.search(r"%s" % regex, _k):
                    new_retval.append(_k)
            retval = new_retval

        return retval

    def action(self, module, key, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return retval

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            eval_str_action = "%s['action']" % eval_str

            try:
                exec("retval = %s" % (eval_str_action,))
                return retval
            except:
                return retval

        else:
            is_dict = True
            eval_str  = "conf"

            if multiple_file is True:
                eval_str  += "['%s']['value']" % new_key.pop(0)

            k_len = len(new_key)
            cnt = 0
            for _k in new_key:
                cnt = cnt + 1
                eval_str  += "['%s']" % _k
                if cnt == k_len:
                    break
                eval_str  += "['value']"
                if is_dict is False:
                    eval_str  += "[0]"
                is_dict = not is_dict

            try:
                exec("%s" % (eval_str,))
                eval_str_action = "%s['action']" % eval_str
                exec("retval = %s" % (eval_str_action,))
                return retval
            except:
                return retval


    def iscomment(self, module, key, is_cdp=False, multiple_file=False):
        retval = False

        try:
            self.ConfigArray[module]
        except:
            return retval

        conf = self.ConfigArray[module]

        if type(key) == list:
            pass
        elif type(key) == str:
            key = [key]
        else:
            return retval

        new_key = []
        for _k in key:
            new_key.append(_k.replace("'","\\'"))

        if is_cdp is False:
            eval_str       = "conf['%s']" % "']['value']['".join(new_key)
            eval_str_comment = "%s['comment']" % eval_str

            try:
                exec("retval = %s" % (eval_str_comment,))
                return retval
            except:
                return retval

        else:
            is_dict = True
            eval_str  = "conf"

            if multiple_file is True:
                eval_str  += "['%s']['value']" % new_key.pop(0)

            k_len = len(new_key)
            cnt = 0
            for _k in new_key:
                cnt = cnt + 1
                eval_str  += "['%s']" % _k
                if cnt == k_len:
                    break
                eval_str  += "['value']"
                if is_dict is False:
                    eval_str  += "[0]"
                is_dict = not is_dict

            try:
                exec("%s" % (eval_str,))
                eval_str_comment = "%s['comment']" % eval_str
                exec("retval = %s" % (eval_str_comment,))
                return retval
            except:
                return retval


    def isset(self, module, key, is_cdp=False, multiple_file=False):
        retval = False

        if is_cdp is False:
            if self.get(module,key) is not False:
                retval = True
        else:
            if self.get(module, key, is_cdp=True, multiple_file=multiple_file) is not False:
                retval = True

        return retval

    def order(self, module, key, is_parent_parser=False):
        retval = False

        search_key = []
        if type(key) == list:
            if is_parent_parser is True:
                _sk = key.pop(0)
                search_key.append(_sk)
        elif type(key) == str:
            key = [key]

        search_key.append(self.orders_key)

        try:
            orders = self.get(module, search_key)
            if key in orders:
                return orders.index(key)
        except:
            pass

        return retval

    def insert_order(self, module, key, num=None, is_parent_parser=False):
        retval = False

        search_key = []
        if type(key) == list:
            if is_parent_parser is True:
                _sk = key.pop(0)
                search_key.append(_sk)
        elif type(key) == str:
            key = [key]

        search_key.append(self.orders_key)

        try:
            orders = self.get(module, search_key)
            if key in orders:
                return orders.index(key)
            else:
                if num is None:
                    num = len(orders)
                orders.insert(num,key)
                self.set(module, search_key, orders)
                retval = num
        except:
            self.set(module, search_key, [key])
            retval = 0
            pass

        return retval

    def change_order(self, module, key, num=None, is_parent_parser=False):
        self.delete_order(module, key, is_parent_parser=is_parent_parser)
        return self.insert_order(module, key, num, is_parent_parser=is_parent_parser)

    def append_order(self, module, key, is_parent_parser=False):
        return self.insert_order(module, key, num=None, is_parent_parser=is_parent_parser)

    def delete_order(self, module, key, is_parent_parser=False):
        retval = False

        search_key = []
        if type(key) == list:
            if is_parent_parser is True:
                _sk = key.pop(0)
                search_key.append(_sk)
        elif type(key) == str:
            key = [key]

        search_key.append(self.orders_key)

        try:
            orders = self.get(module, search_key)
            if key in orders:
                num = orders.index(key)
                orders.pop(num)
                self.set(module, search_key, orders)
                retval = num
        except:
            pass

        return retval

    def cdp_isset(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.isset(module,key,is_cdp=True,multiple_file=multiple_file)

        return retval

    def cdp_get(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            return ret[0]
        else:
            return ret

    def cdp_get_comment(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            return ret[1]
        else:
            return retval

    def cdp_get_pre_comment(self, module, key, force=False, multiple_file=False):
        retval = False

        ret = self.cdp_get_comment(module, key, force, multiple_file)
        if type(ret) == list:
            return ret[0]
        else:
            return retval

    def cdp_get_post_comment(self, module, key, force=False, multiple_file=False):
        retval = False

        ret = self.cdp_get_comment(module, key, force, multiple_file)
        if type(ret) == list:
            return ret[1]
        else:
            return retval

    """
    is_opt_multi: if parameter is multidefine-able, is_opt_multi should be True
    """
    def cdp_set(self, module, key, value, force=False, multiple_file=False, is_opt_multi=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            ret[0] = value
        else:
            if is_opt_multi is True:
                ret = value
            else:
                ret = [value,[[],None]]

        return self.set(module, key, ret, is_cdp=True, multiple_file=multiple_file)

    """
    is_opt_multi: if parameter is multidefine-able, is_opt_multi should be True
    """
    def cdp_add(self, module, key, value, force=False, multiple_file=False, is_opt_multi=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            ret[0] = value
        else:
            if is_opt_multi is True:
                ret = value
            else:
                ret = [value,[[],None]]

        return self.add(module, key, ret, is_cdp=True, multiple_file=multiple_file)

    def cdp_set_pre_comment(self, module, key, value, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        if type(value) == list:
            pass
        elif type(value) == str:
            value = [value]
        else:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            ret[1][0] = value
        elif type(ret) == str:
            return retval
            # not implemented.
            ret = [ret,[value,None]]
        else:
            return retval

        return self.set(module, key, ret, is_cdp=True, multiple_file=multiple_file)

    def cdp_set_post_comment(self, module, key, value, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        if type(value) == list:
            value = " ".join(value)
        elif type(value) == str:
            pass
        else:
            return retval

        ret = self.get(module, key, is_cdp=True, multiple_file=multiple_file)
        if type(ret) == list:
            ret[1][1] = value
        elif type(ret) == str:
            return retval
            # not implemented.
            ret = [ret,[[],value]]
        else:
            return retval

        return self.set(module, key, ret, is_cdp=True, multiple_file=multiple_file)

    def cdp_unset(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        return self.unset(module, key, is_cdp=True, multiple_file=multiple_file)

 
    def cdp_action(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.action(module, key, is_cdp=True, multiple_file=multiple_file)
        return retval


    def cdp_delete(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.delete(module, key, is_cdp=True, multiple_file=multiple_file)
        return retval


    def cdp_iscomment(self, module, key, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.iscomment(module, key, is_cdp=True, multiple_file=multiple_file)
        return retval


    def cdp_comment(self, module, key, recursive=False, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.comment(module, key, recursive=recursive, is_cdp=True, multiple_file=multiple_file)
        return retval


    def cdp_uncomment(self, module, key, recursive=False, force=False, multiple_file=False):
        retval = False

        isCommentDeal = False
        try:
            base_parser_name = self.ConfigArray[module]['@BASE_PARSER']['value']
            if base_parser_name == "commentDealParser" or base_parser_name == "xmlLikeConfParser":
                isCommentDeal = True
        except:
            pass

        if isCommentDeal is False and force is False:
            return retval

        retval = self.uncomment(module, key, recursive=recursive, is_cdp=True, multiple_file=multiple_file)
        return retval


"""
aop = DictOp()
aop.addconf("foo",{})
aop.set("foo",["h'oge1","hoge2","hoge3-0"],"fuga1")
aop.set("foo",["h'oge1","hoge2","hoge3-1"],"fuga2")
aop.add("foo",["h'oge1","hoge2","hoge3-2"],"fuga2")
aop.delete("foo",["h'oge1","hoge2","hoge3-2"])
aop.uncomment("foo",["h'oge1","hoge2","hoge3-2"])
aop.comment("foo",["h'oge1","hoge2","hoge3-2"])
aop.preprint_r("foo")
aop.preprint_r("foo",["h'oge1"])
print aop.query("foo",["h'oge1","hoge2"],"^oge3-[01]")
print aop.action("foo",["h'oge1","hoge2","hoge3-2"])
print aop.iscomment("foo",["h'oge1","hoge2","hoge3-2"])
print aop.isset("foo",["h'oge1","hoge2","hoge3-2"])
print aop.isset("foo",["h'oge1","hoge2","hoge3-5"])
print aop.isset("foo",["h'oge1","hoge3","hoge3-2"])
print aop.isset("foo",["h'oge1","hoge2"])
print aop.getconf("foo")
print aop.getconf("bar")
"""

########NEW FILE########
__FILENAME__ = configfile
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys

from os import environ as env
from mako.lookup import TemplateLookup
from securefile import SecureFile
from karesansui.lib.file.k2v import K2V

class ConfigFile(SecureFile):

    def do_read(self, conf_file):
        return conf_file.readlines()

    def do_write(self, conf_file, conf_content):
        conf_file.write(conf_content)


########NEW FILE########
__FILENAME__ = k2v
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re

from securefile import SecureFile

__all__ = ['K2V']

class K2V(SecureFile):
    """<comment-ja>
    key=value形式のファイルのread/writeを行うクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    def do_read(self, f):
        """<comment-ja>設定ファイルの読み込みを行います。
        @return: dict
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        for line in f.readlines():
            #line = re.sub(r'[ \t]', '', line).strip()
            line = line.strip()
            if len(line) <= 0 or line[0] == "#":
                continue
            key, value = line.split('=',1)
            if not value.rfind('#') == -1:
                value = value[:value.rfind('#')]
            self._data[key] = value.strip()
            
        return self._data

    def do_write(self, f, data):
        """<comment-ja>データを、読み込んだデータとマージ(上書き)します。
        書き込んだデータを再読みし、データを返却します。
        @param data: マージデータ
        @param data: dict
        @return: dict
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        for val in data.iteritems():
            self._data[val[0]] = val[1]
        for line in self._data.iteritems():
            f.write("%s=%s\n" % (line[0], line[1]))
            
        return self.read()

########NEW FILE########
__FILENAME__ = securefile
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import fcntl
import sys

__all__ = ["SecureFile"]

class SecureFile:
    
    _path = None
    _data = {}

    def __init__(self, path):
        """<comment-ja>pathを元に設定ファイルを読み込む
        @param path: 設定ファイルのパス
        @type path: str
        @param autoread: 自動で読み込みを行うかどうか
        @type autoread: bool 
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self._path = path

    def __lock_SH(self, f):
        """<comment-ja>
        共有ロックを取得(読み込みの時に使用)
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        fcntl.lockf(f.fileno(), fcntl.LOCK_SH)
        
    def __lock_EX(self, f):
        """<comment-ja>
        排他的ロックを取得(書き込みの時に使用)
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        fcntl.lockf(f.fileno(), fcntl.LOCK_EX)
        
    def __lock_UN(self, f):
        """<comment-ja>
        アンロック(読み込み/書き込みの時に使用) 
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        fcntl.lockf(f.fileno(), fcntl.LOCK_UN)

    def do_read(self):
        raise Exception("Please override.")

    def read(self):
        try:
            f = open(self._path, 'r')
            try:
                self.__lock_SH(f)
                try:
                    return self.do_read(f)
                finally:
                    self.__lock_UN(f)
            finally:
                f.close()
        except Exception, e:
            print >>sys.stdout, '"%s" : Error reading config file. %s' % (self._path, e.args)
            raise

    def do_write(self, data):
        raise Exception("Please override.")

    def write(self, data):
        try:
            f = open(self._path, "w")
            try:
                self.__lock_EX(f)
                try:
                    return self.do_write(f, data)
                finally:
                    self.__lock_UN(f)
            finally:
                f.close()
                    
        except Exception, e:
            print >>sys.stdout, '"%s" : Error writing config file. %s' % (self._path, e.args)
            raise
        
if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = iptables
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""<description>
<comment-ja>
ファイアウォールの設定や稼働状況を制御するクラスを定義する
</comment-ja>
<comment-en>
Define the class to control packet filtering.
</comment-en>

@file:  iptables.py
@author: Taizo ITO <taizo@karesansui-project.info>
@copyright:     
"""

import time
import os, stat
import re
import errno
import pprint
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui
from karesansui.lib.const import FIREWALL_XML_FILE, \
     FIREWALL_USERCHAIN, RH_USERCHAIN, KARESANSUI_GROUP
from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_xml_parse as XMLParse, get_nums_xml_xpath as XMLXpathNum, \
     execute_command, r_chgrp, is_readable
    
from karesansui.lib.networkaddress import NetworkAddress
from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection

class KaresansuiIpTablesException(karesansui.KaresansuiLibException):
    pass

class IptablesXMLGenerator:

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self,config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree.toxml('UTF-8'))
        return out.getvalue()

class KaresansuiIpTables(IptablesXMLGenerator):

    def __init__(self):
        self.iptables_conf_file = "/etc/sysconfig/iptables"
        self.firewall_xml_file = FIREWALL_XML_FILE

        self._lsmod = "/sbin/lsmod"
        self._iptables = "/sbin/iptables"
        self._iptables_save = "/sbin/iptables-save"
        self._iptables_init = "/etc/init.d/iptables"

        self.basic_targets = {
               'filter':['ACCEPT','DROP','REJECT'],
               'nat':['ACCEPT','DROP','REJECT','MASQUERADE','REDIRECT','DNAT'],
               'mangle':['ACCEPT','DROP','REJECT'],
              }

        self.basic_chains = {
               'filter':['INPUT','OUTPUT','FORWARD'],
               'nat':['PREROUTING','OUTPUT','POSTROUTING'],
               'mangle':['PREROUTING','INPUT','OUTPUT','FORWARD','POSTROUTING'],
              }

        self.chain_protos = ['tcp','udp','icmp','esp','ah','sctp']

        self.ipt_original_opts = {
                   "append|A": 1,
                   "delete|D": 1,
                   "insert|I": 1,
                   "replace|R": 1,
                   "list|L":0,
                   "flush|F":0,
                   "zero|Z":0,
                   "new-chain|N":1,
                   "delete-chain|X":1,
                   "rename-chain|E":1,
                   "policy|P":1,
                   "source|src|s":1,
                   "destination|dst|d":1,
                   "protocol|p":1,
                   "in-interface|i":1,
                   "jump|j":1,
                   "table|t":1,
                   "match|m":1,
                   "numeric|n":0,
                   "out-interface|o":1,
                   "verbose|v":0,
                   "exact|x":0,
                   "fragments|f":0,
                   "version|V":0,
                   "help|h":0,
                   "line-numbers|0":0,
                   "modprobe|M":0,
                   "set-counters|c":1,
                   "goto|g":1,
              }

        self.ipt_udp_opts = {
             "source-port":1,
             "sport":1,
             "destination-port":1,
             "dport":1,
        }

        self.ipt_tcp_opts = {
             "source-port":1,
             "sport":1,
             "destination-port":1,
             "dport":1,
             "syn":0,
             "tcp-flags":1,
             "tcp-option":1,
        }


        self.ipt_ext_opts = {
             "state":1, # --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED]
             "reject-with":1,
             "mss":1,   # --mss value[:value]
        }

        self.params = {
           "target"     :"target",
           "protocol"   :"protocol",
           "source"     :"source",
           "destination":"destination",
           "sport"      :"source-port",
           "dport"      :"destination-port",
           "inif"       :"in-interface",
           "outif"      :"out-interface",
           "option"     :"option",
        }
        return None

    def firewall_xml__to__iptables_config(self):
        self.firewall_xml = self.read_firewall_xml()
        self.set_default()
        self.write_iptables_config()

    def firewall_xml__from__iptables_config(self):
        self.firewall_xml = self.read_iptables_config()
        self.set_default()
        self.write_firewall_xml()

    def read_iptables_config(self):
        config = {}

        res = []
        if is_readable(self.iptables_conf_file):
            res = ConfigFile(self.iptables_conf_file).read()
            ret = 0
        if len(res) == 0:
            cmd = []
            cmd.append(self._iptables_save)
            (ret,res) = execute_command(cmd)

        table_regex = re.compile(r"""^\*(?P<table>[a-z]+)""")
        policy_regex = re.compile(r"""^:(?P<chain>\S+) (?P<target>\S+)""")
        rule_regex = re.compile(r"""^\-A (?P<rule>\S+)""")
        end_regex = re.compile(r"""^COMMIT$""")

        if ret == 0 and len(res) > 0:
            for aline in res:
                aline = aline.rstrip()
                aline = aline.replace(RH_USERCHAIN,FIREWALL_USERCHAIN)

                m = end_regex.match(aline)
                if m is not None:

                    for chain, policy in policies.iteritems():
                        rule = self._make_rule_arr(rules[chain])
                        info = {"policy": policies[chain], "rule": rule}
                        table_info[chain] = info

                    config[table] = table_info
                    continue

                m = table_regex.match(aline)
                if m is not None:
                    table = m.group("table")
                    table_info = {}
                    policies = {}
                    rules = {}
                else:
                    m = policy_regex.match(aline)
                    if m is not None:
                        chain = m.group("chain")
                        target = m.group("target")
                        policies[chain] = target
                        rules[chain] = []
                    else:
                        m = rule_regex.match(aline)
                        if m is not None:
                            rule_chain = m.group("rule")
                            rules[rule_chain].append(aline)

        #pp = pprint.PrettyPrinter(indent=4)
        #pp.pprint(config)
        return config

    def write_iptables_config(self):
        try:
            self.set_libvirt_rules()
            self.write_firewall_xml()
            ConfigFile(self.iptables_conf_file).write("\n".join(self.make_save_lines()) + "\n")
        except:
            raise KaresansuiIpTablesException("Error: Cannot write iptables configuration file.")

    def _make_rule_arr(self,rules):
        arr = []
        for aline in rules:
            arr.append(self._rule_str_to_arr(aline))
        return arr

    def _rule_str_to_arr(self,string,rule_id=None):
        #print string
        m_re = re.compile(r"""(^| )-{1,2}(?P<opt>\S+) ?(?P<value>(\! )?\S+)?""", flags=0)
        for k,v in self.params.iteritems():
            exec("%s = ''" % (k,))

        for itr in m_re.finditer(string):
            opt = itr.group('opt')
            value = itr.group('value')
            if opt == 'A' or opt == 'append':
                continue
            elif opt == 'j' or opt == 'jump':
                target = value
            elif opt == 'p' or opt == 'protocol':
                protocol = value
            elif opt == 's' or opt == 'src' or opt == 'source':
                source = value
            elif opt == 'd' or opt == 'dst' or opt == 'destination':
                destination = value
            elif opt == 'sport' or opt == 'source-port':
                sport = value
            elif opt == 'dport' or opt == 'destination-port':
                dport = value
            elif opt == 'i' or opt == 'in-interface':
                inif = value
            elif opt == 'o' or opt == 'out-interface':
                outif = value
            else:
                if len(opt) == 1:
                    opt = "-%s" % opt
                else:
                    opt = "--%s" % opt
                if option is None:
                    option = ""
                option = "%s %s %s" % (option, opt, value,)

        rule_info = {"id": rule_id,
                     "target": target,
                     "protocol": protocol,
                     "source": source,
                     "destination": destination,
                     "source-port": sport,
                     "destination-port": dport,
                     "in-interface": inif,
                     "out-interface": outif,
                     "option": option,
                    }

        return rule_info


    def read_firewall_xml(self,path=None):

        config = {}

        if path is None:
            path = self.firewall_xml_file

        if not os.path.exists(path) or os.path.getsize(path) == 0:
            raise KaresansuiIpTablesException("no such file: %s" % path)

        document = XMLParse(path)
        
        table_num = XMLXpathNum(document,'/firewall/table')
        for tbl in range(1, table_num + 1):
            table_name = XMLXpath(document,'/firewall/table[%i]/@name' % (tbl,))
            if table_name is None:
                table_name = 'filter'

            chain = {}
            chain_num = XMLXpathNum(document,'/firewall/table[%i]/chain' % (tbl,))
            for chn in range(1, chain_num + 1):
                chain_name = XMLXpath(document,'/firewall/table[%i]/chain[%i]/@name' % (tbl,chn,))
                chain_policy = XMLXpath(document,'/firewall/table[%i]/chain[%i]/@policy' % (tbl,chn,))

                rule = []
                rule_num = XMLXpathNum(document,'/firewall/table[%i]/chain[%i]/rule' % (tbl,chn,))
                for rl in range(1, rule_num + 1):
                    rule_id = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/@id' % (tbl,chn,rl,))

                    target = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/target/text()' % (tbl,chn,rl,))
                    if target is None:
                        target = ''
                    else:
                        target = target.strip()

                    protocol = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/protocol/text()' % (tbl,chn,rl,))
                    if protocol is None:
                        protocol = ''
                    else:
                        protocol = protocol.strip()
                        if protocol == "50":
                            protocol = "esp"
                        if protocol == "51":
                            protocol = "ah"

                    source = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/source/text()' % (tbl,chn,rl,))
                    if source is None:
                        source = ''
                    else:
                        source = source.strip()

                    destination = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/destination/text()' % (tbl,chn,rl,))
                    if destination is None:
                        destination = ''
                    else:
                        destination = destination.strip()

                    sport = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/source-port/text()' % (tbl,chn,rl,))
                    if sport is None:
                        sport = ''
                    else:
                        sport = sport.strip()

                    dport = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/destination-port/text()' % (tbl,chn,rl,))
                    if dport is None:
                        dport = ''
                    else:
                        dport = dport.strip()

                    inif = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/in-interface/text()' % (tbl,chn,rl,))
                    if inif is None:
                        inif = ''
                    else:
                        inif = inif.strip()

                    outif = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/out-interface/text()' % (tbl,chn,rl,))
                    if outif is None:
                        outif = ''
                    else:
                        outif = outif.strip()

                    option = XMLXpath(document,'/firewall/table[%i]/chain[%i]/rule[%i]/option/text()' % (tbl,chn,rl,))
                    if option is None:
                        option = ''
                    else:
                        option = option.strip()

                    rule_info = {"id": rule_id,
                        "target": target,
                        "protocol": protocol,
                        "source": source,
                        "destination": destination,
                        "source-port": sport,
                        "destination-port": dport,
                        "in-interface": inif,
                        "out-interface": outif,
                        "option": option,
                       }

                    rule.append(rule_info)

                chain_info = {"policy": chain_policy,
                        "rule": rule,
                       }
                chain[chain_name] = chain_info

            config[table_name] = chain

        return config

    def generate_xml_tree(self, config):
        self.firewall_xml = config

        self.begin_build()
        for tbl,val in self.firewall_xml.iteritems():
            self.build_table(tbl)
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.firewall = self.document.createElement("firewall")

        self.firewall.setAttribute("type", "iptables")
        self.firewall.appendChild(self._create_text_node("last_modified", "%s" % time.ctime()))
        self.document.appendChild(self.firewall)

    def build_table(self,name):
        doc = self.document
        table = doc.createElement("table")
        table.setAttribute("name", name)

        chains = self.firewall_xml[name]
        for chain_name,val in chains.iteritems():
            chain_n = doc.createElement("chain")
            chain_n.setAttribute("name", chain_name)
            try:
                if val['policy'] is not None:
                    chain_n.setAttribute("policy", val['policy'])
            except:
                pass

            cnt = 1
            for rule in val["rule"]:
                rule_n = doc.createElement("rule")
                rule_n.setAttribute("id", str(cnt))

                if rule["target"] is not None:
                    target = self._create_text_node("target", rule["target"])
                    rule_n.appendChild(target)

                try:
                    if rule["protocol"] is not None and rule["protocol"] != "":
                        protocol = self._create_text_node("protocol", rule["protocol"])
                        rule_n.appendChild(protocol)
                except:
                    pass

                try:
                    if rule["source"] is not None and rule["source"] != "" :
                        source = self._create_text_node("source", rule["source"])
                        rule_n.appendChild(source)
                except:
                    pass

                try:
                    if rule["destination"] is not None and rule["destination"] != "":
                        destination = self._create_text_node("destination", rule["destination"])
                        rule_n.appendChild(destination)
                except:
                    pass

                try:
                    if rule["source-port"] is not None and rule["source-port"] != "":
                        sport = self._create_text_node("source-port", rule["source-port"])
                        rule_n.appendChild(sport)
                except:
                    pass

                try:
                    if rule["destination-port"] is not None and rule["destination-port"] != "":
                        dport = self._create_text_node("destination-port", rule["destination-port"])
                        rule_n.appendChild(dport)
                except:
                    pass

                try:
                    if rule["in-interface"] is not None and rule["in-interface"] != "":
                        inif = self._create_text_node("in-interface", rule["in-interface"])
                        rule_n.appendChild(inif)
                except:
                    pass

                try:
                    if rule["out-interface"] is not None and rule["out-interface"] != "":
                        outif = self._create_text_node("out-interface", rule["out-interface"])
                        rule_n.appendChild(outif)
                except:
                    pass

                try:
                    if rule["option"] is not None and rule["option"] != "":
                        option = self._create_text_node("option", rule["option"])
                        rule_n.appendChild(option)
                except:
                    pass

                chain_n.appendChild(rule_n)
                cnt = cnt + 1
 
            table.appendChild(chain_n)

        self.firewall.appendChild(table)


    def end_build(self):
        pass

    def write_firewall_xml(self,path=None):
        if path is None:
            path = self.firewall_xml_file
        try:
            pathdir = os.path.dirname(path)
            os.makedirs(pathdir)
        except OSError, (err, msg):
            if err != errno.EEXIST:
                raise OSError(err,msg)

        #print self.generate(self.firewall_xml)
        ConfigFile(path).write(self.generate(self.firewall_xml))
        if os.getuid() == 0 and os.path.exists(path):
            r_chgrp(path,KARESANSUI_GROUP)
            os.chmod(path,0664)

    def make_save_lines(self):
        lines = []
        lines.append("# Generated by karesansui on %s" % (time.ctime(),))
        for tbl,tbl_val in self.firewall_xml.iteritems():
            lines.append("*%s" % (tbl,))

            # policy
            for chn,chn_val in tbl_val.iteritems():
                try:
                    policy = chn_val['policy']
                except:
                    policy = '-'
                if policy is None:
                    policy = '-'
                lines.append(":%s %s" % (chn,policy,))

            # rule
            for chn,chn_val in tbl_val.iteritems():
                try:
                    rules = chn_val['rule']
                except:
                    continue

                for rule in rules:
                    rule_s = []
                    try:
                        target = rule["target"]
                    except:
                        target = 'ACCEPT'

                    try:
                        protocol = rule["protocol"]
                    except:
                        protocol = None
                    if protocol is not None and protocol.strip() != "":
                        rule_s.append("--protocol %s" % protocol)

                    try:
                        option = rule["option"]
                    except:
                        option = None

                    loption = ""
                    if option is not None:
                        extopt_regex = re.compile(r"((--reject-with) *(\S+))")
                        for m in extopt_regex.finditer(option):
                            loption = "%s %s" % (loption, m.group(1),)

                        option = extopt_regex.sub('',option,0)
                        rule_s.append(option)

                    try:
                        source = rule["source"]
                    except:
                        source = None
                    if source is not None and source.strip() != "":
                        rule_s.append("--source %s" % source)

                    try:
                        destination = rule["destination"]
                    except:
                        destination = None
                    if destination is not None and destination.strip() != "":
                        rule_s.append("--destination %s" % destination)

                    try:
                        sport = rule["source-port"]
                    except:
                        sport = None
                    if sport is not None and sport.strip() != "":
                        rule_s.append("--source-port %s" % sport)

                    try:
                        dport = rule["destination-port"]
                    except:
                        dport = None
                    if dport is not None and dport.strip() != "":
                        rule_s.append("--destination-port %s" % dport)

                    try:
                        inif = rule["in-interface"]
                    except:
                        inif = None
                    if inif is not None and inif.strip() != "":
                        rule_s.append("--in-interface %s" % inif)

                    try:
                        outif = rule["out-interface"]
                    except:
                        outif = None
                    if outif is not None and outif.strip() != "":
                        rule_s.append("--out-interface %s" % outif)

                    rule_s.append("--jump %s" % target)

                    if loption is not "":
                        rule_s.append(loption)

                    lines.append("-A %s %s" % (chn, " ".join(rule_s)))

            lines.append("COMMIT")
        lines.append("# Completed on %s" % (time.ctime(),))
        return lines

    def set_default(self):

        try:
            self.firewall_xml['filter']
        except:
            self.firewall_xml['filter'] = {}

        try:
            self.firewall_xml['filter'][FIREWALL_USERCHAIN]
        except:
            self.firewall_xml['filter'][FIREWALL_USERCHAIN] = {}

        try:
            self.firewall_xml['filter'][FIREWALL_USERCHAIN]['rule']
        except:
            self.firewall_xml['filter'][FIREWALL_USERCHAIN] = {}
            rules = []

            rules.append({
                          'target':'ACCEPT',
                          'in-interface':'lo',
                        })
            """
            rules.append({
                          'target':'ACCEPT',
                          'protocol':'icmp',
                          'option':'-m icmp --icmp-type any',
                        })
            rules.append({
                          'target':'ACCEPT',
                          'protocol':'esp',
                        })
            rules.append({
                          'target':'ACCEPT',
                          'protocol':'ah',
                        })
            rules.append({
                          'target':'ACCEPT',
                          'option':'-m state --state RELATED,ESTABLISHED',
                        })
            rules.append({
                          'target':'REJECT',
                          'option':'--reject-with icmp-host-prohibited',
                        })
            """
            chain_info = {'rule':rules}
            self.firewall_xml['filter'][FIREWALL_USERCHAIN] = chain_info

        try:
            self.firewall_xml['filter']['INPUT']['rule']
        except:
            try:
                policy = self.firewall_xml['filter']['INPUT']['policy']
            except:
                policy = 'ACCEPT'
            self.firewall_xml['filter']['INPUT'] = {}
            rules = []
            rules.append({'target':FIREWALL_USERCHAIN,
                        })
            chain_info = {'policy':policy,'rule':rules}
            self.firewall_xml['filter']['INPUT'] = chain_info

        try:
            self.firewall_xml['filter']['FORWARD']['rule']
        except:
            try:
                policy = self.firewall_xml['filter']['FORWARD']['policy']
            except:
                policy = 'ACCEPT'
            self.firewall_xml['filter']['FORWARD'] = {}
            rules = []
            rules.append({'target':FIREWALL_USERCHAIN,
                        })
            chain_info = {'policy':policy,'rule':rules}
            self.firewall_xml['filter']['FORWARD'] = chain_info

        try:
            self.firewall_xml['filter']['OUTPUT']['rule']
        except:
            try:
                policy = self.firewall_xml['filter']['OUTPUT']['policy']
            except:
                policy = 'ACCEPT'
            self.firewall_xml['filter']['OUTPUT'] = {}
            rules = []
            chain_info = {'policy':policy,'rule':rules}
            self.firewall_xml['filter']['OUTPUT'] = chain_info

    def _modify_policy(self,table,chain,policy):
        if policy is None:
            self.firewall_xml[table][chain]['policy'] = None 
        elif policy != "":
            self.firewall_xml[table][chain]['policy'] = policy

    def _get_rules(self,table,chain):
        try:
            new_rules = []
            cnt = 1
            for rule in self.firewall_xml[table][chain]['rule']:

                for k,v in self.params.iteritems():
                    try: 
                        exec("%s = rule['%s']" % (k,v,))
                    except KeyError:
                        exec("%s = ''" % (k,))

                rule_info = {"id": cnt,
                        "target": target,
                        "protocol": protocol,
                        "source": source,
                        "destination": destination,
                        "source-port": sport,
                        "destination-port": dport,
                        "in-interface": inif,
                        "out-interface": outif,
                        "option": option,
                       }
                cnt = cnt + 1
                new_rules.append(rule_info)
            return new_rules
        except:
            return []

    def _search_rule(self,table,chain,conditions):

        ret = []
        try:
            rules = self.firewall_xml[table][chain]['rule']
            cnt = 1
            for rule in rules:

                match=True
                for k,v in conditions.iteritems():
                    try:
                        if rule[k] != v:
                            match=False
                    except:
                        match=False

                if match is True:
                    ret.append(cnt)
                cnt = cnt + 1
        except KeyError:
            return ret

        return ret

    def _add_rule(self,table,chain,rule_info):

        try:
            self.firewall_xml[table][chain]['rule']
        except KeyError:
            try:
                self.firewall_xml[table][chain]
            except KeyError:
                try:
                    self.firewall_xml[table]
                except KeyError:
                    self.firewall_xml[table] = {}
                self.firewall_xml[table][chain] = {}
            self.firewall_xml[table][chain]['rule'] = []

        rules = self.firewall_xml[table][chain]['rule']

        for k,v in self.params.iteritems():
            try: 
                exec("%s = rule_info['%s']" % (k,v,))
            except KeyError:
                exec("%s = ''" % (k,))

        if not target in self.basic_targets[table]:
            raise KaresansuiIpTablesException("no such target: %s" % target)

        n_rule_info = {"target": target,
                       "protocol": protocol,
                       "source": source,
                       "destination": destination,
                       "source-port": sport,
                       "destination-port": dport,
                       "in-interface": inif,
                       "out-interface": outif,
                       "option": option,
                      }

        rules.append(n_rule_info)
        self.firewall_xml[table][chain]['rule'] = rules
        return len(rules)

    def _delete_rule(self,table,chain,id):
        ret = []
        rules = self.firewall_xml[table][chain]['rule']
        new_rules = []
        cnt = 1
        for rule in rules:
            if id == cnt:
                ret = rule
            else:
                new_rules.append(rule)
            cnt = cnt + 1

        self.firewall_xml[table][chain]['rule'] = new_rules
        return ret

    def _modify_rule(self,table,chain,id,rule_info):
        rules = self.firewall_xml[table][chain]['rule']

        for k,v in self.params.iteritems():
            try: 
                exec("%s = rule_info['%s']" % (k,v,))
            except KeyError:
                exec("%s = ''" % (k,))

        if not target in self.basic_targets[table]:
            raise KaresansuiIpTablesException("no such target: %s" % target)

        n_rule_info = {"target": target,
                       "protocol": protocol,
                       "source": source,
                       "destination": destination,
                       "source-port": sport,
                       "destination-port": dport,
                       "in-interface": inif,
                       "out-interface": outif,
                       "option": option,
                      }

        new_rules = []
        cnt = 1
        for rule in rules:
            if id == cnt:
                rule = n_rule_info
            new_rules.append(rule)
            cnt = cnt + 1

        self.firewall_xml[table][chain]['rule'] = new_rules
        return id

    def _insert_rule(self,table,chain,id,rule_info):

        try:
            self.firewall_xml[table][chain]['rule']
        except KeyError:
            try:
                self.firewall_xml[table][chain]
            except KeyError:
                try:
                    self.firewall_xml[table]
                except KeyError:
                    self.firewall_xml[table] = {}
                self.firewall_xml[table][chain] = {}
            self.firewall_xml[table][chain]['rule'] = []

        rules = self.firewall_xml[table][chain]['rule']

        for k,v in self.params.iteritems():
            try: 
                exec("%s = rule_info['%s']" % (k,v,))
            except KeyError:
                exec("%s = ''" % (k,))

        if not target in self.basic_targets[table]:
            raise KaresansuiIpTablesException("no such target: %s" % target)

        n_rule_info = {"target": target,
                       "protocol": protocol,
                       "source": source,
                       "destination": destination,
                       "source-port": sport,
                       "destination-port": dport,
                       "in-interface": inif,
                       "out-interface": outif,
                       "option": option,
                      }

        new_rules = []
        cnt = 1
        for rule in rules:
            if id == cnt:
                new_rules.append(n_rule_info)
            new_rules.append(rule)
            cnt = cnt + 1
        if len(rules) == 0:
            new_rules.append(n_rule_info)

        if len(rules) == len(new_rules):
            new_rules.append(n_rule_info)
            id = len(new_rules)

        self.firewall_xml[table][chain]['rule'] = new_rules
        return id

    def modify_policy(self,chain,policy=None):
        self._modify_policy('filter',chain,policy)

    def get_rules(self):
        return self._get_rules('filter',FIREWALL_USERCHAIN)

    def add_rule(self,rule_info):
        return self._add_rule('filter',FIREWALL_USERCHAIN,rule_info)

    def delete_rule(self,id):
        return self._delete_rule('filter',FIREWALL_USERCHAIN,id)

    def modify_rule(self,id,rule_info):
        return self._modify_rule('filter',FIREWALL_USERCHAIN,id,rule_info)

    def insert_rule(self,id,rule_info):
        return self._insert_rule('filter',FIREWALL_USERCHAIN,id,rule_info)

    def is_configured(self):
        if os.path.exists(self.firewall_xml_file):
            ctime2 = time.ctime(os.stat(self.firewall_xml_file).st_mtime)
        else:
            return True

        if os.path.exists(self.iptables_conf_file):
            ctime1 = time.ctime(os.stat(self.iptables_conf_file).st_mtime)
            if ctime1 < ctime2:
                return False
            else:
                return True
        else:
            return False

    def set_libvirt_rules(self):

        kvc = KaresansuiVirtConnection()
        try:
            for name in kvc.list_active_network():
                try:
                    network = kvc.search_kvn_networks(name)[0]

                    info = network.get_info()
                    bridge = info['bridge']['name']
                    ipaddr = info['ip']['address']
                    netmask = info['ip']['netmask']
                    netaddr = NetworkAddress("%s/%s" % (ipaddr,netmask)).get('network')

                    # nat mode
                    if info['forward']['mode'] == 'nat':

                        # rule 1
                        # -A POSTROUTING -s 192.168.122.0/255.255.255.0 -d ! 192.168.122.0/255.255.255.0 -j MASQUERADE 
                        conditions = {'target':'MASQUERADE',
                                      'source':"%s/%s" % (netaddr,netmask),
                                      'destination':"! %s/%s" % (netaddr,netmask),
                                     }
                        ids = self._search_rule('nat','POSTROUTING',conditions)
                        if len(ids) == 0:
                            id = self._insert_rule('nat','POSTROUTING',1,conditions)

                        # rule 2
                        # -A FORWARD -d 192.168.122.0/255.255.255.0 -o virbr0 -m state --state RELATED,ESTABLISHED -j ACCEPT 
                        conditions = {'target':'ACCEPT',
                                      'destination':"%s/%s" % (netaddr,netmask),
                                      'out-interface':bridge,
                                     }
                        ids = self._search_rule('filter','FORWARD',conditions)
                        if len(ids) == 0:
                            conditions['option'] = '-m state --state RELATED,ESTABLISHED'
                            id = self._insert_rule('filter','FORWARD',1,conditions)

                        # rule 3
                        # -A FORWARD -s 192.168.122.0/255.255.255.0 -i virbr0 -j ACCEPT 
                        conditions = {'target':'ACCEPT',
                                      'source':"%s/%s" % (netaddr,netmask),
                                      'in-interface':bridge,
                                     }
                        ids = self._search_rule('filter','FORWARD',conditions)
                        if len(ids) == 0:
                            id = self._insert_rule('filter','FORWARD',1,conditions)

                    # rule 4
                    # -A INPUT -i virbr0 -p udp -m udp --dport 53 -j ACCEPT 
                    # -A INPUT -i virbr0 -p tcp -m tcp --dport 53 -j ACCEPT 
                    # -A INPUT -i virbr0 -p udp -m udp --dport 67 -j ACCEPT 
                    # -A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT 
                    default_port = {'53':['udp','tcp'],
                                    '67':['udp','tcp'],
                                    }
                    for port,v in default_port.iteritems():
                        for protocol in v:

                            conditions = {'target':'ACCEPT',
                                          'protocol':protocol,
                                          'destination-port':port,
                                          'in-interface':bridge,
                                         }
                            ids = self._search_rule('filter','INPUT',conditions)
                            if len(ids) == 0:
                                conditions['option'] = "-m %s" % protocol
                                id = self._insert_rule('filter','INPUT',1,conditions)

                except KaresansuiVirtException, e:
                    pass
        finally:
            kvc.close()

        return True

    def is_running(self):
        return self.status()

    def start(self):
        cmd = []
        cmd.append(self._iptables_init)
        cmd.append('start')
        (ret,res) = execute_command(cmd)
        return ret

    def stop(self):
        cmd = []
        cmd.append(self._iptables_init)
        cmd.append('stop')
        (ret,res) = execute_command(cmd)
        return ret

    def restart(self):
        cmd = []
        cmd.append(self._iptables_init)
        cmd.append('restart')
        (ret,res) = execute_command(cmd)
        return ret

    def condrestart(self):
        ret = 0
        if self.status() is True:
            cmd = []
            cmd.append(self._iptables_init)
            cmd.append('restart')
            (ret,res) = execute_command(cmd)
        return ret

    def status(self):

        kmod_regex = re.compile(r"""^(ip_tables|iptable_filter|iptable_nat)[ \t]""")
        cmd = []
        cmd.append(self._lsmod)
        (ret,res) = execute_command(cmd)
        if len(res) > 0:
            for aline in res:
                m = kmod_regex.match(aline)
                if m:
                    return True
        return False

"""
pp = pprint.PrettyPrinter(indent=4)
kit = KaresansuiIpTables()
pp.pprint(kit.firewall_xml)
#pp.pprint(kit.firewall_xml)
#pp.pprint(kit.read_iptables_config())
config = kit.firewall_xml
#print kit.generate(config)
#pp.pprint(kit.make_save_lines())
print "\n".join(kit.make_save_lines())

pp = pprint.PrettyPrinter(indent=4)
kit = KaresansuiIpTables()
kit.set_libvirt_rules()
"""

########NEW FILE########
__FILENAME__ = form
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from web.form import *

class Label(Input):
    """<comment-ja>
    webpy#formの拡張Labelクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    def render(self, shownote=True):
        x = '<label for="_%s" ' % net.websafe(self.name)
        x += self.addatts()
        x += ' >'   
        if self.value: x += net.websafe(self.value)
        x += '</label>'
        if shownote:
            x += self.rendernote(self.note)
        return x

class CButton(Button):
    """<comment-ja>
    webpy#formの拡張Buttonクラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    def __init__(self, name, *validators, **attrs):
        super(Button, self).__init__(name, *validators, **attrs)
        self.description = ""
              
    def render(self):
        safename = net.websafe(self.name)
        safevalue = net.websafe(self.value)
        x = '<button name="%s"%s>%s</button>' % (safename, self.addatts(), safevalue)
        x += self.rendernote(self.note)
        return x

########NEW FILE########
__FILENAME__ = iptables
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import types
import time
import glob

import karesansui
from karesansui.lib.utils import preprint_r, r_chmod, r_chown, r_chgrp
from karesansui.lib.const import KARESANSUI_PREFIX, KARESANSUI_DATA_DIR, \
                                 KARESANSUI_USER, KARESANSUI_GROUP

CONF_TMP_DIR = "%s/tmp/.conf" % (KARESANSUI_DATA_DIR,)

def iptables_lint_contents(contents, webobj=None, machine=None):
    from karesansui.lib.file.configfile import ConfigFile
    
    if not os.path.exists(CONF_TMP_DIR):
        os.makedirs(CONF_TMP_DIR)
        r_chmod(CONF_TMP_DIR,0770)
        r_chown(CONF_TMP_DIR,KARESANSUI_USER)
        r_chgrp(CONF_TMP_DIR,KARESANSUI_GROUP)

    seconds = 10 * 60
    for _old in glob.glob("%s/iptables-save.*" % (CONF_TMP_DIR,)):
        mtime = os.stat(_old).st_mtime
        if int(time.time()) > (mtime + seconds):
            os.unlink(_old)

    serial = time.strftime("%Y%m%d%H%M%S",time.localtime())
    filename = "%s/iptables-save.%s" % (CONF_TMP_DIR,serial,)

    ConfigFile(filename).write(contents)
    r_chmod(filename,0660)
    r_chown(filename,KARESANSUI_USER)
    r_chgrp(filename,KARESANSUI_GROUP)

    return iptables_lint(filename, webobj, machine, delete=True)

def iptables_lint(filepath, webobj=None, machine=None, delete=False):
    from karesansui.lib.const import IPTABLES_COMMAND_CONTROL

    options = {"config" : filepath, "lint" : None}

    cmd_name = u"Check iptables settings - %s" % filepath

    if type(webobj) == types.InstanceType:
        from karesansui.db.model._2pysilhouette import Job, JobGroup, \
                                                       JOBGROUP_TYPE
        from karesansui.db.access._2pysilhouette import jg_findby1, jg_save,corp
        from karesansui.db.access._2pysilhouette import save_job_collaboration
        from karesansui.db.access.machine2jobgroup import new as m2j_new
        from pysilhouette.command import dict2command

        _cmd = dict2command(
            "%s/%s" % (karesansui.config['application.bin.dir'],
                       IPTABLES_COMMAND_CONTROL), options)

        jobgroup = JobGroup(cmd_name, karesansui.sheconf['env.uniqkey'])
        jobgroup.jobs.append(Job('%s command' % cmd_name, 0, _cmd))
        jobgroup.type = JOBGROUP_TYPE['PARALLEL']

        _machine2jobgroup = m2j_new(machine=machine,
                                jobgroup_id=-1,
                                uniq_key=karesansui.sheconf['env.uniqkey'],
                                created_user=webobj.me,
                                modified_user=webobj.me,
                                )

        if corp(webobj.orm, webobj.pysilhouette.orm,_machine2jobgroup, jobgroup) is False:
            webobj.logger.debug("%s command failed. Return to timeout" % (cmd_name))
            if delete is True and os.path.exists(filepath):
                os.unlink(filepath)
            return False

        cmd_res = jobgroup.jobs[0].action_stdout

    else:
        from karesansui.lib.const import KARESANSUI_PREFIX
        from karesansui.lib.utils import execute_command

        opts_str = ""
        for x in options.keys():
            if options[x] is None:
                opts_str += "--%s " % x 
            else:
                opts_str += "--%s=%s " % (x, options[x])

        _cmd = "%s/bin/%s %s" % (KARESANSUI_PREFIX, IPTABLES_COMMAND_CONTROL, opts_str.strip(),)

        command_args = _cmd.strip().split(" ")
        (rc,res) = execute_command(command_args)
        if rc != 0:
            if delete is True and os.path.exists(filepath):
                os.unlink(filepath)
            return False

        cmd_res = "\n".join(res)


    if delete is True and os.path.exists(filepath):
        os.unlink(filepath)

    return cmd_res


########NEW FILE########
__FILENAME__ = iscsi
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
from karesansui.lib.parser.iscsid import iscsidParser
from karesansui.lib.dict_op import DictOp
from karesansui.lib.const import ISCSI_DEFAULT_NODE_CONFIG_DIR, ISCSI_CONFIG_KEY_AUTH_METHOD, ISCSI_CONFIG_KEY_AUTH_USER, \
    ISCSI_CONFIG_KEY_SATRTUP, ISCSI_CONFIG_VALUE_SATRTUP_OFF

MODULE = "iscsi"

def _get_iscsi_config(node):
    path = iscsi_get_config_path_node(node)
    parser = iscsidParser()
    dop = DictOp()

    dop.addconf(MODULE, parser.read_conf(path))
    return dop

def iscsi_get_config_path_node(node):
    path = iscsi_get_config_path(
        node['hostname'],
        node['iqn'],
        node['port'],
        node['tpgt']
        )
    return path

def iscsi_get_config_path(hostname, iqn, port, tpgt):
    """
    <comment-ja>
    ノード別の設定ファイルパスを取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    path = ISCSI_DEFAULT_NODE_CONFIG_DIR + '/' + iqn + '/' + hostname + ',' + port + ',' + tpgt + '/default'

    return path

def iscsi_parse_node(line):
    """
    <comment-ja>
    iscsiadm -m node コマンドの情報をパースする
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    host,iqn = line.split(' ', 2)
    host,tpgt = host.split(',', 2)
    host,port = host.split(':', 2)
    node = {
        'hostname' : host,
        'port' : port,
        'tpgt' : tpgt,
        'iqn'  : iqn,
        }

    return node

def iscsi_parse_session(session):
    """
    <comment-ja>
    iscsiadm -m session コマンドの情報をパースする
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    protocol,id,host,iqn = session.split(' ', 4)
    protocol = protocol.replace(':','')
    id = re.search(r'\d+', id).group()
    host,tpgt = host.split(',', 2)
    host,port = host.split(':', 2)
    session = {
        'protocol' : protocol,
        'id'       : id,
        'hostname' : host,
        'tpgt'     : tpgt,
        'port'     : port,
        'iqn'      : iqn,
        }

    return session

def iscsi_print_format_node(node):
    return "%s %s %s %s" % (node['hostname'], node['port'], node['tpgt'], node['iqn'])

def iscsi_get_auth_type(node):
    """
    <comment-ja>
    ノードの認証タイプを取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    dop = _get_iscsi_config(node)
    return dop.cdp_get(MODULE, ISCSI_CONFIG_KEY_AUTH_METHOD)

def iscsi_get_auth_user(node):
    """
    <comment-ja>
    ノードの認証のユーザ名を取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    dop = _get_iscsi_config(node)
    user = dop.cdp_get(MODULE, ISCSI_CONFIG_KEY_AUTH_USER)
    if not user:
        user = ""

    return user

def iscsi_check_node_status(node, session):
    """
    <comment-ja>
    ノードが現在アクティブかどうか調べる
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if node['hostname'] == session['hostname'] and node['iqn'] == session['iqn']:
        is_active = True
    else:
        is_active = False

    return is_active

def iscsi_check_node_autostart(node):
    """
    <comment-ja>
    ノードの自動起動が有効かどうか調べる
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    dop = _get_iscsi_config(node)

    if dop.cdp_get(MODULE, ISCSI_CONFIG_KEY_SATRTUP).find(ISCSI_CONFIG_VALUE_SATRTUP_OFF):
        is_active = False
    else:
        is_active = True

    return is_active

########NEW FILE########
__FILENAME__ = locale
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""<comment-ja>
国際化したい文字列を定義します。
 例) 動的に文字列を定義した場合など
</comment-ja>
<comment-en>
</comment-en>
"""

try:
    import karesansui
    import gettext
    gettext.install('messages', karesansui.dirname + "/locale")
except (ImportError,AttributeError,IOError):
    def _(msg):
        return msg

ja_JP = _("ja_JP")
en_US = _("en_US")
de_DE = _("de_DE")
es_ES = _("es_ES")
fr_FR = _("fr_FR")
it_IT = _("it_IT")
ko_KR = _("ko_KR")
pt_BR = _("pt_BR")
zh_CN = _("zh_CN")

########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
</comment-ja>
<comment-en>
Generate configuration file of logview.xml.
</comment-en>

@file:   config.py

@author: Hiroki Takayasu <hiroki@karesansui-project.info>
"""

import os
import errno
import re

import karesansui

from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_nums_xml_xpath as XMLXpathNum, \
     get_xml_parse as XMLParse, \
     uniq_filename, r_chgrp, r_chmod

from karesansui.lib.file.configfile import ConfigFile

class KaresansuiLogConfigParamException(karesansui.KaresansuiLibException):
    pass


class LogViewConfigParam:

    def __init__(self, path):
        self.applications = []
        self.path = path

    def findby1application(self, name):
        ret = None
        for application in self.get_applications():
            if application['name'] == name:
                ret = application

        return ret

    def add_application(self, name, logs):
        self.applications.append({"name" : name,
                                  "logs" : logs})

    def get_applications(self):
        return self.applications

    def load_xml_config(self, path=None):
        if path is not None:
            self.path = path

        if not os.path.isfile(self.path):
            raise KaresansuiLogConfigParamException(
                "logview.xml not found. path=%s" % str(self.path))

        document = XMLParse(self.path)

        self.applications = []
        
        app_num = XMLXpathNum(document, '/applications/application')
        for n in xrange(1, app_num + 1):
            app_name = XMLXpath(document, '/applications/application[%i]/name/text()' % n)
            logs = []
            logs_num = XMLXpathNum(document, '/applications/application[%i]/logs/log' % n)
            for i in xrange(1, logs_num + 1):
                log_name = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/name/text()' %
                                    (n, i))
                log_filename = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/filename/text()' %
                                    (n, i))
                log_filedir = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/dir/text()' %
                                    (n, i))
                view_rotatelog = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/view_rotatelog/text()' %
                                    (n, i))
                time_format = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/time_format/text()' %
                                       (n, i))
                time_pattern = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/time_pattern/text()' %
                                       (n, i))
                use_regex = XMLXpath(document, '/applications/application[%i]/logs/log[%i]/use_regex/text()' %
                                     (n, i))

                if int(use_regex):
                    for logfile in os.listdir("/var/log/%s/" % log_filedir):
                        pattern = re.compile("^%s$" % log_filename)
                        if pattern.findall(logfile):
                            logs.append({"name": logfile,
                                         "dir": log_filedir,
                                         "filename": logfile,
                                         "view_rotatelog":int(view_rotatelog),
                                         "time_format": str(time_format),
                                         "time_pattern": str(time_pattern),
                                         })
                else:
                    logs.append({"name": log_name,
                                 "dir": log_filedir,
                                 "filename": log_filename,
                                 "view_rotatelog":int(view_rotatelog),
                                 "time_format": str(time_format),
                                 "time_pattern": str(time_pattern),
                                 })
            
            self.add_application(str(app_name), logs)


########NEW FILE########
__FILENAME__ = logger
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""<comment-ja>
ロギングプログラム
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

import sys
import logging
import logging.config
from karesansui import KaresansuiException

ready = False
"""<comment-ja>
logging設定が行われているか。
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

class KaresansuiLogError(KaresansuiException):
    """<comment-ja>
    ログ例外クラス
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    pass

def reload_conf(log_conf='/etc/karesansui/log.conf'):
    """<comment-ja>
    loggingの 初期/再 設定を行なう。
    @param log_conf: ログ定義ファイルパス
    @type log_conf: str
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    global ready
    try:
        logging.config.fileConfig(log_conf)
        ready = True
    except:
        ready = False
    
def is_ready():
    """
    <comment-ja>
    ログ出力準備が完了しているか。
    @return bool True(OK) / False(NG)
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    return ready

if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = viewer
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
""" 
@author: Hiroki Takayasu <hiroki@karesansui-project.info>
"""
import re
import time
import datetime
import os
import os.path
import gzip
import fcntl

try:
  from hashlib import sha1 as sha
except:
  import sha
  from sha import sha

from karesansui.lib.const import DEFAULT_DATE_FORMAT, LOG_SYSLOG_REGEX, LOG_EPOCH_REGEX
from karesansui.lib.utils import reverse_file

def read_all_log(log_configs, max_line, start_datetime="", end_datetime="", keyword=""):
    lines = []
    max_line = int(max_line)

    for log_config in log_configs["logs"]:

        try:
            log_config['filepath']
        except:
            if log_config['dir'] is None:
                log_dir = "/var/log"
            else:
                if log_config['dir'][0] == "/":
                    log_dir = log_config['dir']
                else:
                    log_dir = "/var/log/%s" % log_config['dir']
            log_config['filepath'] = "%s/%s" % (log_dir, log_config["filename"])

        filepath = time.strftime(log_config['filepath'])

        if os.path.isfile(filepath) is False:
            continue

        one_file_lines = read_log(filepath, max_line, log_config, start_datetime, end_datetime, keyword)
        lines = one_file_lines + lines

        if len(lines) >= max_line and max_line != 0:
            break

    return lines[-max_line:]

def read_log_with_rotate(filename, max_line, log_config, start_datetime="", end_datetime="", keyword=""):
    if not filename: return False
    if not log_config: return False

    log_dir = "/var/log/%s" % log_config['dir']
    log_dir_list = [filename]
    max_line = int(max_line)

    for tmp_filename in os.listdir(log_dir):
        if tmp_filename.startswith(filename) and tmp_filename != filename:
            log_dir_list.append(tmp_filename)
    log_dir_list.sort()

    lines = []
    for read_filename in log_dir_list:
        log_path = "%s/%s" % (log_dir, read_filename)
        if os.path.isfile(log_path) is False:
            return False
        lines += read_log(log_path, max_line, log_config, start_datetime, end_datetime, keyword)
        if len(lines) >= max_line:
            return lines[:max_line]

    if len(lines) <= max_line:
        return lines
    else:
        return lines[:max_line]

def is_gzip(fd):
    fd.seek(0)
    header = fd.read(2)
    fd.seek(0)
    
    if header == '\x1f\x8b':
        ## GZIP形式
        return 1
    else:
        return 0

def read_log(path, max_line, log_config, start_datetime="", end_datetime="", keyword=""):
    if os.path.isfile(path) is False:
        return False

    time_format = log_config["time_format"]
    if start_datetime:
        start_datetime = time.strptime(start_datetime, DEFAULT_DATE_FORMAT[3])
        if time_format == "syslog":
            start_datetime = datetime.datetime.fromtimestamp(time.mktime(start_datetime)).timetuple()
    if end_datetime:
        end_datetime = time.strptime(end_datetime, DEFAULT_DATE_FORMAT[3])

        if time_format == "syslog":
            end_datetime = datetime.datetime.fromtimestamp(time.mktime(end_datetime)).timetuple()

    if log_config.get("time_pattern"):
        pattern = re.compile(log_config["time_pattern"])
    elif time_format == "epoch":
        pattern = re.compile(LOG_EPOCH_REGEX)
    elif time_format == "syslog":
        pattern = re.compile(LOG_SYSLOG_REGEX)
    elif time_format == "notime":
        pattern = None
    else:
        raise Exception("invalid time_format.")


    try:
        fd = open(path, "r")
    except Exception,e:
        raise
        
    if is_gzip(fd):
        fd.close()
        fd = gzip.open(path, "r")

    # ログの読み込み
    lines = []
    max_line = int(max_line)

    fd = file(path)
    if is_gzip(fd):
        fd = gzip.open(path, "r")
    fd = reverse_file(fd)
    fcntl.lockf(fd.fileno(), fcntl.LOCK_SH)
    try:
        count_line = 0
        for line in fd:
            if count_line >= max_line and max_line != 0:
                break

            if keyword and line.find(keyword) == -1:
                continue

            if time_format == "notime":
                lines.append(line)
                count_line += 1
            else:
                matched = pattern.findall(line)
                if len(matched) > 0:
                    if time_format == "epoch":
                        log_datetime = time.localtime(float(matched[0]))
                        _d = datetime.datetime(
                                log_datetime.tm_year,
                                log_datetime.tm_mon,
                                log_datetime.tm_mday,
                                log_datetime.tm_hour,
                                log_datetime.tm_min,
                                log_datetime.tm_sec)
                        view_datetime = _d.strftime("%Y/%m/%d %H:%M")
                        line = pattern.sub(view_datetime, line)
                    elif time_format == "syslog":
                        log_datetime = time.strptime("2000 %s" % matched[0], "%Y %b %d %H:%M:%S")
                    elif time_format == "notime":
                        log_datetime = 0.0
                    else:
                        log_datetime = time.strptime(matched[0], time_format)

                    if start_datetime and start_datetime > log_datetime:
                        break # check new logtime

                    if end_datetime and end_datetime < log_datetime:
                        continue

                    if (start_datetime and start_datetime <= log_datetime) or not start_datetime:
                        lines.append(line)
                        count_line += 1
                else:
                    ## timestamp not found.
                    lines.append(line)
                    count_line += 1
    finally:
        fcntl.lockf(fd.fileno(), fcntl.LOCK_UN)
        fd.close()
    lines.reverse()
    return lines


########NEW FILE########
__FILENAME__ = merge
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import karesansui
import logging

from karesansui.lib.const import MACHINE_ATTRIBUTE, MACHINE_HYPERVISOR
from karesansui.db.model.machine import Machine
from karesansui.db.model.user import User
from karesansui.db.model.notebook import Notebook
from karesansui.lib.utils import uri_split, uri_join

class MergeHost:
    """<comment-ja>
    Machine(s) Model と libvirt KaresansuiVirtGuest(s)をマージします。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, kvc, model, set_guests=True, if_deleted=2):
        """<comment-ja>
        @param model: Database Model
        @type model: karesansui.db.model.machine.Machine
        @param set_guests: 所属するゲストOS情報を含めるか。
        @type set_guests: bool
        @param is_deleted: 0: すべて, 1: 論理削除のみ, 2: 論理削除以外
        @param is_deleted: int

        注) 本クラスでは、libvirtへのコネクションをクローズしません。呼び出し元でcloseしてください。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.logger = logging.getLogger('karesansui.merge')

        self.info = {"model" : model,
                     "virt" : None,
                     }
        self.guests = []

        self.kvc = kvc
        self.set_guests = set_guests
        self.if_deleted = if_deleted

        if self.set_guests is True:

            if model.attribute == 2:
                #import pdb; pdb.set_trace()
                user  = User(u"unknown",
                             unicode("dummydummy"),
                             unicode("dummydummy"),
                             u"Unknown User",
                             u"",
                            )
                notebook = Notebook(u"", u"")

                for guest_name in kvc.list_active_guest() + kvc.list_inactive_guest():
                    #print guest_name
                    self.logger.info("Reading guest '%s' on '%s' ..." % (guest_name,uri_join(uri_split(model.hostname),without_auth=True)))

                    _virt = kvc.search_kvg_guests(guest_name)
                    if len(_virt) > 0:
                        #uuid = _virt[0].get_info()["uuid"]
                        uuid = _virt[0]._conn.lookupByName(guest_name).UUIDString()

                        #import pdb; pdb.set_trace()
                        guest = Machine(user,
                                        user,
                                        u"%s" % uuid,
                                        u"%s" % guest_name,
                                        MACHINE_ATTRIBUTE['GUEST'],
                                        MACHINE_HYPERVISOR['URI'],
                                        notebook,
                                        [],
                                        u"%s" % "",
                                        u'icon-guest3.png',
                                        False,
                                        None,
                                        )

                        self.guests.append(MergeGuest(guest, _virt[0]))

            else:
                for guest in model.children:
                    if self.if_deleted == 0:
                        _virt = kvc.search_kvg_guests(guest.uniq_key)
                        if len(_virt) > 0:
                            self.guests.append(MergeGuest(guest, _virt[0]))
                    elif self.if_deleted == 1:
                        if guest.is_deleted is True:
                            _virt = kvc.search_kvg_guests(guest.uniq_key)
                            if len(_virt) > 0:
                                self.guests.append(MergeGuest(guest, _virt[0]))
                    elif self.if_deleted == 2:
                        if guest.is_deleted is False:
                            _virt = kvc.search_kvg_guests(guest.uniq_key)
                            if len(_virt) > 0:
                                self.guests.append(MergeGuest(guest, _virt[0]))
                    else:
                        raise Karesansui.KaresansuiLibException("Flag is not expected. if_deleted=%d" % if_deleted)
                
    def get_json(self, languages):
        """<comment-ja>
        @return: {"model" : Host Model,
                  "virt" : Host Virt(karesansui.lib.virt.virt.KaresansuiVirtGuest),
                  "guests" : Guest list(MergeGuest.get_json()),
                  }
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        ret = {"model" : self.info["model"].get_json(languages),
               "virt" : self.info["virt"],
               }

        ret["guests"] = []
        for guest in self.guests:
            ret["guests"].append(guest.get_json(languages))
        return ret
        
class MergeGuest:
    """<comment-ja>
    Machine Model と libvirt KaresansuiVirtGuestをマージします。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    def __init__(self, model, virt): 
        self.info = {"model" : model,
                     "virt" : virt,
                     }

    def get_json(self, languages):
        """<comment-ja>
        @return: {"model" : Guest Model,
                  "virt" : Guest Virt(karesansui.lib.virt.virt.KaresansuiVirtGuest),
                  }
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        ret = {"model" : self.info["model"].get_json(languages),
               "virt" : self.info["virt"].get_json(),
               }
        return ret
        
if __name__ == '__main__':
    pass
    

########NEW FILE########
__FILENAME__ = http
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import socket
import urllib
import urllib2
import base64
import logging
import traceback

import karesansui
from karesansui.lib.utils import is_empty

def is_ssl(hostname, port=443):
    """<comment-ja>
    指定したホスト:ポートがSSLに対応しているか調べる。

    @param hostname: ホスト名
    @type hostname: str
    @param port: ポート番号
    @type port: int
    @return: SSL対応=True | SSL非対応=False
    @rtype: bool
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    try:
        _s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        _s.settimeout(5.0)
        _s.connect((hostname, port))
        if socket.ssl(_s):
            return True
        else:
            return False
    except:
        return False

def is_proxy(config):
    """<comment-ja>
    設定ファイルに設定しているProxy設定を利用できるか。

    @param config: 設定ファイル情報
    @type config: dict
    @return: 利用可=True | 利用不可=False
    @rtype: bool
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    if config.has_key("application.proxy.status") is False:
        return False
    
    if config["application.proxy.status"] == "1":
        return True

    return False

def get_proxy(config):
    if is_proxy(config) is False:
        return None

    host = None
    port = None
    if config.has_key("application.proxy.server") is True:
        host = config["application.proxy.server"]

    if config.has_key("application.proxy.port") is True:
        port = config["application.proxy.port"]

    if is_empty(host) is True:
        return None, None

    return host, port

def get_proxy_user(config):
    if is_proxy(config) is False:
        return None

    user = ""
    password = ""

    if config.has_key("application.proxy.user") is True:
        user = config["application.proxy.user"]

    if config.has_key("application.proxy.password") is True:
        password = config["application.proxy.password"]

    if is_empty(user) is True:
        return None, None

    return user, password

def proxies(proxy_host, proxy_port, user=None, password=None, method="http"):

    if is_empty(user) is False and is_empty(password) is False \
           and is_empty(proxy_host) is False and is_empty(proxy_port) is False:

        return {method: "%s://%s:%s@%s:%s" \
                % (method,user,password,proxy_host,proxy_port)}

    elif is_empty(user) is False and is_empty(proxy_host) is False \
             and is_empty(proxy_port) is False:

        return {method: "%s://%s:@%s:%s" % (method,user,proxy_host,proxy_port)}

    elif is_empty(proxy_host) is False and is_empty(proxy_port) is False:
        return {method: "%s://%s:%s" % (method,proxy_host,proxy_port)}

    elif is_empty(proxy_host) is False:
        return {method: "%s://%s" % (method,proxy_host)}

    else:
        return None

def _wget_proxy(url, file, proxy_host, proxy_port, user=None, password=None):
    _proxies = proxies(proxy_host, proxy_port, user, password)
    if _proxies is None:
        return False

    try:
        proxy_handler = urllib2.ProxyHandler(_proxies)
        auth_handler = urllib2.ProxyBasicAuthHandler()
        opener = urllib2.build_opener(proxy_handler, auth_handler)
        urllib2.install_opener(opener)
        response = urllib2.urlopen(url)

        fp = open(file, "w")
        try:
            fp.write(response.read())
        finally:
            fp.close()

        return True
    except Exception, e:
        logger_trace = logging.getLogger('karesansui_trace.net.http')
        logger_trace.error(traceback.format_exc())
        return False

def wget(url, file=None, proxy_host=None, proxy_port=None, proxy_user=None, proxy_password=None):
    logger = logging.getLogger('karesansui.net.http')
    if file == None:
        i = url.rfind('/')
        file = url[i+1:]

    if proxy_host is not None:
        logger.info("proxy connect - %s:%s (user,password)=(%s:xxxx) url=%s" % (proxy_host, proxy_port, proxy_user, url))
        if proxy_port is None:
            proxy_port = "8080"
        return _wget_proxy(url, file, proxy_host, proxy_port, proxy_user, proxy_password)

    elif is_proxy(karesansui.config) is True:
        proxy_host, proxy_port = get_proxy(karesansui.config)
        user, password = get_proxy_user(karesansui.config)
        logger.info("proxy connect - %s:%s (user,password)=(%s:xxxx) url=%s" % (proxy_host, proxy_port, user, url))
        return _wget_proxy(url, file, proxy_host, proxy_port, user, password)

    else:
        logger.info("not proxy connect - %s" % (url))
        urllib.urlretrieve(url, file)
        return True


########NEW FILE########
__FILENAME__ = mail
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import sys
import time
import glob
import re
import socket
import traceback

import smtplib
from email import message_from_string
from email import Encoders
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.MIMEMultipart import MIMEMultipart
from email.Message import Message
from email.Charset import Charset, QP
from email.Header import Header
from email.Utils import formatdate
from mimetypes import guess_type

default_timeout = 30

class MAIL_LIB_Exception(Exception):
    """Command execution error.
    """
    pass

class MAIL_LIB:

    def __init__(self, smtp_server="localhost", smtp_port=25):

        self.verbose  = False
        self.timeout  = None

        self.smtp_server = smtp_server
        self.smtp_port   = int(smtp_port)

        self.encoding   = "utf-8"
        self.sender     = None
        self.recipients = []
        self.subject    = ""
        self.body       = ""
        self.attach     = None

        self.tls = False
        if self.smtp_port == 587:
            self.tls = True

        self.auth_user   = None
        self.auth_passwd = None

    def set_verbosity(self,flag=0):
        if flag == 0:
            self.verbose = False
        else:
            self.verbose = True

    def set_timeout(self,seconds=30):
        self.timeout = seconds

    def set_sender(self,sender):
        self.sender = sender

    def set_recipients(self,recipients):
        if type(recipients) is str:
            self.recipients = [recipients,]
        else:
            self.recipients = recipients

    def add_recipient(self,recipient):
        if type(recipient) is str:
            self.recipients.append(recipient)
        elif type(recipient) is list:
            self.recipients.update(recipient)

    def set_subject(self,subject):
        self.subject = subject
        try:
            del self.msg['Subject']
            self.msg['Subject'] = Header(self.subject, self.encoding)
        except:
            pass

    def set_body(self,body):
        self.body = body

    def reset_attach(self):
        self.attach = None

    def add_attach(self,attach):
        if self.attach is None:
            self.attach = []

        if type(attach) is str:
            self.attach.append(attach)
        elif type(attach) is list:
            self.attach.update(attach)

    def set_auth_user_passwd(self, user, passwd):
        self.auth_user   = user
        self.auth_passwd = passwd

    def create_message(self):

        if self.attach:
            self.create_multipart_message()
        else:
            self.create_text_message()

        """comment
        """
        charset = Charset(self.encoding)
        charset.header_encoding = QP
        charset.body_encoding = QP
        self.msg.set_charset(charset)
        """
        """

    def create_base_header(self):
        self.msg['Subject'] = Header(self.subject, self.encoding)
        self.msg['From']    = self.sender
        self.msg['To']      = ", ".join(self.recipients)
        self.msg['Date']    = formatdate()

    def create_text_message(self):
        self.msg = MIMEText(self.body, 'plain', self.encoding)
        self.create_base_header()
 
    def create_multipart_message(self):
        self.msg = MIMEMultipart('mixed')
        self.create_base_header()
        text_msg = MIMEText(self.body, 'plain', self.encoding)
        self.msg.attach(text_msg)

        for _attach in self.attach:
            content_type = guess_type(_attach)[0]
            if content_type is None:
                content_type = "application/octet-stream"

            main_type, sub_type = content_type.split('/', 1)
            
            _part = MIMEBase(main_type, sub_type)
            _part['Content-ID'] = _attach
            _part.set_payload(open(_attach).read())
            Encoders.encode_base64(_part)
            _part.__delitem__('Content-Type')
            _part.add_header('Content-Type', content_type, name=os.path.basename(_attach))
            self.msg.attach(_part)

    def send(self):

        if self.timeout is not None:
            if self.verbose is True:
                print "set timeout %d seconds" % self.timeout
            socket.setdefaulttimeout(self.timeout)

        try:
            s = smtplib.SMTP(self.smtp_server,self.smtp_port)
        except socket.error, msg:
            if self.verbose is True:
                print >>sys.stderr, "Error: %s." % msg
            raise MAIL_LIB_Exception("Error: %s." % msg)
        except:
            raise MAIL_LIB_Exception("Error: connection error")


        if self.tls is True:
            s.ehlo()
            if self.verbose is True:
                print "send starttls cmd..."
            s.starttls()
        if self.auth_user is not None and self.auth_passwd is not None:
            s.ehlo()
            if self.verbose is True:
                print "send login cmd..."
            s.login(self.auth_user, self.auth_passwd)

        if self.verbose is True:
            print "send mail to %s..." % ",".join(self.recipients)
        s.sendmail(self.sender, self.recipients, self.msg.as_string())
        s.close()

"""
subject = "root@localhost"
sender = "root@localhost"
recipient = "root@localhost"
attach = "/etc/hosts"
body = " tesst "
subject="foobar"
maillib = MAIL_LIB()
maillib.set_sender(sender)
maillib.set_recipients([recipient])
maillib.add_recipient("root")
maillib.set_subject(subject)
maillib.set_body(body)
maillib.add_attach(attach)
maillib.create_message()
maillib.send()
"""

########NEW FILE########
__FILENAME__ = networkaddress
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re

class NetworkAddress:
    """
    <comment-ja>
    ネットワークアドレスやIPアドレスなどの文字列を操作するクラス
    </comment-ja>
    <comment-en>
    A class to manipulate strings of network address, ip address, etc...
    </comment-en>
    """

    def __init__(self, addr=None):
        """
        <comment-ja>
        "192.168.0.1/24", "192.168.0.1/255.255.255.0"等の種々のIPアドレス指定文字列を操作するクラスのコンストラクタ

        
        @param self: -
        @param addr: アドレス文字列
        @return: なし
        </comment-ja>
        <comment-en>
        constructor of class for manipulating the strings of
        various address formats like "192.168.0.1/24", "192.168.0.1/255.255.255.0".           
        @param self: The object pointer
        @param addr: The string of network address or ip address
        @return: none
        </comment-en>
        """
        self.ip_format = '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'
        self.ipaddr    = None
        self.network   = None
        self.netmask   = None
        self.netlen    = None
        self.cidr      = None
        self.broadcast = None
        if addr != None:
          self.set_network(addr)

    def __repr__(self):
        return '%s/%s' % (self.ipaddr, self.netmask)

    def valid_addr(self, addr=None):
        """
        <comment-ja>
        アドレス形式をチェックする

        @param self: -
        @param addr: アドレス文字列
        @return: アドレス形式が正しければTrue、不正ならFalse
        </comment-ja>
        <comment-en>
        Validate the string of address format

        @param self: The object pointer
        @param addr: The string of address format
        @return: If the specified address is valid, it returns True.
                 If invalid, it returns False.
        </comment-en>
        """
        if addr == None:
          addr = self.ipaddr

        try:
            octets = addr.split('.')
            assert len(octets) == 4
            for x in octets:
                assert 0 <= int(x) <= 255
        except:
            return False
        return True

    def valid_netlen(self, length):
        """
        <comment-ja>
        ネットワーク長をチェックする

        @param self: -
        @param length: ネットワーク長
        @return: アドレス形式が正しければTrue、不正ならFalse
         </comment-ja>
        <comment-en>
        @param self: The object pointer
        @param length: network length
        @return: If the specified address is valid, it returns True.
                 If invalid, it returns False.
         </comment-en>
        """
        try:
            assert 0 <= int(length) <= 32
        except:
            return False
        return True

    def valid_netmask(self, addr):
        """
        <comment-ja>
        ネットマスクをチェックする
        @param self: -
        @param addr: ネットマスク文字列
        @return: アドレス形式が正しければTrue、不正ならFalse
        </comment-ja>
        <comment-en>
        @param self: The object pointer
        @param addr: The string that stands for netmask
        @return: If the specified address is valid, it returns True.
                 If invalid, it returns False.
        </comment-en>
        """
        if self.valid_addr(addr):
            octets = addr.split('.')
            mask = 0x00
            cnt = 0
            for x in octets:
                mask = (int(x) << (24 - 8*cnt)) | mask
                cnt = cnt + 1
            flag = True
            for x in xrange(32):
                bit = mask & (0x01 << 31-x)
                if bit > 0:
                    if flag == False:
                        return False
                    flag = True
                else:
                    flag = False
        else:
            return False
        return True

    def valid_cidr(self, string):
        retval = False

        p = re.compile(r"^(?P<ipaddr>"+self.ip_format+")/(?P<netlen>\d{1,2})$")
        m = p.match(string)
        if m:
            netlen = m.group("netlen")
            retval = self.valid_netlen(int(netlen))

        return retval


    def parse_addr(self, addr):
        """
        <comment-ja>
        "192.168.0.1/24", "192.168.0.1/255.255.255.0"等の種々のアドレス文字列をパースする。ネットマスク部を省略した場合には、32ビット（255.255.255.255）だとみなされる。
    
        @param self: -
        @param addr: アドレス文字列
        @return: アドレスの各形式を格納した連想配列（辞書）
        </comment-ja>
        <comment-en>
        Parse any kind of address format like "192.168.0.1/24", "192.168.0.1/255.255.255.0". If you omit netmask part, it implicits 32bit netmask address(255.255.255.255) .

        @param self: The object pointer
        @param addr: The string of address format
        @return: The hash table that various format of the specified address is stored in.
        </comment-en>
        """
        type = None
        ipaddr = None
        netmask = None
        cidr = None
        netlen = None

        is_cidr = self.valid_cidr(addr)
        if is_cidr is True:
            p = re.compile(r"^(?P<ipaddr>"+self.ip_format+")/(?P<netlen>\d{1,2})$")
            m = p.match(addr)
            if not m:
                return False
            else:
                type  = "cidr"
                ipaddr = m.group("ipaddr")
                netlen = int(m.group("netlen"))
                cidr = addr

        else:
            p = re.compile(r"^(?P<ipaddr>"+self.ip_format+")/(?P<netmask>"+self.ip_format+")$")
            m = p.match(addr)
            if not m:
                p = re.compile(r"^(?P<ipaddr>"+self.ip_format+")$")
                m = p.match(addr)

                if not m:
                    return False
                else:
                    type    = "ip"
                    ipaddr  = m.group("ipaddr")
                    netmask = "255.255.255.255"
                    netlen  = 32

            else:
                type    = "mask"
                ipaddr  = m.group("ipaddr")
                netmask = m.group("netmask")

        if ipaddr:
            if not self.valid_addr(ipaddr):
                return False

        if netlen:
            if not self.valid_netlen(netlen):
                return False

        if netmask:
            if not self.valid_netmask(netmask):
                return False

        return {
                "type":type,
                "ipaddr":ipaddr,
                "netmask":netmask,
                "netlen":netlen,
                "cidr":cidr,
               }

    def netlen_from_netmask(self, netmask):
        """
        <comment-ja>
        ネットマスクからネットワーク長を求める
        
        @param self: -
        @param netmask: ネットマスク文字列
        @return: ネットワーク長
        </comment-ja>
        <comment-en>
        Calculate network length by specified netmask
        
        @param self: The object pointer
        @param netmask: The string that stands for netmask
        @return: The integer of network length
        </comment-en>
        """
        netlen = 0
        octets = netmask.split('.')
        mask = 0x00
        cnt = 0
        for x in octets:
            mask = (int(x) << (24 - 8*cnt)) | mask
            cnt = cnt + 1
        for x in xrange(32):
            bit = mask & (0x01 << 31-x)
            if bit > 0:
                netlen = netlen + 1
            else:
                break
        return netlen

    def netlen_to_netmask(self, netlen):
        """
        <comment-ja>
        ネットワーク長からネットマスクを求める

        @param self: -
        @param netlen: ネットワーク長
        @return: ネットワークマスク文字列
        </comment-ja>
        <comment-en>
        Calculate netmask by specified network length

        @param self: The object pointer
        @param netlen: The integer of network length
        @return: The string that stands for netmask
        </comment-en>
        """
        netmask_bit = "%08x" %( (0xffffffff >> netlen) ^ 0xffffffff)
        netmask = ''
        for x in xrange(0,8,2):
            if netmask != '':
                netmask += "."
            netmask += str(int(netmask_bit[x:x+2],16))
        return netmask

    def set_network(self, addr):
        """
        <comment-ja>
        指定したネットワークアドレス文字列を解析し、そのアドレスの各種要素(CIDR、ネットワーク長など)を変数にセットする。
        ネットワークアドレス文字列には、"192.168.0.1/24"、"192.168.0.1/255.255.255.0"等、parse_addrメソッドで有効な文字列を指定する必要がある。
        
        @param self: -
        @param addr: ネットワークアドレス文字列
        @return: なし
        </comment-ja>
        <comment-en>
        Analize specified network address string, then set the various elements of its address each variable. Network address must be a format valid for parse_addr method.
        
        @param self: The object pointer
        @param addr: The string that stands for network address
        @return: none
        </comment-en>
        """
        res = self.parse_addr(addr)

        if res == False:
          return False

        self.ipaddr = res['ipaddr']

        if res['netmask'] == None and res['netlen'] != None:
            self.netmask = self.netlen_to_netmask(res['netlen'])
        else:
            self.netmask = res['netmask']

        if res['netlen'] == None and res['netmask'] != None:
            self.netlen = self.netlen_from_netmask(res['netmask'])
        else:
            self.netlen = res['netlen']

        cnt = 0
        self.network = ''
        for (x,y) in zip(self.ipaddr.split('.'),self.netmask.split('.')):
            if self.network != '':
                self.network += "."
            if cnt == 3:
                self.first_ip = self.network + "%d" % ((int(x) & int(y)) + 1)
            self.network += "%d" % (int(x) & int(y))
            cnt = cnt + 1

        if self.netlen < 32:
            mask = 0x00
            bit = (0xffffffff >> self.netlen)

            octets = self.network.split('.')
            cnt = 0
            for x in octets:
                mask = mask | (int(x) << (24 - 8*cnt))
                cnt = cnt + 1
            broadcast_bit = "%08x" %( mask | bit )
            self.broadcast = ''
            for x in xrange(0,8,2):
                if self.broadcast != '':
                    self.broadcast += "."
                if x == 6:
                    self.last_ip = self.broadcast + str(int(broadcast_bit[x:x+2],16) - 1)
                self.broadcast += str(int(broadcast_bit[x:x+2],16))


        self.cidr = "%s/%d" % (self.network, self.netlen)

    def network_includes_address(self, addr):
        """
        <comment-ja>
        指定したIPアドレスが同じネットワーク上にあるかどうかを判定する。

        @param self: -
        @param ip: IPアドレス文字列 ('192.168.0.1'等)。ネットマスク部も指定可能だが無視される（判定にはself.netmaskが使用される）。
        @return: boolean
        </comment-ja>
        <comment-en>
        Checks if specified address is on the same network. Netmask part will be ignored (self.network will be used for check).

        @param self: The object pointer
        @param ip: IP address to check
        @return: boolean
        </comment-en>
        """
        na = NetworkAddress(addr)
        na.set_network(na.ipaddr + '/' + self.netmask)
        return na.network  == self.network

    def get(self, type, format=None):
        """
        <comment-ja>
        ネットワークアドレスの指定した要素の値を取得する

        @param self: -
        @param type: ネットワークアドレスの要素（broadcast,cidrなど）
        @param format: 'num'を指定した場合には、ネットワークアドレスを数値で返す（文字列ではなく）
        @return: 指定した要素の値
        </comment-ja>
        <comment-en>
        Get value of the specified network element

        @param self: The object pointer
        @param type: The element of network address
        @param format: if 'num' is specified, return addresses in number (not string).
        @return: Value of specified network element
        </comment-en>
        """
        #var = 'self.' + type
        #return eval(var)
        if format == 'num':
            value = getattr(self, type)
            if self.valid_addr(value):
                return self.addrtonum(value)
            else:
                raise ValueError('"%s" is not in valid address format.' % type)
        else: 
            return getattr(self, type)

    @classmethod    
    def addrtonum(cls, addr):
        num = 0
        fields = addr.split('.')
        for i in xrange(0, len(fields)):
            num += pow(256, len(fields) - i - 1) * int(fields[i])
        return num


########NEW FILE########
__FILENAME__ = pager
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_MIN, CHECK_MAX
from karesansui.lib.const import PAGE_MIN_SIZE, PAGE_MAX_SIZE
from karesansui.lib.utils import is_param

def validates_page(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'p'):
        check = checker.check_number(
                _('Page Number'),
                obj.input.p,
                CHECK_EMPTY | CHECK_VALID | CHECK_MIN | CHECK_MAX,
                min = PAGE_MIN_SIZE,
                max = PAGE_MAX_SIZE,
                ) and check

    obj.view.alert = checker.errors
    return check

class Pager(object):
    """<comment-ja>
    karesansui.db.model.Modelのリストを任意の数で表示する
    ページを作成するクラス。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    def __init__(self, target, now, limit):
        """<comment-ja>
        1ページに表示する対象の数をlimitで指定します。
        表示するページ番号をnowで指定します。
        @param target: ページで区切る対象のリスト
        @type target: [karesansui.db.model.Model...]
        @param now: 表示するページ番号
        @type now: int
        @param limit: 1ページに表示する対象の数
        @type limit: int 
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        self.now = now
        self.limit = limit
        self.total = len(target)
        self.page = self.total / limit
        self.rpage = self.total % limit
        self.start = self.now * self.limit
        self.end = (self.now * self.limit) + self.limit

        if 0 < self.rpage:
            self.page += 1

        self.displays = target[self.start:self.end]

        page_list_size = 6 

        if 0 <= self.now-3:
            self.lnow = self.now - 3
            page_list_size -= 3
        else:
            self.lnow = 0
            page_list_size -= now

        if self.now+3 <= self.page:
            self.rnow = self.now + page_list_size
            if self.page < self.rnow:
                self.rnow = self.page
        else:
            self.rnow = self.page

        page_list = []
        for x in xrange(self.lnow, self.rnow):
            page_list.append(x)
        self.page_list = page_list

    def get_page_list(self):
        """<comment-ja>
        ページ番号のリストを取得する。
        @return: ページ番号のリスト
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return self.page_list

    def is_now_page(self, num):
        """<comment-ja>
        numが現在のページか
        @param num: ページ番号
        @type num: int
        @return: bool
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if num == self.now:
            return True
        else:
            return False

    def get_next_page(self):
        """<comment-ja>
        次のページを取得する。
        @return: 次のページのページ番号
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return self.now + 1

    def get_prev_page(self):
        """<comment-ja>
        前のページを取得する。
        @return: 前のページのページ番号
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return self.now - 1

    def exist_next_page(self):
        """<comment-ja>
        次のページが存在するか
        @return: bool
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.now+1 < self.page:
            return True
        else:
            return False

    def exist_prev_page(self):
        """<comment-ja>
        前のページが存在するか
        @return: bool
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if 0 <= self.now - 1:
            return True
        else:
            return False

    def exist_now_page(self):
        """<comment-ja>
        表示するページが存在するか
        @return: bool
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.now < self.page:
            return True
        else:
            return False

    def get_displays(self):
        """<comment-ja>
        1ページに表示する対象のリストを取得する
        @return: 1ページに表示する対象のリスト
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return self.displays

    def get_start(self):
        """<comment-ja>
        1ページに表示する最初の対象の順番を取得する
        @return: 1ページに表示する最初の対象の順番
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.total == 0:
            return 0
        else:
            return self.start + 1

    def get_end(self):
        """<comment-ja>
        1ページに表示する最後の対象の順番を取得する
        @return: 1ページに表示する最後の対象の順番
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.end < self.total:
            return self.end
        else:
            return self.total

    def get_total(self):
        """<comment-ja>
        全対象の数を取得する
        @return: ページ番号のリスト
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return self.total

########NEW FILE########
__FILENAME__ = comment_deal_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import time

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp
from karesansui.lib.utils import preprint_r


"""
コメントを扱うパーサ
有効な設定行の間のコメントは、次の有効な設定のコメントとみなす

---------------------------------
# comment-1
# comment-2

foo = bar1 bar2  # comment-3
---------------------------------
上記のようなファイルの場合、配列は以下のようになります

value["foo"]["value"] =
  [
    "bar1 bar2",
    ["# comment-1","#comment-2"],
    "# comment-3",
  ]
"""
class commentDealParser:

    _delim               = "[ \t]+"
    _new_delim           = " "
    _comment             = "#"
    _reserved_key_prefix = "@"

    _module  = "comment_deal_parser"
    _footer  = "-- Generated by karesansui"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

    def set_delim(self, delim=" "):
        self._delim = delim

    def set_new_delim(self, delim=" "):
        self._new_delim = delim

    def set_comment(self, comment="#"):
        self._comment = comment

    def set_reserved_key_prefix(self, prefix="@"):
        self._reserved_key_prefix = prefix

    def set_footer(self, footer=""):
        self._footer = footer

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def build_value(self, string, precomment=[], postcomment=None):
        if type(precomment) == str:
            precomment = [precomment]
        return [string, [precomment, postcomment], ]

    def read_conf(self):
        retval = {}

        for _afile in self.source_file():
            res = ConfigFile(_afile).read()

            orders    = []
            comment_1 = []   # 設定の前のコメント リスト配列
            comment_2 = None # 設定行のコメント 文字列
            for _aline in res:
                _aline = _aline.rstrip('\r\n')

                if _aline.strip() == "":
                    comment_1.append(_aline)
                    continue

                if _aline.lstrip()[0:1] == self._comment:
                    footer_regex = re.compile(self._footer)
                    m = footer_regex.search(_aline)
                    if not m:
                        comment = _aline[_aline.rfind(self._comment):]
                        comment_1.append(comment)
                        continue

                regex_str = "^(?P<key>[^ \t]+)%s(?P<value>.*)$" % (self._delim,)
                regex = re.compile(r"%s" % regex_str)

                m = regex.match(_aline)
                if m:
                    key     = m.group('key')
                    value   = m.group('value')
                    if not value.rfind(self._comment) == -1:
                        comment_2 = value[value.rfind(self._comment):]
                        value = value[:value.rfind(self._comment)]

                    new_value = self.build_value(value,comment_1,comment_2)
                    if new_value is not False:
                        self.dop.set(self._module,[_afile,key],new_value)
                        orders.append(key)
                    comment_1 = []
                    comment_2 = None

            if len(comment_1) > 0:
                eof_key    = "%sEOF"    % (self._reserved_key_prefix,)
                new_value = self.build_value("",comment_1,comment_2)
                self.dop.set(self._module,[_afile,eof_key],new_value)

            orders_key = "%sORDERS" % (self._reserved_key_prefix,)
            self.dop.set(self._module,[_afile,orders_key],orders)

        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)


    def _value_to_lines(self,value):
        lines = []

        for _k,_v in value.iteritems():

            try:
                if _v['action'] == "delete":
                    continue
            except:
                pass

            iscomment = False
            try:
                iscomment = _v['comment']
            except:
                pass

            _prefix = ""
            if iscomment is True:
                _prefix += self._comment

            try:
                val = _v['value'][0]

                comment_1 = []
                try:
                    for com1_aline in _v['value'][1][0]:
                        if com1_aline.strip() == "":
                            pass
                        elif com1_aline[0:1] != self._comment:
                            com1_aline = "%s %s" % (self._comment,com1_aline,)
                        comment_1.append(com1_aline)
                except:
                    pass

                comment_2 = _v['value'][1][1]
                try:
                    if comment_2[0:1] != self._comment:
                        comment_2 = "%s %s" % (self._comment,comment_2,)
                except:
                    pass

                lines = lines + comment_1
                aline = "%s%s%s%s" % (_prefix,_k,self._new_delim,val,)
                if comment_2 is not None:
                    aline = "%s %s" % (aline,comment_2,)
                lines.append(aline)
            except:
                pass

        return lines


    def write_conf(self,conf_arr={},dryrun=False):
        retval = True

        self.dop.addconf(self._module,conf_arr)
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)
        eof_key    = "%sEOF"    % (self._reserved_key_prefix,)

        for _path,_v in conf_arr.iteritems():

            if _path[0:1] != "/":
                continue

            lines = []
            try:
                _v['value']
            except:
                continue

            exclude_regex = "^%s[A-Z0-9\_]+$" % self._reserved_key_prefix

            # まずはオーダの順
            if self.dop.isset(self._module,[_path,orders_key]) is True:
                for _k2 in self.dop.get(self._module,[_path,orders_key]):
                    m = re.match(exclude_regex,_k2)
                    if not m:
                        try:
                            if type(_k2) == list:
                                _k2 = _k2.pop()
                            value = {}
                            value[_k2] = _v['value'][_k2]
                            lines = lines + self._value_to_lines(value)
                            self.dop.unset(self._module,[_path,_k2])
                        except:
                            pass

            # オーダにないものは最後に追加
            for _k2,_v2 in self.dop.get(self._module,[_path]).iteritems():
                #if _k2 != orders_key and _k2 != eof_key:
                m = re.match(exclude_regex,_k2)
                if not m:
                    try:
                        value = {}
                        value[_k2] = _v2
                        lines = lines + self._value_to_lines(value)
                    except:
                        pass

            # 最後のコメント用の処理
            if self._footer != "":
                if self.dop.isset(self._module,[_path,eof_key]) is False:
                    self.dop.cdp_set(self._module,[_path,eof_key],"",force=True)

                eof_val     = self.dop.get(self._module,[_path,eof_key])
                eof_action  = self.dop.action(self._module,[_path,eof_key])
                eof_comment = self.dop.comment(self._module,[_path,eof_key])
                try:
                    key = " %s - %s on %s" % (self._footer,self._module,time.strftime("%c",time.localtime()))
                    value = {}
                    value[key] = {}
                    value[key]["value"]   = eof_val
                    value[key]["action"]  = eof_action
                    value[key]["comment"] = eof_comment
                    self.set_new_delim(delim=" ")
                    lines = lines + self._value_to_lines(value)
                except:
                    pass

            if dryrun is False:
                if len(lines) > 0:
                    ConfigFile(_path).write("\n".join(lines) + "\n")
            else:
                #pass
                print "\n".join(lines)

        return retval


########NEW FILE########
__FILENAME__ = generic_conf_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp

"""
Use for parsing files that is written in format such as modprobe.conf etc...
"""

class genericConfParser:

    _delim               = " "
    _new_delim           = " "
    _comment             = "#"
    _reserved_key_prefix = "@"
    _multi_param         = False

    _module      = "generic_conf_parser"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

    def set_delim(self, delim=" "):
        self._delim = delim

    def set_new_delim(self, delim=" "):
        self._new_delim = delim

    def set_comment(self, comment="#"):
        self._comment = comment

    def set_reserved_key_prefix(self, prefix="@"):
        self._reserved_key_prefix = prefix

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def read_conf(self):
        retval = {}

        for _afile in self.source_file():
            res = ConfigFile(_afile).read()

            regex_str = "^(?P<comment>%s)?[ \t]*(?P<key>[^%s]+)[ \t]*%s[ \t]*(?P<value>.*)$" % (self._comment,self._delim,self._delim,)

            orders    = []
            for _aline in res:
                _aline = _aline.rstrip('\r\n')

                regex = re.compile(r"%s" % regex_str)

                m = regex.match(_aline)
                if m:
                    comment = m.group('comment')
                    key     = m.group('key')
                    value   = m.group('value')

                    pieces = re.split("[ \t]*%s[ \t]*" % (self._delim),value,1)

                    if not value.rfind(self._comment) == -1:
                        value = value[:value.rfind(self._comment)]

                    if len(pieces) == 2 and pieces[1] != "":
                        keys = [_afile,key,pieces[0]]
                        new_value = pieces[1]
                    else:
                        if self._multi_param is True:
                            keys = [_afile,key]
                            if self.dop.isset(self._module,keys):
                                old = self.dop.get(self._module,keys)
                                new_value = old + [value]
                            else:
                                new_value = [value]
                        else:
                            keys = [_afile,key,pieces[0]]
                            new_value = ""

                    self.dop.set(self._module,keys,new_value)
                    if not key in orders:
                        orders.append(key)

                    if comment is not None:
                        self.dop.comment(self._module,keys)

            orders_key = "%sORDERS" % (self._reserved_key_prefix,)
            self.dop.set(self._module,[_afile,orders_key],orders)

        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)


    def _value_to_lines(self,value):
        lines = []

        for _k,_v in value.iteritems():

            try:
                if _v['action'] == "delete":
                    continue
            except:
                pass

            try:
                val = _v['value']

                comment = False
                try:
                    if _v['comment'] is True:
                        comment = True
                except:
                    pass

                if type(val) == list:
                    for _val in val:
                        aline = "%s%s%s" % (_k,self._new_delim,_val,)
                        if comment is True:
                            aline = "%s%s" % (self._comment,aline,)
                        lines.append(aline)
                elif type(val) == dict:
                    for _key in sorted(val.keys()):
                        _val = val[_key]

                        """
                    for _key,_val in val.iteritems():
                        """

                        try:
                            if _val['action'] == "delete":
                                continue
                        except:
                            pass

                        _comment = False
                        try:
                            if _val['comment'] is True:
                                _comment = True
                        except:
                            pass

                        if _val['value'] == "":
                            aline = "%s%s%s" % (_k,self._new_delim,_key,)
                        else:
                            aline = "%s%s%s%s%s" % (_k,self._new_delim,_key,self._new_delim,_val['value'],)
                        if comment is True or _comment is True:
                            aline = "%s%s" % (self._comment,aline,)
                        lines.append(aline)
                else:
                    aline = "%s%s%s" % (_k,self._new_delim,val,)
                    lines.append(aline)

            except:
                pass

        return lines

    def write_conf(self,conf_arr={},dryrun=False):
        retval = True

        self.dop.addconf(self._module,conf_arr)
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)

        for _path,_v in conf_arr.iteritems():

            if _path[0:1] != "/":
                continue

            lines = []
            try:
                _v['value']
            except:
                continue

            exclude_regex = "^%s[A-Z0-9\_]+$" % self._reserved_key_prefix

            # まずはオーダの順
            if self.dop.isset(self._module,[_path,orders_key]) is True:
                for _k2 in self.dop.get(self._module,[_path,orders_key]):
                    m = re.match(exclude_regex,_k2)
                    if not m:
                        try:
                            value = {}
                            value[_k2] = _v['value'][_k2]
                            lines = lines + self._value_to_lines(value)
                            self.dop.unset(self._module,[_path,_k2])
                        except:
                            pass

            # オーダにないものは最後に追加
            for _k2,_v2 in self.dop.get(self._module,[_path]).iteritems():
                m = re.match(exclude_regex,_k2)
                if not m:
                    try:
                        value = {}
                        value[_k2] = _v2
                        lines = lines + self._value_to_lines(value)
                    except:
                        pass

            if dryrun is False:
                if len(lines) > 0:
                    ConfigFile(_path).write("\n".join(lines) + "\n")
                if len(lines) == 0:
                    ConfigFile(_path).write("")
            else:
                if len(lines) > 0:
                    print "\n".join(lines)
                if len(lines) == 0:
                    print ""

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    pass

########NEW FILE########
__FILENAME__ = line_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp
from karesansui.lib.utils import execute_command

class lineParser:

    _comment     = ""

    _module      = "line_parser"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

    def set_comment(self, comment=""):
        self._comment = comment

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def read_conf(self):
        retval = {}

        for _afile in self.source_file():
            if _afile[0:4] == "cmd:":
                command_args = _afile[4:].split()
                (ret,res) = execute_command(command_args)
            else:
                res = ConfigFile(_afile).read()

            new_res = []
            for _aline in res:
                _aline = _aline.rstrip('\r\n')
                if self._comment != "" and not _aline.rfind(self._comment) == -1:
                    _aline = _aline[:_aline.rfind(self._comment)]
                if _aline != "":
                    new_res.append(_aline)
            self.dop.set(self._module,[_afile],new_res)

        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},dryrun=False):
        retval = True

        for _path,_v in conf_arr.iteritems():

            if _path[0:1] != "/":
                continue

            try:
                _v['value']
            except:
                continue

            if dryrun is False:
                ConfigFile(_path).write("\n".join(_v['value']) + "\n")
            else:
                print "\n".join(_v['value'])

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    filename = "/etc/hosts"
    parser = lineParser(filename)
    #parser.set_comment("#")
    conf = parser.read_conf()
    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = null_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp

class nullParser:

    _comment     = ""

    _module      = "null_parser"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

    def set_comment(self, comment=""):
        self._comment = comment

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def read_conf(self):
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},dryrun=False):
        retval = True
        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    pass

########NEW FILE########
__FILENAME__ = sh_conf_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp

class shConfParser:

    _delim               = "="
    _new_delim           = "="
    _comment             = "#"
    _multidefine         = False
    _reserved_key_prefix = "@"

    _module      = "sh_conf_parser"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

    def set_delim(self, delim="="):
        self._delim = delim

    def set_new_delim(self, delim="="):
        self._new_delim = delim

    def set_comment(self, comment="#"):
        self._comment = comment

    def set_multidefine(self, multidefine=False):
        self._multidefine = multidefine

    def set_reserved_key_prefix(self, prefix="@"):
        self._reserved_key_prefix = prefix

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def read_conf(self):
        retval = {}

        for _afile in self.source_file():
            res = ConfigFile(_afile).read()

            orders    = []
            for _aline in res:
                _aline = _aline.rstrip('\r\n')

                regex_str = "^(?P<comment>%s)?[ \t]*(?P<key>[^%s ]+)[ \t]*%s *(?P<value>.*)$" % (self._comment,self._delim,self._delim,)
                regex = re.compile(r"%s" % regex_str)

                m = regex.match(_aline)
                if m:
                    comment = m.group('comment')
                    key     = m.group('key')
                    value   = m.group('value')
                    if not value.rfind(self._comment) == -1:
                        value = value[:value.rfind(self._comment)]

                    if self._multidefine and self.dop.isset(self._module,[_afile,key]) is True:
                        new_value = self.dop.get(self._module,[_afile,key])
                        if type(new_value) == str:
                            new_value = [new_value]
                        if not value in new_value:
                            new_value.append(value)
                    else:
                        new_value = value
                    self.dop.set(self._module,[_afile,key],new_value)
                    if not key in orders:
                        orders.append(key)

                    if comment is not None:
                        self.dop.comment(self._module,[_afile,key])

            orders_key = "%sORDERS" % (self._reserved_key_prefix,)
            self.dop.set(self._module,[_afile,orders_key],orders)

        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)


    def _value_to_lines(self,value):
        lines = []

        for _k,_v in value.iteritems():

            try:
                if _v['action'] == "delete":
                    continue
            except:
                pass

            try:
                val = _v['value']

                comment = False
                try:
                    if _v['comment'] is True:
                        comment = True
                except:
                    pass

                if type(val) == list:
                    for _val in val:
                        aline = "%s%s%s" % (_k,self._new_delim,_val,)
                        if comment is True:
                            aline = "%s%s" % (self._comment,aline,)
                        lines.append(aline)
                else:
                    aline = "%s%s%s" % (_k,self._new_delim,val,)
                    lines.append(aline)

            except:
                pass

        return lines

    def write_conf(self,conf_arr={},dryrun=False):
        retval = True

        self.dop.addconf(self._module,conf_arr)
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)

        for _path,_v in conf_arr.iteritems():

            if _path[0:1] != "/":
                continue

            lines = []
            try:
                _v['value']
            except:
                continue

            exclude_regex = "^%s[A-Z0-9\_]+$" % self._reserved_key_prefix

            # まずはオーダの順
            if self.dop.isset(self._module,[_path,orders_key]) is True:
                for _k2 in self.dop.get(self._module,[_path,orders_key]):
                    m = re.match(exclude_regex,_k2)
                    if not m:
                        try:
                            if type(_k2) == list:
                                _k2 = _k2.pop()
                            value = {}
                            value[_k2] = _v['value'][_k2]
                            lines = lines + self._value_to_lines(value)
                            self.dop.unset(self._module,[_path,_k2])
                        except:
                            pass

            # オーダにないものは最後に追加
            for _k2,_v2 in self.dop.get(self._module,[_path]).iteritems():
                m = re.match(exclude_regex,_k2)
                if not m:
                    try:
                        value = {}
                        value[_k2] = _v2
                        lines = lines + self._value_to_lines(value)
                    except:
                        pass

            if dryrun is False:
                if len(lines) > 0:
                    ConfigFile(_path).write("\n".join(lines) + "\n")
                if len(lines) == 0:
                    ConfigFile(_path).write("")
            else:
                if len(lines) > 0:
                    print "\n".join(lines)
                if len(lines) == 0:
                    print ""

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    pass

########NEW FILE########
__FILENAME__ = xml_like_conf_parser
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import time

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.dict_op import DictOp
from karesansui.lib.utils import preprint_r, str_repeat

"""
XMLライクな設定ファイルのパーサ
コメントを扱える
書き込み順を扱える
複数設定可能なオプションを扱える LoadPluginとか

有効な設定行の間のコメントは、次の有効な設定のコメントとみなす

---------------------------------
# comment-1
# comment-2

foo bar1 # comment-3
---------------------------------
上記のようなファイルの場合、配列は以下のようになります

value["foo"]["value"] =
  [
    "bar1",
    ["# comment-1","#comment-2"],
    "# comment-3",
  ]
"""
class xmlLikeConfParser:

    _delim               = "[ \t]+"
    _new_delim           = " "
    _comment             = "#"
    _reserved_key_prefix = "@"
    _indent              = "  "

    _module  = "xml_like_conf_parser"
    _footer  = "-- Generated by karesansui"

    def __init__(self,paths=[]):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.set_source_file(paths)

        self.opt_uni   = ['PIDFile']
        self.opt_multi = ['LoadPlugin','Include']
        self.opt_sect  = ['Directory','VirtualHost','View']

    def set_opt_uni(self, opts):
        self.opt_uni = opts

    def set_opt_multi(self, opts):
        self.opt_multi = opts

    def set_opt_sect(self, opts):
        self.opt_sect = opts

    def set_delim(self, delim=" "):
        self._delim = delim

    def set_new_delim(self, delim=" "):
        self._new_delim = delim

    def set_comment(self, comment="#"):
        self._comment = comment

    def set_reserved_key_prefix(self, prefix="@"):
        self._reserved_key_prefix = prefix

    def set_footer(self, footer=""):
        self._footer = footer

    def set_source_file(self,paths=[]):
        if type(paths) == str:
            paths = [paths]
        self.paths = paths
        return True

    def get_source_file(self):
        return self.paths

    def source_file(self):
        return self.get_source_file()

    def build_value(self, value=None, precomment=[], postcomment=None):
        if type(precomment) == str:
            precomment = [precomment]
        return [value, [precomment, postcomment], ]

    def read_conf(self):
        retval = {}
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)

        for _afile in self.source_file():
            res = ConfigFile(_afile).read()
            self.orders = []
            self.dop.set(self._module,[_afile],self._read_conf(res))
            self.dop.set(self._module,[_afile,orders_key],self.orders)

        return self.dop.getconf(self._module)

    def _read_conf(self,lines,level=0):

        dop = DictOp()
        dop.addconf("__",{})

        pre_comment  = []   # 設定の前のコメント リスト配列
        post_comment = None # 設定行のコメント 文字列
        _in_section = False
        _res = []
        for _aline in lines:

            if _in_section is True:
                regex = "[ \t]*(?P<comment>#*)[ \t]*</(?P<key>%s)>" % _section_key #'|'.join(self.opt_sect)
                _regex = re.compile(r"%s" % regex)
                m = _regex.match(_aline)
                if m:
                    _comment = m.group('comment')
                    _key     = m.group('key').strip()
                    values = self.build_value(self._read_conf(_res,level),pre_comment,post_comment)
                    dop.set("__",[_key,_section_val],values)
                    if _comment != "":
                        dop.comment("__",[_key,_section_val])
                    if level == 1:
                        self.orders.append([_key,_section_val])
                    pre_comment  = []
                    post_comment = None
                    _in_section = False
                    _res = []
                    level = level - 1
                else:
                    _res.append(_aline)

            else:

                _aline = _aline.rstrip('\r\n')

                if _aline.strip() == "":
                    pre_comment.append(_aline)
                    continue

                match = False
                for _type in ['uni','multi','sect']:
                    exec("regex = '|'.join(self.opt_%s)" % _type)
                    if _type == "sect":
                        regex = "[ \t]*(?P<comment>#*)[ \t]*<(?P<key>%s)(?P<section>.*)>" % regex
                    elif _type == "multi":
                        regex = "[ \t]*(?P<comment>#*)[ \t]*(?P<key>%s)[ \t]+(?P<value>.+)"  % regex
                    elif _type == "uni":
                        regex = "[ \t]*(?P<comment>#*)[ \t]*(?P<key>%s)[ \t]+(?P<value>.+)"  % regex

                    _regex = re.compile(r"%s" % regex)
                    m = _regex.match(_aline)
                    if m:
                        match = True
                        _comment = m.group('comment')
                        _key     = m.group('key').strip()
                        if _type == "sect":
                            _section_key = _key
                            _section_val = re.sub(r"[\"']","",m.group('section').strip())
                            _in_section = True
                            level = level + 1
                        elif _type == "multi":
                            _value = m.group('value').strip()
                            if _value.find(self._comment) > 0:
                                post_comment = _value[_value.find(self._comment):]
                            _value = re.sub("%s$" % post_comment, "", _value).rstrip()
                            values = self.build_value(_value,pre_comment,post_comment)
                            dop.set("__",[_key,_value],values)
                            if _comment != "":
                                dop.comment("__",[_key,_value])
                            if level == 0:
                                self.orders.append([_key,_value])
                            pre_comment  = []
                            post_comment = None
                        elif _type == "uni":
                            _value   = m.group('value').strip()
                            if _value.find(self._comment) > 0:
                                post_comment = _value[_value.find(self._comment):]
                            _value = re.sub("%s$" % post_comment, "", _value).rstrip()
                            values = self.build_value(_value,pre_comment,post_comment)
                            dop.set("__",[_key],values)
                            if _comment != "":
                                dop.comment("__",[_key])
                            if level == 0:
                                self.orders.append([_key])
                            pre_comment  = []
                            post_comment = None
                        break

                if match is False:

                    # ブラケットディレクティブのパラメータは除外する (よって、ブラケットディレクティブは全ての定義が必要！)
                    # example: "<undefined_directive 'foobar'>"
                    regex_exclude1 = "[ \t]*(?P<comment>#*)[ \t]*(?P<key>%s)[ \t]" % '|'.join(self.opt_sect)
                    _regex_exclude1 = re.compile(r"%s" % regex_exclude1)

                    # 未定義のパラメータの値がクオートせずにスペース区切りで3つ以上の値を指定している場合はコメント行とみなす
                    # example: "# Read this configuration file"
                    regex_exclude2 = "[ \t]*#+[ \t]*[^ \t]+([ \t]+[^ \t]+){3,}"
                    _regex_exclude2 = re.compile(r"%s" % regex_exclude2)

                    # 未定義のパラメータの値がクオートせずにスペース区切りで2つ以上の値を指定していて、かつ、最後が:で終わる場合はコメント行とみなす
                    # example: "# Read this configuration:"
                    regex_exclude3 = "[ \t]*#+[ \t]*[^ \t]+([ \t]+[^ \t]+){2,}:$"
                    _regex_exclude3 = re.compile(r"%s" % regex_exclude3)

                    # 未定義のパラメータの値が0個以上で、かつ、最後が:で終わる場合はコメント行とみなす
                    # example: "# Read #"
                    regex_exclude4 = "[ \t]*#+[ \t]*[^ \t]+.+[ \t]+#+$"
                    _regex_exclude4 = re.compile(r"%s" % regex_exclude4)

                    m1 = _regex_exclude1.match(_aline)
                    m2 = _regex_exclude2.match(_aline)
                    m3 = _regex_exclude3.match(_aline)
                    m4 = _regex_exclude4.match(_aline)
                    if not m1 and not m2 and not m3 and not m4:

                        # opt_xxxに未定義のパラメータはuniパラメータとする
                        regex = "[ \t]*(?P<comment>#*)[ \t]*(?P<key>[A-Z][^ \t]+)[ \t]+(?P<value>.+)"
                        _regex = re.compile(r"%s" % regex)
                        m = _regex.match(_aline)
                        if m:
                            _comment = m.group('comment')
                            _key     = m.group('key').strip()
                            _value   = m.group('value').strip()
                            if _value.find(self._comment) > 0:
                                post_comment = _value[_value.find(self._comment):]
                            _value = re.sub("%s$" % post_comment, "", _value).rstrip()
                            values = self.build_value(_value,pre_comment,post_comment)
                            dop.set("__",[_key],values)
                            if _comment != "":
                                dop.comment("__",[_key])
                            if level == 0:
                                self.orders.append([_key])
                            pre_comment  = []
                            post_comment = None
                            match = True

                if match is False:

                    if _aline.lstrip()[0:1] == self._comment:
                        footer_regex = re.compile(self._footer)
                        m = footer_regex.search(_aline)
                        if not m: 
                            comment = _aline[_aline.find(self._comment):]
                            pre_comment.append(comment)
                            continue

        if len(pre_comment) > 0:
            eof_key   = "%sEOF"    % (self._reserved_key_prefix,)
            new_value = self.build_value("",pre_comment,post_comment)
            dop.set("__",[eof_key],new_value)

        return dop.getconf("__")


    def _value_to_lines(self,conf_arr,level=0):
        lines = []
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)

        dop = DictOp()
        dop.addconf("__",conf_arr)

        for _k,_v in dop.getconf("__").iteritems():

            action = dop.action("__",[_k])
            if action == "delete":
                continue

            iscomment = dop.iscomment("__",[_k])

            value = dop.get("__",[_k])

            if type(value) == list:

                _val          = value[0]

                if type(_val) != dict:
                    _pre_comment  = value[1][0]
                    _post_comment = value[1][1]

                    pre_comment = []
                    try:
                        for _aline in _pre_comment:
                            if _aline.strip() == "":
                                pass
                            elif _aline[0:1] != self._comment:
                                _prefix = ""
                                if level > 0:
                                    _prefix += str_repeat(self._indent,level)
                                _prefix += self._comment
                                _aline = "%s %s" % (_prefix,_aline,)
                            pre_comment.append(_aline)
                    except:
                        pass

                    if len(pre_comment) > 0:
                        #preprint_r(pre_comment)
                        lines = lines + pre_comment

                    post_comment = _post_comment
                    try:
                        if post_comment is not None and post_comment[0:1] != self._comment:
                            post_comment = "%s %s" % (self._comment,post_comment,)
                    except:
                        pass
                else:
                    pass

            else:
                _val = value

            _prefix = ""
            if iscomment is True:
                _prefix += self._comment
            if level > 0:
                _prefix += str_repeat(self._indent,level)

            if type(_val) == dict:

                # ORDER順に設定する
                orders = []
                try:
                    old_orders = _val[orders_key]['value']
                except:
                    old_orders = []

                for kk in old_orders:
                    if type(kk) is list:
                        orders.append(kk[0])
                    elif type(kk) is str:
                        orders.append(kk)

                for kk in _val.keys():
                    if not kk in orders:
                        orders.append(kk)

                #for _k2,_v2 in _val.iteritems():
                for _k2 in orders:

                    if _k2 == orders_key:
                        continue
                    _v2 = _val[_k2]

                    sub_value = {}
                    sub_value[_k2] = _v2

                    try:
                        iscomment = sub_value[_k2]['comment']
                    except:
                        iscomment = False

                    try:
                        action = sub_value[_k2]['action']
                    except:
                        action = ""

                    if action == "delete":
                        continue

                    #try:
                    #    sub_value[_k2]['value'][1][0]
                    #    lines = lines + sub_value[_k2]['value'][1][0]
                    #except:
                    #    pass


                    is_sect = False
                    if _k in self.opt_multi and _k2 == _v2["value"][0]:
                        for _k3,_v3 in sub_value.iteritems():
                            try:
                                iscomment3 = sub_value[_k3]['comment']
                            except:
                                iscomment3 = iscomment
                            try:
                                action3 = sub_value[_k3]['action']
                            except:
                                action3 = ""

                            _prefix = ""
                            if iscomment is True:
                                _prefix += self._comment
                            if level > 0:
                                _prefix += str_repeat(self._indent,level)
                            lines.append("%s%-18s%s%s" % (_prefix,_k,self._new_delim,_k2))

                    elif _k in self.opt_sect:
                        is_sect = True
                        _prefix = ""
                        if iscomment is True:
                            _prefix += self._comment
                        if level > 0:
                            _prefix += str_repeat(self._indent,level)
                        if _k2 == "":
                            lines.append("%s<%s>" % (_prefix,_k))
                        else:
                            lines.append("%s<%s \"%s\">" % (_prefix,_k,_k2))

                    new_level = level + 1
                    new_lines = self._value_to_lines(sub_value,level=new_level)

                    for _aline in new_lines:
                        _prefix2 = ""
                        if iscomment is True:
                            _prefix2 += self._comment
                        new_aline = "%s%s" % (_prefix2,_aline,)
                        new_aline = re.sub("^%s+" % self._comment,self._comment,new_aline)
                        lines.append(new_aline)
                    #lines = lines + new_lines

                    if is_sect is True:
                        lines.append("%s</%s>" % (_prefix,_k,))

            else:

                aline = ""
                if _k in self.opt_multi:
                    aline += "%s%-18s%s%s" % (_prefix,_k,self._new_delim,_val,)
                else:
                    if re.match("^[A-Z]+[a-z]",_k):
                        aline += "%s%-18s%s%s" % (_prefix,_k,self._new_delim,_val,)

                if post_comment is not None:
                    aline = "%s %s" % (aline,post_comment,)

                if aline != "":
                    lines.append(aline)

        return lines


    def write_conf(self,conf_arr={},dryrun=False):
        retval = True

        self.dop.addconf(self._module,conf_arr)
        orders_key = "%sORDERS" % (self._reserved_key_prefix,)
        eof_key    = "%sEOF"    % (self._reserved_key_prefix,)

        for _path,_v in conf_arr.iteritems():

            if _path[0:1] != "/":
                continue

            lines = []
            try:
                _v['value']
            except:
                continue

            exclude_regex = "^%s[A-Z0-9\_]+$" % self._reserved_key_prefix

            # まずはオーダの順
            if self.dop.isset(self._module,[_path,orders_key]) is True:
                for _k2 in self.dop.get(self._module,[_path,orders_key]):
                    try:
                        if type(_k2) == str:
                            _k2 = [_k2]
                        _search_key = [_path] + _k2

                        is_opt_multi = False
                        if _k2[0] in self.opt_multi:
                            _tmp_conf = self.dop.get(self._module,_search_key)
                            # multiとsectがかぶったオプションの対応 strならmulti
                            if type(_tmp_conf[0]) == str:
                                is_opt_multi = True

                        if is_opt_multi is True:
                            _k2.pop()

                        new_lines = self._new_lines(_search_key,_k2)
                        lines = lines + new_lines
                        self.dop.unset(self._module,_search_key)
                    except:
                        pass

            # オーダにないものは最後に追加
            for _k2,_v2 in self.dop.get(self._module,[_path]).iteritems():

                #if _k2 != orders_key:
                m = re.match(exclude_regex,_k2)
                if not m:
                    try:
                        if type(_k2) == str:
                            _k2 = [_k2]
                        _search_key = [_path] + _k2

                        if _k2[0] in self.opt_multi:
                            for _k3,_v3 in self.dop.get(self._module,_search_key).iteritems():
                                _search_key.append(_k3)
                                new_lines = self._new_lines(_search_key,_k2)
                                lines = lines + new_lines
                        else:
                            new_lines = self._new_lines(_search_key,_k2)
                            lines = lines + new_lines

                    except:
                        pass


            # 最後のコメント用の処理
            if self._footer != "":
                if self.dop.isset(self._module,[_path,eof_key]) is False:
                    self.dop.cdp_set(self._module,[_path,eof_key],"",force=True)

                eof_val     = self.dop.get(self._module,[_path,eof_key])
                eof_action  = self.dop.action(self._module,[_path,eof_key])
                eof_comment = self.dop.comment(self._module,[_path,eof_key])
                try:
                    key = " %s - %s on %s" % (self._footer,self._module,time.strftime("%c",time.localtime()))
                    value = {}
                    value[key] = {}
                    value[key]["value"]   = eof_val
                    value[key]["action"]  = eof_action
                    value[key]["comment"] = eof_comment
                    self.set_new_delim(delim=" ")
                    lines = lines + self._value_to_lines(value)
                except:
                    pass

            if dryrun is False:
                if len(lines) > 0:
                    ConfigFile(_path).write("\n".join(lines) + "\n")
            else:
                print "%s -- filename: %s" % (self._comment,_path,)
                print "\n".join(lines)

        return retval

    def _new_lines(self,search_key,new_key):

        try:
            attrs = self.dop.get(self._module,search_key,with_attr=True)
            action    = attrs['action']
            iscomment = attrs['comment']
            val       = attrs['value']
        except:
            action    = self.dop.action(self._module,search_key)
            iscomment = self.dop.iscomment(self._module,search_key)
            val       = self.dop.get(self._module,search_key)
            pass

        #print val
        dop = DictOp()
        dop.addconf('__',{})
        if action == "delete":
            dop.add('__',new_key,val)
            dop.delete('__',new_key)
        elif action == "set":
            dop.set('__',new_key,val)
        else:
            dop.add('__',new_key,val)
        if iscomment is True:
            dop.comment('__',new_key)

        #preprint_r(dop.getconf('__'))
        new_lines = self._value_to_lines(dop.getconf('__'))
        #print "\n".join(new_lines)

        return new_lines

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = xmlLikeConfParser()
    parser.set_source_file("/etc/collectd.conf")

    conf_arr = parser.read_conf()
    dop = DictOp()
    dop.addconf("parser",conf_arr)
    conf_arr = dop.getconf("parser")
    preprint_r(conf_arr)
    parser.write_conf(conf_arr,dryrun=True)

########NEW FILE########
__FILENAME__ = collectd
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.xml_like_conf_parser import xmlLikeConfParser as Parser
from karesansui.lib.utils import preprint_r
from karesansui.lib.const import VENDOR_SYSCONF_DIR, \
                                 COLLECTD_DATA_DIR, KARESANSUI_GROUP


"""
Define Variables for This Parser
"""
PARSER_COLLECTD_CONF = "%s/collectd.conf" % VENDOR_SYSCONF_DIR

class collectdParser:

    _module = "collectd"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim("[ \t]+")
        self.parser.set_new_delim("\t")
        self.parser.set_comment("#")
        self.base_parser_name = self.parser.__class__.__name__

        self.opt_uni   = ['Hostname',
                          'FQDNLookup',
                          'BaseDir',
                          'PIDFile',
                          'Target',
                          'Host',
                          'Key',
                          'LogLevel',
                          'Plugin',
                          'Subject',
                          'SMTPPort',
                          'SMTPServer',
                          'URL',
                          'Type',
                          'Chain']
        self.opt_multi = ['Include',
                          'LoadPlugin',
                          'Collect',
                          'DriverOption',
                          'GetCapacity',
                          'GetSnapshot',
                          'Irq',
                          'JVMArg',
                          'Listen',
                          'PreCacheChain',
                          'PostCacheChain',
                          'Query',
                          'Recipient',
                          'Sensor',
                          'Server',
                          'WatchAdd']
        self.opt_sect  = ['Plugin',
                          'LoadPlugin',
                          'Threshold',
                          'Type',
                          'Chain',
                          'Data',
                          'Database',
                          'Directory',
                          'Disks',
                          'File',
                          'Host',
                          'Key',
                          'Match',
                          'Metric',
                          'Module',
                          'Page',
                          'Query',
                          'Recursor',
                          'Result',
                          'Router',
                          'Rule',
                          'Server',
                          'System',
                          'Table',
                          'Target',
                          'URL',
                          'View',
                          'VolumePerf',
                          'VolumeUsage',
                          'WAFL']

        self.parser.set_opt_uni(self.opt_uni)
        self.parser.set_opt_multi(self.opt_multi)
        self.parser.set_opt_sect(self.opt_sect)

        pass

    def set_footer(self, footer=""):
        self.parser.set_footer(footer)

    def source_file(self):
        retval = [PARSER_COLLECTD_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_COLLECTD_CONF])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[PARSER_COLLECTD_CONF]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[PARSER_COLLECTD_CONF],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval


"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = collectdParser()

    # 読み込み
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())

    ##########################################################
    # Uniオプション (一箇所しか設定できないオプション) の追加
    ##########################################################
    # 'Foo foo' を追加（設定値リスト形式モードよる addメソッド）
    dop.add("dum",["Foo"],["foo",[["comment foo1","comment foo2"],"comment foo3"]])
    #print dop.cdp_get("dum",["Foo"])
    #print dop.cdp_get_pre_comment("dum",["Foo"])
    #print dop.cdp_get_post_comment("dum",["Foo"])
    dop.insert_order("dum",["Foo"])

    # 'Bar bar' を追加（設定値文字列形式モードによる cdp_setメソッド）
    dop.cdp_set("dum",["Bar"],"bar")
    dop.cdp_set_pre_comment("dum",["Bar"],["","comment bar1","comment bar2"])
    dop.cdp_set_post_comment("dum",["Bar"],"comment bar3")
    dop.insert_order("dum",["Bar"])

    ##########################################################
    # Multiオプション (複数設定できるオプション) の追加
    ##########################################################
    # 'LoadPlugin target_hoge' を追加
    dop.cdp_set("dum",["LoadPlugin","target_hoge"],"target_hoge",is_opt_multi=True)
    dop.cdp_set_pre_comment("dum",["LoadPlugin","target_hoge"],["","Dis is target_hoge"])

    ##########################################################
    # Sectオプション (<ブラケット>ディレクティブオプション) の追加
    ##########################################################
    # 下記 を追加
    # <Plugin "foobar">
    #        <View "hoge">
    #                SubOpt1         gege # post
    #        </View>
    #        Option2         false
    #        Option1         true
    # </Plugin>
    dop.cdp_set("dum",["Plugin","foobar","Option1"],"true")
    dop.cdp_set("dum",["Plugin","foobar","Option2"],"false")
    dop.cdp_set("dum",["Plugin","foobar","View","hoge","SubOpt1"],"gege")
    dop.cdp_set_pre_comment("dum",["Plugin","foobar","View","hoge","SubOpt1"],["","pre comment"])
    dop.cdp_set_post_comment("dum",["Plugin","foobar","View","hoge","SubOpt1"],"post")

    # 'LoadPlugin target_replace' の値を取得
    key = ["LoadPlugin","target_hoge"]
    dop.insert_order("dum",key)
    value = dop.cdp_get("dum",key)
    preprint_r(value)

    # 'LoadPlugin target_replace' の設定順を取得
    key = ["LoadPlugin","target_hoge"]
    num = dop.order("dum",key)
    print num

    # '<Plugin foobar>' を 'LoadPlugin target_hoge' の前にする
    key = ["Plugin","foobar"]
    dop.insert_order("dum",key,num)

    # '<Plugin foobar>' を 'LoadPlugin target_hoge' の後に変更する
    dop.change_order("dum",key,num+1)

    # 'Foo' を 'Bar' の後に変更する
    num = dop.order("dum",['Foo'])
    dop.change_order("dum",['Bar'],num+1)
    print dop.get("dum",['@ORDERS'])

    # 配列確認
    conf = dop.getconf("dum")
    #preprint_r(conf)

    #parser.set_footer("")
    parser.write_conf(conf,dryrun=True)


########NEW FILE########
__FILENAME__ = collectdplugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import glob

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.xml_like_conf_parser import xmlLikeConfParser as Parser
from karesansui.lib.utils import preprint_r, r_chgrp, r_chmod
from karesansui.lib.const import VENDOR_SYSCONF_DIR, \
                                 COLLECTD_DATA_DIR, KARESANSUI_GROUP


"""
Define Variables for This Parser
"""
PARSER_COLLECTD_PLUGIN_DIR = "%s/collectd.d" % VENDOR_SYSCONF_DIR

class collectdpluginParser:

    _module = "collectdplugin"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim("[ \t]+")
        self.parser.set_new_delim("\t")
        self.parser.set_comment("#")
        self.base_parser_name = self.parser.__class__.__name__

        from karesansui.lib.parser.collectd import collectdParser
        collectdp = collectdParser()

        self.parser.set_opt_uni(collectdp.opt_uni)
        self.parser.set_opt_multi(collectdp.opt_multi)
        self.parser.set_opt_sect(collectdp.opt_sect)

        pass

    def set_footer(self, footer=""):
        self.parser.set_footer(footer)

    def source_file(self):
        retval = []

        glob_str = "%s/*.conf" % (PARSER_COLLECTD_PLUGIN_DIR,)
        for _afile in glob.glob(glob_str):
            retval.append(_afile)

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        for _afile in self.source_file():

            plugin_name = re.sub("\.conf$","",os.path.basename(_afile))

            try:
                extra_args['include']
                if not re.search(extra_args['include'],plugin_name):
                    continue
            except:
                pass

            self.parser.set_source_file([_afile])
            conf_arr = self.parser.read_conf()
            try:
                self.dop.set(self._module,[plugin_name],conf_arr[_afile]['value'])
            except:
                pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def _pre_write_conf(self,conf_arr={}):

        # Change permission to be able to read/write data kss group.
        if os.path.exists(COLLECTD_DATA_DIR):
            if os.getuid() == 0:
                r_chgrp(COLLECTD_DATA_DIR,KARESANSUI_GROUP)
                r_chmod(COLLECTD_DATA_DIR,"g+rwx")
                r_chmod(COLLECTD_DATA_DIR,"o-rwx")

        dop = DictOp()
        dop.addconf("__",conf_arr)

        if dop.isset("__",["python"]) is True:
            dop.cdp_unset("__",["python","Plugin","python","@ORDERS"],multiple_file=True)
            orders = []
            orders.append(['Encoding'])
            orders.append(['LogTraces'])
            orders.append(['Interactive'])
            orders.append(['ModulePath'])
            orders.append(['Import'])
            orders.append(['Module'])
            dop.cdp_set("__",["python","Plugin","python","@ORDERS"],orders,is_opt_multi=True,multiple_file=True)

        return dop.getconf("__")

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        conf_arr = self._pre_write_conf(conf_arr)

        for plugin_name,_v in conf_arr.iteritems():

            _afile = "%s/%s.conf" % (PARSER_COLLECTD_PLUGIN_DIR,plugin_name,)
            try:
                _v['action']
                if _v['action'] == "delete":
                    if os.path.exists(_afile):
                        os.unlink(_afile)
                        continue
            except:
                pass
                #continue

            try:
                _v['value']

                self.dop.addconf("parser",{})
                self.dop.set("parser",[_afile],_v['value'])
                #self.dop.preprint_r("parser")
                arr = self.dop.getconf("parser")
                self.parser.write_conf(arr,dryrun=dryrun)
            except:
                pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """

    parser = collectdpluginParser()

    # 読み込み
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())

    new_plugin_name = "takuma"

    ##########################################################
    # Uniオプション (一箇所しか設定できないオプション) の追加
    ##########################################################
    # 'Foo foo' を追加（設定値リスト形式モードよる addメソッド）
    dop.add("dum",[new_plugin_name,"Foo"],["foo",[["comment foo1","comment foo2"],"comment foo3"]])

    # 'Bar bar' を追加（設定値文字列形式モードによる cdp_setメソッド）
    dop.cdp_set("dum",[new_plugin_name,"Bar"],"bar",multiple_file=True)
    dop.cdp_set_pre_comment("dum",[new_plugin_name,"Bar"],["","comment bar1","comment bar2"],multiple_file=True)
    dop.cdp_set_post_comment("dum",[new_plugin_name,"Bar"],"comment bar3",multiple_file=True)

    ##########################################################
    # Multiオプション (複数設定できるオプション) の追加
    ##########################################################
    # 'LoadPlugin target_hoge' を追加
    dop.cdp_set("dum",[new_plugin_name,"LoadPlugin","target_hoge"],"target_hoge",multiple_file=True,is_opt_multi=True)
    dop.cdp_set_pre_comment("dum",[new_plugin_name,"LoadPlugin","target_hoge"],["","Dis is target_hoge"],multiple_file=True)

    ##########################################################
    # Sectオプション (<ブラケット>ディレクティブオプション) の追加
    ##########################################################
    # 下記 を追加
    # <Plugin "foobar">
    #        <View "hoge">
    #                SubOpt1         gege # post
    #        </View>
    #        Option2         false
    #        Option1         true
    # </Plugin>
    dop.cdp_set("dum",[new_plugin_name,"Plugin","foobar","Option1"],"true",multiple_file=True)
    dop.cdp_set("dum",[new_plugin_name,"Plugin","foobar","Option2"],"false",multiple_file=True)
    dop.cdp_set_pre_comment("dum",[new_plugin_name,"Plugin","foobar","Option2"],"pre comment",multiple_file=True)
    dop.cdp_set_post_comment("dum",[new_plugin_name,"Plugin","foobar","Option2"],"post comment",multiple_file=True)
    dop.cdp_set("dum",[new_plugin_name,"Plugin","foobar","View","hoge","SubOpt1"],"gege",multiple_file=True)
    dop.cdp_set_post_comment("dum",[new_plugin_name,"Plugin","foobar","View","hoge","SubOpt1"],"post",multiple_file=True)

    print dop.get("dum",["filter","@ORDERS"],multiple_file=True)

    # 複数ファイルを読み込むパーサーの場合は、is_parent_parser=Trueにすること
    # '<Plugin foobar>' を 先頭にする
    key = [new_plugin_name,"Plugin","foobar"]
    dop.insert_order("dum",key,0,is_parent_parser=True)

    # 'LoadPlugin target_hoge' を 先頭にする => '<Plugin foobar>' は２番目になる
    key = [new_plugin_name,"LoadPlugin","target_hoge"]
    dop.insert_order("dum",key,0,is_parent_parser=True)

    # 'Foo foo' を 先頭にする => 'LoadPlugin target_hoge' は２番目になる
    key = [new_plugin_name,"Foo"]
    dop.insert_order("dum",key,0,is_parent_parser=True)

    # work completely
    #dop.cdp_comment("dum",["python","Plugin","python","Import"],multiple_file=True)
    #dop.cdp_comment("dum",["python","Plugin","python","Module","notification"],multiple_file=True)
    #dop.cdp_comment("dum",["python","Plugin","python","Module","notification","CountupDBPath"],multiple_file=True)
    #dop.cdp_set("dum",["python","Plugin","python","Module","notification","@ORDERS"],[['Environ'],['CountupDBPath']],multiple_file=True,is_opt_multi=True)
    # work completely, too.
    #dop.cdp_comment("dum",["python","Plugin","python","ModulePath"],multiple_file=True)
    # work completely, too. (but this is overwritten by _pre_write_conf() method)
    #dop.cdp_set("dum",["python","Plugin","python","@ORDERS"],[['ModulePath'],['Encoding']],multiple_file=True,is_opt_multi=True)
    #sys.exit()

    # 配列確認
    conf = dop.getconf("dum")
    preprint_r(conf)

    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = eml
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import time
import email.Parser

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.null_parser import nullParser as Parser
from karesansui.lib.utils import array_replace
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""

class emlParser(Parser):

    _module = "eml"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.base_parser_name = Parser.__name__

        self.encoding = "UTF-8"
        pass

    def source_file(self):
        try:
            retval = self.get_source_file()
        except:
            retval = []

        return retval

    def _parse_mail(self,mail):
        retval = {}
        try:
            body              = mail.get_payload()
            boundary          = mail.get_boundary()
            charsets          = mail.get_charsets()         # ['iso-8859-1']
            content_charset   = mail.get_content_charset()  # 'iso-8859-1'
            content_maintype  = mail.get_content_maintype() # 'text'
            content_subtype   = mail.get_content_subtype()  # 'plain'
            content_type      = mail.get_content_type()     # 'text/plain'
            default_type      = mail.get_default_type()     # 'text/plain'
            filename          = mail.get_filename()         # ??
            params            = mail.get_params()           # [('text/plain', ''), ('charset', 'iso-8859-1')]
            is_multipart      = mail.is_multipart()         # False
            if type(body) is list:
                new_body = []
                for _mail in body:
                    new_body.append(self._parse_mail(_mail))
                body = new_body
            retval = {}
            retval['body']             = body
            retval['boundary']         = boundary
            retval['charsets']         = charsets
            retval['content_charset']  = content_charset
            retval['content_maintype'] = content_maintype
            retval['content_subtype']  = content_subtype
            retval['content_type']     = content_type
            retval['default_type']     = default_type
            retval['filename']         = filename
            retval['params']           = params
            retval['is_multipart']     = is_multipart
        except:
            pass

        #preprint_r(retval)
        return retval

    def parse(self,file=None,message=None):
        retval = {}
        try:
            if file is not None and os.path.exists(file):
                message = open(file).read()

            mail = email.Parser.Parser().parsestr(message)

            headers  = mail._headers
            msgs     = self._parse_mail(mail)

            if type(msgs['body']) is list:
                rawbody = ""

                if file is not None and os.path.exists(file):
                    f = open(file)
                    line = f.readline()
                    while line:
                        line = f.readline()
                        if line.rstrip() == "":
                            rawbody += line
                            rawbody += ''.join(f.readlines())
                            break
                    f.close
                else:
                    in_body = False
                    for line in message.split("\n"):
                        if line.rstrip() == "":
                            in_body = True
                        if in_body is True:
                            rawbody += line + "\n"

            elif type(msgs['body']) is str:
                rawbody = msgs['body']

            retval["headers"] = headers
            retval["msgs"]    = msgs
            retval["rawbody"] = rawbody

        except:
            pass

        #preprint_r(retval)
        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.dop.addconf(self._module,{})

        try:
            self.set_source_file(extra_args["file"])

            for _file in self.source_file():
                if os.path.exists(_file):
                    mail = self.parse(file=_file)

                    headers  = mail['headers']
                    msgs     = mail['msgs']
                    rawbody  = mail['rawbody']

                    self.dop.add(self._module,[_file,'@msgs']   ,msgs)
                    self.dop.add(self._module,[_file,'@headers'],headers)
                    for _header in headers:
                        self.dop.add(self._module,[_file,'header',_header[0]],_header[1])
                    self.dop.add(self._module,[_file,'rawbody'] ,rawbody)

        except:
            pass

        try:
            message = extra_args["message"]

            try:
                message = message.encode(self.encoding)
            except:
                pass

            if message != "" and message is not None:
                mail = self.parse(message=message)

                headers  = mail['headers']
                msgs     = mail['msgs']
                rawbody  = mail['rawbody']

                self.dop.add(self._module,["@message",'@msgs']   ,msgs)
                self.dop.add(self._module,["@message",'@headers'],headers)
                for _header in headers:
                    self.dop.add(self._module,["@message",'header',_header[0]],_header[1])
                self.dop.add(self._module,["@message",'rawbody'] ,rawbody)
        except:
            pass


        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """

    message = """Message-ID: <67147291.1.1231874007256.JavaMail.taizo@karesansui-project.info>
Subject: Hello, World!!
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="----=_Part_0_22060966.1231404007271"

------=_Part_0_22060966.1231404007271
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

E-Mail created by Application
------=_Part_0_22060966.1231404007271
Content-Type: application/pdf; name=HelloWorld_007.pdf
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=HelloWorld_007.pdf
Content-ID: Attachment

JVBERi0xLjMgCiXi48/TIAo3IDAgb2JqCjw8Ci9Db250ZW50cyBbIDggMCBSIF0gCi9QYXJlbnQg

------=_Part_0_22060966.1231404007271--
    """

    parser = emlParser()
    dop = DictOp()
    eml = "/tmp/test2.eml"
    extra_args = {"message":message}
    extra_args = {"file":eml}
    extra_args = {"message":open(eml).read()}
    dop.addconf("dum",parser.read_conf(extra_args=extra_args))
    conf = dop.getconf("dum")
    preprint_r(conf)


########NEW FILE########
__FILENAME__ = hosts
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.comment_deal_parser import commentDealParser as Parser
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""
PARSER_HOSTS_CONF="/etc/hosts"

class hostsParser:

    _module = "hosts"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim("[ \t]+")
        self.parser.set_new_delim("\t")
        self.parser.set_comment("#")
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def source_file(self):
        retval = [PARSER_HOSTS_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_HOSTS_CONF])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[PARSER_HOSTS_CONF]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[PARSER_HOSTS_CONF],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = hostsParser()
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())
    dop.add("dum",['key'],['value',[['comment foo','comment bar'],'comment hoge']])
    print dop.cdp_get("dum",['key'])
    print dop.cdp_get_pre_comment("dum",['key'])
    print dop.cdp_get_post_comment("dum",['key'])
    print dop.cdp_set("dum",['key'],"value2")
    print dop.cdp_set_pre_comment("dum",['key'],["comment foo2","comment bar2","a"])
    print dop.cdp_set_post_comment("dum",['key'],"comment fuga")
    conf = dop.getconf("dum")
    preprint_r(conf)
    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = ifcfg
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import glob

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.sh_conf_parser import shConfParser as Parser
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""
PARSER_IFCFG_DIR="/etc/sysconfig/network-scripts"
PARSER_IFCFG_FILE_PREFIX="ifcfg-"

class ifcfgParser:

    _module = "ifcfg"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.exclude_device_regex = "\.old|\.bak|\.rpm.*|lo|\.20"
        self.exclude_device_regex = "\.old|\.bak|\.rpm.*|\.20"
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def source_file(self):
        retval = []

        glob_str = "%s/%s" % (PARSER_IFCFG_DIR,PARSER_IFCFG_FILE_PREFIX,)
        for _afile in glob.glob("%s*" % glob_str):
            device_name =  _afile.replace(glob_str,"")
            if re.search(r"%s" % self.exclude_device_regex, device_name) is None:
                retval.append(_afile)

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        for _afile in self.source_file():

            device_name = os.path.basename(_afile).replace(PARSER_IFCFG_FILE_PREFIX,"")
            self.parser.set_source_file([_afile])
            conf_arr = self.parser.read_conf()
            try:
                self.dop.set(self._module,[device_name],conf_arr[_afile]['value'])
            except:
                pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        for device_name,_v in conf_arr.iteritems():

            _afile = "%s/%s%s" % (PARSER_IFCFG_DIR,PARSER_IFCFG_FILE_PREFIX,device_name)
            try:
                _v['action']
                if _v['action'] == "delete":
                    if os.path.exists(_afile):
                        os.unlink(_afile)
                        #pass
            except:
                continue

            try:
                _v['value']

                self.dop.addconf("parser",{})
                self.dop.set("parser",[_afile],_v['value'])
                #self.dop.preprint_r("parser")
                arr = self.dop.getconf("parser")
                self.parser.write_conf(arr,dryrun=dryrun)
            except:
                pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    pass

########NEW FILE########
__FILENAME__ = iptables
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import time

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.line_parser import lineParser as Parser
from karesansui.lib.utils import array_replace
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""
PARSER_COMMAND_IPTABLES="/sbin/iptables"
PARSER_COMMAND_IPTABLES_SAVE="/sbin/iptables-save"
PARSER_COMMAND_IPTABLES_RESTORE="/sbin/iptables-restore"
PARSER_IPTABLES_CONF="/etc/sysconfig/iptables"
PARSER_IPTABLES_INITRD="/etc/init.d/iptables"
PARSER_IPTABLES_INITRD_ACTIONS="start|stop|restart|condrestart|status|panic|save"

PARSER_IPTABLES_CONF_HEADER="(# Generated by .* on ).*"
PARSER_IPTABLES_CONF_FOOTER="(# Completed on ).*"


class iptablesParser:

    _module = "iptables"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def source_file(self):
        retval = [PARSER_IPTABLES_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_IPTABLES_CONF])
        self.dop.addconf(self._module,{})

        conf_arr = self.parser.read_conf()
        try:
            lines = conf_arr[PARSER_IPTABLES_CONF]['value']
            lint = self.do_lint("\n".join(lines))
            self.dop.set(self._module,["config"],lines)
            self.dop.set(self._module,["lint"]  ,lint)
        except:
            pass

        cmdfile = "cmd:%s" % PARSER_COMMAND_IPTABLES_SAVE
        self.parser.set_source_file([cmdfile])
        conf_arr = self.parser.read_conf()
        try:
            lines = conf_arr[cmdfile]['value']
            self.dop.set(self._module,["status"],lines)
        except:
            pass

        self.parser.set_source_file([PARSER_IPTABLES_CONF])

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        now = time.strftime("%c",time.localtime())
        try:
            self.dop.addconf("parser",{})

            lines = conf_arr["config"]["value"]
            lines = array_replace(lines,PARSER_IPTABLES_CONF_HEADER,"# Generated by karesansui on %s" % (now,))
            lines = array_replace(lines,PARSER_IPTABLES_CONF_FOOTER,"# Completed on %s" % (now,))
            self.dop.set("parser",[PARSER_IPTABLES_CONF],lines)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
            self.do_condrestart()
        except:
            pass

        return retval

    def do_start(self):
        return self._do("start")

    def do_stop(self):
        return self._do("stop")

    def do_restart(self):
        return self._do("restart")

    def do_condrestart(self):
        return self._do("condrestart")

    def do_status(self):
        return self._do("status")

    def is_running(self):
        return self.do_status()[0]

    def _do(self,action=None):
        from karesansui.lib.utils import execute_command

        retval = False
        res    = []
        if re.match("^(%s)$" % PARSER_IPTABLES_INITRD_ACTIONS, action):
            command_args = [PARSER_IPTABLES_INITRD,action]
            (ret,res) = execute_command(command_args)
            if ret == 0:
                retval = True
        return [retval,res]

    # reverseがFalseなら設定ファイルをもとに、システムに反映(condrestart)
    # reverseがTrueならシステムの状態をもとに、設定ファイルに反映
    def do_sync(self,reverse=False):
        try:
            self.dop.addconf("parser",self.read_conf())
            if reverse is False:
                self.do_restart()
            else:
                lines = self.dop.get("parser",["status"])
                self.dop.set("parser",["config"],lines)
                conf = self.dop.getconf("parser")
                self.write_conf(conf)
            return True
        except:
            return False

    def do_lint(self,string,lint=True):
        import signal
        import subprocess
        retval = []

        if lint is True:
            (old_ret,old_res) = self.do_status()
            if old_ret is True:
                old_lines = []
                cmdfile = "cmd:%s" % PARSER_COMMAND_IPTABLES_SAVE
                self.parser.set_source_file([cmdfile])
                conf_arr = self.parser.read_conf()
                try:
                    old_lines = conf_arr[cmdfile]['value']
                except:
                    pass
                self.parser.set_source_file([PARSER_IPTABLES_CONF])


        signal.alarm(10)
        if lint is True:
            command_args = [PARSER_COMMAND_IPTABLES_RESTORE,"--test"]
        else:
            command_args = [PARSER_COMMAND_IPTABLES_RESTORE]
        proc = subprocess.Popen(command_args,
                   bufsize=1,
                   shell=True,
                   stdin=subprocess.PIPE,
                   stdout=subprocess.PIPE,
                   stderr=subprocess.PIPE)

        #proc.stdin.write(string)
        (stdout,stderr) = proc.communicate(string)
        ret = proc.wait()
        signal.alarm(0)

        exclude_strings = [
           "Try `iptables-restore -h' or 'iptables-restore --help' for more information.",
           "iptables-restore v[0-9\.]+: iptables-restore:",
           "iptables-restore v[0-9\.]+: ",
        ]

        new_stderr = []
        for _aline in re.split("[\r\n]+",stderr):
            new_stderr.append(_aline)
        new_stderr = array_replace(new_stderr,exclude_strings,["","",""])
        stderr = "\n".join(new_stderr)
        """
        """

        retval = [ret,stdout,stderr]

        if lint is True:
            if old_ret is True and len(old_lines) != 0:
                self.do_lint("\n".join(old_lines),lint=False)
            elif old_ret is False:
                self.do_stop()

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = iptablesParser()
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())
    lines = dop.get("dum",['config'])
    lines.append("aa# test")
    lines.append("bb# test")
    lines.append("aa# test")
    #preprint_r(lines)

    dop.set("dum",['config'],lines)
    conf = dop.getconf("dum")
    #preprint_r(conf)

    parser.do_stop()
    print parser.is_running()
    parser.do_start()
    print parser.is_running()
    parser.do_stop()
    print parser.is_running()

    parser.write_conf(conf,dryrun=True)
    #parser.do_sync(True)
    print parser.do_sync(False)

    contents = open("/etc/sysconfig/iptables.corrupted").read()
    print parser.do_lint(contents)


########NEW FILE########
__FILENAME__ = iscsid
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.comment_deal_parser import commentDealParser as Parser
from karesansui.lib.utils import preprint_r
from karesansui.lib.const import ISCSI_DEFAULT_CONFIG_PATH

"""
Define Variables for This Parser
"""

class iscsidParser:

    _module = "hosts"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim("[ \t]*=[ \t]*")
        self.parser.set_new_delim(" = ")
        self.parser.set_comment("#")
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def set_footer(self, footer=""):
        self.parser.set_footer(footer)

    def source_file(self):
        retval = [ISCSI_DEFAULT_CONFIG_PATH]

        return retval

    def read_conf(self, conf_path=None, extra_args=None):
        retval = {}

        if conf_path is None:
            conf_path = ISCSI_DEFAULT_CONFIG_PATH

        self.parser.set_source_file([conf_path])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[conf_path]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self, conf_arr={}, conf_path=None, extra_args=None, dryrun=False):
        retval = True

        if conf_path is None:
            conf_path = ISCSI_DEFAULT_CONFIG_PATH

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[conf_path],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = iscsidParser()
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())
    dop.add("dum",['key'],['value',[['','comment mae1','comment mae2'],'comment ato']])
    dop.comment("dum",['node.session.iscsi.FastAbort'])
    dop.uncomment("dum",['node.session.iscsi.FastAbort'])
    conf = dop.getconf("dum")
    #preprint_r(conf)
    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = modprobe_conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.generic_conf_parser import genericConfParser as Parser
from karesansui.lib.utils import preprint_r
from karesansui.lib.const import VENDOR_SYSCONF_DIR, KARESANSUI_GROUP


"""
Define Variables for This Parser
"""
PARSER_MODPROBE_CONF = "/etc/modprobe.conf"

class modprobe_confParser:

    _module = "modprobe_conf"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim(" ")
        self.parser.set_new_delim(" ")
        self.parser.set_comment("#")
        self.base_parser_name = self.parser.__class__.__name__

        pass

    def source_file(self):
        retval = [PARSER_MODPROBE_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_MODPROBE_CONF])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[PARSER_MODPROBE_CONF]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[PARSER_MODPROBE_CONF],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval


"""
"""
if __name__ == '__main__':
    """Testing

alias eth0 e1000
alias eth1 e1000
alias eth2 e1000
alias scsi_hostadapter mptbase
alias scsi_hostadapter1 mptspi
alias scsi_hostadapter2 ata_piix
alias snd-card-0 snd-hda-intel
options snd-card-0 index=0
options snd-hda-intel index=0
remove snd-hda-intel { /usr/sbin/alsactl store 0 >/dev/null 2>&1 || : ; }; /sbin/modprobe -r --ignore-remove snd-hda-intel
include /path/to/include/file1
include /path/to/include/file2
blacklist modulename
    """

    parser = modprobe_confParser()

    # 読み込み
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())

    #########################################
    # include と blacklist パラメータの場合

    # １、パラメータを追加する
    new_key   = '/path/to/include/file1'
    new_value = ''   # valueを空にセットする
    dop.add("dum",["include",new_key],new_value)
    # コメントにするなら
    dop.comment("dum",["include",new_key])

    new_key   = '/path/to/include/file2'
    new_value = ''   # valueを空にセットする
    dop.add("dum",["include",new_key],new_value)

    # ２、パラメータを削除する
    delete_key = '/path/to/include/file2'
    dop.delete("dum",["include",delete_key])

    """
    # こっちの方式は、_multi_paramをTrueにしたときだけ

    # １、パラメータを追加する
    new_value = '/path/to/include/file'
    if dop.isset("dum",["include"]):
        old_values = dop.get("dum",["include"])
        if not new_value in old_values:
            new_values = old_values + [new_value]
    else:
        new_values = [new_value]
    dop.set("dum",["include"],new_values)

    # ２、パラメータを削除する
    new_values = []
    delete_value = '/path/to/include/file'
    if dop.isset("dum",["include"]):
        old_values = dop.get("dum",["include"])
        if delete_value in old_values:
            for _value in old_values:
                if _value != delete_value:
                    new_values.append(_value)
    else:
        pass
    if len(new_values) > 0:
        dop.set("dum",["include"],new_values)
    """

    #########################################
    # include と blacklist パラメータ以外(aliasなど)の場合

    # １、パラメータを追加する
    new_key   = 'eth3'
    new_value = 'foobar'
    dop.add("dum",["alias",new_key],new_value)
    # コメントにするなら
    dop.comment("dum",["alias",new_key])

    new_key   = "snd-hda-intel"
    new_value = "{ /usr/sbin/alsactl store 0 >/dev/null 2>&1 || : ; }; /sbin/modprobe -r --ignore-remove snd-hda-intel"
    dop.add("dum",["remove",new_key],new_value)

    # ２、パラメータを削除する
    delete_key = 'eth3'
    dop.delete("dum",["alias",delete_key])

    # ３、パラメータの値を変更する
    target_key = 'eth3'
    new_value  = 'barfoo'
    dop.set("dum",["alias",target_key],new_value)


    # 配列確認
    conf = dop.getconf("dum")
    #preprint_r(conf)

    parser.write_conf(conf,dryrun=True)


########NEW FILE########
__FILENAME__ = network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.sh_conf_parser import shConfParser as Parser
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""
PARSER_NETWORK_CONF="/etc/sysconfig/network"

class networkParser:

    _module = "network"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim("=")
        self.parser.set_new_delim("=")
        self.parser.set_multidefine(False)
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def source_file(self):
        retval = [PARSER_NETWORK_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_NETWORK_CONF])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[PARSER_NETWORK_CONF]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[PARSER_NETWORK_CONF],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = networkParser()
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())
    dop.add("dum","NETWORK","1.0.0.0")
    dop.add("dum","NETWORK2","1.0.0.0")
    dop.delete("dum","NETWORK")
    conf = dop.getconf("dum")
    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = process_all_module
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys

from karesansui.lib.dict_op import *
from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.utils import execute_command

save_path = "/tmp"
command_read_conf  = "/usr/share/karesansui/bin/read_conf.py"
command_write_conf = "/usr/share/karesansui/bin/write_conf.py"

once_execute = False # コマンド毎回
once_execute = True  # コマンド一回

use_read_conf = True

for _mod in ['ifcfg','network','resolv']:

    print _("################################")
    print _("Processing module '%s'... ") % (_mod)
    print _("################################")

    dop = DictOp()
    try:
        exec("from karesansui.lib.parser.%s  import %sParser as Parser" % (_mod,_mod,))
    except:
        raise

    parser = Parser()

    source_file = parser.source_file()
    print ">" + _("Detecting configuration files")
    print "\n".join(source_file)
    print "<" + _("Detecting configuration files")

    output_file = "%s/%s_dict.py" % (save_path,_mod,)
    if use_read_conf is True:
        command_args = []
        command_args.append(command_read_conf)
        command_args.append("--module")
        command_args.append(_mod)
        command_args.append("--file")
        command_args.append(output_file)
        print ">" + _("Reading configuration files")
        print ">>" + _("Execute") + "=>" + " ".join(command_args)
        (ret, res) = execute_command(command_args)
        if len(res) > 0:
            print ">>" + _("Execute Result") + "=>\n" + "\n".join(res)
        print "<" + _("Reading configuration files")

    else:
        print ">" + _("Reading configuration files")
        dop.addconf(_mod,parser.read_conf())
        print "<" + _("Reading configuration files")

        print ">" + _("Writing module dict files")
        conf = dop.getconf(_mod)
        ConfigFile(output_file).write(str(conf))
        print "<" + _("Writing module dict files")

    if os.path.exists(output_file):
        print ">>Wrote %s" % output_file

        if once_execute is False:
            command_args = []
            command_args.append(command_write_conf)
            command_args.append("--module")
            command_args.append(_mod)
            command_args.append("--file")
            command_args.append(output_file)
            print ">" + _("Writing configuration files")
            print ">>" + _("Execute") + "=>" + " ".join(command_args)
            (ret, res) = execute_command(command_args)
            if len(res) > 0:
                print ">>" + _("Execute Result") + "=>\n" + "\n".join(res)
            print "<" + _("Writing configuration files")

        else:
            try:
                module_args
            except:
                module_args = []
            module_args.append(_mod)
            try:
                file_args
            except:
                file_args = []
            file_args.append(output_file)

if once_execute is True:
    command_args = []
    command_args.append(command_write_conf)
    command_args.append("--module")
    command_args.append(":".join(module_args))
    command_args.append("--file")
    command_args.append(":".join(file_args))
    print ">" + _("Writing configuration files")
    print ">>" + _("Execute") + "=>" + " ".join(command_args)
    (ret, res) = execute_command(command_args)
    if len(res) > 0:
        print ">>" + _("Execute Result") + "=>\n" + "\n".join(res)
    print "<" + _("Writing configuration files")



########NEW FILE########
__FILENAME__ = resolv
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.sh_conf_parser import shConfParser as Parser
from karesansui.lib.utils import preprint_r


"""
Define Variables for This Parser
"""
PARSER_RESOLV_CONF="/etc/resolv.conf"

class resolvParser:

    _module = "resolv"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})

        self.parser = Parser()
        self.parser.set_delim(" ")
        self.parser.set_new_delim(" ")
        self.parser.set_multidefine(True)
        self.base_parser_name = self.parser.__class__.__name__
        pass

    def source_file(self):
        retval = [PARSER_RESOLV_CONF]

        return retval

    def read_conf(self,extra_args=None):
        retval = {}

        self.parser.set_source_file([PARSER_RESOLV_CONF])
        conf_arr = self.parser.read_conf()
        try:
            self.dop.addconf(self._module,conf_arr[PARSER_RESOLV_CONF]['value'])
        except:
            pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        try:
            self.dop.addconf("parser",{})
            self.dop.set("parser",[PARSER_RESOLV_CONF],conf_arr)
            #self.dop.preprint_r("parser")
            arr = self.dop.getconf("parser")
            self.parser.write_conf(arr,dryrun=dryrun)
        except:
            pass

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = resolvParser()
    dop = DictOp()
    dop.addconf("dum",parser.read_conf())
    dop.comment("dum","search")
    dop.comment("dum","nameserver")
    dop.add("dum","domain","example.com localdomain")
    conf = dop.getconf("dum")
    parser.write_conf(conf,dryrun=True)

########NEW FILE########
__FILENAME__ = staticroute
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import os
import re
import sys
import glob

from karesansui.lib.dict_op import DictOp
from karesansui.lib.parser.base.sh_conf_parser import shConfParser as Parser
from karesansui.lib.utils import execute_command
from karesansui.lib.utils import preprint_r
from karesansui.lib.networkaddress import NetworkAddress


"""
Define Variables for This Parser
"""
PARSER_STATICROUTE_DIR="/etc/sysconfig/network-scripts"
PARSER_STATICROUTE_FILE_PREFIX="route-"
PARSER_COMMAND_ROUTE="/sbin/route"
PARSER_COMMAND_IP="/sbin/ip"
PARSER_COMMAND_IFUP_ROUTE="/etc/sysconfig/network-scripts/ifup-routes"
PARSER_COMMAND_IFDOWN_ROUTE="/etc/sysconfig/network-scripts/ifdown-routes"
PARSER_STATICROUTE_DEFAULT_CONFIG_STYLE="old"

"""
##############
old style
##############
192.168.250.0/24 via 172.16.0.1
192.168.20.11/32 via 172.16.0.1

##############
new style
##############
GATEWAY0=172.16.0.1
NETMASK0=255.255.255.0
ADDRESS0=192.168.250.0
GATEWAY1=172.16.0.1
NETMASK1=255.255.255.255
ADDRESS1=192.168.20.11
"""


class staticrouteParser:

    _module = "staticroute"

    def __init__(self):
        self.dop = DictOp()
        self.dop.addconf(self._module,{})
        self.exclude_device_regex = "\.old|\.bak|\.rpm.*|\.20"

        self.parser = Parser()

        self.config_style = self.detect_config_style()
        if self.config_style == "old":
            self.parser.set_delim(" via ")
            self.parser.set_new_delim(" via ")
        else:
            self.parser.set_delim("=")
            self.parser.set_new_delim("=")

        self.base_parser_name = self.parser.__class__.__name__
        pass

    def detect_config_style(self):
        retval = PARSER_STATICROUTE_DEFAULT_CONFIG_STYLE

        command_args = ["grep","ADDRESS\[0\-9\]",PARSER_COMMAND_IFUP_ROUTE]
        (ret,res) = execute_command(command_args)
        if ret == 0:
            retval = "new"
            glob_str = "%s/%s" % (PARSER_STATICROUTE_DIR,PARSER_STATICROUTE_FILE_PREFIX,)
            for _afile in glob.glob("%s*" % glob_str):
                device_name =  _afile.replace(glob_str,"")
                if re.search(r"%s" % self.exclude_device_regex, device_name) is None:
                    command_args = ["grep"," via ",_afile]
                    (ret,res) = execute_command(command_args)
                    if ret == 0:
                        retval = "old"
                        break

        return retval

    def source_file(self):
        retval = []

        glob_str = "%s/%s" % (PARSER_STATICROUTE_DIR,PARSER_STATICROUTE_FILE_PREFIX,)
        for _afile in glob.glob("%s*" % glob_str):
            device_name =  _afile.replace(glob_str,"")
            if re.search(r"%s" % self.exclude_device_regex, device_name) is None:
                retval.append(_afile)

        return retval

    def convert_old_style(self, conf_arr):

        dop = DictOp()
        dop.addconf("__",{})
        orders = []
        for cnt in range(0,20):
            try:
                try:
                    exec("action  = conf_arr['ADDRESS%d']['action']" % cnt)
                except:
                    action = None

                exec("address = conf_arr['ADDRESS%d']['value']" % cnt)
                exec("netmask = conf_arr['NETMASK%d']['value']" % cnt)
                exec("gateway = conf_arr['GATEWAY%d']['value']" % cnt)

                target = "%s/%s" % (address,netmask,)
                net = NetworkAddress(target)
                try:
                    target = net.cidr
                except:
                    pass
                dop.add("__",[target],gateway)

                if action == "delete":
                    dop.delete("__",[target])

                orders.append([target])
            except:
                pass

        if len(orders) != 0:
            dop.add("__",['@ORDERS'],orders)

        return dop.getconf("__")

    def convert_new_style(self, conf_arr):

        dop = DictOp()
        dop.addconf("__",{})
        orders = []

        try:
            old_orders = conf_arr['@ORDERS']['value']
        except:
            old_orders = []

        cnt = 0
        for _k,_v in conf_arr.iteritems():

            if _k[0] != "@":
                net = NetworkAddress(_k)
                try:
                    ipaddr  = net.ipaddr
                    netmask = net.netmask
                    gateway = _v['value']
                    try:
                        action = _v['action']
                    except:
                        action = None
                    try:
                        index = old_orders.index([_k])
                    except:
                        index = cnt

                    dop.add("__",["ADDRESS%d" % index],ipaddr)
                    if action == "delete":
                        dop.delete("__",["ADDRESS%d" % index])
                    orders.insert(cnt*3+0,["ADDRESS%d" % index])

                    dop.add("__",["NETMASK%d" % index],netmask)
                    if action == "delete":
                        dop.delete("__",["NETMASK%d" % index])
                    orders.insert(cnt*3+1,["NETMASK%d" % index])

                    dop.add("__",["GATEWAY%d" % index],gateway)
                    if action == "delete":
                        dop.delete("__",["GATEWAY%d" % index])
                    orders.insert(cnt*3+2,["GATEWAY%d" % index])

                    cnt = cnt + 1
                except:
                    pass

        if len(orders) != 0:
            dop.add("__",['@ORDERS'],orders)

        return dop.getconf("__")

    def read_conf(self,extra_args=None):
        retval = {}

        for _afile in self.source_file():

            device_name = os.path.basename(_afile).replace(PARSER_STATICROUTE_FILE_PREFIX,"")
            self.parser.set_source_file([_afile])
            conf_arr = self.parser.read_conf()
            try:
                # oldスタイルの配列に統一する
                if self.config_style == "new":
                    arr = self.convert_old_style(conf_arr[_afile]['value'])
                else:
                    arr = conf_arr[_afile]['value']
 
                self.dop.set(self._module,[device_name],arr)
            except:
                pass

        self.dop.set(self._module,['@BASE_PARSER'],self.base_parser_name)
        #self.dop.preprint_r(self._module)
        return self.dop.getconf(self._module)

    def write_conf(self,conf_arr={},extra_args=None,dryrun=False):
        retval = True

        for device_name,_v in conf_arr.iteritems():

            _afile = "%s/%s%s" % (PARSER_STATICROUTE_DIR,PARSER_STATICROUTE_FILE_PREFIX,device_name)
            try:
                _v['action']
                if _v['action'] == "delete":
                    if os.path.exists(_afile):
                        os.unlink(_afile)
                        #pass
            except:
                continue

            try:
                _v['value']

                # newスタイルの配列に統一する
                if self.config_style == "new":
                    arr = self.convert_new_style(_v['value'])
                else:
                    arr = _v['value']

                self.dop.addconf("parser",{})
                self.dop.set("parser",[_afile],arr)
                #self.dop.preprint_r("parser")
                arr = self.dop.getconf("parser")
                self.parser.write_conf(arr,dryrun=dryrun)
            except:
                pass

        return retval

    def do_status(self):
        retval = {}

        command_args = [PARSER_COMMAND_ROUTE]
        (ret,res) = execute_command(command_args)

        ip_regex = "\d{1,3}(\.\d{1,3}){3}"
        regex = re.compile("(?P<destination>%s|default)[ \t]+(?P<gateway>%s|\*)[ \t]+(?P<netmask>%s)[ \t]+(?P<flags>[UGH]+)[ \t]+(?P<metric>\d+)[ \t]+(?P<ref>\d+)[ \t]+(?P<use>\d+)[ \t]+(?P<device>[^ ]+)" % (ip_regex,ip_regex,ip_regex,))
        for _aline in res:
            m = regex.match(_aline)
            if m:
                device      = m.group('device')
                destination = m.group('destination')
                if destination == "default":
                    destination = "0.0.0.0"
                netmask     = m.group('netmask')

                target = "%s/%s" % (destination,netmask,)
                net = NetworkAddress(target)
                target = net.cidr

                try:
                    retval[device]
                except:
                    retval[device] = {}
                retval[device][target] = {}

                for _atype in ["use","metric","ref","flags","gateway"]:
                    try:
                        exec("retval[device][target]['%s'] = m.group('%s')" % (_atype,_atype,))
                    except:
                        pass

        return retval

    def do_add(self,device,target,gateway):
        retval = True

        type = "-net"
        try:
            net = NetworkAddress(target)
            if net.netlen == 32:
                type = "-host"
            target = net.cidr
        except:
            pass
        command_args = [PARSER_COMMAND_ROUTE, "add", type, target, "gw", gateway, "dev", device]
        (ret,res) = execute_command(command_args)
        if ret != 0:
            retval = False

        return retval

    def do_del(self,device,target):
        retval = True

        type = "-net"
        try:
            net = NetworkAddress(target)
            if net.netlen == 32:
                type = "-host"
            target = net.cidr
        except:
            pass
        command_args = [PARSER_COMMAND_ROUTE, "del", type, target, "dev", device]
        (ret,res) = execute_command(command_args)
        if ret != 0:
            retval = False

        return retval

"""
"""
if __name__ == '__main__':
    """Testing
    """
    parser = staticrouteParser()

    preprint_r(parser.do_status())
    parser.do_add("eth0","5.6.7.0","172.16.0.1")
    parser.do_del("eth0","5.6.7.0")
    preprint_r(parser.do_status())

    conf_arr = parser.read_conf()
    preprint_r(conf_arr)

    dop = DictOp()
    dop.addconf("parser",conf_arr)
    dop.add("parser",["eth1","2.3.4.5/32"],"172.16.0.10")
    dop.add("parser",["eth1","2.3.4.6/32"],"172.16.0.10")
    dop.add("parser",["eth1","2.3.4.7/32"],"172.16.0.10")
    #dop.insert_order("parser",["eth1","2.3.4.5/32"],0,is_parent_parser=True)
    #dop.insert_order("parser",["eth1","2.3.4.6/32"],0,is_parent_parser=True)
    dop.insert_order("parser",["eth1","2.3.4.7/32"],1,is_parent_parser=True)
    #dop.delete("parser",["eth1","2.3.4.5/32"])
    #dop.delete("parser",["eth1","2.3.4.6/32"])
    conf_arr = dop.getconf("parser")
    preprint_r(conf_arr)
    parser.write_conf(conf_arr,dryrun=True)

########NEW FILE########
__FILENAME__ = progress
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys
import time

try:
    import urlgrabber.progress as progress
except:
    raise

class ProgressMeter(progress.TextMeter):

    def __init__(self, command_object=None, quiet=False, fo=sys.stderr):
        progress.TextMeter.__init__(self)
        self.fo = fo
        self.quiet = quiet
        self.command_object = command_object

    def update(self, amount_read, now=None):
        if now is None:
            now = time.time()
        if (now >= self.last_update_time + self.update_period) or not self.last_update_time:
            self.re.update(amount_read, now)
            self.last_amount_read = amount_read
            self.last_update_time = now
            if self.quiet is False:
                self._do_update(amount_read, now)
            try:
                self.command_object.up_progress(1)
            except:
                pass

    def end(self, amount_read, now=None):
        if now is None:
            now = time.time()
        self.re.update(amount_read, now)
        self.last_amount_read = amount_read
        self.last_update_time = now
        if self.quiet is False:
            self._do_end(amount_read, now)
        try:
            self.command_object.up_progress(1)
        except:
            pass


########NEW FILE########
__FILENAME__ = rest
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""<comment-ja>
Rest(Gadget)全体を司る
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

from datetime import datetime
from base64 import b64decode
from gettext import translation as translation
import logging
import traceback
import os
import sys

import web
from web.utils import Storage
from web.contrib.template import render_mako

from mako.template import Template
from mako.lookup import TemplateLookup
from mako import exceptions

import karesansui
from karesansui.lib.utils import is_int, is_param, karesansui_database_exists
from karesansui.db.access.user import login as dba_login
from karesansui.db.access.machine import is_findbyhost1, is_findbyguest1
from karesansui.lib.const import LOGOUT_FILE_PREFIX, DEFAULT_LANGS
from karesansui.db.access.user import findby1email

BASIC_REALM = 'KARESANSUI_AUTHORIZE'
"""<comment-ja>
Basic Authの Basic realm 名
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

GET='GET'
POST='POST'
PUT='PUT'
DELETE='DELETE'

OVERLOAD_METHOD='_method'
"""<comment-ja>
オーバーロードメソッドのinput名
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

ERROR_MEDIA = ['html', 'json', 'part', 'input']
"""<comment-ja>
対応しているErrorページのメディアタイプ
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

DEFAULT_MEDIA = 'html'
"""<comment-ja>
デフォルトのメディアタイプ
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

OUTPUT_TYPE_NORMAL = 0
OUTPUT_TYPE_FILE = 1
OUTPUT_TYPE_STREAM = 2
"""<comment-ja>

</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

class Rest:
    """<comment-ja>
    全てのRest基底クラス
    Restを使用する場合は本クラスを継承してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    def __init__(self):
        """<comment-ja>
        リクエスト単位で初期化する処理を行います。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        self.__method__ = GET
        """<comment-ja>
        HTTP Method
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
    
        self.view = Storage()
        """<comment-ja>
        テンプレートへ渡したい値をセットする変数
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        self.input = Storage()
        """<comment-ja>
        リクエスト情報、各種設定値が設定されている変数
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        self.__template__ = Storage()

        self.download = Storage()

        # self setting
        self.logger = logging.getLogger('karesansui.rest')
        self.logger_trace = logging.getLogger('karesansui_trace.rest')
        self.orm = web.ctx.orm
        self.pysilhouette = web.ctx.pysilhouette
        self.view.ctx = web.ctx
        self.view.alert = []
        self.me = None
        self.languages = [ unicode(karesansui.config['application.default.locale']), ]
        self._ = mako_translation(languages=self.languages)
        
        # templates
        self.__template__.dir = self.__class__.__name__.lower()
        self.__template__.file = self.__class__.__name__.lower()
        self.__template__.media = DEFAULT_MEDIA

        # download
        self.download.file = None
        self.download.stream = None
        self.download.type = OUTPUT_TYPE_NORMAL
        self.download.once = False

    def _pre(self, *param, **params):
        """<comment-ja>
        HTTP Method別処理を実行する前の処理を行います。
          1. メディアタイプの設定
          2. Content-Typeの設定
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        multi = {}
        for x in web.input(_unicode=False).keys():
            if x.startswith('multi') is True:
                multi[x] = {}
        self.input = web.input(**multi)
        
        try:
            if param:
                resource = web.websafe(param[len(param)-1])
                self.__template__.media = resource[resource.rindex('.')+1:]
                
        except (IndexError, ValueError), ve:
            self.__template__.media = DEFAULT_MEDIA
            self.logger.debug(
                '%s - The media-type has not been specified, or that violate the format, so use a standard format. :Media=%s' \
                % (' '.join(ve.args), self.__template__.media))

        if self.input.has_key('mode') and self.input.mode == 'input':
            self.__template__.media = self.input.mode

    def _post(self, f):
        """<comment-ja>
        HTTP Method別処理を実行した後の処理を行います。
          1. HTTP Responseコード 4xx or 5xx についての処理
          2. テンプレート処理
          3. HTTP Headerをセット
        @param f: 実行結果
        @type f: bool or web.HTTPError
        @return: HTTP Response
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        try: # default view set.
            self.view.me = self.me
            if self.is_standalone() is True:
                self.view.standalone = self.input.standalone
        except AttributeError:
            pass

        # Content-Type
        # TODO
        # "Resource interpreted as script but transferred with MIME type text/plain."
        #if self.__template__.media == 'part':
        #    web.header('Content-Type', 'text/html; charset=utf-8', True)
        #elif self.__template__.media == 'input':
        #    web.header('Content-Type', 'text/html; charset=utf-8', True)
        #elif self.__template__.media == 'html':
        #    web.header('Content-Type', 'text/html; charset=utf-8', True)
        #elif self.__template__.media == 'json':
        #    web.header('Content-Type', 'application/json; charset=utf-8', True)
        #elif self.__template__.media == 'xml':`
        #    web.header('Content-Type', 'text/xml; charset=utf-8', True)
        #elif self.__template__.media == 'gif':
        #    web.header('Content-Type', 'Content-type: image/gif', True)
        #elif self.__template__.media == 'png':
        #    web.header('Content-Type', 'Content-type: image/png', True)
        #elif self.__template__.media == 'jpg':
        #    web.header('Content-Type', 'Content-type: image/jpeg', True)
        #elif self.__template__.media == 'jpeg':
        #    web.header('Content-Type', 'Content-type: image/jpeg', True)
        #elif self.__template__.media == 'ico':
        #    web.header('Content-Type', 'Content-type: image/x-icon', True)
        #elif self.__template__.media == 'css':
        #    web.header('Content-Type', 'Content-type: text/css; charset=utf-8', True)
        #elif self.__template__.media == 'js':
        #    web.header('Content-Type', 'Content-type: text/javascript; charset=utf-8', True)
        #elif self.__template__.media == 'jar':
        #    web.header('Content-Type', 'Content-type: application/java-archiver', True)
        #else:
        #    web.header('Content-Type', 'text/plain; charset=utf-8', True)

        # HTTP Header - No Cache
        now = datetime.now()
        web.lastmodified(now)
        web.httpdate(now)
        # TODO
        #web.expire(0)
        #web.header('Expires', web.httpdate(datetime(1970,1,1)))
        #web.header('Last-Modified',  web.httpdate(datetime(1970,1,1)))
        #web.header('ETag', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
        web.header('Cache-Control', 'no-cache,private')
        web.header('Pragma', 'no-cache')

        ##
        if self.download.type == OUTPUT_TYPE_NORMAL: # Nomal
            if self.me is None:
                self.view.USER_DATE_FORMAT = DEFAULT_LANGS[self.languages[0]]['DATE_FORMAT']
            else:
                self.view.USER_DATE_FORMAT = DEFAULT_LANGS[self.me.languages]['DATE_FORMAT']

            if isinstance(f, web.HTTPError) is True:
                self.logger.info('HTTP Response - %s Headers-->%s' % (f.__class__.__name__, web.ctx.headers))
                raise f

            if f is True:
                path = '%s/%s.%s' % (self.__template__.dir, self.__template__.file, self.__template__.media,)
            else:
                #if self.__template__.media in ERROR_MEDIA:
                #    path = 'error/error.%s' % self.__template__.media
                #else:
                #    path = 'error/error.%s' % DEFAULT_MEDIA
                self.logger.info('"gadget" execution error - %s' % str(self.__class__))
                raise web.internalerror("Execution errors")

            self.logger.debug('lang=%s %s : template=%s' \
                              % (','.join(self.languages), str(self), path))

            try:
                _r = mako_render(self._, path,
                                 title=self._('Karesansui'), view=self.view)
                return _r
            except:
                if web.wsgi._is_dev_mode() is True and os.environ.has_key('FCGI') is False:
                    return exceptions.html_error_template().render(full=True)
                else:
                    self.logger.error('"mako render" execution error - path=%s' % path)
                    self.logger_trace.error(traceback.format_exc())
                    raise web.internalerror("Execution errors")

        elif self.download.type == OUTPUT_TYPE_FILE: # file download
            if self.download.file is None or os.path.isfile(self.download.file) is False:
                self.logger.error('Could not find files to download. - path=%s' % self.download.file)
                return web.internalerror()
            web.header('Content-Type', 'Content-type: image/png', True)
            fp = open(self.download.file , "rb")
            try:
                _r = fp.read()
            finally:
                fp.close()

            if self.download.once is True and os.path.isfile(self.download.file) is True:
                os.unlink(self.download.file)

            return _r

        elif self.download.type == OUTPUT_TYPE_STREAM: # io stream download
            if self.download.stream is None:
                self.logger.error("Data stream has not been set.")
            return self.download.stream

        else:
            self.logger.error('Was specified assuming no output type. - type=%d' % self.download.type)
            raise web.internalerror()

    def POST(self, *param, **params):
        """<comment-ja>
        Method POSTの処理を行います。
          - オーバーロードPOSTに対応しています。
            - リクエストの中に _method を設定することで動作します。(POST,PUT,DELETE)
            - 例) <input type='hidden' name='_method' value='POST' />
          - 各処理は継承先で _POST メソッドを作成し、そこに記述してください。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        try:
            if web.input(_unicode=False).has_key(OVERLOAD_METHOD):
                self.__method__ = web.input(_unicode=False)[OVERLOAD_METHOD].upper()
                if self.__method__ == PUT:
                    self.__method__ = PUT
                    self.logger.debug("OVERLOAD - POST -> PUT")
                    return self.__method_call(*param, **params)
                elif self.__method__ == DELETE:
                    self.__method__ = DELETE
                    self.logger.debug("OVERLOAD - POST -> DELETE")
                    return self.__method_call(*param, **params)
                elif self.__method__ == GET:
                    self.__method__ = GET
                    self.logger.debug("OVERLOAD - POST -> GET")
                    return self.__method_call(*param, **params)

            # POST Method
            self.__method__ = POST    
            self._pre(*param, **params)
            _r = self.__method_call(prefix='_', *param, **params)
            return self._post(_r)
        except web.HTTPError, e:
            raise
        except:
            self.logger_trace.error(traceback.format_exc())
            #return web.internalerror()
            raise

    def GET(self, *param, **params):
        """<comment-ja>
        Method GETの処理を行います。
          - 各処理は継承先で _GET メソッドを作成し、そこに記述してください。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        try:
            self._pre(*param, **params)
            _r = self.__method_call(prefix='_', *param, **params)
            return self._post(_r)
        except web.HTTPError, e:
            raise
        except:
            self.logger_trace.error(traceback.format_exc())
            #return web.internalerror()
            raise

    def PUT(self, *param, **params):
        """<comment-ja>
        Method PUTの処理を行います。
          - 各処理は継承先で _PUT メソッドを作成し、そこに記述してください。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        try:
            self.__method__ = PUT
            self._pre(*param, **params)
            _r = self.__method_call(prefix='_', *param, **params)
            return self._post(_r)
        except web.HTTPError, e:
            raise
        except:
            self.logger_trace.error(traceback.format_exc())
            #return web.internalerror()
            raise
    
    def DELETE(self, *param, **params):
        """<comment-ja>
        Method DELETEの処理を行います。
          - 各処理は継承先で _DELETE メソッドを作成し、そこに記述してください。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        try:
            self.__method__ = DELETE
            self._pre(*param, **params)
            _r = self.__method_call(prefix='_', *param, **params)
            return self._post(_r)
        except web.HTTPError, e:
            raise
        except:
            self.logger_trace.error(traceback.format_exc())
            #return web.internalerror()
            raise

    def __method_call(self, *param, **params):
        """<comment-ja>
        各Methodを動的に呼び出します。
          - paramsに prefixを指定することができます。
            - 例) prefix='_' or prefix=''
          - 存在しないMethodの場合は web.nomethod() を返却します。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if params.has_key('prefix'):
            prefix = params.pop('prefix')
        else:
            prefix = ''

        try:
            if hasattr(self, prefix + self.__method__) is True:
                method = getattr(self, prefix + self.__method__)
                return method(*param, **params)
            else:
                self.logger.debug('%s : Method=%s - Not Method' %
                                  (str(self), self.__method__))
                self._ = mako_translation(languages=self.languages)
                return web.nomethod()
        except:
            self.logger.error("__method_call() error - prefix=%s languages=%s" \
                              % (str(prefix), str(self.languages)))
            raise
    ### --  util
    def is_mode_input(self):
        """<comment-ja>
        URLパラメタにmode=inputが存在するかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.__template__.media == 'input':
            return True
        else:
            return False

    def is_part(self):
        """<comment-ja>
        メディアがpartかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.__template__.media == 'part':
            return True
        else:
            return False

    def is_json(self):
        """<comment-ja>
        メディアがjsonかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.__template__.media == 'json':
            return True
        else:
            return False

    def is_html(self):
        """<comment-ja>
        メディアがhtmlかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.__template__.media == 'html':
            return True
        else:
            return False

    def is_xml(self):
        """<comment-ja>
        メディアがxmlかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.__template__.media == 'xml':
            return True
        else:
            return False

    def is_standalone(self):
        """<comment-ja>
        URLパラメタにstandalone=1が存在するかどうか。
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if self.is_mode_input() is True or self.is_part() is True and is_param(self.input, "standalone") and self.input.standalone == "1":
            return True
        else:
            return False

    def chk_hostby1(self, param):
        """<comment-ja>
        param[0] のホストIDの型とデータベースに存在しているかチェックする。

        @param param: rest#param
        @type param: dict
        @return: check ok : int(param[0]) || check ng : None
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if is_int(param[0]) is True:
            if is_findbyhost1(self.orm, param[0]) == 1:
                return int(param[0])
            else:
                return None
        else:
            return None

    def chk_guestby1(self, param):
        """<comment-ja>
        param[1] のゲストIDの型とデータベースに存在しているかチェックする。ゲストIDの親ホストIDもチェックする。

        @param param: rest#param
        @type param: dict
        @return: check ok : int(param[0]), int(param[1]) : check ng : None, None
        @rtype: bool
        </comment-ja>
        <comment-en>
        English Comment
        </comment-en>
        """
        if is_int(param[1]) is True:
            if is_findbyguest1(self.orm, param[1]) == 1:
                if not (self.chk_hostby1(param) is None):
                    return int(param[0]), int(param[1])
                else:
                    return None, None
            else:
                return None, None
        else:
            return None, None

# -- HTTP Response Code
class Unauthorized(web.HTTPError):
    """<comment-ja>
    401 Unauthorized errorクラス
    呼出は直接ではなく、karesansui.lib.rest.unauthorized を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, data='unauthorized'):
        if isinstance(data, list):
            data = "\n".join(data)

        global BASIC_REALM
        status = "401 Unauthorized"
        headers = {
            'Content-Type': 'text/html; charset=utf-8',
            'WWW-Authenticate': 'Basic realm="%s"' % BASIC_REALM
        }
        web.HTTPError.__init__(self, status, headers, data)
        
web.unauthorized = Unauthorized

class Conflict(web.HTTPError):
    """<comment-ja>
    409 Conflict errorクラス
    呼出は直接ではなく、karesansui.lib.rest.conflict を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, url, data='conflict'):
        if isinstance(data, list):
            data = "\n".join(data)

        status = "409 Conflict"
        headers = { 
            'Content-Type': 'text/html; charset=utf-8',
        }
        headers['Location'] = url
        web.HTTPError.__init__(self, status, headers, data)

web.conflict = Conflict

class Created(web.HTTPError):
    """<comment-ja>
    201 Created クラス
    呼出は直接ではなく、karesansui.lib.rest.created を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, url, data='created'):
        if isinstance(data, list):
            data = "\n".join(data)

        status = "201 Created"
        headers = {
            'Content-Type': 'text/html; charset=utf-8',
            'Location': url
        }
        web.HTTPError.__init__(self, status, headers, data)

web.created = Created

class Accepted(web.HTTPError):
    """<comment-ja>
    202 Accepted クラス
    呼出は直接ではなく、web.accepted を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, data='accepted', url=None):
        if isinstance(data, list):
            data = "\n".join(data)

        status = "202 Accepted"
        headers = {
                'Content-Type': 'text/html; charset=utf-8',
        }
        if url:
            headers['Location'] = url
        web.HTTPError.__init__(self, status, headers, data)

web.accepted = Accepted

class NoContent(web.HTTPError):
    """<comment-ja>
    204 No Content クラス
    呼出は直接ではなく、web.nocontent を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self):
        status = "204 No Content"
        headers = {
            'Content-Type': 'text/html; charset=utf-8',
        }
        web.HTTPError.__init__(self, status, headers)

web.nocontent = NoContent

#class RequestTimeout(web.HTTPError):
#    """<comment-ja>
#    408 Request Timeout クラス
#    呼出は直接ではなく、web.requesttimeout を利用してください。
#    </comment-ja>
#    <comment-en>
#    TODO: English Comment
#    </comment-en>
#    """
#    def __init__(self):
#        status = "408 Request Timeout"
#        web.HTTPError.__init__(self, status)
#
#web.requesttimeout = RequestTimeout

def NotFound(data = None):
    """<comment-ja>
    404 Not Found メソッド
    呼出は直接ではなく、web.notfound を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if isinstance(data, list):
        data = "\n".join(data)

    return web.NotFound(data)

web.notfound = NotFound

def InternalError(data = None):
    """<comment-ja>
    500 InternalError メソッド
    呼出は直接ではなく、web.internalerror を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if isinstance(data, list):
        data = "\n".join(data)

    return web.InternalError(data)

web.internalerror = InternalError

class BadRequest(web.HTTPError):
    """<comment-ja>
    400 Bad Request クラス
    呼出は直接ではなく、web.badrequest を利用してください。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    def __init__(self, data="bad request"):
        if isinstance(data, list):
            data = "\n".join(data)

        status = "400 Bad Request"
        headers = {'Content-Type': 'text/html'}
        web.HTTPError.__init__(self, status, headers, data)

web.badrequest = BadRequest

# -- Bacis Auth Decorator
def auth(func):
    """<comment-ja>
    Basic認証を行います。
      - 認証方式はDB認証
        - 認証に失敗した場合は、401 Unauthorizedなります。
        - 認証に成功すると、呼出元のクラスに me,languages,_ がセットされます。
          - me: ログインユーザ情報が設定されます。(karesansui.db.user.User)
          - languages: locale情報が設定されます。(左から評価されます)
          - _: 国際化メソッドが設定されます。( 使い方 : _('hoge') )
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """


    def wrapper(self, *args, **kwargs):

        if web.ctx.path[0:6] == '/data/':
            languages = unicode(karesansui.config['application.default.locale'])
            if web.ctx.env.has_key('HTTP_AUTHORIZATION'):
                _http_auth = web.ctx.env['HTTP_AUTHORIZATION'].strip()
                if _http_auth[:5] == 'Basic':
                    email, password = b64decode(_http_auth[6:].strip()).split(':')
                    session = web.ctx.orm
                    user = findby1email(session, email)
                    languages = user.languages

            self._ = mako_translation(languages=[ unicode(languages), ])
            return func(self, *args, **kwargs)

        if karesansui_database_exists() is False:
            return web.tempredirect(web.ctx.path + "init", absolute=False)

        if not web.ctx.env.has_key('HTTP_AUTHORIZATION'):
            if web.ctx.env.has_key('Authorization'):
                web.ctx.env['HTTP_AUTHORIZATION'] = web.ctx.env['Authorization']

        if web.ctx.env.has_key('HTTP_AUTHORIZATION'):
            (user, email) = login()

            if user:
                self.me = user

                # Logout
                fname = '%s%s' % (LOGOUT_FILE_PREFIX, self.me.email,)
                if os.access(fname, os.F_OK):
                    os.unlink(fname)
                    return web.unauthorized()

                # Login: Success
                if user.languages in self.languages:
                    x = self.languages.index(user.languages)
                    self.languages.pop(x)
                    
                self.languages.insert(0, user.languages)
                self.logger.info('user_id=%s,lang=%s : Method=%s - Basic Authentication=Success' %
                                  (self.me.id, ','.join(self.languages), self.__method__))
                
                # __init__#self._ update!!
                self._ = mako_translation(languages=self.languages)
                return func(self, *args, **kwargs)
            else:
                 # Login: Failure
                self.logger.info('user=%s : Method=%s - Basic Authentication=Failure' %
                                  (email, self.__method__))
                return web.unauthorized()
        else:
            # Login: Anonymous
            self.logger.info('user=anonymous : Method=%s - Basic Authentication=Anonymous' %
                              (self.__method__))
            return web.unauthorized()
        
    wrapper.__name__ = func.__name__
    wrapper.__dict__ = func.__dict__
    wrapper.__doc__ = func.__doc__
    return wrapper

# -- Basic Auth
def login():
    """<comment-ja>
    ログインチェックを行います。
    @return: ログインユーザ情報
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    _http_auth = web.ctx.env['HTTP_AUTHORIZATION'].strip()
    if _http_auth[:5] == 'Basic':
        email, password = b64decode(_http_auth[6:].strip()).split(':')
        session = web.ctx.orm
        user = dba_login(session, unicode(email), unicode(password))
        return (user, email)

# -- Template Engine
def mako_render(_, templatename, **kwargs):
    """<comment-ja>
    テンプレート実行結果の出力
    @param _: 国際化メソッド
    @type var: gettext.GNUTranslations
    @param templatename: テンプレート名
    @type templatename: str
    @param kwargs:
    @type kwargs:    
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    logger = logging.getLogger('karesansui.rest.mako')
    if templatename.startswith('static/') is True:
        directories = [karesansui.dirname, 'static', templatename[7:]]
        filepath = '/'.join(directories)
        logger.debug(filepath)

        fp = open(filepath, "r")
        try:
            return fp.read()
        finally:
            fp.close()

    else:
        directories = [karesansui.dirname, 'templates']
        if karesansui.config.has_key('application.template.theme'):
            directories.append(karesansui.config['application.template.theme'])
        else:
            directories.append('default')

    tl = TemplateLookup(directories='/'.join(directories),
                        input_encoding='utf-8',
                        output_encoding='utf-8',
                        default_filters=['decode.utf8'],
                        encoding_errors='replace')
    
    try:
        t = tl.get_template(templatename)
    except exceptions.TopLevelLookupException, tlle:
        logger.error('We could not find the template directory. - %s/%s'
                     % ('/'.join(directories), templatename))
        return web.notfound()
        
    logger.info('Template file path=%s' % t.filename)
    kwargs['_'] = _ # gettex
    
    view = {}
    if kwargs.has_key('view'):
        for x in kwargs['view'].keys():
            view[x] = kwargs['view'][x]
        kwargs.pop('view')
    kwargs.update(view)

    try:
        return t.render(**kwargs)
    except Exception, e:
        print >>sys.stderr, '[Error] failed to render. - %s' % ''.join(e.args)
        traceback.format_exc()
        raise

def mako_translation(languages, domain='messages', localedir='locale'):
    """<comment-ja>
    国際化処理
    @param languages: 対象言語
    @type languages: list
    @param domain: ドメイン名
    @type domain: str
    @param localedir: localeディレクトリ
    @type localedir: str
    @return: gettext.GNUTranslations
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    localedir = '/'.join([karesansui.dirname, localedir])
    return translation(domain, localedir, tuple(languages)).ugettext 

if __name__ == "__main__":
    pass

########NEW FILE########
__FILENAME__ = cpu
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def is_cpu_file_exist(rrd_dir, dev):
    ret = True
    dev = str(dev)

    rrd_filepath = ("%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "idle"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "interrupt"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "nice"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "user"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "wait"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "system"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "softirq"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, dev, "steal"),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def create_cpu_graph(_, lang, graph_dir, rrd_dir, start, end, dev=0, type=None):
    cpu_number = str(dev)
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "idle"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "interrupt"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "nice"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "user"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "wait"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "system"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "softirq"),
                    "%s/cpu-%s/cpu-%s.rrd" % (rrd_dir, cpu_number, "steal"),
                    )

    for filename in rrd_filepath:
        if is_readable(filename) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                     %s       %s       %s       %s</tt>" % (legend_header_label['min'],
                                                                                     legend_header_label['max'],
                                                                                     legend_header_label['ave'],
                                                                                     legend_header_label['last']
                                                                                     )
    title = "<tt>CPU-%s</tt>" % (str(cpu_number))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", "jiffies",
                         "--units-length", "2",
                         "--upper-limit", "100",
                         "--lower-limit", "0",
                         "--rigid",
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:idle=%s:value:AVERAGE" % (rrd_filepath[0]),
                         "DEF:interrupt=%s:value:AVERAGE" % (rrd_filepath[1]),
                         "DEF:nice=%s:value:AVERAGE" % (rrd_filepath[2]),
                         "DEF:user=%s:value:AVERAGE" % (rrd_filepath[3]),
                         "DEF:wait=%s:value:AVERAGE" % (rrd_filepath[4]),
                         "DEF:system=%s:value:AVERAGE" % (rrd_filepath[5]),
                         "DEF:softirq=%s:value:AVERAGE" % (rrd_filepath[6]),
                         "DEF:steal=%s:value:AVERAGE" % (rrd_filepath[7]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         # TRANSLATORS:
                         #  CPUのグラフの凡例
                         #  日本語にした場合は表示が崩れますが、後で直すのでそのままで大丈夫です
                         "AREA:steal#FDFF6A:<tt>%s       </tt>" % (_('Steal').encode("utf-8")),
                         "GPRINT:steal:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:steal:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:steal:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:steal:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:interrupt#F7FF13:<tt>%s   </tt>" % (_('Interrupt').encode("utf-8")),
                         "GPRINT:interrupt:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:interrupt:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:interrupt:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:interrupt:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:softirq#E7EF00:<tt>%s     </tt>" % (_('SoftIRQ').encode("utf-8")),
                         "GPRINT:softirq:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:softirq:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:softirq:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:softirq:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:system#B5F100:<tt>%s      </tt>" % (_('System').encode("utf-8")),
                         "GPRINT:system:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:system:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:system:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:system:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:wait#B3EF00:<tt>%s   </tt>" % (_('Wait - IO').encode("utf-8")),
                         "GPRINT:wait:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:wait:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:wait:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:wait:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:user#95C700:<tt>%s       </tt>" % (_('User').encode("utf-8")),
                         "GPRINT:user:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:user:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:user:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:user:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:nice#80AA00:<tt>%s        </tt>" % (_('Nice').encode("utf-8")),
                         "GPRINT:nice:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:nice:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:nice:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:nice:LAST:<tt>%8.2lf</tt>\\n",
                         "STACK:idle#FFFFFF:<tt>%s        </tt>" % (_('Idle').encode("utf-8")),
                         "GPRINT:idle:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:idle:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:idle:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:idle:LAST:<tt>%8.2lf</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = df
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def is_df_file_exist(rrd_dir, dev):
    ret = True

    rrd_filepath = ("%s/df/df-%s.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def create_df_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type=None):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/df/df-%s.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                 %s        %s        %s        %s</tt>" % (legend_header_label['min'],
                                                                                    legend_header_label['max'],
                                                                                    legend_header_label['ave'],
                                                                                    legend_header_label['last']
                                                                                    )
    title = "<tt>%s</tt>" % (dev)

    legend = {"used" : _('Used'),
              "free" : _('Free'),
              }

    reg = re.compile(u"[^a-zA-Z0-9_\-\. ]")
    for key in legend.keys():
        if key == "used":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s<tt>" % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s" % (legend[key].encode("utf-8"))
        elif key == "free":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s <tt>" % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s" % (legend[key].encode("utf-8"))
        else:
            legend[key] = "%s" % (legend[key].encode("utf-8"))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", _('Bytes').encode("utf-8"),
                         "--lower-limit", "0",
                         "--rigid",
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:used=%s:used:AVERAGE" % (rrd_filepath[0]),
                         "DEF:free=%s:free:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         # TRANSLATORS:
                         #  ディスク容量のグラフの縦軸のラベル
                         #  日本語にした場合は表示が崩れますが、後で直すのでそのままで大丈夫です
                         "AREA:used#80AA00:<tt>%s    </tt>" % (legend['used']),
                         "GPRINT:used:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:used:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:used:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:used:LAST:<tt>%8.2lf%s</tt>\\n",
                         "STACK:free#FFFFFF:<tt>%s    </tt>" % (legend['free']),
                         "GPRINT:free:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:free:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:free:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:free:LAST:<tt>%8.2lf%s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = disk
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def is_disk_file_exist(rrd_dir, dev):
    ret = True

    rrd_filepath = ("%s/disk-%s/disk_merged.rrd" % (rrd_dir, dev),
                    "%s/disk-%s/disk_octets.rrd" % (rrd_dir, dev),
                    "%s/disk-%s/disk_ops.rrd" % (rrd_dir, dev),
                    "%s/disk-%s/disk_time.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def create_disk_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/disk-%s/disk_%s.rrd" % (rrd_dir, dev, type),
                    )

    # TRANSLATORS:
    #  ディスク性能のグラフの縦軸のラベル
    #  /proc/diskstatsの値をとってきているらしいです
    #  よく分からないので、公式HPの説明をコピペしておきます
    #
    #    "merged" are the number of operations, that could be merged into other, already queued operations, i. e. one physical disk access served two or more logical operations. Of course, the higher that number, the better.
    #    "time" is the average time an I/O-operation took to complete. Since this is a little messy to calculate take the actual values with a grain of salt.
    graph_label = {
        "merged":_("Merged Ops / sec").encode("utf-8"),
        "octets":_("Bytes / sec").encode("utf-8"),
        "ops":_("Ops / sec").encode("utf-8"),
        "time":_("Seconds / op").encode("utf-8"),
        }

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                  %s        %s        %s        %s</tt>" % (legend_header_label['min'],
                                                                                     legend_header_label['max'],
                                                                                     legend_header_label['ave'],
                                                                                     legend_header_label['last']
                                                                                     )

    legend_label = {"read":_('Read'),
                    "write":_('Write'),
                    }
    for key in legend_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_label[key]):
            legend_label[key] = "</tt>%s<tt>" % (legend_label[key].encode("utf-8"))
        else:
            if key == "read":
                legend_label[key] = "%s " % (legend_label[key].encode("utf-8"))
            else:
                legend_label[key] = "%s" % (legend_label[key].encode("utf-8"))

    title = "<tt>%s/disk_%s</tt>" % (dev,type)

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", graph_label[type],
                         "--lower-limit", "0",
                         "--rigid",
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:read=%s:read:AVERAGE" % (rrd_filepath[0]),
                         "DEF:write=%s:write:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "AREA:read#E7EF00:<tt>%s    </tt>" % legend_label["read"],
                         "GPRINT:read:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:LAST:<tt>%8.2lf%s</tt>\\n",
                         "STACK:write#80AA00:<tt>%s    </tt>" % legend_label["write"],
                         "GPRINT:write:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:LAST:<tt>%8.2lf%s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         "LINE1:read#E7EF00",
                         "STACK:write#80AA00",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = interface
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def is_interface_file_exist(rrd_dir, dev):
    ret = True

    rrd_filepath = ("%s/interface/if_packets-%s.rrd" % (rrd_dir, dev),
                    "%s/interface/if_octets-%s.rrd" % (rrd_dir, dev),
                    "%s/interface/if_errors-%s.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def create_interface_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/interface/if_%s-%s.rrd" % (rrd_dir, type, dev),
                    )
    # TRANSLATORS:
    #  ネットワークのグラフのタイトル
    graph_title = {
        "packets":"%%s - %s" % (_('Packets').encode("utf-8")),
        "octets":"%%s - %s" % (_('Traffic').encode("utf-8")),
        "errors":"%%s - %s" % (_('Errors').encode("utf-8")),
        }

    # TRANSLATORS:
    #  ネットワークのグラフの縦軸のラベル
    #    packetsは1秒あたりのパケット数
    #    octetsは1秒あたりのバイト数
    #    errorsは1秒あたりのエラーパケット数
    graph_label = {
        "packets":_("Packets / sec").encode("utf-8"),
        "octets":_("Octets / sec").encode("utf-8"),
        "errors":_("Packets / sec").encode("utf-8"),
        }

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>             %s        %s        %s        %s</tt>" % (legend_header_label['min'],
                                                                                legend_header_label['max'],
                                                                                legend_header_label['ave'],
                                                                                legend_header_label['last']
                                                                                )

    legend_label = {"rx":_('RX'),
                    "tx":_('TX'),
                    }
    for key in legend_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_label[key]):
            legend_label[key] = "</tt>%s<tt>" % (legend_label[key].encode("utf-8"))
        else:
            legend_label[key] = "%s" % (legend_label[key].encode("utf-8"))

    title = "<tt>%s</tt>" % (graph_title[type] % (dev))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", graph_label[type],
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:rx=%s:rx:AVERAGE" % (rrd_filepath[0]),
                         "DEF:tx=%s:tx:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "AREA:rx#E7EF00:<tt>%s  </tt>" % (legend_label["rx"]),
                         "GPRINT:rx:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:LAST:<tt>%8.2lf%s</tt>\\n",
                         "STACK:tx#80AA00:<tt>%s  </tt>" % (legend_label["tx"]),
                         "GPRINT:tx:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:LAST:<tt>%8.2lf%s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         "LINE1:rx#E7EF00",
                         "STACK:tx#80AA00",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = libvirt
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def is_libvirt_cpu_file_exist(rrd_dir, dev):
    ret = True

    if dev == "total":
        rrd_filepath = ("%s/libvirt/virt_cpu_total.rrd" % (rrd_dir),
                        )
    else:
        rrd_filepath = ("%s/libvirt/virt_vcpu-%s.rrd" % (rrd_dir, dev),
                        )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def is_libvirt_disk_file_exist(rrd_dir, dev):
    ret = True

    rrd_filepath = ("%s/libvirt/disk_octets-%s.rrd" % (rrd_dir, dev),
                    "%s/libvirt/disk_ops-%s.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def is_libvirt_interface_file_exist(rrd_dir, dev):
    ret = True

    rrd_filepath = ("%s/libvirt/if_packets-%s.rrd" % (rrd_dir, dev),
                    "%s/libvirt/if_octets-%s.rrd" % (rrd_dir, dev),
                    "%s/libvirt/if_errors-%s.rrd" % (rrd_dir, dev),
                    "%s/libvirt/if_dropped-%s.rrd" % (rrd_dir, dev),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            ret = False

    return ret

def create_libvirt_cpu_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    if dev == "total":
        rrd_filepath = ("%s/libvirt/virt_cpu_total.rrd" % (rrd_dir),
                        )
    else:
        rrd_filepath = ("%s/libvirt/virt_vcpu-%s.rrd" % (rrd_dir, dev),
                        )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                   %s       %s       %s       %s</tt>" % (legend_header_label['min'],
                                                                                  legend_header_label['max'],
                                                                                  legend_header_label['ave'],
                                                                                  legend_header_label['last']
                                                                                  )
    title = "<tt>%s - CPU-%s</tt>" % (rrd_dir.split('/')[-1], dev)

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         # TRANSLATORS:
                         #  仮想マシンのグラフのCPUグラフの縦軸のラベル
                         #   単位はCPU時間(秒)です
                         "--vertical-label", _('Seconds').encode("utf-8"),
                         "--units-exponent", "0",
                         "--alt-y-grid",
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:ns=%s:ns:AVERAGE" % (rrd_filepath[0]),
                         "CDEF:s=ns,1000,1000,1000,*,*,/",
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         # TRANSLATORS:
                         #  仮想マシンのグラフのCPUグラフの凡例
                         "AREA:s#80AA00:<tt>%s    </tt>" % (_('Seconds').encode("utf-8")),
                         "GPRINT:s:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:s:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:s:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:s:LAST:<tt>%8.2lf</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         "LINE1:s#80AA00",
                         )

    return graph_filepath

def create_libvirt_disk_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/libvirt/disk_%s-%s.rrd" % (rrd_dir, type, dev),
                    )

    graph_title = {
        "octets":"%s - %s",
        "ops":"%s - %s",
        }

    # TRANSLATORS:
    #  仮想マシンのグラフのディスクグラフの縦軸のラベル
    graph_label = {
        "octets":_('Bytes / sec').encode("utf-8"),
        "ops":_('Ops / sec').encode("utf-8"),
        }

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                  %s        %s        %s        %s</tt>" % (legend_header_label['min'],
                                                                                    legend_header_label['max'],
                                                                                    legend_header_label['ave'],
                                                                                    legend_header_label['last']
                                                                                     )
    legend_label = {"read":_('Read'),
                    "write":_('Write'),
                    }
    for key in legend_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_label[key]):
            legend_label[key] = "</tt>%s<tt>" % (legend_label[key].encode("utf-8"))
        else:
            if key == "read":
                legend_label[key] = "%s " % (legend_label[key].encode("utf-8"))
            else:
                legend_label[key] = "%s" % (legend_label[key].encode("utf-8"))

    title = "<tt>%s - %s</tt>" % (rrd_dir.split('/')[-1], graph_title[type] % (dev, type))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", graph_label[type],
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:read=%s:read:AVERAGE" % (rrd_filepath[0]),
                         "DEF:write=%s:write:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "AREA:read#E7EF00:<tt>%s    </tt>" % (legend_label["read"]),
                         "GPRINT:read:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:read:LAST:<tt>%8.2lf%s</tt>\\n",
                         "STACK:write#80AA00:<tt>%s    </tt>" % (legend_label["write"]),
                         "GPRINT:write:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:write:LAST:<tt>%8.2lf%s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         "LINE1:read#E7EF00",
                         "STACK:write#80AA00",
                         )

    return graph_filepath

def create_libvirt_interface_graph(_, lang, graph_dir, rrd_dir, start, end, dev, type):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/libvirt/if_%s-%s.rrd" % (rrd_dir, type, dev),
                    )

    # TRANSLATORS:
    #  仮想マシンのグラフのネットワークグラフのタイトル
    graph_title = {
        "packets":"%%s - %s" % (_('Packets').encode("utf-8")),
        "octets":"%%s - %s" % (_('Traffic').encode("utf-8")),
        "errors":"%%s - %s" % (_('Errors').encode("utf-8")),
        "dropped":"%%s - %s" % (_('Dropped').encode("utf-8")),
        }

    # TRANSLATORS:
    #  仮想マシンのグラフのネットワークグラフの縦軸のラベル
    #    packetsは1秒あたりのパケット数
    #    octetsは1秒あたりのバイト数
    #    errorsは1秒あたりのエラーパケット数
    #    droppedは1秒あたりのパケットドロップ数
    graph_label = {
        "packets":_("Packets / sec").encode("utf-8"),
        "octets":_("Octets / sec").encode("utf-8"),
        "errors":_("Packets / sec").encode("utf-8"),
        "dropped":_("Packets / sec").encode("utf-8"),
        }

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>               %s        %s        %s        %s</tt>" % (legend_header_label['min'],
                                                                                    legend_header_label['max'],
                                                                                    legend_header_label['ave'],
                                                                                    legend_header_label['last']
                                                                                    )

    legend_label = {"rx":_('RX'),
                    "tx":_('TX'),
                    }
    for key in legend_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_label[key]):
            legend_label[key] = "</tt>%s<tt>" % (legend_label[key].encode("utf-8"))
        else:
            legend_label[key] = "%s" % (legend_label[key].encode("utf-8"))

    title = "<tt>%s - %s</tt>" % (rrd_dir.split('/')[-1], graph_title[type] % (dev))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", graph_label[type],
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:rx=%s:rx:AVERAGE" % (rrd_filepath[0]),
                         "DEF:tx=%s:tx:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "AREA:rx#E7EF00:<tt>%s    </tt>" % (legend_label["rx"]),
                         "GPRINT:rx:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:rx:LAST:<tt>%8.2lf%s</tt>\\n",
                         "STACK:tx#80AA00:<tt>%s    </tt>" % (legend_label["tx"]),
                         "GPRINT:tx:MIN:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:MAX:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:AVERAGE:<tt>%8.2lf%s</tt>",
                         "GPRINT:tx:LAST:<tt>%8.2lf%s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         "LINE1:rx#E7EF00",
                         "STACK:tx#80AA00",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = load
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def create_load_graph(_, lang, graph_dir, rrd_dir, start, end, dev=None, type=None):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/load/load.rrd" % (rrd_dir),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                    %s       %s       %s       %s</tt>" % (legend_header_label['min'],
                                                                                       legend_header_label['max'],
                                                                                       legend_header_label['ave'],
                                                                                       legend_header_label['last']
                                                                                       )

    title = _('Load Average')
    if re.search(u"[^a-zA-Z0-9_\-\. ]", title):
        title = "%s" % (title.encode("utf-8"))
    else:
        title = "<tt>%s</tt>" % (title.encode("utf-8"))

    # TRANSLATORS:
    #   ロードアベレージのグラフの凡例
    legend = {"1m":_('1m Average'),
              "5m":_('5m Average'),
              "15m":_('15m Average'),
              }
    for key in legend.keys():
        if re.search(u"[^a-zA-Z0-9_\-\. ]", legend[key]):
            legend[key] = "</tt>%s   <tt>" % (legend[key].encode("utf-8"))
        else:
            legend[key] = "%s" % (legend[key].encode("utf-8"))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", _('System load').encode("utf-8"),
                         "--start", start,
                         "--end",  end,
                         "--units-exponent", "0",
                         #"--legend-direction", "bottomup",
                         "DEF:shortterm=%s:shortterm:AVERAGE" % (rrd_filepath[0]),
                         "DEF:midterm=%s:midterm:AVERAGE" % (rrd_filepath[0]),
                         "DEF:longterm=%s:longterm:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "LINE:shortterm#E7EF00:<tt>%s </tt>" % (legend["1m"]),
                         "GPRINT:shortterm:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:shortterm:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:shortterm:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:shortterm:LAST:<tt>%8.2lf</tt>\\n",
                         "LINE:midterm#B3EF00:<tt>%s </tt>" % (legend["5m"]),
                         "GPRINT:midterm:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:midterm:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:midterm:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:midterm:LAST:<tt>%8.2lf</tt>\\n",
                         "LINE:longterm#80AA00:<tt>%s</tt>" % (legend["15m"]),
                         "GPRINT:longterm:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:longterm:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:longterm:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:longterm:LAST:<tt>%8.2lf</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = memory
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def create_memory_graph(_, lang, graph_dir, rrd_dir, start, end, dev=None, type=None):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = '%s/%s' % (graph_dir, graph_filename)

    rrd_filepath = ("%s/memory/memory-%s.rrd" % (rrd_dir, "free"),
                    "%s/memory/memory-%s.rrd" % (rrd_dir, "cached"),
                    "%s/memory/memory-%s.rrd" % (rrd_dir, "buffered"),
                    "%s/memory/memory-%s.rrd" % (rrd_dir, "used"),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                      %s         %s         %s         %s</tt>" % (legend_header_label['min'],
                                                                                            legend_header_label['max'],
                                                                                            legend_header_label['ave'],
                                                                                            legend_header_label['last']
                                                                                            )

    title = _('Memory')
    if re.search(u"[^a-zA-Z0-9_\-\. ]", title):
        title = "%s" % (title.encode("utf-8"))
    else:
        title = "<tt>%s</tt>" % (title.encode("utf-8"))

    legend = {"used"     : _('Used'),
              "buffered" : _('Buffered'),
              "cached"   : _('Cached'),
              "free"     : _('Free'),
              }

    reg = re.compile(u"[^a-zA-Z0-9_\-\. ]")
    for key in legend.keys():
        if key == "used":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s　　　<tt>    " % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s        " % (legend[key].encode("utf-8"))
        elif key == "buffered":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s　<tt>     " % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s    " % (legend[key].encode("utf-8"))
        elif key == "cached":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s<tt>     " % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s      " % (legend[key].encode("utf-8"))
        elif key == "free":
            if reg.search(legend[key]):
                legend[key] = "</tt>%s　　　<tt>     " % (legend[key].encode("utf-8"))
            else:
                legend[key] = "%s        " % (legend[key].encode("utf-8"))
        else:
            legend[key] = "%s" % (legend[key].encode("utf-8"))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         "--vertical-label", _('Bytes').encode("utf-8"),
                         "--lower-limit", "0",
                         "--rigid",
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:free=%s:value:AVERAGE" % (rrd_filepath[0]),
                         "DEF:cached=%s:value:AVERAGE" % (rrd_filepath[1]),
                         "DEF:buffered=%s:value:AVERAGE" % (rrd_filepath[2]),
                         "DEF:used=%s:value:AVERAGE" % (rrd_filepath[3]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         # TRANSLATORS:
                         #  メモリのグラフの項目名
                         #  日本語にした場合は表示が崩れますが、後で直すのでそのままで大丈夫です
                         "AREA:used#80AA00:<tt>%s</tt>" % (legend['used']),
                         "GPRINT:used:MIN:<tt>%8.1lf %s</tt>",
                         "GPRINT:used:MAX:<tt>%8.1lf %s</tt>",
                         "GPRINT:used:AVERAGE:<tt>%8.1lf %s</tt>",
                         "GPRINT:used:LAST:<tt>%8.1lf %s</tt>\\n",
                         "STACK:buffered#E7EF00:<tt>%s</tt>" % (legend['buffered']),
                         "GPRINT:buffered:MIN:<tt>%8.1lf %s</tt>",
                         "GPRINT:buffered:MAX:<tt>%8.1lf %s</tt>",
                         "GPRINT:buffered:AVERAGE:<tt>%8.1lf %s</tt>",
                         "GPRINT:buffered:LAST:<tt>%8.1lf %s</tt>\\n",
                         "STACK:cached#B3EF00:<tt>%s</tt>" % (legend['cached']),
                         "GPRINT:cached:MIN:<tt>%8.1lf %s</tt>",
                         "GPRINT:cached:MAX:<tt>%8.1lf %s</tt>",
                         "GPRINT:cached:AVERAGE:<tt>%8.1lf %s</tt>",
                         "GPRINT:cached:LAST:<tt>%8.1lf %s</tt>\\n",
                         "STACK:free#FFFFFF:<tt>%s</tt>" % (legend['free']),
                         "GPRINT:free:MIN:<tt>%8.1lf %s</tt>",
                         "GPRINT:free:MAX:<tt>%8.1lf %s</tt>",
                         "GPRINT:free:AVERAGE:<tt>%8.1lf %s</tt>",
                         "GPRINT:free:LAST:<tt>%8.1lf %s</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = rrd
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import os

import karesansui
from karesansui.lib.rrd.cpu       import create_cpu_graph, is_cpu_file_exist
from karesansui.lib.rrd.memory    import create_memory_graph
from karesansui.lib.rrd.df        import create_df_graph, is_df_file_exist
from karesansui.lib.rrd.disk      import create_disk_graph, is_disk_file_exist
from karesansui.lib.rrd.interface import create_interface_graph, is_interface_file_exist
from karesansui.lib.rrd.load      import create_load_graph
from karesansui.lib.rrd.uptime    import create_uptime_graph
from karesansui.lib.rrd.users     import create_users_graph
from karesansui.lib.rrd.libvirt   import create_libvirt_cpu_graph, \
                                         create_libvirt_disk_graph, \
                                         create_libvirt_interface_graph, \
                                         is_libvirt_cpu_file_exist, \
                                         is_libvirt_disk_file_exist, \
                                         is_libvirt_interface_file_exist

from karesansui.lib.const import COLLECTD_DATA_DIR, KARESANSUI_TMP_DIR
from karesansui.lib.utils import get_hostname, locale_dummy

class RRD:
    _graph_dir = KARESANSUI_TMP_DIR
    _rrd_dir = "%s/%s" % (COLLECTD_DATA_DIR, get_hostname())
    _lang = "en_US"
    _ = None

    def __init__(self, locale=None, lang=None, graph_dir=None, rrd_dir=None):
        if locale is not None:
            self.set_locale(locale)
        else:
            self._ = locale_dummy

        if lang is not None:
            self.set_lang(lang)

        if graph_dir is not None:
            self.set_graph_dir(graph_dir)

        if rrd_dir is not None:
            self.set_rrd_dir(rrd_dir)

    def get_graph_dir(self):
        return self._graph_dir

    def get_rrd_dir(self):
        return self._rrd_dir

    def get_locale(self):
        return self._

    def get_lang(self):
        return self._lang

    def set_graph_dir(self, path):
        ret = False
        if os.path.isdir(path) is True:
            self._graph_dir = path
            ret = True
        return ret

    def set_rrd_dir(self, path):
        ret = False
        if os.path.isdir(path) is True:
            self._rrd_dir = path
            ret = True
        return ret

    def set_rrd_dir_host(self, host):
        ret = False
        rrd_dir = "%s/%s" % (COLLECTD_DATA_DIR, str(host))
        if os.path.isdir(rrd_dir) is True:
            self._rrd_dir = rrd_dir
            ret = True
        return ret

    def set_locale(self, locale):
        ret = False
        if locale is not None:
            self._ = locale
            ret = True
        return ret

    def set_lang(self, lang):
        ret = False
        if lang is not None:
            self._lang = lang
            ret = True
        return ret

    def check_rrd_file_exist(self, target, dev, libvirt_target=None):
        ret = False

        if target == "cpu":
            ret = is_cpu_file_exist(self._rrd_dir, dev)
        elif target == "df":
            ret = is_df_file_exist(self._rrd_dir, dev)
        elif target == "disk":
            ret = is_disk_file_exist(self._rrd_dir, dev)
        elif target == "interface":
            ret = is_interface_file_exist(self._rrd_dir, dev)
        elif target == "libvirt":
            if libvirt_target == "vcpu":
                ret = is_libvirt_cpu_file_exist(self._rrd_dir, dev)
            elif libvirt_target == "disk":
                ret = is_libvirt_disk_file_exist(self._rrd_dir, dev)
            elif libvirt_target == "interface":
                ret = is_libvirt_interface_file_exist(self._rrd_dir, dev)

        return ret

    def create_graph(self, target, dev, type, start, end, libvirt_target=None):
        target = str(target)
        dev    = str(dev)
        type   = str(type)
        start  = str(start)
        end    = str(end)

        filepath = ""
        if target == "cpu":
            filepath = create_cpu_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "memory":
            filepath = create_memory_graph(self._, self._lang,  self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "df":
            filepath = create_df_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "disk":
            filepath = create_disk_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "interface":
            filepath = create_interface_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "load":
            filepath = create_load_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "uptime":
            filepath = create_uptime_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "users":
            filepath = create_users_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
        elif target == "libvirt":
            if libvirt_target == "vcpu":
                filepath = create_libvirt_cpu_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
            elif libvirt_target == "disk":
                filepath = create_libvirt_disk_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)
            elif libvirt_target == "interface":
                filepath = create_libvirt_interface_graph(self._, self._lang, self._graph_dir, self._rrd_dir, start, end, dev, type)

        return filepath

########NEW FILE########
__FILENAME__ = uptime
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import rrdtool
import datetime
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def create_uptime_graph(_, lang, graph_dir, rrd_dir, start, end, dev=None, type=None):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/uptime/uptime.rrd" % (rrd_dir),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "   %s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                          %s</tt>" % (legend_header_label['last'])

    # TRANSLATORS:
    #   起動時間のグラフの凡例
    legend_label = {"uptime":_('uptime'),
                    "day":_('days'),
                    "hour":_('hours'),
                    "minute":_('mins'),
                    }

    for key in legend_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_label[key]):
            legend_label[key] = "</tt>%s<tt>" % (legend_label[key].encode("utf-8"))
        else:
            legend_label[key] = "%s" % (legend_label[key].encode("utf-8"))

    # TRANSLATORS:
    #  起動時間のグラフのタイトル
    title = _('Uptime')
    if re.search(u"[^a-zA-Z0-9_\-\.]", title):
        title = "%s" % (title.encode("utf-8"))
    else:
        title = "<tt>%s</tt>" % (title.encode("utf-8"))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         # TRANSLATORS:
                         #  起動時間のグラフの縦軸のラベル
                         "--vertical-label", _('Days').encode("utf-8"),
                         "--lower-limit", "0",
                         "--rigid",
                         "--start", start,
                         "--end",  end,
                         "--alt-autoscale",
                         #"--legend-direction", "bottomup",
                         "DEF:uptime=%s:value:AVERAGE" % (rrd_filepath[0]),
                         "CDEF:day=uptime,86400,/",
                         "CDEF:hour=uptime,86400,%,3600,/",
                         "CDEF:minute=uptime,3600,%,60,/",
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         "AREA:day#80AA00:<tt>%s    </tt>" % (legend_label["uptime"]),
                         "GPRINT:day:LAST:<tt>%%6.0lf %s</tt>" % (legend_label["day"]),
                         "GPRINT:hour:LAST:<tt>%%2.0lf %s</tt>" % (legend_label["hour"]),
                         "GPRINT:minute:LAST:<tt>%%2.0lf %s</tt>\\n" % (legend_label["minute"]),
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = users
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import re
import datetime
import rrdtool
import karesansui
from karesansui.lib.const import GRAPH_COMMON_PARAM, DEFAULT_LANGS
from karesansui.lib.utils import is_readable, generate_phrase

def create_users_graph(_, lang, graph_dir, rrd_dir, start, end, dev=None, type=None):
    graph_filename = "%s.png" % (generate_phrase(12,'abcdefghijklmnopqrstuvwxyz'))
    graph_filepath = "%s/%s" % (graph_dir, graph_filename)

    rrd_filepath = ("%s/users/users.rrd" % (rrd_dir),
                    )

    for filepath in rrd_filepath:
        if is_readable(filepath) is False:
            return ""

    legend_header_label = {"min":_('Min'),
                           "max":_('Max'),
                           "ave":_('Ave'),
                           "last":_('Last'),
                           }

    for key in legend_header_label.keys():
        if re.search(u"[^a-zA-Z0-9]", legend_header_label[key]):
            legend_header_label[key] = "</tt>%s<tt>" % (legend_header_label[key].encode("utf-8"))
        else:
            legend_header_label[key] = "%s" % (legend_header_label[key].encode("utf-8"))

    legend_header = "<tt>                 %s       %s       %s       %s</tt>" % (legend_header_label['min'],
                                                                                legend_header_label['max'],
                                                                                legend_header_label['ave'],
                                                                                legend_header_label['last']
                                                                                )
    # TRANSLATORS:
    #  ユーザ数のグラフのタイトル
    title = _('Users Logged In')
    if re.search(u"[^a-zA-Z0-9_\-\.]", title):
        title = "%s" % (title.encode("utf-8"))
    else:
        title = "<tt>%s</tt>" % (title.encode("utf-8"))

    created_label = _('Graph created')
    if re.search(u"[^a-zA-Z0-9 ]", created_label):
        created_label = "</tt>%s<tt>" % (created_label.encode("utf-8"))
    else:
        created_label = "%s" % (created_label.encode("utf-8"))

    created_time = "%s" % (datetime.datetime.today().strftime(DEFAULT_LANGS[lang]['DATE_FORMAT'][1]))
    created_time = re.sub(r':', '\:', created_time)

    legend_footer = "<tt>%s \: %s</tt>" % (created_label, created_time)

    data = rrdtool.graph(graph_filepath,
    "--imgformat", "PNG",
    "--font", "TITLE:0:IPAexGothic",
    "--font", "LEGEND:0:IPAexGothic",
    "--pango-markup",
    "--width", "550",
    "--height", "350",
    "--full-size-mode",
    "--color", "BACK#FFFFFF",
    "--color", "CANVAS#FFFFFF",
    "--color", "SHADEA#FFFFFF",
    "--color", "SHADEB#FFFFFF",
    "--color", "GRID#DDDDDD",
    "--color", "MGRID#CCCCCC",
    "--color", "FONT#555555",
    "--color", "FRAME#FFFFFF",
    "--color", "ARROW#FFFFFF",
                         "--title", title,
                         # TRANSLATORS:
                         #   ユーザ数のグラフの縦軸のラベル
                         "--vertical-label", _('Users ').encode("utf-8"),
                         "--start", start,
                         "--end",  end,
                         #"--legend-direction", "bottomup",
                         "DEF:users=%s:users:AVERAGE" % (rrd_filepath[0]),
                         "COMMENT:%s\\r" % legend_footer,
                         "COMMENT:<tt>---------------------------------------------------------------------------</tt>\\n",
                         # TRANSLATORS:
                         #   ユーザ数のグラフの凡例
                         "AREA:users#80AA00:<tt>%s    </tt>" % (_('Users').encode("utf-8")),
                         "GPRINT:users:MIN:<tt>%8.2lf</tt>",
                         "GPRINT:users:MAX:<tt>%8.2lf</tt>",
                         "GPRINT:users:AVERAGE:<tt>%8.2lf</tt>",
                         "GPRINT:users:LAST:<tt>%8.2lf</tt>\\n",
                         "COMMENT:%s\\n" % (legend_header),
                         "COMMENT: \\n",
                         )

    return graph_filepath

########NEW FILE########
__FILENAME__ = search
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui.lib.checker import Checker, \
    CHECK_EMPTY, CHECK_VALID, CHECK_LENGTH, CHECK_ONLYSPACE
from karesansui.lib.const import SEARCH_MIN_LENGTH, SEARCH_MAX_LENGTH, \
    MACHINE_NAME_MIN_LENGTH, MACHINE_NAME_MAX_LENGTH, \
    USER_MIN_LENGTH, USER_MAX_LENGTH
from karesansui.db.model._2pysilhouette import JOBGROUP_STATUS
from karesansui.lib.utils import is_param

def validates_query(obj):
    checker = Checker()
    check = True

    _ = obj._
    checker.errors = []

    if is_param(obj.input, 'q'):
        check = checker.check_string(_('Search Query'),
                obj.input.q,
                CHECK_EMPTY | CHECK_LENGTH | CHECK_VALID,
                '[%_]',
                min = SEARCH_MIN_LENGTH,
                max = SEARCH_MAX_LENGTH,
                ) and check

    obj.view.alert = checker.errors
    return check

def validates_jobsearch(obj):
    checker = Checker()
    _ = obj._
    checker.errors = []
    
    check = True
    edit = False
    
    if is_param(obj.input, "name", True) is True:
        edit = True
        check = checker.check_string(
            _('Machine Name'),
            obj.input.name,
            CHECK_LENGTH | CHECK_ONLYSPACE | CHECK_VALID,
            '[%_]',
            min = MACHINE_NAME_MIN_LENGTH,
            max = MACHINE_NAME_MAX_LENGTH,
            ) and check

    if is_param(obj.input, "user", True) is True:
        edit = True
        check = checker.check_string(
            _('Create User'),
            obj.input.user,
            CHECK_LENGTH | CHECK_ONLYSPACE | CHECK_VALID,
            '[%_]',
            min = USER_MIN_LENGTH,
            max = USER_MAX_LENGTH,
            ) and check

    if is_param(obj.input, "status", True) is True:
        edit = True
        check = checker.check_status(
            _('Status'), 
            obj.input.status, 
            CHECK_VALID, 
            JOBGROUP_STATUS.values()
            ) and check

    if is_param(obj.input, "start", True) is True:
        edit = True
        check = checker.check_datetime_string(
            _('Created'),
            obj.input.start,
            CHECK_VALID,
            obj.me.languages
            ) and check
            
    if is_param(obj.input, "end", True) is True:
        edit = True
        check = checker.check_datetime_string(
            _('Created'),
            obj.input.end,
            CHECK_VALID,
            obj.me.languages
            ) and check

    obj.view.alert = checker.errors
    return check, edit


########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
</comment-ja>
<comment-en>
Generate configuration file of service.xml.
</comment-en>

@file:   config.py

@author: Kei Funagayama <kei@karesansui-project.info>
"""

import os
import errno
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui

from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_nums_xml_xpath as XMLXpathNum, \
     get_xml_parse as XMLParse, \
     uniq_filename, r_chgrp, r_chmod

from karesansui.lib.file.configfile import ConfigFile

class KaresasnuiServiceConfigParamException(karesansui.KaresansuiLibException):
    pass

class ServiceConfigParam:

    def __init__(self, path):
        self.services = []
        self.path = path

    def findby1service(self, name):
        ret = None
        for service in self.get_services():
            if service['system_name'] == name:
                ret = service

        return ret

    def get_services(self):
        return self.services

    def set_services(self, services):
        self.services = services

    def add_service(self, system_name, system_command, system_readonly, display_name, display_description):
        self.services.append({'system_name': system_name,
                              'system_command': system_command,
                              'system_readonly':system_readonly,
                              'display_name': display_name,
                              'display_description': display_description,
                              })

    def load_xml_config(self, path=None):
        if path is not None:
            self.path = path

        if not os.path.isfile(self.path):
            raise KaresasnuiServiceConfigParamException(
                "service.xml not found. path=%s" % str(self.path))

        document = XMLParse(self.path)

        self.services = []
        service_num = XMLXpathNum(document, '/services/service')
        for n in xrange(1, service_num + 1):
            system_name = XMLXpath(document, '/services/service[%i]/system/name/text()' % n)
            system_command = XMLXpath(document, '/services/service[%i]/system/command/text()' % n)
            system_readonly = XMLXpath(document, '/services/service[%i]/system/readonly/text()' % n)
            display_name = XMLXpath(document, '/services/service[%i]/display/name/text()' % n)
            display_description = XMLXpath(document,
                                           '/services/service[%i]/display/description/text()' % n)

            self.add_service(str(system_name),
                             str(system_command),
                             str(system_readonly),
                             str(display_name),
                             str(display_description))

    def validate(self):
        pass

class ServiceXMLGenerator:

    def __init__(self, path):
        self.config_path = path

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self, config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree,toxml())
        return out.getvalue()

    def writecfg(self, cfg):
        ConfigFile(self.config_path).write(cfg)
        r_chmod(self.config_path, "o-rwx")
        r_chmod(self.config_path, "g+rw")

        if os.getuid() == 0:
            r_chgrp(self.config_path, KARESANSUI_GROUP)

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config
        self.begin_build()
        self.build_services()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.services = self.document.createElement("services")
        self.document.appendChild(self.services)

    def build_services(self):
        doc = self.document

        def build_service(self, val):
            service = doc.createElement("service")
            system = doc.createElement("system")
            system.appendChild(
                self._create_text_node('name', val["system_name"]))
            system.appendChild(
                self._create_text_node('command', val["system_command"]))
            system.appendChild(
                self._create_text_node('readonly', val["system_readonly"]))

            display = doc.createElement("display")
            display.appendChild(
                self._create_text_node('name', val["display_name"]))
            display.appendChild(
                self._create_text_node('description', val["display_description"]))

            service.appendChild(system)
            service.appendChild(display)
            return service

        for service in self.config.get_services():
            self.services.appendChild(build_service(self, service))

    def end_build(self):
        pass

if __name__ == '__main__':
    orig_xml = """<?xml version='1.0' encoding='UTF-8'?>
<services>
  <service>
    <system>
      <name></name>
      <command></command>
    </system>
    <display>
      <name></name>
      <description></description>
    </display>
  </service>
</services>"""
    param = ServiceConfigParam()
    for i in xrange(10):
        param.add_service("system_name_%s" % i,
                          "system_command_%s" % i,
                          "0",
                          "display_name_%s" % i,
                          "display_description_%s" % i)

    generator =  ServiceXMLGenerator('/etc/karesansui/service.xml')
    try:
        cfgxml = generator.generate(param)
    except:
        raise

    generator.writecfg(cfgxml)

########NEW FILE########
__FILENAME__ = sysvinit_rh
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

"""
 * 
 * System V 系 initスクリプトを利用してシステムサービスの起動制御を行う
 *
"""

import os
import sys
import time
import re
import glob
import signal

from karesansui.lib.utils import is_executable
from karesansui.lib.utils import execute_command
from karesansui.lib.utils import get_process_id

class SysVInit_RH:

    procdir           = "/proc"
    initrddir         = "/etc/init.d"
    piddir            = "/var/run"
    command_chkconfig = "/sbin/chkconfig"

    """
    <comment-ja>
    </comment-ja>
    <comment-en>
    </comment-en>
    """

    def __init__(self,name=None,path=None):
        """
        <comment-ja>
        @param self: -
        @return: なし
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """

        self.set_sleep_time(2)
        if name is not None:
            self.set_service_name(name)
        if path is not None:
            self.set_service_path(path)

        self.set_runlevel("3")

        self.error_msg = []
        pass

    def set_runlevel(self,runlevel="3"):
        self.runlevel = runlevel

    def set_sleep_time(self,seconds=2):
        self.sleep_time = seconds

    def set_service_name(self,name=None):
        """
        <comment-ja>
        制御対象サービス名をセットする
        @param self: -
        @param string name	制御対象サービス名
        @return: なし
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """

        self.service_name = name
        self.service_script = "%s/%s" % (self.initrddir, name,)

        return os.path.exists(self.service_script) and is_executable(self.service_script)


    def set_service_path(self,path=None):
        """
        <comment-ja>
        制御対象サービスの実行ファイル名をセットする
        @param self: -
        @param string path	制御対象サービスの実行ファイル名
        @return: なし
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """

        self.service_path = self._get_service_path(path)
        return os.path.exists(self.service_path) and is_executable(self.service_path)

    def _get_service_path(self,path=None):
        """
        <comment-ja>
        ベースネームの実行ファイル名から実行ファイルへの絶対パスを取得する
        @param self: -
        @param string path	実行ファイル名
        @return string		実行ファイルへの絶対パス
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """

        if path is None:
            path = self.service_name

        search_paths = [
            "/usr/share/karesansui/bin",
            "/usr/share/karesansui/sbin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
            "/usr/libexec",
            "/usr/libexec/postfix",
            "/usr/lib/courier-imap/libexec",
        ]

        if path[0:1] != "/":
            for _path in search_paths:
                _path = "%s/%s" % (_path,path,)
                if os.path.exists(_path) and is_executable(_path):
                    path = _path
                    break

        return path


    def status(self):
        """
        <comment-ja>
        制御対象サービスの現在の起動状態を取得する
        @param self: -
        @return mixed    起動中:サービスのPIDが格納された配列  停止中:[]
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        service_paths = "(%s|%s)" % (self.service_path,os.path.basename(self.service_path),)
        retval = get_process_id("^%s *(.+)?$" % service_paths, regex=True)

        # perl等を利用したデーモンはpidファイルで判定
        if len(retval) == 0:
            pid_file = "%s/%s.pid" % (self.piddir,self.service_name,)
            if os.path.exists(pid_file):
                try:
                    # 本当に起動しているか確かめよう
                    pids = open(pid_file).read().split()
                    for process_id in pids:
                        process_id = int(process_id)
                        cmdline_file = "%s/%d/cmdline" % (self.procdir,process_id,)
                        if os.path.exists(cmdline_file):
                            retval.append(process_id)
                except:
                    pass
        return retval

    def start(self,force=False):
        """
        <comment-ja>
        制御対象サービスを起動する
        @param self: -
        @return mixed   成功:サービスのPIDが格納された配列  失敗:False
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = False

        if force is False:
            pids = self.status()

        if force is True or len(pids) == 0:
            if os.path.exists(self.service_script) and is_executable(self.service_script):
                command = "%s start" % (self.service_script,)
                command_args = command.split()
                #print command
                (ret,res) = execute_command(command_args)

                time.sleep(self.sleep_time)
                if force is False:
                    pids = self.status()

                if force is False and len(pids) == 0:
                    message = "Error: failed to start '%s'." % (self.service_name,)
                    self.error_msg.append(message)
                else:
                    message = "Notice: succeeded to start '%s'." % (self.service_name,)
                    #print message
                    try:
                        retval = pids
                    except:
                        retval = True
            else:
                message = "Error: '%s' not found." % (self.service_script,)
                self.error_msg.append(message)
        else:
            pids = [str(p) for p, q in zip(pids, pids[1:] + [None])]
            message = "Warning: '%s' already running. [PID:%s]" % (self.service_name,",".join(pids),)
            self.error_msg.append(message)

        return retval

    def stop(self,force=False):
        """
        <comment-ja>
        制御対象サービスを停止する
        @param self: -
        @return boolean   成功:True  失敗:False
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = False

        if force is False:
            pids = self.status()

        if force is False and len(pids) == 0:
            message = "Warning: '%s' already stopped." % (self.service_name,)
            self.error_msg.append(message)

        else:
            if os.path.exists(self.service_script) and is_executable(self.service_script):
                command = "%s stop" % (self.service_script,)
                command_args = command.split()
                #print command
                (ret,res) = execute_command(command_args)

                time.sleep(self.sleep_time)
                if force is False:
                   pids = self.status()

                if force is True or len(pids) == 0:
                    message = "Notice: succeeded to stop '%s'." % (self.service_name,)
                    #print message
                    retval = True
                else:
                    pids = [str(p) for p, q in zip(pids, pids[1:] + [None])]
                    message = "Error: failed to stop '%s'. [%s]" % (self.service_name," ".join(res),)
                    self.error_msg.append(message)
                    message = "Notice: '%s' is running. [PID:%s]" % (self.service_name,",".join(pids),)
                    retval = False
            else:
                message = "Error: '%s' not found." % (self.service_script,)
                self.error_msg.append(message)

        return retval


    def restart(self,force=False):
        """
        <comment-ja>
        制御対象サービスを再起動する
        @param self: -
        @return mixed   成功:サービスのPIDが格納された配列  失敗:False
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = False

        retval = self.stop(force)
        retval = self.start(force)

        return retval


    def condrestart(self):
        """
        <comment-ja>
        制御対象サービスが起動中のときだけ再起動する
        @param self: -
        @return mixed   成功:サービスのPIDが格納された配列  失敗:False
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = True

        pids = self.status()
        if len(pids) != 0:
            retval = self.restart()

        return retval


    def reload(self):
        """
        <comment-ja>
        制御対象サービスにHUPシグナルを送る
        @param self: -
        @return boolean   成功:True  失敗:False
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = True

        pids = self.status()
        if len(pids) != 0:
            for _pid in pids:
                os.kill(_pid,signal.SIGHUP)

        return retval


    def onboot(self,flag=None,runlevel=None):
        """
        <comment-ja>
        制御対象サービスのマシン起動時の起動状態の有効/無効の切り替えを行う。
        または、その状態を取得する。
        @param self: -
        @param string flag 指定なし:状態を取得する
                           True    :起動時有効にする
                           False   :起動時無効にする
        @return boolean    True :状態取得なら起動時有効、起動時切替なら成功
                           False:状態取得なら起動時有効、起動時切替なら成功
        </comment-ja>
        <comment-en>
        constructor of class
        @param self: The object pointer
        @return: none
        </comment-en>
        """
        retval = False

        if flag is not None and flag is not True and flag is not False:
            raise Exception("Invalid argument.")

        if os.path.exists(self.service_script) and is_executable(self.service_script):
            script_name = os.path.basename(self.service_script)

            old_lang = os.environ["LANG"]
            os.environ["LANG"] = "C"

            if flag is None:
                command = "%s --list %s" % (self.command_chkconfig,script_name,)
                command_args = command.split()
                (ret,res) = execute_command(command_args)

                if runlevel is None:
                    runlevel = self.runlevel
                try:
                    m = re.search("[ \t]+%s:on[ \t]+" % runlevel ,res[0])
                    if m:
                        retval = True
                except:
                    pass

            else:
                if flag is True:
                    on_or_off = "on"
                else:
                    on_or_off = "off"
                if runlevel is None:
                    command = "%s %s %s" % (self.command_chkconfig,script_name,on_or_off)
                else:
                    command = "%s --level %s %s %s" % (self.command_chkconfig,runlevel,script_name,on_or_off)

                command_args = command.split()
                (ret,res) = execute_command(command_args)
                if ret == 0:
                    retval = True

            os.environ["LANG"] = old_lang

        else:
            message = "Error: '%s' not found." % (self.service_script,)
            self.error_msg.append(message)

        return retval
    
if __name__ == '__main__':
    """Testing
    """

    sysv = SysVInit_RH("libvirtd","libvirtd")
    print sysv.status()
    print sysv.onboot()
    print sysv.onboot(True)
    """
    print sysv.onboot()
    print sysv.onboot(False)
    print sysv.onboot()
    print sysv.onboot(True)
    print sysv.onboot()
    print "start"
    print sysv.start()
    print sysv.status()
    print sysv.reload()
    print sysv.status()
    print "stop"
    print sysv.stop()
    print sysv.status()
    print "start"
    print sysv.start()
    print sysv.status()

    sysv = SysVInit_RH("network","network")
    print sysv.status()
    print sysv.restart(force=True)
    """

    """
    sysv = SysVInit_RH("network","network")
    print sysv.onboot()
    print sysv.onboot(runlevel="4")
    """

    """
    sysv = SysVInit_RH("libvirtd","libvirtd")
    sysv.set_service_name("asynschedulerd")
    sysv.set_service_path("asynschedulerd.py")
    print sysv.status()
    """

########NEW FILE########
__FILENAME__ = template
#! /usr/bin/env python
# -*- coding: utf-8 -*-`
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

from karesansui import KaresansuiTemplateException
from karesansui.lib.utils import get_system_user_list, get_system_group_list

def view(text, _):
    """<comment-ja>
    mako#render時にUNDEFINEDが発生する可能性がある場合に利用してください。
    UNDEFINEDが発生した場合は、国際化された_('Undefined')が返却されます。
    @param text: 表示する文字列
    @type text: str
    @param _: translationオブジェクト
    @type _:gettext.GNUTranslations
    @rtype: str
    @return: 表示する文字列
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from mako.runtime import UNDEFINED

    if text is UNDEFINED:
        return ""
    elif not text:
        return _('Undefined')
    else:
        return text

def img_status(status, prefix='', extra=''):
    """<comment-ja>
    ゲストOSのステータスを元に指定された形式で出力します。
    @param status: libvirt status
    @type status: int
    @param prefix: 固定画像名の先頭につけるプレフィックスファイル名　example) prefix='bar-' result 'bar-nostate.png'
    @type prefix: str
    @param extra: imgタグに別途追記する属性
    @type extra: str
    @return: form#img
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    import web
    from karesansui.lib.virt.virt import VIR_DOMAIN_NOSTATE, \
         VIR_DOMAIN_RUNNING, \
         VIR_DOMAIN_BLOCKED, \
         VIR_DOMAIN_PAUSED, \
         VIR_DOMAIN_SHUTDOWN, \
         VIR_DOMAIN_SHUTOFF, \
         VIR_DOMAIN_CRASHED

    _img_tpl = '<img src="' + web.ctx.homepath + '/static/images/%s" alt=""' + extra + ' />'

    if status == VIR_DOMAIN_NOSTATE:
        return _img_tpl % (prefix+'nostate.png')
    elif status == VIR_DOMAIN_CRASHED:
        return _img_tpl % (prefix+'crashed.png')
    elif status == VIR_DOMAIN_SHUTOFF:
        return _img_tpl % (prefix+'shutoff.png')
    elif status == VIR_DOMAIN_SHUTDOWN:
        return _img_tpl % (prefix+'shutdown.png')
    elif status == VIR_DOMAIN_PAUSED:
        return _img_tpl % (prefix+'paused.png')
    elif status == VIR_DOMAIN_BLOCKED:
        return _img_tpl % (prefix+'blocked.png')
    elif status == VIR_DOMAIN_RUNNING:
        return _img_tpl % (prefix+'running.png')
    else:
        raise KaresansuiTemplateException("Not specify the status.")

def str_status(status, _):
    """<comment-ja>
    ゲストOSステータスの名称を出力します。
    @param status: libvirt status
    @type status: int
    @param _: translationオブジェクト
    @type _:gettext.GNUTranslations
    @return: 名称
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    import web
    from karesansui.lib.virt.virt import VIR_DOMAIN_NOSTATE, \
         VIR_DOMAIN_RUNNING, \
         VIR_DOMAIN_BLOCKED, \
         VIR_DOMAIN_PAUSED, \
         VIR_DOMAIN_SHUTDOWN, \
         VIR_DOMAIN_SHUTOFF, \
         VIR_DOMAIN_CRASHED

    if status == VIR_DOMAIN_NOSTATE:
        return _('NOSTATE')
    elif status == VIR_DOMAIN_CRASHED:
        return _('CRASHED')
    elif status == VIR_DOMAIN_SHUTOFF:
        return _('SHUTOFF')
    elif status == VIR_DOMAIN_SHUTDOWN:
        return _('SHUTDOWN')
    elif status == VIR_DOMAIN_PAUSED:
        return _('PAUSED')
    elif status == VIR_DOMAIN_BLOCKED:
        return _('BLOCKED')
    elif status == VIR_DOMAIN_RUNNING:
        return _('RUNNING')
    else:
        raise KaresansuiTemplateException("Not specify the status.")

def str_attribute(attribute):
    """<comment-ja>
    マシン属性の名称を出力します。
    @param attribute: マシン属性値
    @type attribute: int
    @return: 名称
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from karesansui.lib.const import MACHINE_ATTRIBUTE

    for key, value in MACHINE_ATTRIBUTE.items():
        if attribute == value:
            return key
    else:
        raise KaresansuiTemplateException("Not specify the attribute.")

def locale_hypervisor(hypervisor, _):
    """<comment-ja>
    Japanese Comment
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from karesansui.lib.const import MACHINE_HYPERVISOR
    if (hypervisor in MACHINE_HYPERVISOR.values()) is True:
        for x in MACHINE_HYPERVISOR.items():
            if hypervisor == x[1]:
                return _(x[0])

        raise KaresansuiTemplateException("Hypervisor is not defined.")
    else:
        raise KaresansuiTemplateException("Hypervisor is not defined.")

def locale_bool(bool, _):
    """<comment-ja>
    Bool型を国際化された名称で出力します。
    @param bool: True/False
    @type bool: bool
    @param _: translationオブジェクト
    @type _:gettext.GNUTranslations
    @return: 名称
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    import web

    if bool is True:
        return _('Enabled')
    elif bool is False:
        return _('Disabled')
    else:
        raise KaresansuiTemplateException("Bool not specified.")

def lnewline(text):
    from mako.runtime import UNDEFINED
    if text is UNDEFINED:
        return ""
    ret = ""
    for t in text:
        ret += t + '\n'
    return ret

def clipping(text, num):
    """<comment-ja>
    テキストが任意の文字数を超えていたら、
    省略したテキストに … を加えたものをを返却する。
    そうでないなら、テキストをそのまま返却する。
    半角は1文字、全角は2文字としてカウントする。

    @param text: 省略するテキスト
    @type text: str
    @param num: 省略する文字数
    @type num: int
    @return: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from mako.runtime import UNDEFINED
    if text is UNDEFINED:
        return ""

    ret = text

    count = 0
    for i in xrange(len(text)):
        if ord(text[i]) <= 255:
            count += 1;
        else:
            count += 2;

        if num < count:
            ret = text[0:i] + u"…"
            break

    return ret

def replace_empty(value, replace_value):
    """<comment-ja>
    値がNone、または、空文字('')のものを指定の値に置き換えます
    @param value: 置き換え元の要素
    @type value: str
    @param replace_value: 置き換え先の要素
    @type replace_value: str
    @return: 存在するマシン名
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if value == None or value == "":
        return replace_value
    else:
        return value

def get_exist_machine_name(machines, _):
    """<comment-ja>
    存在するマシン名を返却します。
    マシン名が複数あるときはカンマ区切りで返却します。
    マシン名が存在しない、または、マシンが削除されているときは、「Unregistered」を返却します。
    @param machines: マシンの配列
    @type machines: list
    @param _: translationオブジェクト
    @type _:gettext.GNUTranslations
    @return: 存在するマシン名
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if machines is None:
        return _('N/A')

    _names = []
    for machine in machines:
        if machine.is_deleted is False:
            _names.append(machine.name)
    
    if len(_names) > 0:
        return  ",".join(_names)
    else:
        return  _('N/A')

def userid2realname(userid):
    users = get_system_user_list()
    for user in users:
        if userid == user[2]:
            return user[0]
    return userid

def groupid2realname(groupid):
    groups = get_system_group_list()
    for group in groups:
        if groupid == group[2]:
            return group[0]
    return groupid

def autounit(t, unit):
    _t = float(t)
    now = 0
    _u = 1
    while True:
        ret = long(_t / _u)
        if 0 == ret or now == len(unit):
            break
        _u *= 1024
        now += 1

    if 0 < now:
       _u /= 1024 
       now -= 1

    if len(unit) < now:
        return (_t, unit[0])
    return (_t/_u, unit[now])

def view_autounit(_b, unit=('B','KB','MB','GB','TB', 'PB', 'EB'), decimal_point=0, print_unit=False):
    ret = autounit(_b, unit)
    formmat = "%." + str(decimal_point) + "f"
    view_number = formmat % ret[0]
    view_unit = ret[1]

    if print_unit is True:
        return "%s%s" % (view_number, view_unit)
    else:
        return "%s" % (view_number)

def megaunit(t, now_unit):
    UNIT = ('B','KB','MB','GB','TB', 'PB', 'EB')
    MEGA_POS = 2

    _t = float(t)
    _u = 1

    now_pos = 0
    for i in range(len(UNIT)):
        if now_unit == UNIT[i]:
            now_pos = i
            break

    if MEGA_POS <= now_pos:
        for i in range(now_pos - MEGA_POS):
            _u *= 1024
        return _t * _u
    else:
        for i in range(MEGA_POS - now_pos):
            _u *= 1024
        return _t / _u

def view_megaunit(_b, now_unit, decimal_point=0, print_unit=False):
    ret = megaunit(_b, now_unit)
    formmat = "%." + str(decimal_point) + "f"

    view_number = formmat % ret

    if print_unit is True:
        return "%sMB" % (view_number)
    else:
        return "%s" % (view_number)

def total_progress(jobs):
    complete_progress = len(jobs) * 100

    sum_progress = 0
    for job in jobs:
        sum_progress += job.progress

    return int(float(sum_progress) / float(complete_progress) * 100)

def newline2br(text):
    import re
    return re.compile(r"[\r\n]+").sub('<br/>', text)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
ユーティリティ関数群を定義する
</comment-ja>
<comment-en>
Define the utility functions
</comment-en>

@file:   utils.py

@author: Taizo ITO <taizo@karesansui-project.info>

@copyright:    

"""
import string
import os
import os.path
import stat
import random
import subprocess
import shutil
import time
import datetime
import re
import pwd
import grp
import sys
import math
import glob
import fcntl
import gzip

import karesansui
import karesansui.lib.locale

from karesansui import KaresansuiLibException
from karesansui.lib.const import CHECK_DISK_QUOTA
from karesansui.lib.networkaddress import NetworkAddress

def preprint_r(var,indent=2,depth=None,return_var=False):
    import pprint

    pp = pprint.PrettyPrinter(indent=indent,depth=depth)
    if return_var is True:
        return pp.pformat(var)
    else:
        pp.pprint(var)
        return True

def dotsplit(val):
    """<comment-ja>
    ドット(.)区切りで文字列分割する。ドット(.)は)
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    rf = val.rfind('.')
    if rf == -1:
        return val, ''
    else:
        return val[:rf], val[rf+1:]

def toplist(val):
    """<comment-ja>
    リスト型に変換する。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if type(val) is list:
        return val
    else:
        return [val,]
        
def comma_split(s):
    """<comment-ja>
    カンマ(,)単位で文字列分割しリスト型に変換する。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    ret = []
    for y in [x.strip() for x in s.split(',') if x]:
        ret.append(y)
    return ret

def uniq_sort(array):
    """<comment-ja>
    配列の要素をソートし重複した要素を取り除く
    @param array: 配列
    @return: 配列
    @rtype: list
    </comment-ja>
    <comment-en>
    run a unique sort and return an array of sorted

    @param array: list
    @return: list
    </comment-en>
    """
    array = sorted(array)
    #array = [x for i,x in enumerate(array) if array.index(x) == i]
    array = [_x for _x, _y in zip(array, array[1:] + [None]) if _x != _y]
    return array

def dict_ksort(dt):
    """<comment-ja>
    辞書配列をキーを元にソートし重複する

    @param dt: 辞書
    @type dt: dict
    @return: ソート後の辞書配列
    @rtype: dict
    </comment-ja>
    <comment-en>
    run a key sort in dict
    </comment-en>
    """
    new_dict = {}
    for k,v in sorted(dt.iteritems(), lambda x,y : cmp(x[0], y[0])):
        new_dict[k] = v
    return new_dict

def dict_search(search_key, dt):
    """<comment-ja>
    辞書配列から指定した値に対応するキーを取得する

    @param dt: 辞書
    @type dt: dict
    @return: 取得したキーを要素とする配列
    @rtype: array
    </comment-ja>
    <comment-en>
    Searches the dictionary for a given value and returns the corresponding key.
    </comment-en>
    """
    def map_find(_x, _y):
        if _y == search_key:
            return _x
    def except_None(_z):
        return _z <> None
    rlist = map(map_find, dt.keys(), dt.values())
    return filter(except_None, rlist)

def dec2hex(num):
    """<comment-ja>
    整数値を１６進数の文字列に変換する
    @param num: 整数値
    @return: １６進数の文字列
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return "%X" % num

def dec2oct(num):
    """<comment-ja>
    整数値を８進数の文字列に変換する
    @param num:整数値
    @return: ８進数の文字列
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return "%o" % num

def hex2dec(s):
    """<comment-ja>
    １６進数の文字列を整数値に変換する
    @param string:１６進数の文字列
    @return int16
    @rtype: int
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return int(s, 16)

def oct2dec(string):
    """<comment-ja>
    ８進数の文字列を整数値に変換する
    @param string:８進数の文字列
    @rtype: integer
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return int(string, 8)

def float_from_string(string):
    """<comment-ja>
    浮動小数点表記の文字列を数値に変換する
    @param string: 浮動小数点表記
    @rtype: float
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>

    >>> from karesansui.lib.utils import float_from_string
    >>> 
    >>> float_from_string("9.95287e+07")        # 99528700
    99528700.0
    >>> float_from_string("2.07499e+08")        # 207499000
    207499000.0
    >>> float_from_string("-2.07499e+02")       # -207.499
    -207.499
    >>> float_from_string("+2.07499e+02")       # 207.499
    207.499
    >>> float_from_string("+2.07499e-02")       # 0.0207499
    0.0207499
    >>> float_from_string("3.39112632978e+001") # 3391126329780.0
    33.9112632978
    """

    if type(string) != str:
        return False

    regex = re.compile("^([\+\-]?)(([0-9]+|[0-9]*[\.][0-9]+))([eE])([\+\-]?)([0-9]+)$")
    m = regex.match(string)
    if m:
        sign = m.group(1)
        mantissa = float(m.group(2))
        sign_exponent = m.group(5)
        exponent = int(m.group(6))

        data = float(1)

        if sign == "-":
            data = data * -1

        if sign_exponent == "-":
            exponent = -1 * exponent

        data = data * mantissa * (10**exponent)

    else:
        return False

    return data

def ucfirst(string):
    return string[0].upper() + string[1:]

def lcfirst(string):
    return string[0].lower() + string[1:]

def next_number(min,max,exclude_numbers):
    """
    <comment-ja>
    指定範囲内における除外対象整数以外の次の整数を取得する
    
    @param min: 範囲中の最小の整数
    @param max: 範囲中の最大の整数
    @param exclude_numbers: 除外対象整数を要素にもつ配列
    @return: 整数
    @rtype: int
    </comment-ja>
    <comment-en>
    @param min: Minimum interger in specified range
    @param max: Maximum interger in specified range
    @param exclude_numbers: array that has the element of exclusive interger
    @return: Interger
    </comment-en>
    """
    for _x in range(min,max):
      if not _x in exclude_numbers:
        return _x

def isset(string, vars=globals(), verbose=False):
    """
    bool isset(str string  [,bool verbose=False])
    <comment-ja>
    変数名がセットされていることを検査する
    
    @param string: 変数名を示す文字列
    @type string: str
    @param vars: 検査対象の変数配列
    @type vars: dict
    @param verbose: エラーメッセージを表示する場合はTrue
    @type verbose: bool
    @return: 変数名がセットされていればTrue、いなければFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    Determine if a variable is set.

    @param string: The variable name, as a string. 
    @type string: str
    @param vars: all variables available in scope
    @type vars: dict
    @param verbose: If used and set to True, isset() will output error messages.
    @type verbose: bool
    @return: Returns True if a variable is set, False otherwise. 
    @rtype: bool
    </comment-en>
    """
    retval = False
    try:
        for _k,_v in vars.iteritems():
            exec("%s = _v" % _k)
        exec("%s" % string)
        retval = True
    except NameError, e:
        if verbose is True:
            print _("Notice: Undefined variable \"%s\"") % str(e.args)
    except KeyError, e:
        if verbose is True:
            print _("Notice: Undefined index \"%s\"") % str(e.args)
    except Exception, e:
        if verbose is True:
            print _("Notice: Undefined variable \"%s\"") % str(e.args)
        pass
    return retval

def is_uuid(uuid=None):
    """<comment-ja>
    KaresansuiのUUIDフォーマットに対応しているか。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    uuid_regex = re.compile(r"""^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$""")
    if uuid != None and uuid_regex.match(uuid):
        return True

    return False

def generate_uuid():
    """
    <comment-ja>
    ランダムなUUIDを生成する

    @return: UUID用の16個のバイト要素を持つ配列
    </comment-ja>
    <comment-en>
    Generate UUID

    @return: Array UUID
    </comment-en>
    """
    uuid = []
    for _x in range(0, 16):
      uuid.append(random.randint(0x00,0xff))
    return uuid

def string_from_uuid(uuid):
    """
    <comment-ja>
    UUIDデータを文字列に変換する

    @param uuid: generate_uuid関数等で生成されたUUIDデータ
    @return: UUID文字列
    </comment-ja>
    <comment-en>
    Convert UUID data to string

    @param uuid: UUID data that was generated by certain function like as generate_uuid()
    @return: The string that stands for uuid
    </comment-en>
    """
    tuuid = tuple(uuid)
    return "-".join(["%02x"*4 % tuuid[0:4],
                    "%02x"*2 % tuuid[4:6],
                    "%02x"*2 % tuuid[6:8],
                    "%02x"*2 % tuuid[8:10],
                    "%02x"*6 % tuuid[10:16]
                   ]);

def string_to_uuid(string):
    """
    <comment-ja>
    文字列をUUIDデータに変換する

    @param string: UUID文字列
    @return: UUIDデータ
    </comment-ja>
    <comment-en>
    Convert string to UUID data

    @param string: The string that stands for uuid
    @return: UUID data
    </comment-en>
    """
    string = string.replace('-', '')
    return [ int(string[i : i + 2], 16) for i in range(0, 32, 2) ]

def generate_mac_address(type="XEN"):
    """
    <comment-ja>
    ランダムなMACアドレスを生成する
    (XENなら、00:16:3e:00:00:00 から 00:16:3e:7f:ff:ff の範囲)
    (KVMなら、52:54:00:00:00:00 から 52:54:00:ff:ff:ff の範囲)

    @param type: ハイパーバイザのタイプ (XEN or KVM)
    @return: MACアドレス
    </comment-ja>
    <comment-en>
    Generate random MAC address
    (if hypervisor is XEN, generates address by range between 00:16:3e:00:00:00 and 00:16:3e:7f:ff:ff)
    (if hypervisor is KVM, generates address by range between 52:54:00:00:00:00 and 52:54:00:ff:ff:ff)

    @param type: The type of hypervisor (XEN or KVM)
    @return: The string that stands for MAC address
    </comment-en>
    """
    if type == "KVM":
        mac = [ 0x52, 0x54, 0x00,
                random.randint(0x00, 0xff),
                random.randint(0x00, 0xff),
                random.randint(0x00, 0xff) ]
    else:
        mac = [ 0x00, 0x16, 0x3e,
                random.randint(0x00, 0x7f),
                random.randint(0x00, 0xff),
                random.randint(0x00, 0xff) ]
    return ':'.join(map(lambda x: "%02x" % x, mac))

def generate_phrase(len,letters=None):
    """<comment-ja>
    ランダムな文字列を生成する

    @param len: 文字列の長さ
    @return: ランダム文字列
    @rtype: str
    </comment-ja>
    <comment-en>
    Generate random string

    @param len: length of string
    @return: The generated string
    @rtype: str
    </comment-en>
    """
    if letters is None:
        letters = string.digits + string.letters + '-.'
    random.seed()
    return ''.join(random.choice(letters) for i in xrange(len))

def detect_encoding(string,encoding_list=None):
    """
    <comment-ja>
    文字エンコーディングを検出する

    @param string: 検出する文字列データ
    @param encoding_list: エンコーディングのリスト。エンコーディング検出の順番を配列で指定。省略時は、[ 'euc-jp', 'utf-8', 'shift-jis', 'iso2022-jp' ]
    @return: 検出した文字エンコーディング
    </comment-ja>
    <comment-en>
    Detect character encoding

    @param string: The string being detected
    @param encoding_list: list of character encoding. Encoding order will be specified by array. if it is omitted, detect order is [ 'euc-jp', 'utf-8', 'shift-jis', 'iso2022-jp' ]
    @return: The detected character encoding
    </comment-en>
    """
    func = lambda data,encoding: data.decode(encoding) and encoding

    if not encoding_list:
        encoding_list = [ 'euc-jp', 'utf-8', 'shift-jis', 'iso2022-jp' ]

    for encoding in encoding_list:
        try:
            return func(string, encoding)
        except:
            pass

    return None

def execute_command(command_args,user=None,env=None):
    """
    <comment-ja>
    コマンドを実行する

    @param command_args: 実行するコマンドとその引数を要素とする配列
    @param user: 実行するユーザー名 (省略時はgetuidによる)
    @param env:  実行時に適用する環境変数の辞書配列
    @return: 終了ステータスと実行時の出力結果の配列
    </comment-ja>
    <comment-en>
    Execute command

    @param command_args: The array that consists of command name and its arguments.
    @param user: the effective user id 
    @param env:  dictionary of environ variables
    @return: The return status of the executed command
    </comment-en>
    """
    ret = -1
    res = []

    curdir  = os.getcwd()

    if user is None:
        homedir = pwd.getpwuid(os.getuid())[5]
    else:
        try:
            int(user)
            homedir = pwd.getpwuid(int(user))[5]
        except:
            try:
                homedir = pwd.getpwnam(user)[5]
            except:
                homedir = pwd.getpwuid(os.getuid())[5]

    subproc_args = { 'stdin': subprocess.PIPE,
                     'stdout': subprocess.PIPE,
                     'stderr': subprocess.STDOUT,
#                     'shell': True,
                     'cwd': homedir,
                     'close_fds': True,
                   }

    if env is not None:
        subproc_args['env'] = env

    try:
        pp = subprocess.Popen(command_args, **subproc_args)
    except OSError, e:
        #raise KaresansuiLibException("Failed to execute command: %s" % command_args[0])
        return [ret,res]

    (stdouterr, stdin) = (pp.stdout, pp.stdin)
    while True:
        line = stdouterr.readline()
        if not line:
            break
        line = line.rstrip()

        try:
            res.append(unicode(line, detect_encoding(line)).encode("utf-8"))
        except:
            res.append(line)

    try:
        ret = pp.wait()
    except:
        ret = 0

    return [ret,res]


def pipe_execute_command(commands):
    """
    <comment-ja>
    PIPE付きコマンドを実行する

    @param commands: パイプ付きのコマンドを分割した、配列  example) [['rpm', '-qa'], ['grep', 'karesansui'],]
    @return: 終了ステータスと実行時の出力結果の配列
    </comment-ja>
    <comment-en>
    </comment-en>
    """
    ret = -1
    res = []
    out = []
    for cmd in commands:
        subproc_args = {'stdin': subprocess.PIPE,
                        'stdout': subprocess.PIPE,
                        }
        if 0 < len(out):
            subproc_args['stdin'] = out[len(out)-1]

        pp = subprocess.Popen(cmd, **subproc_args)

        (stdout, stdin) = (pp.stdout, pp.stdin)
        out.append(stdout)
        ret = pp.wait()
    res = out[len(out)-1].read()
    return (ret,res)


def create_file(file, value) :
    """
    <comment-ja>
    ファイルを作成する。

    @param file: 作成するファイル名
    @param value: 書き込む値
    @return: なし
    </comment-ja>
    <comment-en>
    create file

    @param file: The name of generated file
    @param value: The value of generated file
    @return: None
    </comment-en>
    """
    if os.path.exists(file):
        raise KaresansuiLibException("Error: %s already exists" % file)

    fd = open(file, 'w')
    try:
        try:
            fd.write(value)
        except IOError, err:
            raise KaresansuiLibException("IOError: %s" % str(err))
    finally:
        fd.close()

def remove_file(file) :
    """
    <comment-ja>
    ファイルを削除する。

    @param file: 削除するファイル名
    @return: なし
    </comment-ja>
    <comment-en>
    remove file

    @param file: The name of removed file
    @return: None
    </comment-en>
    """
    if not os.path.exists(file):
        raise KaresansuiLibException("Error: %s not exists" % file)

    try:
        os.remove(file)
    except OSError, err:
        raise KaresansuiLibException("OSError: %s" % str(err))

def create_raw_disk_img(file,size,is_sparse=True) :
    """
    <comment-ja>
    rawディスクファイルを生成する

    @param file: 生成するファイル名
    @param size: ファイルサイズ(MB)
    @param sparse: スパースファイル？
    @return: なし
    </comment-ja>
    <comment-en>
    Create raw disk file

    @param file: The name of generated file
    @param size: The size of generated file
    @return: None
    </comment-en>
    """
    if is_sparse is True:
        command_args = [
            "dd",
            "if=/dev/zero",
            "of=%s" % file,
            "seek=%s" % str(size),
            "bs=1M",
            "count=0",
            ]
    else:
        command_args = [
            "dd",
            "if=/dev/zero",
            "of=%s" % file,
            "bs=1M",
            "count=%s" % str(size) ,
            ]

    (rc,res) = execute_command(command_args)
    if rc != 0:
        return None
    return rc

#    if os.path.exists(file):
#        raise KaresansuiLibException("Error: %s already exists" % file)
#
#    try:
#        fd = open(file, 'w')
#        try:
#            fd.truncate(1024L * 1024L * size)
#        except IOError, err:
#            raise KaresansuiLibException("IOError: %s" % str(err))
#    finally:
#        fd.close()

def create_qemu_disk_img(file,size,type="raw") :
    """
    <comment-ja>
    qemu用ディスクイメージファイルを生成する

    @param file: 生成するファイル名
    @param size: ファイルサイズ(MB)
    @param type: ディスクイメージのタイプ raw/qcow/qcow2/cow/vmdk/cloop
    @return: なし
    </comment-ja>
    <comment-en>
    Create qemu disk image file

    @param file: The name of generated file
    @param size: The size of generated file
    @return: None
    </comment-en>
    """
    from karesansui.lib.const import DISK_QEMU_FORMAT
    #available_formats = [ "raw","qcow","qcow2","cow","vmdk","cloop" ]
    available_formats = DISK_QEMU_FORMAT.values()

    if type in available_formats:
        command_args = [
            "qemu-img",
            "create",
            "-f",
            type,
            file,
            "%sM" % str(size),
            ]
        (rc,res) = execute_command(command_args)
        if rc != 0:
            return None
    else:
        rc = None

    return rc

def create_disk_img(file,size,type="raw",is_sparse=True) :
    """
    <comment-ja>
    ディスクイメージファイルを生成する

    @param file: 生成するファイル名
    @param size: ファイルサイズ(MB)
    @param type: ディスクイメージのタイプ raw/qcow/qcow2/cow/vmdk/cloop
    @param sparse: スパースファイル？(rawのときのみ)
    @return: なし
    </comment-ja>
    <comment-en>
    Create disk image file

    @param file: The name of generated file
    @param size: The size of generated file
    @return: None
    </comment-en>
    """
    from karesansui.lib.const import DISK_QEMU_FORMAT
    #available_formats = [ "raw","qcow","qcow2","cow","vmdk","cloop" ]
    available_formats = DISK_QEMU_FORMAT.values()

    if type in available_formats:
        if type == "raw":
            rc = create_raw_disk_img(file,size,is_sparse)
        else:
            rc = create_qemu_disk_img(file,size,type)
    else:
        rc = None
        raise KaresansuiLibException("Unsupported disk image format. [%s]" % type)

    return rc

def copy_file(src_file,dest_file):
    """
    <comment-ja>
    ファイルをコピーする

    @param src_file: コピー元ファイル名
    @param dest_file: コピー先ファイル名
    @return: コピー先ファイル名
    </comment-ja>
    <comment-en>
    Copy file

    @param src_file: Path to the source file
    @param dest_file: The destination path
    @return: The destination path
    </comment-en>
    """
    #ret = shutil.copy2(src_file, dest_file)
    ret = False
    if os.path.exists(src_file):
        try:
            if dest_file[0] != "/":
                dest_path = "%s/%s" % (os.getcwd(),os.path.dirname(dest_file),)
            else:
                dest_path = os.path.dirname(dest_file)
            if not os.path.exists(dest_path):
                os.makedirs(dest_path)

            (ret, res) = execute_command(["cp","-rfp",src_file,dest_file])
            if ret == 0:
                ret = True
        except:
            return False
    else:
        return False

    return ret


def copy_file_cb(src,dst,callback=None,sparse=False,each=True):
    default_block_size = 4096

    if type(src) == str:
        src = [src]

    if type(dst) == str:
        dst = [dst]

    if len(src) != len(dst):
        raise

    if each is not True:
        all_bytes = 0
        for _src in src:
            all_bytes = all_bytes + os.path.getsize(_src)

        text = "Copying"
        callback.start(filename=None, size=long(all_bytes), text=text)
        cnt = 0

    i = 0
    all_bytes = 0
    for _src in src:
        try:
            _dst = str(dst[i])
        except:
            _dst = dst[i]

        if os.path.exists(os.path.dirname(_dst)) is False:
            os.makedirs(os.path.dirname(_dst))

        bytes = os.path.getsize(_src)
        all_bytes = all_bytes + bytes

        if each is True:
            text = _("Copying %s") % os.path.basename(_src)
            callback.start(filename=_src, size=long(bytes), text=text)
            cnt = 0


        if os.path.exists(_dst) is False and sparse is True:
            block_size = default_block_size
            fd = None
            try:
                fd = os.open(_dst, os.O_WRONLY|os.O_CREAT)
                os.ftruncate(fd, bytes)
            finally:
                if fd:
                    os.close(fd)
        else:
            block_size = 1024*1024*10

        #nulls = '\0' * default_block_size
        nulls = 0x00 * default_block_size

        src_fd = None
        dst_fd = None
        try:
            try:
                src_fd = os.open(_src, os.O_RDONLY)
                dst_fd = os.open(_dst, os.O_WRONLY|os.O_CREAT)

                while 1:
                    data = os.read(src_fd, block_size)
                    sz = len(data)
                    if sz == 0:
                        if each is True:
                            callback.end(bytes)
                        else:
                            callback.update(all_bytes)
                        break
                    if sparse and nulls == data:
                        os.lseek(dst_fd, sz, 1)
                    else:
                        b = os.write(dst_fd, data)
                        if sz != b:
                            if each is True:
                                callback.end(cnt)
                            else:
                                callback.update(cnt)
                            break
                    cnt += sz
                    if cnt < bytes:
                        callback.update(cnt)
            except OSError, e:
                raise RuntimeError(_("ERROR: copying %s to %s: %s") % (_src,_dst,str(e)))
        finally:
            if src_fd is not None:
                os.close(src_fd)
            if dst_fd is not None:
                os.close(dst_fd)

        i = i + 1
    callback.end(all_bytes)

def move_file(src_file,dest_file):
    """
    <comment-ja>
    ファイルを移動する

    @param src_file: 移動元ファイル名
    @param dest_file: 移動先ファイル名
    @return: 移動先先ファイル名
    </comment-ja>
    <comment-en>
    Copy file

    @param src_file: Path to the source file
    @param dest_file: The destination path
    @return: The destination path
    </comment-en>
    """
    #ret = shutil.copy2(src_file, dest_file)
    ret = False
    if os.path.exists(src_file):
        try:
            if dest_file[0] != "/":
                dest_path = "%s/%s" % (os.getcwd(),os.path.dirname(dest_file),)
            else:
                dest_path = os.path.dirname(dest_file)
            if not os.path.exists(dest_path):
                os.makedirs(dest_path)

            (ret, res) = execute_command(["mv","-f",src_file,dest_file])
            if ret == 0:
                ret = True
        except:
            return False
    else:
        return False

    return ret

def get_xml_parse(file):
    from xml.dom import minidom

    if os.path.exists(file):
        document = minidom.parse(file)
    else:
        document = minidom.parseString(file)

    return document

def get_xml_xpath(document, expression):
    """
    <comment-ja>
    XPathロケーションパスを評価する

    @param document: xml.dom.minidom.Document
    @param expression: 実行する XPath 式
    @return: 与えられた XPath 式 にマッチするすべてのノードを含む ノード一覧
    </comment-ja>
    <comment-en>
    Evaluates the XPath Location Path in the given string

    @param file: Path to XML file
    @param expression: The XPath expression to execute
    @return: Returns node list containing all nodes matching the given XPath expression
    </comment-en>
    """
    from xml import xpath

    result = None
    for i in xpath.Evaluate(expression, document.documentElement):
        result = i.nodeValue

    return result

def get_nums_xml_xpath(document, expression):
    """
    <comment-ja>
    XPathロケーションパスを評価する

    @param file: XMLファイルパス、または、XMLデータそのもの
    @param expression: 実行する XPath 式
    @return: 与えられた XPath 式 にマッチするすべてのノードを含む ノード数
    </comment-ja>
    <comment-en>
    Evaluates the XPath Location Path in the given string

    @param file: Path to XML file
    @param expression: The XPath expression to execute
    @return: Returns the number of node containing all nodes matching the given XPath expression
    </comment-en>
    """
    from xml import xpath

    result = None
    return xpath.Evaluate('count(%s)' % expression, document.documentElement)

def gettimeofday():
    """
    <comment-ja>
    現在の時刻を取得する

    @return: 紀元 (the Epoch: time(2) を参照) からの秒とマイクロ秒
    </comment-ja>
    <comment-en>
    Get current time

    @return: the number of seconds and microseconds since the  Epoch  (see time(2))
    </comment-en>
    """
    d = datetime.datetime.now()
    return int(time.mktime(d.timetuple())),d.microsecond


def load_locale():

    import karesansui
    import gettext
    try:
      t = gettext.translation('messages', karesansui.dirname + "/locale")
    except IOError, err:
      old_lang = os.environ['LANG']
      os.environ['LANG'] = 'en'
      t = gettext.translation('messages', karesansui.dirname + "/locale")
      os.environ['LANG'] = old_lang

    return t.gettext

def get_no_overlap_list(target_list):
    """
    <comment-ja>
    リストから重複要素を取り除く

    @param target_list: 重複要素を取り除きたいリスト
    @return: 重複が取り除かれたリスト(順番は保存されない)
    </comment-ja>
    <comment-en>
    delete overlap element in list

    @param target_list: list that has overlap element
    @return: list that delete overlap element (not keep original number)
    </comment-en>
    """
    return list(set(target_list))

def is_int(val):
    """<comment-ja>
    int型かどうか。
    @return: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    try:
        ret = int(val)
        return True
    except (TypeError, ValueError):
        return False

def is_param(input, name, empty=False):
    """
    <comment-ja>
    リクエストデータ(self.input or web.input)に指定したパラメタが存在しているか。
    @param input: 
    @type input 
    @param
    @type
    @return: bool
    </comment-ja>
    <comment-en>
    TODO: English
    </comment-en>
    """
    try:
        if input.has_key(name) is True:
            if empty is True:
                if is_empty(input[name]) is True:
                    return False
                else: # has (name)key and input[name] is not empty
                    return True
            else: # has (name)key and empty arg is False
                return True
        else: # does not have (name)key
            return False
    except:
        return False

def is_ascii(value):
    for x in xrange(len(value)):
        # Printable characters ASCII is between 0x20(SP) and 0x7e(~)
        if ord(value[x]) < 0x20 or 0x7e < ord(value[x]):
            return False
    return True

def str2datetime(src, format, whole_day=False):
    """<comment-ja>
    フォーマット(format)に一致した文字列(src)をdatetime型にキャストして
    M D Y のみのdatetimeを取得します。
    
    @param src: 変換文字列
    @type src: str
    @param format: 文字列フォーマット
    @type format: str
    @param whole_day: 一日の最終時刻まで
    @type whole_day: boolean
    @return: datetime型
    @rtype: datetime
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    _t = time.strptime(src, format)
    if whole_day is True:
        target = datetime.datetime(_t.tm_year, _t.tm_mon, _t.tm_mday, 23, 59)
    else:
        target = datetime.datetime(_t.tm_year, _t.tm_mon, _t.tm_mday)
    return target

def unixtime():
    """<comment-ja>
    UTCのエポックタイムを返却します。
    @rtype: float
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return time.time()

def unixtime_str():
    """<comment-ja>
    UTCのエポックタイムを文字列として返却します。
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return "%f" % unixtime()

def getfilesize(filepath):
    """<comment-ja>
    指定されたファイルのサイズを返却します。
    @rtype: long
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return os.stat(filepath)[stat.ST_SIZE]

def getfilesize_str(filepath):
    """<comment-ja>
    指定されたファイルのサイズを文字列で返却します。
    @rtype: str
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return "%ld" % getfilesize(filepath)

def get_filesize_MB(size):
    """
    <comment-ja>
    サイズ(str)をMBに変換する。
    @param size: サイズ
    @type size: str
    @return: MB
    @rtype: long
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    return long(math.ceil(float(size) / 1024 / 1024))

def replace_None(obj, replace_item):
    """<comment-ja>
    __dict__から要素がNone, あるいは空文字('')のものを指定の要素に置き換えます
    @param __dict__をもつオブジェクト
    @rtype: object
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    for k,v in obj.__dict__.iteritems():
        if v == None or v == '':
            obj.__dict__[k] = replace_item
    return obj

def is_readable(path):
    """<comment-ja>
    指定されたパスが読み込み可能かどうか判定する
    @param path:ファイルパス
    @return: 可能ならTrue、不可能ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    test the readability of path
    </comment-en>
    """
    return os.access(path, os.R_OK)

def is_writable(path):
    """<comment-ja>
    指定されたパスが書き込み可能かどうか判定する
    @param path:ファイルパス
    @return: 可能ならTrue、不可能ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    test the readability of path
    </comment-en>
    """
    return os.access(path, os.W_OK)

def is_executable(path):
    """<comment-ja>
    指定されたパスが実行可能かどうか判定する
    @param path:ファイルパス
    @return: 可能ならTrue、不可能ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    test the readability of path
    </comment-en>
    """
    return os.access(path, os.X_OK)

def r_chown(path,owner):
    """<comment-ja>
    指定されたパス配下のディレクトリのオーナーを再帰的に変更する
    @param path:オーナーを変更したいパス
    @param owner:ユーザー名もしくがユーザーID、「:」で続けてグループを指定可能
    @return: 成功ならTrue、失敗ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    owner = str(owner)
    if not os.path.exists(path):
        return False

    if ':' in owner:
        user, group = owner.split(':')
    else:
        user, group = [owner,None ]

    if is_int(user) is not True:
        try:
            pw = pwd.getpwnam(user)
        except:
            return False
    else:
        try:
            pw = pwd.getpwuid(int(user))
        except:
            return False
    uid = pw[2]

    if group == None:
        statinfo = os.stat(path)
        gid = statinfo.st_gid
    else:
        if is_int(group) is not True:
            try:
                gr = grp.getgrnam(group)
            except:
                return False
        else:
            try:
                gr = grp.getgrgid(int(group))
            except:
                return False
        gid = gr[2]

    if os.path.isfile(path) or os.path.islink(path):
        try:
            os.chown(path,uid,gid)
        except:
            return False

    elif os.path.isdir(path):
        try:
            os.chown(path,uid,gid)
        except:
            return False

        for name in os.listdir(path):
            sub_path = os.path.join(path, name)
            r_chown(sub_path,owner)

    return True

def r_chgrp(path,group):
    """<comment-ja>
    指定されたパス配下のディレクトリのグループを再帰的に変更する
    @param path:グループを変更したいパス
    @param group:グループ名もしくがグループID
    @return: 成功ならTrue、失敗ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    group = str(group)
    if not os.path.exists(path):
        return False

    statinfo = os.stat(path)
    uid = statinfo.st_uid

    if is_int(group) is not True:
        try:
            gr = grp.getgrnam(group)
        except:
            return False
    else:
        try:
            gr = grp.getgrgid(int(group))
        except:
            return False
    gid = gr[2]

    if os.path.isfile(path) or os.path.islink(path):
        try:
            os.chown(path,uid,gid)
        except:
            return False

    elif os.path.isdir(path):
        try:
            os.chown(path,uid,gid)
        except:
            return False

        for name in os.listdir(path):
            sub_path = os.path.join(path, name)
            r_chgrp(sub_path,group)

    return True

def r_chmod(path,perm):
    """<comment-ja>
    指定されたパス配下のディレクトリのグループを再帰的に変更する
    @param path:グループを変更したいパス
    @param perm:パーミッション
    @return: 成功ならTrue、失敗ならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """

    perm_regex = re.compile(r"""^(?P<user>[ugo]{0,3})(?P<action>[\+\-])(?P<value>[rwxst]{1,3})$""")

    user_table = {"u":"USR","g":"GRP","o":"OTH"}
    perm_table = {"r":"R","w":"W","x":"X"}

    if not os.path.exists(path):
        return False

    original_perm = perm
    if is_int(perm):
        if type(perm) == str:
            perm = oct2dec(perm)
        new_perm = perm
    else:
        s = os.lstat(path)
        new_perm = stat.S_IMODE(s.st_mode)

        m = perm_regex.match(perm)
        if m:
            user = m.group('user')
            action = m.group('action')
            value = m.group('value')
            if user == "":
                user = "ugo"

            mask_perm = 0
            for k,v in user_table.iteritems():
                if k in user:
                    for k2,v2 in perm_table.iteritems():
                        if k2 in value:
                            exec("bit = stat.S_I%s%s" % (v2,v,))
                            mask_perm = mask_perm | bit


            if "t" in value:
                bit = stat.S_ISVTX
                mask_perm = mask_perm | bit

            if "s" in value:
                if "u" in user:
                    bit = stat.S_ISUID
                    mask_perm = mask_perm | bit
                if "g" in user:
                    bit = stat.S_ISGID
                    mask_perm = mask_perm | bit

            #print "new_perm1:" + dec2oct(new_perm)
            #print "mask_perm:" + dec2oct(mask_perm)
            if action == "-":
                new_perm = new_perm & (~ mask_perm)
            elif action == "+":
                new_perm = new_perm | mask_perm
            #print "new_perm2:" + dec2oct(new_perm)

        else:
            return False

    if os.path.isfile(path) or os.path.islink(path):
        try:
            os.chmod(path,new_perm)
        except:
            return False

    elif os.path.isdir(path):
        try:
            os.chmod(path,new_perm)
        except:
            return False

        for name in os.listdir(path):
            sub_path = os.path.join(path, name)
            r_chmod(sub_path,original_perm)

    return True

def is_dict_value(value, dic):
    """<comment-ja>
    指定された値が辞書にあるか調べる
    @param value:調べたい値
    @param dic:辞書
    @return: 辞書にあればTrue、ないならFalse
    @rtype: bool
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    for key in dic.keys():
        if value == dic[key]:
            return True
    return False

#def is_number(string):
#    """<comment-ja>
#    文字列が数字のみで構成されているか調べる
#    @param string:調べたい文字列
#    @return: 数字のみならTrue、そうでないならFalse
#    @rtype: bool
#    </comment-ja>
#    <comment-en>
#    TODO: English Comment
#    </comment-en>
#    """
#    pattern = re.compile('^[\d]+$')
#    if pattern.match(string):
#        return True
#    return False

def is_empty(string):
    """<comment-ja>
    文字列が空かどうか調べる
    @param string: 調べたい文字列
    @return: 文字列が空ならTrue、そうでないならFalse
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if string and 0 < len(string.strip()):
        return False
    else:
        return True

def uniq_filename():
    """<comment-ja>
    ユニークなファイル名を返却する。
    @param filename: 既存のファイル名
    @return: ユニークなファイル名
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return unixtime_str()

def get_model_name(model):
    """<comment-ja>
    モデル名を返却する。
    @param model: モデル
    @return: モデル名
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if hasattr(model, "__repr__"):
        return repr(model).split("<")[0]
    else:
        return None


def chk_create_disk(target, disk_size):
    """<comment-ja>
    指定されたフォルダ/ファイルが属するパーティションに、指定したサイズのファイルが作成できるか。
    比較単位はMB

    @param target: 調べるファイル/フォルダパス
    @type target: str 
    @param disk_size:
    @return: OK=True | NG=False
    @rtype: bool
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    partition = get_partition_info(target, header=False)
    available = long(partition[3][0])
    if 0 < (available * CHECK_DISK_QUOTA - float(disk_size)):
        return True
    else:
        return False

def get_partition_info(target, header=False):
    """<comment-ja>
    指定したファイル/フォルダパスのパーティション情報(dfコマンドの結果)を取得する。
     - return
       - 0: 'Filesystem' デバイス名
       - 1: '1048576-blocks' 最大サイズ
       - 2: 'Used' 使用サイズ
       - 3: 'Available' ディスク残量
       - 4: 'Capacity' 使用率
       - 5: 'Mounted' マウント先
    値はすべてMB

    @param target: 調べるファイル/フォルダパス
    @type target: str
    @param header: ヘッダ情報を表示するか
    @type header: bool
    @rtype: dict
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    if os.path.exists(target) is True:
        ret = {}
        if header is True:
            pipe = os.popen("LANG=C /bin/df -P -m " + target)
            try:
                data = []
                for line in pipe.readlines():
                    data.append(re.sub(r'[ \t]', ' ', line).split())
            finally:
                pipe.close()

            for i in range(0,6):
                ret[i] = (data[0][i], data[1][i])
        else:
            pipe = os.popen("LANG=C /bin/df -P -m %s | /bin/sed -n 2p" % target)
            try:
                line = pipe.read()
            finally:
                pipe.close()

            data = re.sub(r'[ \t]', ' ', line).split()

            for i in range(0,6):
                ret[i] = (data[i],)

        return ret
    else:
        return None

def uni_force(string, system="utf-8"):
    """
    <comment-ja>
    systemで指定された文字コードもしくは、["ascii", "utf-8", "euc-jp", "cp932", "shift-jis"]で強制的にunicodeへ変換します。

    @param string: 変換文字列
    @type string: str
    @param system: 文字コード
    @type system: str
    @return: Unicode文字列
    @rtype: str
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    if isinstance(string, unicode) is True:
        return string
    else:
        try:
            return unicode(string, system)
        except:
            encodings = ["ascii", "utf-8", "euc-jp", "cp932", "shift-jis"]
            for encode in encodings:
                try:
                    return unicode(string, encode)
                except:
                    pass
            raise KaresansuiLibException("Character code that can be converted to unicode.")

def get_ifconfig_info(name=None):
    """
    <comment-ja>
    ネットワークデバイス情報を取得する

    @param name: 取得したいデバイス名(省略時は全デバイス情報が指定されたとみなす) 「regex:^eth」のようにプレフィックスにregex:を付けると正規表現にマッチしたデバイス名の情報を全て取得できる。
    @return:    デバイス情報が格納されたdict配列
                配列の内容例
                {'eth0': {   'bcast': '172.16.0.255',
                             'device': 'eth0',
                             'hwaddr': '00:1D:09:D7:30:4B',
                             'ipaddr': '172.16.0.10',
                             'ipv6addr': 'fe80::21d:9ff:fed7:304b/64',
                             'link': 'Ethernet',
                             'mask': '255.255.255.0',
                             'metric': '1',
                             'mtu': '1500',
                             'running': True,
                             'scope': 'Link',
                             'up': True,
                             'use_bcast': 'BROADCAST',
                             'use_mcast': 'MULTICAST'}}

    </comment-ja>
    <comment-en>
    Get computer's network interface information

    @param name: network device name
    @return: a dict with: ipaddr, hwaddr, bcast, mask etc...
    @rtype: dict
    </comment-en>
    """
    info = {}

    _ifconfig = '/sbin/ifconfig'
    command_args = [_ifconfig,'-a']

    old_lang = os.environ['LANG']
    os.environ['LANG'] = 'C'
    (ret,res) = execute_command(command_args)
    os.environ['LANG'] = old_lang

    if ret != 0:
        return info

    device_regex = re.compile(r"""^(?P<device>[\S\:]+)\s+Link encap:(?P<link>(\S+ ?\S+))(\s+HWaddr (?P<hwaddr>[0-9a-fA-F:]+))?""")
    ipv4_regex = re.compile(r"""^\s+inet addr:\s*(?P<ipaddr>[0-9\.]+)(\s+Bcast:(?P<bcast>[0-9\.]+))?\s+Mask:(?P<mask>[0-9\.]+)""")
    ipv6_regex = re.compile(r"""^\s+inet6 addr:\s*(?P<ipv6addr>[0-9a-fA-F\:\/]+)\s+Scope:(?P<scope>\S+)""")
    status_regex = re.compile(r"""^\s+((?P<up>UP)\s+)?((?P<use_bcast>(BROADCAST|LOOPBACK))\s+)?((?P<running>RUNNING)\s+)?((?P<use_mcast>(MULTICAST|NOARP))\s+)?MTU:(?P<mtu>[0-9]+)\s+Metric:(?P<metric>[0-9]+)""")

    _info = {}
    for aline in res:
        if aline.strip() == "":

            cidr = None
            netlen = None

            if ipaddr is not None and mask is not None:
                netaddr = NetworkAddress("%s/%s" % (ipaddr,mask,))
                cidr = netaddr.get('cidr')
                netlen = netaddr.get('netlen')

            _info[device] = {
                           "device":device,
                           "link":link,
                           "hwaddr":hwaddr,
                           "ipaddr":ipaddr,
                           "bcast":bcast,
                           "mask":mask,
                           "ipv6addr":ipv6addr,
                           "scope":scope,
                           "up":up,
                           "running":running,
                           "use_bcast":use_bcast,
                           "use_mcast":use_mcast,
                           "mtu":mtu,
                           "metric":metric,
                           "cidr":cidr,
                           "netlen":netlen,
                           }
        m = device_regex.match(aline)
        if m:
            device = m.group('device')
            link = m.group('link')
            hwaddr = m.group('hwaddr')
            ipaddr = None
            bcast = None
            mask = None
            ipv6addr = None
            scope = None
            up = False
            running = False
            use_bcast = None
            use_mcast = None
            mtu = None
            metric = None

        m = ipv4_regex.match(aline)
        if m:
            ipaddr = m.group('ipaddr')
            bcast = m.group('bcast')
            mask = m.group('mask')

        m = ipv6_regex.match(aline)
        if m:
            ipv6addr = m.group('ipv6addr')
            scope = m.group('scope')

        m = status_regex.match(aline)
        if m:
            if m.group('up') == 'UP':
                up = True
            use_bcast = m.group('use_bcast')
            if m.group('running') == 'RUNNING':
                running = True
            use_mcast = m.group('use_mcast')
            mtu = m.group('mtu')
            metric = m.group('metric')

    all_info = dict_ksort(_info)
    #import pprint
    #pp = pprint.PrettyPrinter(indent=4)
    #pp.pprint(all_info)

    if name == None:
        return all_info

    regex_regex = re.compile(r"""^regex:(?P<regex>.*)""")
    m = regex_regex.match(name)

    for dev,value in all_info.iteritems():
        if m == None:
            if dev == name:
                info[dev] = value
                return info
        else:
            regex = m.group('regex')
            query_regex = re.compile(r""+regex+"")
            n = query_regex.search(dev)
            if n != None:
                info[dev] = value
    return info

def get_proc_meminfo(path="/proc/meminfo"):
    if os.path.isfile(path) is False:
        return None

    fp = open(path, "r")
    try:
        ret = {}
        for line in fp.readlines():
            val = line.split(":")
            key = re.sub(r'[\t\n]', '', val[0].strip())
            value = re.sub(r'[\t\n]', '', val[1]).strip()
            invalue = value.split(" ")
            if len(invalue) > 1:
                ret[key] = (invalue[0], invalue[1])
            else:
                ret[key] = (invalue[0])

        return ret
    except:
        return None

def get_proc_cpuinfo(path="/proc/cpuinfo"):
    if os.path.isfile(path) is False:
        return None

    fp = open(path, "r")
    try:
        ret = {}
        i = 0
        ret[i] = {}
        for line in fp.readlines():
            if len(line.strip()) <= 0:
                i += 1
                ret[i] = {}
            else:
                val = line.split(":")
                key = re.sub(r'[\t\n]', '', val[0].strip())
                value = re.sub(r'[\t\n]', '', val[1]).strip()
                ret[i][key] = value

        if len(ret[len(ret)-1]) <= 0:
            ret.pop(len(ret)-1)

        return ret
        
    except:
        return None

def get_process_id(command=None,regex=False):
    """
    <comment-ja>
    指定した文字列のプロセスIDを取得する

    @param command: コマンド文字列
    @type command: str
    @param regex: 正規表現による指定かどうか
    @type regex: boolean
    @return: プロセスIDのリスト
    @rtype: list
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>

    >>> from ps_match import get_process_id
    >>> get_process_id("libvirtd",regex=True)
    ['26859']
    >>> get_process_id("/usr/sbin/libvirtd --daemon --config /etc/libvirt/libvirtd.conf --listen --pid-file=/var/run/libvirtd.pid",regex=False)
    ['26859']
    """

    retval = []

    proc_dir = "/proc"
    cmdline_file_glob = "%s/[0-9]*/cmdline" % (proc_dir,)
    for _file in glob.glob(cmdline_file_glob):
        try:
            data = open(_file).read()
            data = re.sub("\0"," ",data)
            pid = os.path.basename(os.path.dirname(_file))
            if regex is False:
                if data.strip() == command:
                    retval.append(pid)
            else:
                if re.search(command,data):
                    retval.append(pid)
        except:
            pass
    return retval

def json_dumps(obj, **kw):
    """
    <comment-ja>
    PythonオブジェクトをJSONオブジェクトに変換する。

    @param obj: Pythonオブジェクト
    @type obj: str or dict or list or tuple or None or bool
    @param kw: 追加引数
    @type kw: str or dict or list or tuple or None or bool
    @return: JSONオブジェクト
    @rtype: str
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    import simplejson as json
    return json.dumps(obj, ensure_ascii=False, encoding="utf-8", **kw)

def is_path(target):
    """
    <comment-ja>
    指定された値が、パス名かどうか

    @param target: 調べるパス名
    @type target: str 
    @return: OK=True | NG=False
    @rtype: bool
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    _path, _file = os.path.split(target)
    if _path != "":
        return True
    else:
        return False

def get_keymaps(dir_path='/usr/share/xen/qemu/keymaps'):
    """<comment-ja>
    指定されたKeymapフォルダのファイル名からKeymapのリストを取得する。
    </comment-ja>
    <comment-en>
    English Comment
    </comment-en>
    """
    ret = []
    if os.path.isdir(dir_path) is True:
        for _file in os.listdir(dir_path):
            if len(_file)==2 or (len(_file)==5 and _file[2:3]=='-'):
                ret.append(_file)
    return sorted(ret)

def findFile(dir, pattern):
    fullPattern = os.path.join(dir,pattern)
    return glob.glob(fullPattern)

def findFileRecursive(topdir=None, pattern="*.*", nest=False, verbose=False):
    allFilenames = list()
    # current dir
    if verbose:
        print "*** %s" %topdir
    if topdir is None: topdir = os.getcwd()
    filenames = findFile(topdir, pattern)
    if verbose:
        for filename in [os.path.basename(d) for d in filenames]:
            print "   %s" %filename
    allFilenames.extend(filenames)
    # possible sub dirs
    names = [os.path.join(topdir, dir) for dir in os.listdir(topdir)]
    dirs = [n for n in names if os.path.isdir(n)]
    if verbose:
        print "--> %s" % [os.path.basename(d) for d in dirs]
    if len(dirs) > 0:
        for dir in dirs:
            filenames = findFileRecursive(dir, pattern, nest, verbose)
            if nest:
                allFilenames.append(filenames)
            else:
                allFilenames.extend(filenames)
    # final result
    return allFilenames

def available_kernel_modules():
    ret = []
    modules_dir = "/lib/modules/%s" % os.uname()[2]
    if os.path.isdir(modules_dir) is True:
        for k in findFileRecursive(modules_dir,"*.ko"):
            ret.append(os.path.basename(k)[0:-3])
        for k in findFileRecursive(modules_dir,"*.o"):
            ret.append(os.path.basename(k)[0:-2])
    ret = sorted(ret)
    ret = [p for p, q in zip(ret, ret[1:] + [None]) if p != q]
    return ret

def loaded_kernel_modules():
    proc_modules = "/proc/modules"
    if os.path.isfile(proc_modules) is False:
        return None

    ret = []
    fp = open(proc_modules, "r")
    try:
        for line in fp.readlines():
            if len(line.strip()) > 0:
                val = line.split(" ")
                ret.append(val[0])
        fp.close()
    except:
        return None

    return ret

def is_loaded_kernel_module(module=None):
    return module in loaded_kernel_modules()

def loaded_kernel_module_dependencies(module=None):
    if not module in loaded_kernel_modules():
        return None

    proc_modules = "/proc/modules"
    if os.path.isfile(proc_modules) is False:
        return None

    ret = []
    fp = open(proc_modules, "r")
    try:
        for line in fp.readlines():
            if len(line.strip()) > 0:
                val = line.split(" ")
                if val[0] == module and val[3] != "-":
                    ret = val[3].split(",")
                    ret.pop()
        fp.close()
    except:
        return None

    return ret

def load_kernel_module(module=None):
    if is_loaded_kernel_module(module):
        return False
    if module in available_kernel_modules():
        command_args = ["/sbin/modprobe",module]
        ret = execute_command(command_args)
        if is_loaded_kernel_module(module) is False:
            return False
    else:
        return False
    return True

def unload_kernel_module(module=None,force=False):
    if is_loaded_kernel_module(module) is False:
        return False
    else:
        if force is True:
            for k in loaded_kernel_module_dependencies(module):
                unload_kernel_module(k,force)
        command_args = ["/sbin/rmmod",module]
        ret = execute_command(command_args)
        if is_loaded_kernel_module(module):
            return False
    return True

def available_virt_mechs():
    """<comment-ja>
    </comment-ja>
    <comment-en>
    get list of usable virtualization mechanisms
    </comment-en>
    """
    ret = []
    if os.access("/proc/xen", os.R_OK):
        ret.append("XEN")
    if is_loaded_kernel_module("kvm"):
        ret.append("KVM")

    return sorted(ret)


def sh_config_read(filename):
    import re
    regex = re.compile("\s*=\s*")
    value_quote_regex = re.compile("\".*\"")

    ret = {}
    try:
        fp = open(filename,"r")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
        for line in fp.readlines():
            line = line.strip()
            if len(line) <= 0 or line[0] == "#":
                continue
            key, value = regex.split(line,1)
            #ret[key] = value
            value = re.sub(r"^\"(.*)\"$", r"\1", value)
            value = re.sub(r"^'(.*)'$", r"\1", value)
            ret[key] = value
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
    except:
        ret = False

    return ret

def sh_config_write(filename,opts):
    ret = True

    res = {}
    if type(opts) == dict:
        res = opts
    else:
        for k in dir(opts):
            res[k] = getattr(opts,k)

    try:
        fp = open(filename,"w")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_EX)
        for k,v in res.iteritems():
            if type(v) == str and k[0:2] != "__" and k[0:4] != "pass":
                fp.write("%s = %s\n" % (k, v,))
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
    except:
        ret = False

    return ret

def available_virt_uris():
    """<comment-ja>
    </comment-ja>
    <comment-en>
    get list of libvirt's uri
    </comment-en>
    """
    from karesansui.lib.const import VIRT_LIBVIRTD_CONFIG_FILE, \
               VIRT_LIBVIRT_SOCKET_RW, VIRT_LIBVIRT_SOCKET_RO, \
               KVM_VIRT_URI_RW, KVM_VIRT_URI_RO, \
               XEN_VIRT_URI_RW, XEN_VIRT_URI_RO

    uris = {}
    mechs = available_virt_mechs()
    if len(mechs) == 0:
        mechs = ['KVM']

    for _mech in mechs:
        hostname = "127.0.0.1"
        if _mech == "XEN":
            uris[_mech] = XEN_VIRT_URI_RW
        if _mech == "KVM":
            if os.path.exists(VIRT_LIBVIRTD_CONFIG_FILE):
                opts = sh_config_read(VIRT_LIBVIRTD_CONFIG_FILE)
                uri_prefix = "qemu"
                uri_suffix = ""
                uri_args = ""

                try:
                    if opts["listen_tcp"] == "1":
                        uri_prefix = "qemu+tcp"
                        try:
                            opts["tcp_port"]
                            port_number = opts["tcp_port"]
                        except:
                            port_number = "16509"
                except:
                    pass

                try:
                    if opts["listen_tls"] == "1":
                        uri_prefix = "qemu+tls"
                        try:
                            opts["tls_port"]
                            port_number = opts["tls_port"]
                        except:
                            port_number = "16514"
                        uri_args += "?no_verify=1"
                        hostname = os.uname()[1]
                except:
                    pass

                try:
                    port_number
                    uri_suffix += ":%s/system%s" % (port_number, uri_args,)
                except:
                    uri_suffix += "/system%s" % (uri_args,)

                #print "%s://%s%s" % (uri_prefix,hostname,uri_suffix,)
                uris[_mech] = "%s://%s%s" % (uri_prefix,hostname,uri_suffix,)
            else:
                uris[_mech] = KVM_VIRT_URI_RW

    return uris

def file_type(file):
    command_args = [ "file", file, ]
    (rc,res) = execute_command(command_args)
    if rc != 0:
        return None
    else:
        return res[0].replace("%s: " % file, "")

def is_vmdk_format(file):
    try:
        f = open(file, "rb")
        return f.read(4) == "KDMV"
    except:
        return False

def is_iso9660_filesystem_format(file):

    retval = False

    magic  = "CD001"
    extra_magic = "EL TORITO SPECIFICATION" # bootable
    offset       = 32769
    label_offset = 32808
    extra_offset = 34823

    if not os.path.exists(file) or os.stat(file).st_size < offset+len(magic):
        return retval

    try:
        regex = re.compile(r"""\S""")
 
        f = open(file,"rb")
        f.seek(offset)
        header = f.read(len(magic))

        if header != magic:
            return retval

        label = ""
        step = 0
        for cnt in xrange(label_offset, label_offset + 100):
            f.seek(cnt)
            char = f.read(1)
            #print cnt,  
            #print "%x" % ord(char)
            if ord(char) == 0 or char == '\0':
                step = step + 1
                if step == 2:
                    break
            #elif regex.match(char):
            else:
                label += char

        label = label.strip()

        f.seek(extra_offset)
        data = f.read(len(extra_magic))
        if data == extra_magic:
            label += "(bootable)"

        f.close()

        retval = label
    except:
        pass

    return retval

def is_windows_bootable_iso(file):
    retval = False
    regexes = {
      "Windows XP Home"                  :"WXH(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Professional"          :"WXP(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Home (SP1)"            :"XRMH(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Professional (SP1)"    :"XRMP(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Home (SP1a)"           :"X1AH(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Professional (SP1a)"   :"X1AP(CCP|FPP|OEM|VOL|OCCP)_[A-Z]{2}",
      "Windows XP Home (SP2)"            :"VRMH(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Professional (SP2)"    :"VRMP(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Home (SP2b)"           :"VX2H(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Professional (SP2b)"   :"VX2P(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Home (SP3)"            :"GRTMH(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Home K (SP3)"          :"GRTMHK(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Home KN (SP3)"         :"GRTMHKN(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Professional (SP3)"    :"GRTMP(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Professional K (SP3)"  :"GRTMPK(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP Professional KN (SP3)" :"GRTMPKN(CCP|FPP|OEM|VOL)_[A-Z]{2}",
      "Windows XP from Dell"             :"XP2_(PER|PRO)_ENG",
      "Windows 7 Professional"           :"WIN_7_PROFESSIONAL",
      "Windows 7"                        :"WIN7",
     }
    label = is_iso9660_filesystem_format(file)
    if label is not False:
        for k,v in regexes.iteritems():
            regex_str = "%s.*\(bootable\)" % v
            regex = re.compile(regex_str)
            if regex.search(label):
                retval = k
                break
    return retval

def is_linux_bootable_iso(file):
    retval = False
    regexes = {
      "Asianux"               :"Asianux",
      "MIRACLE LINUX \\1.\\2" :"MLSE([0-9])([0-9])",
      "Turbolinux"            :"Turbolinux",
      "Fedora Core \\1"       :"^FC/([0-9\.]*)",
      "Fedora \\1 \\2"        :"^Fedora ([0-9\.]+) (i386|x86_64)",
      "CentOS \\2"            :"CentOS( \-_)([0-9].[0-9])",
      "Red Hat Enterprise Linux \\2 \\3":"RHEL(/|\-)([0-9\.\-U]) (i386|x86_64)",
      "Red Hat Linux/\\1"     :"Red Hat Linux/(.+)",
      "openSUSE-\\1.\\2"      :"^SU(1[0-3])([0-9])0.00",
      "Debian \\1"            :"^Debian (.+)",
      "Buildix"               :"^Buildix",
      "Ubuntu \\1"            :"^Ubuntu ([0-9].+)",
      "Ubuntu Server \\1"     :"^Ubuntu-Server (.+)",
     }
    label = is_iso9660_filesystem_format(file)
    if label is not False:
        for k,v in regexes.iteritems():
            regex_str = "%s.*\(bootable\)" % v
            regex = re.compile(regex_str)
            if regex.search(label):
                retval = re.sub(r"""%s\(bootable\)""" % v,k,label).strip()
                break
    return retval

def is_darwin_bootable_iso(file):
    retval = False
    regexes = {
      "DARWIN \\1" :"^DARWIN(.+)",
     }
    label = is_iso9660_filesystem_format(file)
    if label is not False:
        for k,v in regexes.iteritems():
            regex_str = "%s.*\(bootable\)" % v
            regex = re.compile(regex_str)
            if regex.search(label):
                retval = re.sub(r"""%s\(bootable\)""" % v,k,label).strip()
                break
    return retval

def sizeunit_to_byte(string):
    import re
    import math

    unit_map = { "b" : 1024**0, "k" : 1024**1, "m" : 1024**2, "g" : 1024**3 }
    p = re.compile(r"""^(?P<bytes>[\d\.]+)(?P<unit>[gmkb]?)$""", re.IGNORECASE)
    m = p.match(string)
    if not m:
        return None
    size = float(m.group("bytes")) * unit_map.get(m.group("unit").lower(), 1)

    #return math.round(size)
    return int(math.floor(size))

def sizeunit_format(size,unit="b",digit=1):
    import re
    import math

    unit_map = { "b" : 1024**0, "k" : 1024**1, "m" : 1024**2, "g" : 1024**3 }
    string = float (size) / unit_map.get(unit, 1)

    return "%s%c" % (round(string,digit), unit.upper(),)

def get_disk_img_info(file):
    import re

    if not os.path.exists(file):
        return None

    command_args = [
          "qemu-img",
          "info",
          file,
          ]
    (rc,res) = execute_command(command_args)
    if rc != 0:
        ret = {}
        ftype = file_type(file)
        if ftype != None:
            if re.match(r'^QEMU Copy-On-Write disk image version 1', ftype):
                ret["file_format"] = "qcow"
            elif re.match(r'^QEMU Copy-On-Write disk image version 2', ftype):
                ret["file_format"] = "qcow2"
            elif re.match(r'^User-mode Linux COW file, version 2', ftype):
                ret["file_format"] = "cow"
            elif re.match(r'^data', ftype):
                if is_vmdk_format(file):
                    ret["file_format"] = "vmdk"
                else:
                    ret["file_format"] = "raw"
            else:
                ret["file_format"] = "unknown"
        ret["real_size"] = os.path.getsize(file)
        return ret

    else:
        regex = re.compile(":\s*")
        regex_bracket = re.compile(r"""^(?P<unitformat>.+) \((?P<bytes>[0-9\.]+) bytes\)""")
        ret = {}
        for line in res:
            try:
                key, value = regex.split(line,1)
                if key == "file format":
                    ret["file_format"] = value
                elif key == "virtual size":
                    m = regex_bracket.match(value)
                    ret["virtual_size"] = int(m.group("bytes"))
                elif key == "disk size":
                    ret["disk_size"] = sizeunit_to_byte(value)
                elif key == "cluster_size":
                    ret["cluster_size"] = int(value)
            except:
                pass 
        ret["real_size"] = os.path.getsize(file)
        return ret

def array_replace(array, pattern=None, replace=None, mode="og"):

    if type(array) != list:
        return array

    regex_mode = 0
    once_match_only = False
    search_cnt = 1

    cnt = 0
    while cnt < len(mode):
        if mode[cnt] == 'o':
            once_match_only = True
        if mode[cnt] == 'g':
            search_cnt = 0
        if mode[cnt] == 'i':
            regex_mode = re.IGNORECASE

        cnt += 1

    if type(pattern) is str and type(replace) is str:
        pattern = [pattern]
        replace = [replace]

    if type(pattern) is list and type(replace) is list and len(pattern) == len(replace):
        new_array = []
        for k in array:
            cnt = 0
            #print k,
            #print " => ",
            while cnt < len(pattern):
                p = re.compile("%s" % pattern[cnt],regex_mode)
                if p.search(k):
                    k = p.sub(replace[cnt], k, search_cnt) 
                    if once_match_only is True:
                        break
                cnt += 1
            #print k
            new_array.append(k)

        return new_array
    else:
        return array

def file_contents_replace(filename, new_filename, pattern=None, replace=None, mode="og"):

    lines = []
    try:
        fp = open(filename,"r")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
        for line in fp.readlines():
            lines.append(line)
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
    except:
        return False

    if len(lines) > 0:
        lines = array_replace(lines,pattern,replace,mode)
        try:
            fp = open(new_filename,"w")
            fcntl.lockf(fp.fileno(), fcntl.LOCK_EX)
            for line in lines:
                fp.write(line)
            fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
            fp.close()
        except:
            return False

    return True

def get_inspect_stack(prettyprint=False):
    import inspect

    stack_content = [
      'frame obj  ', 'file name  ', 'line num   ',
      'function   ', 'context    ', 'index      ',
    ]
    context, frame = 1, 2

    retval = dict(zip(stack_content, inspect.stack(context)[frame]))

    if prettyprint is True:
        preprint_r(retval)

    return retval

def get_dom_list():
    from karesansui.lib.const import VIRT_XML_CONFIG_DIR
    retval = []
    for _name in os.listdir(VIRT_XML_CONFIG_DIR):
        if _name[-4:] == ".xml":
            _path = os.path.join(VIRT_XML_CONFIG_DIR, _name)
            doc = get_xml_parse(_path)
            domain_name = get_xml_xpath(doc,'/domain/name/text()')
            retval.append(domain_name)
    return retval

def get_dom_type(domain):
    from karesansui.lib.const import VIRT_XML_CONFIG_DIR
    retval = None
    _path = os.path.join(VIRT_XML_CONFIG_DIR, domain+".xml")
    if os.path.exists(_path):
        doc = get_xml_parse(_path)
        retval = get_xml_xpath(doc,'/domain/@type')
    return retval

def base64_encode(string=""):
    import base64

    if type(string) == unicode:
        string = string.encode("utf-8")
    elif type(string) == str:
        pass
    else:
        raise

    return base64.b64encode(string)

def base64_decode(string=""):
    import base64

    if type(string) == str:
        pass
    else:
        raise

    return base64.b64decode(string)

def get_system_user_list():
    """<comment-ja>
    登録されているシステムユーザリストを/etc/passwd形式で取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    info = []
    _getent = '/usr/bin/getent'
    command_args = [_getent,'passwd']

    old_lang = os.environ['LANG']
    os.environ['LANG'] = 'C'
    (ret,res) = execute_command(command_args)
    os.environ['LANG'] = old_lang

    if ret != 0:
        return info

    for user in res:
        info.append(user.split(':'))
    return info

def get_system_group_list():
    """<comment-ja>
    登録されているシステムグループリストを/etc/group形式で取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    info = []
    _getent = '/usr/bin/getent'
    command_args = [_getent,'group']

    old_lang = os.environ['LANG']
    os.environ['LANG'] = 'C'
    (ret,res) = execute_command(command_args)
    os.environ['LANG'] = old_lang

    if ret != 0:
        return {}

    for group in res:
        info.append(group.split(':'))
    return info

def str_repeat(string="",count=1):
    """<comment-ja>
    文字列を繰り返す
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    retval = ""
    for _cnt in range(0,count):
       retval = "%s%s" % (retval,string,)
    return retval

def _php_array_to_python_dict(string=""):
    """<comment-ja>
    PHPのvar_export形式の文字列をpythonの辞書文字列に変換する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    lines = string.split("\n")

    array_depth = 0

    regex_array_s = " *array *\("
    regex_array_e = " *\)(?P<comma>,?)"
    regex_list    = " *[0-9]+ *=> *(?P<value>.+)"
    regex_dict    = " *(?P<key>'.+') *=> *"

    array_types = []
    _b_array = False
    new_lines = []
    for _aline in lines:
        indent = ""
        if array_depth > 0:
            indent = str_repeat("   ",array_depth-1)
        m_array_s = re.match(regex_array_s,_aline.rstrip())
        m_array_e = re.match(regex_array_e,_aline.rstrip())
        m_list    = re.match(regex_list   ,_aline)
        m_dict    = re.match(regex_dict   ,_aline)
        if m_array_s is not None:
            array_depth = array_depth + 1
            _b_array = True
            continue
        elif m_array_e is not None:
            array_depth = array_depth - 1
            array_type = array_types.pop()
            if array_type == "list":
                new_aline = "%s]%s" % (indent,m_array_e.group('comma'),)
            if array_type == "dict":
                new_aline = "%s}%s" % (indent,m_array_e.group('comma'),)
            _b_array = False
        elif m_list is not None:
            if _b_array is True:
                array_types.append("list")
                new_aline = "%s[" % indent
                new_lines.append(new_aline)
            value = m_list.group('value')
            new_aline = "%s%s" % (indent,re.sub("'","\'",value),)
            _b_array = False
        elif m_dict is not None:
            if _b_array is True:
                array_types.append("dict")
                new_aline = "%s{" % indent
                new_lines.append(new_aline)
            key = m_dict.group('key')
            value = re.sub(regex_dict,"%s:" % key, _aline)
            new_aline = "%s%s" % (indent,value,)
            _b_array = False
        else:
            new_aline = "%s%s" % (indent,_aline,)
            _b_array = False

        new_aline = re.sub("':false,","':False,", new_aline)
        new_aline = re.sub("':true," ,"':True," , new_aline)
        new_lines.append(new_aline)

    #print "\n".join(new_lines)
    return "\n".join(new_lines)
 
def python_dict_to_php_array(dictionary={},var_name=""):
    """<comment-ja>
    pythonの辞書配列をPHPの連想配列(できればvar_export形式)の文字列に変換する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    import signal

    dict_str = preprint_r(dictionary,return_var=True)
    dict_str = dict_str.replace('{','array(')
    dict_str = dict_str.replace('\':','\' =>')
    dict_str = dict_str.replace('}',')')
    dict_str = dict_str.replace('=> [','=> array(')
    dict_str = dict_str.replace('])','))')
    dict_str = re.sub("\)$",')',dict_str)

    php_start = "<?php\n"
    php_end   = "?>\n"

    # Convert var_export format
    _php = "/usr/bin/php"
    if is_executable(_php):
        _script = "\"<?php var_export(%s); ?>\"" % (re.sub("[\r\n]"," ",dict_str),)
        signal.alarm(10)
        proc = subprocess.Popen(_php,
                   bufsize=1,
                   shell=True,
                   stdin=subprocess.PIPE,
                   stdout=subprocess.PIPE,
                   stderr=subprocess.PIPE)

        proc.stdin.write(_script)
        output = proc.communicate()
        ret = proc.wait()
        signal.alarm(0)
        if ret == 0:
            dict_str = "".join(output)
            dict_str = re.sub("^\"","",dict_str)
            dict_str = re.sub("\"$","",dict_str)

    header = php_start;
    if var_name != "":
        header = "%s$%s = " % (header,var_name,)
    footer = php_end

    return "%s%s;\n%s" % (header,dict_str,footer,)

def php_array_to_python_dict(string=""):
    """<comment-ja>
    PHPの連想配列(var_export形式)の文字列をpythonの辞書配列に変換する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    retval = False

    string = re.sub("^<[\?%](php)?"         ,'' ,string.lstrip())
    string = re.sub("[\?%]>$"               ,'' ,string.rstrip())
    string = re.sub("^\\$[a-zA-Z0-9_]+ *= *",'' ,string.lstrip())
    dict_str = string
    dict_str = dict_str.replace('array('    ,'{')
    dict_str = dict_str.replace('\' =>'     ,'\':')
    dict_str = dict_str.replace(')'         ,'}')
    dict_str = dict_str.replace('=> array(' ,'=> [')
    dict_str = dict_str.replace('))'        ,'])')
    dict_str = re.sub("{'(.*':.*)'}"         ,"['\\1']" ,dict_str)
    dict_str = re.sub("\);"                   ,')',dict_str)
    try:
        exec("retval = %s" % dict_str)
    except:
        try:
            # Read by var_export format
            exec("retval = %s" % _php_array_to_python_dict(string))
        except:
            raise

    return retval

def get_karesansui_version():
    import karesansui
    return karesansui.__version__ + '.' + karesansui.__release__

def get_blocks(d='/dev'):
    """<comment-ja>
    指定したフォルダに存在するブロックデバイス名一覧を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    ret = []
    for f in os.listdir(d):
        if stat.S_ISBLK(os.stat("%s/%s" % (d, f))[stat.ST_MODE]) is True:
            ret.append(f)

    return set(ret)

def get_hdd_list(_prefix='/dev'):
    """<comment-ja>
    OSで認識しているハードディスク名一覧を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    from karesansui.lib.const import HDD_TYPES_REGEX
    blocks = get_blocks(_prefix)
    ret = []
    for _type in HDD_TYPES_REGEX:
        _regex = re.compile(_type)
        for _b in blocks:
            if _regex.match(_b):
                ret.append(_b)
    return ret

def get_fs_info():
    """<comment-ja>
    OSで認識しているファイルシステムの情報(dfコマンドの結果)を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    ret = []
    tmp_dict = {}
    pipe = os.popen("LANG=C /bin/df -m -P")
    try:
        data = []
        for line in pipe.readlines():
            data.append(re.sub(r'[ \t]', ' ', line).split())
    finally:
        pipe.close()

    for i in range(1, len(data)):
        for j in range(0,6):
            tmp_dict[data[0][j]] = data[i][j]

        ret.append(tmp_dict)
        tmp_dict = {}

    return ret

def read_file(filepath):
    """<comment-ja>
    指定されたファイルの中身を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    ret = ""
    try:
        fp = open(filepath, "r")
        fcntl.lockf(fp.fileno(), fcntl.LOCK_SH)
        for line in fp.readlines():
            ret = ret + line
        fcntl.lockf(fp.fileno(), fcntl.LOCK_UN)
        fp.close()
    except:
        ret = False

    return ret

def create_epochsec(year, month, day, hour=0, minute=0, second=0):
    return str(int(time.mktime(datetime.datetime(year, month, day, hour, minute, second).timetuple())))

def get_hostname():
    import socket
#   return socket.gethostname()
    return socket.getfqdn()

def host2ip(host):
    import socket
    return socket.gethostbyname(host)

def uri_split(uri):
    """
       Basic URI Parser
    """
    import re
    regex = '^(([^:/?#]+):)?(//(([^:]+)(:(.+))?@)?([^/?#:]*)(:([0-9]+))?)?([^?#]*)(\?([^#]*))?(#(.*))?'

    p = re.match(regex, uri).groups()
    scheme, user, passwd, host, port, path, query, fragment = p[1], p[4], p[6], p[7], p[9], p[10], p[12], p[14]

    if not path: path = None
    return { "scheme"  :scheme,
             "user"    :user,
             "passwd"  :passwd,
             "host"    :host,
             "port"    :port,
             "path"    :path,
             "query"   :query,
             "fragment":fragment,
           }

def uri_join(segments,without_auth=False):
    """
       Reverse of uri_split()
    """
    result = ''

    try:
        result += segments["scheme"] + '://'
    except:
        pass

    if without_auth is False:
        try:
            result += segments["user"]
            try:
                result += ':' + segments["passwd"]
            except:
                pass
            result += '@'
        except:
            pass

    try:
        result += segments["host"]
    except:
        pass

    try:
        result += ':' + segments["port"]
    except:
        pass

    try:
        if segments["path"] is None or segments["path"] == "":
            segments["path"] = "/"
        if result != "":
            result += segments["path"]
    except:
        pass

    try:
        result += '?' + segments["query"]
    except:
        pass
    try:
        result += '#' + segments["fragment"]
    except:
        pass

    return result

def locale_dummy(str):
    return str

def symlink2real(symlink):
    """<comment-ja>
    シンボリック先の実体ファイルのファイル名を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    path = os.path.realpath(symlink)
    filename = os.path.basename(path)
    sfilename = filename.split(".")
    if len(sfilename) < 2:
        return (os.path.dirname(path), sfilename[0], "")
    else:
        name = ""
        for x in xrange(len(sfilename)-1):
            name = os.path.join(name, sfilename[x])
        return (os.path.dirname(path), name, sfilename[len(sfilename)-1])

def get_filelist(dir_path="/"):
    """<comment-ja>
    指定したディレクトリに存在するファイル名の一覧を取得します。
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if os.path.isdir(dir_path):
        filelist = os.listdir(dir_path)
    else:
        filelist = []

    return filelist

def get_bonding_info(name=None):
    """
    <comment-ja>
    bondingデバイス情報を取得する

    @param name: 取得したいデバイス名(省略時は全デバイス情報が指定されたとみなす) 「regex:bond0」のようにプレフィックスにregex:を付けると正規表現にマッチしたデバイス名の情報を全て取得できる。
    @return:    デバイス情報が格納されたdict配列
                配列の内容例
                {'bond0': {  'mode'    : 'fault-tolerance (active-backup)',
                             'primary' : 'eth0',
                             'active'  : 'eth0',
                             'slave'   : ['eth0', 'eth1'],
                          }

    </comment-ja>
    <comment-en>
    Get computer's bonding interface information

    @param name: bonding device name
    @return: a dict with: mode, slave etc...
    @rtype: dict
    </comment-en>
    """
    info = {}
    _info = {}
    _proc_bonding_dir = '/proc/net/bonding'

    mode_regex = re.compile(r"""^Bonding Mode:\s*(?P<mode>.+)""")
    primary_regex = re.compile(r"""^Primary Slave:\s*(?P<primary>eth[0-9]+)""")
    active_regex = re.compile(r"""^Currently Active Slave:\s*(?P<active>eth[0-9]+)""")
    slave_regex = re.compile(r"""^Slave Interface:\s*(?P<slave>eth[0-9]+)""")

    for device in get_filelist(_proc_bonding_dir):
        _info[device] = {}
        _info[device]['slave'] = []
        for aline in read_file("%s/%s" % (_proc_bonding_dir, device)).split("\n"):
            if aline.strip() == "":
                continue

            m = mode_regex.match(aline)
            if m:
                _info[device]['mode'] = m.group('mode')

            m = primary_regex.match(aline)
            if m:
                _info[device]['primary'] = m.group('primary')

            m = active_regex.match(aline)
            if m:
                _info[device]['active'] = m.group('active')

            m = slave_regex.match(aline)
            if m:
                _info[device]['slave'].append(m.group('slave'))

    all_info = dict_ksort(_info)

    if name == None:
        return all_info

    regex_regex = re.compile(r"""^regex:(?P<regex>.*)""")
    m = regex_regex.match(name)

    for dev,value in all_info.iteritems():
        if m == None:
            if dev == name:
                info[dev] = value
                return info
        else:
            regex = m.group('regex')
            query_regex = re.compile(r""+regex+"")
            n = query_regex.search(dev)
            if n != None:
                info[dev] = value
    return info

def get_bridge_info(name=None):
    """
    <comment-ja>
    Bridgeデバイス情報を取得する

    @param name: 取得したいデバイス名(省略時は全デバイス情報が指定されたとみなす)
    @return:    デバイス情報が格納されたdict配列
                配列の内容例
                {'eth0': ['peth0'] }

    </comment-ja>
    <comment-en>
    Get computer's bridge interface information

    @param name: bridge device name
    @return: a dict with: bridge name
    @rtype: dict
    </comment-en>
    """
    info = {}

    _sys_bridge_dir_tpl = '/sys/class/net/%s/bridge'
    _sys_brif_dir_tpl = '/sys/class/net/%s/brif'

    if_list = get_ifconfig_info()

    for dev in if_list:
        if os.path.exists(_sys_bridge_dir_tpl % (dev)):
            if os.path.exists(_sys_brif_dir_tpl % (dev)):
                info[dev] = get_filelist(_sys_brif_dir_tpl % (dev))

    if name is not None:
        if name in info:
            return info[name]

    return info


def get_pwd_info():
    """
    <comment-ja>
    全てのユーザ情報を取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return pwd.getpwall()

def get_grp_info():
    """
    <comment-ja>
    全てのグループ情報を取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    return grp.getgrall()

def get_filesystem_info():
    """
    <comment-ja>
    使用できるファイルシステムを取得する
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    ret = []
    _filesystem_path = "/etc/filesystems"
    nodev_regex = re.compile("^nodev")

    data = read_file(_filesystem_path)
    if data:
        for line in data.split("\n"):
            line = line.strip()
            if line == "":
                continue
            if nodev_regex.match(line):
                continue

            ret.append(line)

    return ret

def karesansui_database_exists():
    from karesansui.db import get_session
    from karesansui.db.model.user import User
    session = get_session()
    try:
        email = session.query(User).first().email
    except:
        return False
    return True

class ReverseFile(object):
    def __init__(self, fp):
        self.fp = fp
        if isinstance(self.fp ,gzip.GzipFile):
            self.fp.readlines()
            self.end = self.fp.size
            self.fp.seek(self.end)
        else:
            self.fp.seek(0, 2)
            self.end = self.fp.tell()

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, exception_traceback):
        self.fp.close()

    def __iter__(self):
        return self

    def next(self):
        if self.end == 0:
            raise StopIteration

        start = self.end - 2
        while start >= 0:
            self.fp.seek(start)
            if self.fp.read(1) == '\n':
                end = self.end
                self.end = start
                return self.fp.read(end - start)
            start -= 1

        end = self.end + 1
        self.end = 0
        self.fp.seek(0)
        return self.fp.read(end)

    def readline(self):
        return self.next()

    def fileno(self):
        return self.fp.fileno()

    def close(self):
        return self.fp.close()

reverse_file = ReverseFile

if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
libvirtの仮想マシン(VM)の設定を生成する
</comment-ja>
<comment-en>
Generate configuration file of VMs for libvirt.
</comment-en>

@file:   config.py

@author: Taizo ITO <taizo@karesansui-project.info>

@copyright:    

"""

import time
import os, stat
import re
import shutil
import errno
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui

from karesansui.lib.const import KARESANSUI_GROUP, VIRT_XML_CONFIG_DIR, \
                                 DEFAULT_KEYMAP

from karesansui.lib.const import XEN_VIRT_CONFIG_DIR, \
                                 XEN_KARESANSUI_TMP_DIR

from karesansui.lib.const import KVM_VIRT_CONFIG_DIR, \
                                 KVM_KARESANSUI_TMP_DIR

from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_nums_xml_xpath as XMLXpathNum, \
     get_xml_parse as XMLParse, \
     uniq_filename, r_chgrp, r_chmod, isset

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.file.configfile import ConfigFile

SIZE_UNIT_MAP = { "b" : 1024**0, "k" : 1024**1, "m" : 1024**2, "g" : 1024**3 }
"""
<comment-ja>
ファイルサイズの単位とバイト数のマップを定義
</comment-ja>
<comment-en>
Define byte unit map
</comment-en>
"""

class KaresansuiConfigParamException(karesansui.KaresansuiLibException):
    pass

class ConfigParam:
    """
    <comment-ja>
    Xenの仮想マシン(VM)の設定ファイル(key = value形式)を生成するクラス
    </comment-ja>
    <comment-en>
    Class for generating Xen VM configuration file
    </comment-en>
    """

    def __init__(self, name):

        self.name = name
        self.domain_type = None
        self.os_root = None
        self.uuid = None
        self.kernel = None
        self.initrd = None
        self.boot_dev = None
        self.bootloader = None
        self.maxmem = None
        self.memory = None
        self.cmdline = []
        self.interfaces = []
        self.disks = []
        self.vcpus = 1
        self.max_vcpus = None
        self.vcpus_limit = None
        self.max_vcpus_limit = None
        self.graphics_type = "vnc"
        self.graphics_port = None
        self.graphics_autoport = "no"
        self.graphics_listen = None
        self.graphics_keymap = None
        self.graphics_passwd = None
        self.features_pae = None
        self.features_acpi = None
        self.features_apic = None
        self.behavior = { "on_poweroff" : "destroy",
                          "on_reboot"   : "restart",
                          "on_crash"    : "restart"
                        }
        self.current_snapshot = None
        self.config_file = None

    def __get_value(self,key):

        if self.domain_type == "xen":
            self.config_file = "%s/%s" % (XEN_VIRT_CONFIG_DIR, self.name)
        elif self.domain_type == "kvm":
            self.config_file = "%s/%s" % (KVM_VIRT_CONFIG_DIR, self.name)

        sh_regex = re.compile(r"""^(?P<key>[^ =]+) *= *[\"']?(?P<value>[^\"']*)[\"']?$""")
        ret = ''
        if os.path.exists(self.config_file):
            try:
                lines = ConfigFile(self.config_file).read()
                for line in lines:
                    line = line.strip()
                    if len(line) <= 0 or line[0] == "#":
                        continue
                    m = sh_regex.match(line)
                    if m and m.group('key') == key:
                        ret = m.group('value')
                        break
            except:
                ret = ''
        return ret

    def get_domain_name(self):
        return self.name

    def set_domain_type(self, domain_type):
        self.domain_type = domain_type

    def get_domain_type(self):
        return self.domain_type

    def set_os_root(self, os_root):
        self.os_root = os_root

    def get_os_root(self):
        return self.os_root

    def set_uuid(self, uuid):
        self.uuid = uuid

    def get_uuid(self):
        return self.uuid

    def set_current_snapshot(self, snapshot):
        if snapshot is not None:
            snapshot = str(snapshot)
        self.current_snapshot = snapshot

    def get_current_snapshot(self):
        return self.current_snapshot

    def set_behavior(self, param, value):
        self.behavior[param] = value

    def get_behavior(self, param):
        return self.behavior.get(param)

    def set_bootloader(self, bootloader):
        self.bootloader = bootloader

    def get_bootloader(self):
        return self.bootloader

    def set_kernel(self, kernel):
        self.kernel = kernel

    def get_kernel(self):
        return self.kernel

    def set_initrd(self, initrd):
        self.initrd = initrd

    def get_initrd(self):
        return self.initrd

    def set_boot_dev(self, boot_dev):
        self.boot_dev = boot_dev

    def get_boot_dev(self):
        return self.boot_dev

    def append_commandline(self, *args, **kwargs):
        for opt in args:
            self.cmdline.append(opt)
        for k,v in kwargs.iteritems():
            self.cmdline.append("%s=%s" % (k,v))

    def get_commandline(self):
        return " ".join(self.cmdline)

    def set_graphics_type(self, type):
        self.graphics_type = type

    def get_graphics_type(self):
        return self.graphics_type

    def set_graphics_port(self, port):
        self.graphics_port = port

    def get_graphics_port(self):
        return self.graphics_port

    def set_graphics_autoport(self, autoport):
        self.graphics_autoport = autoport

    def get_graphics_autoport(self):
        return self.graphics_autoport

    def set_graphics_listen(self, listen):
        self.graphics_listen = listen

    def get_graphics_listen(self):
        if self.graphics_listen == None:
            self.set_graphics_listen("0.0.0.0")
        return self.graphics_listen

    def set_graphics_keymap(self, keymap):
        self.graphics_keymap = keymap

    def get_graphics_keymap(self):
        #if self.graphics_keymap == None:
        #    self.set_graphics_keymap(DEFAULT_KEYMAP)
        return self.graphics_keymap

    def set_graphics_passwd(self, passwd):
        self.graphics_passwd = passwd

    def get_graphics_passwd(self):
        return self.graphics_passwd

    def set_vcpus(self, vcpus):
        self.vcpus = vcpus

    def get_vcpus(self):
        return self.vcpus

    def set_max_vcpus(self, max_vcpus):
        self.max_vcpus = max_vcpus

    def get_max_vcpus(self):
        return self.max_vcpus

    def set_vcpus_limit(self, vcpus_limit):
        self.vcpus_limit = vcpus_limit

    def get_vcpus_limit(self):
        return self.vcpus_limit

    def set_max_vcpus_limit(self, max_vcpus_limit):
        self.max_vcpus_limit = max_vcpus_limit

    def get_max_vcpus_limit(self):
        return self.max_vcpus_limit

    def set_features_pae(self, pae):
        self.features_pae = pae

    def get_features_pae(self):
        return self.features_pae

    def set_features_acpi(self, acpi):
        self.features_acpi = acpi

    def get_features_acpi(self):
        return self.features_acpi

    def set_features_apic(self, apic):
        self.features_apic = apic

    def get_features_apic(self):
        return self.features_apic

    def add_disk(self, path, target, device="disk",
                 bus="ide", disk_type="file", driver_name=None, driver_type=None, shareable=None, readonly=None):
        disk = {"path"     :path,
                "target"   :target,
                "device"   :device,
                "bus"      :bus,
                "disk_type":str(disk_type),
                "shareable":shareable,
                "readonly" :readonly,
                }

        if driver_name is not None:
            disk["driver_name"] = str(driver_name)

        if driver_type is not None:
            disk["driver_type"] = str(driver_type)

        self.disks.append(disk)

    def delete_disk(self, target):
        for arr in self.disks:
            if arr["target"] == target:
                self.disks.remove(arr)

    def get_disk(self):
        return self.disks

    def get_disk_path(self,target):
        for arr in self.disks:
            if arr["target"] == target:
                return arr["path"]
        return None

    def add_interface(self, mac, type, bridge, script, target=None, model=None):
        self.interfaces.append( {"mac": mac, "type": type, "bridge": bridge, "script": script, "target": target, "model": model} )

    def delete_interface(self, mac):
        for arr in self.interfaces:
            if arr["mac"] == mac:
                self.interfaces.remove(arr)

    def get_interface(self):
        return self.interfaces

    def set_memory(self, memory):
        try:
            memory = str(memory).strip().lower()
        except Exception, e:
            param_err = KaresansuiConfigParamException("invalid memory: %s" % str(memory))
            param_err.exception = e
        p = re.compile(r"""^(?P<bytes>\d+)(?P<unit>[gmkb]?)$""")
        m = p.match(memory)
        if not m: raise KaresansuiConfigParamException("invalid memory: %s" % str(memory))

        self.memory = int(m.group("bytes")) * SIZE_UNIT_MAP.get(m.group("unit"), 1)
        if (self.memory <= 0): raise KaresansuiConfigParamException("invalid memory: %d" % self.memory)
        
    def get_memory(self, unit="b"):
        if not unit in SIZE_UNIT_MAP.keys():
            raise KaresansuiConfigParamException("no such unit: %s" % unit)
        return int(self.memory / SIZE_UNIT_MAP.get(unit))

    def set_max_memory(self, memory):
        try:
            memory = str(memory).strip().lower()
        except Exception, e:
            param_err = KaresansuiConfigParamException("invalid memory: %s" % str(memory))
            param_err.exception = e
        import re
        p = re.compile(r"""^(?P<bytes>\d+)(?P<unit>[gmkb]?)$""")
        m = p.match(memory)
        if not m: raise KaresansuiConfigParamException("invalid memory: %s" % str(memory))

        self.maxmem = int(m.group("bytes")) * SIZE_UNIT_MAP.get(m.group("unit"), 1)
        if (self.maxmem <= 0): raise KaresansuiConfigParamException("invalid memory: %d" % self.maxmem)
        
    def get_max_memory(self, unit="b"):
        if self.maxmem == None and self.memory != None:
            self.maxmem = self.memory
        if not unit in SIZE_UNIT_MAP.keys():
            raise KaresansuiConfigParamException("no such unit: %s" % unit)
        return int(self.maxmem / SIZE_UNIT_MAP.get(unit))

    def load_xml_config(self,path):

        #if not os.path.exists(path):
        #    raise KaresansuiConfigParamException("no such file: %s" % path)

        document = XMLParse(path)

        domain_type = XMLXpath(document,'/domain/@type')
        self.set_domain_type(str(domain_type))

        os_root = XMLXpath(document,'/domain/os/root/text()')
        if os_root:
            self.set_os_root(str(os_root))

        uuid = XMLXpath(document,'/domain/uuid/text()')
        self.set_uuid(str(uuid))

        current_snapshot = XMLXpath(document,'/domain/currentSnapshot/text()')
        if current_snapshot:
            self.set_current_snapshot(str(current_snapshot))

        bootloader = XMLXpath(document,'/domain/bootloader/text()')
        if bootloader:
            self.set_bootloader(str(bootloader))

        kernel = XMLXpath(document,'/domain/os/kernel/text()')
        if kernel:
            self.set_kernel(str(kernel))

        initrd = XMLXpath(document,'/domain/os/initrd/text()')
        if initrd:
            self.set_initrd(str(initrd))

        boot_dev = XMLXpath(document,'/domain/os/boot/@dev')
        if boot_dev:
            self.set_boot_dev(str(boot_dev))

        features_pae = XMLXpathNum(document,'/domain/features/pae')
        if features_pae > 0:
            self.set_features_pae(True)

        features_acpi = XMLXpathNum(document,'/domain/features/acpi')
        if features_acpi > 0:
            self.set_features_acpi(True)

        features_apic = XMLXpathNum(document,'/domain/features/apic')
        if features_apic > 0:
            self.set_features_apic(True)

        memory = XMLXpath(document,'/domain/memory/text()')
        if memory:
            self.set_memory(memory+"k")

        maxmem = XMLXpath(document,'/domain/maxmem/text()')
        if maxmem:
            self.set_max_memory(maxmem+"k")

        max_vcpu = XMLXpath(document,'/domain/vcpu/text()')
        self.set_max_vcpus(int(max_vcpu))

        graphics_type = XMLXpath(document,'/domain/devices/graphics/@type')
        self.set_graphics_type(str(graphics_type))

        graphics_port = XMLXpath(document,'/domain/devices/graphics/@port')
        self.set_graphics_port(int(graphics_port))

        graphics_autoport = XMLXpath(document,'/domain/devices/graphics/@autoport')
        self.set_graphics_autoport(str(graphics_autoport))

        graphics_listen = XMLXpath(document,'/domain/devices/graphics/@listen')
        if graphics_listen:
            self.set_graphics_listen(str(graphics_listen))

        graphics_keymap = XMLXpath(document,'/domain/devices/graphics/@keymap')
        if graphics_keymap:
            self.set_graphics_keymap(str(graphics_keymap))

        graphics_passwd = XMLXpath(document,'/domain/devices/graphics/@passwd')
        if graphics_passwd:
            self.set_graphics_passwd(str(graphics_passwd))
        else:
            graphics_passwd = self.__get_value('graphics_passwd')
            if graphics_passwd != "":
                self.set_graphics_passwd(graphics_passwd)

        self.interfaces = []
        interface_num = XMLXpathNum(document,'/domain/devices/interface')
        for n in range(1, interface_num + 1):
            type = XMLXpath(document,'/domain/devices/interface[%i]/@type' % n)
            mac = XMLXpath(document,'/domain/devices/interface[%i]/mac/@address' % n)
            if str(type) == "network":
                name = XMLXpath(document,'/domain/devices/interface[%i]/source/@network' % n)
            else:
                name = XMLXpath(document,'/domain/devices/interface[%i]/source/@bridge' % n)
            script = XMLXpath(document,'/domain/devices/interface[%i]/script/@path' % n)
            if script != None:
                script = str(script)
            target = XMLXpath(document,'/domain/devices/interface[%i]/target/@dev' % n)
            if target != None:
                target = str(target)
            model = XMLXpath(document,'/domain/devices/interface[%i]/model/@type' % n)
            if model != None:
                model = str(model)
            self.add_interface(str(mac), str(type), str(name), script, target, model=model)

        self.disks = []
        disk_num = XMLXpathNum(document,'/domain/devices/disk')
        for n in range(1, disk_num + 1):
            device_type = XMLXpath(document,'/domain/devices/disk[%i]/@device' % n)
            if device_type == None:
                device_type = "disk"
            disk_type = XMLXpath(document,'/domain/devices/disk[%i]/@type' % n)
            source_dev = XMLXpath(document,'/domain/devices/disk[%i]/source/@dev' % n) # block
            source_file = XMLXpath(document,'/domain/devices/disk[%i]/source/@file' % n) # file
            source_attribute = ""
            if source_dev:
                source_attribute = source_dev
            elif source_file:
                source_attribute = source_file

            target_dev = XMLXpath(document,'/domain/devices/disk[%i]/target/@dev' % n)
            target_bus = XMLXpath(document,'/domain/devices/disk[%i]/target/@bus' % n)

            driver_name = XMLXpath(document,'/domain/devices/disk[%i]/driver/@name' % n)
            driver_type = XMLXpath(document,'/domain/devices/disk[%i]/driver/@type' % n)

            shareable = None
            shareable_num = XMLXpathNum(document,'/domain/devices/disk[%i]/shareable' % n)
            if shareable_num > 0:
                shareable = True

            readonly = None
            readonly_num = XMLXpathNum(document,'/domain/devices/disk[%i]/readonly' % n)
            if readonly_num > 0:
                readonly = True

            if target_bus is None:
                self.add_disk(str(source_attribute),
                              str(target_dev),
                              device=str(device_type),
                              disk_type=disk_type,
                              driver_name=driver_name,
                              driver_type=driver_type,
                              shareable=shareable,
                              readonly=readonly,
                              )
            else:
                self.add_disk(str(source_attribute),
                              str(target_dev),
                              device=str(device_type),
                              bus=str(target_bus),
                              disk_type=disk_type,
                              driver_name=driver_name,
                              driver_type=driver_type,
                              shareable=shareable,
                              readonly=readonly,
                              )

        on_poweroff = XMLXpath(document,'/domain/on_poweroff/text()')
        if on_poweroff:
            self.set_behavior('on_poweroff',str(on_poweroff))
        on_reboot = XMLXpath(document,'/domain/on_reboot/text()')
        if on_reboot:
            self.set_behavior('on_reboot',str(on_reboot))
        on_crash = XMLXpath(document,'/domain/on_crash/text()')
        if on_crash:
            self.set_behavior('on_crash',str(on_crash))


    def validate(self):

        if not self.uuid:
            raise KaresansuiConfigParamException("ConfigParam: uuid is None")
        if self.graphics_port < 5900:
            raise KaresansuiConfigParamException("ConfigParam: graphics port < 5900: %d" % self.graphics_port)
        if self.vcpus < 1:
            raise KaresansuiConfigParamException("ConfigParam: vcpus < 1: %d" % self.vcpus)
        if self.vcpus_limit and self.vcpus_limit < self.vcpus:
            raise KaresansuiConfigParamException("ConfigParam: vcpus > %d: %d" % (self.vcpus_limit, self.vcpus))
        if self.max_vcpus is not None and self.max_vcpus < 1:
            raise KaresansuiConfigParamException("ConfigParam: max_vcpus < 1: %d" % self.max_vcpus)
        if self.max_vcpus is not None and self.max_vcpus_limit and self.max_vcpus_limit < self.max_vcpus:
            raise KaresansuiConfigParamException("ConfigParam: max_vcpus > %d: %d" %(self.max_vcpus_limit, self.max_vcpus))
        if self.bootloader and not os.path.exists(self.bootloader):
            raise KaresansuiConfigParamException("ConfigParam: bootloader %s not found", self.bootloader)
        #if self.kernel and not os.path.exists(self.kernel):
        #    raise KaresansuiConfigParamException("ConfigParam: kernel %s not found", self.kernel)
        #if self.initrd and not os.path.exists(self.initrd):
        #    raise KaresansuiConfigParamException("ConfigParam: initrd %s not found", self.initrd)
        if not len(self.get_disk()):
            raise KaresansuiConfigParamException("ConfigParam: no disks are specified")
        if not self.name or not len(self.name):
            raise KaresansuiConfigParamException("ConfigParam: illegal name")
        """
        if not len(self.get_interface()):
            raise KaresansuiConfigParamException("ConfigParam: no interfaces are specified")
        """

class XMLGenerator:

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        if txt is not None:
            self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self, config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree.toxml())
        return out.getvalue()

class ConfigGenerator:

    def __init__(self,domain_type):
      self.config_dir = KVM_VIRT_CONFIG_DIR
      if domain_type == "xen":
        self.config_dir = XEN_VIRT_CONFIG_DIR
      elif domain_type == "kvm":
        self.config_dir = KVM_VIRT_CONFIG_DIR

    def generate(self, config):
        config.validate()
        self.config = config
        
        self.out = StringIO()
        self.print_header()
        self.print_bootloader_section()
        self.print_kernel_section()
        self.print_disks_section()
        self.print_memory_section()
        self.print_vcpu_section()
        self.print_graphics_section()
        self.print_network_section()
        self.print_behavior_section()
        return self.out.getvalue()

    def _print_param(self, key, value):
        if value != '':
            print >>self.out, key, "=", "%s" % repr(value)

    def print_header(self):
        print >>self.out, "# This is an automatically generated xen configuration file: %s" % self.config.get_domain_name()
        print >>self.out, "# Generated Date: %s" % time.ctime()
        print >>self.out
        self._print_param("name", self.config.get_domain_name())
        self._print_param("uuid", self.config.get_uuid())
        if self.config.get_current_snapshot() is not None:
            self._print_param("current_snapshot", self.config.get_current_snapshot())
        print >>self.out

    def print_kernel_section(self):
        print >>self.out, "# Kernel configuration"
        if self.config.get_kernel():
            self._print_param("kernel", self.config.get_kernel())
        if self.config.get_initrd():
            self._print_param("ramdisk", self.config.get_initrd())
        # additional arguments to kernel
        if self.config.get_commandline():
            self._print_param("extra", self.config.get_commandline())
        if self.config.get_features_pae() is True:
            self._print_param("pae", 1)
        if self.config.get_features_acpi() is True:
            self._print_param("acpi", 1)
        if self.config.get_features_apic() is True:
            self._print_param("apic", 1)
        print >>self.out

    def print_bootloader_section(self):
        print >>self.out, "# Bootloader configuration"
        if self.config.get_bootloader():
            self._print_param("bootloader", self.config.get_bootloader())
        print >>self.out

    def print_memory_section(self):
        print >>self.out, "# Memory configuration"
        self._print_param("maxmem", self.config.get_max_memory("m"))
        self._print_param("memory", self.config.get_memory("m"))
        print >>self.out

    def print_vcpu_section(self):
        print >>self.out, "# CPU configuration"
        self._print_param("vcpus", self.config.get_max_vcpus())
        print >>self.out

    def print_disks_section(self):
        
        print >>self.out, "# Disk device configuration"
        
        # root
        self._print_param("root", "/dev/"+self.config.get_disk()[0]["target"])

        # all disks
        disks = []
        for disk in self.config.get_disk():
            if stat.S_ISBLK(os.stat(disk['path'])[stat.ST_MODE]):
                ftype = "phy"
            else:
                ftype = "file"
            disk_param = ftype+":%(path)s,%(target)s,w" % disk
            disks.append( str(disk_param) )
        self._print_param("disk", disks)
        print >>self.out

    def print_network_section(self):
        print >>self.out, "# Network configuration"
        vif = []
        for interface in self.config.get_interface():
            vif_param = "mac=%(mac)s, bridge=%(bridge)s" % interface
            vif.append( str(vif_param) )
        self._print_param("vif", vif)
        print >>self.out

    def print_graphics_section(self):
        print >>self.out, "# Graphics configuration"
        if self.config.get_graphics_port():
            if self.config.get_graphics_type() == "sdl":
                self._print_param("sdl", 1)
                self._print_param("vnc", 0)
                self._print_param("spice", 0)
            elif self.config.get_graphics_type() == "spice":
                self._print_param("sdl", 0)
                self._print_param("vnc", 0)
                self._print_param("spice", 1)
            else:
                self._print_param("sdl", 0)
                self._print_param("vnc", 1)
                self._print_param("spice", 1)
            self._print_param("vncunused", 0)
            self._print_param("vncdisplay", int(self.config.get_graphics_port())-5900)
            self._print_param("vnclisten", self.config.get_graphics_listen())

            if self.config.get_graphics_keymap() is not None:
                self._print_param("keymap", self.config.get_graphics_keymap())
            if self.config.get_graphics_passwd() is not None and self.config.get_graphics_passwd() != "":
                self._print_param("vncpasswd", self.config.get_graphics_passwd())
        print >>self.out

    def print_behavior_section(self):
        print >>self.out, "# Behavior configuration"
        self._print_param("on_poweroff", self.config.get_behavior("on_poweroff"))
        self._print_param("on_reboot", self.config.get_behavior("on_reboot"))
        self._print_param("on_crash", self.config.get_behavior("on_crash"))

    def writecfg(self,cfg, config_dir=None):
        if config_dir is None:
            config_dir = self.config_dir
            
        filename = "%s/%s" %(config_dir, self.config.get_domain_name())
        ConfigFile(filename).write(cfg)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

    def copycfg(self,src_dir):
            
        src_filename = "%s/%s" %(src_dir, self.config.get_domain_name())
        filename = "%s/%s" %(self.config_dir, self.config.get_domain_name())
        
        shutil.copy(src_filename, filename)
        
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

    def removecfg(self, config_dir=None):
        if config_dir is None:
            config_dir = self.config_dir

        filename = "%s/%s" %(config_dir, self.config.get_domain_name())
        if os.path.exists(filename):
            os.unlink(filename)
 
class XMLDiskConfigGenerator(XMLGenerator):

    def __init__(self):
        self.path = None
        self.target = None
        self.bus = None

    def set_path(self, path):
        self.path = path
    def get_path(self):
        return self.path

    def set_target(self, target):
        self.target = target
    def get_target(self):
        return self.target

    def set_bus(self, bus):
        self.bus = bus
    def get_bus(self):
        return self.bus

    def validate(self):
        pass #TODO

    def generate_xml_tree(self, config=None):
#        self.validate()

        self.begin_build()
        self.build_disk()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.disk = self.document.createElement("disk")

        self.disk.setAttribute("type", "file")
        self.disk.setAttribute("device", "disk")

        self.document.appendChild(self.disk)

    def build_disk(self):
        doc = self.document
        driver = doc.createElement("driver")
        driver.setAttribute("name", "file")
        self.disk.appendChild(driver)

        # TODO
        if self.get_path() != None:
            source = doc.createElement("source")
            source.setAttribute("file", self.get_path())
            self.disk.appendChild(source)

        if self.get_target() != None:
            target = doc.createElement("target")
            target.setAttribute("dev", self.get_target())
            if self.get_bus() != None:
                target.setAttribute("bus", self.get_bus())
            self.disk.appendChild(target)

    def end_build(self):
        pass

class XMLInterfaceConfigGenerator(XMLGenerator):

    def __init__(self):
        self.mac = None
        self.bridge = None
        self.script = None
        self.target = None

    def set_mac(self, mac):
        self.mac = mac
    def get_mac(self):
        return self.mac

    def set_bridge(self, bridge):
        self.bridge = bridge
    def get_bridge(self):
        return self.bridge

    def set_script(self, script):
        self.script = script
    def get_script(self):
        return self.script

    def set_target(self, target):
        self.target = target
    def get_target(self):
        return self.target

    def validate(self):
        if not os.path.exists("/etc/xen/scripts/" + self.script):
            raise KaresansuiConfigParamException("ConfigParam: script %s not found", self.path)

    def generate_xml_tree(self, config=None):
#        self.validate()

        self.begin_build()
        self.build_interface()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.interface = self.document.createElement("interface")

        self.interface.setAttribute("type", "bridge")
        self.document.appendChild(self.interface)

    def build_interface(self):
        doc = self.document

        if self.get_mac():
            mac = doc.createElement("mac")
            mac.setAttribute("address", self.get_mac())
            self.interface.appendChild(mac)

        if self.get_bridge():
            source = doc.createElement("source")
            source.setAttribute("bridge", self.get_bridge())
            self.interface.appendChild(source)

        if self.get_script():
            script = doc.createElement("script")
            script.setAttribute("path", self.get_script())
            self.interface.appendChild(script)

        if self.get_target():
            target = doc.createElement("target")
            target.setAttribute("dev", self.get_target())
            self.interface.appendChild(target)

    def end_build(self):
        pass

class XMLGraphicsConfigGenerator(XMLGenerator):

    def __init__(self):
        self.type = None
        self.port = None
        self.listen = None
        self.keymap = None

    def set_type(self, type):
        self.type = type

    def get_type(self):
        if self.type == None:
          self.set_type("vnc")
        return self.type

    def set_port(self, port):
        self.port = port

    def get_port(self):
        if self.port == None:
          self.set_port(5901)
        return self.port

    def set_listen(self, listen):
        self.listen = listen

    def get_listen(self):
        if self.listen is None:
          self.set_listen("0.0.0.0")
        return self.listen

    def set_keymap(self, keymap):
        self.keymap = keymap

    def get_keymap(self):
        #if self.keymap is None:
        #  self.set_keymap(DEFAULT_KEYMAP)
        return self.keymap

    def validate(self):
        if self.get_port() < 5900:
            raise KaresansuiConfigParamException("ConfigParam: port < 5900: %d" % self.get_port())

    def generate_xml_tree(self, config=None):
        self.validate()
        self.build_graphics()
        return self.document

    def build_graphics(self):
        self.document = implementation.createDocument(None,None,None)
        self.graphics = self.document.createElement("graphics")

        self.graphics.setAttribute("type", self.get_type())
        self.graphics.setAttribute("port", str(self.get_port()))
        self.graphics.setAttribute("listen", self.get_listen())
        if self.get_keymap() is not None:
            self.graphics.setAttribute("keymap", self.get_keymap())
        self.document.appendChild(self.graphics)

class XMLConfigGenerator(XMLGenerator):

    def __init__(self):
        self.config_dir = VIRT_XML_CONFIG_DIR

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config

        self.begin_build()
        self.build_os()
        self.build_features()
        self.build_other()
        self.build_devices()
        self.build_behavior()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.domain = self.document.createElement("domain")

        self.domain.setAttribute("type", self.config.get_domain_type())
        name = self._create_text_node("name", self.config.get_domain_name())
        uuid = self._create_text_node("uuid", self.config.get_uuid())
        self.domain.appendChild(name)
        self.domain.appendChild(uuid)
        if self.config.get_current_snapshot():
            current_snapshot = self._create_text_node("currentSnapshot", self.config.get_current_snapshot())
            self.domain.appendChild(current_snapshot)

        self.document.appendChild(self.domain)

    def build_os(self):
        doc = self.document
        os_elem = doc.createElement("os")

        if self.config.get_domain_type() == "kvm":
            type_n = self._create_text_node("type", "hvm")
            type_n.setAttribute("arch", os.uname()[4])
            type_n.setAttribute("machine", "pc")
        else:
            type_n = self._create_text_node("type", "linux")
        os_elem.appendChild(type_n)

        if self.config.get_kernel():
            os_elem.appendChild(self._create_text_node("kernel", self.config.get_kernel()))
        if self.config.get_initrd():
            os_elem.appendChild(self._create_text_node("initrd", self.config.get_initrd()))
        os_elem.appendChild(self._create_text_node("root", "/dev/" + self.config.get_disk()[0]["target"]))

        if self.config.get_boot_dev():
            boot_dev_n = doc.createElement("boot")
            boot_dev_n.setAttribute("dev", self.config.get_boot_dev())
            os_elem.appendChild(boot_dev_n)

        # additional commandline
        if self.config.get_commandline():
            os_elem.appendChild(self._create_text_node("cmdline", self.config.get_commandline()))

        self.domain.appendChild(os_elem)

    def build_features(self):
        doc = self.document
        if self.config.get_features_pae()  is True or \
           self.config.get_features_acpi() is True or \
           self.config.get_features_apic() is True:

            features_elem = doc.createElement("features")

            if self.config.get_features_pae() is True:
                features_elem.appendChild(self._create_text_node("pae",None))

            if self.config.get_features_acpi() is True:
                features_elem.appendChild(self._create_text_node("acpi",None))

            if self.config.get_features_apic() is True:
                features_elem.appendChild(self._create_text_node("apic",None))

            self.domain.appendChild(features_elem)

    def build_other(self):
        self.domain.appendChild(self._create_text_node("maxmem",
                                    str(self.config.get_max_memory("k"))))
        self.domain.appendChild(self._create_text_node("memory",
                                    str(self.config.get_memory("k"))))
        self.domain.appendChild(self._create_text_node("vcpu",
                                    str(self.config.get_max_vcpus())))
        if self.config.get_bootloader():
            self.domain.appendChild(self._create_text_node("bootloader",
                                        str(self.config.get_bootloader())))

    def build_devices(self):
        doc = self.document
        devs_elem = doc.createElement("devices")

        # graphics
        if self.config.get_graphics_port():
            graphics_n = doc.createElement("graphics")
            if self.config.get_graphics_type() == "sdl":
                graphics_n.setAttribute("type", "sdl")
            elif self.config.get_graphics_type() == "spice":
                graphics_n.setAttribute("type", "spice")
            else:
                graphics_n.setAttribute("type", "vnc")
            graphics_n.setAttribute("port", str(self.config.get_graphics_port()))
            graphics_n.setAttribute("autoport", str(self.config.get_graphics_autoport()))
            graphics_n.setAttribute("listen", str(self.config.get_graphics_listen()))
            if self.config.get_graphics_keymap() is not None:
                graphics_n.setAttribute("keymap", str(self.config.get_graphics_keymap()))
            if self.config.get_graphics_passwd() is not None:
                graphics_n.setAttribute("passwd", str(self.config.get_graphics_passwd()))
            devs_elem.appendChild(graphics_n)

        # disks
        for disk in self.config.get_disk():
            disk_n = doc.createElement("disk")

            if disk["disk_type"] == "file":
                disk_n.setAttribute("type", "file")
            elif disk["disk_type"] == "block":
                disk_n.setAttribute("type", "block")
            else:
                disk_n.setAttribute("type", "file") # default                
                
            disk_n.setAttribute("device", disk["device"])

            # disk -> driver
            driver_n = doc.createElement("driver")
            try:
                if disk["driver_name"] is not None:
                    driver_n.setAttribute("name", disk["driver_name"])
            except:
                pass
            try:
                if disk["driver_type"] is not None:
                    driver_n.setAttribute("type", disk["driver_type"])
            except:
                pass

            source_n = doc.createElement("source")
            if disk["disk_type"] == "file":
                source_n.setAttribute("file", disk["path"])
            elif disk["disk_type"] == "block":
                source_n.setAttribute("dev", disk["path"])
            else:
                source_n.setAttribute("file", disk["path"]) # default
                
            target_n = doc.createElement("target")
            target_n.setAttribute("dev", disk["target"])
            if disk["bus"] != None:
                target_n.setAttribute("bus", disk["bus"])

            disk_n.appendChild(driver_n)
            disk_n.appendChild(source_n)
            disk_n.appendChild(target_n)

            #if isset("disk['shareable']",vars=locals()) is True:
            #    disk_n.appendChild(self._create_text_node("shareable",None))

            #if isset("disk['readonly']",vars=locals()) is True:
            #    disk_n.appendChild(self._create_text_node("readonly",None))

            devs_elem.appendChild(disk_n)

        # network
        for interface in self.config.get_interface():

            interface_n = doc.createElement("interface")
            interface_n.setAttribute("type", "bridge")
            
            source_n = doc.createElement("source")
            source_n.setAttribute("bridge", interface["bridge"])
            mac_n = doc.createElement("mac")
            mac_n.setAttribute("address", interface["mac"])
            interface_n.appendChild(source_n)
            interface_n.appendChild(mac_n)
            if interface["script"] != None:
                script_n = doc.createElement("script")
                script_n.setAttribute("path", interface["script"])
                interface_n.appendChild(script_n)
            if interface["target"] != None:
                target_n = doc.createElement("target")
                target_n.setAttribute("dev", interface["target"])
                interface_n.appendChild(target_n)
            if interface["model"] != None:
                model_n = doc.createElement("model")
                model_n.setAttribute("type", interface["model"])
                interface_n.appendChild(model_n)
            devs_elem.appendChild(interface_n)
        
        self.domain.appendChild(devs_elem)

    def build_behavior(self):
        self.domain.appendChild(self._create_text_node("on_poweroff",
                                    self.config.get_behavior("on_poweroff")))
        self.domain.appendChild(self._create_text_node("on_reboot",
                                    self.config.get_behavior("on_reboot")))
        self.domain.appendChild(self._create_text_node("on_crash",
                                    self.config.get_behavior("on_crash")))

    def end_build(self):
        pass

    def writecfg(self,cfg,config_dir=None):
        if config_dir is None:
            config_dir = self.config_dir
        try:
            os.makedirs(config_dir)
        except OSError, (err, msg):
            if err != errno.EEXIST:
                raise OSError(err,msg)
        filename = "%s/%s.xml" %(config_dir,self.config.get_domain_name())
        ConfigFile(filename).write(cfg)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

    def copycfg(self,src_dir):
        try:
            os.makedirs(self.config_dir)
        except OSError, (err, msg):
            if err != errno.EEXIST:
                raise OSError(err,msg)
            
        src_filename = "%s/%s.xml" %(src_dir ,self.config.get_domain_name())
        filename = "%s/%s.xml" %(self.config_dir,self.config.get_domain_name())
        
        shutil.copy(src_filename, filename)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

    def removecfg(self, config_dir=None):
        if config_dir is None:
            config_dir = self.config_dir

        filename = "%s/%s.xml" %(config_dir,self.config.get_domain_name())
        if os.path.exists(filename):
            os.unlink(filename)

def sync_config_generator(param, domname=None):

    domain_type = param.get_domain_type()

    tmp_prefix = KVM_KARESANSUI_TMP_DIR
    if domain_type == "xen":
      tmp_prefix = XEN_KARESANSUI_TMP_DIR
    elif domain_type == "kvm":
      tmp_prefix = KVM_KARESANSUI_TMP_DIR

    if os.path.exists(tmp_prefix) is False:
        os.makedirs(tmp_prefix)

    uniq = uniq_filename()

    tmp_dir = "%s/%s" % (tmp_prefix, uniq)
    tmp_xml_dir = "%s/%s/xml" % (tmp_prefix, uniq)

    if os.path.exists(tmp_dir) is False:
        os.makedirs(tmp_dir)
    if os.path.exists(tmp_xml_dir) is False:
        os.makedirs(tmp_xml_dir)

    # config
    config_generator = ConfigGenerator(domain_type)
    cfg = config_generator.generate(param)

    # xml config
    xml_generator = XMLConfigGenerator()
    cfgxml = xml_generator.generate(param)

    try:
        config_generator.writecfg(cfg, tmp_dir)
        xml_generator.writecfg(cfgxml, tmp_xml_dir)
    except:
        config_generator.removecfg(tmp_dir)
        xml_generator.removecfg(tmp_xml_dir)
        raise KaresansuiConfigParamException("Failed to update tmp configuration files. - domname=" + str(domname))

    try:
        config_generator.copycfg(tmp_dir)
        xml_generator.copycfg(tmp_xml_dir)
    except:
        raise KaresansuiConfigParamException("Failed to update configuration files. - domname=" + str(domname))

    if os.path.exists(tmp_dir):
        shutil.rmtree(tmp_dir)

    if os.path.exists(tmp_xml_dir):
        shutil.rmtree(tmp_xml_dir)

    return True

########NEW FILE########
__FILENAME__ = config_capabilities
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
</comment-ja>
<comment-en>
Read xml of libvirt's capabilities and load to object.
!!! Notice: this is read-only parser. !!!
</comment-en>

@file:   config_capabilities.py

@author: Taizo ITO <taizo@karesansui-project.info>

xml sample:
-----------------------------------------------------------
<capabilities>
  <host>
    <cpu>
      <arch>x86_64</arch>
      <model>pentium3</model>
      <topology sockets='1' cores='1' threads='1'/>
      <feature name='syscall'/>
      <feature name='hypervisor'/>
      <feature name='acpi'/>
      <feature name='apic'/>
    </cpu>
    <migration_features>
      <live/>
      <uri_transports>
        <uri_transport>tcp</uri_transport>
      </uri_transports>
    </migration_features>
  </host>
  <guest>
    <os_type>hvm</os_type>
    <arch name='i686'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu</emulator>
      <machine>pc-0.12</machine>
      <machine canonical='pc-0.12'>pc</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
    <features>
      <cpuselection/>
      <pae/>
      <nonpae/>
      <acpi default='on' toggle='yes'/>
      <apic default='on' toggle='no'/>
    </features>
  </guest>
  <guest>
    <os_type>hvm</os_type>
    <arch name='x86_64'>
      <wordsize>64</wordsize>
      <emulator>/usr/bin/qemu-system-x86_64</emulator>
      <machine>pc-0.12</machine>
      <machine canonical='pc-0.12'>pc</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
    <features>
      <cpuselection/>
      <acpi default='on' toggle='yes'/>
      <apic default='on' toggle='no'/>
    </features>
  </guest>
</capabilities>
-----------------------------------------------------------

"""

import os
import time

from StringIO import StringIO
import errno

import karesansui

from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_nums_xml_xpath as XMLXpathNum, \
     get_xml_parse as XMLParse, \
     r_chgrp, r_chmod, preprint_r

class KaresasnuiCapabilitiesConfigParamException(karesansui.KaresansuiLibException):
    pass

class CapabilitiesConfigParam:

    def __init__(self):
        self.host      = {}
        self.guest     = []

    def get_host_cpu_arch(self):
        try:
            return self.host['cpu']['arch']
        except:
            return None

    def load_xml_config(self,string):

        doc = XMLParse(string)
        xpath_prefix = "/capabilities"

        ###################
        # host section
        host_xpath = "%s/host" % xpath_prefix
        host = {}

        # host - cpu section
        host_cpu_xpath = "%s/cpu" % host_xpath
        cpu = {}
        cpu['arch']  = XMLXpath(doc, '%s/arch/text()'  % host_cpu_xpath)
        cpu['model'] = XMLXpath(doc, '%s/model/text()' % host_cpu_xpath)
        topology = {}
        topology['sockets'] = XMLXpath(doc, '%s/topology/@sockets' % host_cpu_xpath)
        topology['cores']   = XMLXpath(doc, '%s/topology/@cores'   % host_cpu_xpath)
        topology['threads'] = XMLXpath(doc, '%s/topology/@threads' % host_cpu_xpath)
        cpu['topology'] = topology

        features = {}
        feature = []
        feature_num = XMLXpathNum(doc, '%s/feature' % host_cpu_xpath)
        for n in range(1, feature_num + 1):
            name = XMLXpath(doc, '%s/feature[%i]/@name' % (host_cpu_xpath, n,))
            feature.append(name)
        vmx = XMLXpath(doc, '%s/features/vmx' % host_cpu_xpath)
        features['feature'] = feature
        features['vmx'] = vmx
        cpu['feature'] = features

        host['cpu'] = cpu

        # host - migration_features section
        host_migration_features_xpath = "%s/migration_features" % host_xpath
        migration_features = {}

        uri_transports = []
        uri_transport_num = XMLXpathNum(doc,'%s/uri_transports/uri_transport' % host_migration_features_xpath)
        for n in range(1, uri_transport_num + 1):
            uri_transport = XMLXpath(doc,'%s/uri_transports/uri_transport/text()' % host_migration_features_xpath)
            uri_transports.append(uri_transport)
        live = XMLXpath(doc, '%s/live' % host_migration_features_xpath)
        migration_features['uri_transports'] = uri_transports
        migration_features['live'] = live

        host['migration_features'] = migration_features

        ###################
        # guest section
        guest_xpath = "%s/guest" % xpath_prefix
        guests = []

        guest_num = XMLXpathNum(doc,'%s' % guest_xpath)
        for n in range(1, guest_num + 1):
            guest = {}

            os_type  = XMLXpath(doc, '%s[%i]/os_type/text()' % (guest_xpath,n,))

            arch = {}
            name     = XMLXpath(doc, '%s[%i]/arch/@name'           % (guest_xpath,n,))
            wordsize = XMLXpath(doc, '%s[%i]/arch/wordsize/text()' % (guest_xpath,n,))
            emulator = XMLXpath(doc, '%s[%i]/arch/emulator/text()' % (guest_xpath,n,))
            machines = []
            machine_num = XMLXpathNum(doc, '%s[%i]/arch/machine'      % (guest_xpath,n,))
            for m in range(1, machine_num + 1):
                machine = XMLXpath(doc, '%s[%i]/arch/machine[%i]/text()'  % (guest_xpath,n,m,))
                machines.append(machine)
            domain = {}
            type = XMLXpath(doc, '%s[%i]/arch/domain/@type'        % (guest_xpath,n,))
            domain['type'] = type
            arch['name'] = name
            arch['wordsize'] = wordsize
            arch['emulator'] = emulator
            arch['machine']  = machines
            arch['domain']   = domain

            features = {}
            cpuselection  = XMLXpath(doc, '%s[%i]/features/cpuselection' % (guest_xpath,n,))
            pae      = XMLXpath(doc, '%s[%i]/features/pae'           % (guest_xpath,n,))
            nonpae   = XMLXpath(doc, '%s[%i]/features/nonpae'        % (guest_xpath,n,))
            acpi = {}
            default  = XMLXpath(doc, '%s[%i]/features/acpi/@default' % (guest_xpath,n,))
            toggle   = XMLXpath(doc, '%s[%i]/features/acpi/@toggle'  % (guest_xpath,n,))
            acpi['default'] = default
            acpi['toggle']  = toggle
            apic = {}
            default  = XMLXpath(doc, '%s[%i]/features/apic/@default' % (guest_xpath,n,))
            toggle   = XMLXpath(doc, '%s[%i]/features/apic/@toggle'  % (guest_xpath,n,))
            apic['default'] = default
            apic['toggle']  = toggle
            features['acpi'] = acpi
            features['apic'] = apic

            guest['os_type']  = os_type
            guest['arch']     = arch
            guest['features'] = features
            guests.append(guest)

        self.host  = host
        self.guest = guests

        return { "host" :self.host, "guest":self.guest }


    def validate(self):
        pass

if __name__ == '__main__':
    string = """<capabilities>

  <host>
    <cpu>
      <arch>x86_64</arch>
      <model>pentium3</model>
      <topology sockets='1' cores='1' threads='1'/>
      <feature name='lahf_lm'/>
      <feature name='lm'/>
      <feature name='nx'/>
      <feature name='syscall'/>
      <feature name='hypervisor'/>
      <feature name='sse4.1'/>
      <feature name='cx16'/>
      <feature name='ssse3'/>
      <feature name='pni'/>
      <feature name='ss'/>
      <feature name='sse2'/>
      <feature name='acpi'/>
      <feature name='ds'/>
      <feature name='clflush'/>
      <feature name='apic'/>
    </cpu>
    <migration_features>
      <live/>
      <uri_transports>
        <uri_transport>tcp</uri_transport>
      </uri_transports>
    </migration_features>
  </host>

  <guest>
    <os_type>hvm</os_type>
    <arch name='i686'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu</emulator>
      <machine>pc-0.12</machine>
      <machine canonical='pc-0.12'>pc</machine>
      <machine>pc-0.11</machine>
      <machine>pc-0.10</machine>
      <machine>isapc</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
    <features>
      <cpuselection/>
      <pae/>
      <nonpae/>
      <acpi default='on' toggle='yes'/>
      <apic default='on' toggle='no'/>
    </features>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='x86_64'>
      <wordsize>64</wordsize>
      <emulator>/usr/bin/qemu-system-x86_64</emulator>
      <machine>pc-0.12</machine>
      <machine canonical='pc-0.12'>pc</machine>
      <machine>pc-0.11</machine>
      <machine>pc-0.10</machine>
      <machine>isapc</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
    <features>
      <cpuselection/>
      <acpi default='on' toggle='yes'/>
      <apic default='on' toggle='no'/>
    </features>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='arm'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu-system-arm</emulator>
      <machine>integratorcp</machine>
      <machine>syborg</machine>
      <machine>musicpal</machine>
      <machine>mainstone</machine>
      <machine>n800</machine>
      <machine>n810</machine>
      <machine>cheetah</machine>
      <machine>sx1</machine>
      <machine>sx1-v1</machine>
      <machine>tosa</machine>
      <machine>akita</machine>
      <machine>spitz</machine>
      <machine>borzoi</machine>
      <machine>terrier</machine>
      <machine>connex</machine>
      <machine>verdex</machine>
      <machine>lm3s811evb</machine>
      <machine>lm3s6965evb</machine>
      <machine>realview-eb</machine>
      <machine>realview-eb-mpcore</machine>
      <machine>realview-pb-a8</machine>
      <machine>realview-pbx-a9</machine>
      <machine>versatilepb</machine>
      <machine>versatileab</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='mips'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu-system-mips</emulator>
      <machine>malta</machine>
      <machine>mipssim</machine>
      <machine>magnum</machine>
      <machine>pica61</machine>
      <machine>mips</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='mipsel'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu-system-mipsel</emulator>
      <machine>malta</machine>
      <machine>mipssim</machine>
      <machine>magnum</machine>
      <machine>pica61</machine>
      <machine>mips</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='sparc'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu-system-sparc</emulator>
      <machine>SS-5</machine>
      <machine>SS-10</machine>
      <machine>SS-600MP</machine>
      <machine>SS-20</machine>
      <machine>Voyager</machine>
      <machine>LX</machine>
      <machine>SS-4</machine>
      <machine>SPARCClassic</machine>
      <machine>SPARCbook</machine>
      <machine>SS-1000</machine>
      <machine>SS-2000</machine>
      <machine>SS-2</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
  </guest>

  <guest>
    <os_type>hvm</os_type>
    <arch name='ppc'>
      <wordsize>32</wordsize>
      <emulator>/usr/bin/qemu-system-ppc</emulator>
      <machine>g3beige</machine>
      <machine>mpc8544ds</machine>
      <machine>bamboo</machine>
      <machine>ref405ep</machine>
      <machine>taihu</machine>
      <machine>mac99</machine>
      <machine>prep</machine>
      <machine>xenpv</machine>
      <domain type='qemu'>
      </domain>
    </arch>
  </guest>

</capabilities>
"""

    param = CapabilitiesConfigParam()
    param.load_xml_config(string)

    preprint_r(param.host)
    preprint_r(param.guest) 

########NEW FILE########
__FILENAME__ = config_export
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
</comment-ja>
<comment-en>
Generate configuration file of info.dat.
</comment-en>

@file:   config_export.py

@author: Taizo ITO <taizo@karesansui-project.info>
"""

import os
import time

import errno
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui

from karesansui.lib.utils import get_xml_xpath as XMLXpath, \
     get_nums_xml_xpath as XMLXpathNum, \
     get_xml_parse as XMLParse, \
     r_chgrp, r_chmod

from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.const import VIRT_DOMAINS_DIR, KARESANSUI_GROUP


class KaresasnuiExportConfigParamException(karesansui.KaresansuiLibException):
    pass

class ExportConfigParam:

    def __init__(self, uuid=None):

        self.path      = None
        self.uuid      = uuid
        self.domain    = None
        self.title     = None
        self.created   = None
        self.database = None
        # エクスポート元のストレージプール名
        self.pool = None
        self.disks = []
        self.snapshots = None

    def get_path(self):
        return self.path

    def set_path(self, path):
        self.path = path

    def get_uuid(self):
        return self.uuid

    def set_uuid(self, uuid):
        self.uuid = uuid

    def get_domain(self):
        return self.domain

    def set_domain(self, domain):
        self.domain = domain

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_created(self):
        return self.created

    def set_created(self, created):
        try:
            created = str(created)
        except:
            created = None
        self.created = created

    def get_database(self):
        return self.database

    def set_database(self, database):
        self.database = database

    def get_pool(self):
        return self.pool

    def set_pool(self, pool):
        self.pool = pool

    def get_disks(self):
        return self.disks

    def set_disks(self, disks):
        self.disks = disks

    def get_snapshots(self):
        return self.snapshots

    def set_snapshots(self, snapshots):
        self.snapshots = snapshots

    def get_default_export_dir(self, uuid):
        return "%s/%s" % (VIRT_DOMAINS_DIR,uuid,)

    def add_export(self, uuid, domain, title, database, pool, disks, created=None, snapshots=None):
        self.set_uuid(uuid)
        self.set_domain(domain)
        self.set_title(title)
        self.set_database(database)
        self.set_pool(pool)
        self.set_disks(disks)
        self.set_snapshots(snapshots)

        if created is None:
            created = str(int(time.time()))
        else:
            pass
        self.set_created(created)

        if self.path is None:
            self.set_path(self.get_default_export_dir(uuid))

    def add_disk(self, uuid, name, path):
        """<comment-ja>
        @param uuid: Storage Volume UUID
        @param name: Storage Pool Name
        @param path: Storage Pool Path
        </comment-ja>
        <comment-en>
        TODO: English Documents(en)
        </comment-en>
        """
        self.disks.append({"uuid" : uuid, "name" : name, "path" : path,})

    def add_snapshot(self, name, title, value):
        self.snapshots.append({"name":name , "title":title, "value":value,})

    def load_xml_config(self, path=None):
        if path is not None:
            self.path = path

        if not os.path.isfile(self.path):
            raise KaresasnuiExportConfigParamException(
                "File not found. path=%s" % (str(self.path)))

        document = XMLParse(self.path)

        uuid    = XMLXpath(document, '/export/@id')
        domain  = XMLXpath(document, '/export/domain/text()')
        title   = XMLXpath(document, '/export/title/text()')
        created = XMLXpath(document, '/export/created/text()')

        database = {'name' : XMLXpath(document, '/export/database/name/text()'),
                    'tags' : XMLXpath(document, '/export/database/tags/text()'),
                    'attribute' : XMLXpath(document, '/export/database/attribute/text()'),
                    'uniq_key' : XMLXpath(document, '/export/database/uniq_key/text()'),
                    'hypervisor' : XMLXpath(document, '/export/database/hypervisor/text()'),
                    'icon' : XMLXpath(document, '/export/database/icon/text()'),
                    'notebook' : {
                        'title' : XMLXpath(document, '/export/database/notebook/title/text()'),
                        'value' : XMLXpath(document, '/export/database/notebook/value/text()'),
                        },
                    }

        disks = []
        disk_num = XMLXpathNum(document,'/export/disks/disk')
        for n in range(1, disk_num + 1):
            duuid = XMLXpath(document, '/export/disks/disk[%i]/@uuid' % n)
            dname = XMLXpath(document, '/export/disks/disk[%i]/name/text()' % n)
            dpath = XMLXpath(document, '/export/disks/disk[%i]/path/text()' % n)
            disks.append({"uuid" : duuid, "name" : dname, "path" : dpath,})

        pool = XMLXpath(document, '/export/pool/text()')

        snapshots = []
        snapshot_num = XMLXpathNum(document,'/export/snapshots/snapshot')
        for n in range(1, snapshot_num + 1):
            name  = XMLXpath(document, '/export/snapshots/snapshot[%i]/@name' % n)
            title = XMLXpath(document, '/export/snapshots/snapshot[%i]/title/text()' % n)
            value = XMLXpath(document, '/export/snapshots/snapshot[%i]/value/text()' % n)
            snapshots.append({"name":name, "title":title, "value":value,})

        self.add_export(uuid, domain, title, database, pool, disks, created=created, snapshots=snapshots)

    def validate(self):
        pass

class ExportXMLGenerator:

    def __init__(self, path):
        self.path = path

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self, config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree.toxml())
        return out.getvalue()

    def writecfg(self, cfg):
        ConfigFile(self.path).write(cfg)
        r_chmod(self.path, "o-rwx")
        r_chmod(self.path, "g+rw")

        if os.getuid() == 0:
            r_chgrp(self.path, KARESANSUI_GROUP)

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config
        self.begin_build()
        self.build_database()
        self.build_disks()
        self.build_snapshots()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)

        self.export = self.document.createElement("export")
        self.export.setAttribute("id", self.config.get_uuid())

        domain = self.config.get_domain()
        if domain is not None:
            n_domain = self._create_text_node("domain", domain)
            self.export.appendChild(n_domain)

        title = self.config.get_title()
        if title is not None:
            n_title = self._create_text_node("title", title)
            self.export.appendChild(n_title)

        created = self.config.get_created()
        if created is not None:
            n_created = self._create_text_node("created", created)
            self.export.appendChild(n_created)

        pool = self.config.get_pool()
        if pool is not None:
            n_pool = self._create_text_node("pool", pool)
            self.export.appendChild(n_pool)

        self.document.appendChild(self.export)

    def build_database(self):
        doc = self.document
        database = self.config.get_database()
        self.database = doc.createElement("database")

        for _k,_v in database.iteritems():
            if _v is not None:
                if type(_v) is dict:
                    child_elem = doc.createElement(_k)
                    for _n_k, _n_v in _v.iteritems():
                        child_node = self._create_text_node(_n_k, _n_v)
                        child_elem.appendChild(child_node)
                    self.database.appendChild(child_elem)
                elif type(_v) in (str, unicode):
                    node = self._create_text_node(_k, str(_v.encode('utf-8')))
                else:
                    node = self._create_text_node(_k, str(_v))
            else:
                node = doc.createElement(_k)
            self.database.appendChild(node)
        self.export.appendChild(self.database)

    def build_disks(self):
        doc = self.document
        disks = self.config.get_disks()
        self.disks = doc.createElement("disks")

        for disk in disks:
            elem_disk = doc.createElement("disk")
            # uuid
            elem_disk.setAttribute("uuid", disk['uuid'])
            # name
            elem_disk.appendChild(self._create_text_node("name", disk["name"]))
            # path
            elem_disk.appendChild(self._create_text_node("path", disk["path"]))

            self.disks.appendChild(elem_disk)

        self.export.appendChild(self.disks)

    def build_snapshots(self):
        doc = self.document
        snapshots = self.config.get_snapshots()
        if snapshots is not None:
            self.snapshots = doc.createElement("snapshots")
            for snapshot in snapshots:
                elem_snapshot = doc.createElement("snapshot")
                # name
                elem_snapshot.setAttribute("name", snapshot['name'])
                # title
                elem_snapshot.appendChild(self._create_text_node("title", snapshot["title"]))
                # value
                elem_snapshot.appendChild(self._create_text_node("value", snapshot["value"]))

                self.snapshots.appendChild(elem_snapshot)

            self.export.appendChild(self.snapshots)

    def end_build(self):
        pass

if __name__ == '__main__':
    orig_xml = """<?xml version='1.0' encoding='UTF-8'?>
<export id='19ea2e00-418f-673c-94bf-a32c2d143a87'>
  <domain>kaeru</domain>
  <title>
  </title>
  <created>1274353107</created>
  <pool></pool>
  <database>
    <name>かえる</name>
    <tags>
    </tags>
    <attribute>1</attribute>
    <notebook>
      <value>
      </value>
      <title>
      </title>
    </notebook>
    <uniq_key>f7313c64-6925-1caf-e84e-070f2b10738d</uniq_key>
    <hypervisor>2</hypervisor>
    <icon>1274172707.069426.png</icon>
  </database>
  <disks>
    <disk uuid="f7313c64-6925-1caf-e84e-070f2b10738d">
      <name>default</name>
      <path>/var/lib/libvirt/domains</path>
    </disk>
  </disks>
</export>"""

    param = ExportConfigParam()

    path = "/var/lib/libvirt/domains/8cf93333-4565-9d8e-9f19-4fbc95f9b96d/info.dat"

    # read original data file
    param.load_xml_config(path)

    # overwrite some parameters
    param.set_uuid("uuid_desu")
    param.set_domain("domain1")
    param.set_title("title1")

    # write to new file
    generator =  ExportXMLGenerator(path+".new")
    try:
        cfgxml = generator.generate(param)
    except:
        raise

    generator.writecfg(cfgxml)

########NEW FILE########
__FILENAME__ = config_network
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
libvirtの仮想ネットワークの設定を生成する
</comment-ja>
<comment-en>
Generate configuration file of virtual networks for libvirt.
</comment-en>

@file:   config_network.py

@author: Taizo ITO <taizo@karesansui-project.info>

@copyright:    

"""

import time
import os, stat
import re
import errno
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui
from karesansui.lib.const import KARESANSUI_GROUP, \
     VIRT_NETWORK_CONFIG_DIR
from karesansui.lib.utils import get_xml_parse        as XMLParse
from karesansui.lib.utils import get_xml_xpath        as XMLXpath
from karesansui.lib.utils import r_chgrp, r_chmod
from karesansui.lib.networkaddress import NetworkAddress
from karesansui.lib.file.configfile import ConfigFile

class KaresansuiNetworkConfigParamException(karesansui.KaresansuiLibException):
    pass

class NetworkConfigParam:
    def __init__(self, arg):
        if isinstance(arg, basestring):
            # expect name as string
            self.name = arg
            self.uuid = None
            self.bridge = None
            self.forward_dev = None
            self.forward_mode = None
            self.ipaddr = None
            self.netmask = None
            self.dhcp_start = None
            self.dhcp_end = None
            self.bridge_stp = None
            self.bridge_forwardDelay = None
        else:
            # expect dict in KaresansuiVirtNetwork#get_info() format
            self.name = arg['name']
            self.uuid = arg['uuid']
            self.bridge = arg['bridge']['name']
            self.forward_dev = arg['forward']['dev']
            self.forward_mode = arg['forward']['mode']
            self.ipaddr = arg['ip']['address']
            self.netmask = arg['ip']['netmask']
            self.dhcp_start = arg['dhcp']['start']
            self.dhcp_end = arg['dhcp']['end']
            try:
                self.bridge_stp = arg['bridge']['stp']
            except:
                self.bridge_stp = None
            try:
                self.bridge_forwardDelay = arg['bridge']['forwardDelay']
            except:
                self.bridge_forwardDelay = None


    def get_network_name(self):
        return self.name

    def set_uuid(self, uuid):
        self.uuid = uuid
    def get_uuid(self):
        return self.uuid

    def set_bridge(self, bridge):
        """
        @param bridge: name of the bridge
        @type bridge: string
        @return nothing
        """
        if bridge is not None:
            self.bridge = str(bridge)

    def get_bridge(self):
        return self.bridge

    def set_forward_dev(self, device):
        if device is not None:
            self.forward_dev = str(device)
    def get_forward_dev(self):
        return self.forward_dev

    def set_forward_mode(self, mode='nat'):
        if mode is not None:
            self.forward_mode = str(mode)
    def get_forward_mode(self):
        return self.forward_mode

    def set_default_networks(self, addr, dhcp_start=None, dhcp_end=None):
        self.set_netmask(NetworkAddress(addr).get('netmask'))
        self.set_ipaddr(NetworkAddress(addr).get('first_ip'))
        if not dhcp_start:
            dhcp_start = NetworkAddress(addr).get('first_ip')
        if not dhcp_end:
            dhcp_end = NetworkAddress(addr).get('last_ip')
        self.set_dhcp_start(dhcp_start)
        self.set_dhcp_end(dhcp_end)

    def get_networks(self):
        return {"ipaddr": self.ipaddr, "netmask":self.netmask,
                "dhcp_start": self.dhcp_start, "dhcp_stop":self.dhcp_stop}

    def set_ipaddr(self, addr):
        if addr is not None:
            self.ipaddr = str(addr)
    def get_ipaddr(self):
        return self.ipaddr

    def set_netmask(self, addr):
        if addr is not None:
            self.netmask = str(addr)
    def get_netmask(self):
        return self.netmask

    def set_ipaddr_and_netmask(self, addr):
        """
        Set ip address and netmask from '192.168.0.1/24' or '192.168.0.1/255.255.255.0' styled strings.
        @param addr: Strings like '192.168.0.1/24' or '192.168.0.1/255.255.255.0'.
        @type addr: string
        @return: nothing
        """
        na = NetworkAddress(addr)
        self.set_ipaddr(na.get('ipaddr'))
        self.set_netmask(na.get('netmask'))

    def set_dhcp_start(self, addr):
        if addr is not None:
            self.dhcp_start = str(addr)
    def get_dhcp_start(self):
        return self.dhcp_start

    def set_dhcp_end(self, addr):
        if addr is not None:
            self.dhcp_end = str(addr)
    def get_dhcp_end(self):
        return self.dhcp_end

    def set_bridge_stp(self, stp='on'):
        if stp is not None:
           self.bridge_stp = str(stp)
    def get_bridge_stp(self):
        return self.bridge_stp

    def set_bridge_forwardDelay(self, forwardDelay):
        if forwardDelay is not None:
            self.bridge_forwardDelay = str(forwardDelay)
    def get_bridge_forwardDelay(self):
        return self.bridge_forwardDelay

    def load_xml_config(self,path):

        if not os.path.exists(path):
            raise KaresansuiNetworkConfigParamException("no such file: %s" % path)

        document = XMLParse(path)
        uuid = XMLXpath(document,'/network/uuid/text()')
        self.set_uuid(str(uuid))

        bridge = XMLXpath(document,'/network/bridge/@name')
        self.set_bridge(bridge)

        forward_dev  = XMLXpath(document,'/network/forward/@dev')
        if forward_dev:
            self.set_forward_dev(forward_dev)
        forward_mode = XMLXpath(document,'/network/forward/@mode')
        if forward_mode:
            self.set_forward_mode(forward_mode)

        ipaddr = XMLXpath(document,'/network/ip/@address')
        self.set_ipaddr(ipaddr)

        netmask = XMLXpath(document,'/network/ip/@netmask')
        self.set_netmask(netmask)

        dhcp_start = XMLXpath(document,'/network/ip/dhcp/range/@start')
        self.set_dhcp_start(dhcp_start)

        dhcp_end = XMLXpath(document,'/network/ip/dhcp/range/@end')
        self.set_dhcp_end(dhcp_end)

        bridge_stp = XMLXpath(document,'/network/bridge/@stp')
        self.set_bridge_stp(bridge_stp)

        bridge_forwardDelay = XMLXpath(document,'/network/bridge/@forwardDelay')
        self.set_bridge_forwardDelay(bridge_forwardDelay)

    def validate(self):

        if not self.uuid:
            raise KaresansuiNetworkConfigParamException("ConfigParam: uuid is None")
        if not self.name or not len(self.name):
            raise KaresansuiNetworkConfigParamException("ConfigParam: illegal name")

class NetworkXMLGenerator:

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self, config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree.toxml())
        return out.getvalue()

class NetworkXMLConfigGenerator(NetworkXMLGenerator):

    def __init__(self):
        self.config_dir = VIRT_NETWORK_CONFIG_DIR

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config

        self.begin_build()
        self.build_bridge()
        self.build_forward()
        self.build_ip()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.network = self.document.createElement("network")

        name = self._create_text_node("name", self.config.get_network_name())
        uuid = self._create_text_node("uuid", self.config.get_uuid())
        self.network.appendChild(name)
        self.network.appendChild(uuid)

        self.document.appendChild(self.network)

    def build_bridge(self):
        doc = self.document
        if self.config.get_bridge():
            bridge = doc.createElement("bridge")
            bridge.setAttribute("name", self.config.get_bridge())

            if self.config.get_bridge_stp() is not None:
                bridge.setAttribute("stp", self.config.get_bridge_stp())
            else:
                bridge.setAttribute("stp", "on")

            if self.config.get_bridge_forwardDelay() is not None:
                bridge.setAttribute("forwardDelay", self.config.get_bridge_forwardDelay())
            else:
                bridge.setAttribute("forwardDelay", "0")

            self.network.appendChild(bridge)

    def build_forward(self):
        doc = self.document
        if self.config.get_forward_dev() is not None or \
           self.config.get_forward_mode() is not None:

            forward = doc.createElement("forward")
            if self.config.get_forward_dev() is not None:
                forward.setAttribute("dev", self.config.get_forward_dev())
            if self.config.get_forward_mode() is not None:
                forward.setAttribute("mode", self.config.get_forward_mode())
            self.network.appendChild(forward)

    def build_ip(self):
        doc = self.document
        ip = doc.createElement("ip")
        ip.setAttribute("netmask", self.config.get_netmask())
        ip.setAttribute("address", self.config.get_ipaddr())
        self.network.appendChild(ip)

        dhcp = doc.createElement("dhcp")
        range = doc.createElement("range")
        range.setAttribute("start", self.config.get_dhcp_start())
        range.setAttribute("end", self.config.get_dhcp_end())
        dhcp.appendChild(range)
        ip.appendChild(dhcp)

    def end_build(self):
        pass

    def writecfg(self,cfg):
        try:
            os.makedirs(self.config_dir)
        except OSError, (err, msg):
            if err != errno.EEXIST:
                raise OSError(err,msg)

        filename = "%s/%s.xml" %(self.config_dir,self.config.get_network_name())
        ConfigFile(filename).write(cfg)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)


########NEW FILE########
__FILENAME__ = config_storage
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
libvirtのStorage Pool/Volume の設定を生成する
</comment-ja>
<comment-en>
Generate configuration file of storage pool/volume for libvirt.
</comment-en>

@file:   config_storage.py

@author: Kei Funagayama <kei@karesansui-project.info>
"""

import time
import os, stat
import re
import errno
from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui
from karesansui.lib.const import KARESANSUI_GROUP, \
     VIRT_STORAGE_CONFIG_DIR
from karesansui.lib.utils import get_xml_parse        as XMLParse
from karesansui.lib.utils import get_xml_xpath        as XMLXpath
from karesansui.lib.utils import r_chgrp, r_chmod, symlink2real
from karesansui.lib.file.configfile import ConfigFile

class KaresansuiStorageConfigParamException(karesansui.KaresansuiLibException):
    pass

class KaresansuiStoragePoolConfigParamException(KaresansuiStorageConfigParamException):
    pass

class KaresansuiStorageVolumeConfigParamException(KaresansuiStorageConfigParamException):
    pass


class StorageConfigParam:
    def set_uuid(self, uuid):
        self.uuid = uuid
    def get_uuid(self):
        return self.uuid

    def set_allocation(self, allocation):
        self.allocation = allocation
    def get_allocation(self):
        return self.allocation

    def set_capacity(self, capacity):
        self.capacity = capacity
    def get_capacity(self):
        return self.capacity

    def set_storage_name(self, name):
        self.name = name
    def get_storage_name(self):
        return self.name

class StoragePoolConfigParam(StorageConfigParam):

    def __init__(self, arg):
        if isinstance(arg, basestring):
            # expect name as string
            self.name = arg
            self.uuid = None
            self.p_type = None
            self.allocation = None
            self.capacity = None
            self.available = None
            self.s_dev_path = None
            self.s_dir_path = None
            self.s_h_name = None
            #self.s_name = None
            self.s_f_type = None
            self.t_path = None
            self.t_p_owner = None
            self.t_p_group = None
            self.t_p_mode = None
            self.t_p_label = None
            self.t_e_format = None
            self.t_e_s_type = None
            self.t_e_s_uuid = None

        else:
            self.name = arg['name']
            self.uuid = arg['uuid']
            self.p_type = arg['pool']['type']
            self.allocation = arg['allocation']
            self.capacity = arg['capacity']
            self.available = arg['available']
            self.s_dev_path = arg['source']['device']['path']
            self.s_dir_path = arg['source']['directory']['path']
            self.s_h_name = arg['source']['host']['name']
            #self.s_name = arg['source']['name']
            self.s_f_type = arg['source']['format']['type']
            self.t_path = arg['target']['path']
            self.t_p_owner = arg['target']['permissions']['owner']
            self.t_p_group = arg['target']['permissions']['group']
            self.t_p_mode = arg['target']['permissions']['mode']
            self.t_p_label = arg['target']['permissions']['label']
            self.t_e_format = arg['target']['encryption']['format']
            self.t_e_s_type = arg['target']['encryption']['secret']['type']
            self.t_e_s_uuid = arg['target']['encryption']['secret']['uuid']

    def set_pool_type(self, p_type):
        self.p_type = p_type
    def get_pool_type(self):
        return self.p_type

    def set_available(self, available):
        self.available = available
    def get_available(self):
        return self.available

    def set_source_dev_path(self, s_dev_path):
        self.s_dev_path = s_dev_path
    def get_source_dev_path(self):
        return self.s_dev_path

    def set_source_dir_path(self, s_dir_path):
        self.s_dir_path = s_dir_path
    def get_source_dir_path(self):
        return self.s_dir_path

    def set_source_h_name(self, s_h_name):
        self.s_h_name = s_h_name
    def get_source_h_name(self):
        return self.s_h_name

    def set_source_f_type(self, s_f_type):
        self.s_f_type = s_f_type
    def get_source_f_type(self):
        return self.s_f_type

    def set_target_path(self, t_path):
        self.t_path = t_path
    def get_target_path(self):
        return self.t_path

    def set_target_permissions_owner(self, t_p_owner):
        self.t_p_owner = t_p_owner
    def get_target_permissions_owner(self):
        return self.t_p_owner

    def set_target_permissions_group(self, t_p_group):
        self.t_p_group = t_p_group
    def get_target_permissions_group(self):
        return self.t_p_group

    def set_target_permissions_mode(self, t_p_mode):
        self.t_p_mode = t_p_mode
    def get_target_permissions_mode(self):
        return self.t_p_mode

    def set_target_permissions_label(self, t_p_label):
        self.t_p_label = t_p_label
    def get_target_permissions_label(self):
        return self.t_p_label

    def set_target_e_format(self, t_e_format):
        self.t_e_format = t_e_format
    def get_target_e_format(self):
        return self.t_e_format

    def set_target_encryption_s_type(self, t_e_s_type):
        self.t_e_s_type = t_e_s_type
    def get_target_encryption_s_type(self):
        return self.t_e_s_type

    def set_target_encryption_s_uuid(self, t_e_s_uuid):
        self.t_e_s_uuid = t_e_s_uuid
    def get_target_encryption_s_uuid(self):
        return self.t_e_s_uuid

    def load_xml_config(self,path):
        document = XMLParse(path)

        p_type =  XMLXpath(document, '/pool/@type')        
        self.set_pool_type(p_type)

        uuid = XMLXpath(document,'/pool/uuid/text()')
        self.set_uuid(str(uuid))

        allocation = XMLXpath(document, '/pool/allocation/text()')
        self.set_allocation(allocation)

        capacity = XMLXpath(document, '/pool/capacity/text()')
        self.set_capacity(capacity)

        available = XMLXpath(document, '/pool/available/text()')
        self.set_available(available)

        s_dev_path = XMLXpath(document, '/pool/source/device/@path')
        self.set_source_dev_path(s_dev_path)

        s_dir_path = XMLXpath(document, '/pool/source/directory/@path')
        self.set_source_dir_path(s_dir_path)

        s_h_name = XMLXpath(document, '/pool/source/host/@name')
        self.set_source_h_name(s_h_name)

        s_f_type = XMLXpath(document, '/pool/source/format/@type')
        self.set_source_f_type


        t_path = XMLXpath(document, '/pool/target/path/text()')
        self.set_target_path(t_path)

        t_p_owner = XMLXpath(document, '/pool/target/permissions/owner/text()')
        self.set_target_permissions_owner(t_p_owner)
        
        t_p_group = XMLXpath(document, '/pool/target/permissions/group/text()')
        self.set_target_permissions_group(t_p_group)

        t_p_mode = XMLXpath(document, '/pool/target/permissions/mode/text()')
        self.set_target_permissions_mode(t_p_mode)

        t_p_label = XMLXpath(document, '/pool/target/permissions/label/text()')
        self.set_target_permissions_label(t_p_label)

        t_e_format = XMLXpath(document, '/pool/target/encryption/@format')
        self.set_target_e_format(t_e_format)

        t_e_s_type = XMLXpath(document, '/pool/target/encryption/secret/@type')
        self.set_target_encryption_s_type(t_e_s_type)

        t_e_s_uuid = XMLXpath(document, '/pool/target/encryption/secret/@uuid')
        self.set_target_encryption_s_uuid(t_e_format)

    def validate(self):

        if not self.uuid:
            raise KaresansuiStorageConfigParamException("ConfigParam: uuid is None")
        if not self.name or not len(self.name):
            raise KaresansuiStorageConfigParamException("ConfigParam: illegal name")


#--
class StorageVolumeConfigParam(StorageConfigParam):

    def __init__(self, arg):
        if isinstance(arg, basestring):
            # expect name as string
            self.name = arg
            self.uuid = None
            self.key = None
            self.allocation = None
            self.capacity = None
            self.c_unit = None
            self.source = None

            self.t_path = None
            self.t_f_type = None
            self.t_p_owner = None
            self.t_p_group = None
            self.t_p_mode = None
            self.t_p_label = None

            self.b_path = None
            self.b_format = None
            self.b_p_owner = None
            self.b_p_group = None
            self.b_p_mode = None
            self.b_p_label = None

        else:
            # expect dict in KaresansuiVirtStorageVolume#get_info() format
            self.name = arg['name']
            self.uuid = arg['uuid']
            
            self.key = arg['key']
            self.allocation = arg['allocation']
            self.capacity = arg['capacity']
            self.c_unit = arg['capacity']['unit']
            self.source = arg['source']
            
            self.t_path = arg['target']['path']
            self.t_f_type = arg['target']['format']['type']
            self.t_p_owner = arg['target']['permissions']['owner']
            self.t_p_group = arg['target']['permissions']['group']
            self.t_p_mode = arg['target']['permissions']['mode']
            self.t_p_label = arg['target']['permissions']['label']

            self.b_path = arg['backingStore']['path']
            self.b_format = arg['backingStore']['format']
            self.b_p_owner = arg['backingStore']['permissions']['owner']
            self.b_p_group = arg['backingStore']['permissions']['group']
            self.b_p_mode = arg['backingStore']['permissions']['mode']
            self.b_p_label = arg['backingStore']['permissions']['label']

    def set_key(self, key):
        self.key = key
    def get_key(self):
        return self.key

    def set_c_unit(self, c_unit):
        self.c_unit = c_unit
    def get_c_unit(self):
        return self.c_unit

    def set_source(self, source):
        self.source = source
    def get_source(self):
        return self.source

    def set_target_path(self, t_path):
        self.t_path = t_path
    def get_target_path(self):
        return self.t_path

    def set_target_f_type(self, t_f_type):
        self.t_f_type = t_f_type
    def get_target_f_type(self):
        return self.t_f_type

    def set_target_permissions_owner(self, t_p_owner):
        self.t_p_owner = t_p_owner
    def get_target_permissions_owner(self):
        return self.t_p_owner

    def set_target_permissions_group(self, t_p_group):
        self.t_p_group = t_p_group
    def get_target_permissions_group(self):
        return self.t_p_group

    def set_target_permissions_mode(self, t_p_mode):
        self.t_p_mode = t_p_mode
    def get_target_permissions_mode(self):
        return self.t_p_mode

    def set_target_permissions_label(self, t_p_label):
        self.t_p_label = t_p_label
    def get_target_permissions_label(self):
        return self.t_p_label

    def set_backingStore_path(self, b_path):
        self.b_path = b_path
    def get_backingStore_path(self):
        return self.b_path

    def set_backingStore_format(self, b_format):
        self.b_format = b_format
    def get_backingStore_format(self):
        return self.b_format

    def set_backingStore_permissions_owner(self, b_p_owner):
        self.b_p_owner = b_p_owner
    def get_backingStore_permissions_owner(self):
        return self.b_p_owner

    def set_backingStore_permissions_group(self, b_p_group):
        self.b_p_group = b_p_group
    def get_backingStore_permissions_group(self):
        return self.b_p_group

    def set_backingStore_permissions_mode(self, b_p_mode):
        self.b_p_mode = b_p_mode
    def get_backingStore_permissions_mode(self):
        return self.b_p_mode

    def set_backingStore_permissions_label(self, b_p_label):
        self.b_p_label = b_p_label
    def get_backingStore_permissions_label(self):
        return self.b_p_label

    def get_symlink2real(self):
        return symlink2real(self.get_target_path())
        
    def load_xml_config(self,path):
        document = XMLParse(path)

        name = XMLXpath(document,'/volume/name/text()')
        self.set_storage_name(str(name))

        uuid = XMLXpath(document,'/volume/uuid/text()')
        self.set_uuid(str(uuid))

        key = XMLXpath(document, '/volume/key/text()')
        self.set_key(key)

        allocation = XMLXpath(document, '/volume/allocation/text()')
        self.set_allocation(allocation)

        capacity = XMLXpath(document, '/volume/capacity/text()')
        self.set_capacity(capacity)

        c_unit = XMLXpath(document, '/volume/source/@unit')
        self.set_c_unit(c_unit)

        source = XMLXpath(document, '/volume/source/text()')
        self.set_source(source)
  
        t_path = XMLXpath(document, '/volume/target/path/text()')
        self.set_target_path(t_path)

        t_f_type = XMLXpath(document, '/volume/target/format/@type')
        self.set_target_f_type(t_f_type)

        t_p_owner = XMLXpath(document, '/volume/target/permissions/owner/text()')
        self.set_target_permissions_owner(t_p_owner)

        t_p_group = XMLXpath(document, '/volume/target/permissions/group/text()')
        self.set_target_permissions_group(t_p_group)

        t_p_mode = XMLXpath(document, '/volume/target/permissions/mode/text()')
        self.set_target_permissions_mode(t_p_mode)

        t_p_label = XMLXpath(document, '/volume/target/permissions/label/text()')
        self.set_target_permissions_label(t_p_label)

        b_path = XMLXpath(document, '/volume/backingStore/path/text()')
        self.set_backingStore_path(b_path)

        b_format = XMLXpath(document, '/volume/backingStore/format/text()')
        self.set_backingStore_format(b_format)

        b_p_owner = XMLXpath(document, '/volume/backingStore/permissions/owner/text()')
        self.set_backingStore_permissions_owner(b_p_owner)

        b_p_group = XMLXpath(document, '/volume/backingStore/permissions/group/text()')
        self.set_backingStore_permissions_group(b_p_group)

        b_p_mode = XMLXpath(document, '/volume/backingStore/permissions/mode/text()')
        self.set_backingStore_permissions_mode(b_p_mode)

        b_p_label = XMLXpath(document, '/volume/backingStore/permissions/label/text()')
        self.set_backingStore_permissions_label(b_p_label)

    def validate(self):

        if not self.uuid:
            raise KaresansuiStorageConfigParamException("ConfigParam: uuid is None")
        if not self.name or not len(self.name):
            raise KaresansuiStorageConfigParamException("ConfigParam: illegal name")

class StorageXMLGenerator:

    def __init__(self):
        self.config_dir = VIRT_STORAGE_CONFIG_DIR

    def _create_text_node(self, tag, txt):
        node = self.document.createElement(tag)
        self._add_text(node, txt)
        return node

    def _add_text(self, node, txt):
        txt_n = self.document.createTextNode(txt)
        node.appendChild(txt_n)

    def generate(self, config):
        tree = self.generate_xml_tree(config)
        out = StringIO()
        out.write(tree.toxml())
        return out.getvalue()

    def end_build(self):
        pass

    def writecfg(self,cfg):
        try:
            os.makedirs(self.config_dir)
        except OSError, (err, msg):
            if err != errno.EEXIST:
                raise OSError(err,msg)

        filename = "%s/%s.xml" %(self.config_dir,
                                 self.config.get_storage_name())
        ConfigFile(filename).write(cfg)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

class StoragePoolXMLConfigGenerator(StorageXMLGenerator):

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config
        self.begin_build()
        self.build_allocation()
        self.build_capacity()
        self.build_source()
        self.build_target()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.pool = self.document.createElement("pool")

        self.pool.setAttribute('type', self.config.get_pool_type())

        name = self._create_text_node("name", self.config.get_storage_name())
        uuid = self._create_text_node("uuid", self.config.get_uuid())
        self.pool.appendChild(name)
        self.pool.appendChild(uuid)

        self.document.appendChild(self.pool)

    def build_allocation(self):
        allocation = self._create_text_node("allocation",
                                        str(self.config.get_allocation()))
        self.pool.appendChild(allocation)

    def build_capacity(self):
        capacity = self._create_text_node("capacity",
                                        str(self.config.get_capacity()))
        self.pool.appendChild(capacity)

    def build_source(self):
        doc = self.document
        source = doc.createElement('source')

        if self.config.get_source_dev_path() is not None:
            device = doc.createElement('device')
            device.setAttribute('path', str(self.config.get_source_dev_path()))
            source.appendChild(device)

        if self.config.get_source_dir_path() is not None:
            directory = doc.createElement('directory')
            directory.setAttribute('path', str(self.config.get_source_dir_path()))
            source.appendChild(directory)
        
        if self.config.get_source_h_name() is not None:
            host = doc.createElement('host')
            host.setAttribute('name', str(self.config.get_source_h_name()))
            source.appendChild(host)

        if self.config.get_source_f_type() is not None:
            format = doc.createElement('format')
            format.setAttribute('type', str(self.config.get_source_f_type()))
            source.appendChild(format)

        self.pool.appendChild(source)

    def build_target(self):
        def build_permissions(self):
            doc = self.document
            permissions = doc.createElement("permissions")
            if self.config.get_target_permissions_owner() is not None:
                permissions.appendChild(
                    self._create_text_node("owner",
                                           str(self.config.get_target_permissions_owner())))
            if self.config.get_target_permissions_group() is not None:
                permissions.appendChild(
                    self._create_text_node("group",
                                           str(self.config.get_target_permissions_group())))
            if self.config.get_target_permissions_mode() is not None:
                permissions.appendChild(
                    self._create_text_node("mode",
                                           str(self.config.get_target_permissions_mode())))
            if self.config.get_target_permissions_label() is not None:
                permissions.appendChild(
                    self._create_text_node("label",
                                           str(self.config.get_target_permissions_label())))

            return permissions

        def build_encryption(self):
            doc = self.document
            encryption = doc.createElement("encryption")

            if self.config.get_target_e_format() is not None and \
                   self.config.get_target_encryption_s_type() is not None and \
                   self.config.get_target_encryption_s_uuid() is not None:

                encryption.setAttribute('format', str(self.config.get_target_e_format()))
                secret = doc.createElement("secret")
                secret.setAttribute('type', str(self.config.get_target_encryption_s_type()))
                secret.setAttribute('uuid', str(self.config.get_target_encryption_s_uuid()))
                encryption.appendChild(secret)
                
            return encryption

        doc = self.document
        target = doc.createElement("target")
        target.appendChild(self._create_text_node("path",
                                                  str(self.config.get_target_path())))
        
        target.appendChild(build_permissions(self))
        target.appendChild(build_encryption(self))

        self.pool.appendChild(target)


class StorageVolumeXMLConfigGenerator(StorageXMLGenerator):

    def generate_xml_tree(self, config):
        config.validate()
        self.config = config

        self.begin_build()
        self.build_key()
        self.build_allocation()
        self.build_capacity()
        self.build_source()
        self.build_target()
        self.build_backingStore()
        self.end_build()

        return self.document

    def begin_build(self):
        self.document = implementation.createDocument(None,None,None)
        self.volume = self.document.createElement("volume")

        name = self._create_text_node("name", self.config.get_storage_name())
        uuid = self._create_text_node("uuid", self.config.get_uuid())
        self.volume.appendChild(name)
        self.volume.appendChild(uuid)

        self.document.appendChild(self.volume)

    def build_key(self):
        if self.config.get_key() is not None:
            self.volume.appendChild(self._create_text_node("key",
                                                           str(self.config.get_key())))

    def build_allocation(self):
        self.volume.appendChild(self._create_text_node("allocation",
                                    str(self.config.get_allocation())))
    def build_capacity(self):
        capacity = self._create_text_node("capacity",
                                        str(self.config.get_capacity()))
        if self.config.get_c_unit() is not None:
            capacity.setAttribute("unit", str(self.config.get_c_unit()))

        self.volume.appendChild(capacity)

    def build_source(self):
        if self.config.get_source() is not None:
            self.volume.appendChild(self._create_text_node("source",
                                                           str(self.config.get_source())))

    def build_target(self):
        def build_permissions(self):
            doc = self.document
            permissions = doc.createElement("permissions")
            if self.config.get_target_permissions_owner() is not None:
                permissions.appendChild(
                    self._create_text_node("owner",
                                           str(self.config.get_target_permissions_owner())))
            if self.config.get_target_permissions_group() is not None:
                permissions.appendChild(
                    self._create_text_node("group",
                                           str(self.config.get_target_permissions_group())))
            if self.config.get_target_permissions_mode() is not None:
                permissions.appendChild(
                    self._create_text_node("mode",
                                           str(self.config.get_target_permissions_mode())))
            if self.config.get_target_permissions_label() is not None:
                permissions.appendChild(
                    self._create_text_node("label",
                                           str(self.config.get_target_permissions_label())))

            return permissions
            
        doc = self.document
        target = doc.createElement("target")
        #target.appendChild(self._create_text_node("path",
        #                                          str(self.config.get_target_path())))

        format = doc.createElement("format")
        format.setAttribute("type",
                            str(self.config.get_target_f_type()))

        target.appendChild(format)

        target.appendChild(build_permissions(self))

        self.volume.appendChild(target)

    def build_backingStore(self):
        def build_permissions(self):
            doc = self.document
            permissions = doc.createElement("permissions")
            if self.config.get_backingStore_permissions_owner() is not None:
                permissions.appendChild(
                    self._create_text_node("owner",
                                           str(self.config.get_backingStore_permissions_owner())))
            if self.config.get_backingStore_permissions_group() is not None:
                permissions.appendChild(
                    self._create_text_node("group",
                                           str(self.config.get_backingStore_permissions_group())))

            if self.config.get_backingStore_permissions_mode() is not None:
                permissions.appendChild(
                    self._create_text_node("mode",
                                           str(self.config.get_backingStore_permissions_mode())))
            if self.config.get_backingStore_permissions_label() is not None:
                permissions.appendChild(
                    self._create_text_node("label",
                                           str(self.config.get_backingStore_permissions_label())))

            return permissions
            
        if self.config.get_backingStore_path() is not None and \
               self.config.get_backingStore_format() is not None:

            doc = self.document
            backingStore = doc.createElement("backingStore")

            backingStore.appendChild(self._create_text_node("path",
                                                            str(self.config.get_backingStore_path())))
            backingStore.appendChild(self._create_text_node("format",
                                                            str(self.config.get_backingStore_format())))

            backingStore.appendChild(build_permissions(self))
            self.volume.appendChild(backingStore)

########NEW FILE########
__FILENAME__ = snapshot
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
スナップショットの生成と適用、情報取得を行う
</comment-ja>
<comment-en>
Take and revert snapshot of domain, or get stats of snapshot image.
</comment-en>

@file:   snapshot.py

@author: Taizo ITO <taizo@karesansui-project.info>

@copyright:    

"""

import os
import re
import libvirt
import libvirtmod
import logging
import glob

from StringIO import StringIO
from xml.dom.minidom import DOMImplementation
implementation = DOMImplementation()

import karesansui
import karesansui.lib.locale

from karesansui.lib.utils import get_xml_parse        as XMLParse
from karesansui.lib.utils import get_xml_xpath        as XMLXpath
from karesansui.lib.utils import get_nums_xml_xpath   as XMLXpathNum
from karesansui.lib.utils import get_inspect_stack, preprint_r, r_chgrp, r_chmod
from karesansui.lib.const import VIRT_XML_CONFIG_DIR, VIRT_SNAPSHOT_DIR, KARESANSUI_GROUP
from karesansui.lib.file.configfile import ConfigFile
from karesansui.lib.virt.config import ConfigParam

from karesansui.lib.virt.virt import KaresansuiVirtException, \
     KaresansuiVirtConnection

class KaresansuiVirtSnapshotException(KaresansuiVirtException):
    pass

class KaresansuiVirtSnapshot:

    def __init__(self,uri=None,readonly=True):
        self.__prep()
        self.logger.debug(get_inspect_stack())
        try:
            self.kvc = KaresansuiVirtConnection(uri=uri, readonly=readonly)
        except:
            raise KaresansuiVirtSnapshotException(_("Cannot open '%s'") % uri)
        try:
            from libvirtmod import virDomainRevertToSnapshot
            from libvirtmod import virDomainSnapshotCreateXML
            from libvirtmod import virDomainSnapshotCurrent
            from libvirtmod import virDomainSnapshotDelete
            from libvirtmod import virDomainSnapshotGetXMLDesc
            from libvirtmod import virDomainSnapshotLookupByName
        except:
            raise KaresansuiVirtSnapshotException(_("Snapshot is not supported by this version of libvirt"))
        self.error_msg = []


    def __del__(self):
        self.finish()

    def __prep(self):
        self.logger = logging.getLogger('karesansui.virt.snapshot')

    def finish(self):
        try:
            self.kvc.close()
        except:
            pass

    def append_error_msg(self,string):
        self.error_msg.append(string)

    def reset_error_msg(self):
        self.error_msg = []

    def generateXML(self, doc):
        out = StringIO()
        out.write(doc,toxml())
        return out.getvalue()

    def isSupportedDomain(self,domain=None):
        retval = True

        inactives = self.kvc.list_inactive_guest()
        actives   = self.kvc.list_active_guest()

        if domain is not None:
            if domain in inactives + actives:
                guest = self.kvc.search_guests(domain)[0]

                param = ConfigParam(domain)
                param.load_xml_config(guest.XMLDesc(1))

                for info in param.disks:
                    """
                    { 'bus'        :'ide',
                      'device'     :'disk',
                      'disk_type'  :'file',
                      'driver_name':'qemu',
                      'driver_type':'qcow2',
                      'path'       :'/path/to/disk_image.img',
                      'target'     :'hda'}
                    """
                    try:
                        if info['driver_type'] == "qcow2":
                            pass
                        elif info['device'] == "cdrom":
                            pass
                        else:
                            if info['disk_type'] != "block":
                                self.append_error_msg(_("%s: unsupported image format %s") % (info['target'],info['driver_type']))
                                retval = False
                                #break
                    except:
                        retval = False
                        #break
            else:
                retval = False

        return retval

    def _snapshotListNames(self,domain=None):
        retval = []

        if domain is not None:
            for xml_path in glob.glob("%s/%s/*.xml" % (VIRT_SNAPSHOT_DIR,domain,)):
                retval.append(os.path.basename(xml_path)[0:-4])

        return retval

    def listNames(self,domain=None,all=False):
        retval = {}

        inactives = self.kvc.list_inactive_guest()
        actives   = self.kvc.list_active_guest()

        if domain is None:
            for domname in inactives + actives:
                if all is True:
                    names = self._snapshotListNames(domname)
                else:
                    guest = self.kvc.search_guests(domname)[0]
                    names = guest.snapshotListNames(0)
                retval[domname] = names
        else:
            if domain in inactives + actives:
                if all is True:
                    names = self._snapshotListNames(domain)
                else:
                    guest = self.kvc.search_guests(domain)[0]
                    names = guest.snapshotListNames(0)
                retval[domain] = names
            else:
                pass

        return retval

    def listNum(self,domain=None,all=False):
        retval = 0

        inactives = self.kvc.list_inactive_guest()
        actives   = self.kvc.list_active_guest()

        if domain is not None:
            if domain in inactives + actives:
                if all is True:
                    names = self._snapshotListNames(domain)
                    retval = len(names)
                else:
                    guest = self.kvc.search_guests(domain)[0]
                    retval = guest.snapshotNum(0)
            else:
                pass

        return retval

    def whichDomain(self,name):
        retval = []

        try:
            for domain,names in self.listNames().iteritems():
                if name in names:
                    retval.append(domain)
        except:
            pass

        return retval

    def lookupByName(self,name,domain=None):
        retval = False

        if domain is None:
            domains = self.whichDomain(name)
            if len(domains) != 0:
                domain = domains[0]

        if domain is not None:
            guest = self.kvc.search_guests(domain)[0]
            retval = libvirtmod.virDomainSnapshotLookupByName(guest._o, name, 0)

        return retval

    """
    # 親スナップショットなし
    <domainsnapshot>
      <name>1271408851</name>
      <state>running</state>
      <creationTime>1271408851</creationTime>
      <domain>
        <uuid>7833e0a3-f45e-0528-3745-f5d60bf31bd5</uuid>
      </domain>
    </domainsnapshot>

    # 親スナップショットあり
    <domainsnapshot>
      <name>1271409890</name>
      <state>running</state>
      <parent>
        <name>1271408851</name>
      </parent>
      <creationTime>1271409890</creationTime>
      <domain>
        <uuid>7833e0a3-f45e-0528-3745-f5d60bf31bd5</uuid>
      </domain>
    </domainsnapshot>
    """
    def getXMLDesc(self,name,domain=None,flag=True):
        retval = None

        snapshot = self.lookupByName(name,domain=domain)
        if snapshot is not False:

            if flag is True:
                xml_path = self.getSnapshotXMLPath(name,domain=domain)
                if os.path.exists(xml_path):
                    retval = open(xml_path).read()

            if retval is None:
                retval = libvirtmod.virDomainSnapshotGetXMLDesc(snapshot, 0)
                if retval is False:
                    retval = None

        return retval

    def getSnapshotXMLPath(self,name,domain=None):
        retval = None

        try:
            if domain is None:
                domains = self.whichDomain(name)
                if len(domains) != 0:
                    domain = domains[0]

            xml_path = "%s/%s/%s.xml" % (VIRT_SNAPSHOT_DIR,domain,name,)
            if os.path.exists(xml_path):
                retval = xml_path
        except:
            pass

        return retval

    def getSnapshotInfo(self,name,domain=None):
        retval = {}

        xml = self.getXMLDesc(name,domain=domain)
        if xml is not None:

            doc = XMLParse(xml)
            name         = XMLXpath(doc, '/domainsnapshot/name/text()')
            state        = XMLXpath(doc, '/domainsnapshot/state/text()')
            parent_name  = XMLXpath(doc, '/domainsnapshot/parent/name/text()')
            creationTime = XMLXpath(doc, '/domainsnapshot/creationTime/text()')
            domain_uuid  = XMLXpath(doc, '/domainsnapshot/domain/uuid/text()')

            retval['name']         = name
            retval['state']        = state
            retval['parent_name']  = parent_name
            retval['creationTime'] = creationTime
            retval['domain_uuid']  = domain_uuid
            if domain_uuid is not None:
                for guests in self.kvc.search_guests():
                    if domain_uuid == guests.UUIDString():
                        retval['domain_name']  = guests.name()
            try:
                retval['domain_name']
            except:
                domains  = self.whichDomain(name)
                if len(domains) != 0:
                    retval['domain_name']  = domains[0]

        return retval

    def getParentName(self,name,domain=None):
        retval = None

        info = self.getSnapshotInfo(name,domain=domain)
        if info is not False:
            try:
               retval = info['parent_name']
            except:
               pass

        return retval

    def getChildrenNames(self,name,domain=None):
        retval = []

        names = self.listNames()
        try:
            for _domain,_names in names.iteritems():
                for _name in _names:
                    if domain == _domain and _name != name and self.getParentName(_name,domain=_domain) == name:
                        retval.append(_name)
        except:
            pass

        return retval

    def hasCurrentSnapshot(self,domain=None):
        retval = False

        inactives = self.kvc.list_inactive_guest()
        actives   = self.kvc.list_active_guest()

        if domain is not None:
            if domain in inactives + actives:
                guest = self.kvc.search_guests(domain)[0]
                ret = guest.hasCurrentSnapshot(0)
                if ret != 0:
                    retval = True
            else:
                pass

        return retval


    def getCurrentSnapshotXMLDesc(self,domain=None):
        retval = False

        if domain is not None:
            has_current = self.hasCurrentSnapshot(domain)
            if has_current is True:
                guest = self.kvc.search_guests(domain)[0]
                snapshot = libvirtmod.virDomainSnapshotCurrent(guest._o,0)
                if snapshot is not False:
                    retval = libvirtmod.virDomainSnapshotGetXMLDesc(snapshot, 0)

        return retval

    def getCurrentSnapshotName(self,domain=None,force=True):
        retval = False

        if domain is not None:
            xml = self.getCurrentSnapshotXMLDesc(domain)
            if xml is not False:
                doc = XMLParse(xml)
                retval = XMLXpath(doc, '/domainsnapshot/name/text()')

            # 取得できなければ、domainのXMLファイルから取得
            else:
                if force is True:
                    xml_path = "%s/%s.xml" %(VIRT_XML_CONFIG_DIR,domain,)
                    if os.path.exists(xml_path):
                        try:
                            doc = XMLParse(xml_path)
                            retval = XMLXpath(doc, '/domain/currentSnapshot/text()')
                        except:
                            pass

        return retval

    def getCurrentSnapshotInfo(self,domain=None):
        retval = False

        if domain is not None:
            name = self.getCurrentSnapshotName(domain)
            if name is not False:
                retval = self.getSnapshotInfo(name,domain=domain)

        return retval

    def createSnapshot(self, domain=None, xmlDesc=None):
        retval = False

        if domain is not None:
            parent_snapshot_name = self.getCurrentSnapshotName(domain)

            if xmlDesc is None:
                xml = "<domainsnapshot/>"

            else: # validate xml file
                try:
                    doc = XMLParse(xmlDesc)
                    name = XMLXpath(doc, '/domainsnapshot/name/text()')
                    if name is not None:
                        xml = xmlDesc
                except:
                    pass
            try:
                xml
                guest = self.kvc.search_guests(domain)[0]
                snapshot = libvirtmod.virDomainSnapshotCreateXML(guest._o,xml,0)
                if snapshot is not False:
                    retval = libvirtmod.virDomainSnapshotGetXMLDesc(snapshot, 0)
            except:
                pass

        if retval is not False:
            kvg_guest = self.kvc.search_kvg_guests(domain)[0]
            id = self.getCurrentSnapshotName(domain)
            kvg_guest.set_current_snapshot(id)

            # ここにsnapshotのxmlファイルに親のsnapshotの情報を書き込む処理
            try:
                xml_path = self.getSnapshotXMLPath(id)

                # <parent/>が設定されてない場合
                # かつ、snapshot実行前に<currentSnapshot/>が設定されていた場合
                if self.getParentName(id) is None and parent_snapshot_name is not None:
                    if os.path.exists(xml_path):
                        doc = XMLParse(xml_path)
                        parent = doc.createElement("parent")
                        name   = doc.createElement("name")
                        txt = doc.createTextNode(str(parent_snapshot_name))
                        name.appendChild(txt)
                        parent.appendChild(name)
                        doc.childNodes[0].appendChild(parent)
                        xmlDesc = self.generateXML(doc)

                        ConfigFile(xml_path).write(xmlDesc)

                if os.path.exists(xml_path):
                    if os.getuid() == 0:
                        r_chgrp(xml_path,KARESANSUI_GROUP)
                        r_chmod(xml_path,"g+rw")
                        r_chmod(xml_path,"o-rwx")
            except:
                pass

        return retval

    def deleteSnapshot(self, name, domain=None):
        retval = False

        snapshot = self.lookupByName(name,domain=domain)
        if snapshot is not False:

            if domain is None:
                domains = self.whichDomain(name)
                if len(domains) != 0:
                    domain = domains[0]

            retval = libvirtmod.virDomainSnapshotDelete(snapshot, 0)

        if retval is not False:
            kvg_guest = self.kvc.search_kvg_guests(domain)[0]
            id = self.getCurrentSnapshotName(domain)
            kvg_guest.set_current_snapshot(id)

        return retval

    def revertSnapshot(self, name, domain=None):
        retval = False

        snapshot = self.lookupByName(name,domain=domain)
        if snapshot is not False:

            if domain is None:
                domains = self.whichDomain(name)
                if len(domains) != 0:
                    domain = domains[0]

            kvg_guest = self.kvc.search_kvg_guests(domain)[0]

            guest = kvg_guest._conn.lookupByName(domain)
            retval = libvirtmod.virDomainRevertToSnapshot(guest,snapshot, 0)

        if retval is not False:
            id = self.getCurrentSnapshotName(domain)
            kvg_guest.set_current_snapshot(id)

        return retval

    def refreshSnapshot(self):
        from karesansui.lib.utils import execute_command

        inactives = self.kvc.list_inactive_guest()
        actives   = self.kvc.list_active_guest()

        do_refresh = False
        for domname in inactives + actives:
            all_num    = self.listNum(domain=domname,all=True)
            active_num = self.listNum(domain=domname,all=False)
            if all_num > 0 and active_num == 0:
                do_refresh = True

        # 差分があれば実行
        if do_refresh is True:
            command = "/etc/init.d/libvirtd restart"
            command_args = command.split(" ")
            (rc,res) = execute_command(command_args)
            pass

        return True

if __name__ == '__main__':
    """Testing
    """

    kvs = KaresansuiVirtSnapshot()

    """
    names = kvs.listNames()

    for _k,_v in names.iteritems():
        for _k2 in _v:
            print kvs.whichDomain(_k2)
            print kvs.lookupByName(_k2)
            print kvs.getXMLDesc(_k2)
            preprint_r(kvs.getSnapshotInfo(_k2))

        has_current = kvs.hasCurrentSnapshot(_k)
        if has_current is False:
            print "domain %s does not have current snapshot." % (_k,)
        else:
            print "domain %s has current snapshot." % (_k,)
            print kvs.getCurrentSnapshotXMLDesc(_k)
            preprint_r(kvs.getCurrentSnapshotInfo(_k))

    #print "createSnapshot"
    #print kvs.createSnapshot('guest1')
    #print kvs.revertSnapshot('1271409890')
    print kvs.isSupportedDomain('guest1')
    print kvs.isSupportedDomain('guest2')

    print kvs.getParentName('1271409890')
    print kvs.getChildrenNames('1271409890')

    print kvs.getCurrentSnapshotName("guest2")
    xml_path = kvs.getSnapshotXMLPath("1274174139")
    if os.path.exists(xml_path):
        dom = XMLParse(xml_path)
        parent = dom.createElement("parent")
        name   = dom.createElement("name")
        txt = dom.createTextNode("hoge")
        name.appendChild(txt)
        parent.appendChild(name)
        dom.childNodes[0].appendChild(parent)
        xmlDesc = kvs.generateXML(dom)
        print xmlDesc

    id = u'1274235845'
    print kvs.getSnapshotXMLPath(id)
    print kvs.getXMLDesc(id)

    id = '1274235848'
    id = '1274235841'
    for domain in kvs.whichDomain(id):
        print kvs.getSnapshotXMLPath(id,domain=domain)
        print kvs.getXMLDesc(id,domain=domain)
        print kvs.getChildrenNames(id,domain=domain)
    """

    names = kvs.listNames()
    preprint_r(names)
    names = kvs.listNames(all=True)
    preprint_r(names)

    kvs.refreshSnapshot()

    kvs.finish()

########NEW FILE########
__FILENAME__ = virt
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

""" 
<comment-ja>
仮想化全般のライブラリ群
</comment-ja>
<comment-en>
</comment-en>

@file:   virt.py

@author: Taizo ITO <taizo@karesansui-project.info>

@copyright:    

"""

import sys
import string
import os, os.path
import time
import tempfile
import re
import libvirt
import libvirtmod
import logging
import glob

# define
from libvirt import VIR_DOMAIN_NOSTATE,VIR_DOMAIN_RUNNING,\
     VIR_DOMAIN_BLOCKED,VIR_DOMAIN_PAUSED,VIR_DOMAIN_SHUTDOWN,\
     VIR_DOMAIN_SHUTOFF,VIR_DOMAIN_CRASHED,\
     VIR_STORAGE_POOL_DELETE_NORMAL,\
     VIR_STORAGE_POOL_DELETE_ZEROED, \
     VIR_STORAGE_VOL_DELETE_NORMAL, \
     VIR_STORAGE_VOL_DELETE_ZEROED, \
     VIR_DOMAIN_XML_SECURE, \
     VIR_DOMAIN_XML_INACTIVE, \
     VIR_DOMAIN_XML_UPDATE_CPU

if __name__ == '__main__':
    for y in [os.path.abspath(os.path.dirname(os.path.abspath(__file__))+"/../../.."),"/usr/lib/python2.6","/usr/lib/python2.6/site-packages"]:
        if (y in sys.path) is False: sys.path.insert(0, y)

import karesansui
import karesansui.lib.locale

from karesansui.lib.const import VIRT_LIBVIRT_DATA_DIR, VIRT_DOMAINS_DIR, \
     VIRT_XML_CONFIG_DIR, VIRT_NETWORK_CONFIG_DIR, VIRT_SNAPSHOT_DIR, \
     VIRT_XENDOMAINS_AUTO_DIR, VIRT_AUTOSTART_CONFIG_DIR, \
     KARESANSUI_GROUP, GRAPHICS_PORT_MIN_NUMBER, PORT_MAX_NUMBER, \
     DEFAULT_KEYMAP, VIRT_STORAGE_CONFIG_DIR, \
     DEFAULT_KVM_DISK_FORMAT, DEFAULT_XEN_DISK_FORMAT, \
     DISK_USES, GUEST_EXPORT_FILE, KVM_BUS_TYPES, XEN_BUS_TYPES, \
     VENDOR_DATA_ISCSI_DOMAINS_DIR, ISCSI_DEVICE_DIR

from karesansui.lib.const import XEN_VIRT_CONFIG_DIR, \
     XEN_VIRTUAL_DISK_PREFIX, \
     XEN_VIRT_URI_RW, XEN_VIRT_URI_RO, \
     XEN_KARESANSUI_TMP_DIR, \
     XEN_KEYMAP_DIR

from karesansui.lib.const import KVM_VIRT_CONFIG_DIR, \
     KVM_VIRTUAL_DISK_PREFIX, \
     KVM_VIRT_URI_RW, KVM_VIRT_URI_RO, \
     KVM_KARESANSUI_TMP_DIR, \
     KVM_KEYMAP_DIR

from karesansui.lib.virt.config import ConfigParam, \
     XMLConfigGenerator, sync_config_generator, KaresansuiConfigParamException

from karesansui.lib.virt.config_network import NetworkConfigParam
from karesansui.lib.virt.config_network import NetworkXMLConfigGenerator

from karesansui.lib.virt.config_storage import StorageVolumeConfigParam, \
     StorageVolumeXMLConfigGenerator, StoragePoolConfigParam, \
     StoragePoolXMLConfigGenerator

from karesansui.lib.virt.config_export import ExportConfigParam, ExportXMLGenerator

from karesansui.lib.virt.config_capabilities import CapabilitiesConfigParam

from karesansui.lib.utils import uniq_sort            as UniqSort
from karesansui.lib.utils import generate_mac_address as GenMAC
from karesansui.lib.utils import execute_command      as ExecCmd
from karesansui.lib.utils import string_from_uuid     as StrFromUUID
from karesansui.lib.utils import generate_uuid        as GenUUID
from karesansui.lib.utils import next_number          as NextNumber
from karesansui.lib.utils import create_disk_img      as MakeDiskImage
from karesansui.lib.utils import copy_file            as CopyFile
from karesansui.lib.net.http import wget              as DownloadFile
from karesansui.lib.utils import is_uuid, get_ifconfig_info, r_chgrp, r_chmod, \
  getfilesize_str, get_filesize_MB, get_disk_img_info, available_virt_uris, \
  is_iso9660_filesystem_format, is_windows_bootable_iso, is_darwin_bootable_iso, \
  file_contents_replace, uri_split, uri_join

from karesansui.lib.utils import get_inspect_stack

from karesansui.lib.file.configfile import ConfigFile


os.environ['LIBVIRT_XM_CONFIG_DIR'] = XEN_VIRT_CONFIG_DIR

class KaresansuiVirtException(karesansui.KaresansuiLibException):
    pass

class KaresansuiVirtConnection:

    def __init__(self,uri=None,readonly=True):
        self.__prep()
        self.logger.debug(get_inspect_stack())
        try:
            self.open(uri,readonly)
        except:
            raise KaresansuiVirtException(_("Cannot open '%s'") % uri)

        self.__prep2()

    def __prep(self):
        """
        <comment-ja>
        デフォルトのストレージを作成します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        if not os.path.exists(VIRT_DOMAINS_DIR):
          os.makedirs(VIRT_DOMAINS_DIR)
        if not os.path.exists(VIRT_XML_CONFIG_DIR):
          os.makedirs(VIRT_XML_CONFIG_DIR)
        self.logger = logging.getLogger('karesansui.virt')
        if os.getuid() == 0:
            r_chgrp(VIRT_LIBVIRT_DATA_DIR,KARESANSUI_GROUP)
            r_chmod(VIRT_DOMAINS_DIR,"o-rwx")

    def __prep2(self):
        try:
            if not os.path.exists(self.config_dir):
                os.makedirs(self.config_dir)
            self.logger = logging.getLogger('karesansui.virt')
            if os.getuid() == 0:
                r_chgrp(self.config_dir,KARESANSUI_GROUP)
        except:
            pass

    def open(self, uri,readonly=True):
        """
        <comment-ja>
        libvirtのコネクションをOpenします。またそれに伴う初期化も行います。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        if uri == None:
            uris = available_virt_uris()
            try:
                uri = uris["KVM"]
            except:
                try:
                    uri = uris["XEN"]
                except:
                    raise KaresansuiVirtException("Error: You must specify connect uri.")

        if uri.lower()[0:3] == "xen":
            self.disk_prefix = XEN_VIRTUAL_DISK_PREFIX
            self.config_dir  = XEN_VIRT_CONFIG_DIR
            self.bus_types   = XEN_BUS_TYPES

            if not os.access("/proc/xen", os.R_OK):
                raise KaresansuiVirtException("Error: The system is not running under Xen kernel.")

        if uri.lower()[0:4] == "qemu":
            self.disk_prefix = KVM_VIRTUAL_DISK_PREFIX
            self.config_dir  = KVM_VIRT_CONFIG_DIR
            self.bus_types   = KVM_BUS_TYPES

            if False == True:
                raise KaresansuiVirtException("Error: The system is not running under KVM hypervisor.")

        if uri != None:
            self.uri = uri

        self.logger.debug('uid=%d' % os.getuid())
        self.logger.debug('gid=%d' % os.getgid())
        
        try:
            """
            if readonly == True:
                self.logger.info('libvirt.openReadOnly - %s' % self.uri)
                self._conn = libvirt.openReadOnly(self.uri)
            else:
                self.logger.info('libvirt.open - %s' % self.uri)
                self._conn = libvirt.open(self.uri)
            """
            self.logger.debug('libvirt.open - %s' % self.uri)
            self._conn = libvirt.open(self.uri)
        except:
            self.logger.error('failed to libvirt open - %s' % self.uri)

        self.logger.debug('succeed to libvirt open - %s' % self.uri)
        self.logger.debug('hypervisor_type - %s' % self.get_hypervisor_type())

        self.guest = KaresansuiVirtGuest(self)
        self.network = KaresansuiVirtNetwork(self)
        self.storage_volume = KaresansuiVirtStorageVolume(self)
        self.storage_pool = KaresansuiVirtStoragePool(self)
        return self._conn

    def close(self, conn=None):
        """
        <comment-ja>
        libvirtなどの仮想化コネクションをCloseします。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        self.logger.debug(get_inspect_stack())
        if conn == None:
            try:
                conn = self._conn
            except NameError:
                pass
        if conn != None:
            conn.__del__()
            self.logger.debug('succeed to libvirt close - %s' % self.uri)

    def get_hypervisor_type(self):
        """<comment-ja>
        使用中のハイパーバイザーの種類を取得する。
        @param void
        @return: hypervisor type
                 Xen or QEMU is available now (depend on libvirt API)
                 e.g. Xen QEMU Test LXC phyp OpenVZ VBox UML ONE ESX
                      XenAPI Remote
        @rtype: string (see examples in previous field '@return')
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        return self._conn.getType()

    def get_capabilities(self):
        retval = {}
        param = CapabilitiesConfigParam()
        try:
            param.load_xml_config(self._conn.getCapabilities())
            retval = {
               "host" :param.host,
               "guest":param.guest,
             }
        except:
            pass
        return retval

    def get_version(self):
        """
        <comment-ja>
        libvirtのバージョン情報を取得します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        hypervisior = self.get_hypervisior_type()
        ret = libvirtmod.virGetVersion(hypervisior)
        libVersion = ret[0]
        apiVersion = ret[1]

        libVersion_major = libVersion / 1000000
        libVersion %= 1000000
        libVersion_minor = libVersion / 1000
        libVersion_rel = libVersion % 1000
        #print "Using library: libvir %d.%d.%d" %(libVersion_major, libVersion_minor, libVersion_rel)

        apiVersion_major = apiVersion / 1000000
        apiVersion %= 1000000
        apiVersion_minor = apiVersion / 1000
        apiVersion_rel = apiVersion % 1000
        #print "Using API: %s %d.%d.%d" %(hypervisior, apiVersion_major, apiVersion_minor, apiVersion_rel)

        return { "libVersion"  : "%d.%d.%d" %(libVersion_major, libVersion_minor, libVersion_rel),
                 "apiVersion"  : "%s %d.%d.%d" %(hypervisior, apiVersion_major, apiVersion_minor, apiVersion_rel)
               }

    def get_nodeinfo(self):
        info = dict()
        data = self._conn.getInfo()
        info = {
            "model"        : data[0],
            "memory"       : data[1],
            "cpus"         : data[2],
            "mhz"          : data[3],
            "nodes"        : data[4],
            "sockets"      : data[5],
            "cores"        : data[6],
            "threads"      : data[7]
        }
        return info

    def get_mem_info(self):
        """<comment-ja>
        メモリの情報を取得する。
         - guest_alloc_mem: ゲストOSに割り当てているメモリサイズ,
         - host_max_mem: ホストOSのメモリサイズ,
         - host_free_mem: ホストOSの未割り当てメモリサイズ
         - 単位はMB
        @rtype: dict
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        active_guests = self.list_active_guest()
        inactive_guests = self.list_inactive_guest()
        info = self.get_nodeinfo()
        host_max_mem = info['memory']

        guest_alloc_mem = 0
        
        for domname in active_guests + inactive_guests:
            if not domname == "Domain-0":
                virt = self.search_kvg_guests(domname)[0]
                info = virt.get_info()
                guest_alloc_mem += int(info["maxMem"])
                
        guest_alloc_mem /= 1000  # a unit 'MB'

        host_free_mem = host_max_mem - guest_alloc_mem
        if host_free_mem < 0: host_free_mem = 0

        info = {
            'guest_alloc_mem' : guest_alloc_mem,
            'host_max_mem' : host_max_mem,
            'host_free_mem' : host_free_mem,
        }
        return info

    def is_max_vcpus(self, type=None):
        """<comment-ja>
        ゲストに割り当て可能な仮想CPU数の最大値を取得できるか。

        @param type: ハイパーバイザー
        @return: the maximum number of virtual CPUs supported for a
          guest VM of a specific type.
        @rtype: bool
        </comment-ja>
        <comment-en>
        Get the maximum number of vcpu supported for guest.

        @param type: type of hypervisor
        @return: the maximum number of vcpus
        @rtype: bool
        </comment-en>
        """
        if type is None:
            type = self.get_hypervisor_type()
        try:
            max = self._conn.getMaxVcpus(type.lower())
            return True
        except libvirt.libvirtError:
            return False

    def get_max_vcpus(self, type=None):
        """<comment-ja>
        ゲストに割り当て可能な仮想CPU数の最大値を取得する

        @param type: ハイパーバイザー
        @return: the maximum number of virtual CPUs supported for a
          guest VM of a specific type.
        @rtype: integer
        </comment-ja>
        <comment-en>
        Get the maximum number of vcpu supported for guest.

        @param type: type of hypervisor
        @return: the maximum number of vcpus
        @rtype: integer
        </comment-en>
        """
        if type is None:
            type = self.get_hypervisor_type()
        try:
            max = self._conn.getMaxVcpus(type.lower())
        except libvirt.libvirtError:
            max = 32
        return max

    def get_physical_cpus(self):
        """<comment-ja>
        物理CPU数を取得する

        @return: 物理CPU数
        @rtype: integer
        </comment-ja>
        <comment-en>
        Get the number of phisical CPUs.

        @return: the number of physical CPUs
        @rtype: integer
        </comment-en>
        """
        info = self.get_nodeinfo()
        return info['nodes'] * info['sockets'] * info['cores'] * info['threads']

    """
    Domain-U
    """
    def set_domain_name(self,name=None):
        self.guest.set_domain_name(name)
    def get_domain_name(self):
        return self.guest.get_domain_name()

    def uuid_to_domname(self, uuid):
        """
        <comment-ja>
        ゲストOSのUUIDからドメイン名を取得します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        try:
            #guest = self._conn.lookupByUUIDString(uuid)
            #return guest.name()
            for guests in self.search_guests():
                if uuid == guests.UUIDString():
                    return guests.name()
        except:
            return ''

    def domname_to_uuid(self, domname):
        """
        <comment-ja>
        ドメイン名からゲストOSのUUIDを取得します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        try:
            return self.search_guests(domname)[0].UUIDString()
        except:
            return ''


    def list_inactive_guest(self,type=None):
        """
        <comment-ja>
        現在起動していないゲストOSを取得します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        if type == "uuid":
            return self._conn.listDefinedDomains()
        else:
            return self._conn.listDefinedDomains()

    def list_active_guest(self,type=None):
        """
        <comment-ja>
        現在起動しているゲストOSを取得します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        names = []
        for id in self._conn.listDomainsID():
            dom = self._conn.lookupByID(id);
            if type == "uuid":
                names.append(dom.UUIDString())
            else:
                names.append(dom.name())
        return names

    def search_guests(self, name=None):
        """
        <comment-ja>
        ドメイン名からゲストOSを検索します。
        </comment-ja>
        <comment-en>
        </comment-en>
        """
        guests = []

        if is_uuid(name):
            name = self.uuid_to_domname(name)

        try:
            guests = self.result_search_guests
        except:
            ids = self._conn.listDomainsID()
            for id in ids:
                if self._conn.lookupByID(id).name() == "Domain-0" and self.get_hypervisor_type() == 'Xen':
                    continue
                guests.append(self._conn.lookupByID(id))
            names = self.list_inactive_guest()
            for _name in names:
                guests.append(self._conn.lookupByName(_name))
            self.result_search_guests = guests

        if name == None:
            return guests

        for guest in guests:
            if guest.name() == name:
                return [guest]

        #return []
        raise KaresansuiVirtException("guest %s not found" % name)

    def search_kvg_guests(self, name=None):
        """<comment-ja>
        指定されたゲストOSオブジェクトをKaresansuiVirtGuestオブジェクトのlistにして返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        if is_uuid(name):
            name = self.uuid_to_domname(name)

        guests = []
        for guest in self.search_guests(name):
            guests.append(
                KaresansuiVirtGuest(conn=self, name=guest.name()))

        return guests

    def list_used_graphics_port(self):
        """
        <comment-ja>
        すでにシステムで利用しているグラフィックスのポート番号を取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        ports = []
        for guest in self.search_guests(None):

            param = ConfigParam(guest.name())
            xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, guest.name())
            dom = self._conn.lookupByName(guest.name())
            if not os.path.exists(xml_file):
                if dom._conn.getURI() in available_virt_uris().values():
                    ConfigFile(xml_file).write(dom.XMLDesc(0))
                    if os.getuid() == 0 and os.path.exists(xml_file):
                        r_chgrp(xml_file,KARESANSUI_GROUP)
            #param.load_xml_config(xml_file)
            param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

            graphics_port = param.graphics_port
            if graphics_port and int(graphics_port) > 0:
                ports.append(int(graphics_port))

        return UniqSort(ports)

    def list_used_mac_addr(self):
        """
        <comment-ja>
        すでにシステムで利用しているMAC Addressを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        addrs = []
        for guest in self.search_guests(None):

            param = ConfigParam(guest.name())
            xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, guest.name())
            dom = self._conn.lookupByName(guest.name())
            if not os.path.exists(xml_file):
                if dom._conn.getURI() in available_virt_uris().values():
                    ConfigFile(xml_file).write(dom.XMLDesc(0))
                    if os.getuid() == 0 and os.path.exists(xml_file):
                        r_chgrp(xml_file,KARESANSUI_GROUP)
            #param.load_xml_config(xml_file)
            param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

            for info in param.interfaces:
                mac_addr = info['mac']
                addrs.append(mac_addr.lower())

        return addrs

    def set_interface_format(self, format=None):
        """
        <comment-ja>
        TODO:
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """

        if format is None:
            format = "b:xenbr0"

        self.interface_format = []
        for _format in format.split(','):
            (type, name) = _format.split(':')
            if type[0] == 'n':
                try:
                    netinfo = self.search_kvn_networks(name)[0].get_info()
                    self.interface_format.append( {"type": "bridge", "name":netinfo['bridge']['name']} )
                except:
                    raise
            else:
                self.interface_format.append( {"type": "bridge", "name":name} )

    def make_domain_dir(self, dir, name):
        """
        <comment-ja>
        'dir'(Storage Pool)で構成されたゲスト用ディレクトリ構成を作成します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        # domain dir
        domain_dir = "%s/%s" % (dir, name,)
        domain_images_dir   = "%s/images"   % (domain_dir,)
        domain_boot_dir     = "%s/boot"     % (domain_dir,)
        domain_disk_dir     = "%s/disk"     % (domain_dir,)
        # < 2.0.0
        #domain_snapshot_dir = "%s/snapshot" % (domain_dir,)

        if not os.path.exists(domain_dir):
            os.makedirs(domain_dir)
        if not os.path.exists(domain_images_dir):
            os.makedirs(domain_images_dir)
        if not os.path.exists(domain_boot_dir):
            os.makedirs(domain_boot_dir)
        if not os.path.exists(domain_disk_dir):
            os.makedirs(domain_disk_dir)
        #if not os.path.exists(domain_snapshot_dir):
        #    os.makedirs(domain_snapshot_dir)
        if os.getuid() == 0:
            r_chgrp(domain_dir,KARESANSUI_GROUP)
            r_chmod(domain_dir,"o-rwx")

        return domain_dir

    def create_guest(self, name=None, type="xen", ram=256, disk=None, disksize=1024*16, 
                     mac=None, uuid=None, kernel=None, initrd=None, iso=None, graphics=None,
                     vcpus=None, extra=None, keymap=DEFAULT_KEYMAP,
                     bus=None, disk_format=None,
                     storage_pool=None, storage_volume=None):
        """
        <comment-ja>
        ゲストOSの作成を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        param = ConfigParam(name)

        # Disk
        if type == "kvm" and iso is not None:
            param.add_disk(iso, "hdc", "cdrom") # install iso image

        if bus is not None:
            bus = bus.lower()

        # Pool
        pool_objs = self.search_kvn_storage_pools(storage_pool)
        if not pool_objs:
            raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                              storage_pool)

        pool_type = pool_objs[0].get_info()['type']

        if pool_type == 'iscsi':
            domains_dir = VENDOR_DATA_ISCSI_DOMAINS_DIR
            domain_dir = self.make_domain_dir(VENDOR_DATA_ISCSI_DOMAINS_DIR, name)
        else:
            domains_dir = pool_objs[0].get_info()["target"]["path"]
            domain_dir = self.make_domain_dir(domains_dir, name)


        if pool_type == "iscsi":
            disk_type = "block"
            disk = self.get_storage_volume_path(storage_pool, storage_volume)
        else:
            disk_type = "file"
            #disk = "%s/images/%s.img" % (domain_dir, storage_volume)
            disk = "%s/images/%s.img" % (domain_dir, name)

        if disk is None:
            raise KaresansuiVirtException("%s pool=%s,volume=%s" % \
                                          (_("Storage path could not be retrieved."),
                                           storage_pool,
                                           storage_volume
                                           ))

        driver_type = None
        driver_name = None
        try:
            file_format = get_disk_img_info(disk)['file_format']
            if file_format == "qcow2":
                driver_type = "qcow2"
                if type == "kvm":
                    driver_name = "qemu"
            if type == "kvm":
                driver_type = file_format
        except:
            pass

        if bus == "virtio":
            target_dev_prefix = "vd"
        elif bus == "scsi":
            target_dev_prefix = "sd"
        else:
            target_dev_prefix = self.disk_prefix

        param.add_disk(disk,
                       target_dev_prefix + "a",
                       bus=bus,
                       disk_type=disk_type,
                       driver_name=driver_name,
                       driver_type=driver_type)

        if mac is None:
            mac = GenMAC()

        if uuid is None:
            uuid = StrFromUUID(GenUUID())

        if vcpus is None:
            vcpus = 1

        if graphics is None:
            used_ports = self.list_used_graphics_port()
            graphics = NextNumber(GRAPHICS_PORT_MIN_NUMBER,PORT_MAX_NUMBER,used_ports)

#        if os.path.exists(disk):
#            os.unlink(disk)

        param.set_domain_type(type)
        param.set_uuid(uuid)
        if type == "kvm":
            acpi_info_file = "/proc/acpi/info"
            if os.path.exists(acpi_info_file):
                param.set_features_acpi(True)
            if iso is not None:
                param.set_boot_dev("cdrom")
                if is_windows_bootable_iso(iso) is not False:
                    param.set_features_apic(True)
                elif is_darwin_bootable_iso(iso) is not False:
                    param.set_features_apic(True)
            else:
                param.set_kernel(kernel)
                param.set_initrd(initrd)
        else:
            param.set_kernel(kernel)
            param.set_initrd(initrd)

        param.set_max_vcpus(vcpus)
        param.set_memory(str(ram) + 'm')
        param.set_graphics_keymap(keymap)

        # definition for a network interface
        if type == "kvm":
            model = "virtio"
        else:
            model = None
        for _format in self.interface_format:
            if _format['name'][0:5] == 'xenbr':
                script = "vif-bridge"
            else:
                script = None

            if mac is None:
                mac = GenMAC()
                param.add_interface(mac,"bridge",_format['name'],script,model=model)
            else:
                param.add_interface(mac.lower(),"bridge",_format['name'],script,model=model)
                mac = None

        param.set_graphics_port(graphics)
        if extra != None:
            param.append_commandline(extra)
        param.set_behavior("on_shutoff","destroy")
        param.set_behavior("on_reboot","destroy")
        param.set_behavior("on_crash","destroy")

        r = re.compile(r"""(?:ftp|http)s?://""")

        domain_boot_dir = "%s/boot" % (domain_dir,)
        if kernel is not None:
            (kfd, kfn) = tempfile.mkstemp(prefix="vmlinuz.", dir=domain_boot_dir)
            m = r.match(param.get_kernel())
            if m:
              os.close(kfd)
              DownloadFile(param.get_kernel(),kfn)
            else:
              kernel = open(param.get_kernel(),"r")
              os.write(kfd, kernel.read())
              os.close(kfd)
              kernel.close()
            param.set_kernel(kfn)

        if initrd is not None:
            (ifd, ifn) = tempfile.mkstemp(prefix="initrd.img.", dir=domain_boot_dir)
            m = r.match(param.get_initrd())
            if m:
              os.close(ifd)
              DownloadFile(param.get_initrd(),ifn)
            else:
              initrd = open(param.get_initrd(),"r")
              os.write(ifd, initrd.read())
              os.close(ifd)
              initrd.close()
            param.set_initrd(ifn)

        sync_config_generator(param)

        if self._conn is None:
            self._conn = self.open(None)

        generator = XMLConfigGenerator()
        try:
            cfgxml = generator.generate(param)
        except:
            raise

        dom = self._conn.createLinux(cfgxml, 0)
        time.sleep(2)
        self._conn.defineXML(cfgxml)
        time.sleep(1)
        try:
            self._conn.lookupByID(dom.ID())
        except libvirt.libvirtError:
            raise KaresansuiVirtException("create_guest() error. name:%s" % (name))

        if initrd is not None:
            os.unlink(param.get_initrd())

        if kernel is not None:
            os.unlink(param.get_kernel())

        param.set_kernel(None)
        param.set_initrd(None)
        param.cmdline = []
        if type == "xen":
            param.set_bootloader("/usr/bin/pygrub")
        elif type == "kvm":
            param.set_boot_dev("hd")

        if type == "kvm" and iso is not None:
            param.delete_disk("hdc")
        param.set_behavior("on_reboot","restart")
        param.set_behavior("on_crash","restart")

        sync_config_generator(param)

        config = "%s/%s.xml" %(VIRT_XML_CONFIG_DIR,name,)
        if os.path.exists(config):
            f = open(config, "r")
            cfgxml= f.read()
            f.close()
            self._conn.defineXML(cfgxml)

            r_chmod(config,"o-rwx")
            r_chmod(config,"g+rw")
            if os.getuid() == 0:
                r_chgrp(config,KARESANSUI_GROUP)

        try:
            self.search_storage_pools(storage_pool)[0].refresh(0)
        except:
            pass

        return True

    def start_guest(self,name=None):
        """
        <comment-ja>
        ゲストOSの起動を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)

        name = self.guest.get_domain_name()
        config = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR,name,)
        if os.path.exists(config):
            f = open(config, "r")
            cfgxml= f.read()
            f.close()
            self._conn.defineXML(cfgxml)

        self.guest.create()

    def shutdown_guest(self,name=None):
        """
        <comment-ja>
        ゲストOSの停止を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        self.guest.shutdown()

    def reboot_guest(self,name=None):
        """
        <comment-ja>
        ゲストOSを再起動します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        self.guest.reboot()

    def destroy_guest(self,name=None):
        """
        <comment-ja>
        ゲストOSを削除します。(設定ファイルやゲストOS定義は削除されません。)
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        self.guest.destroy()

    def delete_guest(self, name, pool, volume):
        """
        <comment-ja>
        ゲストOSを完全に削除します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        name = self.guest.get_domain_name()
        tmp_pool = self.get_storage_pool_name_bydomain(name, 'os')
        if tmp_pool:
            pool_objs = self.search_kvn_storage_pools(tmp_pool[0])
        else:
            pool_objs = self.search_kvn_storage_pools(pool)

        pool_type = pool_objs[0].get_info()['type']
        if pool_type == 'iscsi':
            domains_dir = VENDOR_DATA_ISCSI_DOMAINS_DIR
            domain_dir = "%s/%s" % (VENDOR_DATA_ISCSI_DOMAINS_DIR, name)
        else:
            domains_dir = self.get_storage_pool_targetpath(pool)
            domain_dir = "%s/%s" % (domains_dir, name)

        vols = self.get_storage_volume_bydomain(name, 'os')
        if vols:
            vol_path = "%s/%s" % (domains_dir, vols.keys()[0])
        else:
            vol_path = "%s/%s" % (domains_dir, volume)

        try:
            self.destroy_guest(name)
        except libvirt.libvirtError, e:
            self.logger.info("Could not remove the guest. - name=%s" % name)

        try:
            self.guest.undefine()
        except:
            self.logger.info("Guests definition could not be removed. - name=%s" % name)

        import shutil
        if os.path.islink(vol_path):
            os.unlink(vol_path)

        if os.path.exists(domain_dir):
            #os.removedirs(domain_dir)
            shutil.rmtree(domain_dir)

        # delete qemu snapshot
        domain_snapshot_dir = "%s/%s" % (VIRT_SNAPSHOT_DIR,name,)
        if os.path.exists(domain_snapshot_dir):
            #os.removedirs(domain_snapshot_dir)
            shutil.rmtree(domain_snapshot_dir)

        if tmp_pool:
            try:
                self.search_storage_pools(tmp_pool[0])[0].refresh(0)
            except:
                pass
        else:
            try:
                self.search_storage_pools(pool)[0].refresh(0)
            except:
                pass

    def suspend_guest(self,name=None):
        """
        <comment-ja>
        起動しているゲストOSを一時停止します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        self.guest.suspend()

    def resume_guest(self,name=None):
        """
        <comment-ja>
        suspendしているゲストOSを復帰させます。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        self.guest.resume()

    def autostart_guest(self,flag=None,name=None):
        """
        <comment-ja>
        ゲストOSの自動起動設定を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        guests = self.search_guests(self.guest.get_domain_name())
        if len(guests):
            return self.guest.autostart(flag)
        else:
            return False

    def replicate_storage_volume(self, orig_domname, orig_pool, orig_volume,
                                 dest_domname, dest_pool, dest_volume,
                                 progresscb=None):
        """<comment-ja>
        ストレージボリュームをコピーします。
        @param orig_domname: コピー元ドメイン名
        @param orig_pool: コピー元ストレージプール名
        @param orig_volume: コピー元ストレージボリューム名
        @param dest_domname: コピー先ドメイン名
        @param dest_pool: コピー先ストレージプール名
        @param dest_volume: コピー先ストレージボリューム名
        @param progresscb: コピー方式
        @return: 実行結果
        </comment-ja>
        <comment-en>
        TODO: English Documents(en)
        </comment-en>
        """
        orig_symlink_path = self.get_storage_volume_iscsi_rpath_bystorage(orig_pool, orig_volume)
        orig_rpath = os.path.realpath(orig_symlink_path)
        if not orig_rpath:
            return False

        # orig
        orig_domains_dir = self.get_storage_pool_targetpath(orig_pool)
        orig_domain_dir = "%s/%s" % (orig_domains_dir, orig_domname)

        # dest
        dest_domains_dir = self.get_storage_pool_targetpath(dest_pool)
        dest_domain_dir = self.make_domain_dir(dest_domains_dir, dest_domname)

        orig_files = [orig_rpath,]
        dest_files = ["%s/disk/%s.img" % (dest_domain_dir, dest_volume),]
        if os.path.isfile(dest_files[0]) is True:
            raise KaresansuiVirtException("Already exists in the destination storage volume.")

        if progresscb is not None:
            from karesansui.lib.utils import copy_file_cb
            copy_file_cb(orig_files, dest_files, progresscb, each=False)
        else:
            CopyFile(orig_files, dest_files)

        # symlink
        os.symlink(dest_files[0], "%s/%s" % (dest_domains_dir, dest_volume))

        # Storage Pool refresh
        try:
            self.search_storage_pools(orig_pool)[0].refresh(0)
            self.search_storage_pools(dest_pool)[0].refresh(0)
        except:
            pass

        return True

    def replicate_guest(self, name, source_name, pool, mac=None, uuid=None, graphics=None):
        """<comment-ja>
        ゲストOSのコピーを行います。
        すべてのディスクがfile形式のみ実行可能です。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        param = ConfigParam(name)

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, source_name)
        dom = self._conn.lookupByName(source_name)
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        autostart = False
        try:
            guest_obj = self.search_kvg_guests(source_name)[0]
            if not guest_obj:
                raise KaresansuiVirtException(_("Domain could not be found. name=%s") % source_name)
            autostart = guest_obj.autostart()
        except:
            pass

        # Source storage pool dir
        src_pool = self.get_storage_pool_name_bydomain(source_name, "os")[0]
        src_target_path = self.get_storage_pool_targetpath(src_pool)
        source_disk = "%s/%s/images/%s.img" \
                      % (src_target_path, source_name,source_name)

        pool_dir = self.get_storage_pool_targetpath(pool)
        disk = "%s/%s/images/%s.img" % (pool_dir, name, name)

        # definition for a network interface
        src_interfaces = param.interfaces
        param.interfaces = []
        for ifs in src_interfaces:
            script = ifs['script']
            try:
                model = ifs['model']
            except:
                model = None
            if mac is None:
                mac = GenMAC()
                param.add_interface(mac,"bridge",ifs['bridge'],script,model=model)
            else:
                param.add_interface(mac.lower(),"bridge",ifs['bridge'],script,model=model)
                mac = None

        if uuid is None:
            uuid = StrFromUUID(GenUUID())

        if graphics is None:
            used_ports = self.list_used_graphics_port()
            graphics = NextNumber(GRAPHICS_PORT_MIN_NUMBER,PORT_MAX_NUMBER,used_ports)

        old_disks = param.disks

        # get further informations of disk used by os.
        bus = None
        driver_name = None
        driver_type = None
        for disk_info in old_disks:
            if disk_info['path'] == source_disk:
                try:
                    bus = disk_info['bus']
                except:
                    bus = None
                try:
                    driver_name = disk_info['driver_name']
                except:
                    driver_name = None
                try:
                    driver_type = disk_info['driver_type']
                except:
                    driver_type = None
                break

        param.disks = []
        param.set_uuid(uuid)
        param.set_graphics_port(graphics)
        param.add_disk(disk,
                       self.disk_prefix + "a",
                       bus=bus,
                       driver_name=driver_name,
                       driver_type=driver_type)

        # dest make dirs
        self.make_domain_dir(pool_dir, name)

        # TODO : boot dir

        # 追加ディスクのコピー
        for _disk in old_disks:
            try:
                s_disk_path   = _disk['path']
                s_disk_target = _disk['target']
                s_disk_bus    = _disk['bus']
                try:
                    s_driver_name = _disk['driver_name']
                except:
                    s_driver_name = None
                try:
                    s_driver_type = _disk['driver_type']
                except:
                    s_driver_type = None

                m = re.search("/domains/%s/disk/(?P<disk_name>[0-9\.]+\.img)$" % source_name ,s_disk_path)
                if m:
                    new_disk_path = "%s/%s/disk/%s" % (pool_dir,name,m.group("disk_name"),)

                    param.add_disk(new_disk_path,
                                   s_disk_target,
                                   "disk",
                                   bus=s_disk_bus,
                                   driver_name=s_driver_name,
                                   driver_type=s_driver_type)

                    if not os.path.exists(new_disk_path):
                        CopyFile(s_disk_path,new_disk_path)
            except:
                pass

        # スナップショットのコピー
        # libvirtdの再起動後に認識される。(qemuDomainSnapshotLoad)
        s_domain_snapshot_dir = "%s/%s" % (VIRT_SNAPSHOT_DIR,source_name,)
        if os.path.exists(s_domain_snapshot_dir):
            domain_snapshot_dir = "%s/%s" % (VIRT_SNAPSHOT_DIR,name,)
            for snapshot_xml in glob.glob("%s/*.xml" % s_domain_snapshot_dir):
                snapshot_xml_name = os.path.basename(snapshot_xml)
                new_snapshot_xml = "%s/%s" % (domain_snapshot_dir,snapshot_xml_name,)
                if not os.path.exists(domain_snapshot_dir):
                    os.makedirs(domain_snapshot_dir)

                old_pattern = "<uuid>.{36}</uuid>"
                new_string  = "<uuid>%s</uuid>" % uuid
                file_contents_replace(snapshot_xml,new_snapshot_xml,old_pattern,new_string)
            if os.getuid() == 0:
                if os.path.exists(domain_snapshot_dir):
                    r_chmod(domain_snapshot_dir,"o-rwx")
                    r_chgrp(domain_snapshot_dir,KARESANSUI_GROUP)

                # This is commented out.
                # cos guests that set to autostart flag will be started without intention.
                #from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
                #kvs = KaresansuiVirtSnapshot()
                #kvs.refreshSnapshot()

        try:
            # ゲストOSイメージのコピー
            CopyFile(source_disk,disk)

            # Storage pool directory, OS image set symlink
            os.symlink(disk,
                       "%s/%s" % (pool_dir, uuid))

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)
        except:
            raise

        sync_config_generator(param, name)

        # set autostart flag
        if autostart is True:
            try:
                guest_obj = self.search_kvg_guests(name)[0]
                if not guest_obj:
                    raise KaresansuiVirtException(_("Domain could not be found. name=%s") % name)
                guest_obj.autostart(flag=autostart)
            except:
                raise KaresansuiVirtException(_("Failed to set autostart flag. - dom=%s flag=%s") % (name,autostart))

        # Storage Pool refresh
        for p in [src_pool, pool]:
            try:
                self.search_storage_pools(p)[0].refresh(0)
            except:
                pass

        return True

    def export_guest(self, uuid, name, directory, database, realicon, title="", snapshots=None, progresscb=None):
        """<comment-ja>
        ゲストOSののエクスポートを行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        #inactive_pools = self.list_inactive_storage_pool()
        inactive_pools = []
        active_pools   = self.list_active_storage_pool()

        pool_name = None
        for _pool in inactive_pools + active_pools:
            path = self.search_kvn_storage_pools(_pool)[0].get_info()["target"]["path"]
            if directory == path:
                pool_name = _pool

        if not os.path.exists(directory):
            raise KaresansuiVirtException(_("Directory '%s' not found.") % directory)

        if not (name is None):
            self.guest.set_domain_name(name)

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, name)
        config_file = "%s/%s" % (self.config_dir, name)

        src_pool = self.get_storage_pool_name_bydomain(name, "os")[0]
        src_path = self.get_storage_pool_targetpath(src_pool)

        domain_dir = "%s/%s" % (src_path,name,)
        image_file = "%s/images/%s.img" % (domain_dir,name)
        domain_snapshot_dir = "%s/%s" % (VIRT_SNAPSHOT_DIR,name,)

        export_dir = "%s/%s" % (directory,uuid)
        #export_domain_dir = "%s/%s" % (export_dir,name)
        export_domain_dir = "%s/domain/%s" % (export_dir,name)
        #export_disk_dir = "%s/%s" % (export_dir,name)
        export_disk_dir = "%s/disk" % (export_dir)

        if os.path.exists(export_domain_dir):
            raise KaresansuiVirtException(_("Directory '%s' found.") % export_domain_dir)

        try:
            if not os.path.exists(export_domain_dir):
                os.makedirs(export_domain_dir)
                if os.getuid() == 0:
                    r_chgrp(export_dir,KARESANSUI_GROUP)
                    r_chmod(export_dir,"o-rwx")

            if not os.path.exists(export_disk_dir):
                os.makedirs(export_disk_dir)
                if os.getuid() == 0:
                    r_chgrp(export_dir,KARESANSUI_GROUP)
                    r_chmod(export_dir,"o-rwx")

            # -----------------------
            # Export information to disk to retrieve.
            disk_keys = self.get_storage_volume_bydomain(
                self.guest.get_domain_name(), 'disk', 'key')

            disks_info = []
            for key in disk_keys.keys():
                _volume = key
                _path = disk_keys[key]
                _pool_name = self.get_storage_pool_name_byimage(_path)

                if not _pool_name:
                    raise KaresansuiVirtException("'%s' disk storage pool can not be found." % _volume)
                else:
                    _pool_name = _pool_name[0]

                _pool = self.search_kvn_storage_pools(_pool_name)
                if not _pool:
                    raise KaresansuiVirtException("'%s' disk storage pool(path) can not be found." % _volume)
                else:
                    _pool = _pool[0]

                _pool_path = _pool.get_info()['target']['path']
                pool_uuid = _pool.get_info()['uuid']

                disks_info.append({"volume" : _volume,
                                   "volume_path" : _path,
                                   "pool_name" : _pool_name,
                                   "domname" : self.guest.get_domain_name(),
                                   "pool_path" : _pool_path,
                                   "pool_uuid" : pool_uuid
                                   })

            # Disk export
            for disk_info in disks_info:
                disk_dir = "%s/%s" % (disk_info["pool_path"], disk_info["domname"])
                if progresscb is not None:
                    from karesansui.lib.utils import copy_file_cb

                    src_files = []
                    dst_files = []
                    for _sub in glob.glob("%s/disk/*" % disk_dir):
                        if os.path.isfile(_sub):
                            # {export uuid}/disk/{pool name}/{domname}/[images|boot|disk]
                            #dst_file = "%s/%s" % (export_disk_dir, os.path.basename(_sub),)
                            dst_file = "%s/%s/%s/disk/%s" % (export_disk_dir,
                                                       disk_info["pool_name"],
                                                       disk_info["domname"],
                                                       os.path.basename(_sub),
                                                       )
                            src_file = _sub
                            src_files.append(src_file)
                            dst_files.append(dst_file)
                    copy_file_cb(src_files,dst_files,progresscb,each=False)
                else:
                    CopyFile(disk_dir, export_disk_dir)

            # -----------------------

            # copy domain image data
            if progresscb is not None:
                from karesansui.lib.utils import copy_file_cb

                src_files = []
                dst_files = []
                # os image
                src_files.append("%s/images/%s.img" % (domain_dir, name))
                dst_files.append("%s/images/%s.img" % (export_domain_dir, name))
                copy_file_cb(src_files,dst_files,progresscb,each=False)

                # boot
                src_files = []
                dst_files = []
                for _sub in glob.glob("%s/boot/*" % domain_dir):
                    if os.path.isfile(_sub) is True:
                        dst_file = "%s/boot/%s" % (export_domain_dir,os.path.basename(_sub),)
                        src_files.append(_sub)
                        dst_files.append(dst_file)

                copy_file_cb(src_files,dst_files,progresscb,each=False)
            else:
                CopyFile(domain_dir,export_domain_dir)

            # copy domain configuration
            export_xml_file    = "%s/%s.xml"  % (export_dir,name,)
            CopyFile(xml_file,   export_xml_file)
            export_config_file = "%s/%s.conf" % (export_dir,name,)
            CopyFile(config_file,export_config_file)

            # copy snapshot xmls
            if os.path.exists(domain_snapshot_dir):
                export_snapshot_dir = "%s/snapshot" % (export_domain_dir,)

                try:
                    os.makedirs(export_snapshot_dir)
                except:
                    pass

                for snapshot_xml in glob.glob("%s/*.xml" % domain_snapshot_dir):
                    snapshot_xml_name = os.path.basename(snapshot_xml)
                    export_snapshot_xml = "%s/%s" % (export_snapshot_dir,snapshot_xml_name,)
                    CopyFile(snapshot_xml,export_snapshot_xml)

            # symlink to recognize as libvirt pool
            export_image_file = "%s/images/%s.img" % (export_domain_dir,name)
            link_file = "%s/%s-%s.img" % (directory,uuid,name,)
            if os.path.exists(link_file) is False:
                os.symlink(export_image_file,link_file)

            # web icon image
            if database['icon']:
                CopyFile(realicon, "%s/%s" % (export_dir, database['icon']))

            # info.dat
            param = ExportConfigParam()

            param.set_path("%s/%s" % (export_dir, GUEST_EXPORT_FILE))
            param.set_uuid(uuid)
            param.set_domain(name)
            param.set_title(title)
            param.set_created(str(int(time.time())))
            param.set_database(database)
            param.set_pool(src_pool)
            param.set_snapshots(snapshots)

            # add_disk
            for disk_info in disks_info:
                param.add_disk(disk_info['volume'],
                               disk_info['pool_name'],
                               disk_info['pool_path'],
                               )

            generator = ExportXMLGenerator(param.get_path())
            try:
                cfgxml = generator.generate(param)
            except:
                raise
            generator.writecfg(cfgxml)

            if os.getuid() == 0:
                r_chgrp(export_dir,KARESANSUI_GROUP)
                r_chmod(export_dir,"o-rwx")

            if pool_name is not None:
                try:
                    self.search_storage_pools(pool_name)[0].refresh(0)
                except:
                    pass

        except:
            raise

    def import_guest(self, directory, uuid, progresscb):
        """
        <comment-ja>
        ゲストOSのインポートを行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not os.path.exists(directory):
            raise KaresansuiVirtException(_("Directory '%s' not found.") % directory)

        export_dir = directory

        # read info.dat
        param = ExportConfigParam()
        info_file = "%s/info.dat" % (export_dir,)
        if os.path.exists(info_file):
            try:
                param.load_xml_config(info_file)
            except:
                raise KaresansuiVirtException(_("'%s' is invalid format.") % info_file)
        else:
            raise KaresansuiVirtException(_("'%s' not found.") % info_file)

        id    = param.get_uuid()
        name  = param.get_domain()
        title = param.get_title()
        created = param.get_created()

        domains_dir = self.get_storage_pool_targetpath(param.get_pool())
        xml_file    = "%s/%s.xml"        % (VIRT_XML_CONFIG_DIR, name)
        config_file = "%s/%s"            % (self.config_dir, name)
        domain_dir  = "%s/%s"            % (domains_dir,name,)
        image_file  = "%s/images/%s.img" % (domain_dir,name)
        domain_snapshot_dir = "%s/%s"    % (VIRT_SNAPSHOT_DIR,name,)

        export_domain_dir   = "%s/domain/%s"       % (export_dir,name,)
        #export_snapshot_dir = "%s/snapshot" % (export_domain_dir,)
        export_snapshot_dir = "%s/snapshot" % (export_domain_dir)

        if not os.path.exists(export_domain_dir):
            raise KaresansuiVirtException(_("Directory '%s' not found.") % export_domain_dir)

        if os.path.exists(domain_dir):
            raise KaresansuiVirtException(_("guest '%s' already exists.") % name)

        try:
            from karesansui.lib.utils import copy_file_cb
            # copy disks {export dir}/{export uuid}/disk/{pool}/{domname}/disk/{disk uuid}.img
            export_disk_dir = "%s/disk" % (export_dir)
            export_disks = param.get_disks()
            src_files = []
            dst_files = []
            dst_symlinks = []
            for disk in export_disks:
                volume = disk['uuid']
                pool_name = disk['name']
                pool_path = disk['path']
                pool = self.search_kvn_storage_pools(pool_name)
                if not pool:
                    raise KaresansuiVirtException(_("Disk storage pools were found to import. - pool=%s") \
                                            % pool_name)
                else:
                    pool = pool[0]

                # check
                if pool_path != pool.get_json()['target']['path']:
                    raise KaresansuiVirtException(_("When exporting, there are differences in the storage pool information. (Storage pool path) = export=%s, import=%s") \
                                            % (pool_path, pool.get_json()['target']['path']))

                src_file = "%s/%s/%s/disk/%s.img" % (export_disk_dir, pool_name, name, volume)
                if os.path.isfile(src_file) is False:
                    raise KaresansuiVirtException(_("Could not find the exported disk image. src_file=%s", src_file))

                dst_file = "%s/%s/disk/%s.img" % (pool.get_json()['target']['path'], name, volume)

                src_files.append(src_file)
                dst_files.append(dst_file)
                dst_symlinks.append("%s/%s" % (pool.get_json()['target']['path'], volume))

            copy_file_cb(src_files,dst_files,progresscb,each=False)
            for i in xrange(len(dst_symlinks)):
                os.symlink(dst_files[i], dst_symlinks[i])


            # copy domain image data
            src_files = []
            dst_files = []
            for _sub in glob.glob("%s/*" % export_domain_dir):
                if os.path.isdir(_sub):
                    dst_dir = "%s/%s" % (domain_dir,os.path.basename(_sub),)
                    for _sub2 in glob.glob("%s/*" % _sub):
                        if os.path.isfile(_sub2):
                            src_file = _sub2
                            dst_file = "%s/%s" % (dst_dir,os.path.basename(_sub2),)
                            src_files.append(src_file)
                            dst_files.append(dst_file)
            copy_file_cb(src_files,dst_files,progresscb,each=False)

            export_xml_file    = "%s/%s.xml"  % (export_dir,name,)
            # os image symlink
            g_param = ConfigParam(name)
            if os.path.isfile(export_xml_file) is False:
                raise KaresansuiVirtException(
                    _("Export data not found. - path=%s" % export_xml_file))
            g_param.load_xml_config(export_xml_file)

            os_image_path = "%s/%s/images/%s.img" % (domains_dir, name, name)
            if os.path.isfile(os_image_path) is False:
                raise KaresansuiVirtException(_("Failed to import guest image. Image not found.- path=%s") \
                                              % os_image_path)
            os.symlink(os_image_path, "%s/%s" % (domains_dir, g_param.uuid))

            # copy domain configuration
            export_config_file = "%s/%s.conf" % (export_dir,name,)
            if uuid is None:
                CopyFile(export_xml_file    ,xml_file)
                CopyFile(export_config_file ,config_file)
            else:
                old_pattern = "<uuid>.{36}</uuid>"
                new_string  = "<uuid>%s</uuid>" % uuid
                file_contents_replace(export_xml_file,xml_file,old_pattern,new_string)
                old_pattern = "^uuid = .*"
                new_string  = "uuid = '%s'" % str(uuid)
                file_contents_replace(export_config_file ,config_file,old_pattern,new_string)

            if os.path.exists(xml_file):
                self._conn.defineXML("".join(ConfigFile(xml_file).read()))

            # copy snapshot xmls
            # libvirtdの再起動後に認識される。(qemuDomainSnapshotLoad)
            if os.path.exists(export_snapshot_dir):

                if not os.path.exists(domain_snapshot_dir):
                    os.makedirs(domain_snapshot_dir)

                for snapshot_xml in glob.glob("%s/*.xml" % export_snapshot_dir):
                    snapshot_xml_name = os.path.basename(snapshot_xml)
                    new_snapshot_xml = "%s/%s" % (domain_snapshot_dir,snapshot_xml_name,)
                    CopyFile(snapshot_xml,new_snapshot_xml)


            if os.getuid() == 0:
                r_chgrp(domain_dir,KARESANSUI_GROUP)
                r_chmod(domain_dir,"o-rwx")
                r_chgrp(xml_file,    KARESANSUI_GROUP)
                r_chgrp(config_file, KARESANSUI_GROUP)
                if os.path.exists(domain_snapshot_dir):
                    r_chmod(domain_snapshot_dir,"o-rwx")
                    r_chgrp(domain_snapshot_dir,KARESANSUI_GROUP)

                # This is commented out.
                # cos guests that set to autostart flag will be started without intention.
                #from karesansui.lib.virt.snapshot import KaresansuiVirtSnapshot
                #kvs = KaresansuiVirtSnapshot()
                #kvs.refreshSnapshot()

            # Storage Pool refresh
            try:
                self.search_storage_pools(param.get_pool())[0].refresh(0)
                for disk in param.get_disks():
                    self.search_storage_pools(disk["name"])[0].refresh(0)
            except:
                pass

        except:
            raise

    def get_hypervisor_type_bydomain(self,name=None):
        """<comment-ja>
        指定ドメインのハイパーバイザーの種類を取得する。
        @param void
        @return: hypervisor type
                 xen or kvm is available now (but depend on domain.xml)
                 e.g. xen kvm hyperv kqemu ldom lxc one openvz phyp qemu test
                      uml vbox vmware vserver
        @rtype: string (lower case only)
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        retval = None

        if not (name is None):
            self.guest.set_domain_name(name)

        try:
            retval = self.guest.get_info()['VMType']
        except libvirt.libvirtError, e:
            pass

        return retval

    """
    Network
    """
    def list_inactive_network(self):
        """
        <comment-ja>
        現在起動していない仮想ネットワークのリストを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        return self._conn.listDefinedNetworks()

    def list_active_network(self):
        """
        <comment-ja>
        現在起動している仮想ネットワークのリストを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        names = []
        for name in self._conn.listNetworks():
            names.append(name)
        return names

    def search_networks(self, name=None):
        """
        <comment-ja>
        仮想ネットワークの検索を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        networks = []

        names = self._conn.listNetworks()
        for __name in names:
            networks.append(self._conn.networkLookupByName(__name))
        names = self.list_inactive_network()
        for __name in names:
            networks.append(self._conn.networkLookupByName(__name))

        if name == None:
            return networks

        regex_regex = re.compile(r"""^regex:(?P<regex>.*)""")
        m = regex_regex.match(name)

        n_networks = []
        for network in networks:
            network_name = network.name()
            if m == None:
                if network_name == name:
                    return [network]
            else:
                regex = m.group('regex')
                query_regex = re.compile(r""+regex+"")
                n = query_regex.search(network_name)
                if n != None:
                    n_networks.append(network)
        if len(n_networks):
            return n_networks

        #return []
        raise KaresansuiVirtException("network %s not found" % name)

    def search_kvn_networks(self, name=None):
        """<comment-ja>
        指定された仮想ネットワークオブジェクトをKaresansuiVirtNetworkオブジェクトのlistにして返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        if is_uuid(name):
            name = self.uuid_to_domname(name)

        networks = []
        for network in self.search_networks(name):
            networks.append(
                KaresansuiVirtNetwork(conn=self, name=network.name()))

        return networks

    def create_network(self, name, cidr, dhcp_start=None, dhcp_end=None, forward=None, bridge=None, autostart=None):
        """
        <comment-ja>
        仮想ネットワークを作成します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        param = NetworkConfigParam(name)
        param.set_default_networks(cidr,dhcp_start,dhcp_end)
        param.set_ipaddr_and_netmask(cidr)
        if forward:
            if 'dev' in forward.keys():
                param.set_forward_dev(forward['dev'])
            if 'mode' in forward.keys():
                param.set_forward_mode(forward['mode'])
        if bridge:
            param.set_bridge(bridge)
        uuid = StrFromUUID(GenUUID())
        param.set_uuid(uuid)

        generator = NetworkXMLConfigGenerator()
        try:
            cfgxml = generator.generate(param)
        except:
            raise
        generator.writecfg(cfgxml)

        ret = libvirtmod.virNetworkCreateXML(self._conn._o,cfgxml)
        time.sleep(2)
        self._conn.networkDefineXML(cfgxml)

        filename = "%s/%s.xml" %(VIRT_NETWORK_CONFIG_DIR,name)
        r_chmod(filename,"o-rwx")
        r_chmod(filename,"g+rw")
        if os.getuid() == 0:
            r_chgrp(filename,KARESANSUI_GROUP)

        if autostart is not None:
            self.network.set_network_name(name)
            self.network.autostart(autostart)

        return ret

    def update_network(self, name, cidr=None, dhcp_start=None, dhcp_end=None, forward=None, bridge=None, autostart=None):
        """
        <comment-ja>
        仮想ネットワークを更新します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        # パラメータをリセットする場合と引数が無い場合の区別 => リセットの場合は、空文字列を渡す。

        if not ( cidr or
                 dhcp_start or
                 dhcp_end or
                 forward or
                 bridge ):
            # Not changed, do nothing
            # 更新成功時と同じ返り値(0)を返す
            return 0

        try:
            param  = self.search_kvn_networks(name)[0].get_network_config_param()
        except:
            raise KaresansuiVirtException("Can't get parameters of network '%s'." % name)

        if cidr:
            param.set_ipaddr_and_netmask(cidr)
        if dhcp_start:
            param.set_dhcp_start(dhcp_start)
        if dhcp_end:
            param.set_dhcp_end(dhcp_end)
        if forward:
            if 'dev' in forward.keys():
                if forward['dev'] == '':
                    param.set_forward_dev(None)
                else:
                    param.set_forward_dev(forward['dev'])
            if 'mode' in forward.keys():
                if forward['mode'] == '':
                    param.set_forward_mode(None)
                else:
                    param.set_forward_mode(forward['mode'])
        if bridge:
            param.set_bridge(bridge)

        generator = NetworkXMLConfigGenerator()
        try:
            cfgxml = generator.generate(param)
        except:
            raise

        self.stop_network(name)

        generator.writecfg(cfgxml)

        ret = libvirtmod.virNetworkCreateXML(self._conn._o,cfgxml)
        time.sleep(2)
        self._conn.networkDefineXML(cfgxml)

        if autostart is not None:
            self.network.autostart(autostart)

        return ret

    def start_network(self,name=None):
        """
        <comment-ja>
        仮想ネットワークを起動します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.network.set_network_name(name)
        self.network.start()

    def stop_network(self,name=None):
        """
        <comment-ja>
        仮想ネットワークを停止します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.network.set_network_name(name)
        self.network.stop()

    def delete_network(self,name=None):
        """
        <comment-ja>
        仮想ネットワークを削除します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        self.stop_network(name)
        if len(self.search_networks(name)) > 0:
            self.network.undefine()

        config = "%s/%s.xml" %(VIRT_NETWORK_CONFIG_DIR, self.network.get_network_name())
        if os.path.exists(config):
            os.unlink(config)

        config = "%s/autostart/%s.xml" %(VIRT_NETWORK_CONFIG_DIR, self.network.get_network_name())
        if os.path.exists(config):
            os.unlink(config)

    def autostart_network(self,flag=None,name=None):
        """
        <comment-ja>
        仮想ネットワークの自動起動を設定します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.guest.set_domain_name(name)
        networks = self.search_networks(self.network.get_network_name())
        if len(networks):
            return self.network.autostart(flag)
        else:
            return False


    """
    Storage Pool
    """
    def refresh_pools(self):
        """
        <comment-ja>
        現在のストレージプール情報をリフレッシュします。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        # refresh pool.
        active_pools =  self.list_active_storage_pool()
        #inactive_pools =  self.list_inactive_storage_pool()
        inactive_pools = []
        for pool_name in active_pools + inactive_pools:
            try:
                pool =  self.search_kvn_storage_pools(pool_name)
                path = pool[0].get_info()["target"]["path"]
                self.search_storage_pools(pool_name)[0].refresh(0)
            except:
                pass
    
    def list_inactive_storage_pool(self):
        """
        <comment-ja>
        現在起動していないストレージプールのリストを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        pools = self._conn.listDefinedStoragePools()
        ret = []
        for i in xrange(len(pools)):
            path = "%s/%s.xml" % (VIRT_STORAGE_CONFIG_DIR, pools[i])
            if os.path.isfile(path) is False:
                continue
            ret.append(pools[i])
        return ret

    def list_active_storage_pool(self):
        """
        <comment-ja>
        現在起動しているストレージプールのリストを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        names = []
        for name in self._conn.listStoragePools():
            names.append(name)
        return names

    def search_storage_pools(self, name=None, active_only=False):
        """
        <comment-ja>
        ストレージプールの検索を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        pools = []

        names = self._conn.listStoragePools()
        for __name in names:
            pools.append(self._conn.storagePoolLookupByName(__name))

        if active_only is False:
            names = self.list_inactive_storage_pool()
            for __name in names:
                pools.append(self._conn.storagePoolLookupByName(__name))

        if name == None:
            return pools

        regex_regex = re.compile(r"""^regex:(?P<regex>.*)""")
        m = regex_regex.match(name)

        n_pools = []
        for pool in pools:
            pool_name = pool.name()
            if m == None:
                if pool_name == name:
                    return [pool]
            else:
                regex = m.group('regex')
                query_regex = re.compile(r""+regex+"")
                n = query_regex.search(storage_name)
                if n != None:
                    n_pools.append(pool)
        if len(n_pools):
            return n_pools

        #return []
        raise KaresansuiVirtException("Storage pool %s not found" % name)

    def search_kvn_storage_pools(self, name=None, active_only=False):
        """<comment-ja>
        指定されたStorage Pool をKaresansuiVirtStoragePoolオブジェクトのlistにして返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """

        if is_uuid(name):
            name = self.uuid_to_domname(name)

        pools = []
        for pool in self.search_storage_pools(name, active_only):
            pools.append(
                KaresansuiVirtStoragePool(conn=self, name=pool.name()))

        return pools

    def start_storage_pool(self, name):
        """
        <comment-ja>
        ストレージプールの起動します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        return self.storage_pool.create(name)
        
    def create_storage_pool(self, name, type,
                            target_path=None,
                            allocation=0, available=0, capacity=0,
                            source_f_type=None, source_dev_path=None, source_a_name=None,
                            source_dir_path=None, source_h_name=None,
                            target_p_group=None, target_p_label=None,
                            target_p_mode=None, target_p_owner=None,
                            target_e_format=None, target_encryption_s_type=None,
                            #target_encryption_s_uuid=None,
                            ):
        """
        <comment-ja>
        ストレージプールの作成を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """

        param = StoragePoolConfigParam(name)
        
        uuid = StrFromUUID(GenUUID())
        param.set_uuid(uuid)

        if type is not None:
            param.set_pool_type(type)

        if target_path is not None:
            param.set_target_path(target_path)

        param.set_allocation(allocation)
        param.set_available(available)
        param.set_capacity(capacity)
        
        if source_f_type is not None:
            param.set_source_f_type(source_f_type)

        if source_dev_path is not None:
            param.set_source_dev_path(source_dev_path)

        if source_dir_path is not None:
            param.set_source_dir_path(source_dir_path)

        if source_f_type is not None:
            param.set_source_f_type(source_f_type)

        if source_h_name is not None:
            param.set_source_h_name(source_h_name)

        if target_e_format is not None and \
               target_encryption_s_type is not None:
            param.set_target_e_format(target_e_format)
            param.set_target_encryption_s_type(target_encryption_s_type)
            target_encryption_s_uuid = StrFromUUID(GenUUID())
            param.set_target_encryption_s_uuid(target_encryption_s_uuid)

        if target_p_group is not None:
            param.set_target_permissions_group(target_p_group)

        if target_p_label is not None:
            param.set_target_permissions_label(target_p_label)

        if target_p_mode is not None:
            param.set_target_permissions_mode(target_p_mode)

        if target_p_owner is not None:
            param.set_target_permissions_owner(target_p_owner)

        generator = StoragePoolXMLConfigGenerator()
        try:
            cfgxml = generator.generate(param)
        except:
            raise
        generator.writecfg(cfgxml)

        if self.storage_pool.start(cfgxml, 0, name) == 0:
            return True
        else:
            return False

    def is_autostart_storage_pool(self, name=None):
        """
        <comment-ja>
        指定されたストレージプールが自動起動するか。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.storage_pool.set_storage_name(name)

        pools = self.search_storage_pools(self.storage_pool.get_storage_name())
        if len(pools):
            ret = self.storage_pool.autostart()
            if ret == 0:
                return False # OFF
            elif ret == 1:
                return True # ON
            else:
                return None # ERR
        else:
            return None # ERR
        
    def autostart_storage_pool(self, flag=None, name=None):
        """
        <comment-ja>
        ストレージプールの自動起動設定を行います。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if not (name is None):
            self.storage_pool.set_storage_name(name)

        pools = self.search_storage_pools(self.storage_pool.get_storage_name())
        if len(pools):
            if self.storage_pool.set_autostart(flag) == 0:
                return True
            else:
                return False
        else:
            return False

    def destroy_storage_pool(self,name=None):
        """
        <comment-ja>
        ストレージプールの削除を行います。(設定ファイルなどの情報は削除されません)
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if name is not None:
            self.storage_pool.set_storage_name(name)
        if self.storage_pool.destroy() == 0:
            return True
        else:
            return False

    def delete_storage_pool(self,name=None, flags=False):
        """
        <comment-ja>
        ストレージプールを完全に削除します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if name is not None:
            self.storage_pool.set_storage_name(name)

        # autostart off
        self.autostart_storage_pool(False)

        path = "%s/%s.xml" % (VIRT_STORAGE_CONFIG_DIR, self.storage_pool.get_storage_name())
        if os.path.isfile(path) is True:
            os.unlink(path)

        mode = VIR_STORAGE_POOL_DELETE_NORMAL
        if flags is True:
            mode = VIR_STORAGE_POOL_DELETE_ZEROED

        if self.storage_pool.delete(mode) == 0:
            return True
        else:
            return False

    def is_used_storage_pool(self, name=None, active_only=False):
        """
        <comment-ja>
        ストレージプールが現在利用されているか。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        if name is None:
            return False

        guests = self.list_active_guest()
        if active_only is False:
            guests += self.list_inactive_guest()

        pools = []
        for guest in guests:
            pools += self.get_storage_pool_name_bydomain(guest)

        if name in pools:
            return True

        return False

    def is_storage_volume(self, path):
        """<comment-ja>
        指定したパスがストレージボリュームに含まれているか。
        </comment-ja>
        <comment-en>
        Storage volume that contains the specified path.
        </comment-en>
        """
        if os.path.isfile(path) is False:
            return False

        try:
            vir_storage_vol = self.storage_volume._conn.storageVolLookupByPath(path)
            return True
        except libvirt.libvirtError, e:
            # _("The specified path is not registered in the storage volume. '%s' (%s)")
            return False

    def get_storage_volume(self, pool_name, vol_name):
        """
        <comment-ja>
        ストレージボリュームを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        vol = None

        try:
            pools = self.search_storage_pools(pool_name)
            if len(pools) <= 0:
                return vol
            if vol_name in pools[0].listVolumes():
                vol = pools[0].storageVolLookupByName(vol_name)
        except libvirt.libvirtError, e:
            return vol

        return vol

    def get_storage_volume_path(self, pool_name, vol_name):
        """
        <comment-ja>
        ストレージボリュームのパスを取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        try:
            vol = self.get_storage_volume(pool_name, vol_name)
            if vol is None:
                return None
            vol_path = vol.path()
            return vol_path
        except libvirt.libvirtError, e:
            return None

    def get_storage_pool_UUIDString2kvn_storage_pool(self, uuidstr):
        """
        <comment-ja>
        ストレージプールのUUIDをもとに、ストレージプール情報を取得します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        pool_obj = self._conn.storagePoolLookupByUUIDString(uuidstr)
        return self.search_kvn_storage_pools(pool_obj.name())
        
    def create_storage_volume(self,
                              name,
                              pool_name,
                              t_f_type,
                              use,
                              volume_name=None,
                              #t_path=None,
                              key=None, allocation=0, capacity=0, c_unit=None,
                              source=None,
                              t_p_owner=None,t_p_group=None,t_p_mode=None, t_p_label=None,
                              b_path=None,
                              b_format=None,
                              b_p_owner=None, b_p_group=None, b_p_mode=None, b_p_label=None):
        """
        <comment-ja>
        ストレージボリュームを作成します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        param = StorageVolumeConfigParam(name)

        if volume_name is None:
            uuid = StrFromUUID(GenUUID())
        else:
            uuid = volume_name
        param.set_uuid(uuid)
        param.set_storage_name(uuid)

        self.storage_pool.set_storage_name(pool_name)
        self.storage_volume.set_storage_volume_name(uuid)

        #if t_path is not None:
        #   param.set_target_path(t_path)

        param.set_target_f_type(t_f_type)

        if key is not None:
            set_key(key)

        param.set_allocation(allocation)
        param.set_capacity(capacity)

        if c_unit is not None and (capacity != 0 or allocation != 0):
            param.set_c_unit(c_unit)

        if source is not None:
            param.set_source(source)
                
        if t_p_owner is not None:
            param.set_target_permissions_owner(t_p_owner)

        if t_p_group is not None:
            param.set_target_permissions_group(t_p_group)

        if t_p_mode is not None:
            param.set_target_permissions_mode(t_p_mode)

        if t_p_label is not None:
            param.set_target_permissions_label(t_p_label)

        if b_path is not None:
            param.set_backingStore_path(b_path)
            if b_format is not None:
                param.set_backingStore_format(b_format)

            if b_p_owner is not None:
                param.set_backingStore_permissions_owner(b_p_owner)

            if b_p_group is not None:
                param.set_backingStore_permissions_group(b_p_group)

            if b_p_mode is not None:
                param.set_backingStore_permissions_mode(b_p_mode)

            if b_p_label is not None:
                param.set_backingStore_permissions_label(b_p_label)

        generator = StorageVolumeXMLConfigGenerator()
        try:
            cfgxml = generator.generate(param)
        except:
            raise

        # comment out
        #generator.writecfg(cfgxml)

        vir_storage_vol = self.storage_pool.vol_createXML(cfgxml, 0)

        if not isinstance(vir_storage_vol, libvirt.virStorageVol):
            return False
        # storage dir
        pool_objs = self.search_kvn_storage_pools(pool_name)
        if not pool_objs:
            raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                          pool_name)

        # TODO iscsi block device
        domains_dir = pool_objs[0].get_info()["target"]["path"]
        domain_dir = self.make_domain_dir(domains_dir, name)

        import shutil
        if use == DISK_USES["IMAGES"]:
            disk = "%s/%s/%s.img" % (domain_dir, DISK_USES["IMAGES"], name)
            shutil.move("%s/%s" % (domains_dir, param.get_storage_name()),
                        disk)

            os.symlink(disk,
                       "%s/%s" % (domains_dir, param.get_storage_name()))
        else:
            disk = "%s/%s/%s.img" % (domain_dir, DISK_USES["DISK"], uuid)
            shutil.move("%s/%s" % (domains_dir, uuid),
                        disk)

            os.symlink(disk,
                       "%s/%s" % (domains_dir, uuid))

        # Storage Pool refresh
        try:
            self.search_storage_pools(pool_name)[0].refresh(0)
        except:
            pass

        return True

    def delete_storage_volume(self,pool_name, vol_name, use, flags=False):
        """
        <comment-ja>
        ストレージボリュームを完全に削除します。
        </comment-ja>
        <comment-en>
        TODO:
        </comment-en>
        """
        self.storage_volume.set_storage_name(pool_name)
        self.storage_volume.set_storage_volume_name(vol_name)

        # delete storage dir
        pool_objs = self.search_kvn_storage_pools(pool_name)
        if not pool_objs:
            raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                              pool_name)

        domains_dir = pool_objs[0].get_info()["target"]["path"]
        target_path = "%s/%s" % (domains_dir, vol_name)
        taget_real_path = os.path.realpath(target_path)

        # delete process
        mode = VIR_STORAGE_VOL_DELETE_NORMAL
        if flags is True:
            mode = VIR_STORAGE_VOL_DELETE_ZEROED

        if self.storage_volume.delete(mode) != 0:
            return False

        # physical process
        if use == DISK_USES["IMAGES"]:
            os.remove(taget_real_path)
            if os.path.exists(target_path) is True:
                os.remove(target_path)
        elif use == DISK_USES["DISK"]:
            os.remove(taget_real_path)
            if os.path.exists(target_path) is True:
                os.remove(target_path)
        else:
            pass

    def get_storage_pool_type(self, pool_name):
        """<comment-ja>
        ストレージプールのタイプを取得する
        @param pool_name: ストレージプール名
        @return: ストレージプールの種別
        @rtype: string
        </comment-ja>
        <comment-en>
        Get the type of storage pool.
        @param pool_name: name of storage pool
        @return: type of storage pool
        @rtype: string
        </comment-en>
        """
        retval = None

        try:
            pool_objs = self.search_kvn_storage_pools(pool_name)
            if not pool_objs:
                raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                          pool_name)
            retval = pool_objs[0].get_info()['type']
        except:
            pass

        return retval

    def get_storage_pool_targetpath(self, pool_name):
        """<comment-ja>
        ストレージプールのターゲットパスを取得します。(dir)
        @param pool_name: ストレージプール名
        @return: ターゲットパス
        @rtype: string
        </comment-ja>
        <comment-en>
        Get the target path of storage pool.
        @param pool_name: name of storage pool
        @return: target path
        @rtype: string
        </comment-en>
        """
        retval = None

        try:
            pool_objs = self.search_kvn_storage_pools(pool_name)
            if not pool_objs:
                raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                          pool_name)
            retval = pool_objs[0].get_info()['target']['path']
        except:
            pass

        return retval

    def get_storage_pool_sourcedevicepath(self, pool_name):
        """<comment-ja>
        ストレージプールのソースデバイスパスを取得します。(iscsi)
        @param pool_name: ストレージプール名
        @return: ソースデバイスパス
        @rtype: string
        </comment-ja>
        <comment-en>
        Get the source device path of storage pool.
        @param pool_name: name of storage pool
        @return: source device path
        @rtype: string
        </comment-en>
        """
        retval = None

        try:
            pool_objs = self.search_kvn_storage_pools(pool_name)
            if not pool_objs:
                raise KaresansuiVirtException(_("Storage pool could not be found. pool=%s") % \
                                          pool_name)
            retval = pool_objs[0].get_info()['source']['dev_path']
        except:
            pass

        return retval

    def get_storage_pool_name_byimage(self, path):
        """<comment-ja>
        ディスクイメージのパスからストレージプールの名前を取得する
        @param path: ディスクイメージのパス
        @return: ストレージプールの名前
        @rtype: list
        </comment-ja>
        <comment-en>
        Get name of storage pool where the specified disk image belongs to.
        @param path: path of disk image
        @return: list of storage pool name
        @rtype: list
        </comment-en>
        """
        retval = []

        paths = [path]
        realpath = os.path.realpath(path)

        # Includes realpath as detecting target if it is symbolic link.
        if realpath != path:
            paths.append(realpath)

        try:
            pool_objs = self.search_kvn_storage_pools()
            if not pool_objs:
                raise KaresansuiVirtException(_("No storage pools could be found."))

            for pool_obj in pool_objs:
                pool_info = pool_obj.get_info()
                name        = pool_info['name']
                pool_type   = pool_info['type']

                for vol_name,vol_path in self.get_storage_volume_bypool(name, attr="path").iteritems():
                    for _path in paths:
                        if pool_type == "dir":
                            if ( vol_path == _path or os.path.realpath(vol_path) == _path ) and not name in retval:
                                retval.append(name)
                        else:
                            if ( vol_path == _path[0:len(vol_path)] ) and not name in retval:
                                retval.append(name)

        except:
            pass

        return retval

    def get_storage_pool_name_bydomain(self, domain, image_type=None):
        """<comment-ja>
        ドメインの名前からストレージプールの名前を取得する
        * iscsi is returning the [].
        @param domain: ドメイン名
        @param image_type: イメージの種別 
                     "os"                :ゲストOS本体のイメージファイル
                     "disk"              :拡張ディスクのイメージファイル
                     未指定またはそれ以外:ドメインに属する全てのイメージファイル
        @return: ストレージプールの名前
        @rtype: list
        </comment-ja>
        <comment-en>
        Get name of storage pool where image files that the specified domain uses belong to.

        @param domain: domain name
        @return: list of storage pool name
        @rtype: list
        </comment-en>
        """
        retval = []

        regex = []
        if image_type == "os":
            regex.append("%s/images/%s\.img$" % (domain,domain,))
        if image_type == "disk":
            regex.append("%s/disk/[0-9\.]+\.img$" % (domain,))
        regex_str = "|".join(regex)

        try:
            guest_obj = self.search_kvg_guests(domain)[0]
            if not guest_obj:
                raise KaresansuiVirtException(_("Domain could not be found. name=%s") % \
                                          domain)

            os_root = guest_obj.get_info()['os_root']

            for info in guest_obj.get_disk_info():
                try:
                    target = info['target']['dev']
                except:
                    target = None

                try:
                    source = info['source']['file']
                except:
                    try:
                        source = info['source']['dev']
                    except:
                        source = None

                pools = []
                if image_type == "os":
                   if os_root is not None and target == os.path.basename(os_root):
                       pools = self.get_storage_pool_name_byimage(source)
                elif image_type == "disk":
                   if os_root is not None and target != os.path.basename(os_root):
                       pools = self.get_storage_pool_name_byimage(source)
                else:
                    pools = self.get_storage_pool_name_byimage(source)

                if len(pools) > 0:
                    for pool_name in pools:
                        if not pool_name in retval:
                            retval.append(pool_name)

            # in case that os_root is not specified.
            if len(retval) == 0:
                for info in guest_obj.get_disk_info():
                    if re.search(regex_str,info['source']['file']):
                        for pool_name in self.get_storage_pool_name_byimage(info['source']['file']):
                            if not pool_name in retval:
                                retval.append(pool_name)

        except:
            pass

        return retval


    def get_storage_volume_bypool(self, pool, attr="name"):
        """<comment-ja>
        ストレージプールの名前からボリュームの一覧を取得する
        @param pool: プール名
        @param attr: 取得する属性
                     "name"  :ボリュームの名前(UUID形式)
                     "key"   :ボリュームのキー
                     "path"  :ボリュームのパス
                     "info"  :ボリュームの情報
                     未指定  :nameが指定されたものとする

                     attr 'info' depends on virStorageVolInfo structure.
                       int type;                      virStorageVolType flags
                                                      0 :Regular file
                                                      1 :Block
                       unsigned long long capacity;   Logical size bytes
                       unsigned long long allocation; Current allocation bytes
        @return: ストレージボリューム名と対応するデータの辞書配列
        @rtype: dict
        </comment-ja>
        <comment-en>
        Get name of storage volume in the specified pool.
        
        @param pool: name of pool
        @param attr: volume attribute that you want to get
                     "name"  :name of volume (UUID style)
                     "key"   :key of volume
                     "path"  :path of volume
                     "info"  :volume information
                     none    :same as 'name' is specified

        @return: dict of storage volume
        @rtype: dict
        </comment-en>
        """
        retval = {}

        try:
            pool_obj = self.search_kvn_storage_pools(pool)[0]
            if not pool_obj:
                raise KaresansuiVirtException(_("No storage pool '%s' could be found.") % pool)

            pool_type = pool_obj.get_info()['type']
            if pool_type == "dir":
                vols = pool_obj.vol_listVolumes()
                for vol in vols:
                    vol_obj = pool_obj.vol_storageVolLookupByName(vol)
                    try:
                        exec("value = vol_obj.%s()" % attr)
                        retval[vol] = value
                    except:
                        pass
            else:
                value = pool_obj.get_info()['target']['path']
                retval[pool] = value
        except:
            pass

        return retval

    def get_storage_volume_iscsi_rpath_bystorage(self, pool, volume):
        """<comment-ja>
        ストレージプール名とストレージボリューム名から、ストレージのREAL PATHを取得します。
        </comment-ja>
        <comment-en>
        TODO: To include comments in English
        </comment-en>
        """
        ret = None
        try:
            pool_obj = self.search_kvn_storage_pools(pool)[0]
            if not pool_obj:
                raise KaresansuiVirtException(_("No storage pool '%s' could be found.") % pool)

            vol_obj = pool_obj.vol_storageVolLookupByName(volume)
            ret = vol_obj.key()
        except:
            pass

        return ret

    def get_storage_volume_bydomain(self, domain, image_type=None, attr="name"):
        """<comment-ja>
        ドメインの名前からボリュームの一覧を取得する
        @param domain: ドメイン名
        @param image_type: イメージの種別
                     "os"    :ゲストOS本体のイメージファイル
                     "disk"  :拡張ディスクのイメージファイル
                     未指定  :ドメインに属する全てのイメージファイル
        @param attr: 取得する属性
                     "name"  :ボリュームの名前(UUID形式)
                     "key"   :ボリュームのキー
                     "path"  :ボリュームのパス
                     "info"  :ボリュームの情報
                     未指定  :nameが指定されたものとする

                     attr 'info' depends on virStorageVolInfo structure.
                       int type;                      virStorageVolType flags
                                                      0 :Regular file
                                                      1 :Block
                       unsigned long long capacity;   Logical size bytes
                       unsigned long long allocation; Current allocation bytes
        @return: ストレージボリューム名と対応するデータの辞書配列
        @rtype: dict
        </comment-ja>
        <comment-en>
        Get name of storage volume in the specified domain.

        @param domain: domain name
        @param image_type: type of image file
                     "os"    :os image only
                     "disk"  :extended disk image only
                     none    :all images that domain uses
        @param attr: volume attribute that you want to get
                     "name"  :name of volume (UUID style)
                     "key"   :key of volume
                     "path"  :path of volume
                     "info"  :volume information
                     none    :same as 'name' is specified

        @return: dict of storage volume
        @rtype: dict
        </comment-en>
        """
        retval = {}

        regex = []
        if image_type == "os":
            regex.append("%s/images/%s\.img$" % (domain,domain,))
        if image_type == "disk":
            regex.append("%s/disk/[0-9\.]+\.img$" % (domain,))
        regex_str = "|".join(regex)

        try:
            guest_obj = self.search_kvg_guests(domain)[0]
            if not guest_obj:
                raise KaresansuiVirtException(_("Domain could not be found. name=%s") % \
                                          domain)

            os_root = guest_obj.get_info()['os_root']

            for info in guest_obj.get_disk_info():
                try:
                    target = info['target']['dev']
                except:
                    target = None

                try:
                    source = info['source']['file']
                except:
                    try:
                        source = info['source']['dev']
                    except:
                        source = None

                pools = []
                if image_type == "os":
                   if os_root is not None and target == os.path.basename(os_root):
                       pools = self.get_storage_pool_name_byimage(source)
                elif image_type == "disk":
                   if os_root is not None and target != os.path.basename(os_root):
                       pools = self.get_storage_pool_name_byimage(source)
                else:
                    pools = self.get_storage_pool_name_byimage(source)

                if len(pools) > 0:
                    for _pool in pools:
                        vols = self.get_storage_volume_bypool(_pool, attr=attr)
                        for vol,value in vols.iteritems():
                            path = self.get_storage_volume_iscsi_rpath_bystorage(_pool,vol)
                            if path[0:5] != "/dev/":
                                path = os.path.realpath(path)
                            if source == path and not vol in retval.keys():
                                retval[vol] = value

        except:
            pass

        return retval


    def get_storage_volume_symlink(self, path):
        """<comment-ja>
        ディスクイメージのパスからストレージボリューム(symlink)の名前を取得します。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        ret = []

        paths = [path]
        realpath = os.path.realpath(path)

        # Includes realpath as detecting target if it is symbolic link.
        if realpath != path:
            paths.append(realpath)

        try:
            pool_objs = self.search_kvn_storage_pools()
            if not pool_objs:
                raise KaresansuiVirtException(_("No storage pools could be found."))

            for pool_obj in pool_objs:
                pool_info = pool_obj.get_info()
                if pool_info['type'] != 'dir' or pool_info['is_active'] is False:
                    continue

                vols = pool_obj.vol_listVolumes()
                for vol in vols:
                    vol_path = "%s/%s" % (pool_info['target']['path'], vol)
                    vol_real_path = os.path.realpath(vol_path)
                    if path == vol_real_path:
                        #ret.append(vol_real_path)
                        ret.append(vol)
        except:
            pass
        return ret

    def get_storage_volume_iscsi_bysymlink(self, symlink):
        """<comment-ja>
        example形式のiscsiパスからlibvirtのストレージボリューム情報を取得します。
        
        @param symlink: example) 'ip-192.168.100.100:3260-iscsi-iqn.2010-01.info.karesansui-project:iscsi-123-lun-1'
        @return: {pool: プール名,volume: ボリューム名,rpath:iscsiのby-path}
        </comment-ja>
        <comment-en>
        TODO: To include comments in English
        </comment-en>
        """
        pools = self.search_kvn_storage_pools()
        rpath = "%s/%s" % (ISCSI_DEVICE_DIR, symlink)
        ret = None
        for pool in pools:
            name = pool.get_storage_name()
            if self.get_storage_pool_type(name) == 'iscsi':
                volumes = self.get_storage_volume_bypool(name, 'key')
                for vkey in volumes.keys():
                    if rpath == volumes[vkey]:
                        ret = {"pool" : name,
                               "volume" : vkey,
                               "rpath" : volumes[vkey],
                               }
                        break
        return ret

    def get_storage_volume_iscsi_block_bypool(self, pool):
        """<comment-ja>
        ストレージプールの名前からiSCSIブロックデバイスのボリュームの一覧を取得する
        @param pool: プール名
        @return: ストレージボリューム名の配列
        @rtype: dict
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        retval = []

        try:
            active_pool = self.list_active_storage_pool()
            #inactive_pool = self.list_inactive_storage_pool()
            inactive_pool = []
            pools = inactive_pool + active_pool

            pool_obj = self.search_kvn_storage_pools(pool)[0]
            if not pool_obj:
                raise KaresansuiVirtException(_("No storage pool '%s' could be found.") % pool)

            vols = pool_obj.vol_listVolumes()
            for vol in vols:
                vol_obj = pool_obj.vol_storageVolLookupByName(vol)
                vol_key = vol_obj.key()
                vol_key = vol_key.replace("%s/" % (ISCSI_DEVICE_DIR), "")
                regex = re.compile(r"^%s" % (re.escape(vol_key)))
                is_mount = False
                for pool in pools:
                    if regex.match(pool):
                        is_mount = True

                if is_mount is False:
                    retval.append(vol)
        except:
            pass

        return retval


class KaresansuiVirtGuest:

    def __init__(self, conn, name=None):
        self.connection = conn
        self._conn = self.connection._conn
        self.set_domain_name(name)

    def get_json(self):
        """<comment-ja>
        JSON形式でKaresansuiVirtGuest情報を返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        
        ret = {}
        ret['name'] = self.get_domain_name()
        ret.update(self.get_info())
        return ret

    def set_domain_name(self,name=None):
        if is_uuid(name):
            self.domain = conn.uuid_to_domname(name)
        else:
            self.domain = name

    def get_domain_name(self):
        return self.domain

    def get_info(self):
        dom = self._conn.lookupByName(self.get_domain_name())
        data = dom.info()
        try:
            os_type = dom.OSType()
        except:
            os_type = None
        try:
            uuid = dom.UUIDString()
        except:
            uuid = None

        try:
            param = ConfigParam(dom.name())
            xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
            if not os.path.exists(xml_file):
                if dom._conn.getURI() in available_virt_uris().values():
                    ConfigFile(xml_file).write(dom.XMLDesc(0))
                    if os.getuid() == 0 and os.path.exists(xml_file):
                        r_chgrp(xml_file,KARESANSUI_GROUP)
            #param.load_xml_config(xml_file)
            param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

            vm_type = param.domain_type
            os_root = param.os_root

        except:
            vm_type = uri_split(self._conn.getURI())["scheme"]
            os_root = "unknown"
            pass

        try:
            self.connection.hypervisor
        except:
            self.connection.hypervisor = self.connection.get_hypervisor_type()
        hypervisor = self.connection.hypervisor

        try:
            self.connection.hvVersion
        except:
            try:
                self.connection.hvVersion = libvirtmod.virConnectGetVersion(self._conn._o)
            except:
                pass
        try:
            hvVersion = self.connection.hvVersion
            hvVersion_major = hvVersion / 1000000
            hvVersion %= 1000000
            hvVersion_minor = hvVersion / 1000
            hvVersion_rel = hvVersion % 1000
            hv_version = "%s %d.%d.%d" %(hypervisor, hvVersion_major, hvVersion_minor, hvVersion_rel)
        except:
            hv_version = None

        return {
                "state"     : data[0],
                "maxMem"    : data[1],
                "memory"    : data[2],
                "nrVirtCpu" : data[3],
                "cpuTime"   : data[4],
                "OSType"    : os_type,
                "VMType"    : vm_type,
                "hypervisor": hypervisor,
                "hv_version": hv_version,
                "os_root"   : os_root,
                "uuid"      : uuid,
        }

    def get_netinfo(self):
        info = {}
        dom = self._conn.lookupByName(self.get_domain_name())
        dom_id = dom.ID()
        if self.get_info()["VMType"] == "kvm":
            #eth_info = get_ifconfig_info("regex:^eth")
            eth_info = get_ifconfig_info("regex:^br")
            for dev,value in eth_info.iteritems():
                info[dev] = value
        else:
            vif_info = get_ifconfig_info("regex:^vif%d\.[0-9]" % dom_id)
            for dev,value in vif_info.iteritems():
                dev = dev.replace("vif%d." % (dom_id,), "eth")
                info[dev] = value
        return info

    def get_disk_info(self):
        infos = []
        dom = self._conn.lookupByName(self.get_domain_name())

        param = ConfigParam(dom.name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        for info in param.disks:
            driver = {}
            source = {}
            target = {}
            type   = info['disk_type']
            device = info['device']

            try:
                driver['name'] = info["driver_name"]
            except:
                driver['name'] = None
            try:
                driver['type'] = info["driver_type"]
            except:
                driver['type'] = None

            if type == 'block':
                source['dev'] = info['path']
                source_path = source['dev']
            else:
                source['file'] = info['path']
                source_path = source['file']

            target['dev'] = info['target']
            target['bus'] = info['bus']

            if os.path.exists(source_path):
                img_info = get_disk_img_info(source_path)
                try:
                    img_size = img_info['virtual_size']
                except:
                    img_size = img_info['real_size']
                source['size'] = get_filesize_MB(img_size)
            else:
                source['size'] = 0
            info = {
                   "type":type,
                   "device":device,
                   "driver":driver,
                   "source":source,
                   "target":target,
                   }
            infos.append(info)
        return infos

    def get_vcpus_info(self):
        dom = self._conn.lookupByName(self.get_domain_name())

        param = ConfigParam(dom.name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(1))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        try:
            max_vcpus = int(param.max_vcpus)
        except:
            max_vcpus = None
        try:
            if self.status() != VIR_DOMAIN_SHUTOFF:
                vcpus = self.get_info()['nrVirtCpu']
            else:
                vcpus = None
        except:
            vcpus = None
        try:
            bootup_vcpus = int(param.vcpus)
        except:
            bootup_vcpus = None

        return {
                "max_vcpus"    :max_vcpus,
                "vcpus"        :vcpus,
                "bootup_vcpus" :bootup_vcpus,
               }

    def get_interface_info(self):
        infos = []
        dom = self._conn.lookupByName(self.get_domain_name())

        param = ConfigParam(dom.name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(0))

        for info in param.interfaces:
            mac = {}
            source = {}
            script = {}
            target = {}
            type           = info['type']
            mac['address'] = info['mac']
            script['path'] = info['script']
            target['dev']  = info['target']
            if str(type) == "network":
                try:
                    source['network'] = info['network']
                except:
                    source['network'] = None
            else:
                try:
                    source['bridge']  = info['bridge']
                except:
                    source['bridge']  = None

            if_info = {
                   "type":type,
                   "mac":mac,
                   "source":source,
                   "script":script,
                   "target":target,
                   }
            infos.append(if_info)

        return infos

    def get_graphics_info(self):
        dom = self._conn.lookupByName(self.get_domain_name())

        """ current info """
        param = ConfigParam(dom.name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(0))

        type     = param.get_graphics_type()
        port     = param.get_graphics_port()
        autoport = param.get_graphics_autoport()
        listen   = param.get_graphics_listen()
        keymap   = param.get_graphics_keymap()
        current_info = {
                       "type"    :type,
                       "port"    :port,
                       "autoport":autoport,
                       "listen"  :listen,
                       "keymap"  :keymap,
                       }

        """ current setting """
        param = ConfigParam(self.get_domain_name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        type     = param.get_graphics_type()
        port     = param.get_graphics_port()
        autoport = param.get_graphics_autoport()
        listen   = param.get_graphics_listen()
        keymap   = param.get_graphics_keymap()
        passwd   = param.get_graphics_passwd()
        current_setting = {
                       "type"    :type,
                       "port"    :port,
                       "autoport":autoport,
                       "listen"  :listen,
                       "keymap"  :keymap,
                       "passwd"  :passwd,
                       }

        return {"info":current_info,"setting":current_setting}

    def create(self):
        if self.is_creatable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())
            dom.create()
            for x in range(0,5):
                time.sleep(1)
                if self.status() != VIR_DOMAIN_SHUTOFF:
                    break

    def shutdown(self):
        if self.is_shutdownable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())
            dom.shutdown()
            for x in range(0,120):
                time.sleep(1)
                if self.status() == VIR_DOMAIN_SHUTOFF:
                    break

    def reboot(self):
        if self.is_shutdownable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())

            """
            dom.reboot(0)
            """
            dom.shutdown()
            for x in range(0,480):
                time.sleep(1)
                if self.status() == VIR_DOMAIN_SHUTOFF:
                    break
            dom.create()

            for x in range(0,30):
                time.sleep(1)
                if self.status() != VIR_DOMAIN_SHUTOFF:
                    break

    def destroy(self):
        if self.is_destroyable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())
            dom.destroy()
            for x in range(0,120):
                time.sleep(1)
                if self.status() == VIR_DOMAIN_SHUTOFF:
                    break

    def suspend(self):
        if self.is_suspendable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())
            dom.suspend()
            for x in range(0,5):
                time.sleep(1)
                if self.status() == VIR_DOMAIN_PAUSED:
                    break

    def resume(self):
        if self.is_resumable() is True:
            time.sleep(1)
            dom = self._conn.lookupByName(self.get_domain_name())
            dom.resume()
            for x in range(0,5):
                time.sleep(1)
                if self.status() != VIR_DOMAIN_PAUSED:
                    break

    def undefine(self):
        dom = self._conn.lookupByName(self.get_domain_name())
        dom.undefine()

    def status(self):
        return self.get_info()["state"]

    def save(self,file):
        dom = self._conn.lookupByName(self.get_domain_name())
        dom.save(file)
        for x in range(0,120):
            time.sleep(1)
            if self.status() == VIR_DOMAIN_SHUTOFF:
                break


    def set_current_snapshot(self,id=None):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        param.set_current_snapshot(id)

        xml_generator = XMLConfigGenerator()
        cfgxml = xml_generator.generate(param)
        self._conn.defineXML(cfgxml)

        sync_config_generator(param, self.get_domain_name())


    def autostart(self, flag=None):
        dom = self._conn.lookupByName(self.get_domain_name())

        if dom._conn.getURI() in available_virt_uris().values():
            if self.connection.get_hypervisor_type() == "Xen":
                autostart_file = "%s/%s" %(VIRT_XENDOMAINS_AUTO_DIR,self.get_domain_name())

                if flag == True:
                    if not os.path.exists(autostart_file):
                        command_args = [
                        "/bin/ln", "-s",
                        "%s/%s" %(self.connection.config_dir,self.get_domain_name()),
                        "%s" % VIRT_XENDOMAINS_AUTO_DIR
                        ]
                        ret = ExecCmd(command_args)
                    return True
                elif flag == False:
                    if os.path.exists(autostart_file):
                        os.unlink(autostart_file)
                    return True
                else:
                    return os.path.lexists(autostart_file)

            elif self.connection.get_hypervisor_type() == "QEMU":
                autostart_file = "%s/%s.xml" %(VIRT_AUTOSTART_CONFIG_DIR,self.get_domain_name())
                if flag == True:
                    return dom.setAutostart(flag)
                elif flag == False:
                    return dom.setAutostart(flag)
                else:
                    return os.path.exists(autostart_file)

        else:
            if flag == True:
                return dom.setAutostart(flag)
            elif flag == False:
                return dom.setAutostart(flag)

        return False

    def next_disk_target(self,bus=None):
        dom = self._conn.lookupByName(self.get_domain_name())
        serials = []

        param = ConfigParam(dom.name())
        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, dom.name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if bus is None:
            bus = self.connection.bus_types[0]

        if bus == "virtio":
            prefix_regex = "vd"
        elif bus == "scsi":
            prefix_regex = "sd"
        else:
            prefix_regex = "hd|xvd"

        prefix = None
        for info in param.disks:
            block_name = info['target']
            p = re.compile(r"""^(?P<prefix>%s)(?P<serial>[a-z])$""" % prefix_regex)
            m = p.match(block_name)
            if m is not None:
                prefix = m.group("prefix")
                serials.append(m.group("serial"))

        if prefix is None:
            prefix = prefix_regex

        for i,_x in enumerate('abcdefghijklmnopqrstuvwxyz'):
          if not _x in serials:
            next_serial = _x
            break

        return "%s%s" %(prefix, next_serial)

    """This is unused method
    def add_disk(self, path, target, size, is_sparse=True, bus=None,
                 driver_name=None, driver_type=None):
        name = self.get_domain_name()

        # TODO VIRT_DOMAINS_DIR
        domain_disk_dir = "%s/%s/disk" % (VIRT_DOMAINS_DIR,name,)
        if not os.path.exists(domain_disk_dir):
            os.makedirs(domain_disk_dir)

        if bus is None:
            bus = self.connection.bus_types[0]

        if driver_type is None:
            if driver_name == "qemu":
                driver_type = "qcow2"
            else:
                driver_type = "raw"

        try:
            MakeDiskImage(path,int(size),driver_type, is_sparse)
            return self.append_disk(path, target, bus,
                                    driver_name=driver_name, driver_type=driver_type)
        except:
            if os.path.exists(path) is True:
                os.remove(path)
            raise
    """

    def append_disk(self, path, target, bus=None, disk_type=None, driver_name=None, driver_type=None, disk_device='disk'):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if bus is None:
            bus = self.connection.bus_types[0]

        if disk_type != 'block':
            if driver_name is None:
                if self.connection.get_hypervisor_type() == "QEMU":
                    driver_name = "qemu"
            if driver_type is None:
                if driver_name == "qemu":
                    driver_type = "qcow2"

        param.add_disk(path,
                       target,
                       disk_device,
                       bus,
                       disk_type=disk_type,
                       driver_name=driver_name,
                       driver_type=driver_type)

        try:
            from karesansui.lib.virt.config import XMLDiskConfigGenerator
            generator = XMLDiskConfigGenerator()
            generator.set_path(path)
            generator.set_target(target)
            cfg = generator.generate(None)

            # qemu: cannot attach device on inactive domain
            if self.connection.get_hypervisor_type() == "QEMU" and dom.isActive() == 0:
                True
            # qemu: disk bus 'ide' cannot be hotplugged.
            elif self.connection.get_hypervisor_type() == "QEMU" and bus is not None and bus == "ide":
                True
            """Do not attach device whatever domain is active or not.
            else:
                dom.attachDevice(cfg)
            """

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)
        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def delete_disk(self, target):
        status = self.status()
        if status == VIR_DOMAIN_PAUSED:
            self.resume()
            time.sleep(2)
            #raise KaresansuiVirtException("Domain %s is suspended." % self.get_domain_name())

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        path = param.get_disk_path(target)

        # physical disk remove
        if path is not None and os.path.exists(path) is True:
            try:
                os.remove(path)
            except:
                self.logger.info("You do not have a disk file. - %s" % path)
                raise
        param.delete_disk(target)

        try:
            from karesansui.lib.virt.config import XMLDiskConfigGenerator
            generator = XMLDiskConfigGenerator()
            generator.set_target(target)
            generator.set_path(path)
            cfg = generator.generate(None)

            """Do not detach device whatever domain is active or not.
            try:
                dom.detachDevice(cfg)
            except:
                xml_generator = XMLConfigGenerator()
                cfgxml = xml_generator.generate(param)
                self._conn.defineXML(cfgxml)
            """
            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)

            if status == VIR_DOMAIN_PAUSED:
                self.suspend()
        except KaresansuiConfigParamException, e:
            raise e
        except Exception, e:
            raise e

        sync_config_generator(param, self.get_domain_name())

    def append_interface(self,mac,bridge=None,network=None,model=None):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if network is not None:
            netinfo = self.connection.search_kvn_networks(network)[0].get_info()
            bridge = netinfo['bridge']['name']

        if bridge[0:5] == 'xenbr':
            script = "vif-bridge"
            model  = None
        else:
            script = None
            model  = "virtio"
        mac = mac.lower()
        param.add_interface(mac,"bridge",bridge,script,model=model)

        try:
            from karesansui.lib.virt.config import XMLInterfaceConfigGenerator
            generator = XMLInterfaceConfigGenerator()
            generator.set_mac(mac)
            generator.set_bridge(bridge)
            if script is not None:
                generator.set_script(script)
            cfg = generator.generate(None)

            # qemu: cannot attach device on inactive domain
            if self.connection.get_hypervisor_type() == "QEMU" and dom.isActive() == 0:
                True
            else:
                dom.attachDevice(cfg)

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)

        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def delete_interface(self,mac,force=False):

        status = self.status()
        if status == VIR_DOMAIN_PAUSED:
            self.resume()
            time.sleep(2)
            #raise KaresansuiVirtException("Domain %s is suspended." % self.get_domain_name())

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        current_snapshot = param.get_current_snapshot()
        if force is True:
            param.load_xml_config(dom.XMLDesc(0))
            if current_snapshot is not None:
                param.set_current_snapshot(current_snapshot)

        bridge = None
        for info in param.interfaces:
            if info["mac"] == mac:
                bridge = info['bridge']

        bridge = None
        if bridge is None:
            param.load_xml_config(dom.XMLDesc(0))
            for info in param.interfaces:
                if info["mac"] == mac:
                    bridge = info['bridge']

        mac = mac.lower()
        param.delete_interface(mac)

        try:
            from karesansui.lib.virt.config import XMLInterfaceConfigGenerator
            generator = XMLInterfaceConfigGenerator()
            generator.set_mac(mac)
            if bridge is not None:
                generator.set_bridge(bridge)
            cfg = generator.generate(None)

            if self.connection.get_hypervisor_type() == "Xen":
                try:
                    dom.detachDevice(cfg)
                except:
                    pass

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)

            if status == VIR_DOMAIN_PAUSED:
                self.suspend()
        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def modify_mac_address(self,old,new):

        status = self.status()
        if status == VIR_DOMAIN_PAUSED:
            self.resume()
            time.sleep(2)
            #raise KaresansuiVirtException("Domain %s is suspended." % self.get_domain_name())

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        new_interfaces = []

        old = old.lower()
        new = new.lower()
        for info in param.interfaces:
            if info["mac"] == old:
                bridge = info['bridge']
                info["mac"] = new
            new_interfaces.append(info)
        param.interfaces = new_interfaces

        try:
            """
            try:
                self.delete_interface(old,True)
                self.append_interface(new,bridge)
            except:
                xml_generator = XMLConfigGenerator()
                cfgxml = xml_generator.generate(param)
                self._conn.defineXML(cfgxml)
            """
            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)

            if status == VIR_DOMAIN_PAUSED:
                self.suspend()
        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def set_memory(self,maxmem=None,memory=None):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if maxmem:
            param.set_max_memory(maxmem)
        if memory:
            param.set_memory(memory)

        try:
            dom.setMaxMemory(param.get_max_memory("k"))
            dom.setMemory(param.get_memory("k"))

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)
        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def set_vcpus(self,max_vcpus=None,vcpus=None):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if max_vcpus is not None:
            param.set_max_vcpus(int(max_vcpus))

        if vcpus is not None:
            param.set_vcpus(int(vcpus))

        param.set_max_vcpus_limit(int(self.connection.get_max_vcpus()))
        param.set_vcpus_limit(int(self.get_vcpus_info()['max_vcpus']))

        try:
            # qemu: cannot change vcpu count of an active domain
            if self.connection.get_hypervisor_type() == "QEMU" and dom.isActive() == 1:
                True
            else:
                dom.setVcpus(param.get_vcpus())

            xml_generator = XMLConfigGenerator()
            cfgxml = xml_generator.generate(param)
            self._conn.defineXML(cfgxml)
        except:
            raise

        sync_config_generator(param, self.get_domain_name())

    def set_graphics(self,port=None,listen=None,passwd=None,keymap=None,type='vnc'):

        from karesansui.lib.virt.config import ConfigParam
        param = ConfigParam(self.get_domain_name())
        dom = self._conn.lookupByName(self.get_domain_name())

        xml_file = "%s/%s.xml" % (VIRT_XML_CONFIG_DIR, self.get_domain_name())
        if not os.path.exists(xml_file):
            if dom._conn.getURI() in available_virt_uris().values():
                ConfigFile(xml_file).write(dom.XMLDesc(0))
                if os.getuid() == 0 and os.path.exists(xml_file):
                    r_chgrp(xml_file,KARESANSUI_GROUP)
        #param.load_xml_config(xml_file)
        param.load_xml_config(dom.XMLDesc(VIR_DOMAIN_XML_INACTIVE))

        if port is not None:
            param.set_graphics_port(port)

        if listen is not None:
            param.set_graphics_listen(listen)

        if passwd is not None:
            param.set_graphics_passwd(passwd)

        if keymap is not None:
            param.set_graphics_keymap(keymap)

        if type is not None:
            param.set_graphics_type(type)

        xml_generator = XMLConfigGenerator()
        cfgxml = xml_generator.generate(param)
        self._conn.defineXML(cfgxml)

        sync_config_generator(param, self.get_domain_name())

    def is_creatable(self):
        """<comment-ja>
        ゲストOS(ドメイン)を起動することができるか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.status() == VIR_DOMAIN_SHUTOFF:
            return True
        else:
            return False

    def is_shutdownable(self):
        """<comment-ja>
        ゲストOS(ドメイン)をシャットダウンすることができるか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        
        status = self.status()
        if status == VIR_DOMAIN_RUNNING \
               or status == VIR_DOMAIN_BLOCKED \
               or status == VIR_DOMAIN_PAUSED:
            return True
        else:
            return False

    def is_destroyable(self):
        """<comment-ja>
        ゲストOS(ドメイン)を強制停止することができるか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        status = self.status()
        if status == VIR_DOMAIN_RUNNING \
               or status == VIR_DOMAIN_BLOCKED \
               or status == VIR_DOMAIN_PAUSED:
            return True
        else:
            return False

    def is_suspendable(self):
        """<comment-ja>
        ゲストOS(ドメイン)の一時停止することができるか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        status = self.status()
        if status == VIR_DOMAIN_NOSTATE \
               or status ==VIR_DOMAIN_RUNNING \
               or status == VIR_DOMAIN_BLOCKED:
            return True
        else:
            return False

    def is_resumable(self):
        """<comment-ja>
        ゲストOS(ドメイン)再開することができるか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.status() == VIR_DOMAIN_PAUSED:
            return True
        else:
            return False

    def is_active(self):
        """<comment-ja>
        ゲストOSの状態がactiveか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return (self.get_domain_name() in self.connection.list_active_guest())

    def is_inactive(self):
        """<comment-ja>
        ゲストOSの状態がinactiveか。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        return (self.get_domain_name() in self.connection.list_inactive_guest())

    def is_takable_snapshot(self):
        """<comment-ja>
        スナップショットを作成できる状態か。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        if self.status() == VIR_DOMAIN_SHUTOFF:
            return False
        else:
            return True

    
class KaresansuiVirtNetwork:

    def __init__(self, conn, name=None):
        self.connection = conn
        self._conn = self.connection._conn
        self.set_network_name(name)

    def set_network_name(self,name=None):
        self.network_name = name
    def get_network_name(self):
        return self.network_name

    def load(self):
        param = NetworkConfigParam(self.get_network_name())
        param.load_xml_config("%s/%s.xml" % (VIRT_NETWORK_CONFIG_DIR, self.get_network_name()))

    def start(self):
        net = self._conn.networkLookupByName(self.get_network_name())
        try:
            net.create()
        except libvirt.libvirtError, e:
            raise KaresansuiVirtException(_("Could not start network '%s' (%s)") % (self.network_name, e))

    def stop(self):
        net = self._conn.networkLookupByName(self.get_network_name())
        try:
            # now isActive() is deplicated.
            # if net.isActive() != 0:
            if net.name() in self._conn.listNetworks():
                net.destroy()
        except libvirt.libvirtError, e:
            raise KaresansuiVirtException(_("Could not stop network '%s' (%s)") % (self.network_name, e))

    def undefine(self):
        net = self._conn.networkLookupByName(self.get_network_name())
        net.undefine()

    def autostart(self, flag=None):
        net = self._conn.networkLookupByName(self.get_network_name())
        current_flag = net.autostart()
        if flag is None:
            return current_flag
        else:
            if current_flag != flag:
                return net.setAutostart(flag)
            else:
                return True

    def get_json(self):
        """<comment-ja>
        JSON形式でKaresansuiVirtNetwork情報を返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        
        ret = {}
        ret['name'] = self.get_network_name()
        ret.update(self.get_info())
        return ret

    def get_info(self):
        try:
            net = self._conn.networkLookupByName(self.get_network_name())
            autostart = net.autostart()
        except Exception, e:
            raise KaresansuiVirtException("Could not get network: %s"
                                            % str(e))

        param = NetworkConfigParam(self.get_network_name())
        xml_file = "%s/%s.xml" % (VIRT_NETWORK_CONFIG_DIR, self.get_network_name())
        if not os.path.exists(xml_file):
            ConfigFile(xml_file).write(net.XMLDesc(0))
            if os.getuid() == 0 and os.path.exists(xml_file):
                r_chgrp(xml_file,KARESANSUI_GROUP)
        param.load_xml_config(xml_file)


        name        = param.get_network_name()
        uuid        = param.get_uuid()
        bridge_name = param.get_bridge()
        bridge_stp  = param.get_bridge_stp()
        bridge_forwardDelay = param.get_bridge_forwardDelay()
        bridge = {
                   "name"        :bridge_name,
                   "stp"         :bridge_stp,
                   "forwardDelay":bridge_forwardDelay,
                 }

        dhcp_start = param.get_dhcp_start()
        dhcp_end   = param.get_dhcp_end()
        dhcp = {
                   "start":dhcp_start,
                   "end"  :dhcp_end,
               }

        ip_address = param.get_ipaddr()
        ip_netmask = param.get_netmask()
        ip = {
                   "address":ip_address,
                   "netmask":ip_netmask,
                   "dhcp"   :dhcp,
             }

        forward_dev  = param.get_forward_dev()
        forward_mode = param.get_forward_mode()
        forward = {
                   "mode":forward_mode,
                   "dev" :forward_dev,
             }

        is_active = self.is_active()

        return {
                "name"     :name,
                "uuid"     :uuid,
                "bridge"   :bridge,
                "dhcp"     :dhcp,
                "ip"       :ip,
                "forward"  :forward,
                "autostart":autostart,
                "is_active":is_active,
        }

    def get_network_config_param(self):
        return NetworkConfigParam(self.get_info())

    def is_active(self):
        return (self.network_name in self._conn.listNetworks())

    def is_inactive(self):
        return (self.network_name in self._conn.listDefinedNetworks())

class KaresansuiVirtStorage:

    def __init__(self, conn, name=None):
        self.connection = conn
        self._conn = self.connection._conn
        self.set_storage_name(name)

    def set_storage_name(self,name=None):
        self.storage_name = name

    def get_storage_name(self):
        return self.storage_name

class KaresansuiVirtStoragePool(KaresansuiVirtStorage):

    def build(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            return pool.build(libvirt.VIR_STORAGE_POOL_BUILD_NEW)
        except Exception, e:
            raise KaresansuiVirtException("Could not build storage pool: %s"
                                            % str(e))

    def create(self, name=None, flags=0):
        if name is not None:
            self.set_storage_name(name)
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            ret = pool.create(flags)
            pool.refresh(0)
            return ret
        except Exception, e:
            raise KaresansuiVirtException("Could not create storage pool: %s"
                                            % str(e))

    def start(self, cfgxml, flags, name=None):
        if name:
            self.set_storage_name(name)
            
        # define
        try:
            ret = self._conn.storagePoolDefineXML(cfgxml, flags) # virStoragePoolDefineXML
            #ret = libvirtmod.virStoragePoolCreateXML(self._conn._o,cfgxml, 0)
        except libvirt.libvirtError, e:
            raise KaresansuiVirtException("Could not start pool '%s' (%s)" \
                                          % (self.get_storage_name, e))
        ret1 = self.build()
        ret2 = self.create()
        return ret2

    def load(self):
        param = StoragePoolConfigParam(self.get_storage_name())
        param.load_xml_config("%s/%s.xml" \
                              % (VIRT_STORAGE_CONFIG_DIR, self.get_storage_name()))


    def destroy(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            return pool.destroy()
        except Exception, e:
            raise KaresansuiVirtException("Could not destroy storage pool: %s" \
                                            % str(e))

    def delete(self, flags):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            return pool.delete(flags)
        except Exception, e:
            raise KaresansuiVirtException("Could not delete storage pool: %s" \
                                            % str(e))

    def autostart(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        return pool.autostart()

    def is_autostart(self):
        ret = self.autostart()
        if ret == 0:
            return False # OFF
        elif ret == 1:
            return True # ON
        else:
            return None # ERR

    def set_autostart(self, flag=None):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        return pool.setAutostart(flag)

    def get_json(self):
        """<comment-ja>
        JSON形式でKaresansuiVirtNetwork情報を返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        ret = {}
        ret['name'] = self.get_storage_name()
        ret.update(self.get_info())
        return ret

    def get_info(self):
        try:
            pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        except Exception, e:
            raise KaresansuiVirtException("Could not get the storage pool: %s" \
                                            % str(e))

        param = StoragePoolConfigParam(self.get_storage_name())
        param.load_xml_config(pool.XMLDesc(0))
        return {"name" : param.get_storage_name(),
                "uuid" : param.get_uuid(),
                "type" : param.get_pool_type(),
                "allocation" : param.get_allocation(),
                "capacity" : param.get_capacity(),
                "available" : param.get_available(),
                "source" : {"dev_path" : param.get_source_dev_path(),
                            "dir_path" : param.get_source_dir_path(),
                            "h_name" : param.get_source_h_name(),
                            "f_type" : param.get_source_f_type(),
                            },
                "target" : {"path" : param.get_target_path(),
                            "p_owner" : param.get_target_permissions_owner(),
                            "p_group" : param.get_target_permissions_group(),
                            "p_mode" : param.get_target_permissions_mode(),
                            "p_label" : param.get_target_permissions_label(),
                            "e_format" : param.get_target_e_format(),
                            "e_s_type" : param.get_target_encryption_s_type(),
                            "e_s_uuid" : param.get_target_encryption_s_uuid(),
                            },
                "is_active"    : self.is_active(),
                "is_autostart" : self.is_autostart(),
            }

    def is_active(self):
        return (self.storage_name in self._conn.listStoragePools())

    def is_inactive(self):
        return (self.storage_name in self._conn.listdefinedStoragePools())

    def vol_createXML(self, xmldesc, flags):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            return pool.createXML(xmldesc, flags)
        except Exception, e:
            raise KaresansuiVirtException("Could not create storage volume: %s" % str(e))

    def vol_numOfVolumes(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        return pool.numOfVolumes()
        
    def vol_storageVolLookupByName(self, name):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        return pool.storageVolLookupByName(name)
        
    def vol_listVolumes(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        return pool.listVolumes()

    def search_kvn_storage_volumes(self, conn):
        vols_obj = []
        for vol in self.vol_listVolumes():
            vol_obj = KaresansuiVirtStorageVolume(conn)
            vol_obj.set_storage_name(self.get_storage_name())
            vol_obj.set_storage_volume_name(vol)
            
            vols_obj.append(vol_obj)
        return vols_obj

class KaresansuiVirtStorageVolume(KaresansuiVirtStorage):

    storage_volume_name = None

    def set_storage_volume_name(self,name=None):
        self.storage_volume_name = name

    def get_storage_volume_name(self):
        return self.storage_volume_name

    def load(self):
        param = StorageVolumeConfigParam(self.get_storage_volume_name())
        param.load_xml_config("%s/%s.xml" \
                              % (VIRT_STORAGE_CONFIG_DIR, self.get_storage_volume_name()))

    def delete(self, flags):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            vol = pool.storageVolLookupByName(self.get_storage_volume_name())
            return vol.delete(flags)
        except Exception, e:
            raise KaresansuiVirtException("Could not delete storage volume: %s"
                                            % str(e))

    def get_json(self):
        """<comment-ja>
        JSON形式でKaresansuiVirtNetwork情報を返却する。
        </comment-ja>
        <comment-en>
        TODO: English Comment
        </comment-en>
        """
        pass
        #ret = {}
        #ret['name'] = self.get_network_name()
        #ret.update(self.get_info())
        #return ret

    def get_info(self):
        pool = self._conn.storagePoolLookupByName(self.get_storage_name())
        try:
            vol = pool.storageVolLookupByName(self.get_storage_volume_name())
        except Exception, e:
            raise KaresansuiVirtException("Could not get the storage volume: %s"
                                            % str(e))

        param = StorageVolumeConfigParam(self.get_storage_name())
        try:
            param.load_xml_config(vol.XMLDesc(0))
        except libvirt.libvirtError, le:
            # TODO test!!
            self.connection.refresh_pools()
            param.load_xml_config(vol.XMLDesc(0))

        real = param.get_symlink2real()
        return {"name" : param.get_storage_name(),
                "uuid" : param.get_uuid(),
                "key" : param.get_key(),
                "allocation" : param.get_allocation(),
                "capacity" : param.get_capacity(),
                "c_unit" : param.get_c_unit(),
                "source" : param.get_source(),
                "target" : {"path" : param.get_target_path(),
                            "f_type" : param.get_target_f_type(),
                            "p_owner" : param.get_target_permissions_owner(),
                            "p_group" : param.get_target_permissions_group(),
                            "p_mode" : param.get_target_permissions_mode(),
                            "p_label" : param.get_target_permissions_label(),
                            "b_path" : param.get_backingStore_path(),
                            "b_format" : param.get_backingStore_format(),
                            "b_p_owner" : param.get_backingStore_permissions_owner(),
                            "b_p_group" : param.get_backingStore_permissions_group(),
                            "b_p_mode" : param.get_backingStore_permissions_mode(),
                            "b_p_label" : param.get_backingStore_permissions_label(),
                            },
                "real" : {"dir" : real[0],
                          "name" : real[1],
                          "extension" : real[2],
                          },
                }


def getCredentials(credentials, data):

    userpass = data.split(":")

    for credential in credentials:

        if credential[0] == libvirt.VIR_CRED_AUTHNAME:
            credential[4] = userpass[0]

        elif credential[0] == libvirt.VIR_CRED_PASSPHRASE:
            credential[4] = userpass[1]

        else:
            return -1

    return 0


class KaresansuiVirtConnectionAuth(KaresansuiVirtConnection):

    def __init__(self,uri=None,creds="", readonly=True):
        self.logger = logging.getLogger('karesansui.virt')
        self.logger.debug(get_inspect_stack())
        try:
            self.open(uri, creds)
        except:
            raise KaresansuiVirtException(_("Cannot open '%s'") % uri_join(uri_split(uri.encode('utf8')), without_auth=True))

    def open(self, uri, creds="foo:pass"):
        """
        <comment-ja>
        libvirtのコネクションをOpenします。またそれに伴う初期化も行います。
        </comment-ja>
        <comment-en>
        </comment-en>
        """

        if uri != None:
            self.uri = uri

        try:
            self.logger.debug('libvirt.open - %s' % self.uri)

            flags = [libvirt.VIR_CRED_AUTHNAME,libvirt.VIR_CRED_PASSPHRASE]
            auth = [flags,getCredentials,creds]
            self._conn = libvirt.openAuth(self.uri,auth,0)

        except:
            self.logger.error('failed to libvirt open - %s' % self.uri)

        self.logger.debug('succeed to libvirt open - %s' % self.uri)

        self.guest = KaresansuiVirtGuest(self)

        return self._conn


if __name__ == '__main__':
    from karesansui.lib.utils import preprint_r

    conn = KaresansuiVirtConnection(readonly=False)
    try:
        pass
        #print conn.get_storage_pool_type("default")
        #preprint_r(conn.get_capabilities())
        #print conn.get_storage_pool_name_bydomain("test3-iscsi-1-mount.hoge.com",image_type='os')
        #print conn.get_storage_pool_name_bydomain("guest1",image_type='')
        #print conn.get_storage_pool_name_bydomain("centos55",image_type='')
        #print conn.get_storage_volume_bypool("default",attr="info")
        #print conn.get_storage_volume_bypool("default",attr="name")
        #print conn.get_storage_volume_bydomain("centos55",image_type=None, attr="name")
        #print conn.get_storage_volume_bydomain("centos55",image_type=None, attr="path")
        #print conn.get_storage_volume_bydomain("centos55",image_type="os", attr="info")
        #print conn.get_storage_volume_bydomain("centos55",image_type="os", attr="name")
        #print conn.get_storage_volume_bydomain("centos55",image_type="disk", attr="name")
        #print conn.get_storage_pool_name_byimage("/var/lib/libvirt/domains/guest1/images/guest1.img")
        #print conn.list_used_graphics_port()
        #print conn.list_used_mac_addr()

        #kvg = conn.search_kvg_guests("centos55")[0]
        #preprint_r(kvg.get_info())
        #preprint_r(kvg.get_disk_info())
        #conn.import_guest("/var/lib/libvirt/domains/527109d0-cb91-7308-ad39-7738c1893dc9", uuid=None, progresscb=None)
        #preprint_r(kvg.get_vcpus_info())
        #preprint_r(kvg.get_interface_info())
        #preprint_r(kvg.get_graphics_info())
        #print kvg.next_disk_target()
        #print kvg.delete_interface("52:54:00:0f:cb:6a")

        #kvn = conn.search_kvn_networks("default")[0]
        #preprint_r(kvn.get_info())

        #print conn.get_hypervisor_type()
        #print conn.get_hypervisor_type_bydomain("guest1")

    except:
        raise


########NEW FILE########
__FILENAME__ = prep
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys
import os.path
from os import environ as env
import traceback
from optparse import OptionParser, OptionValueError

try:
    import karesansui
except ImportError:
    import __init__ as karesansui

from karesansui.lib.utils import is_uuid, is_int
from lib.file.k2v import K2V 

usage = "%prog [options]"
version = 'karesansui %s' % karesansui.__version__

def getopts():
    """<comment-ja>
    コマンドラインオプションの解析
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    
    optp = OptionParser(usage=usage, version=version)
    optp.add_option('-c', '--config', dest='cf', help='Configuration file of application')
    optp.add_option('-s', '--shell', dest='shell', action="store_true", help='Start at the terminal.(IPython)')
    return optp.parse_args()

def chkopts(opts):
    """<comment-ja>
    コマンドラインオプションチェック
    @param opts: コマンドラインオプション
    @type opts: OptionParser#parse_args()
    @rtype: bool
    @return: チェック結果
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    if not opts.cf:
        print >>sys.stderr, '%s: --config is required.' % karesansui.__app__
        return True

    if os.path.isfile(opts.cf) is False:
        print >>sys.stderr, '-c or --config file is specified in the option does not exist.'
        return True

def chkconfig(config):
    """<comment-ja>
    Karesansui設定ファイル情報をチェックします。
    @param config: 設定ファイル情報
    @type config: dict
    @rtype: bool
    @return: チェック結果
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    check = True

    # application.log.config
    if check and config.has_key("application.log.config") is False:
        print >>sys.stderr, 'Configuration information is missing. - application.log.config'
        check = False

    if check and os.path.isfile(config["application.log.config"]) is False:
        print >>sys.stderr, 'There is a mistake in the configuration information. - application.log.config=%s' % config["application.log.config"]
        check = False

    # application.tmp.dir
    if check and config.has_key("application.tmp.dir") is False:
        print >>sys.stderr, 'Configuration information is missing. - application.tmp.dir'
        check = False

    if check and os.path.isdir(config["application.tmp.dir"]) is False:
        print >>sys.stderr, 'There is a mistake in the configuration information. - application.tmp.dir=%s' % config["application.tmp.dir"]
        check = False

    if check and os.access(config["application.tmp.dir"], os.R_OK | os.W_OK) is False:
        print >>sys.stderr, 'Not set the appropriate permissions to that directory. - application.tmp.dir=%s' % config["application.tmp.dir"]
        check = False

    # application.bin.dir
    if check and config.has_key("application.bin.dir") is False:
        print >>sys.stderr, 'Configuration information is missing. - application.bin.dir'
        check = False

    if check and os.path.isdir(config["application.bin.dir"]) is False:
        print >>sys.stderr, 'There is a mistake in the configuration information. - application.bin.dir=%s' % config["application.bin.dir"]
        check = False

    if check and os.access(config["application.bin.dir"], os.R_OK) is False:
        print >>sys.stderr, 'Not set the appropriate permissions to that directory. - application.bin.dir=%s' % config["application.bin.dir"]
        check = False

    # pysilhouette.conf.path
    if check and config.has_key("pysilhouette.conf.path") is False:
        print >>sys.stderr, 'Configuration information is missing. - pysilhouette.conf.path'
        check = False
        
    if check and os.path.isfile(config["pysilhouette.conf.path"]) is False:
        print >>sys.stderr, 'There is a mistake in the configuration information. - pysilhouette.conf.path=%s' % config["pysilhouette.conf.path"]
        check = False

    if check and os.access(config["pysilhouette.conf.path"], os.R_OK) is False:
        print >>sys.stderr, 'Not set the appropriate permissions to that file. - pysilhouette.conf.path=%s' % config["pysilhouette.conf.path"]
        check = False

    # application.uniqkey
    if check and config.has_key("application.uniqkey") is False:
        print >>sys.stderr, 'Configuration information is missing. - application.uniqkey'
        check = False

    if check and is_uuid(config["application.uniqkey"]) is False:
        print >>sys.stderr, 'UUID format is not set. - application.uniqkey'
        check = False

    # database.pool.status
    if check and config.has_key("database.pool.status") is False:
        print >>sys.stderr, 'Configuration information is missing. - database.pool.status'
        check = False

    if check and (config["database.pool.status"] in ("0","1")) is False:
        print >>sys.stderr, 'The mistake is found in the set value. Please set 0 or 1. - database.pool.status'
        check = False

    if check and config["database.pool.status"] == "1":
        # database.pool.max.overflow
        if check and config.has_key("database.pool.max.overflow") is False:
            print >>sys.stderr, 'Configuration information is missing. - database.pool.max.overflow'
            check = False

        # database.pool.size
        if check and config.has_key("database.pool.size") is False:
            print >>sys.stderr, 'Configuration information is missing. - database.pool.size'
            check = False

        # int
        if check and is_int(config["database.pool.max.overflow"]) is False:
            print >>sys.stderr, 'Please set it by the numerical value. - database.pool.max.overflow'
            check = False

        if check and is_int(config["database.pool.size"]) is False:
            print >>sys.stderr, 'Please set it by the numerical value. - database.pool.size'
            check = False

        if check and int(config["database.pool.size"]) <= 0:
            print >>sys.stderr, 'Please set values that are larger than 0. - database.pool.size'
            check = False

        # Comparison
        if check and int(config["database.pool.max.overflow"]) < int(config["database.pool.size"]):
            print >>sys.stderr, 'Please set "database.pool.max.overflow" to a value that is larger than "database.pool.size".'
            check = False

    return check

def built_in():
    """<comment-ja>
    built-in Web Server 起動処理
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # Built-in Web server
    conf = ''
    (opts, args) = getopts()
    if opts.cf: # option
        if chkopts(opts): sys.exit(1)
        conf = opts.cf
        env['KARESANSUI_CONF'] = conf
    elif env.get('KARESANSUI_CONF'): # envrion
        conf = env.get('KARESANSUI_CONF')
    else: #error
        print >>sys.stderr, '[built_in] Please specify the configuration file. - Please set the environment variable that "KARESANSUI_CONF". Otherwise, please set the command option that "-c or --config".'
        sys.exit(1)

    config = None
    if conf: # read file
        conf = os.path.abspath(conf)
        _k2v = K2V(conf)
        config = _k2v.read()
    else: # error
        print >>sys.stderr, '[built_in] Please specify the configuration file. - Environment variables or command-option'
        sys.exit(1)

#    if env.has_key('SEARCH_PATH'):
#        for y in [x.strip() for x in env.get('SEARCH_PATH').split(',') if x]:
#            if (y in sys.path) is False: sys.path.insert(0, y)

    if config and config.has_key('application.search.path'):
        for y in [x.strip() for x in config['application.search.path'].split(',') if x]:
            if (y in sys.path) is False: sys.path.insert(0, y)

    import karesansui
    karesansui.config = config
    return config, opts, args

def fcgi():
    """<comment-ja>
    外部Web Server(FastCGI) 起動処理
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # WebServer(fcgi)
    conf = ''
    if env.get('KARESANSUI_CONF'): # envrion
        conf = env.get('KARESANSUI_CONF')
    else: #error
        print >>sys.stderr, '[fcgi] Please specify the configuration file. - Please set the environment variable that "KARESANSUI_CONF".'
        sys.exit(1)

    config = None
    if conf: # read file
        _k2v = K2V(conf)
        config = _k2v.read()

    try:
        import flup
    except ImportError, e:
        print >>sys.stderr, '[Error] There are not enough libraries.(fcgi) - %s' % ''.join(e.args)
        traceback.format_exc()
        sys.exit(1)


    if config and config.has_key('application.search.path'):
        for y in [x.strip() for x in config['application.search.path'].split(',') if x]:
            if (y in sys.path) is False: sys.path.insert(0, y)

#    if env.has_key('SEARCH_PATH'):
#        for y in [x.strip() for x in env.get('SEARCH_PATH').split(',') if x]:
#            if (y in sys.path) is False: sys.path.insert(0, y)

    import karesansui
    karesansui.config = config
    return config , None, None

def create__cmd__(config, conf):
    """<comment-ja>
    Karesansuiで使用する実行コマンドで使用する__cmd__.pyを生成する。
    生成場所: 'application.bin.dir'
    </comment-ja>
    <comment-en>
    TODO: English Comment
    </comment-en>
    """
    # create __cmd__.py file
    from lib.file.configfile import ConfigFile
    from lib.utils import r_chgrp
    from lib.const import KARESANSUI_GROUP

    command_py = "%s/__cmd__.py" % config['application.bin.dir']
    ConfigFile(command_py).write("""#!/usr/bin/env python
# -*- coding: utf-8 -*-

karesansui_conf = '%s'
search_path = '%s'
pysilhouette_conf = '%s'

""" % (conf, config['application.search.path'], config['pysilhouette.conf.path']))
    
    if os.path.exists(command_py) and os.getuid() == 0:
        r_chgrp(command_py,KARESANSUI_GROUP)

def have_privilege(msg=True):
    """<comment-ja>
    実行可能ユーザーかどうかの判定
    </comment-ja>
    <comment-en>
    Return True if the current process should be able to run karesansui.
    </comment-en>
    """
    import os
    import pwd, grp
    from lib.const import KARESANSUI_USER, KARESANSUI_GROUP

    try:
        ok_gr = grp.getgrnam(KARESANSUI_GROUP)[3]
        ok_gr.append(grp.getgrgid(pwd.getpwnam(KARESANSUI_USER)[3])[0])
    except:
        ok_gr = []

    ret = (grp.getgrgid(os.getgid())[0] in ok_gr)
    if ret is False and msg is True:
        print >>sys.stderr, """
# chgrp -R %s %s
# chmod -R g+w %s
# chgrp -R %s %s
# chmod -R g+w %s
Or check permission of the following directories.
* log file directory
* configuration file directory
""" % (KARESANSUI_GROUP,karesansui.config['application.bin.dir'],karesansui.config['application.bin.dir'], KARESANSUI_GROUP,os.path.dirname(__file__),os.path.dirname(__file__),
)
    return ret

if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = testk2v
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import unittest
import tempfile

from karesansui.lib.file.k2v import *

class TestK2V(unittest.TestCase):

    _w = {'key.1':'h oge',
         'key.2':'fo o',
         'key.3':'bar ',
         'key.4':' piyo',
         'key.5':'s p am'}

    def setUp(self):
        self._tmpfile = tempfile.mkstemp()
        fp = open(self._tmpfile[1], 'w')
        self._t = K2V(self._tmpfile[1])
    
    def tearDown(self):
        os.unlink(self._tmpfile[1])

    def test_write_0(self):
        _d = self._t.write(self._w)
        for i in xrange(1,6):
            self.assertEqual(self._w['key.%d'%i],_d['key.%d'%i])

    def test_read_0(self):
        _d = self._t.read()
        for i in xrange(1,6):
            self.assertEqual(self._w['key.%d'%i],_d['key.%d'%i])
        
    def test_lock_sh_0(self):
        self.fail('TODO:')

    def test_lock_ex_0(self):
        self.fail('TODO:')

    def test_lock_un_0(self):
        self.fail('TODO:')

        
class SuiteK2V(unittest.TestSuite):
    def __init__(self):
        tests = ['test_write_0', 'test_read_0',
                 'test_lock_ex_0', 'test_lock_un_0']
        unittest.TestSuite.__init__(self,map(TestK2V, tests))

def all_suite_k2v():
    return unittest.TestSuite([SuiteK2V()])

def main():
    unittest.TextTestRunner(verbosity=2).run(all_suite_k2v())
    
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = http
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import unittest
import re

from karesansui.lib.net.http import *
import karesansui.lib.net.http
_wget_proxy = karesansui.lib.net.http._wget_proxy

class TestHttp(unittest.TestCase):

    def setUp(self):
      return True

    def tearDown(self):
      return True

    def test__wget_proxy_1(self):
        url="http://ftp.jaist.ac.jp/pub/Linux/CentOS/5.3/os/x86_64/images/xen/initrd.img"
        file="/tmp/karesansui_test__wget_proxy_1"
        proxy_host="foo.example.com"
        proxy_port="80"
        user="hayashi"
        password="hayashi"
        
        _wget_proxy(url,file,proxy_host,proxy_port,user,password)

    def test__wget_proxy_2(self):
        url="http://ftp.jaist.ac.jp/pub/Linux/CentOS/5.3/os/x86_64/images/xen/initrd.img"
        file="/tmp/karesansui_test__wget_proxy_2"
        proxy_host="foo.example.com"
        proxy_port="80"
        user="nopass"
        password=None
        
        _wget_proxy(url,file,proxy_host,proxy_port,user,password)

    def test__wget_proxy_3(self):
        url="http://ftp.jaist.ac.jp/pub/Linux/CentOS/5.3/os/x86_64/images/xen/initrd.img"
        file="/tmp/karesansui_test__wget_proxy_3"
        proxy_host="foo.example.com"
        proxy_port="9080"
        user=None
        password=None
        
        _wget_proxy(url,file,proxy_host,proxy_port,user,password)

    def test__wget_proxy_4(self):
        url="http://ftp.jaist.ac.jp/pub/Linux/CentOS/5.3/os/x86_64/images/xen/initrd.img"
        file="/tmp/karesansui_test__wget_proxy_4"
        proxy_host="foo.example.com"
        proxy_port="9080"
        user=None
        password=None
        
        _wget_proxy(url,file,proxy_host,proxy_port,user,password)

class SuiteHttp(unittest.TestSuite):
    def __init__(self):
        tests = ['test__wget_proxy_1',
                 'test__wget_proxy_2',
                 'test__wget_proxy_3',
                 'test__wget_proxy_4',
                 ]
        unittest.TestSuite.__init__(self,map(TestHttp, tests))

def all_suite_http():
    return unittest.TestSuite([SuiteHttp()])

def main():
    unittest.TextTestRunner(verbosity=2).run(all_suite_http())
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = networkaddress
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import unittest
import re

from karesansui.lib.networkaddress import *

class TestNetworkAddress(unittest.TestCase):

    _targets = {'valid_ipaddr0':'1.2.3.4',
                'valid_ipaddr1':'192.168.0.4',
                'invalid_ipaddr0':'1.2.3.256',
                'invalid_ipaddr1':'.2.3.256',
                'valid_cidr0':'1.2.3.0/24',
                'valid_cidr1':'192.168.0.0/16',
                'invalid_cidr0':'1.2.3.0/33',
                'invalid_cidr1':'1.2.3/33',
                'valid_netmask0':'255.255.0.0',
                'valid_netmask1':'255.255.255.128',
                'invalid_netmask0':'255.256.1.1',
                'invalid_netmask1':'255.255.',
                }

    def setUp(self):
      return True

    def tearDown(self):
      return True

    def test_valid_addr(self):
        for target in self._targets.keys():
          p = re.compile("^valid_")
          if p.match(target):
            self._t = NetworkAddress(self._targets[target])
            self.assertEqual(self._t.valid_addr(),True)

    def test_invalid_addr(self):
        for target in self._targets.keys():
          p = re.compile("^invalid_")
          if p.match(target):
            self._t = NetworkAddress(self._targets[target])
            self.assertEqual(self._t.valid_addr(),False)

    def test_valid_netlen(self):
        for i in xrange(0,32):
            self._t = NetworkAddress()
            self.assertEqual(self._t.valid_netlen(i),True)
 
    def test_invalid_netlen(self):
        for i in xrange(33,35):
            self._t = NetworkAddress()
            self.assertEqual(self._t.valid_netlen(i),False)

    def test_valid_netmask(self):
        for target in self._targets.keys():
          p = re.compile("^valid_netmask")
          if p.match(target):
            self._t = NetworkAddress()
            self.assertEqual(self._t.valid_netmask(self._targets[target]),True)
 
    def test_invalid_netmask(self):
        for target in self._targets.keys():
          p = re.compile("^invalid_netmask")
          if p.match(target):
            self._t = NetworkAddress()
            self.assertEqual(self._t.valid_netmask(self._targets[target]),False)
 
class SuiteNetworkAddress(unittest.TestSuite):
    def __init__(self):
        tests = ['test_valid_addr', 'test_invalid_addr',
                 'test_valid_netlen', 'test_invalid_netlen',
                 'test_valid_netmask', 'test_invalid_netmask',
                 ]
        unittest.TestSuite.__init__(self,map(TestNetworkAddress, tests))

def all_suite_networkaddress():
    return unittest.TestSuite([SuiteNetworkAddress()])

def main():
    unittest.TextTestRunner(verbosity=2).run(all_suite_networkaddress())
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import unittest
import re

from karesansui.lib.utils import *

class TestUtils(unittest.TestCase):

    def setUp(self):
      return True

    def tearDown(self):
      return True

    def test_dummy(self):
        self.assertEqual(True,True)
 
    def test_dotsplit(self):
        ret = dotsplit("foo.bar.gah,goh")
        self.assertEqual(ret,("foo.bar", "gah,goh"))
 
    def test_toplist(self):
        ret = toplist("foo")
        self.assertEqual(ret,["foo",])
 
    def test_comma_split(self):
        ret = comma_split("1a,2b,3c,4d")
        self.assertEqual(ret,["1a","2b","3c","4d"])
 
    def test_uniq_sort(self):
        ret = uniq_sort(["z1","z0","a1","19","21","20","19"])
        self.assertEqual(ret,["19","20","21","a1","z0","z1"])
 
    def test_dec2hex(self):
        self.assertEqual(dec2hex(10),"A")
 
    def test_dec2oct(self):
        self.assertEqual(dec2oct(10),"12")
 
    def test_hex2dec(self):
        self.assertEqual(hex2dec("A"),10)
 
    def test_oct2dec(self):
        self.assertEqual(oct2dec("12"),10)

    def test_next_number(self):
        ret = next_number(10,20,[10,11,12,13])
        self.assertEqual(ret,14)

    def test_generate_uuid(self):
        uuid = string_from_uuid(generate_uuid())
        self.assertEqual(is_uuid(uuid),True)

    def test_generate_uuid_reverse(self):
        old_uuid = generate_uuid()
        uuid_str = string_from_uuid(old_uuid)
        new_uuid = string_to_uuid(uuid_str)
        self.assertEqual(old_uuid,new_uuid)

    def test_generate_mac_address(self):
        addr = generate_mac_address()
        regex = '^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$'
        m = re.compile(regex).search(addr)
        self.assertNotEqual(m,None)

    def test_execute_command_success(self):
        ret,res = execute_command(["ls","-l"])
        self.assertEqual(ret,0)

    def test_execute_command_failure(self):
        ret,res = execute_command(["invalid_command","-l"])
        self.assertNotEqual(ret,0)

class SuiteUtils(unittest.TestSuite):
    def __init__(self):
        tests = ['test_dummy',
                 'test_dotsplit',
                 'test_toplist',
                 'test_comma_split',
                 'test_uniq_sort',
                 'test_dec2hex',
                 'test_dec2oct',
                 'test_hex2dec',
                 'test_oct2dec',
                 'test_next_number',
                 'test_generate_uuid',
                 'test_generate_uuid_reverse',
                 'test_generate_mac_address',
                 'test_execute_command_success',
                 'test_execute_command_failure',
                 ]
        unittest.TestSuite.__init__(self,map(TestUtils, tests))

def all_suite_utils():
    return unittest.TestSuite([SuiteUtils()])

def main():
    unittest.TextTestRunner(verbosity=2).run(all_suite_utils())
    
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_list
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from nose.tools import *

from karesansui.lib.utils import *

def assert_regexp_matches(text, regexp):
    import re
    if isinstance(regexp, basestring):
        regexp = re.compile(regexp)
    if not regexp.search(text):
        message = '''Regexp didn't match: %r not found in %r''' % (regexp.pattern, text)
        raise AssertionError(message)

class TestList(object):

    def test_sample(self):
        numbers = xrange(10)
        eq_(len(numbers), 10)
        assert max(numbers) == 9
        assert_equal(sum(numbers), 45)

    def test_dotsplit(self):
        string_1 = "foo"
        string_2 = "foo.bar"
        string_3 = "foo.bar.hoge"
        assert_equal(dotsplit(string_1)[0], "foo")
        assert_equal(dotsplit(string_2)[0], "foo")
        assert_equal(dotsplit(string_2)[1], "bar")
        assert_equal(dotsplit(string_3)[0], "foo.bar")
        assert_equal(dotsplit(string_3)[1], "hoge")

    def test_ucfirst(self):
        string_lc = "abcdefg012345-./"
        string_uc = "ABCDEFG012345-./"
        assert_equal(ucfirst(string_lc)[0:4], "Abcd")
        assert_equal(ucfirst(string_uc)[0:4], "ABCD")

    def test_lcfirst(self):
        string_lc = "abcdefg012345-./"
        string_uc = "ABCDEFG012345-./"
        assert_equal(lcfirst(string_lc)[0:4], "abcd")
        assert_equal(lcfirst(string_uc)[0:4], "aBCD")

    def test_next_number(self):
        min = 10
        max = 20
        exclude_numbers = [10,11,12]
        min = 21
        max = 20
        exclude_numbers = [10,11,12]
        assert_equal(next_number(min,max,exclude_numbers), None)

    def test_is_uuid(self):
        uuid = string_from_uuid(generate_uuid())
        assert_equal(is_uuid(uuid), True)

        uuid_1 = generate_uuid()
        uuid_2 = generate_uuid()
        assert uuid_1 != uuid_2

    def test_file_type(self):
        assert_regexp_matches(file_type("/etc/hosts"),"ASCII .*text")
        assert_regexp_matches(file_type("/bin/ls"),"bit LSB executable")

def test_sample():
    numbers = xrange(10)
    assert_equal(len(numbers), 10)
    assert_equal(max(numbers), 9)
    assert_equal(sum(numbers), 45)

########NEW FILE########
__FILENAME__ = suite
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""<comment-ja>
全てのテストを実行する。
</comment-ja>
<comment-en>
TODO: English Comment
</comment-en>
"""

import unittest
from karesansui.tests.lib.file.testk2v import all_suite_k2v
from karesansui.tests.lib.networkaddress import all_suite_networkaddress
from karesansui.tests.lib.utils import all_suite_utils
from karesansui.tests.restapi import all_suite_restapi

ts = unittest.TestSuite()
ts.addTest(all_suite_k2v())
ts.addTest(all_suite_networkaddress())
ts.addTest(all_suite_utils())
ts.addTest(all_suite_restapi())
unittest.TextTestRunner(verbosity=2).run(ts)  

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui Core.
#
# Copyright (C) 2009-2012 HDE, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import web

import karesansui.gadget.index
import karesansui.gadget.data
import karesansui.gadget.user
import karesansui.gadget.userby1
import karesansui.gadget.me
import karesansui.gadget.job
import karesansui.gadget.logout
import karesansui.gadget.tree
import karesansui.gadget.console
import karesansui.gadget.mail
import karesansui.gadget.tag
import karesansui.gadget.msg
import karesansui.gadget.icon
import karesansui.gadget.about
import karesansui.gadget.host
import karesansui.gadget.hosttag
import karesansui.gadget.hostby1
import karesansui.gadget.hostby1job
import karesansui.gadget.hostby1firewall
import karesansui.gadget.hostby1firewallstatus
import karesansui.gadget.hostby1firewallpolicy
import karesansui.gadget.hostby1firewallrule
import karesansui.gadget.hostby1firewallruleby1
import karesansui.gadget.hostby1network
import karesansui.gadget.hostby1networkby1
import karesansui.gadget.hostby1networkby1status
import karesansui.gadget.hostby1setting
import karesansui.gadget.hostby1settingby1mail
import karesansui.gadget.hostby1settingby1proxy
import karesansui.gadget.hostby1networkstorage
import karesansui.gadget.hostby1networkstorageby1
import karesansui.gadget.hostby1networkstorageby1status
import karesansui.gadget.hostby1storagepool
import karesansui.gadget.hostby1storagepoolby1
import karesansui.gadget.hostby1storagepoolby1status
import karesansui.gadget.hostby1networksettings
import karesansui.gadget.hostby1networksettingsgeneral
import karesansui.gadget.hostby1networksettingsnicby1
import karesansui.gadget.hostby1iptables
import karesansui.gadget.hostby1iptablesstatus
import karesansui.gadget.hostby1staticroute
import karesansui.gadget.hostby1staticrouteby1
import karesansui.gadget.hostby1report
import karesansui.gadget.hostby1reportby1
import karesansui.gadget.hostby1reportby1by1
import karesansui.gadget.hostby1watch
import karesansui.gadget.hostby1watchby1
import karesansui.gadget.hostby1watchtemplate
import karesansui.gadget.hostby1service
import karesansui.gadget.hostby1serviceby1
import karesansui.gadget.hostby1serviceby1status
import karesansui.gadget.hostby1log
import karesansui.gadget.hostby1logby1
import karesansui.gadget.hostby1logby1appby1
import karesansui.gadget.guest
import karesansui.gadget.guesttag
import karesansui.gadget.guestreplicate
import karesansui.gadget.guestexport
import karesansui.gadget.guestexportby1
import karesansui.gadget.guestimport
import karesansui.gadget.guestby1
import karesansui.gadget.guestby1status
import karesansui.gadget.guestby1device
import karesansui.gadget.guestby1diskby1
import karesansui.gadget.guestby1nicby1
import karesansui.gadget.guestby1cpu
import karesansui.gadget.guestby1memory
import karesansui.gadget.guestby1graphics
import karesansui.gadget.guestby1snapshot
import karesansui.gadget.guestby1snapshotby1
import karesansui.gadget.guestby1currentsnapshot
import karesansui.gadget.guestby1job
import karesansui.gadget.uriguestby1
import karesansui.gadget.uriguestby1status
import karesansui.gadget.uriguestby1console
import karesansui.gadget.init

#: URL List
urls = karesansui.gadget.index.urls \
       + karesansui.gadget.data.urls \
       + karesansui.gadget.user.urls \
       + karesansui.gadget.userby1.urls \
       + karesansui.gadget.me.urls \
       + karesansui.gadget.job.urls \
       + karesansui.gadget.logout.urls \
       + karesansui.gadget.tree.urls \
       + karesansui.gadget.console.urls \
       + karesansui.gadget.mail.urls \
       + karesansui.gadget.tag.urls \
       + karesansui.gadget.msg.urls \
       + karesansui.gadget.icon.urls \
       + karesansui.gadget.about.urls \
       + karesansui.gadget.host.urls \
       + karesansui.gadget.hosttag.urls \
       + karesansui.gadget.hostby1.urls \
       + karesansui.gadget.hostby1job.urls \
       + karesansui.gadget.hostby1firewall.urls \
       + karesansui.gadget.hostby1firewallstatus.urls \
       + karesansui.gadget.hostby1firewallpolicy.urls \
       + karesansui.gadget.hostby1firewallrule.urls \
       + karesansui.gadget.hostby1firewallruleby1.urls \
       + karesansui.gadget.hostby1network.urls \
       + karesansui.gadget.hostby1networkby1.urls \
       + karesansui.gadget.hostby1networkby1status.urls \
       + karesansui.gadget.hostby1setting.urls \
       + karesansui.gadget.hostby1settingby1mail.urls \
       + karesansui.gadget.hostby1settingby1proxy.urls \
       + karesansui.gadget.hostby1networkstorage.urls \
       + karesansui.gadget.hostby1networkstorageby1.urls \
       + karesansui.gadget.hostby1networkstorageby1status.urls \
       + karesansui.gadget.hostby1storagepool.urls \
       + karesansui.gadget.hostby1storagepoolby1.urls \
       + karesansui.gadget.hostby1storagepoolby1status.urls \
       + karesansui.gadget.hostby1networksettings.urls \
       + karesansui.gadget.hostby1networksettingsgeneral.urls \
       + karesansui.gadget.hostby1networksettingsnicby1.urls \
       + karesansui.gadget.hostby1iptables.urls \
       + karesansui.gadget.hostby1iptablesstatus.urls \
       + karesansui.gadget.hostby1staticroute.urls \
       + karesansui.gadget.hostby1staticrouteby1.urls \
       + karesansui.gadget.hostby1report.urls \
       + karesansui.gadget.hostby1reportby1.urls \
       + karesansui.gadget.hostby1reportby1by1.urls \
       + karesansui.gadget.hostby1watch.urls \
       + karesansui.gadget.hostby1watchby1.urls \
       + karesansui.gadget.hostby1watchtemplate.urls \
       + karesansui.gadget.hostby1service.urls \
       + karesansui.gadget.hostby1serviceby1.urls \
       + karesansui.gadget.hostby1serviceby1status.urls \
       + karesansui.gadget.hostby1log.urls \
       + karesansui.gadget.hostby1logby1.urls \
       + karesansui.gadget.hostby1logby1appby1.urls \
       + karesansui.gadget.guest.urls \
       + karesansui.gadget.guesttag.urls \
       + karesansui.gadget.guestreplicate.urls \
       + karesansui.gadget.guestexport.urls \
       + karesansui.gadget.guestexportby1.urls \
       + karesansui.gadget.guestimport.urls \
       + karesansui.gadget.guestby1.urls \
       + karesansui.gadget.guestby1status.urls \
       + karesansui.gadget.guestby1device.urls \
       + karesansui.gadget.guestby1diskby1.urls \
       + karesansui.gadget.guestby1nicby1.urls \
       + karesansui.gadget.guestby1cpu.urls \
       + karesansui.gadget.guestby1memory.urls \
       + karesansui.gadget.guestby1graphics.urls \
       + karesansui.gadget.guestby1snapshot.urls \
       + karesansui.gadget.guestby1snapshotby1.urls \
       + karesansui.gadget.guestby1currentsnapshot.urls \
       + karesansui.gadget.guestby1job.urls \
       + karesansui.gadget.uriguestby1.urls \
       + karesansui.gadget.uriguestby1status.urls \
       + karesansui.gadget.uriguestby1console.urls \
       + karesansui.gadget.init.urls \


if web.wsgi._is_dev_mode() is True:
    import karesansui.gadget.static
    urls += karesansui.gadget.static.urls

########NEW FILE########
__FILENAME__ = rrd_const
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import datetime

def create_epochsec(year, month, day, hour, minute, second):
    return str(int(time.mktime(datetime.datetime(year, month, day, hour, minute, second).timetuple())))

_start_year = 2010
_start_month = 4
_start_day = 1
_start_hour = 0
_start_minute = 0
_start_second = 0

_end_year = 2010
_end_month = 5
_end_day = 1
_end_hour = 0
_end_minute = 0
_end_second = 0

RRD_DIR = "/var/lib/collectd/foo.example.com/"

RRD_DIR_VIRT = "/var/lib/collectd/virt.example.com/"

START_TIME = create_epochsec(_start_year, _start_month, _start_day, _start_hour, _start_minute, _start_second)
END_TIME = create_epochsec(_end_year, _end_month, _end_day, _end_hour, _end_minute, _end_second)

INTERFACE = "br0"


########NEW FILE########
__FILENAME__ = sample_cpu
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME

data = rrdtool.graph('cpu_graph.gif',
#                     "--font", "DEFAULT:0:IPAexMincho",
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "CPU",
                     "--vertical-label", "jiffies",
                     "--upper-limit", "100",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
                     "--legend-direction", "bottomup",
                     "DEF:idle=" + RRD_DIR + "cpu-0/cpu-idle.rrd:value:AVERAGE",
                     "DEF:interrupt=" + RRD_DIR + "cpu-0/cpu-interrupt.rrd:value:AVERAGE",
                     "DEF:nice=" + RRD_DIR + "cpu-0/cpu-nice.rrd:value:AVERAGE",
                     "DEF:user=" + RRD_DIR + "cpu-0/cpu-user.rrd:value:AVERAGE",
                     "DEF:wait=" + RRD_DIR + "cpu-0/cpu-wait.rrd:value:AVERAGE",
                     "DEF:system=" + RRD_DIR + "cpu-0/cpu-system.rrd:value:AVERAGE",
                     "DEF:softirq=" + RRD_DIR + "cpu-0/cpu-softirq.rrd:value:AVERAGE",
                     "DEF:steal=" + RRD_DIR + "cpu-0/cpu-steal.rrd:value:AVERAGE",
#                     "CDEF:un=idle,UNKN,UNKN,IF",
                     "AREA:steal#000000:Steal      ",
                     "GPRINT:steal:MIN:%8.2lf",
                     "GPRINT:steal:MAX:%8.2lf",
                     "GPRINT:steal:AVERAGE:%8.2lf",
                     "GPRINT:steal:LAST:%8.2lf\\n",
                     "STACK:interrupt#FF00FF:Interrupt",
                     "GPRINT:interrupt:MIN:%8.2lf",
                     "GPRINT:interrupt:MAX:%8.2lf",
                     "GPRINT:interrupt:AVERAGE:%8.2lf",
                     "GPRINT:interrupt:LAST:%8.2lf\\n",
                     "STACK:softirq#FF22DD:SoftIRQ  ",
                     "GPRINT:softirq:MIN:%8.2lf",
                     "GPRINT:softirq:MAX:%8.2lf",
                     "GPRINT:softirq:AVERAGE:%8.2lf",
                     "GPRINT:softirq:LAST:%8.2lf\\n",
                     "STACK:system#FF0000:System   ",
                     "GPRINT:system:MIN:%8.2lf",
                     "GPRINT:system:MAX:%8.2lf",
                     "GPRINT:system:AVERAGE:%8.2lf",
                     "GPRINT:system:LAST:%8.2lf\\n",
                     "STACK:wait#FFDD00:Wait - IO",
                     "GPRINT:wait:MIN:%8.2lf",
                     "GPRINT:wait:MAX:%8.2lf",
                     "GPRINT:wait:AVERAGE:%8.2lf",
                     "GPRINT:wait:LAST:%8.2lf\\n",
                     "STACK:user#0000FF:User        ",
                     "GPRINT:user:MIN:%8.2lf",
                     "GPRINT:user:MAX:%8.2lf",
                     "GPRINT:user:AVERAGE:%8.2lf",
                     "GPRINT:user:LAST:%8.2lf\\n",
                     "STACK:nice#00FF00:Nice        ",
                     "GPRINT:nice:MIN:%8.2lf",
                     "GPRINT:nice:MAX:%8.2lf",
                     "GPRINT:nice:AVERAGE:%8.2lf",
                     "GPRINT:nice:LAST:%8.2lf\\n",
                     "STACK:idle#EEEEEE:Idle       ",
#                     "STACK:un#FFFFFF:Idle       ",
                     "GPRINT:idle:MIN:%8.2lf",
                     "GPRINT:idle:MAX:%8.2lf",
                     "GPRINT:idle:AVERAGE:%8.2lf",
                     "GPRINT:idle:LAST:%8.2lf\\n",
                     "COMMENT:色                          最小         最大         平均          最新\\n",
                     "COMMENT: \\n",
                     )

########NEW FILE########
__FILENAME__ = sample_df
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME

dev = "mapper_VolGroup00-LogVol00"

data = rrdtool.graph('df_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", dev + "の情報",
                     "--vertical-label", "Byte",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:used=" + RRD_DIR + "df/df-" + dev + ".rrd:used:AVERAGE",
                     "DEF:free=" + RRD_DIR + "df/df-" + dev + ".rrd:free:AVERAGE",
                     "AREA:used#FF9999:Used",
                     "GPRINT:used:MIN:%6.2lf%s Min, ",
                     "GPRINT:used:MAX:%6.2lf%s Max, ",
                     "GPRINT:used:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:used:LAST:%6.2lf%s Last\\n",
                     "STACK:free#99FF99:Free",
                     "GPRINT:free:MIN:%6.2lf%S Min, ",
                     "GPRINT:free:MAX:%6.2lf%S Max, ",
                     "GPRINT:free:AVERAGE:%6.2lf%S Ave, ",
                     "GPRINT:free:LAST:%6.2lf%S Last\\n",
                     "LINE1:used#FF0000",
                     "STACK:free#00FF00",
                     )


########NEW FILE########
__FILENAME__ = sample_disk
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME

dev = "hda"

data = rrdtool.graph('disk_merged_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "disk-" + dev + "/disk_merged",
                     "--vertical-label", "Merged Ops/s",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:merged_read=" + RRD_DIR + "disk-" + dev + "/disk_merged.rrd:read:AVERAGE",
                     "DEF:merged_write=" + RRD_DIR + "disk-" + dev + "/disk_merged.rrd:write:AVERAGE",
                     "AREA:merged_read#44FF44:Read",
                     "GPRINT:merged_read:MIN:%6.2lf%s Min, ",
                     "GPRINT:merged_read:MAX:%6.2lf%s Max, ",
                     "GPRINT:merged_read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:merged_read:LAST:%6.2lf%s Last\\n",
                     "STACK:merged_write#4444FF:Write",
                     "GPRINT:merged_write:MIN:%6.2lf%s Min, ",
                     "GPRINT:merged_write:MAX:%6.2lf%s Max, ",
                     "GPRINT:merged_write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:merged_write:LAST:%6.2lf%s Last\\n",
                     "LINE1:merged_read#00FF",
                     "STACK:merged_write#0000FF",
                     )

data = rrdtool.graph('disk_octets_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "disk-" + dev + "/disk_octets",
                     "--vertical-label", "Byte/s",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:octets_read=" + RRD_DIR + "disk-" + dev + "/disk_octets.rrd:read:AVERAGE",
                     "DEF:octets_write=" + RRD_DIR + "disk-" + dev + "/disk_octets.rrd:write:AVERAGE",
                     "AREA:octets_read#44FF44:Read",
                     "GPRINT:octets_read:MIN:%6.2lf%s Min, ",
                     "GPRINT:octets_read:MAX:%6.2lf%s Max, ",
                     "GPRINT:octets_read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:octets_read:LAST:%6.2lf%s Last\\n",
                     "STACK:octets_write#4444FF:Write",
                     "GPRINT:octets_write:MIN:%6.2lf%s Min, ",
                     "GPRINT:octets_write:MAX:%6.2lf%s Max, ",
                     "GPRINT:octets_write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:octets_write:LAST:%6.2lf%s Last\\n",
                     "LINE1:octets_read#00FF",
                     "STACK:octets_write#0000FF",
                     )

data = rrdtool.graph('disk_ops_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "disk-" + dev + "/disk_ops",
                     "--vertical-label", "Ops/s",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:ops_read=" + RRD_DIR + "disk-" + dev + "/disk_ops.rrd:read:AVERAGE",
                     "DEF:ops_write=" + RRD_DIR + "disk-" + dev + "/disk_ops.rrd:write:AVERAGE",
                     "AREA:ops_read#44FF44:Read",
                     "GPRINT:ops_read:MIN:%6.2lf%s Min, ",
                     "GPRINT:ops_read:MAX:%6.2lf%s Max, ",
                     "GPRINT:ops_read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:ops_read:LAST:%6.2lf%s Last\\n",
                     "STACK:ops_write#4444FF:Write",
                     "GPRINT:ops_write:MIN:%6.2lf%s Min, ",
                     "GPRINT:ops_write:MAX:%6.2lf%s Max, ",
                     "GPRINT:ops_write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:ops_write:LAST:%6.2lf%s Last\\n",
                     "LINE1:ops_read#00FF",
                     "STACK:ops_write#0000FF",
                     )

data = rrdtool.graph('disk_time_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "disk-" + dev + "/disk_time",
                     "--vertical-label", "Seconds/s",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:time_read=" + RRD_DIR + "disk-" + dev + "/disk_time.rrd:read:AVERAGE",
                     "DEF:time_write=" + RRD_DIR + "disk-" + dev + "/disk_time.rrd:write:AVERAGE",
                     "AREA:time_read#44FF44:Read",
                     "GPRINT:time_read:MIN:%6.2lf%s Min, ",
                     "GPRINT:time_read:MAX:%6.2lf%s Max, ",
                     "GPRINT:time_read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:time_read:LAST:%6.2lf%s Last\\n",
                     "STACK:time_write#4444FF:Write",
                     "GPRINT:time_write:MIN:%6.2lf%s Min, ",
                     "GPRINT:time_write:MAX:%6.2lf%s Max, ",
                     "GPRINT:time_write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:time_write:LAST:%6.2lf%s Last\\n",
                     "LINE1:time_read#00FF",
                     "STACK:time_write#0000FF",
                     )


########NEW FILE########
__FILENAME__ = sample_interface
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME, INTERFACE

data = rrdtool.graph('interface_packet_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", INTERFACE + "のパケット情報",
                     "--vertical-label", "Packets / sec",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:rx=" + RRD_DIR + "interface/if_packets-" + INTERFACE + ".rrd:rx:AVERAGE",
                     "DEF:tx=" + RRD_DIR + "interface/if_packets-" + INTERFACE + ".rrd:tx:AVERAGE",
                     "AREA:rx#4444FF:RX",
                     "GPRINT:rx:MIN:%6.2lf%s Min, ",
                     "GPRINT:rx:MAX:%6.2lf%S Max, ",
                     "GPRINT:rx:AVERAGE:%6.2lf%S Ave, ",
                     "GPRINT:rx:LAST:%6.2lf%S Last\\n",
                     "STACK:tx#44FF44:TX",
                     "GPRINT:tx:MIN:%6.2lf%S Min, ",
                     "GPRINT:tx:MAX:%6.2lf%S Max, ",
                     "GPRINT:tx:AVERAGE:%6.2lf%S Ave, ",
                     "GPRINT:tx:LAST:%6.2lf%S Last\\n",
                     "LINE1:rx#0000FF",
                     "STACK:tx#00FF00",
                     )


data = rrdtool.graph('interface_octet_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", INTERFACE + "のトラフィック情報",
                     "--vertical-label", "Octet / sec",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:rx=" + RRD_DIR + "interface/if_octets-" + INTERFACE + ".rrd:rx:AVERAGE",
                     "DEF:tx=" + RRD_DIR + "interface/if_octets-" + INTERFACE + ".rrd:tx:AVERAGE",
                     "AREA:rx#4444FF:RX",
                     "GPRINT:rx:MIN:%6.2lf%s Min,\t",
                     "GPRINT:rx:MAX:%6.2lf%s Max,\t",
                     "GPRINT:rx:AVERAGE:%6.2lf%s Ave,\t",
                     "GPRINT:rx:LAST:%6.2lf%s Last\\n",
                     "STACK:tx#44FF44:TX",
                     "GPRINT:tx:MIN:%6.2lf%s Min,\t",
                     "GPRINT:tx:MAX:%6.2lf%s Max,\t",
                     "GPRINT:tx:AVERAGE:%6.2lf%s Ave,\t",
                     "GPRINT:tx:LAST:%6.2lf%s Last\\n",
                     "LINE1:rx#0000FF",
                     "STACK:tx#00FF00",
                     )


data = rrdtool.graph('interface_error_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", INTERFACE + "のエラーパケット情報",
                     "--vertical-label", "Packets / sec",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:rx=" + RRD_DIR + "interface/if_errors-" + INTERFACE + ".rrd:rx:AVERAGE",
                     "DEF:tx=" + RRD_DIR + "interface/if_errors-" + INTERFACE + ".rrd:tx:AVERAGE",
                     "AREA:rx#4444FF:RX",
                     "GPRINT:rx:MIN:%6.2lf%s Min, ",
                     "GPRINT:rx:MAX:%6.2lf%S Max, ",
                     "GPRINT:rx:AVERAGE:%6.2lf%S Ave, ",
                     "GPRINT:rx:LAST:%6.2lf%S Last\\n",
                     "STACK:tx#44FF44:TX",
                     "GPRINT:tx:MIN:%6.2lf%S Min, ",
                     "GPRINT:tx:MAX:%6.2lf%S Max, ",
                     "GPRINT:tx:AVERAGE:%6.2lf%S Ave, ",
                     "GPRINT:tx:LAST:%6.2lf%S Last\\n",
                     "LINE1:rx#0000FF",
                     "STACK:tx#00FF00",
                     )

########NEW FILE########
__FILENAME__ = sample_libvirt
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR_VIRT, START_TIME, END_TIME

data = rrdtool.graph('virt_cpu_total_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "virt CPUの情報",
                     "--vertical-label", "second",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:ns=" + RRD_DIR_VIRT + "libvirt/virt_cpu_total.rrd:ns:AVERAGE",
                     "CDEF:s=ns,1000,1000,1000,*,*,/",
                     "AREA:s#9999FF:Second",
                     "GPRINT:s:MIN:%6.2lf min",
                     "GPRINT:s:MAX:%6.2lf max",
                     "GPRINT:s:AVERAGE:%6.2lf ave",
                     "GPRINT:s:LAST:%6.2lf last\\n",
                     "LINE1:s#0000FF",
                     )

data = rrdtool.graph('virt_cpu-0_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "virt CPU-0の情報",
                     "--vertical-label", "second",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:ns=" + RRD_DIR_VIRT + "libvirt/virt_vcpu-0.rrd:ns:AVERAGE",
                     "CDEF:s=ns,1000,1000,1000,*,*,/",
                     "AREA:s#9999FF:Second",
                     "GPRINT:s:MIN:%6.2lf min",
                     "GPRINT:s:MAX:%6.2lf max",
                     "GPRINT:s:AVERAGE:%6.2lf ave",
                     "GPRINT:s:LAST:%6.2lf last\\n",
                     "LINE1:s#0000FF",
                     )


data = rrdtool.graph('virt_disk_octets_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "virt disk octetsの情報",
                     "--vertical-label", "Octets",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:read=" + RRD_DIR_VIRT + "libvirt/disk_octets-hda.rrd:read:AVERAGE",
                     "DEF:write=" + RRD_DIR_VIRT + "libvirt/disk_octets-hda.rrd:write:AVERAGE",
                     "AREA:read#44FF44:Read",
                     "GPRINT:read:MIN:%6.2lf%s Min, ",
                     "GPRINT:read:MAX:%6.2lf%s Max, ",
                     "GPRINT:read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:read:LAST:%6.2lf%s Last\\n",
                     "STACK:write#4444FF:Write",
                     "GPRINT:write:MIN:%6.2lf%s Min, ",
                     "GPRINT:write:MAX:%6.2lf%s Max, ",
                     "GPRINT:write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:write:LAST:%6.2lf%s Last\\n",
                     "LINE1:read#00FF",
                     "STACK:write#0000FF",
                     )

data = rrdtool.graph('virt_disk_ops_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "virt disk opsの情報",
                     "--vertical-label", "Octets / sec",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:read=" + RRD_DIR_VIRT + "libvirt/disk_ops-hda.rrd:read:AVERAGE",
                     "DEF:write=" + RRD_DIR_VIRT + "libvirt/disk_ops-hda.rrd:write:AVERAGE",
                     "AREA:read#44FF44:Read",
                     "GPRINT:read:MIN:%6.2lf%s Min, ",
                     "GPRINT:read:MAX:%6.2lf%s Max, ",
                     "GPRINT:read:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:read:LAST:%6.2lf%s Last\\n",
                     "STACK:write#4444FF:Write",
                     "GPRINT:write:MIN:%6.2lf%s Min, ",
                     "GPRINT:write:MAX:%6.2lf%s Max, ",
                     "GPRINT:write:AVERAGE:%6.2lf%s Ave, ",
                     "GPRINT:write:LAST:%6.2lf%s Last\\n",
                     "LINE1:read#00FF",
                     "STACK:write#0000FF",
                     )

########NEW FILE########
__FILENAME__ = sample_matplotlib
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib64/python2.4/site-packages/')
import rrdtool

import datetime
from pylab import *
import matplotlib.font_manager as fm
from matplotlib.ticker import FuncFormatter

import time


def millions(x, pos):
    return '%1fM' % (x*1e-6)


data = rrdtool.fetch('memory-used.rrd',
                     "AVERAGE",
                     "-r",
                     "60",
                     "-s",
                     str(int(time.mktime((2010,3,23,16,0,0,1,82,0)))),
                     "-e",
                     str(int(time.mktime((2010,3,23,17,0,0,1,82,0))))
                     )


prop = fm.FontProperties(fname='/home/fukawa/ipamp.otf')
title('テストtest', fontproperties=prop)

#info = rrdtool.info('memory-used.rrd')
#print info

plot(data[2])

formatter = FuncFormatter(millions)
ax = subplot(111)
ax.yaxis.set_major_formatter(formatter)

show()


########NEW FILE########
__FILENAME__ = sample_memory
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME

data = rrdtool.graph('memory_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "メモリの情報",
                     "--vertical-label", "byte",
#                     "--upper-limit", "536870912",
                     "--lower-limit", "0",
                     "--rigid",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
                     "--legend-direction", "bottomup",
                     "DEF:free=" + RRD_DIR + "memory/memory-free.rrd:value:AVERAGE",
                     "DEF:cached=" + RRD_DIR + "memory/memory-cached.rrd:value:AVERAGE",
                     "DEF:buffered=" + RRD_DIR + "memory/memory-buffered.rrd:value:AVERAGE",
                     "DEF:used=" + RRD_DIR + "memory/memory-used.rrd:value:AVERAGE",
                     "AREA:used#FFAAAA:used\t",
                     "GPRINT:used:MIN:%6.1lf %s\t",
                     "GPRINT:used:MAX:%6.1lf %s\t",
                     "GPRINT:used:AVERAGE:%6.1lf %s\t",
                     "GPRINT:used:LAST:%6.1lf %s\\n",
                     "STACK:buffered#FFDDAA:buffered",
                     "GPRINT:buffered:MIN:%6.1lf %s\t",
                     "GPRINT:buffered:MAX:%6.1lf %s\t",
                     "GPRINT:buffered:AVERAGE:%6.1lf %s\t",
                     "GPRINT:buffered:LAST:%6.1lf %s\\n",
                     "STACK:cached#AAAAFF:cached",
                     "GPRINT:cached:MIN:%6.1lf %s\t",
                     "GPRINT:cached:MAX:%6.1lf %s\t",
                     "GPRINT:cached:AVERAGE:%6.1lf %s\t",
                     "GPRINT:cached:LAST:%6.1lf %s\\n",
                     "STACK:free#AAFFAA:free\t",
                     "GPRINT:free:MIN:%6.1lf %s\t",
                     "GPRINT:free:MAX:%6.1lf %s\t",
                     "GPRINT:free:AVERAGE:%6.1lf %s\t",
                     "GPRINT:free:LAST:%6.1lf %s\\n",
#                     "COMMENT:色                      最小            最大          平均            最新\\n",
                     "COMMENT:色\t\t最小\t最大\t平均\t最新\\n",
                     "COMMENT: \\n",
                     "LINE1:used#FF0000",
                     "STACK:buffered#DD9900",
                     "STACK:cached#0000FF",
                     "STACK:free#00FF00",
                     )

########NEW FILE########
__FILENAME__ = sample_uptime
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.path.append('/usr/lib/python2.6/')
import rrdtool

from rrd_const import RRD_DIR, START_TIME, END_TIME

data = rrdtool.graph('uptime_graph.gif',
                     "--font", "DEFAULT:0:IPAexGothic",
                     "--title", "uptimeの情報",
                     "--vertical-label", "sec",
                     "--width", "500",
                     "--height", "200",
                     "--start", START_TIME,
                     "--end",  END_TIME,
#                     "--legend-direction", "bottomup",
                     "DEF:uptime=" + RRD_DIR + "uptime/uptime.rrd:value:AVERAGE",
                     "VDEF:max=uptime,MAXIMUM",
                     "VDEF:min=uptime,MINIMUM",
                     "VDEF:average=uptime,AVERAGE",
                     "AREA:uptime#DDDDDD",
                     "LINE1:uptime#FF6622:Current",
                     "GPRINT:uptime:LAST:%6.2lf Last\\n",
                     "HRULE:max#FF0000:Maximum:dashes",
                     "GPRINT:uptime:MAX:%6.2lf max\\n",
                     "HRULE:min#FFFF00:Minimum:dashes",
                     "GPRINT:uptime:MIN:%6.2lf min\\n",
                     "HRULE:average#0044FF:Average:dashes",
                     "GPRINT:uptime:AVERAGE:%6.2lf ave\\n",
                     )

########NEW FILE########
__FILENAME__ = cleanlydb
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of Karesansui.
#
# Copyright (C) 2009-2010 HDE, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#

import sqlalchemy
import sqlalchemy.orm
from pysilhouette.db.model import *
import sqlalchemy.pool
import sqlite

bind_name = 'sqlite:///:memory:'

def gs():
    hoge = ':memory:'
    return sqlite.connect('/tmp/hoge.db')

def main():
    #qp = sqlalchemy.pool.QueuePool( gs , pool_size=5, max_overflow=100, echo=True)
    #engine = sqlalchemy.create_engine(bind_name, encoding="utf8", echo=True, pool=qp)
    #engine = sqlalchemy.create_engine(bind_name, encoding="utf8", echo=True, poolclass=sqlalchemy.pool.QueuePool)
    
    engine = sqlalchemy.create_engine(bind_name, encoding="utf8", echo=True)
    
    metadata = sqlalchemy.MetaData(bind=engine)
    
    t_job_group = get_job_group_table(metadata)
    t_job = get_job_table(metadata)

    sqlalchemy.orm.mapper(JobGroup, t_job_group, properties={'jobs': sqlalchemy.orm.relation(Job)})
    sqlalchemy.orm.mapper(Job, t_job)
    
    metadata.drop_all()
    metadata.create_all()
    
    Session = sqlalchemy.orm.sessionmaker(engine)
    session1 = Session()
    session2 = Session()
    session3 = Session()
    hoge = session1.query(JobGroup).all()
    jg1 = JobGroup(u'Test Success', '')
    jg1.jobs.append(Job(u'日付取得','0','/bin/date', 'fdaf'))
    session1.add(jg1)
    session1.close()
                                        
if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = initialize_database
#!/usr/bin/env python

import sys, os
import socket
import re
import string
from optparse import OptionParser
import traceback

try:
    from distutils.sysconfig import get_python_lib
    sys.real_prefix = '/usr';
    sys.path.append(get_python_lib(0,0))
except:
    pass

try:
    import sqlalchemy
    import karesansui
    from karesansui import __version__
    from karesansui.lib.utils import is_uuid, is_int
    from karesansui.lib.utils import generate_phrase, generate_uuid, string_from_uuid
    from karesansui.lib.file.k2v import K2V
    from karesansui.lib.crypt import sha1encrypt
    from karesansui.lib.const import MACHINE_ATTRIBUTE, MACHINE_HYPERVISOR
    from karesansui.db import get_engine, get_metadata, get_session
    from karesansui.db.model.user import User
    from karesansui.db.model.notebook import Notebook
    from karesansui.db.model.tag import Tag
    from karesansui.db.model.machine import Machine

except ImportError:
    print >>sys.stderr, "[Error] karesansui package was not found."
    sys.exit(1)

usage = '%prog [options]'

def getopts():
    optp = OptionParser(usage=usage, version=__version__)
    # basic
    optp.add_option('-m', '--email',    dest='email',    help=_("E-mail Address"), default="root@localhost")
    optp.add_option('-p', '--password', dest='password', help=_("Password"),       default="")
    optp.add_option('-l', '--lang',     dest='lang',     help=_("Language"),       default="")
    optp.add_option('-f', '--host',     dest='fqdn',     help=_("FQDN"),           default="")
    optp.add_option('-u', '--uuid',     dest='uuid',     help=_("UUID"),           default="")

    return optp.parse_args()

def chkopts(opts):
    from karesansui.lib.utils import generate_phrase, generate_uuid, string_from_uuid, is_uuid
    from karesansui.lib.const import DEFAULT_LANGS

    reg_email = re.compile("^[a-zA-Z0-9\./_-]{1,}@[a-zA-Z0-9\./-]{4,}$")
    if opts.email:
        if reg_email.search(opts.email) is None:
            raise Exception('ERROR: Illigal option value. option=%s value=%s' % ('-m or --email', opts.email))
    else:
        raise Exception('ERROR: %s option is required.' % '-m or --email')

    reg_passwd = re.compile("^.{5,}")
    if opts.password:
        if reg_passwd.search(opts.password) is None:
            raise Exception('ERROR: Illigal option value. option=%s value=%s' % ('-p or --password', opts.password))
    else:
        pass

    if opts.password == "":
        opts.password = generate_phrase(8)

    if opts.uuid:
        if is_uuid(opts.uuid) is False:
            raise Exception('ERROR: Illigal option value. option=%s value=%s' % ('-u or --uuid', opts.uuid))
    else:
        pass

    if opts.uuid == "":
        opts.uuid = string_from_uuid(generate_uuid())

    reg_fqdn = re.compile("^[a-z0-9][a-z0-9\.\-]{2,}$")
    if opts.fqdn:
        if reg_fqdn.search(opts.fqdn) is None:
            raise Exception('ERROR: Illigal option value. option=%s value=%s' % ('-f or --fqdn', opts.fqdn))
    else:
        pass

    if opts.fqdn == "":
        opts.fqdn = socket.gethostname() 

    reg_lang = re.compile("^[a-z]{2}_[A-Z]{2}$")
    if opts.lang:
        if reg_lang.search(opts.lang) is None:
            raise Exception('ERROR: Illigal option value. option=%s value=%s' % ('-l or --lang', opts.lang))
    else:
        pass

    if opts.lang == "":
        try:
            DEFAULT_LANGS[os.environ["LANG"][0:5]]
            opts.lang = os.environ["LANG"][0:5]
        except:
            opts.lang = "en_US"


karesansui.config = K2V("/etc/karesansui/application.conf").read()

(opts, args) = getopts()
#print opts
chkopts(opts)

for k in dir(opts):
    v = getattr(opts,k)
    if type(v) == str and k[0:2] != "__":
        exec("%s = '%s'" % (k, v,))

#print opts
#sys.exit()

engine = get_engine()
metadata = get_metadata()

try:
    metadata.drop_all()   
    metadata.tables['machine2jobgroup'].create()
    metadata.create_all()   
except Exception, e:
    traceback.format_exc()
    raise Exception('Initializing/Updating a database error - %s' % ''.join(e.args))

session = get_session()
try:
    (password, salt) = sha1encrypt(u"%s" % password)
    user = session.query(User).filter(User.email == email).first()

    if user is None:
        # User Table set.
        new_user  = User(u"%s" % email,
                              unicode(password),
                              unicode(salt),
                              u"Administrator",
                              u"%s" % lang,
                              )

        if string.atof(sqlalchemy.__version__[0:3]) >= 0.6:
            session.add(new_user)
        else:
            session.save(new_user)
        session.commit()
    else:
        user.password  = password
        user.salt      = salt
        user.languages = lang
        if string.atof(sqlalchemy.__version__[0:3]) >= 0.6:
            session.add(user)
        else:
            session.update(user)
        session.commit()

    # Tag Table set.
    tag = Tag(u"default")
    if string.atof(sqlalchemy.__version__[0:3]) >= 0.6:
        session.add(tag)
    else:
        session.save(tag)
    session.commit()
        
    # Machine Table set.
    user     = session.query(User).filter(User.email == email).first()
    notebook = Notebook(u"", u"")
    machine  = Machine(user,
                       user,
                       u"%s" % uuid,
                       u"%s" % fqdn,
                       MACHINE_ATTRIBUTE['HOST'],
                       MACHINE_HYPERVISOR['REAL'],
                       notebook,
                       [tag],
                       u"%s" % fqdn,
                       u'icon-guest1.png',
                       False,
                       None,
                      )

    if string.atof(sqlalchemy.__version__[0:3]) >= 0.6:
        session.add(machine)
    else:
        session.save(machine)
    session.commit()

    session.close()
except Exception, e:
    traceback.format_exc()
    raise Exception('Initializing/Updating a database error - %s' % ''.join(e.args))


########NEW FILE########
