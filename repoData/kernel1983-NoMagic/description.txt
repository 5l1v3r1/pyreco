Read the code is easy!

	import uuid
	import json

Import the necessory library

	from setting import conn

Import the database connection, this connection is used for index_* tables

	from setting import ring

Import the **ring**.

**ring** is a list of connections to the databases.
	
	_NUMBER = len(ring)

**_NUMBER** is the number of database connections.

	def _pack(data): return json.dumps(data, ensure_ascii=False)

**_pack** function is used to turn data into json. We may consider to compress the data in gzip some day. however, we keep it simple now. 

	def _unpack(data): return json.loads(data)

**_unpack** is also easy to understand.

	def _key(data): return data

**_key** just be ready for future.

	def _new_key():
	    return uuid.uuid4().hex
	    #return uuid.uuid3(uuid.NAMESPACE_DNS, "yourdomain.com").hex
	    #return uuid.uuid5(uuid.NAMESPACE_DNS, "yourdomain.com").hex

**_new_key** function create a random new key with UUID.

	def _number(key): return int(key, 16) % _NUMBER

**_number** function tell the key which node of ring it should be store.

	def _get_entity_by_id(entity_id):
	    entity = ring[_number(entity_id)].get("SELECT body FROM entities WHERE id = %s", _key(entity_id))
	    return _unpack(entity["body"]) if entity else None

**_get_entity_by_id** given a entity id, return the data object(dict/list) from the certian node. 

	def _get_entities_by_ids(entity_ids):
	    entities = []
	
	    for h in range(_NUMBER):
	        ids = [str(i) for i in entity_ids if h == _number(i)]
	
	        if len(ids) > 1:
	            entities.extend([(i["id"], _unpack(i["body"])) \
	                for i in ring[h].query("SELECT * FROM entities WHERE id IN %s" % str(tuple(ids)))])
	        elif len(ids) == 1:
	            entity = _get_entity_by_id(ids[0])
	            entities.extend([(ids[0], entity)] if entity else [])
	
	    entities = dict(entities)
	    return [(i, entities[i]) for i in entity_ids]

**_get_entities_by_ids** given a list entity ids, return the data objects(dict/list) from the certian nodes.

Please take a note that the return value is a list of tuple: [(key1, data1), (key2, data2), …]

We making return value in this format for reasons:

 * the value should be returned in sequence, if this function simple return a dict, you need to sort it by **entity_ids** again.
 * the result can be easily turn to a dict by **dict(_get_entities_by_ids(entity_ids))**

Because the entities are supposed to be stored in different nodes, so this function give a help to fetch a lot of entities in one line code.

	def _update_entity_by_id(entity_id, data):
	    assert ring[_number(entity_id)].execute_rowcount("UPDATE entities SET body = %s WHERE id = %s", _pack(data), _key(entity_id))

**_update_entity_by_id** function is use to update an entity. For now, we only provide function to update one entity, because even if you have the function to do a batch, it's still be split into the same number of SQL code.

We don't provide function to delete the entity. One of reasons is that we believed data should not be delete, or you can mark them as delete, remove them out of index, but keep the data record in the database. There are some article talking about this on Internet, however it's not our topic today.
Project [https://github.com/kernel1983/NoMagic/](https://github.com/kernel1983/NoMagic/) >> [如果你更喜欢读中文](README_cn.md)


NoMagic big data framework
=======

NoMagic is a MySQL based big data framework which enable you to create sharding data structure from the beginning of project.

* sharding

This framework stands on the shoulders of giants, we borrowed the idea from [Bret Taylor](http://backchannel.org/about)'s article [http://backchannel.org/blog/friendfeed-schemaless-mysql](http://backchannel.org/blog/friendfeed-schemaless-mysql)

We use function to implement a lot of helper function, I believe each action in database should be given a friendly function name, and the function should always return the same result of data if you give right parameters. If you don't like ORM, we may be looking for this project.

NoMagic framework doesn't try to put anything into the blackbox. We hope you read the core source code and try to get fully understanding before you start to using it. And we hope you forking our project and creating your own database helper function sets based on your need.

Using NoMagic, you will turn the MySQL database into a schemaless solution, the schemaless database will save your time so that you don't need to spend to much time in planning database table structure.


Learning
--------
1. Understand what is index and what is payload in database world.
2. The concept change of key-value database programming.
3. NoMagic database structure design.
4. [Read the core function library](docs/__init__.py.md).
5. Play around with NoMagic.


Project [https://github.com/kernel1983/NoMagic/](https://github.com/kernel1983/NoMagic/)


NoMagic 大数据框架
=======

NoMagic 是一个基于 MySQL 的大数据框架, 它可以让你方便的使用 MySQL 数据库创建分片的, 非结构的数据库方案.

它是一组函数库, 几乎全部都是函数, 用到的数据结构也都是字典, 列表. 基本上没有类的定义. 使用 NoMagic 得到的好处:

* 碎片化. 你将不用考虑当你的项目变得很大的时候, 数据库成为瓶颈.
* 非结构化. 你将无需修改你的数据库结构.

我们站在巨人的肩膀上, 我们可以很自豪的说我们并不是这个主意的原创者, 我们读了 Facebook 前 CTO [Bret Taylor](http://backchannel.org/about) 的文章 [http://backchannel.org/blog/friendfeed-schemaless-mysql](http://backchannel.org/blog/friendfeed-schemaless-mysql) [中文翻译](http://virest.org/archives/2010/07/21/how-friendfeed-uses-mysql-cn_2.html) 以后, 我们决定实现它. 现在这个框架已经在我们自己产品的生产环境中使用了.

我们使用非常函数的风格去实现了很多功能, 给一个函数起一个一眼就能看懂的名字非常重要. 这些函数除了从参数里获取数据, 返回我们需要的数据以外, 并不通过其他的途径读取数据影响返回结果(纯函数). 如果你不喜欢 ORM, 又需要处理大数据, 也许这个项目就是你要找的.

NoMagic 框架不喜欢把任何东西藏在黑盒里面. 我们希望在使用这个之前, 可以简单的阅读一下不是很长的核心部分代码. 我们也希望你可以fork我们的项目, 然后随心所欲的按照你的要求修改以及添加一些函数.

使用 NoMagic, 你将把现有的 MySQL 数据库变成一个非结构化的存储解决方案. 幸运的是, 我们发现非结构化的数据类型往往能解放程序员的思维, 提高程序员的生产效率. 我们无需再更加频繁的修改数据库结构, 这无疑会使得你的团队工作的更快一些.

学习
--------
1. 理解数据库的[索引和存储](http://kjam.org/cn/index-and-payload.html).
2. 假定你有关系数据库的编程经验: 现在需要转变观念, 我们要适应 [Key-Value 数据库的编程](http://kjam.org/cn/index-and-payload.html).
3. 搞清楚 NoMagic 数据库结构是怎么设计的.
4. [读一读我们的核心代码库](docs/__init__.py.md), 我向你保证不是很长.
5. 自己动手试一试 NoMagic.

