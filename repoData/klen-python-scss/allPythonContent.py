__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# python-scss documentation build configuration file, created by
# sphinx-quickstart on Wed Feb 16 19:24:45 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from scss import VERSION, AUTHOR

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'python-scss'
copyright = AUTHOR

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = VERSION
# The full version, including alpha/beta/rc tags.
release = VERSION

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'python-scssdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'python-scss.tex', u'python-scss Documentation',
   u'Kirill Klenov', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'python-scss', u'python-scss Documentation',
     [u'Kirill Klenov'], 1)
]

########NEW FILE########
__FILENAME__ = base
from scss import SORTING


class Node(object):
    """ Base class for parsed objects.
    """
    delim = ' '
    root = None

    def __init__(self, s, n, t):
        self.num, self.data = n, t
        self.parent = self._ctx = None

    def __str__(self):
        return self.delim.join(map(str, self.data))

    def __repr__(self):
        return '(%s%s)' % (
                self.__class__.__name__,
                ': %s' % ' '.join(map(repr, self.data)) if self.data else ''
        )

    def parse(self, target):
        self.parent = target

    def copy(self):
        return self

    def _get_ctx(self):
        if self._ctx:
            return self._ctx

        if self.parent:
            return self.parent.ctx

        self._ctx = dict()
        return self._ctx

    def _set_ctx(self, value):
        self._ctx = value

    ctx = property(_get_ctx, _set_ctx)

class Empty(Node):

    def __str__(self):
        return ''


class ParseNode(Node):

    def parse(self, target):
        super(ParseNode, self).parse(target)
        for n in self.data:
            if isinstance(n, Node):
                n.parse(self)

    def copy(self):
        t = [n.copy() if isinstance(n, Node) else n for n in self.data]
        return self.__class__(None, self.num, t)


class ContentNode(ParseNode):

    def __init__(self, s, n, t):
        super(ContentNode, self).__init__(s, n, t)
        self.name = self.data[0] if self.data else ''
        self.declareset = []
        self.ruleset = []

    def __str__(self):
        # Sort declaration
        if self.root.get_opt('sort'):
            self.declareset.sort(
                    key=lambda x: SORTING.get(x.name.lstrip('_#*'), 999 ))

        nl, ws, ts = self.root.cache['delims']
        semicolon = '' if self.root.cache['opts'].get('compress') else ';'

        return ''.join((

            # Self
            ''.join((

                # Selector tree
                str(self.name),

                "%s{%s%s" % (ws, nl, ts) if self.name else '',

                # Declarations
                (';%s%s' % ( nl, ts )).join(str(d) for d in self.declareset),

                semicolon,

                '}%s%s' % ( nl, nl ) if self.name else ''

            )) if self.declareset else '',

            # Children
            ''.join(str(r) for r in self.ruleset)
        ))


class IncludeNode(ParseNode):

    def parse(self, target):
        for node in self.data:
            if isinstance(node, Node):
                node.ctx.update(self.ctx)
                node.parse(target)

    def __str__(self):
        node = ContentNode(None, None, [])
        self.parse(node)
        return str(node)

########NEW FILE########
__FILENAME__ = control
from scss import OPRT
from scss.base import ParseNode, Empty, Node, IncludeNode
from scss.function import FUNCTION_LIST, unknown, warn
from scss.value import StringValue, Value, BooleanValue, NumberValue


class Option(Empty):
    """ Set parser option.
    """
    def parse(self, target):
        opts = map(lambda (x, y): (x.value, BooleanValue(y).value),
                    zip(*[iter(self.data[1:])]*2))
        for v in opts:
            self.root.set_opt(*v)


class Variable(Value, ParseNode):

    def_value = StringValue('none')

    @classmethod
    def _do_op(cls, self, other, op):
        return self.value._do_op(self.value, other, op)

    @classmethod
    def _do_cmps(cls, self, other, op):
        return self.value._do_cmps(self.value, other, op)

    def __nonzero__(self):
        return True

    @property
    def value(self):
        name = self.data[0].strip('-$')
        minus = self.data[0][0] == '-'
        value = self.ctx.get(name) or self.root.ctx.get(name, self.def_value)
        return (0 - value) if minus else value


class Variables(ParseNode, Empty):
    pass


class Expression(Variable):

    @property
    def value(self):
        it = iter(self.data)
        try:
            first = next(it)
            while True:
                res = next(it)
                op = OPRT.get(res.strip(), None)
                if op:
                    second = next(it)
                    first = op(first, second)

                    if op == OPRT['and'] and not first:
                        raise StopIteration

                    elif op == OPRT['or'] and first:
                        raise StopIteration

        except StopIteration:
            while isinstance(first, Variable):
                first = first.value
            return first


class SepValString(Expression):

    @property
    def value(self):
        return ', '.join(str(e.value) for e in self.data)


class Function(Expression):

    @property
    def value(self):
        name = self.data[0]
        func_name_a = "%s:%d" % (name, len(self.data) - 1)
        func_name_n = "%s:n" % name
        func = FUNCTION_LIST.get(func_name_a, FUNCTION_LIST.get(func_name_n, unknown))

        params = map(lambda v: v.value, self.data[1:])
        kwargs = dict(root=self.root, name=name)
        return func(*params, **kwargs)


class FunctionDefinition(Empty):

    def parse(self, target):
        name = self.data[1].value
        params = self.data[2]
        func_name = '%s:%s' % (name, len(params))
        FUNCTION_LIST[func_name] = self.wrapper

    def wrapper(self, *args, **kwargs):
        self.ctx = Mixin.get_context(self.data[2], args)
        for node in self.data[2:]:
            if isinstance(node, FunctionReturn):
                return node.value
            elif isinstance(node, Node):
                node.parse(self)


class FunctionReturn(Variable):

    @property
    def value(self):
        return self.data[1]


class MixinParam(Empty):
    def __init__(self, s, n, t):
        super(MixinParam, self).__init__(s, n, t)
        self.name = self.data[0].data[0][1:]
        self.value = self.data[1] if len(self.data) > 1 else None


class Extend(Empty):

    def parse(self, target):
        for rule in self.root.cache['rset'][self.data[1]]:
            rule.name.extend(target.name)


class Mixin(Empty):

    def __init__(self, s, n, t):
        super(Mixin, self).__init__(s, n, t)
        self.name = str(self.data[1])
        self.default = self.data[2]

    def parse(self, target):
        self.root.cache['mix'][self.name] = self

    def include(self, target, params):
        ctx = self.get_context(self.default, params)
        if target.ctx:
            ctx.update(target.ctx)

        self.ctx = ctx
        for n in params:
            n.parse(self)

        for node in self.data[3:]:
            if isinstance(node, Node):
                copy = node.copy()
                copy.ctx = ctx
                copy.parse(target)

    @staticmethod
    def get_context(default, params=''):
        test = map(lambda x, y: (x, y), default, params)
        return dict(( mp.name, v or mp.value ) for mp, v in test if mp)


class Include(IncludeNode):

    def parse(self, target):
        if isinstance(target, ParseNode):
            name = str(self.data[1])
            params = self.data[2:]
            mixin = self.root.cache['mix'].get(name)
            if mixin:
                mixin.include(target, params)
            else:
                warn("Required mixin not found: %s:%d." % ( name, len(params)))


class If(IncludeNode):

    def parse(self, target):
        self.data[0].parse(self)
        target.ctx.update(self.ctx)
        if isinstance(target, ParseNode):
            if self.data[0].value:
                self.data[1].parse(target)
            elif len(self.data) > 2:
                self.data[2].parse(target)


class For(IncludeNode):
    def parse(self, target):
        if isinstance(target, ParseNode):
            name = self.data[1].data[0][1:]
            for i in xrange(int(float(self.data[2])), int(float(self.data[3]))+1):
                body = self.data[4].copy()
                body.ctx.update({name: NumberValue(i)})
                body.parse(target)

########NEW FILE########
__FILENAME__ = function
import base64
import colorsys
import math
import mimetypes
import os.path
import sys

try:
    from itertools import product
    
except ImportError:
    def product(*args, **kwds):
        # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
        # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
        pools = map(tuple, args) * kwds.get('repeat', 1)
        result = [[]]
        for pool in pools:
            result = [x+[y] for x in result for y in pool]
        for prod in result:
            yield tuple(prod)
            
from scss import OPRT, CONV_TYPE, ELEMENTS_OF_TYPE
from scss.value import NumberValue, StringValue, QuotedStringValue, ColorValue, BooleanValue, hsl_op, rgba_op


try:
    from PIL import Image
except ImportError:
    Image = None

IMAGES = dict()


def warn(warning):
    """ Write warning messages in stderr.
    """
    print >> sys.stderr, "\nWarning: %s" % str( warning )


def unknown(*args, **kwargs):
    """ Unknow scss function handler.
        Simple return 'funcname(args)'
    """
    name = kwargs.get('name', '')
    return "%s(%s)" % ( name, ', '.join(str(a) for a in args) )


def check_pil(func):
    """ PIL module checking decorator.
    """
    def __wrapper(*args, **kwargs):
        root = kwargs.get('root')
        if not Image:
            if root and root.get_opt('warn'):
                warn("Images manipulation require PIL")
            return 'none'
        return func(*args, **kwargs)
    return __wrapper


# RGB functions
# =============

def _rgb(r, g, b, **kwargs):
    """ Converts an rgb(red, green, blue) triplet into a color.
    """
    return _rgba(r, g, b, 1.0)

def _rgba(r, g, b, a, **kwargs):
    """ Converts an rgba(red, green, blue, alpha) quadruplet into a color.
    """
    return ColorValue((float(r), float(g), float(b), float(a)))

def _red(color, **kwargs):
    """ Gets the red component of a color.
    """
    return NumberValue(color.value[0])

def _green(color, **kwargs):
    """ Gets the green component of a color.
    """
    return NumberValue(color.value[1])

def _blue(color, **kwargs):
    """ Gets the blue component of a color.
    """
    return NumberValue(color.value[2])

def _mix(color1, color2, weight=0.5, **kwargs):
    """ Mixes two colors together.
    """
    weight = float(weight)
    c1 = color1.value
    c2 = color2.value
    p = 0.0 if weight < 0 else 1.0 if weight > 1 else weight
    w = p * 2 - 1
    a = c1[3] - c2[3]

    w1 = ((w if (w * a == -1) else (w + a) / (1 + w * a)) + 1) / 2.0
    w2 = 1 - w1
    q = [ w1, w1, w1, p ]
    r = [ w2, w2, w2, 1 - p ]
    return ColorValue([c1[i] * q[i] + c2[i] * r[i] for i in range(4) ])


# HSL functions
# =============

def _hsl(h, s, l, **kwargs):
    """ HSL color value.
    """
    return _hsla(h, s, l, 1.0)

def _hsla(h, s, l, a, **kwargs):
    """ HSL with alpha channel color value.
    """
    res = colorsys.hls_to_rgb(float(h), float(l), float(s))
    return ColorValue(map(lambda x: x * 255.0, res) + [float(a)])

def _hue(color, **kwargs):
    """ Get hue value of HSL color.
    """
    h = colorsys.rgb_to_hls(*map(lambda x: x / 255.0, color.value[:3]))[0]
    return NumberValue(h * 360.0)

def _lightness(color, **kwargs):
    """ Get lightness value of HSL color.
    """
    l = colorsys.rgb_to_hls( *map(lambda x: x / 255.0, color.value[:3]) )[1]
    return NumberValue(( l * 100, '%' ))

def _saturation(color, **kwargs):
    """ Get saturation value of HSL color.
    """
    s = colorsys.rgb_to_hls( *map(lambda x: x / 255.0, color.value[:3]) )[2]
    return NumberValue(( s * 100, '%' ))

def _adjust_hue(color, degrees, **kwargs):
    return hsl_op(OPRT['+'], color, degrees, 0, 0)

def _lighten(color, amount, **kwargs):
    return hsl_op(OPRT['+'], color, 0, 0, amount)

def _darken(color, amount, **kwargs):
    return hsl_op(OPRT['-'], color, 0, 0, amount)

def _saturate(color, amount, **kwargs):
    return hsl_op(OPRT['+'], color, 0, amount, 0)

def _desaturate(color, amount, **kwargs):
    return hsl_op(OPRT['-'], color, 0, amount, 0)

def _grayscale(color, **kwargs):
    return hsl_op(OPRT['-'], color, 0, 100, 0)

def _complement(color, **kwargs):
    return hsl_op(OPRT['+'], color, 180.0, 0, 0)


# Opacity functions
# =================

def _alpha(color, **kwargs):
    c = ColorValue(color).value
    return NumberValue(c[3])

def _opacify(color, amount, **kwargs):
    return rgba_op(OPRT['+'], color, 0, 0, 0, amount)

def _transparentize(color, amount, **kwargs):
    return rgba_op(OPRT['-'], color, 0, 0, 0, amount)


# String functions
# =================

def _unquote(*args, **kwargs):
    return StringValue(' '.join(str(s).strip("\"'") for s in args))

def _quote(*args, **kwargs):
    return QuotedStringValue(' '.join(str(s) for s in args))


# Number functions
# =================

def _percentage(value, **kwargs):
    value = NumberValue(value)
    if not value.units == '%':
        value.value *= 100
        value.units = '%'
    return value

def _abs(value, **kwargs):
    return abs(float(value))

def _pi(**kwargs):
    return NumberValue(math.pi)

def _sin(value, **kwargs):
    return math.sin(value)

def _cos(value, **kwargs):
    return math.cos(value)

def _tan(value, **kwargs):
    return math.tan(value)

def _round(value, **kwargs):
    return round(value)

def _ceil(value, **kwargs):
    return math.ceil(value)

def _floor(value, **kwargs):
    return math.floor(value)


# Introspection functions
# =======================

def _type_of(obj, **kwargs):
    if isinstance(obj, BooleanValue):
        return StringValue('bool')
    if isinstance(obj, NumberValue):
        return StringValue('number')
    if isinstance(obj, QuotedStringValue):
        return StringValue('string')
    if isinstance(obj, ColorValue):
        return StringValue('color')
    if isinstance(obj, dict):
        return StringValue('list')
    return 'unknown'

def _unit(value, **kwargs):
    return NumberValue(value).units

def _unitless(value, **kwargs):
    if NumberValue(value).units:
        return BooleanValue(False)
    return BooleanValue(True)

def _comparable(n1, n2, **kwargs):
    n1, n2 = NumberValue(n1), NumberValue(n2)
    type1 = CONV_TYPE.get(n1.units)
    type2 = CONV_TYPE.get(n2.units)
    return BooleanValue(type1 == type2)


# Color functions
# ================

def _adjust_color(color, saturation=0.0, lightness=0.0, red=0.0, green=0.0, blue=0.0, alpha=0.0, **kwargs):
    return __asc_color(OPRT['+'], color, saturation, lightness, red, green, blue, alpha)

def _scale_color(color, saturation=1.0, lightness=1.0, red=1.0, green=1.0, blue=1.0, alpha=1.0, **kwargs):
    return __asc_color(OPRT['*'], color, saturation, lightness, red, green, blue, alpha)

def _change_color(color, saturation=None, lightness=None, red=None, green=None, blue=None, alpha=None, **kwargs):
    return __asc_color(None, color, saturation, lightness, red, green, blue, alpha)

def _invert(color, **kwargs):
    """ Returns the inverse (negative) of a color.
        The red, green, and blue values are inverted, while the opacity is left alone.
    """
    col = ColorValue(color)
    args = [
            255.0 - col.value[0],
            255.0 - col.value[1],
            255.0 - col.value[2],
            col.value[3],
        ]
    inverted = ColorValue(args)
    return inverted

def _adjust_lightness(color, amount, **kwargs):
    return hsl_op(OPRT['+'], color, 0, 0, amount)

def _adjust_saturation(color, amount, **kwargs):
    return hsl_op(OPRT['+'], color, 0, amount, 0)

def _scale_lightness(color, amount, **kwargs):
    return hsl_op(OPRT['*'], color, 0, 0, amount)

def _scale_saturation(color, amount, **kwargs):
    return hsl_op(OPRT['*'], color, 0, amount, 0)


# Compass helpers
# ================

def _color_stops(*args, **kwargs):
    raise NotImplementedError

def _elements_of_type(display, **kwargs):
    return StringValue(ELEMENTS_OF_TYPE.get(StringValue(display).value, ''))

def _enumerate(s, b, e, **kwargs):
    return ', '.join(
        "%s%d" % (StringValue(s).value, x) for x in xrange(int(b.value), int(e.value+1))
    )

def _font_files(*args, **kwargs):
    raise NotImplementedError

def _headings(a=None, b=None, **kwargs):
    h = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
    if not a or StringValue(a).value == 'all':
        a, b = 1, 6
    elif b is None:
        b, a = a.value + 1, 1
    return ', '.join(h[int(float(a)-1):int(float(b))])

def _nest(*args, **kwargs):
    return ', '.join(
        ' '.join(s.strip() for s in p)
            if not '&' in p[1] else p[1].replace('&', p[0].strip())
                for p in product(
                    *(StringValue(sel).value.split(',') for sel in args)
                )
        )

@check_pil
def _image_width(image, **kwargs):
    root = kwargs.get('root')
    path = os.path.abspath(os.path.join(root.get_opt('path'), StringValue(image).value))
    size = __get_size(path, root=root)
    return NumberValue([size[0], 'px'])

@check_pil
def _image_height(image, **kwargs):
    root = kwargs.get('root')
    path = os.path.abspath(os.path.join(root.get_opt('path'), StringValue(image).value))
    size = __get_size(path, root=root)
    return NumberValue([size[1], 'px'])

def _image_url(image, **kwargs):
    return QuotedStringValue(image).value

def _inline_image(image, mimetype=None, **kwargs):
    root = kwargs.get('root')
    path = os.path.abspath(os.path.join(root.get_opt('path'), StringValue(image).value))
    if os.path.exists(path):
        mimetype = StringValue(mimetype).value or mimetypes.guess_type(path)[0]
        f = open(path, 'rb')
        url = 'data:' + mimetype + ';base64,' + base64.b64encode(f.read())
    else:
        if root and root.get_opt('warn'):
            warn("Not found image: %s" % path)
        url = '%s?_=NA' % QuotedStringValue(image).value
    inline = 'url("%s")' % url
    return StringValue(inline)


# Misc
# ====

def _if(cond, body, els, **kwargs):
    if BooleanValue( cond ).value:
        return body
    return els


def _sprite_position(*args):
    pass

def _sprite_file(*args):
    pass

def _sprite(*args):
    pass

def _sprite_map(*args):
    pass

def _sprite_map_name(*args):
    pass

def _sprite_url(*args):
    pass

def _opposite_position(*args):
    pass

def _grad_point(*args):
    pass

def _grad_color_stops(*args):
    pass

def _nth(*args):
    pass

def _join(*args):
    pass

def _append(*args):
    pass

FUNCTION_LIST = {

    # RGB functions
    'rgb:3': _rgb,
    'rgba:4': _rgba,
    'red:1': _red,
    'green:1': _green,
    'blue:1': _blue,
    'mix:2': _mix,
    'mix:3': _mix,

    # HSL functions
    'hsl:3': _hsl,
    'hsla:4': _hsla,
    'hue:1': _hue,
    'saturation:1': _saturation,
    'lightness:1': _lightness,
    'adjust-hue:2': _adjust_hue,
    'spin:2': _adjust_hue,
    'lighten:2': _lighten,
    'darken:2': _darken,
    'saturate:2': _saturate,
    'desaturate:2': _desaturate,
    'grayscale:1': _grayscale,
    'complement:1': _complement,

    # Opacity functions
    'alpha:1': _alpha,
    'opacity:1': _alpha,
    'opacify:2': _opacify,
    'fadein:2': _opacify,
    'fade-in:2': _opacify,
    'transparentize:2': _transparentize,
    'fadeout:2': _transparentize,
    'fade-out:2': _transparentize,

    # String functions
    'quote:n': _quote,
    'unquote:n': _unquote,

    # Number functions
    'percentage:1': _percentage,
    'sin:1': _sin,
    'cos:1': _cos,
    'tan:1': _tan,
    'abs:1': _abs,
    'round:1': _round,
    'ceil:1': _ceil,
    'floor:1': _floor,
    'pi:0': _pi,

    # Introspection functions
    'type-of:1': _type_of,
    'unit:1': _unit,
    'unitless:1': _unitless,
    'comparable:2': _comparable,

    # Color functions
    'adjust-color:n': _adjust_color,
    'scale-color:n': _scale_color,
    'change-color:n': _change_color,
    'adjust-lightness:2': _adjust_lightness,
    'adjust-saturation:2': _adjust_saturation,
    'scale-lightness:2': _scale_lightness,
    'scale-saturation:2': _scale_saturation,
    'invert:1': _invert,

    # Compass helpers
    'append-selector:2': _nest,
    'color-stops:n': _color_stops,
    'enumerate:3': _enumerate,
    'elements-of-type:1': _elements_of_type,
    'font-files:n': _font_files,
    'headings:n': _headings,
    'nest:n': _nest,

    # Images functions
    'image-url:1': _image_url,
    'image-width:1': _image_width,
    'image-height:1': _image_height,
    'inline-image:1': _inline_image,
    'inline-image:2': _inline_image,

    # Not implemented
    'sprite-map:1': _sprite_map,
    'sprite:2': _sprite,
    'sprite:3': _sprite,
    'sprite:4': _sprite,
    'sprite-map-name:1': _sprite_map_name,
    'sprite-file:2': _sprite_file,
    'sprite-url:1': _sprite_url,
    'sprite-position:2': _sprite_position,
    'sprite-position:3': _sprite_position,
    'sprite-position:4': _sprite_position,

    'opposite-position:n': _opposite_position,
    'grad-point:n': _grad_point,
    'grad-color-stops:n': _grad_color_stops,

    'nth:2': _nth,
    'first-value-of:1': _nth,
    'join:2': _join,
    'join:3': _join,
    'append:2': _append,
    'append:3': _append,

    'if:3': _if,
    'escape:1': _unquote,
    'e:1': _unquote,

}

def __asc_color(op, color, saturation, lightness, red, green, blue, alpha):
    if lightness or saturation:
        color = hsl_op(op, color, 0, saturation, lightness)
    if red or green or blue or alpha:
        color = rgba_op(op, color, red, green, blue, alpha)
    return color

def __get_size(path, **kwargs):
    root = kwargs.get('root')
    if not IMAGES.has_key(path):

        if not os.path.exists(path):

            if root and root.get_opt('warn'):
                warn("Not found image: %s" % path)

            return 0, 0

        image = Image.open(path)
        IMAGES[path] = image.size
    return IMAGES[path]

########NEW FILE########
__FILENAME__ = grammar
" SCSS Grammars."
from pyparsing import Word, Suppress, Literal, alphanums, SkipTo, ZeroOrMore, Optional, OneOrMore, Forward, cStyleComment, Combine, dblSlashComment, quotedString, Regex, lineEnd, Group


__all__ = ("STYLESHEET", "NUMBER_VALUE", "quotedString", "EXPRESSION", "IDENT", "PATH", "VARIABLE", "VAR_DEFINITION", "VARIABLES", "FUNCTION", "COLOR_VALUE", "SCSS_COMMENT", "CSS_COMMENT", "IMPORT", "RULESET", "DECLARATION", "DECLARATION_NAME", "SELECTOR_TREE", "SELECTOR_GROUP", "SELECTOR", "MIXIN", "INCLUDE", "MIXIN_PARAM", "EXTEND", "FONT_FACE", "OPTION", "FUNCTION_DEFINITION", "FUNCTION_RETURN", "IF", "ELSE", "IF_BODY", "FOR", "FOR_BODY", "CHARSET", "MEDIA", "WARN", "SEP_VAL_STRING", "POINT")


# Base css word and literals
COMMA, COLON, SEMICOLON = [Suppress(c) for c in ",:;"]
OPT_SEMICOLON = Optional(SEMICOLON)
LACC, RACC, LPAREN, RPAREN = [Suppress(c) for c in "{}()"]
LLACC, LRACC, LBRACK, RBRACK = [Literal(c) for c in "{}[]"]

# Comment
CSS_COMMENT = cStyleComment + Optional(lineEnd)
SCSS_COMMENT = dblSlashComment

IDENT = Regex(r"-?[a-zA-Z_][-a-zA-Z0-9_]*")
COLOR_VALUE = Regex(r"#[a-zA-Z0-9]{3,6}")
VARIABLE = Regex(r"-?\$[-a-zA-Z_][-a-zA-Z0-9_]*")
NUMBER_VALUE = Regex(r"-?\d+(?:\.\d*)?|\.\d+") + Optional(Regex(r"(em|ex|px|cm|mm|in|pt|pc|deg|s|%)(?![-\w])"))
PATH = Regex(r"[-\w\d_\.]*\/{1,2}[-\w\d_\.\/\?\=\&]*") | Regex(r"((https?|ftp|file):((//)|(\\\\))+[\w\d:#@%/;$()~_?\+-=\\\.&]*)")
POINT_PART = (NUMBER_VALUE | Regex(r"(top|bottom|left|right)"))
POINT = POINT_PART + POINT_PART

# Values
EXPRESSION = Forward()
INTERPOLATION_VAR = Suppress("#") + LACC + EXPRESSION + RACC
SIMPLE_VALUE = NUMBER_VALUE | PATH | IDENT | COLOR_VALUE | quotedString
DIV_STRING = SIMPLE_VALUE + OneOrMore(Literal("/") + SIMPLE_VALUE)

PARAMS = LPAREN + (POINT|EXPRESSION) + ZeroOrMore(COMMA + (POINT|EXPRESSION)) + RPAREN
FUNCTION = Regex(r"-?[a-zA-Z_][-a-zA-Z0-9_]*") + PARAMS
VALUE = FUNCTION | VARIABLE | SIMPLE_VALUE
PARENS = LPAREN + EXPRESSION + RPAREN
MATH_OPERATOR = Regex(r"(\+|-|/|\*|and|or|==|!=|<=|<|>|>=)\s+")
_ = EXPRESSION << ((VALUE | PARENS) + ZeroOrMore(MATH_OPERATOR + (VALUE | PARENS)))

# Declaration
TERM = ( DIV_STRING | EXPRESSION | INTERPOLATION_VAR ) + Optional(",")
DECLARATION_NAME = Optional("*") + OneOrMore(IDENT | INTERPOLATION_VAR)
DECLARATION = Forward()
_ = DECLARATION << (
        DECLARATION_NAME +
        ":" +
        ZeroOrMore(TERM) +
        Optional("!important") +
        Optional(LACC + OneOrMore(DECLARATION | CSS_COMMENT | SCSS_COMMENT) + RACC) +
        OPT_SEMICOLON )

# Selectors
ELEMENT_NAME = Combine(OneOrMore(IDENT | '&')) | Literal("*")
ATTRIB = LBRACK + SkipTo("]") + RBRACK
CLASS_NAME = Word('.', alphanums + "-_")
HASH = Regex(r"#[-a-zA-Z_][-a-zA-Z0-9_]+")
FILTER = HASH | CLASS_NAME | ATTRIB

# PSEUDO = Regex(r':{1,2}[A-Za-z0-9-_]+')
PSEUDO = Regex(r':{1,2}[^\s;{}]+')

SELECTOR = OneOrMore(ELEMENT_NAME | FILTER | INTERPOLATION_VAR | PSEUDO)
SELECTOR.leaveWhitespace()
SELECTOR_GROUP = SELECTOR + ZeroOrMore(Optional(Word("+>", max=1)) + SELECTOR)
SELECTOR_GROUP.skipWhitespace = True
SELECTOR_TREE = SELECTOR_GROUP + ZeroOrMore(COMMA + SELECTOR_GROUP)

# @debug
DEBUG = "@debug" + EXPRESSION + OPT_SEMICOLON

# @warn
WARN = "@warn" + quotedString + OPT_SEMICOLON

# @include
INCLUDE = "@include" + IDENT + Optional( PARAMS ) + OPT_SEMICOLON

# @extend
EXTEND = "@extend" + OneOrMore(ELEMENT_NAME | FILTER | INTERPOLATION_VAR | PSEUDO) + OPT_SEMICOLON

# SCSS variable assigment
SEP_VAL_STRING = EXPRESSION + OneOrMore(COMMA + EXPRESSION)
VAR_DEFINITION = Regex(r"\$[a-zA-Z_][-a-zA-Z0-9_]*") + COLON + (SEP_VAL_STRING | EXPRESSION ) + Optional("!default") + OPT_SEMICOLON

RULESET = Forward()
IF = Forward()
CONTENT = CSS_COMMENT | SCSS_COMMENT | WARN | DEBUG | IF | INCLUDE | VAR_DEFINITION | RULESET | DECLARATION

# SCSS control directives
IF_BODY = LACC + ZeroOrMore(CONTENT) + RACC
ELSE = Suppress("@else") + LACC + ZeroOrMore(CONTENT) + RACC
_ = IF << (
        ( Suppress("@if") | Suppress("@else if") ) + EXPRESSION + IF_BODY + Optional(ELSE))

FOR_BODY = ZeroOrMore(CONTENT)
FOR = "@for" + VARIABLE + Suppress("from") + VALUE + (Suppress("through") | Suppress("to")) + VALUE + LACC + FOR_BODY + RACC

_ = RULESET << (
    SELECTOR_TREE +
    LACC + ZeroOrMore(CONTENT | FOR | EXTEND) + RACC )

# SCSS mixin
MIXIN_PARAM = VARIABLE + Optional(COLON + EXPRESSION)
MIXIN_PARAMS = LPAREN + ZeroOrMore(COMMA | MIXIN_PARAM) + RPAREN
MIXIN = "@mixin" + IDENT + Group(Optional(MIXIN_PARAMS)) + LACC + ZeroOrMore(CONTENT | FOR) + RACC

# SCSS function
FUNCTION_RETURN = "@return" + VARIABLE + OPT_SEMICOLON
FUNCTION_BODY = LACC + ZeroOrMore(VAR_DEFINITION) + FUNCTION_RETURN + RACC
FUNCTION_DEFINITION = "@function" + IDENT + Group(MIXIN_PARAMS) + FUNCTION_BODY

# Root elements
OPTION = "@option" + OneOrMore(IDENT + COLON + IDENT + Optional(COMMA)) + OPT_SEMICOLON
IMPORT = "@import" + FUNCTION + OPT_SEMICOLON
MEDIA = "@media" + IDENT + ZeroOrMore("," + IDENT) + LLACC + ZeroOrMore( CONTENT | MIXIN | FOR ) + LRACC
FONT_FACE = "@font-face" + LLACC + ZeroOrMore(DECLARATION) + LRACC
VARIABLES = ( Literal("@variables") | Literal('@vars') ) + LLACC + ZeroOrMore(VAR_DEFINITION) + RACC
PSEUDO_PAGE = ":" + IDENT
PAGE = "@page" + Optional(IDENT) + Optional(PSEUDO_PAGE) + LLACC + ZeroOrMore(DECLARATION) + LRACC
CHARSET = "@charset" + IDENT + OPT_SEMICOLON

# Css stylesheet
STYLESHEET = ZeroOrMore(
    FONT_FACE
    | CHARSET
    | OPTION
    | MEDIA
    | PAGE
    | CONTENT
    | FUNCTION_DEFINITION
    | MIXIN
    | FOR
    | IMPORT
    | VARIABLES
    | EXPRESSION
)

########NEW FILE########
__FILENAME__ = parser
import cPickle
import os.path
import sys
from collections import defaultdict

from pyparsing import ParseBaseException

from scss import SORTING
from scss.base import Node, Empty, ParseNode, ContentNode, IncludeNode
from scss.control import Variable, Expression, Function, Mixin, Include, MixinParam, Extend, Variables, Option, FunctionDefinition, FunctionReturn, If, For, SepValString
from scss.function import warn, _nest
from scss.grammar import *
from scss.value import NumberValue, StringValue, ColorValue, QuotedStringValue, PointValue


class Comment(Node):
    """ Comment node.
    """
    delim = ''
    def __str__(self):
        """ Clean comments if option `comments` disabled
            or enabled option `compress`
        """
        if self.root.get_opt('comments') and not self.root.get_opt('compress'):
            return super(Comment, self).__str__()
        return ''


class Warn(Empty):
    """ Warning node @warn.
    """
    def parse(self, target):
        """ Write message to stderr.
        """
        if self.root.get_opt('warn'):
            warn(self.data[1])


class Import(Node):
    """ Import node @import.
    """
    def __str__(self):
        """ Write @import to outstring.
        """
        return "%s;\n" % super(Import, self).__str__()


class Ruleset(ContentNode):
    """ Rule node.
    """
    def parse(self, target):
        """ Parse nested rulesets
            and save it in cache.
        """
        if isinstance(target, ContentNode):
            if target.name:
                self.parent = target
                self.name.parse(self)
                self.name += target.name
            target.ruleset.append(self)
        self.root.cache['rset'][str(self.name).split()[0]].add(self)
        super(Ruleset, self).parse(target)


class Declaration(ParseNode):
    """ Declaration node.
    """
    def __init__(self, s, n, t):
        """ Add self.name and self.expr to object.
        """
        super(Declaration, self).__init__(s, n, t)
        self.name = self.expr = ''

    def parse(self, target):
        """ Parse nested declaration.
        """
        if not isinstance(target, Node):
            parent = ContentNode(None, None, [])
            parent.parse(target)
            target = parent

        super(Declaration, self).parse(target)
        self.name = str(self.data[0])
        while isinstance(target, Declaration):
            self.name = '-'.join(( str(target.data[0]), self.name))
            target = target.parent

        self.expr = ' '.join(str(n) for n in self.data[2:] if not isinstance(n, Declaration))
        if self.expr:
            target.declareset.append(self)

    def __str__(self):
        """ Warning on unknown declaration
            and write current in outstring.
        """
        name = self.name.strip('*_#')
        if name.startswith('-moz-'):
            name = name[5:]
        elif name.startswith('-webkit-'):
            name = name[8:]
        elif name.startswith('-o-'):
            name = name[3:]
        elif name.startswith('-ms-'):
            name = name[4:]

        if (not SORTING.has_key(name)
                and self.root.get_opt('warn')):
            warn("Unknown declaration: %s" % self.name)

        return (":%s" % self.root.cache['delims'][1] ).join(
                (self.name, self.expr))


class DeclarationName(ParseNode):
    """ Name of declaration node.
        For spliting it in one string.
    """
    delim = ''


class SelectorTree(ParseNode):
    """ Tree of selectors in ruleset.
    """
    delim = ', '

    def extend(self, target):
        """ @extend selectors tree.
        """
        self_test = ', '.join(map(str, self.data))
        target_test = ', '.join(map(str, target.data))
        self.data = (self_test + ', ' + self_test.replace(str(self.data[0].data[0]), target_test)).split(', ')

    def __add__(self, target):
        """ Add selectors from parent nodes.
        """
        if isinstance(target, SelectorTree):
            self_test = ', '.join(map(str, self.data))
            target_test = ', '.join(map(str, target.data))
            self.data = _nest(target_test, self_test).split(', ')
        return self


class Selector(ParseNode):
    """ Simple selector node.
    """
    delim = ''

    def __str__(self):
        """ Write to output.
        """
        return ''.join(StringValue(n).value for n in self.data)


class VarDefinition(ParseNode, Empty):
    """ Variable definition.
    """
    def __init__(self, s, n, t):
        """ Save self.name, self.default, self.expression
        """
        super(VarDefinition, self).__init__(s, n, t)
        self.name = t[0][1:]
        self.default = len(t) > 2
        self.expression = t[1]

    def parse(self, target):
        """ Update root and parent context.
        """
        super(VarDefinition, self).parse(target)
        if isinstance(self.parent, ParseNode):
            self.parent.ctx.update({ self.name: self.expression.value })
        self.root.set_var(self)


class Stylesheet(object):
    """ Root stylesheet node.
    """

    def_delims = '\n', ' ', '\t'

    def __init__(self, cache = None, options=None):
        self.cache = cache or dict(

            # Variables context
            ctx = dict(),

            # Mixin context
            mix = dict(),

            # Rules context
            rset = defaultdict(set),

            # Options context
            opts = dict(
                comments = True,
                warn = True,
                sort = True,
                path = os.getcwd(),
            ),

            # CSS delimeters
            delims = self.def_delims,

        )

        if options:
            for option in options.items():
                self.set_opt(*option)

        self.setup()
        Node.root = self

    @staticmethod
    def setup():

        # Values
        NUMBER_VALUE.setParseAction(NumberValue)
        IDENT.setParseAction(StringValue)
        PATH.setParseAction(StringValue)
        POINT.setParseAction(PointValue)
        COLOR_VALUE.setParseAction(ColorValue)
        quotedString.setParseAction(QuotedStringValue)
        EXPRESSION.setParseAction(Expression)
        SEP_VAL_STRING.setParseAction(SepValString)

        # Vars
        VARIABLE.setParseAction(Variable)
        VAR_DEFINITION.setParseAction(VarDefinition)
        VARIABLES.setParseAction(Variables)
        FUNCTION.setParseAction(Function)
        FUNCTION_DEFINITION.setParseAction(FunctionDefinition)
        FUNCTION_RETURN.setParseAction(FunctionReturn)

        # Coments
        SCSS_COMMENT.setParseAction(lambda x: '')
        CSS_COMMENT.setParseAction(Comment)

        # At rules
        IMPORT.setParseAction(Import)
        CHARSET.setParseAction(Import)
        MEDIA.setParseAction(Node)

        # Rules
        RULESET.setParseAction(Ruleset)
        DECLARATION.setParseAction(Declaration)
        DECLARATION_NAME.setParseAction(DeclarationName)
        SELECTOR.setParseAction(Selector)
        SELECTOR_GROUP.setParseAction(ParseNode)
        SELECTOR_TREE.setParseAction(SelectorTree)
        FONT_FACE.setParseAction(ContentNode)

        # SCSS Directives
        MIXIN.setParseAction(Mixin)
        MIXIN_PARAM.setParseAction(MixinParam)
        INCLUDE.setParseAction(Include)
        EXTEND.setParseAction(Extend)
        OPTION.setParseAction(Option)
        IF.setParseAction(If)
        IF_BODY.setParseAction(IncludeNode)
        ELSE.setParseAction(IncludeNode)
        FOR.setParseAction(For)
        FOR_BODY.setParseAction(IncludeNode)
        WARN.setParseAction(Warn)

    @property
    def ctx(self):
        return self.cache['ctx']

    def set_var(self, vardef):
        """ Set variable to global stylesheet context.
        """
        if not(vardef.default and self.cache['ctx'].get(vardef.name)):
            self.cache['ctx'][vardef.name] = vardef.expression.value

    def set_opt(self, name, value):
        """ Set option.
        """
        self.cache['opts'][name] = value

        if name == 'compress':
            self.cache['delims'] = self.def_delims if not value else ('', '', '')

    def get_opt(self, name):
        """ Get option.
        """
        return self.cache['opts'].get(name)

    def update(self, cache):
        """ Update self cache from other.
        """
        self.cache['delims'] = cache.get('delims')
        self.cache['opts'].update(cache.get('opts'))
        self.cache['rset'].update(cache.get('rset'))
        self.cache['mix'].update(cache.get('mix'))
        map(self.set_var, cache['ctx'].values())

    @staticmethod
    def scan(src):
        """ Scan scss from string and return nodes.
        """
        assert isinstance(src, basestring)
        try:
            nodes = STYLESHEET.parseString(src, parseAll=True)
            return nodes
        except ParseBaseException:
            err = sys.exc_info()[1]
            print >> sys.stderr, err.line
            print >> sys.stderr, " "*(err.column-1) + "^"
            print >> sys.stderr, err
            sys.exit(1)

    def parse(self, nodes):
        map(lambda n: n.parse(self) if isinstance(n, Node) else None, nodes)

    def loads(self, src):
        """ Compile css from scss string.
        """
        assert isinstance(src, basestring)
        nodes = self.scan(src.strip())
        self.parse(nodes)
        return ''.join(map(str, nodes))

    def load(self, f, precache=None):
        """ Compile scss from file.
            File is string path of file object.
        """
        precache = precache or self.get_opt('cache') or False
        nodes = None
        if isinstance(f, file):
            path = os.path.abspath(f.name)

        else:
            path = os.path.abspath(f)
            f = open(f)

        cache_path = os.path.splitext(path)[0] + '.ccss'

        if precache and os.path.exists(cache_path):
            ptime = os.path.getmtime(cache_path)
            ttime = os.path.getmtime(path)
            if ptime > ttime:
                dump = open(cache_path, 'rb').read()
                nodes = cPickle.loads(dump)

        if not nodes:
            src = f.read()
            nodes = self.scan(src.strip())

        if precache:
            f = open(cache_path, 'wb')
            cPickle.dump(nodes, f)

        self.parse(nodes)
        return ''.join(map(str, nodes))


def parse( src, cache=None ):
    """ Parse from string.
    """
    parser = Stylesheet(cache)
    return parser.loads(src)


def load(path, cache=None, precache=False):
    """ Parse from file.
    """
    parser = Stylesheet(cache)
    return parser.load(path, precache=precache)

########NEW FILE########
__FILENAME__ = test_color_functions
import unittest

from scss.parser import Stylesheet

def verify_testcases(func):
    """Runs the output of the function through SCSS and compares output.

    To use: Write a function that returns a list of tuples, where the first
    element of the tuple is SCSS code and the second element the expected
    output. When you place this decorator around your function it will take the
    SCSS code, run the parser over it and assert the output equals the expected
    output."""

    def assert_testcases(self, *args, **kwargs):
        for (testcase, expected_output) in func(self, *args, **kwargs):
            out = self.parser.loads(testcase)
            self.assertEqual(expected_output, out)
    return assert_testcases

class TestSCSS( unittest.TestCase ):
    """Test color functions

    """
    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    @verify_testcases
    def test_invert(self):
        return [
            ('invert(#000)', '#fff'),
            ('invert(#fff)', '#000'),
            ('invert(#567)', '#a98'),
            ('invert(invert(#123456))', '#123456'),
            ('invert(rgba(100, 110, 120, 0.7))', 'rgba(155,145,135,0.70)'),
            ('invert(hsla(0, 50%, 50%, 0.7))',   'rgba(63,191,191,0.70)'),
        ]
    
    @verify_testcases
    def test_adjust_lightness(self):
        # First example is taken from
        # http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html
        return [
            ('adjust-lightness(#800, 20%)', '#e00'),
        ]

########NEW FILE########
__FILENAME__ = test_extend
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_extend(self):
        src = """
        .error {
            _border: 1px #f00;
            background-color: #fdd;
        }
        .error .intrusion {
            background-image: url("/image/hacked.png");
        }
        .seriousError {
            @extend .error;
            border-width: 3px;
        }
        """
        test = ".error, .seriousError{_border:1px #f00;background-color:#fdd}.error .intrusion, .seriousError .intrusion{background-image:url('/image/hacked.png')}.seriousError{border-width:3px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_fake
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_math(self):
        src = """
           margin: 2px - 5em -1px 0;
        """
        test = ""
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_files
import os.path
import unittest

from scss import parser


class ScssCache(unittest.TestCase):

    def test_cache(self):
        path = os.path.join(os.path.dirname(__file__), 'example.scss')
        src = open(path).read()
        test = parser.parse(src)
        out = parser.load(open(path), precache=True)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_font_face
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_font_face(self):
        src = """
            @font-face {
                    font-family: 'MyMinionPro';
                src: url('minion-webfont.eot?') format('eot'),
                    url('minion-webfont.woff') format('woff'),
                    url('minion-webfont.ttf') format('truetype');
                    font-weight: normal;
                    font-style: normal;
                    font-size: ( 12px / 16px ) * 100%;
            }

            @font-face {
                    font-family: 'MyMinionProItalic';
                src: url('minionpro-it-webfont.eot?') format('eot'),
                    url('minionpro-it-webfont.woff') format('woff'),
                    url('minionpro-it-webfont.ttf') format('truetype');
                    font-weight: normal;
                    font-style: italic;
            }

            h1,h2,h3, time, ol#using .number {
                    font-weight: normal;
                    font-family: 'MyMinionPro';
            }
        """
        test = "@font-face{font-weight:normal;font-style:normal;font-size:75%;font-family:'MyMinionPro';src:url('minion-webfont.eot?') format('eot') , url('minion-webfont.woff') format('woff') , url('minion-webfont.ttf') format('truetype')}@font-face{font-weight:normal;font-style:italic;font-family:'MyMinionProItalic';src:url('minionpro-it-webfont.eot?') format('eot') , url('minionpro-it-webfont.woff') format('woff') , url('minionpro-it-webfont.ttf') format('truetype')}h1, h2, h3, time, ol#using .number{font-weight:normal;font-family:'MyMinionPro'}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_for
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_for(self):
        src = """
            @mixin test($src:2px){
                $width: $src + 5px;
                width: $width;
            }
            .test {
                color: blue;
                @for $i from 1 through 4 {
                    .span-#{$i}{
                        @include test($i); }
                }
            }

            @for $i from 1 through 2 {
                .span-#{$i}{
                    color: red; }
            }
        """
        test = ".test{color:#00f}.test .span-1{width:6px}.test .span-2{width:7px}.test .span-3{width:8px}.test .span-4{width:9px}.span-1{color:#f00}.span-2{color:#f00}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_functions
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_math(self):
        src = " 12 * (60px + 20px) "
        test = "960px"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_operations_and_functions(self):
        src = """
        #navbar {
            $navbar-width: 800px;
            $items: 1 + 2;
            $navbar-color: rgb(100, 100, 55);
            $font: "Verdana", monospace;
            width: $navbar-width;
            border-bottom: 2px solid $navbar-color;

            #{enumerate("div", 1, $items)} {
                p & {
                    color: blue }
                color: red; }
            }

            li {
                background-color: $navbar-color - #333;
                background-image: url(test/value.png);
                float: left;
                font: 8px/10px $font;
                margin: 3px + 5.5px auto;
                height: 5px + (4px * (2 + $items));
                width: $navbar-width / $items - 10px;
                &:hover { background-color: $navbar-color - 10%; } }"""
        test = "#navbar{width:800px;border-bottom:2px solid #646437}#navbar div1, #navbar div2, #navbar div3{color:#f00}p #navbar div1, p #navbar div2, p #navbar div3{color:#00f}li{float:left;margin:8.5px auto;width:256.667px;height:25px;background-color:#313104;background-image:url(test/value.png);font:8px / 10px 'Verdana', monospace}li:hover{background-color:#5c5c3e}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_rgb_functions(self):
        src = """
            @option warn:false;

            $color: rgba(23, 45, 67, .4)
            $color2: #fdc;
            .test {
                red_test: red($color);
                blue_test: blue($color);
                green_test: green($color);
                color: mix(#f00, #00f, 25%);
            }
        """
        test = ".test{color:#3f00bf;red_test:23;blue_test:67;green_test:45}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_hsl_functions(self):
        src = """
            @option warn:false;

            $hsl: hsla(0, 100%, 25%, .4);
            .test {
                color: $hsl;
                hue: hue($hsl);
                s: saturation($hsl);
                g: grayscale(#099);
                l: lighten(#333, 50%);
                ah: adjust-hue(#811, 45deg);
            }
        """
        test = ".test{color:rgba(127,0,0,0.40);hue:0;s:100%;g:#4c4c4c;l:#b2b2b2;ah:#886a10}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_opacity_functions(self):
        src = """
            $color: rgba(100, 100, 100, .4);
            .test {
                color: opacify( $color, 60% );
            }
        """
        test = ".test{color:#646464}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_string_functions(self):
        src = """
            $top: 'top';
            $bottom: bottom;
            .test {
                bottom: quote($bottom);
                top: unquote($top);
            }
        """
        test = ".test{top:top;bottom:'bottom'}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_number_functions(self):
        src = """
            @option warn:false;

            $top: 100px;
            $bottom: 50px;
            .test {
                top: percentage($top / $bottom);
                round: round($top);
                ceil: ceil(1.24);
                floor: floor(1.24);
                abs: abs(-1.24);
            }
        """
        test = ".test{top:200%;round:100.0;ceil:2.0;floor:1.0;abs:1.24}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_introspection_functions(self):
        src = """
            @option warn:false;

            $top: 100px;
            $color: #f00;
            .test {
                test: type-of($top);
                test2: type-of($color);
                test3: unit($top);
                test4: unitless($top);
            }
        """
        test = ".test{test:number;test2:color;test3:px;test4:false}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_compass_helpers(self):
        src = """
            #{append-selector(".foo, .bar", ".baz")} {
                color: red;
            }

            .example {

                #{elements-of-type(block)} {
                    border: 1px solid #777777;
                    margin: 1em 3em; }

                #{elements-of-type(inline)} {
                    color: #cc0000; }
            }

            a {
                #{headings(2, 4)} {
                    font-weight: bold;
                }
            }
        """
        test = ".foo .baz, .bar .baz{color:#f00}.example address, .example article, .example aside, .example blockquote, .example center, .example dd, .example dialog, .example dir, .example div, .example dl, .example dt, .example fieldset, .example figure, .example footer, .example form, .example frameset, .example h1, .example h2, .example h3, .example h4, .example h5, .example h6, .example header, .example hgroup, .example hr, .example isindex, .example menu, .example nav, .example noframes, .example noscript, .example ol, .example p, .example pre, .example section, .example ul{margin:1em 3em;border:1px solid #777}.example a, .example abbr, .example acronym, .example b, .example basefont, .example bdo, .example big, .example br, .example cite, .example code, .example dfn, .example em, .example font, .example i, .example img, .example input, .example kbd, .example label, .example q, .example s, .example samp, .example select, .example small, .example span, .example strike, .example strong, .example sub, .example sup, .example textarea, .example tt, .example u, .example var{color:#c00}a h2, a h3, a h4{font-weight:bold}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_image_functions(self):
        src = """
            img.test {
                width: image-width(scss/tests/ + 'bug_64.png');
                height: image-height(scss/tests/ + 'bug_64.png');
                background-image: inline-image(scss/tests/ + 'test.png')

            }
        """
        test = 'img.test{width:64px;height:64px;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAMAAAC67D+PAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAlQTFRF8EFB3AAA////d5xsogAAAAN0Uk5T//8A18oNQQAAAClJREFUeNpiYIIDBkYGCAXEYDaEAFEQKbAQVBEyE6EASRuSYQgrAAIMAB1mAIkfpDEtAAAAAElFTkSuQmCC")}'
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_function_define(self):
        src = """
            @function percent-width($t, $c) {
                $perc: $t / $c * 100%;
                @return $perc;
            }

            .test {
                width: percent-width(5px, 24px);
            }
        """
        test = ".test{width:20.833%}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_misc(self):
        src = """
            $test: center;
            .test {
                margin: 0 if($test == center, auto, 10px);
            }
        """
        test = ".test{margin:0 auto}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_if
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_if(self):
        src = """
            $type: monster;
            $test: 9px;

            $rec: true;
            $rec2: $rec or true;
            $rec3: $rec or true;
            $rec: $rec2 or $rec3;

            @if $test + 2 > 10 {
                @if $rec {
                    .test { border: 2px; }
                }
            }

            @mixin test($fix: true) {
                @if $fix {
                    display: block;
                } @else {
                    display: none;
                }
            }
            span {
                @include test(false)
            }
            p {
                @if $type == girl {
                    color: pink;
                }
                @else if $type == monster {
                    color: red;
                    b { border: 2px; }
                }
                @else {
                    color: blue;
                }
            }
        """
        test = ".test{border:2px}span{display:none}p{color:#f00}p b{border:2px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_mixin
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_mixin(self):
        src = """
        @mixin font {
            font: {
                weight: inherit;
                style: inherit;
                size: 100%;
                family: inherit; };
            vertical-align: baseline; }

        @mixin global {
            .global {
                border:red;
                @include font;
            }
        }

        @include global;

        @mixin rounded-top( $radius:10px ) {
            $side: top;
            border-#{$side}-radius: $radius;
            -moz-border-radius-#{$side}: $radius;
            -webkit-border-#{$side}-radius: $radius;
        }
        #navbar li { @include rounded-top; }
        #footer { @include rounded-top(5px); }
        """
        test = ".global{border:#f00;vertical-align:baseline;font-weight:inherit;font-style:inherit;font-size:100%;font-family:inherit}#navbar li{border-top-radius:10px;-moz-border-radius-top:10px;-webkit-border-top-radius:10px}#footer{border-top-radius:5px;-moz-border-radius-top:5px;-webkit-border-top-radius:5px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_nesting
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_variables(self):
        src = """
            table.hl {
                margin: 2em 0;
                td.ln {
                    text-align: right;

                    li {
                        color: red;
                    }
                    &:hover {
                        width: 20px;
                    }
                }
            }

            li {
                font: {
                    family: serif;
                    weight: bold;
                    size: 1.2em;
                }
            }
            """
        test = "table.hl{margin:2em 0}table.hl td.ln{text-align:right}table.hl td.ln li{color:#f00}table.hl td.ln:hover{width:20px}li{font-weight:bold;font-size:1.2em;font-family:serif}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)


########NEW FILE########
__FILENAME__ = test_options
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet()

    def test_default(self):
        src = """
        @option compress:false;
        // SCSS comment
        /* CSS Comment */
        #navbar {
            height: 100px;
            color: #ff0033;
            border: 2px solid magenta;
            @warn "Test";

            li {
                background-color: red - #333;
                float: left;
                font: 8px/10px verdana;
                margin: 3px + 5.5px auto;
                height: 5px + (4px * 2);
            }
        }
        """
        test = "/* CSS Comment */\n#navbar {\n\theight: 100px;\n\tborder: 2px solid #f0f;\n\tcolor: #f03;}\n\n#navbar li {\n\tfloat: left;\n\tmargin: 8.5px auto;\n\theight: 13px;\n\tbackground-color: #c00;\n\tfont: 8px / 10px verdana;}\n\n"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_compress(self):
        src = """
        @option compress:true;
        // SCSS comment
        /* CSS Comment */
        #navbar, p {
            height: 100px;
            color: #ff0033;
            border: 2px solid magenta;

            li {
                background-color: red - #333;
                float: left;
                font: 8px/10px verdana;
                margin: 3px + 5.5px auto;
                height: 5px + (4px * 2);
            }
        }
        """
        test = "#navbar, p{height:100px;border:2px solid #f0f;color:#f03}#navbar li, p li{float:left;margin:8.5px auto;height:13px;background-color:#c00;font:8px / 10px verdana}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_comments(self):
        src = """
        @option comments:false, compress: false;
        // SCSS comment
        /* CSS Comment */
        #navbar, p {
            height: 100px;
            color: #ff0033;
            border: 2px solid magenta;

            li {
                background-color: red - #333;
                float: left;
                font: 8px/10px verdana;
                margin: 3px + 5.5px auto;
                height: 5px + (4px * 2);
            }
        }
        """
        test = "#navbar, p {\n\theight: 100px;\n\tborder: 2px solid #f0f;\n\tcolor: #f03;}\n\n#navbar li, p li {\n\tfloat: left;\n\tmargin: 8.5px auto;\n\theight: 13px;\n\tbackground-color: #c00;\n\tfont: 8px / 10px verdana;}\n\n"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_sortings(self):
        src = """
        @option comments:true, compress: false, sort: false;
        // SCSS comment
        /* CSS Comment */
        #navbar, p {
            height: 100px;
            color: #ff0033;
            border: 2px solid magenta;

            li {
                background-color: red - #333;
                float: left;
                font: 8px/10px verdana;
                margin: 3px + 5.5px auto;
                height: 5px + (4px * 2);
            }
        }
        """
        test = "/* CSS Comment */\n#navbar, p {\n\theight: 100px;\n\tcolor: #f03;\n\tborder: 2px solid #f0f;}\n\n#navbar li, p li {\n\tbackground-color: #c00;\n\tfloat: left;\n\tfont: 8px / 10px verdana;\n\tmargin: 8.5px auto;\n\theight: 13px;}\n\n"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_scss
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_bugs(self):
        src = """
            .bug {
                background: -webkit-gradient(linear, top left, 100% 100%, from(#ddd), to(#aaa));
                background: -moz-linear-gradient (top, #DDD, #AAA);
                margin: 2px -5em -1px 0;
            }
        """
        test = ".bug{margin:2px -5em -1px 0;background:-webkit-gradient(linear, top left, 100% 100%, from(#ddd), to(#aaa));background:-moz-linear-gradient(top, #ddd, #aaa)}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_base(self):
        src = """
            @charset utf-8;
            @import url(test);

            @warn "Test warnings!"
            @mixin z-base {
                a:hover, a:active { outline: none; }
                a, a:active, a:visited { color: #607890; }
                a:hover { color: #036; }
                @debug test; }

            @media print { @include z-base; }

            // Test comment
            /* Css comment */
            body:not(.test) {
                $font: Georgia;

                margin-bottom: .5em;
                font-family: $font, sans-serif;
                *font:13px/1.231 sans-serif; }

            ::selection {
                color: red;
            }

            .test:hover {
                color: red;
                &:after {
                    content: 'blue'; }}

            pre, code, kbd, samp {
                font: 12px/10px;
                font-family: monospace, sans-serif; }

            abbr[title], dfn[title] {
                border:2px; }

            """
        test = "@charset utf-8;\n@import url(test);\n@media print { a:hover, a:active{outline:none}a, a:active, a:visited{color:#607890}a:hover{color:#036} }body:not(.test){margin-bottom:.5em;*font:13px / 1.231 sans-serif;font-family:Georgia , sans-serif}::selection{color:#f00}.test:hover{color:#f00}.test:hover:after{content:#00f}pre, code, kbd, samp{font:12px / 10px;font-family:monospace , sans-serif}abbr[title], dfn[title]{border:2px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_nesting_2(self):
        src = """#navbar {
          width: 80%;
          height: 23px;
          ul { list-style-type: none; }
          li { float: left;
            a .test .main{ font-weight: bold; }
          } }"""
        test = "#navbar{width:80%;height:23px}#navbar ul{list-style-type:none}#navbar li{float:left}#navbar li a .test .main{font-weight:bold}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_nestproperties(self):
        src = """.fakeshadow {
            border: {
                style: solid;
                left: { width: 4px; color: #888; }
                right: { width: 2px; color: #ccc; }
            } }"""
        test = ".fakeshadow{border-style:solid;border-right-width:2px;border-right-color:#ccc;border-left-width:4px;border-left-color:#888}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_parent_references(self):
        src = """a { color: #ce4dd6;
            &:hover { color: #ffb3ff; }
            &:visited { color: #c458cb; }
            .test & { color: red; }}"""
        test = "a{color:#ce4dd6}a:hover{color:#ffb3ff}a:visited{color:#c458cb}.test a{color:#f00}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_variables(self):
        src = """$main-color: #ce4dd6;
            $style: solid;
            $def_test: first;
            $def_test: second;
            $def_test: beep-beep !default;
            #navbar { border-bottom: { color: $main-color; style: $style; } }
            a.#{$def_test} { color: $main-color; &:hover { border-bottom: $style 1px; } }"""
        test = "#navbar{border-bottom-style:solid;border-bottom-color:#ce4dd6}a.second{color:#ce4dd6}a.second:hover{border-bottom:solid 1px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_interpolation(self):
        src = """$side: top;
            $radius: 10px;
            div.rounded-#{$side} p {
            border-#{$side}-radius: $radius;
            -moz-border-radius-#{$side}: $radius;
            -webkit-border-#{$side}-radius: $radius; }"""
        test = "div.rounded-top p{border-top-radius:10px;-moz-border-radius-top:10px;-webkit-border-top-radius:10px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_mixin_arg(self):
        src = """@mixin rounded($side, $radius: 10px, $dummy: false) {
            border-#{$side}-radius: $radius;
            -moz-border-radius-#{$side}: $radius;
            -webkit-border-#{$side}-radius: $radius; }
            #navbar li { @include rounded(top); }
            #footer { @include rounded(top, 5px); }
            #sidebar { @include rounded(left, 8px); }"""
        test = "#navbar li{border-top-radius:10px;-moz-border-radius-top:10px;-webkit-border-top-radius:10px}#footer{border-top-radius:5px;-moz-border-radius-top:5px;-webkit-border-top-radius:5px}#sidebar{border-left-radius:8px;-moz-border-radius-left:8px;-webkit-border-left-radius:8px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

    def test_extend_rule(self):
        src = """
            .error { border: 1px #f00; background-color: #fdd; }
            a:hover {text-decoration: underline}
            .hoverlink {@extend a:hover}
            .error .intrusion { background-image: url(/image/hacked.png); }
            .seriousError { @extend .error; border-width: 3px; }
            """
        test = ".error, .seriousError{border:1px #f00;background-color:#fdd}a:hover{text-decoration:underline}.error .intrusion, .seriousError .intrusion{background-image:url(/image/hacked.png)}.seriousError{border-width:3px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = test_variables
import unittest

from scss.parser import Stylesheet


class TestSCSS( unittest.TestCase ):

    def setUp(self):
        self.parser = Stylesheet(options=dict(compress=True))

    def test_variables(self):
        src = """
            @vars {
                $blue: #ffdd00 !default;
                $test: rgb(120, 35, 64);
                $test2: rgba(120, 35, 64, .4);
                $property: float;
                $value: left;
                $len: 0px or 5px;
            }
            $margin: 16px;
            $side: top;
            $image: 'test.png';

            .content-navigation {
                #{$property}: #{$value};
                border-color: $blue;
                background-color: $test + 5%;


                background-image: url('/test/' + $image);
                display: -moz-inline-box;
                color: $blue - 9%;
                margin: $len (-$margin * 2 ) -12px;
            }

            .border {
                padding-#{$side}: $margin / 2;
                margin: $margin / 2;
                padding-left: -$margin + 2px;
                border-#{$side}: {
                    color:  $blue;
                }
                color: $test2;
                font: -1.5em + 50px;
            }
            """
        test = ".content-navigation{float:left;display:-moz-inline-box;margin:5px -32px -12px;border-color:#fd0;background-color:#7b1f3e;background-image:url(/test/test.png);color:#f3d40b}.border{margin:8px;padding-top:8px;padding-left:-14px;border-top-color:#fd0;color:rgba(120,35,64,0.40);font:30.5px}"
        out = self.parser.loads(src)
        self.assertEqual(test, out)

########NEW FILE########
__FILENAME__ = tool
""" Command-line tool to parse scss file.
"""
import optparse
import sys, os
import time

from scss import parser, VERSION


COMMANDS = ['import', 'option', 'mixin', 'include', 'for', 'if', 'else']


def complete(text, state):
    """ Auto complete scss constructions
        in interactive mode.
    """
    for cmd in COMMANDS:
        if cmd.startswith(text):
            if not state:
                return cmd
            else:
                state -= 1


def main(argv=None):

    try:
        # Upgrade shell in interactive mode
        import atexit
        import readline
        history = os.path.join(os.environ['HOME'], ".scss-history")
        atexit.register(readline.write_history_file, history)
        readline.parse_and_bind("tab: complete")
        readline.set_completer(complete)
        readline.read_history_file(history)
    except ( ImportError, IOError ):
        pass

    # Create options
    p = optparse.OptionParser(
        usage="%prog [OPTION]... [INFILE] [OUTFILE]",
        version="%prog " + VERSION,
        epilog="SCSS compiler.",
        description="Compile INFILE or standard input, to OUTFILE or standard output.")

    p.add_option(
        '-c', '--cache', action='store_true', dest='cache',
        help="Create and use cache file. Only for files.")

    p.add_option(
        '-i', '--interactive', action='store_true', dest='shell',
        help="Run in interactive shell mode.")

    p.add_option(
        '-m', '--compress', action='store_true', dest='compress',
        help="Compress css output.")

    p.add_option(
        '-w', '--watch', dest='watch',
        help="""Watch files or directories for changes.
The location of the generated CSS can be set using a colon:
    scss -w input.scss:output.css
""")

    p.add_option(
        '-S', '--no-sorted', action='store_false', dest='sort',
        help="Do not sort declaration.")

    p.add_option(
        '-C', '--no-comments', action='store_false', dest='comments',
        help="Clear css comments.")

    p.add_option(
        '-W', '--no-warnings', action='store_false', dest='warn',
        help="Disable warnings.")

    opts, args = p.parse_args(argv or sys.argv[1:])
    precache = opts.cache

    # Interactive mode
    if opts.shell:
        p = parser.Stylesheet()
        print 'SCSS v. %s interactive mode' % VERSION
        print '================================'
        print 'Ctrl+D or quit for exit'
        while True:
            try:
                s = raw_input('>>> ').strip()
                if s == 'quit':
                    raise EOFError
                print p.loads(s)
            except (EOFError, KeyboardInterrupt):
                print '\nBye bye.'
                break

        sys.exit()

    # Watch mode
    elif opts.watch:
        self, sep, target = opts.watch.partition(':')
        files = []
        if not os.path.exists(self):
            print >> sys.stderr, "Path don't exist: %s" % self
            sys.exit(1)

        if os.path.isdir(self):
            for f in os.listdir(self):
                path = os.path.join(self, f)
                if os.path.isfile(path) and f.endswith('.scss'):
                    tpath = os.path.join(target or self, f[:-5] + '.css')
                    files.append([ path, tpath, 0 ])
        else:
            files.append([ self, target or self[:-5] + '.css', 0 ])

        s = parser.Stylesheet(
            options=dict(
                comments = opts.comments,
                compress = opts.compress,
                warn = opts.warn,
                sort = opts.sort,
                cache = precache,
            ))

        def parse(f):
            infile, outfile, mtime = f
            ttime = os.path.getmtime(infile)
            if mtime < ttime:
                print " Parse '%s' to '%s' .. done" % ( infile, outfile )
                out = s.load(open(infile, 'r'))
                open(outfile, 'w').write(out)
                f[2] = os.path.getmtime(outfile)

        print 'SCSS v. %s watch mode' % VERSION
        print '================================'
        print 'Ctrl+C for exit\n'
        while True:
            try:
                for f in files:
                    parse(f)
                time.sleep(0.3)
            except OSError:
                pass
            except KeyboardInterrupt:
                print "\nSCSS stoped."
                break

        sys.exit()


    # Default compile files
    elif not args:
        infile = sys.stdin
        outfile = sys.stdout
        precache = False

    elif len(args) == 1:
        try:
            infile = open(args[0], 'r')
            outfile = sys.stdout
        except IOError, e:
            sys.stderr.write(str(e))
            sys.exit()

    elif len(args) == 2:
        try:
            infile = open(args[0], 'r')
            outfile = open(args[1], 'w')
        except IOError, e:
            sys.stderr.write(str(e))
            sys.exit()

    else:
        p.print_help(sys.stdout)
        sys.exit()

    try:
        s = parser.Stylesheet(
            options=dict(
                comments = opts.comments,
                compress = opts.compress,
                warn = opts.warn,
                sort = opts.sort,
                cache = precache,
            ))
        outfile.write(s.load(infile))
    except ValueError, e:
        raise SystemExit(e)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = value
" SCSS Values."

from colorsys import rgb_to_hls, hls_to_rgb
from pyparsing import ParseResults

from scss import OPRT, CONV_FACTOR, COLORS
from scss.base import Node


hex2rgba = {
    8: lambda c: (int(c[0:2], 16), int(c[2:4], 16), int(c[4:6], 16), int(c[6:8], 16)),
    6: lambda c: (int(c[0:2], 16), int(c[2:4], 16), int(c[4:6], 16), 1.0),
    4: lambda c: (int(c[0]*2, 16), int(c[1]*2, 16), int(c[2]*2, 16), int(c[3]*2, 16)),
    3: lambda c: (int(c[0]*2, 16), int(c[1]*2, 16), int(c[2]*2, 16), 1.0),
}


def hsl_op(op, color, h, s, l):
    color = ColorValue(color)
    h, s, l = map(NumberValue, (h, s, l))
    h.units = 'deg'
    s.units = l.units = '%'
    other_hls = map(float, (h, l, s))
    self_hls = rgb_to_hls(*map(lambda x: x / 255.0, color.value[:3]))
    res_hls = map(lambda x, y: op(x, y) if op else y if y else x, self_hls, other_hls)
    res_hls = map(lambda x: 1 if x > 1 else 0 if x < 0 else x, res_hls)
    res = hls_to_rgb(*res_hls)
    return ColorValue((res[0] * 255.0, res[1] * 255.0, res[2] * 255.0, color.value[3]))


def rgba_op(op, color, r, g, b, a):
    other = (float(r), float(g), float(b), float(a))
    res = map(op or ( lambda x, y: x or y ), color.value, other)
    res[3] = 1 if float(a) == color.value[3] == 1 else res[3]
    return ColorValue(res)


class Value(Node):
    """ Abstract value.
    """
    @classmethod
    def _do_op(cls, self, other, op):
        first, second = cls(self), cls(other)
        return op(first.value, second.value)

    @classmethod
    def _do_cmps(cls, first, second, op):
        return op(first.value, second.value)

    # Math operation
    def __add__(self, other):
        return self._do_op(self, other, OPRT['+'])

    __radd__ = __add__

    def __div__(self, other):
        return self._do_op(self, other, OPRT['/'])

    def __rdiv__(self, other):
        return self._do_op(other, self, OPRT['/'])

    def __sub__(self, other):
        return self._do_op(self, other, OPRT['-'])

    def __rsub__(self, other):
        return self._do_op(other, self, OPRT['-'])

    def __mul__(self, other):
        return self._do_op(self, other, OPRT['*'])

    def __lt__(self, other):
        return self._do_cmps(self, other, OPRT['<'])

    __rmul__ = __mul__

    # Compare operation
    def __le__(self, other):
        return self._do_cmps(self, other, OPRT['<='])

    def __gt__(self, other):
        return self._do_cmps(self, other, OPRT['>='])

    def __ge__(self, other):
        return self._do_cmps(self, other, OPRT['>'])

    def __eq__(self, other):
        return self._do_cmps(self, other, OPRT['=='])

    def __ne__(self, other):
        return self._do_cmps(self, other, OPRT['!='])

    # Boolean
    def __nonzero__(self):
        return getattr(self, 'value') and True or False

    def __bool__(self):
        return bool(self.value) if self.value != 'false' else False

    def __str__(self):
        return str(self.value)

    def __float__(self):
        return float(self.value)


class StringValueMeta(type):

    def __call__(mcs, *args, **kwargs):
        test = mcs.__new__(mcs)
        test.__init__(*args, **kwargs)

        if test.value in ('true', 'false'):
            return BooleanValue(test.value)

        elif COLORS.has_key(test.value):
            return ColorValue(COLORS.get(test.value))

        return test


class StringValue(Value):

    __metaclass__ = StringValueMeta

    def_value = ''

    def __init__(self, t):
        super(StringValue, self).__init__(None, None, t)

        self.value = self.def_value

        if isinstance(t, ParseResults):
            self.value = ''.join(str(s) for s in t)

        elif isinstance(t, StringValue):
            self.value = t.value

        elif isinstance(t, Node):
            self.value = str(t.value).strip('"\'')

        elif isinstance(t, (str, int, float)):
            self.value = str(t)

    def __div__(self, other):
        self.value = '/'.join((str(self), str(other)))
        return self

    def __str__(self):
        return self.value


class PointValue(Value):

    @property
    def value(self):
        return ' '.join(map(str, self.data))

    def __str__(self):
        return self.value


class QuotedStringValue(StringValue):

    def __init__(self, t):
        super(QuotedStringValue, self).__init__(t)
        self.value = self.value.strip('"\'')

    def __str__(self):
        return "'%s'" % self.value


class ColorValue(Value):

    def_value = (255.0, 255.0, 255.0, 1)

    def __init__(self, t):
        super(ColorValue, self).__init__(None, None, t)
        self.value = self.def_value

        if isinstance(t, ParseResults):
            val = t[0][1:]
            self.value = hex2rgba[len(val)](val)

        elif isinstance(t, (list, tuple)):
            r = self.value
            c = map(lambda x, y: x if not x is None else y, t, r)
            c = tuple(0.0 if c[i] < 0 else r[i] if c[i] > r[i] else c[i] for i in range(4))
            self.value = c

        elif isinstance(t, str):
            val = t[1:]
            self.value = hex2rgba[len(val)](val)

        elif isinstance(t, ColorValue):
            self.value = t.value

    def __float__(self):
        return float( sum(self.value[:3], 0.0) / 3 * self.value[3] )

    def __str__(self):
        if self.value[3] == 1:
            v = '%02x%02x%02x' % self.value[:3]
            if v[0] == v[1] and v[2] == v[3] and v[4] == v[5]:
                v = v[0] + v[2] + v[4]
            return '#%s' % v
        return 'rgba(%d,%d,%d,%.2f)' % self.value

    __repr__ = __str__

    @classmethod
    def _do_op(cls, self, other, op):
        if isinstance(other, ColorValue):
            return rgba_op(op, self, *other.value)

        elif isinstance(other, ( NumberValue, int )):
            if op in (OPRT['*'], OPRT['/']):
                return ColorValue(map(lambda x: op(x, float(other)), self.value[:3]))
            return hsl_op(op, self, 0, other, 0)

        else:
            return self


class BooleanValue(Value):

    def_value = True

    def __init__(self, t):
        super(BooleanValue, self).__init__(None, None, t)
        self.value = self.def_value

        if isinstance(t, (str, bool)):
            self.value = bool(t) if t != 'false' else False

        elif isinstance(t, Node):
            self.value = bool(t)

    def __str__(self):
        return 'true' if self.value else 'false'

    __repr__ = __str__

    def __float__(self):
        return 1.0 if self.value else 0.0


class NumberValue(Value):

    def_value = 0.0

    def __init__(self, t):
        super(NumberValue, self).__init__(None, None, t)
        self.value = self.def_value
        self.units = ''

        if isinstance(t, (ParseResults, list, tuple)):
            if len(t) > 1:
                self.units = t[1]
            self.value = float(t[0])

        elif isinstance(t, NumberValue):
            self.value, self.units = t.value, t.units

        elif isinstance(t, Node):
            self.value = float(t.value)
            self.units = getattr(t.value, 'units', '')

        elif isinstance(t, (int, float, str)):
            self.value = float(t)

    def __float__(self):
        return self.value * CONV_FACTOR.get(self.units, 1.0)

    def __str__(self):
        value = ("%0.03f" % self.value).strip('0').rstrip('.') or 0
        return "%s%s" % (value, self.units if self.value else '')

    @classmethod
    def _do_op(cls, self, other, op):
        first, second = cls(self), cls(other)
        units = second.units or first.units
        value = op(float(first), float(second))
        value /= CONV_FACTOR.get(units, 1.0)
        return cls((value, units))

########NEW FILE########
