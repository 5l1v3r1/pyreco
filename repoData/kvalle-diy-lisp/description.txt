## Part 1: parsing

The language we are making is an interpreted one. This means that we basically need to implement two things: a **parser** and an **evaluator**. In this first part, we implement the parser.

The job of the parser is to convert the program into something the evaluator understands. The evaluator evaluates whatever the parser produces, and returns the result. Here is a nice diagram to explain everything:

```

            +-----------+        +-------------+
    text    |           |  AST   |             |  result
  +-------->|  parser   |+------>|  evaluator  |+-------->
            |           |        |             |
            +-----------+        +-------------+
```

The format produced by the parser is called the *abstract syntax tree* (AST) of the program.

### Our AST

So what does our AST look like? Lets have a sneak peek.

```python
>>> from diylisp.parser import parse
>>> program = """
...   (define fact 
...       ;; Factorial function
...       (lambda (n) 
...           (if (eq n 0) 
...               1 ; Factorial of 0 is 1, and we deny 
...                 ; the existence of negative numbers
...               (* n (fact (- n 1))))))
... """))
>>> parse(program)
['define', 'fact', ['lambda', ['n'], ['if', ['eq', 'n', 0], 1, ['*', 'n', ['fact', ['-', 'n', 1]]]]]]
```

The AST, then, is created as follows:

- Comments are removed.
- Symbols are represented as strings.
    + `"foo"` parses to `"foo"`
- The symbols `#t` and `#f` are represented by Python's `True` and `False`, respectively.
    + `"#t"` parses to `True`
- Integers are represented as Python integers.
    + `"42"` parses to `42`
- The Lisp list expressions are represented as Python lists.
    `"(foo #f 100)"` parses to `["foo", False, 100]`
- Nested expressions are parsed accordingly.
    + `"((+ (- 1 2) (* (- 4 1) 42)))"` parses to `[['+', ['-', 1, 2], ['*', ['-', 4, 1], 42]]]`

### Your turn

The parsing is done in `parser.py`. It is your job to implement the `parse` function here. A lot of the gritty work of counting parentheses and such has been done for you, but you must stitch everything together.

- Have a look at the provided functions in `diylisp/parser.py` before you start. These should prove useful. 
- The following command runs the tests, stopping at the first one failed.

    ```bash
    nosetests tests/test_1_parsing.py --stop
    ```
- Run the tests and hack away until the tests are passing. Each test has a description, and you should probably read it if you get stuck.

### What's next?

Go to [part 2](2.md) where we evaluate some simple expressions.

## Part 2: evaluating simple expressions

Now that we have the parser up and running, it's time to start working on the evaluator. We'll start with some simple expressions, such as evaluating numbers or booleans, and a few of the most basic *special forms* in the language.

- `quote` takes one argument which is returned directly (without being evaluated).
- `atom` also takes a single argument, and returns true or false depending on whether the argument is an atom.
- `eq` returns true if both its arguments are the same atom, and false otherwise.
- The arithmetic operators (`+`, `-`, `*`, `/`, `mod` and `>`) all take two arguments, and do exactly what you would expect.

This time, your work is in the file `evaluator.py`.

### Make it happen!

The following command runs the tests, stopping at the first one failed. You know the drill.

```bash
nosetests tests/test_2_evaluating_simple_expressions.py --stop
```

### Play while you work

Now that we are beginning to get an interpreter going, we can start testing the results in the read-eval-print-loop (REPL).

Start the REPL from the command line, and try the language as we move along.

```bash
./repl
```

Remember, you'll need to restart the REPL for it to pick up any changes you make to the language.

### What's next?

Head on to [part 3](3.md) where the expressions we take become slightly more complex.

## Part 3: evaluating complex expressions

You have now already made a simple language, able to evaluate nested arithmetic expressions. It is time to add the ability to use control structures. 

For our language, an `if` statement will suffice. The `if` takes three arguments. The first one is the predicate `p`, which is always evaluated. The second **or** third argument is then evaluated and returned depending on the value of `p`.

### Make it happen!

Go on, you know what to do.

```bash
nosetests tests/test_3_evaluating_complex_expressions.py --stop
```

### Play while you work

Remember that the REPL is a great way to play around with your language while you work on it.

```bash
./repl
→  (if (> 42 100)
…      'foo
…      'bar)
bar
```

### What's next?

Go to [part 4](4.md) where we add environments that'll enable us to work with variables.

## Part 4: working with variables

So far, our interpreted language is only able do deal with expressions one by one. In a real programming language, we need to be able to store intermediate results in variables, and then later to look them up from the environment.

We will start by implementing the `Environment` class (which can be found in `diylisp/types.py`). Then we'll extend `evaluate` to handle expressions using defined variables, and the creation of new variables with the `define` form.

Run the tests, and get going!

```bash
nosetests tests/test_4_working_with_variables_and_environments.py --stop
```

### What's next?

In [part 5](5.md) the environments we just implemented enable us to make lexically scoped functions.

## Part 5: functions

This part is the one you might have been waiting for. It's time to add functions to our little language.

Functions are created with the `lambda` form, which returns an instance of `Closure` (find the class definition in `diylisp/types.py`). The first few tests guide you to implement the `lambda` form correctly. 

The next tests concern calling functions. A function call happens when we evaluate a list in which the first element is a function closure.

Finally, we handle some situations where function calls are done incorrectly, and make sure we give appropriate errors.

### Make it happen!

This is probably the most difficult part of making the language, so don't worry if it takes a bit longer than the previous parts.

```bash
nosetests tests/test_5_adding_functions_to_the_mix.py --stop
```

### What's next?

Ready for the last part of the language? In [part 6](6.md) we add a ways to work with lists.

## Part 6: working with lists

This is the last section before we're done implementing the language, and compared to the last part it should be relatively easy.

In Lisp one of the fundamental data structures is *the list* (the name Lisp is derived from *list processing* after all). In order to be able to work properly with lists, we'll introduce four new forms into the language:

- `cons` is used to construct lists from a "head" element, and the rest of the list (the "tail").
- `head` extracts the first element of a list
- `tail` returns the rest of the elments, once the first is dropped.
- `empty` takes a list as input, and returns `#t` if it is empty and `#f` otherwise.

Go on, then, finish your language.

```bash
nosetests tests/test_6_working_with_lists.py --stop
```

### What's next?

With the language implementation done, it's time to use our language in [part 7](7.md).

## Part 7: using your language

Congratulations! You have now made your own programming language. It's time to take it out for a spin.

Any programming language with respect for itself needs to have a standard library. This is a collection of useful functions provided with the language, distributed with the language.

In this section we will create various useful functions, all implemented purely in the Lisp. No Python this time!

For this part, you should consider the provided tests more like suggestions than something you *have* to follow. It is your language, after all, and you decide what should be in its library.

```bash
nosetests tests/test_7_using_the_language.py --stop
```

## The Language

The syntax of our little language is Lisp-inspired. This is mainly to make it easy to write the parser.

We will handle two types of expressions: **atoms** and **lists**. 

- Atoms can be numbers (`42`), booleans(`#t` and `#f`) or symbols (`foobar`).
- Lists consists of a series of zero or more expressions (other atoms or lists) separated by spaces and enclosed by parentheses.

### Evaluation rules

- Numbers and booleans evaluate to themselves.
- Symbols are treated as variable references. When evaluated, their values are looked up in the environment.
- Lists are treated as function calls (or calls to the special forms built into the language).
- Anything in between semicolons (`;`) and the end of a line is considered a comment and ignored.

### Special Forms

The language will have a set of "special forms". These are the construct built into the language. If a list expression is evaluated, and the first element is one of a number of defined symbols, the special form is executed: 

Here is a brief explanation of each form:

- `quote` takes one argument which is returned without it being evaluated.
- `atom` is a predicate indicating whether or not it's one argument is an atom.
- `eq` returns true (`#t`) if both its arguments are the same atom.
- `+`, `-`, `*`, `/`, `mod` and `>` all take two arguments, and does exactly what you would expect. (Note that since we have no floating point numbers, the `/` represent integer division.)
- `if` is the conditional, taking three arguments. It's return value is the result of evaluating the second or third argument, depending on the value of the first one.
- `define` is used to define new variables in the environment.
- `lambda` creates function closures.
- `cons` is used to construct lists from a head (element) and the tail (list).
- `head` returns the first element of a list.
- `tail` returns all but the first element of a list.

### Function calls

If a list is evaluated, and the first element is something other than one of the special forms, it is expected to be a function closure. Function closures are created using the `lambda` form. 

Here is a (rather silly) example showing how to define and use a function.

```lisp
(define my-function
    ;; This function returns 42, unless the argument 
    ;; actually is 42. In that case, we return 1000.
    (lambda (n) 
        (if (eq n 42) 
            1000
            42)))

(my-function 42) ;; => 1000
```

This might for some be the most "magic" part, and one that you hopefully will understand a lot better after implementing the language.

## Python Cheat Sheet

This is not an introduction to Python. 
For that, see the [Python tutorial](https://docs.python.org/2/tutorial/) or the [Python module index](https://docs.python.org/3/py-modindex.html).
Instead, this lists some tips and pointers that will prove useful when working on your language.

### Lists

Lists will comprise our ASTs, so you'll need lists pretty early on. The [tutorial page on lists](https://docs.python.org/2/tutorial/datastructures.html#more-on-lists) should prove useful.

### Dictionaries

We'll be using [dictionaries](https://docs.python.org/2/library/stdtypes.html#typesmapping) when representing the program environments.

- Remember that dicts are mutable in Python. Use the [`copy`](https://docs.python.org/2/library/stdtypes.html#dict.copy) function when a copy is needed.
- To update a dictionary with values from another, use [`update`](https://docs.python.org/2/library/stdtypes.html#set.update).
- You will find yourself needing to make a dictionary from a list of keys and a list of values. To do so, combine the [`dict`](https://docs.python.org/2/library/functions.html#func-dict) and [`zip`](https://docs.python.org/2/library/functions.html#zip) functions like this:
    
    ```python
    >>> dict(zip(["foo", "bar"], [1, 2]))
    {'foo': 1, 'bar': 2}
    ```

Read more about dicts in the [documentation](https://docs.python.org/2/tutorial/datastructures.html#dictionaries).

### Strings

- Strings works in many ways like lists. Thus, you can substring using indices:

    ```python
    >>> "hello world"[6:]
    'world'
    ```

- Remove unwanted whitespace using [`str.strip()`](https://docs.python.org/2/library/stdtypes.html#str.strip).

- It is also useful to know about how to do [string interpolation](https://docs.python.org/2/library/stdtypes.html#string-formatting-operations) in Python.

    ```python
    >>> "Hey, %s language!" % "cool"
    'Hey, cool language!'
    >>> "%d bottles of %s on the wall" % (99, "beer")
    '99 bottles of beer on the wall'
    >>> "%(num)s bottles of %(what)s on the %(where)s, %(num)d bottles of %(what)s" \
    ...      % {"num": 99, "what": "beer", "where": "wall"}
    '99 bottles of beer on the wall, 99 bottles of beer'
    ```

### Classes

When defining a class, all methods take a special argument `self` as the first argument. The `__init__` method works as constructor for the class.

```python
class Knight:
    
    def __init__(self, sound):
        self.sound = sound
    
    def speak(self):
        print self.sound
```

You don't provide the `self` when creating instances or calling methods:

```python
>>> knight = Knight("ni")
>>> knight.speak()
ni
```

### Default argument values

One thing it is easy to be bitten by is the way Python handles default function argument values. These are members of the function itself, and not "reset" every time the function is called.

```python
>>> def function(data=[]):
...     data.append(1)
...     return data
...
>>> function()
[1]
>>> function()
[1, 1]
>>> function()
[1, 1, 1]
```

Beware this when you implement the `Environment` class.

## DIY Lisp 

> batteries included, some assembly required

In this tutorial/workshop we'll be implementing our own little language, more or less from scratch. 

By the end of the tutorial you will be the proud author of a programming language, and will hopefully better understand how programming languages work  on a fundamental level.

### What we will be making

We will make a relatively simple, but neat language. We aim for the following features:

- A handful of datatypes (integers, booleans and symbols)
- Variables
- First class functions with lexical scoping
- That nice homemade quality feeling

We will *not* have:

- A proper type system
- Error handling
- Good performance
- And much, much more

The language should be able to interpret the following code by the time we are done:

```lisp
(define fact 
    ;; Factorial function
    (lambda (n) 
        (if (eq n 0) 
            1 ; Factorial of 0 is 1
            (* n (fact (- n 1))))))

;; When parsing the file, the last statement is returned
(fact 5)
```

The syntax is that of the languages in the Lisp family. If you find the example unfamiliar, you might want to have a look at [a more detailed description of the language](parts/language.md).

### Prerequisites

Before we get started, make sure you have installed [Python](http://www.python.org/) and [Pip](https://pypi.python.org/pypi/pip). 
*(It should now work with Python 3. If you have any problem with it, please [fill an issue](https://github.com/kvalle/diy-lisp/issues).)*

Then install `nose`, the Python test framework we'll be using.

```bash
pip install nose
```

*Optional: If you are familiar with [virtualenv](http://www.virtualenv.org/en/latest/) you might want to do this in a separate pyenv.*

Finally, clone this repo, and you're ready to go!

```bash
git clone https://github.com/kvalle/diy-lisp.git
```

> Also, if you're unfamiliar with Python, you might want to have a look at the basics in the [Python tutorial](https://docs.python.org/2/tutorial/index.html) before we get going. There is also the small [Python cheat sheet](parts/python.md) to help you along.

### Get started!

The workshop is split up into seven parts. Each consist of an introduction, and a bunch of unit tests which it is your task to make run. When all the tests run, you'll have implemented that part of the language.

Have fun!

- [Part 1: parsing](parts/1.md)
- [Part 2: evaluating simple expressions](parts/2.md)
- [Part 3: evaluating complex expressions](parts/3.md)
- [Part 4: working with variables](parts/4.md)
- [Part 5: functions](parts/5.md)
- [Part 6: working with lists](parts/6.md)
- [Part 7: using your language](parts/7.md)

