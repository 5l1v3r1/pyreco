__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# WTForms-Alchemy documentation build configuration file, created by
# sphinx-quickstart on Wed Aug 29 16:20:21 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
from wtforms_alchemy import __version__

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'WTForms-Alchemy'
copyright = u'2012, Konsta Vesterinen'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'WTForms-Alchemydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'WTForms-Alchemy.tex', u'WTForms-Alchemy Documentation',
   u'Konsta Vesterinen', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'wtforms-alchemy', u'WTForms-Alchemy Documentation',
     [u'Konsta Vesterinen'], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None,
                       'http://wtforms.readthedocs.org/en/latest/': None,
                       'https://sqlalchemy-utils.readthedocs.org/en/latest/': None,
                       'http://wtforms-components.readthedocs.org/en/latest/': None,
                      }

########NEW FILE########
__FILENAME__ = conftest
import pytest
from wtforms_alchemy import (model_form_factory, model_form_meta_factory,
                             ModelFormMeta)
from wtforms.form import FormMeta


class _MetaWithInit(FormMeta):
    def __init__(cls, *args, **kwargs):
        cls.test_attr = 'SomeVal'
        FormMeta.__init__(cls, *args, **kwargs)


MetaWithInit = model_form_meta_factory(_MetaWithInit)


class _MetaWithoutInit(FormMeta):
    test_attr = 'SomeVal'


MetaWithoutInit = model_form_meta_factory(_MetaWithoutInit)


@pytest.fixture(params=[MetaWithInit, MetaWithoutInit, ModelFormMeta])
def model_form_all(request):
    """Returns one of each possible model form classes with custom and the
    original metaclass."""
    ModelForm = model_form_factory(meta=request.param)
    return ModelForm


@pytest.fixture(params=[MetaWithInit, MetaWithoutInit])
def model_form_custom(request):
    """Returns one of each possible model form classes with custom
    metaclasses."""
    return model_form_factory(meta=request.param)

########NEW FILE########
__FILENAME__ = test_class_map
from pytest import mark, raises
from wtforms_alchemy.utils import ClassMap, sorted_classes


class A(object):
    pass


class B(object):
    pass


class A2(A):
    pass


class A3(A2):
    pass


class A4(A3):
    pass


class A5(A4):
    pass


class B2(B):
    pass


class C(object):
    pass


@mark.parametrize(
    'key',
    [B2, B, A, A2]
)
def test_contains_with_subclass_check(key):
    class_map = ClassMap({A: 3, B: 6})
    assert key in class_map


@mark.parametrize(
    'key',
    [B2(), B(), A(), A2()]
)
def test_contains_with_isinstance_check(key):
    class_map = ClassMap({A: 3, B: 6})
    assert key in class_map


@mark.parametrize(
    ('key', 'value'),
    [
        (B2, 6),
        (B, 6),
        (A, 3),
        (A2, 3)
    ]
)
def test_getitem_with_classes(key, value):
    class_map = ClassMap({A: 3, B: 6})
    assert class_map[key] == value


@mark.parametrize(
    ('key', 'value'),
    [
        (B2(), 6),
        (B(), 6),
        (A(), 3),
        (A2(), 3)
    ]
)
def test_getitem_with_objects(key, value):
    class_map = ClassMap({A: 3, B: 6})
    assert class_map[key] == value


@mark.parametrize(
    'items',
    [
        [A, A2, A3, A4, A5],
        [A2, A, A4, A3, A5],
        [A5, A, A4, A3, A2],
    ]
)
def test_sorted_classes_with_reverse(items):
    assert sorted_classes(items, reverse=True) == [A5, A4, A3, A2, A]


@mark.parametrize(
    'items',
    [
        [A, A2, A3, A4, A5],
        [A2, A, A4, A3, A5],
        [A5, A, A4, A3, A2],
    ]
)
def test_sorted_classes_without_reverse(items):
    assert sorted_classes(items) == [A, A2, A3, A4, A5]


def test_getitem_throws_keyerror_for_unknown_key():
    class_map = ClassMap({A: 3, B: 6})
    with raises(KeyError):
        class_map['unknown']


@mark.parametrize(
    'items',
    [
        {A: 1, A2: 2, A3: 3, A4: 4, A5: 5},
        {A2: 2, A: 1, A4: 4, A3: 3, A5: 5},
        {A5: 5, A: 1, A4: 4, A3: 3, A2: 2},
    ]
)
def test_init_sorts_dict_of_items_by_inheritance(items):
    class_map = ClassMap(items)
    assert list(class_map.items()) == [
        (A5, 5), (A4, 4), (A3, 3), (A2, 2), (A, 1)
    ]


@mark.parametrize(
    'items',
    [
        [(A, 1), (A2, 2), (A3, 3), (A4, 4), (A5, 5)],
        [(A2, 2), (A, 1), (A4, 4), (A3, 3), (A5, 5)],
        [(A5, 5), (A, 1), (A4, 4), (A3, 3), (A2, 2)],
    ]
)
def test_init_sorts_items_by_inheritance(items):
    class_map = ClassMap(items)
    assert list(class_map.items()) == [
        (A5, 5), (A4, 4), (A3, 3), (A2, 2), (A, 1)
    ]

########NEW FILE########
__FILENAME__ = test_column_aliases
import sqlalchemy as sa
from wtforms.validators import NumberRange
from wtforms_alchemy import ModelForm
from tests import ModelFormTestCase


class TestColumnAliases(ModelFormTestCase):
    def test_supports_column_aliases(self):
        class TestModel(self.base):
            __tablename__ = 'TestTable'
            id = sa.Column(sa.Integer, primary_key=True)
            some_alias = sa.Column('some_name', sa.Integer)

        class TestForm(ModelForm):
            class Meta:
                model = TestModel

        form = TestForm()
        assert hasattr(form, 'some_alias')
        assert not hasattr(form, 'some_name')

    def test_labels(self):
        class TestModel(self.base):
            __tablename__ = 'TestTable'
            id = sa.Column(sa.Integer, primary_key=True)
            some_alias = sa.Column(
                'some_name',
                sa.Integer,
            )

        class TestForm(ModelForm):
            class Meta:
                model = TestModel

        form = TestForm()
        assert form.some_alias.label.text == 'some_alias'

    def test_unique_indexes(self):
        class TestModel(self.base):
            __tablename__ = 'TestTable'
            id = sa.Column(sa.Integer, primary_key=True)
            some_alias = sa.Column('some_name', sa.Integer, unique=True)

        class TestForm(ModelForm):
            class Meta:
                model = TestModel

            @staticmethod
            def get_session():
                return None

        form = TestForm()
        assert hasattr(form, 'some_alias')
        assert not hasattr(form, 'some_name')

    def test_meta_field_args(self):
        class TestModel(self.base):
            __tablename__ = 'TestTable'
            id = sa.Column(sa.Integer, primary_key=True)
            some_alias = sa.Column('some_name', sa.Integer)

        validators = [NumberRange(max=4)]

        class TestForm(ModelForm):
            class Meta:
                model = TestModel
                field_args = {'some_alias': {'validators': validators}}

        form = TestForm()
        assert hasattr(form, 'some_alias')
        assert not hasattr(form, 'some_name')
        assert form.some_alias.validators == validators

    def test_additional_validators(self):
        class TestModel(self.base):
            __tablename__ = 'TestTable'
            id = sa.Column(sa.Integer, primary_key=True)
            some_alias = sa.Column('some_name', sa.Integer)

        number_range = NumberRange(max=4)
        validator_list = [number_range]

        class TestForm(ModelForm):
            class Meta:
                model = TestModel
                validators = {'some_alias': validator_list}

        form = TestForm()
        assert number_range in form.some_alias.validators

########NEW FILE########
__FILENAME__ = test_configuration
from pytest import raises
import sqlalchemy as sa
from wtforms.fields import IntegerField
from wtforms.validators import Email
from wtforms_alchemy import (
    AttributeTypeException, InvalidAttributeException, ModelForm
)
from tests import ModelFormTestCase, MultiDict


class UnknownType(sa.types.UserDefinedType):
    def get_col_spec(self):
        return "UNKNOWN()"


class TestModelFormConfiguration(ModelFormTestCase):
    def test_skip_unknown_types(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            query = None
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(UnknownType)
            some_property = 'something'

        self.ModelTest = ModelTest

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                skip_unknown_types = True

        self.form_class = ModelTestForm
        assert not self.has_field('test_column')

    def test_supports_field_exclusion(self):
        self.init_model()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                exclude = ['test_column']

        self.form_class = ModelTestForm
        assert not self.has_field('test_column')

    def test_throws_exception_for_unknown_excluded_column(self):
        self.init_model()

        with raises(InvalidAttributeException):
            class ModelTestForm(ModelForm):
                class Meta:
                    model = self.ModelTest
                    exclude = ['some_unknown_column']

    def test_invalid_exclude_with_attr_errors_as_false(self):
        self.init_model()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                attr_errors = False
                exclude = ['some_unknown_column']

    def test_throws_exception_for_unknown_included_column(self):
        self.init_model()

        with raises(InvalidAttributeException):
            class ModelTestForm(ModelForm):
                class Meta:
                    model = self.ModelTest
                    include = ['some_unknown_column']

    def test_invalid_include_with_attr_errors_as_false(self):
        self.init_model()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                attr_errors = False
                include = ['some_unknown_column']

    def test_throws_exception_for_non_column_fields(self):
        self.init_model()

        with raises(AttributeTypeException):
            class ModelTestForm(ModelForm):
                class Meta:
                    model = self.ModelTest
                    include = ['some_property']

    def test_supports_field_inclusion(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                include = ['id']

        self.form_class = ModelTestForm
        assert self.has_field('id')

    def test_supports_only_attribute(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            query = None
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.UnicodeText)
            test_column2 = sa.Column(sa.UnicodeText)

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                only = ['test_column']

        form = ModelTestForm()
        assert len(form._fields) == 1

    def test_supports_field_overriding(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest

            test_column = IntegerField()

        self.form_class = ModelTestForm
        self.assert_type('test_column', IntegerField)

    def test_supports_assigning_all_fields_as_optional(self):
        self.init(nullable=False)

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                all_fields_optional = True

        self.form_class = ModelTestForm
        self.assert_not_required('test_column')
        self.assert_optional('test_column')

    def test_supports_custom_datetime_format(self):
        self.init(sa.DateTime, nullable=False)

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                datetime_format = '%Y-%m-%dT%H:%M:%S'

        form = ModelTestForm()
        assert form.test_column.format == '%Y-%m-%dT%H:%M:%S'

    def test_supports_additional_validators(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                validators = {'test_column': Email()}

        self.form_class = ModelTestForm
        self.assert_has_validator('test_column', Email)

    def test_inherits_config_params_from_parent_meta(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                only = ['test_column']

        class AnotherModelTestForm(ModelTestForm):
            class Meta:
                pass

        assert AnotherModelTestForm.Meta.only == ['test_column']

    def test_child_classes_override_parents_config_params(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                only = ['test_column']

        class AnotherModelTestForm(ModelTestForm):
            class Meta:
                only = []

        assert AnotherModelTestForm.Meta.only == []

    def test_strip_strings_fields(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                only = ['test_column']
                strip_string_fields = True

        form = ModelTestForm(MultiDict(test_column=u' something '))
        assert form.test_column.data == u'something'

    def test_strip_strings_fields_with_empty_values(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                only = ['test_column']
                strip_string_fields = True

        ModelTestForm()

    def test_class_meta_regression(self):
        self.init()

        class SomeForm(ModelForm):
            class Meta:
                model = self.ModelTest
                foo = 9

        class OtherForm(SomeForm):
            class Meta:
                pass

        assert issubclass(OtherForm.Meta, SomeForm.Meta)
        form = OtherForm()

        # Create a side effect on the base meta.
        assert form.Meta.foo == 9
        SomeForm.Meta.foo = 12
        assert form.Meta.foo == 12

########NEW FILE########
__FILENAME__ = test_country_field
from babel import Locale
from wtforms import Form
from wtforms_alchemy import CountryField
import sqlalchemy_utils
from tests import MultiDict


sqlalchemy_utils.i18n.get_locale = lambda: Locale('en')


class TestCountryField(object):
    field_class = CountryField

    def init_form(self, **kwargs):
        class TestForm(Form):
            test_field = self.field_class(**kwargs)

        self.form_class = TestForm
        return self.form_class

    def setup_method(self, method):
        self.valid_countries = [
            'US',
            'SA',
            'FI'
        ]
        self.invalid_countries = [
            'unknown',
        ]

    def test_valid_countries(self):
        form_class = self.init_form()
        for country in self.valid_countries:
            form = form_class(MultiDict(test_field=country))
            form.validate()
            assert len(form.errors) == 0

    def test_invalid_countries(self):
        form_class = self.init_form()
        for country in self.invalid_countries:
            form = form_class(MultiDict(test_field=country))
            form.validate()
            assert len(form.errors['test_field']) == 1

########NEW FILE########
__FILENAME__ = test_custom_fields
from wtforms import Form
from wtforms_alchemy import SelectField, null_or_unicode
from tests import MultiDict


class TestSelectField(object):
    def test_understands_none_values(self):
        class MyForm(Form):
            choice_field = SelectField(
                choices=[('', '-- Choose --'), ('choice 1', 'Something')],
                coerce=null_or_unicode
            )

        form = MyForm(MultiDict({'choice_field': u''}))
        form.validate()
        assert form.errors == {}

########NEW FILE########
__FILENAME__ = test_deep_form_relations
import sqlalchemy as sa
from wtforms_alchemy import ModelForm, ModelFormField, ModelFieldList
from wtforms.fields import FormField, FieldList
from tests import FormRelationsTestCase, MultiDict


class TestDeepFormRelationsOneToManyToOne(FormRelationsTestCase):
    def create_models(self):
        class Event(self.base):
            __tablename__ = 'event'
            id = sa.Column(sa.Integer, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=False)

        class Address(self.base):
            __tablename__ = 'address'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            street = sa.Column(sa.Unicode(255), nullable=True)

        class Location(self.base):
            __tablename__ = 'location'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)

            address_id = sa.Column(sa.Integer, sa.ForeignKey(Address.id))
            address = sa.orm.relationship(Address)

            event_id = sa.Column(sa.Integer, sa.ForeignKey(Event.id))
            event = sa.orm.relationship(Event, backref='locations')

        self.Event = Event
        self.Location = Location
        self.Address = Address

    def create_forms(self):
        class AddressForm(ModelForm):
            class Meta:
                model = self.Address

        class LocationForm(ModelForm):
            class Meta:
                model = self.Location

            address = ModelFormField(AddressForm)

        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            locations = ModelFieldList(FormField(LocationForm))

        self.LocationForm = LocationForm
        self.EventForm = EventForm
        self.AddressForm = AddressForm

    def save(self):
        data = {
            'name': u'Some event',
            'locations-0-name': u'Some location',
            'locations-0-address-street': u'Some address'
        }
        event = self.Event()
        self.session.add(event)
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()

    def test_assigment_and_deletion(self):
        self.save()
        event = self.session.query(self.Event).first()
        assert event.locations[0].name == u'Some location'
        assert event.locations[0].address.street == u'Some address'
        data = {
            'name': u'Some event'
        }
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()
        event = self.session.query(self.Event).first()
        assert event.locations == []


class TestDeepFormRelationsOneToOneToMany(FormRelationsTestCase):
    def create_models(self):
        class Location(self.base):
            __tablename__ = 'location'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)

        class Address(self.base):
            __tablename__ = 'address'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            street = sa.Column(sa.Unicode(255), nullable=True)

            location_id = sa.Column(sa.Integer, sa.ForeignKey(Location.id))
            location = sa.orm.relationship(Location, backref='addresses')

        class Event(self.base):
            __tablename__ = 'event'
            id = sa.Column(sa.Integer, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=False)
            location_id = sa.Column(sa.Integer, sa.ForeignKey(Location.id))
            location = sa.orm.relationship(Location)

        self.Event = Event
        self.Location = Location
        self.Address = Address

    def create_forms(self):
        class AddressForm(ModelForm):
            class Meta:
                model = self.Address

        class LocationForm(ModelForm):
            class Meta:
                model = self.Location

            addresses = ModelFieldList(FormField(AddressForm))

        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            location = ModelFormField(LocationForm)

        self.LocationForm = LocationForm
        self.EventForm = EventForm
        self.AddressForm = AddressForm

    def save(self):
        data = {
            'name': u'Some event',
            'location-name': u'Some location',
            'location-addresses-0-street': u'Some address'
        }
        event = self.Event()
        self.session.add(event)
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()

    def test_assigment_and_deletion(self):
        self.save()
        event = self.session.query(self.Event).first()
        assert event.location.name == u'Some location'
        assert event.location.addresses[0].street == u'Some address'
        data = {
            'name': u'Some event'
        }
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()
        event = self.session.query(self.Event).first()
        assert event.location.addresses == []

########NEW FILE########
__FILENAME__ = test_descriptions
from wtforms_alchemy import ModelForm
from tests import ModelFormTestCase


class TestFieldParameters(ModelFormTestCase):
    def test_assigns_description_from_column_info(self):
        self.init(info={'description': 'Description'})
        self.assert_description('test_column', 'Description')

    def test_assigns_descriptions_from_form_configuration(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest

                field_args = {
                    'test_column': {'description': 'TESTING'}
                }

        self.form_class = ModelTestForm
        self.assert_description('test_column', 'TESTING')

########NEW FILE########
__FILENAME__ = test_field_exclusion
from datetime import datetime
import sqlalchemy as sa
from sqlalchemy_utils import TSVectorType
from tests import ModelFormTestCase


class TestFieldExclusion(ModelFormTestCase):
    def test_does_not_include_datetime_columns_with_default(self):
        self.init(sa.DateTime, default=datetime.now())
        assert not self.has_field('test_column')

    def test_excludes_surrogate_primary_keys_by_default(self):
        self.init()
        assert not self.has_field('id')

    def test_excludes_column_properties(self):
        self.init()
        self.ModelTest.calculated_value = sa.orm.column_property(
            sa.func.lower(self.ModelTest.test_column)
        )
        self.init_form()
        self.form_class()


class TestTSVectorType(ModelFormTestCase):
    dns = 'postgres://postgres@localhost/wtforms_alchemy_test'

    def test_does_not_include_tsvector_typed_columns_with_default(self):
        self.init(TSVectorType)
        assert not self.has_field('test_column')

########NEW FILE########
__FILENAME__ = test_field_order
import sqlalchemy as sa
from tests import ModelFormTestCase


class TestFieldOrder(ModelFormTestCase):
    def setup_method(self, method):
        ModelFormTestCase.setup_method(self, method)

        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)
            full_description = sa.Column(sa.UnicodeText)
            description = sa.Column(sa.UnicodeText)
            start_time = sa.Column(sa.DateTime)
            end_time = sa.Column(sa.DateTime)
            category = sa.Column(sa.Unicode(255))
            entry_fee = sa.Column(sa.Numeric)
            type = sa.Column(sa.Unicode(255))

        self.ModelTest = ModelTest
        self.init_form()

    def test_field_definition_order(self):
        field_names = [field.name for field in self.form_class()]
        assert field_names == sa.inspect(self.ModelTest).attrs.keys()[1:]

########NEW FILE########
__FILENAME__ = test_field_parameters
from datetime import date, time
import sqlalchemy as sa
from sqlalchemy_utils import IntRangeType, NumericRangeType

from wtforms import widgets
from wtforms_alchemy import ModelForm
from wtforms_components import DateRange, TimeRange
from wtforms.fields import StringField
from wtforms.validators import NumberRange
from tests import ModelFormTestCase


class TestFieldParameters(ModelFormTestCase):
    def test_accepts_custom_widgets(self):
        self.init(info={'widget': widgets.HiddenInput()})
        form = self.form_class()
        assert isinstance(form.test_column.widget, widgets.HiddenInput)

    def test_accepts_custom_filters(self):
        test_filter = lambda a: a
        self.init(info={'filters': [test_filter]})
        form = self.form_class()
        assert test_filter in form.test_column.filters

    def test_assigns_description_from_column_info(self):
        self.init(info={'description': 'Description'})
        self.assert_description('test_column', 'Description')

    def test_does_not_add_default_value_if_default_is_callable(self):
        self.init(default=lambda: "test")
        self.assert_default('test_column', None)

    def test_assigns_scalar_defaults(self):
        self.init(default=u"test")
        self.assert_default('test_column', "test")

    def test_min_and_max_info_attributes_with_integer_field(self):
        self.init(type_=sa.Integer, info={'min': 1, 'max': 100})
        validator = self.get_validator('test_column', NumberRange)
        assert validator.min == 1
        assert validator.max == 100

    def test_min_and_max_info_attributes_with_numeric_field(self):
        self.init(type_=sa.Numeric, info={'min': 1, 'max': 100})
        validator = self.get_validator('test_column', NumberRange)
        assert validator.min == 1
        assert validator.max == 100

    def test_min_and_max_info_attributes_with_float_field(self):
        self.init(type_=sa.Float, info={'min': 1, 'max': 100})
        validator = self.get_validator('test_column', NumberRange)
        assert validator.min == 1
        assert validator.max == 100

    def test_min_and_max_info_attributes_with_int_range_field(self):
        self.init(type_=IntRangeType, info={'min': 1, 'max': 100})
        validator = self.get_validator('test_column', NumberRange)
        assert validator.min == 1
        assert validator.max == 100

    def test_min_and_max_info_attributes_generate_time_range_validator(self):
        self.init(
            type_=sa.types.Time,
            info={'min': time(12, 30), 'max': time(14, 30)}
        )
        validator = self.get_validator('test_column', TimeRange)
        assert validator.min == time(12, 30)
        assert validator.max == time(14, 30)

    def test_min_and_max_info_attributes_generate_date_range_validator(self):
        self.init(
            type_=sa.Date,
            info={'min': date(1990, 1, 1), 'max': date(2000, 1, 1)}
        )
        validator = self.get_validator('test_column', DateRange)
        assert validator.min == date(1990, 1, 1)
        assert validator.max == date(2000, 1, 1)

    def test_uses_custom_field_class(self):
        class InputTest(widgets.Input):
            input_type = 'color'

        class FieldTest(StringField):
            widget = InputTest()

        class ModelTest(self.base):
            __tablename__ = 'model_test'
            query = None
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(
                sa.UnicodeText,
                info={'form_field_class': FieldTest}
            )

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest

        form = ModelTestForm()
        assert 'type="color"' in str(form.test_column)

    def test_accepts_none_as_custom_field_class(self):
        class InputTest(widgets.Input):
            input_type = 'color'

        class FieldTest(StringField):
            widget = InputTest()

        class ModelTest(self.base):
            __tablename__ = 'model_test'
            query = None
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(
                sa.UnicodeText,
                info={'form_field_class': None}
            )

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest

        assert ModelTestForm()

########NEW FILE########
__FILENAME__ = test_field_trimming
from wtforms_alchemy import ModelForm
from tests import ModelFormTestCase, MultiDict


class TestStringFieldTrimming(ModelFormTestCase):
    def test_strip_string_fields_set_for_string_field(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                strip_string_fields = True

        f = ModelTestForm(MultiDict([('test_column', 'strip this   ')]))
        assert f.test_column.data == 'strip this'

    def test_does_not_trim_fields_when_trim_param_is_false(self):
        self.init(info={'trim': False})

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                strip_string_fields = True

        f = ModelTestForm(MultiDict([('test_column', 'strip this   ')]))
        assert f.test_column.data == 'strip this   '

########NEW FILE########
__FILENAME__ = test_form_meta
import sqlalchemy as sa
from tests import ModelFormTestCase


class TestModelFormMetaWithInheritance(ModelFormTestCase):

    def test_skip_unknown_types(self, model_form_all):
        self.init(type_=sa.Integer)

        class ModelTestForm(model_form_all):
            class Meta:
                skip_unknown_types = True

        class ModelTestForm2(ModelTestForm):
            class Meta:
                model = self.ModelTest

        self.form_class = ModelTestForm2
        assert self.form_class.Meta.skip_unknown_types is True

    def test_inheritance_attributes(self, model_form_custom):
        self.init(type_=sa.Integer)

        class ModelTestForm(model_form_custom):
            class Meta:
                model = self.ModelTest

        assert ModelTestForm.test_attr == 'SomeVal'


class TestUnboundFieldsInitialization(ModelFormTestCase):
    def test_skip_unknown_types(self, model_form_all):
        self.init(type_=sa.Integer)

        class ModelTestForm(model_form_all):
            class Meta:
                model = self.ModelTest
                skip_unknown_types = True

        assert ModelTestForm.test_column

########NEW FILE########
__FILENAME__ = test_hybrid_properties
from pytest import raises
import sqlalchemy as sa
from sqlalchemy.ext.hybrid import hybrid_property
from wtforms_alchemy import ModelForm
from wtforms_alchemy.exc import AttributeTypeException
from tests import ModelFormTestCase


class TestHybridProperties(ModelFormTestCase):
    def test_hybrid_property_returning_column_property(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            _test_column = sa.Column('test_column', sa.Boolean, nullable=False)

            @hybrid_property
            def test_column_hybrid(self):
                return self._test_column

            @test_column_hybrid.setter
            def test_column_hybrid(self, value):
                self._test_column = value

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_str_validator = None
                not_null_validator = None
                include = ('test_column_hybrid', )
                exclude = ('_test_column', )

        form = ModelTestForm()
        assert form.test_column_hybrid

    def test_hybrid_property_returning_expression(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            _test_column = sa.Column('test_column', sa.Boolean, nullable=False)

            @hybrid_property
            def test_column_hybrid(self):
                return self._test_column + self._test_column

            @test_column_hybrid.setter
            def test_column_hybrid(self, value):
                self._test_column = value

        with raises(AttributeTypeException):
            class ModelTestForm(ModelForm):
                class Meta:
                    model = ModelTest
                    not_null_str_validator = None
                    not_null_validator = None
                    include = ('test_column_hybrid', )
                    exclude = ('_test_column', )

########NEW FILE########
__FILENAME__ = test_i18n_extension
from pytest import raises
import sqlalchemy as sa
from sqlalchemy_i18n import Translatable, make_translatable, translation_base
from wtforms_alchemy import ModelForm
from tests import ModelFormTestCase, MultiDict


make_translatable()


class TestInternationalizationExtension(ModelFormTestCase):
    def init(self):
        class ModelTest(self.base, Translatable):
            __tablename__ = 'model_test'
            __translatable__ = {
                'locales': ['fi', 'en']
            }

            id = sa.Column(sa.Integer, primary_key=True)
            some_property = 'something'

            locale = 'en'

        class ModelTranslation(translation_base(ModelTest)):
            __tablename__ = 'model_translation'

            name = sa.Column(sa.Unicode(255))
            content = sa.Column(sa.Unicode(255))

        self.ModelTest = ModelTest
        sa.orm.configure_mappers()
        Session = sa.orm.sessionmaker(bind=self.engine)
        self.session = Session()

        self.init_form()

    def test_supports_translated_columns(self):
        self.init()
        form = self.form_class()
        assert form.name
        assert form.content

    def test_supports_field_exclusion(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest
                exclude = ['name']

        with raises(AttributeError):
            ModelTestForm().name

    def test_model_population(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest

        form = ModelTestForm(
            MultiDict([('name', u'something'), ('content', u'something')])
        )
        obj = self.ModelTest()
        form.populate_obj(obj)
        assert obj.name == u'something'
        assert obj.content == u'something'

########NEW FILE########
__FILENAME__ = test_inheritance
from wtforms_alchemy import model_form_factory, ModelForm
from wtforms import Form
from wtforms_test import FormTestCase


class TestInheritance(FormTestCase):
    class Base(Form):
        @classmethod
        def get_session(self):
            return 'TestSession'

    def test_default_base(self):
        assert ModelForm.get_session is None

    def test_custom_base_without_session(self):
        cls = model_form_factory(Form)
        assert cls.get_session is None

    def test_custom_base_with_session(self):
        cls = model_form_factory(self.Base)
        assert cls.get_session() == 'TestSession'

    def test_inherit_with_new_session(self):
        cls = model_form_factory(self.Base)

        class Sub(cls):
            @classmethod
            def get_session(self):
                return 'SubTestSession'
        assert Sub.get_session() == 'SubTestSession'

    def test_inherit_without_new_session(self):
        cls = model_form_factory(self.Base)

        class Sub(cls):
            pass
        assert Sub.get_session() == 'TestSession'

########NEW FILE########
__FILENAME__ = test_labels
from tests import ModelFormTestCase
from wtforms_alchemy import ModelForm


class TestFieldLabels(ModelFormTestCase):
    def test_assigns_labels_from_column_info(self):
        self.init(info={'label': 'Test Column'})
        self.assert_label('test_column', 'Test Column')

    def test_assigns_labels_from_form_configuration(self):
        self.init()

        class ModelTestForm(ModelForm):
            class Meta:
                model = self.ModelTest

                field_args = {
                    'test_column': {'label': 'TESTING'}
                }

        self.form_class = ModelTestForm
        self.assert_label('test_column', 'TESTING')

########NEW FILE########
__FILENAME__ = test_model_field_dict
# from pytest import raises

# import sqlalchemy as sa
# from sqlalchemy.orm.collections import attribute_mapped_collection
# from wtforms_alchemy import ModelForm, ModelFieldDict
# from wtforms_alchemy.fields import FieldDict
# from wtforms import Form
# from wtforms.fields import FormField, StringField
# from tests import FormRelationsTestCase, MultiDict


# class FieldDict(FieldList):
#     """Acts just like a FieldList, but works with a `dict` instead of
#     a `list`. Also, it wouldn't make sense to have `min_entries` and
#     `max_entries` params, so they are not provided.

#     The `keys` of the `dict` are used as labels for the generated
#     fields.

#     Warning: the character '-' must not be used in the `keys` of the
#     `dict` because it is already used to separate the parts of the
#     names/ids of the form fields. This should be configurable but
#     it would require a lot of changes in WTForms.
#     """
#     def __init__(self, unbound_field, label=None, validators=None,
#                  default=dict, **kwargs):
#         super(FieldDict, self).__init__(
#             unbound_field, label,
#             validators, min_entries=0, max_entries=None,
#             default=default, **kwargs
#         )

#     def process(self, formdata, data=_unset_value):

#         self.entries = []
#         if data is _unset_value or not data:
#             try:
#                 data = self.default()
#             except TypeError:
#                 data = self.default

#         self.object_data = data

#         if formdata:
#             indices = sorted(set(self._extract_indices(self.name, formdata)))

#             for index in indices:
#                 try:
#                     obj_data = data[index]
#                 except KeyError:
#                     obj_data = _unset_value
#                 self._add_entry(formdata, obj_data, index=index)
#         else:
#             for index, obj_data in data.items():
#                 self._add_entry(formdata, obj_data, index)

#     def _extract_indices(self, prefix, formdata):
#         offset = len(prefix) + 1
#         for k in formdata:
#             if k.startswith(prefix):
#                 k = k[offset:].split('-', 1)[0]
#                 yield k

#     def _add_entry(self, formdata=None, data=_unset_value, index=None):
#         name = '{}-{}'.format(self.short_name, index)
#         id = '{}-{}'.format(self.id, index)

#         field = self.unbound_field.bind(label=index, form=None, name=name,
#                                         prefix=self._prefix, id=id)
#         field.process(formdata, data)
#         self.entries.append(field)
#         return field

#     def append_entry(self, data=None):
#         if not data:
#             raise TypeError(
#                 'To add an entry to a FieldDict, you must at '
#                 'least provide a valid `dict`, containing at '
#                 'least one key.'
#             )
#         return self._add_entry(data=data)

#     def populate_obj(self, obj, name):
#         dic = getattr(obj, name, {})
#         _fake = type(str('_fake'), (object, ), {})
#         output = {}

#         for field in self.entries:
#             id = self._extract_entry_id(field)
#             fake_obj = _fake()
#             fake_obj.data = dic.get(id, None)
#             field.populate_obj(fake_obj, 'data')
#             output[id] = fake_obj.data

#         setattr(obj, name, output)

#     @property
#     def data(self):
#         return {self._extract_entry_id(e): e.data for e in self.entries}

#     def _extract_entry_id(self, entry):
#         offset = len(self.id) + 1
#         return entry.id[offset:]


# class TestModelFieldDict(FormRelationsTestCase):
#     def create_models(self):
#         class Item(self.base):
#             __tablename__ = 'item'
#             id = sa.Column(sa.Integer, primary_key=True)
#             name = sa.Column(sa.Unicode(255), nullable=False)

#         class Note(self.base):
#             __tablename__ = 'note'
#             id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)

#             keyword = sa.Column(sa.Unicode(255))
#             content = sa.Column(sa.UnicodeText, nullable=True)

#             item_id = sa.Column(sa.Integer, sa.ForeignKey(Item.id))
#             item = sa.orm.relationship(
#                 Item,
#                 backref=sa.orm.backref(
#                     'items',
#                     collection_class=attribute_mapped_collection('keyword'),
#                     cascade="all, delete-orphan"
#                 )
#             )

#         self.Item = Item
#         self.Note = Note

#     def create_forms(self):
#         class NoteForm(ModelForm):
#             class Meta:
#                 model = self.Note

#         class ItemForm(ModelForm):
#             class Meta:
#                 model = self.Item

#             notes = ModelFieldDict(FormField(NoteForm))

#         self.NoteForm = NoteForm
#         self.ItemForm = ItemForm

#     def test_saves_new_entries(self, data={}):
#         class AForm(Form):
#             attributes = FieldDict(StringField())
#             something = StringField()

#         class Resource(object):
#             attributes = {
#                 'anattribute': 'avalue',
#                 'anotherattribute': 'anothervalue'
#             }
#             something = '123'

#         form = AForm(
#             MultiDict(), obj=Resource()
#         )

#         assert 0


########NEW FILE########
__FILENAME__ = test_model_field_list
import sqlalchemy as sa
from wtforms_alchemy import ModelForm, ModelFieldList
from wtforms_components import PassiveHiddenField
from wtforms.fields import FormField
from tests import FormRelationsTestCase, MultiDict


class ModelFieldListTestCase(FormRelationsTestCase):
    def create_models(self):
        class Event(self.base):
            __tablename__ = 'event'
            id = sa.Column(sa.Integer, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=False)

        class Location(self.base):
            __tablename__ = 'location'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)

            event_id = sa.Column(sa.Integer, sa.ForeignKey(Event.id))
            event = sa.orm.relationship(Event, backref='locations')

        self.Event = Event
        self.Location = Location

    def save(self, event=None, data=None):
        if not data:
            data = {
                'name': u'Some event',
                'locations-0-name': u'Some location',
                'locations-0-description': u'Some description'
            }
        if not event:
            event = self.Event()
            self.session.add(event)
            form = self.EventForm(MultiDict(data))
        else:
            form = self.EventForm(MultiDict(data), obj=event)

        form.validate()
        form.populate_obj(event)
        self.session.commit()
        return event


class TestReplaceStrategy(ModelFieldListTestCase):
    def create_forms(self):
        class LocationForm(ModelForm):
            class Meta:
                model = self.Location

        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            locations = ModelFieldList(FormField(LocationForm))

        self.LocationForm = LocationForm
        self.EventForm = EventForm

    def test_assigment_and_deletion(self):
        self.save()
        event = self.session.query(self.Event).first()
        assert event.locations[0].name == u'Some location'
        data = {
            'name': u'Some event'
        }
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()
        event = self.session.query(self.Event).first()
        assert event.locations == []


class TestUpdateStrategy(ModelFieldListTestCase):
    def create_models(self):
        class Event(self.base):
            __tablename__ = 'event'
            id = sa.Column(sa.Integer, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=False)

        class Location(self.base):
            __tablename__ = 'location'
            TYPES = (u'', u'football field', u'restaurant')

            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)
            description = sa.Column(sa.Unicode(255), default=u'')
            type = sa.Column(
                sa.Unicode(255),
                info={'choices': zip(TYPES, TYPES)},
                default=u''
            )

            event_id = sa.Column(sa.Integer, sa.ForeignKey(Event.id))
            event = sa.orm.relationship(Event, backref='locations')

            def __repr__(self):
                return 'Location(id=%r, name=%r)' % (self.id, self.name)

        self.Event = Event
        self.Location = Location

    def create_forms(self):
        class LocationForm(ModelForm):
            class Meta:
                model = self.Location
                only = ['name', 'description', 'type']

            id = PassiveHiddenField()

        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            locations = ModelFieldList(
                FormField(LocationForm),
                population_strategy='update'
            )

        self.LocationForm = LocationForm
        self.EventForm = EventForm

    def test_with_none_as_formdata_for_existing_objects(self):
        event = self.save()
        form = self.EventForm(MultiDict(), obj=event)
        assert form.locations[0].data['id']

    def test_single_entry_update(self):
        event = self.save()
        location_id = event.locations[0].id
        data = {
            'name': u'Some event',
            'locations-0-id': location_id,
            'locations-0-name': u'Some other location'
        }
        self.save(event, data)

        assert len(event.locations) == 1
        assert event.locations[0].id == location_id
        assert event.locations[0].name == u'Some other location'

    def test_creates_new_objects_for_entries_with_unknown_identifiers(self):
        event = self.save()
        location_id = event.locations[0].id
        data = {
            'name': u'Some event',
            'locations-0-id': 12,
            'locations-0-name': u'Some other location'
        }
        self.save(event, data)
        assert event.locations
        assert event.locations[0].id != location_id

    def test_replace_entry(self):
        data = {
            'name': u'Some event',
            'locations-0-name': u'Some location',
            'locations-0-description': u'Some description',
            'locations-0-type': u'restaurant'
        }
        event = self.save(data=data)
        location_id = event.locations[0].id
        self.session.commit()
        data = {
            'name': u'Some event',
            'locations-0-name': u'Some other location',
        }
        self.save(event, data)
        location = event.locations[0]
        assert location.id != location_id
        assert location.name == u'Some other location'
        assert location.description == u''
        assert location.type == u''
        assert len(event.locations) == 1

    def test_replace_and_update(self):
        data = {
            'name': u'Some event',
            'locations-0-name': u'Location 1',
            'locations-0-description': u'Location 1 description',
            'locations-1-name': u'Location 2',
            'locations-1-description': u'Location 2 description',
        }
        event = self.save(data=data)
        self.session.commit()
        data = {
            'name': u'Some event',
            'locations-0-id': event.locations[1].id,
            'locations-0-name': u'Location 2 updated',
            'locations-0-description': u'Location 2 description updated',
            'locations-1-name': u'Location 3',
        }
        self.save(event, data)
        self.session.commit()
        location = event.locations[0]
        location2 = event.locations[1]
        assert location.name == u'Location 2 updated'
        assert location.description == u'Location 2 description updated'
        assert len(event.locations) == 2
        assert location2.name == u'Location 3'
        assert location2.description == u''

    def test_multiple_entries(self):
        event = self.save()
        location_id = event.locations[0].id
        data = {
            'name': u'Some event',
            'locations-0-name': u'Some location',
            'locations-1-id': str(location_id),  # test coercing works
            'locations-1-name': u'Some other location',
            'locations-2-name': u'Third location',
            'locations-3-id': 123,
            'locations-3-name': u'Fourth location'
        }
        self.save(event, data)
        assert len(event.locations) == 4
        assert event.locations[0].id == location_id
        assert event.locations[0].name == u'Some other location'
        assert event.locations[1].name == u'Some location'
        assert event.locations[2].name == u'Third location'
        assert event.locations[3].name == u'Fourth location'

    def test_delete_all_field_list_entries(self):
        event = self.save()
        data = {
            'name': u'Some event'
        }
        self.save(event, data)
        assert not event.locations

########NEW FILE########
__FILENAME__ = test_model_form_factory
from pytest import raises
from wtforms import Form
from wtforms_alchemy import (
    model_form_factory,
    FormGenerator,
    UnknownConfigurationOption
)
from tests import ModelFormTestCase

try:
    from wtforms.meta import DefaultMeta
    has_wtforms2 = True
except ImportError:
    has_wtforms2 = False


class TestModelFormFactory(ModelFormTestCase):
    def test_supports_parameter_overriding(self):
        self.init()

        class MyFormGenerator(FormGenerator):
            pass

        defaults = {
            'all_fields_optional': True,
            'only_indexed_fields': True,
            'include_primary_keys': True,
            'include_foreign_keys': True,
            'strip_string_fields': True,
            'include_datetimes_with_default': True,
            'form_generator': True,
            'date_format': '%d-%m-%Y',
            'datetime_format': '%Y-%m-%dT%H:%M:%S',
        }
        ModelForm = model_form_factory(Form, **defaults)
        for key, value in defaults.items():
            assert getattr(ModelForm.Meta, key) == value

    def test_throws_exception_for_unknown_configuration_option(self):
        self.init()

        class SomeForm(Form):
            pass

        defaults = {
            'unknown': 'something'
        }
        with raises(UnknownConfigurationOption):
            model_form_factory(SomeForm, **defaults)

    def test_supports_custom_base_class_with_model_form_factory(self):
        self.init()

        class SomeForm(Form):
            pass

        class TestCustomBase(model_form_factory(SomeForm)):
            class Meta:
                model = self.ModelTest

        assert isinstance(TestCustomBase(), SomeForm)

    def test_class_meta_wtforms2(self):
        if not has_wtforms2:
            return  # Not running on wtforms2

        self.init()

        class SomeForm(Form):
            class Meta:
                locales = ['fr']
                foo = 9

        class OtherForm(SomeForm):
            class Meta:
                pass

        class TestCustomBase(model_form_factory(SomeForm)):
            class Meta:
                model = self.ModelTest

        form = TestCustomBase()
        other_form = OtherForm()
        assert isinstance(form.meta, DefaultMeta)
        assert form.meta.locales == ['fr']
        assert hasattr(form.meta, 'model')
        assert hasattr(form.meta, 'csrf')

        assert form.meta.foo == 9
        # Create a side effect on the base meta.
        SomeForm.Meta.foo = 12
        assert other_form.meta.foo == 12
        assert form.meta.foo == 12

########NEW FILE########
__FILENAME__ = test_model_form_field
from pytest import raises
import sqlalchemy as sa
from wtforms_alchemy import ModelForm, ModelFormField
from tests import FormRelationsTestCase, MultiDict


class TestOneToOneModelFormRelations(FormRelationsTestCase):
    def create_models(self):
        class Location(self.base):
            __tablename__ = 'location'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=True)

        class Event(self.base):
            __tablename__ = 'event'
            id = sa.Column(sa.Integer, primary_key=True)
            name = sa.Column(sa.Unicode(255), nullable=False)
            location_id = sa.Column(sa.Integer, sa.ForeignKey(Location.id))
            location = sa.orm.relationship(Location)

        self.Event = Event
        self.Location = Location

    def create_forms(self):
        class LocationForm(ModelForm):
            class Meta:
                model = self.Location

        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            location = ModelFormField(LocationForm)

        self.LocationForm = LocationForm
        self.EventForm = EventForm

    def save(self, event=None, data={}):
        if not data:
            data = {
                'name': u'Some event',
                'location-name': u'Some location',
            }
        if not event:
            event = self.Event()
        self.session.add(event)
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()
        return event

    def test_assigment_and_deletion(self):
        self.save()
        event = self.session.query(self.Event).first()
        assert event.location.name == u'Some location'
        data = {
            'name': u'Some event'
        }
        form = self.EventForm(MultiDict(data))
        form.validate()
        form.populate_obj(event)
        self.session.commit()
        event = self.session.query(self.Event).first()
        assert event.location.name is u''

    def test_only_populates_related_if_they_are_obj_attributes(self):
        class EventForm(ModelForm):
            class Meta:
                model = self.Event

            unknown_field = ModelFormField(self.LocationForm)

        self.EventForm = EventForm

        with raises(TypeError):
            self.save(data={
                'name': u'Some event',
                'unknown_field-name': u'Some location',
            })

    def test_updating_related_object(self):
        event = self.save()
        location_id = event.location.id
        self.save(event, {'location-name': u'Some other location'})

        assert event.location.id == location_id

########NEW FILE########
__FILENAME__ = test_phone_number
from pytest import mark
import sqlalchemy as sa

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

from sqlalchemy_utils.types import phone_number
from wtforms_alchemy import ModelForm

from tests import MultiDict


class TestCase(object):
    def setup_method(self, method):
        self.engine = create_engine('sqlite:///:memory:')
        self.Base = declarative_base()

        self.create_models()
        self.Base.metadata.create_all(self.engine)

        Session = sessionmaker(bind=self.engine)
        self.session = Session()

    def teardown_method(self, method):
        self.session.close_all()
        self.Base.metadata.drop_all(self.engine)
        self.engine.dispose()

    def create_models(self):
        class User(self.Base):
            __tablename__ = 'user'
            id = sa.Column(sa.Integer, autoincrement=True, primary_key=True)
            name = sa.Column(sa.Unicode(255))
            phone_number = sa.Column(
                phone_number.PhoneNumberType(country_code='FI')
            )

        self.User = User


@mark.xfail('phone_number.phonenumbers is None')
class TestPhoneNumbers(TestCase):
    '''
    Simple tests to ensure that sqlalchemy_utils.PhoneNumber,
    wtforms_alchemy.PhoneNumberType and sqlalchemy_utils.PhoneNumberField work
    nicely together.
    '''
    def setup_method(self, method):
        super(TestPhoneNumbers, self).setup_method(method)

        class UserForm(ModelForm):
            class Meta:
                model = self.User
        self.UserForm = UserForm

        super(TestPhoneNumbers, self).setup_method(method)
        self.phone_number = phone_number.PhoneNumber(
            '040 1234567',
            'FI'
        )
        self.user = self.User()
        self.user.name = u'Someone'
        self.user.phone_number = self.phone_number
        self.session.add(self.user)
        self.session.commit()

    def test_query_returns_phone_number_object(self):
        queried_user = self.session.query(self.User).first()
        assert queried_user.phone_number == self.phone_number

    def test_phone_number_is_stored_as_string(self):
        result = self.session.execute(
            'SELECT phone_number FROM user WHERE id=:param',
            {'param': self.user.id}
        )
        assert result.first()[0] == u'+358401234567'

    def test_phone_number_in_form(self):
        form = self.UserForm(MultiDict(
            name=u'Matti Meikalainen',
            phone_number='+358401231233'
        ))
        form.validate()
        assert len(form.errors) == 0
        assert form.data['phone_number'] == (
            phone_number.PhoneNumber('+358401231233')
        )

    def test_empty_phone_number_in_form(self):
        form = self.UserForm(MultiDict(
            name=u'Matti Meikalainen',
            phone_number=''
        ))
        form.validate()
        assert len(form.errors) == 0
        assert form.data['phone_number'] is None

########NEW FILE########
__FILENAME__ = test_select_field
import six
from decimal import Decimal
import sqlalchemy as sa
from wtforms_alchemy import SelectField
from tests import ModelFormTestCase


class MultiDict(dict):
    def getlist(self, key):
        return [self[key]]


class TestSelectFieldDefaultValue(ModelFormTestCase):
    def test_option_selected_by_field_default_value(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(
            type_=sa.Integer,
            default=u'1',
            info={'choices': choices}
        )
        form = self.form_class(MultiDict({'test_column': '2'}))
        assert (
            '<option selected value="2">2</option>' in
            str(form.test_column)
        )


class TestSelectFieldCoerce(ModelFormTestCase):
    def test_integer_coerces_values_to_integers(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.Integer, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2'}))
        assert form.test_column.data is 2

    def test_nullable_integer_coerces_values_to_integers(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.Integer, nullable=True, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2'}))
        assert form.test_column.data is 2

    def test_integer_coerces_empty_strings_to_nulls(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.Integer, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': ''}))
        assert form.test_column.data is None

    def test_big_integer_coerces_values_to_integers(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.BigInteger, info={'choices': choices})
        self.assert_type('test_column', SelectField)
        form = self.form_class(MultiDict({'test_column': '2'}))
        assert form.test_column.data is 2

    def test_small_integer_coerces_values_to_integers(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.SmallInteger, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2'}))
        assert form.test_column.data is 2

    def test_numeric_coerces_values_to_decimals(self):
        choices = [(u'1.0', '1.0'), (u'2.0', '2.0')]
        self.init(type_=sa.Numeric, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2.0'}))
        assert form.test_column.data == Decimal('2.0')

    def test_float_coerces_values_to_floats(self):
        choices = [(u'1.0', '1.0'), (u'2.0', '2.0')]
        self.init(type_=sa.Float, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2.0'}))
        assert form.test_column.data == 2.0

    def test_unicode_coerces_values_to_unicode_strings(self):
        choices = [('1.0', '1.0'), ('2.0', '2.0')]
        self.init(type_=sa.Unicode(255), info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2.0'}))
        assert form.test_column.data == u'2.0'
        assert isinstance(form.test_column.data, six.text_type)

    def test_unicode_text_coerces_values_to_unicode_strings(self):
        choices = [('1.0', '1.0'), ('2.0', '2.0')]
        self.init(type_=sa.UnicodeText, info={'choices': choices})
        form = self.form_class(MultiDict({'test_column': '2.0'}))
        assert form.test_column.data == u'2.0'
        assert isinstance(form.test_column.data, six.text_type)

########NEW FILE########
__FILENAME__ = test_synonym
import sqlalchemy as sa
from sqlalchemy.ext.hybrid import hybrid_property
from wtforms_alchemy import ModelForm
from tests import ModelFormTestCase


class TestSynonym(ModelFormTestCase):
    def test_synonym_returning_column_property_with_include(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            _test_column = sa.Column('test_column', sa.Integer, nullable=False)

            @hybrid_property
            def test_column(self):
                return self.test_column * 2

            @test_column.setter
            def test_column(self, value):
                self._test_column = value

            test_column = sa.orm.synonym(
                '_test_column', descriptor='test_column'
            )

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_str_validator = None
                not_null_validator = None
                include = ('test_column', )
                exclude = ('_test_column', )

        form = ModelTestForm()
        assert form.test_column

    def test_synonym_returning_column_property_with_only(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            _test_column = sa.Column('test_column', sa.Integer, nullable=False)

            @hybrid_property
            def test_column(self):
                return self.test_column * 2

            @test_column.setter
            def test_column(self, value):
                self._test_column = value

            test_column = sa.orm.synonym(
                '_test_column', descriptor='test_column'
            )

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_str_validator = None
                not_null_validator = None
                only = ('test_column', )

        form = ModelTestForm()
        assert form.test_column

########NEW FILE########
__FILENAME__ = test_types
from pytest import raises, mark
import sqlalchemy as sa
passlib = None
try:
    import passlib
except ImportError:
    pass
from wtforms.fields import (
    TextAreaField,
    BooleanField,
    FloatField,
    PasswordField,
)
from wtforms.validators import Length
from sqlalchemy_utils import (
    ChoiceType,
    ColorType,
    CountryType,
    DateRangeType,
    DateTimeRangeType,
    EmailType,
    IntRangeType,
    NumericRangeType,
    PasswordType,
    PhoneNumberType,
    UUIDType,
)
from sqlalchemy_utils.types import arrow, phone_number, WeekDaysType
from wtforms_components import Email
from wtforms_components.fields import (
    ColorField,
    DateField,
    DateTimeField,
    DecimalField,
    EmailField,
    IntegerField,
    IntIntervalField,
    DecimalIntervalField,
    DateIntervalField,
    DateTimeIntervalField,
    StringField,
    TimeField,
)
from wtforms_components.fields.weekdays import WeekDaysField
from wtforms_alchemy import (
    ModelForm,
    SelectField,
    UnknownTypeException,
    CountryField,
    null_or_unicode
)
from wtforms_alchemy.utils import ClassMap
from wtforms_components import PhoneNumberField
from tests import ModelFormTestCase


class UnknownType(sa.types.UserDefinedType):

    def get_col_spec(self):
        return "UNKNOWN()"


class CustomUnicodeTextType(sa.types.TypeDecorator):
    impl = sa.types.UnicodeText


class CustomUnicodeType(sa.types.TypeDecorator):
    impl = sa.types.Unicode


class CustomNumericType(sa.types.TypeDecorator):
    impl = sa.types.Numeric


class TestModelColumnToFormFieldTypeConversion(ModelFormTestCase):
    def test_raises_exception_for_unknown_type(self):
        with raises(UnknownTypeException):
            self.init(type_=UnknownType)
            self.form_class()

    def test_unicode_converts_to_text_field(self):
        self.init()
        self.assert_type('test_column', StringField)

    def test_custom_unicode_converts_to_text_field(self):
        self.init(type_=CustomUnicodeType)
        self.assert_type('test_column', StringField)

    def test_string_converts_to_text_field(self):
        self.init(type_=sa.String)
        self.assert_type('test_column', StringField)

    def test_integer_converts_to_integer_field(self):
        self.init(type_=sa.Integer)
        self.assert_type('test_column', IntegerField)

    def test_unicode_text_converts_to_text_area_field(self):
        self.init(type_=sa.UnicodeText)
        self.assert_type('test_column', TextAreaField)

    def test_custom_unicode_text_converts_to_text_area_field(self):
        self.init(type_=CustomUnicodeTextType)
        self.assert_type('test_column', TextAreaField)

    def test_boolean_converts_to_boolean_field(self):
        self.init(type_=sa.Boolean)
        self.assert_type('test_column', BooleanField)

    def test_datetime_converts_to_datetime_field(self):
        self.init(type_=sa.DateTime)
        self.assert_type('test_column', DateTimeField)

    def test_date_converts_to_date_field(self):
        self.init(type_=sa.Date)
        self.assert_type('test_column', DateField)

    def test_float_converts_to_float_field(self):
        self.init(type_=sa.Float)
        self.assert_type('test_column', FloatField)

    def test_numeric_converts_to_decimal_field(self):
        self.init(type_=sa.Numeric)
        self.assert_type('test_column', DecimalField)

    def test_numeric_scale_converts_to_decimal_field_scale(self):
        self.init(type_=sa.Numeric(scale=4))
        form = self.form_class()
        assert form.test_column.places == 4

    def test_custom_numeric_converts_to_decimal_field(self):
        self.init(type_=CustomNumericType)
        self.assert_type('test_column', DecimalField)

    def test_enum_field_converts_to_select_field(self):
        choices = ['1', '2']
        self.init(type_=sa.Enum(*choices))
        self.assert_type('test_column', SelectField)
        form = self.form_class()
        assert form.test_column.choices == [(s, s) for s in choices]

    def test_nullable_enum_uses_null_or_unicode_coerce_func_by_default(self):
        choices = ['1', '2']
        self.init(type_=sa.Enum(*choices), nullable=True)
        field = self._get_field('test_column')
        assert field.coerce == null_or_unicode

    def test_custom_choices_override_enum_choices(self):
        choices = ['1', '2']
        custom_choices = [('2', '2'), ('3', '3')]
        self.init(type_=sa.Enum(*choices), info={'choices': custom_choices})
        form = self.form_class()
        assert form.test_column.choices == custom_choices

    def test_column_with_choices_converts_to_select_field(self):
        choices = [(u'1', '1'), (u'2', '2')]
        self.init(type_=sa.Integer, info={'choices': choices})
        self.assert_type('test_column', SelectField)
        form = self.form_class()
        assert form.test_column.choices == choices

    def test_assigns_email_validator_for_email_type(self):
        self.init(type_=EmailType)
        self.assert_has_validator('test_column', Email)

    def test_time_converts_to_time_field(self):
        self.init(type_=sa.types.Time)
        self.assert_type('test_column', TimeField)

    def test_varchar_converts_to_text_field(self):
        self.init(type_=sa.types.VARCHAR)
        self.assert_type('test_column', StringField)

    def test_text_converts_to_textarea_field(self):
        self.init(type_=sa.types.TEXT)
        self.assert_type('test_column', TextAreaField)

    def test_char_converts_to_text_field(self):
        self.init(type_=sa.types.CHAR)
        self.assert_type('test_column', StringField)

    def test_real_converts_to_float_field(self):
        self.init(type_=sa.types.REAL)
        self.assert_type('test_column', FloatField)

    @mark.xfail('phone_number.phonenumbers is None')
    def test_phone_number_converts_to_phone_number_field(self):
        self.init(type_=PhoneNumberType)
        self.assert_type('test_column', PhoneNumberField)

    @mark.xfail('phone_number.phonenumbers is None')
    def test_phone_number_country_code_passed_to_field(self):
        self.init(type_=PhoneNumberType(country_code='SE'))
        form = self.form_class()
        assert form.test_column.country_code == 'SE'

    @mark.xfail('phone_number.phonenumbers is None')
    def test_phone_number_type_has_no_length_validation(self):
        self.init(type_=PhoneNumberType(country_code='FI'))
        field = self._get_field('test_column')
        for validator in field.validators:
            assert validator.__class__ != Length

    @mark.parametrize(('type', 'field'), (
        (IntRangeType, IntIntervalField),
    ))
    def test_range_type_conversion(self, type, field):
        self.init(type_=type)
        self.assert_type('test_column', field)

    @mark.xfail('passlib is None')
    def test_password_type_converts_to_password_field(self):
        self.init(type_=PasswordType)
        self.assert_type('test_column', PasswordField)

    @mark.xfail('arrow.arrow is None')
    def test_arrow_type_converts_to_datetime_field(self):
        self.init(type_=arrow.ArrowType)
        self.assert_type('test_column', DateTimeField)

    def test_uuid_type_converst_to_uuid_type(self):
        self.init(type_=UUIDType)
        self.assert_type('test_column', StringField)

    def test_color_type_converts_to_color_field(self):
        self.init(type_=ColorType)
        self.assert_type('test_column', ColorField)

    def test_email_type_converts_to_email_field(self):
        self.init(type_=EmailType)
        self.assert_type('test_column', EmailField)

    def test_country_type_converts_to_country_field(self):
        self.init(type_=CountryType)
        self.assert_type('test_column', CountryField)

    def test_choice_type_converts_to_select_field(self):
        choices = [(u'1', u'choice 1'), (u'2', u'choice 2')]
        self.init(type_=ChoiceType(choices))
        self.assert_type('test_column', SelectField)
        assert self.form_class().test_column.choices == choices

    def test_choice_type_uses_custom_coerce_func(self):
        choices = [(u'1', u'choice 1'), (u'2', u'choice 2')]
        self.init(type_=ChoiceType(choices))
        self.assert_type('test_column', SelectField)
        model = self.ModelTest(test_column=u'2')
        form = self.form_class(obj=model)
        assert '<option selected value="2">' in str(form.test_column)


class TestWeekDaysTypeConversion(ModelFormTestCase):
    dns = 'postgres://postgres@localhost/wtforms_alchemy_test'

    def test_weekdays_type_converts_to_weekdays_field(self):
        self.init(type_=WeekDaysType)
        self.assert_type('test_column', WeekDaysField)


class TestCustomTypeMap(ModelFormTestCase):
    def test_override_type_map_on_class_level(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Unicode(255), nullable=False)

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_validator = None
                type_map = ClassMap({sa.Unicode: TextAreaField})

        form = ModelTestForm()
        assert isinstance(form.test_column, TextAreaField)

########NEW FILE########
__FILENAME__ = test_validators
from datetime import datetime, time
from pytest import raises
import sqlalchemy as sa
from sqlalchemy_utils import EmailType
from wtforms.validators import (
    Email, InputRequired, DataRequired, Optional, NumberRange, Length
)
from wtforms_alchemy import Unique, ModelForm, ClassMap
from wtforms_components import TimeRange, DateRange
from tests import ModelFormTestCase


class TestAutoAssignedValidators(ModelFormTestCase):
    def test_auto_assigns_length_validators(self):
        self.init()
        self.assert_max_length('test_column', 255)

    def test_assigns_validators_from_info_field(self):
        self.init(info={'validators': Email()})
        self.assert_has_validator('test_column', Email)

    def test_assigns_unique_validator_for_unique_fields(self):
        self.init(unique=True)
        self.assert_has_validator('test_column', Unique)

    def test_raises_exception_if_no_session_set_for_unique_validators(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Unicode(255), unique=True)

        with raises(Exception):
            class ModelTestForm(ModelForm):
                class Meta:
                    model = ModelTest

    def test_assigns_non_nullable_fields_as_required(self):
        self.init(nullable=False)
        self.assert_has_validator('test_column', DataRequired)
        self.assert_has_validator('test_column', InputRequired)

    def test_type_level_not_nullable_validators(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Unicode(255), nullable=False)

        validator = DataRequired()

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_validator_type_map = ClassMap()
                not_null_validator = validator

        form = ModelTestForm()
        assert validator in form.test_column.validators

    def test_not_nullable_validator_with_type_decorator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(EmailType, nullable=False)

        validator = DataRequired()

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_validator_type_map = ClassMap(
                    [(sa.String, validator)]
                )
                not_null_validator = []

        form = ModelTestForm()
        assert validator in form.test_column.validators

    def test_not_null_validator_as_empty_list(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Boolean, nullable=False)

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_validator_type_map = ClassMap()
                not_null_validator = []

        form = ModelTestForm()
        assert form.test_column.validators == []

    def test_not_null_validator_as_none(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Boolean, nullable=False)

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                not_null_validator_type_map = ClassMap()
                not_null_validator = None

        form = ModelTestForm()
        assert len(form.test_column.validators) == 1
        assert isinstance(form.test_column.validators[0], Optional)

    def test_not_nullable_booleans_are_required(self):
        self.init(sa.Boolean, nullable=False)
        self.assert_has_validator('test_column', InputRequired)

    def test_not_nullable_fields_with_defaults_are_not_required(self):
        self.init(nullable=False, default=u'default')
        self.assert_not_required('test_column')

    def test_assigns_not_nullable_integers_as_optional(self):
        self.init(sa.Integer, nullable=True)
        self.assert_optional('test_column')

    def test_override_email_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(EmailType, nullable=True)

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                email_validator = lambda: Email('Wrong email')

        form = ModelTestForm()
        assert form.test_column.validators[1].message == 'Wrong email'

    def test_override_optional_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(EmailType, nullable=True)

        class MyOptionalValidator(object):
            def __init__(self, *args, **kwargs):
                pass

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                optional_validator = MyOptionalValidator

        form = ModelTestForm()
        assert isinstance(form.test_column.validators[0], MyOptionalValidator)

    def test_override_number_range_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Integer, info={'min': 3}, nullable=True)

        def number_range(min=-1, max=-1):
            return NumberRange(min=min, max=max, message='Wrong number range')

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                number_range_validator = number_range

        form = ModelTestForm()
        assert form.test_column.validators[1].message == 'Wrong number range'

    def test_override_date_range_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(
                sa.DateTime,
                info={'min': datetime(2000, 1, 1)},
                nullable=True
            )

        def date_range(min=None, max=None):
            return DateRange(min=min, max=max, message='Wrong date range')

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                date_range_validator = date_range

        form = ModelTestForm()
        assert form.test_column.validators[1].message == 'Wrong date range'

    def test_override_time_range_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(
                sa.Time,
                info={'min': time(14, 30)},
                nullable=True
            )

        def time_range(min=None, max=None):
            return TimeRange(min=min, max=max, message='Wrong time')

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                time_range_validator = time_range

        form = ModelTestForm()
        assert form.test_column.validators[1].message == 'Wrong time'

    def test_override_length_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(sa.Unicode(255), nullable=True)

        def length(min=-1, max=-1):
            return Length(min=min, max=max, message='Wrong length')

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                length_validator = length

        form = ModelTestForm()
        assert form.test_column.validators[1].message == 'Wrong length'

    def test_override_unique_validator(self):
        class ModelTest(self.base):
            __tablename__ = 'model_test'
            id = sa.Column(sa.Integer, primary_key=True)
            test_column = sa.Column(
                sa.Unicode(255), unique=True, nullable=True
            )

        def unique(column, get_session):
            return Unique(
                column, get_session=get_session, message='Not unique'
            )

        class ModelTestForm(ModelForm):
            class Meta:
                model = ModelTest
                unique_validator = unique

            @staticmethod
            def get_session():
                return None

        form = ModelTestForm()
        assert form.test_column.validators[2].message == 'Not unique'

########NEW FILE########
__FILENAME__ = test_widgets
from decimal import Decimal
import sqlalchemy as sa
from tests import ModelFormTestCase


class TestNumericFieldWidgets(ModelFormTestCase):
    def test_converts_numeric_scale_to_steps(self):
        self.init(
            type_=sa.Numeric(scale=2),
        )
        form = self.form_class()
        assert 'step="0.01"' in str(form.test_column)

    def test_supports_numeric_column_without_scale(self):
        self.init(
            type_=sa.Numeric(),
        )
        form = self.form_class()
        assert 'step="any"' in str(form.test_column)

    def test_supports_step_as_info_arg(self):
        self.init(
            type_=sa.Numeric(), info={'step': '0.1'},
        )
        form = self.form_class()
        assert 'step="0.1"' in str(form.test_column)

    def test_numeric_field_with_scale_and_choices(self):
        self.init(
            type_=sa.Numeric(scale=2),
            info={'choices': [
                (Decimal('1.1'), 'choice1'),
                (Decimal('1.2'), 'choice2')
            ]},
        )
        form = self.form_class()
        assert 'step="0.1"' not in str(form.test_column)


class TestIntegerFieldWidgets(ModelFormTestCase):
    def test_supports_step_as_info_arg(self):
        self.init(
            type_=sa.Integer, info={'step': '3'},
        )
        form = self.form_class()
        assert 'step="3"' in str(form.test_column)


class TestFloatFieldWidgets(ModelFormTestCase):
    def test_supports_step_as_info_arg(self):
        self.init(
            type_=sa.Float, info={'step': '0.2'},
        )
        form = self.form_class()
        assert 'step="0.2"' in str(form.test_column)

########NEW FILE########
__FILENAME__ = exc
class UnknownTypeException(Exception):
    def __init__(self, column):
        Exception.__init__(
            self,
            "Unknown type '%s' for column '%s'" %
            (column.type, column.name)
        )


class InvalidAttributeException(Exception):
    def __init__(self, attr_name):
        Exception.__init__(
            self,
            "Model does not contain attribute named '%s'." %
            attr_name
        )


class AttributeTypeException(Exception):
    def __init__(self, attr_name):
        Exception.__init__(
            self,
            "Model attribute '%s' is not of type ColumnProperty." %
            attr_name
        )


class UnknownConfigurationOption(Exception):
    def __init__(self, option):
        Exception.__init__(
            self,
            "Unknown configuration option '%s' given." %
            option
        )

########NEW FILE########
__FILENAME__ = fields
import operator
from wtforms_components import SelectField
from sqlalchemy_utils.types import Country
from sqlalchemy_utils import i18n
import six
from wtforms.fields import FieldList, FormField
try:
    from wtforms.utils import unset_value as _unset_value
except ImportError:
    from wtforms.fields import _unset_value
from .utils import find_entity


class SkipOperation(Exception):
    pass


class ModelFormField(FormField):
    def populate_obj(self, obj, name):
        if self.data:
            try:
                if getattr(obj, name) is None:
                    setattr(obj, name, self.form.Meta.model())
            except AttributeError:
                pass
        FormField.populate_obj(self, obj, name)


class ModelFieldList(FieldList):
    def __init__(
            self,
            unbound_field,
            population_strategy='update',
            **kwargs):
        self.population_strategy = population_strategy
        super(ModelFieldList, self).__init__(unbound_field, **kwargs)

    @property
    def model(self):
        return self.unbound_field.args[0].Meta.model

    def _get_bound_field_for_entry(self, formdata, data, index):
        assert not self.max_entries or len(self.entries) < self.max_entries, \
            'You cannot have more than max_entries entries in this FieldList'
        new_index = self.last_index = index or (self.last_index + 1)
        name = '%s-%d' % (self.short_name, new_index)
        id = '%s-%d' % (self.id, new_index)
        if hasattr(self, 'meta'):
            # WTForms 2.0
            return self.unbound_field.bind(
                form=None,
                name=name,
                prefix=self._prefix,
                id=id,
                _meta=self.meta
            )
        else:
            # WTForms 1.0
            return self.unbound_field.bind(
                form=None, name=name, prefix=self._prefix, id=id
            )

    def _add_entry(self, formdata=None, data=_unset_value, index=None):
        field = self._get_bound_field_for_entry(
            formdata=formdata,
            data=data,
            index=index
        )
        if (
            data != _unset_value and
            data
        ):
            if formdata:
                field.process(formdata)
            else:
                field.process(formdata, data=data)

            entity = find_entity(self.object_data, self.model, field.data)
            if entity is not None:
                field.process(formdata, entity)
        else:
            field.process(formdata)

        self.entries.append(field)
        return field

    def populate_obj(self, obj, name):
        state = obj._sa_instance_state

        if not state.identity or self.population_strategy == 'replace':
            setattr(obj, name, [])
            for counter in six.moves.range(len(self.entries)):
                try:
                    getattr(obj, name).append(self.model())
                except AttributeError:
                    pass
        else:
            for index, entry in enumerate(self.entries):
                data = entry.data
                coll = getattr(obj, name)
                if find_entity(coll, self.model, data) is None:
                    coll.insert(index, self.model())
        FieldList.populate_obj(self, obj, name)


class CountryField(SelectField):
    def __init__(self, *args, **kwargs):
        kwargs['coerce'] = Country
        super(CountryField, self).__init__(*args, **kwargs)
        self.choices = self._get_choices

    def _get_choices(self):
        # Get all territories and filter out continents (3-digit code)
        # and some odd territories such as "Unknown or Invalid Region"
        # ("ZZ"), "European Union" ("QU") and "Outlying Oceania" ("QO").
        territories = [
            (code, name)
            for code, name in six.iteritems(i18n.get_locale().territories)
            if len(code) == 2 and code not in ('QO', 'QU', 'ZZ')
        ]
        return sorted(territories, key=operator.itemgetter(1))

########NEW FILE########
__FILENAME__ = generator
#import pytz
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict
from decimal import Decimal
import inspect
import six
from wtforms import (
    BooleanField,
    FloatField,
    TextAreaField,
    PasswordField,
)
from wtforms.widgets import (
    CheckboxInput,
    TextArea
)
import sqlalchemy as sa
from sqlalchemy.orm.properties import ColumnProperty
from sqlalchemy_utils import types
from wtforms_components import (
    ColorField,
    DateField,
    DateIntervalField,
    DateTimeField,
    DateTimeIntervalField,
    DateTimeLocalField,
    DecimalField,
    DecimalIntervalField,
    EmailField,
    IntegerField,
    IntIntervalField,
    PhoneNumberField,
    SelectField,
    StringField,
    TimeField,
    WeekDaysField,
)
from wtforms_components.widgets import (
    ColorInput,
    EmailInput,
    DateInput,
    DateTimeInput,
    DateTimeLocalInput,
    NumberInput,
    TextInput,
    TimeInput,
)
from .exc import (
    AttributeTypeException,
    InvalidAttributeException,
    UnknownTypeException
)
from .fields import CountryField
from .utils import (
    choice_type_coerce_factory,
    flatten,
    is_date_column,
    is_number,
    is_number_range,
    is_scalar,
    null_or_unicode,
    strip_string,
    translated_attributes,
    ClassMap
)


class FormGenerator(object):
    """
    Base form generator, you can make your own form generators by inheriting
    this class.
    """

    # When converting SQLAlchemy types to fields this ordered dict is iterated
    # in given order. This allows smart type conversion of different inherited
    # type objects.
    TYPE_MAP = ClassMap((
        (sa.types.UnicodeText, TextAreaField),
        (sa.types.BigInteger, IntegerField),
        (sa.types.SmallInteger, IntegerField),
        (sa.types.Text, TextAreaField),
        (sa.types.Boolean, BooleanField),
        (sa.types.Date, DateField),
        (sa.types.DateTime, DateTimeField),
        (sa.types.Enum, SelectField),
        (sa.types.Float, FloatField),
        (sa.types.Integer, IntegerField),
        (sa.types.Numeric, DecimalField),
        (sa.types.String, StringField),
        (sa.types.Time, TimeField),
        (sa.types.Unicode, StringField),
        (types.ArrowType, DateTimeField),
        (types.ChoiceType, SelectField),
        (types.ColorType, ColorField),
        (types.CountryType, CountryField),
        (types.DateRangeType, DateIntervalField),
        (types.DateTimeRangeType, DateTimeIntervalField),
        (types.EmailType, EmailField),
        (types.IntRangeType, IntIntervalField),
        (types.NumericRangeType, DecimalIntervalField),
        (types.PasswordType, PasswordField),
        (types.PhoneNumberType, PhoneNumberField),
        (types.ScalarListType, StringField),
        (types.UUIDType, StringField),
        (types.WeekDaysType, WeekDaysField),
    ))

    WIDGET_MAP = OrderedDict((
        (BooleanField, CheckboxInput),
        (ColorField, ColorInput),
        (DateField, DateInput),
        (DateTimeField, DateTimeInput),
        (DateTimeLocalField, DateTimeLocalInput),
        (DecimalField, NumberInput),
        (EmailField, EmailInput),
        (FloatField, NumberInput),
        (IntegerField, NumberInput),
        (TextAreaField, TextArea),
        (TimeField, TimeInput),
        (StringField, TextInput)
    ))

    def __init__(self, form_class):
        """
        Initializes the form generator

        :param form_class: ModelForm class to be used as the base of generation
                           process
        """
        self.form_class = form_class
        self.model_class = self.form_class.Meta.model
        self.meta = self.form_class.Meta
        self.TYPE_MAP.update(self.form_class.Meta.type_map)

    def create_form(self, form):
        """
        Creates the form.

        :param form: ModelForm instance
        """
        attrs = OrderedDict()
        for key, property_ in sa.inspect(self.model_class).attrs.items():
            if not isinstance(property_, ColumnProperty):
                continue
            if self.skip_column_property(property_):
                continue
            attrs[key] = property_

        for attr in translated_attributes(self.model_class):
            attrs[attr.key] = attr.property

        return self.create_fields(form, self.filter_attributes(attrs))

    def filter_attributes(self, attrs):
        """
        Filter set of model attributes based on only, exclude and include
        meta parameters.

        :param attrs: Set of attributes
        """
        if self.meta.only:
            attrs = OrderedDict([
                (key, prop)
                for key, prop in map(self.validate_attribute, self.meta.only)
                if key
            ])
        else:
            if self.meta.include:
                attrs.update([
                    (key, prop)
                    for key, prop
                    in map(self.validate_attribute, self.meta.include)
                    if key
                ])

            if self.meta.exclude:
                for key in self.meta.exclude:
                    try:
                        del attrs[key]
                    except KeyError:
                        if self.meta.attr_errors:
                            raise InvalidAttributeException(key)
        return attrs

    def validate_attribute(self, attr_name):
        """
        Finds out whether or not given sqlalchemy model attribute name is
        valid. Returns attribute property if valid.

        :param attr_name: Attribute name
        """
        try:
            attr = getattr(self.model_class, attr_name)
        except AttributeError:
            try:
                translation_class = (
                    self.model_class.__translatable__['class']
                )
                attr = getattr(translation_class, attr_name)
            except AttributeError:
                if self.meta.attr_errors:
                    raise InvalidAttributeException(attr_name)
                else:
                    return None, None
        try:
            if not isinstance(attr.property, ColumnProperty):
                if self.meta.attr_errors:
                    raise InvalidAttributeException(attr_name)
                else:
                    return None, None
        except AttributeError:
            raise AttributeTypeException(attr_name)
        return attr_name, attr.property

    def create_fields(self, form, properties):
        """
        Creates fields for given form based on given model attributes.

        :param form: form to attach the generated fields into
        :param attributes: model attributes to generate the form fields from
        """
        for key, prop in properties.items():
            column = prop.columns[0]
            try:
                field = self.create_field(prop, column)
            except UnknownTypeException:
                if not self.meta.skip_unknown_types:
                    raise
                else:
                    continue

            if not hasattr(form, key):
                setattr(form, key, field)

    def skip_column_property(self, column_property):
        """
        Whether or not to skip column property in the generation process.

        :param column_property: SQLAlchemy ColumnProperty object
        """
        if column_property._is_polymorphic_discriminator:
            return True

        return self.skip_column(column_property.columns[0])

    def skip_column(self, column):
        """
        Whether or not to skip column in the generation process.

        :param column_property: SQLAlchemy Column object
        """
        if not self.meta.include_foreign_keys and column.foreign_keys:
            return True

        if not self.meta.include_primary_keys and column.primary_key:
            return True

        if (not self.meta.include_datetimes_with_default and
                isinstance(column.type, sa.types.DateTime) and
                column.default):
            return True

        if isinstance(column.type, types.TSVectorType):
            return True

        if self.meta.only_indexed_fields and not self.has_index(column):
            return True

        # Skip all non columns (this is the case when using column_property
        # methods).
        if not isinstance(column, sa.Column):
            return True

        return False

    def has_index(self, column):
        """
        Whether or not given column has an index.

        :param column: Column object to inspect the indexes from
        """
        if column.primary_key or column.foreign_keys:
            return True
        table = column.table
        for index in table.indexes:
            if len(index.columns) == 1 and column.name in index.columns:
                return True
        return False

    def create_field(self, prop, column):
        """
        Create form field for given column.

        :param prop: SQLAlchemy ColumnProperty object.
        :param column: SQLAlchemy Column object.
        """
        kwargs = {}
        field_class = self.get_field_class(column)
        kwargs['default'] = self.default(column)
        kwargs['validators'] = self.create_validators(prop, column)
        kwargs['filters'] = self.filters(column)
        kwargs.update(self.type_agnostic_parameters(prop.key, column))
        kwargs.update(self.type_specific_parameters(column))
        if prop.key in self.meta.field_args:
            kwargs.update(self.meta.field_args[prop.key])

        if issubclass(field_class, DecimalField):
            if hasattr(column.type, 'scale'):
                kwargs['places'] = column.type.scale
        field = field_class(**kwargs)
        return field

    def default(self, column):
        """
        Return field default for given column.

        :param column: SQLAlchemy Column object
        """
        if column.default and is_scalar(column.default.arg):
            return column.default.arg
        else:
            if not column.nullable:
                return self.meta.default

    def filters(self, column):
        """
        Return filters for given column.

        :param column: SQLAlchemy Column object
        """
        should_trim = column.info.get('trim', None)
        filters = column.info.get('filters', [])
        if (
            (
                isinstance(column.type, sa.types.String) and
                self.meta.strip_string_fields and
                should_trim is None
            ) or
            should_trim is True
        ):
            filters.append(strip_string)
        return filters

    def date_format(self, column):
        """
        Returns date format for given column.

        :param column: SQLAlchemy Column object
        """
        if (
            isinstance(column.type, sa.types.DateTime) or
            isinstance(column.type, types.ArrowType)
        ):
            return self.meta.datetime_format

        if isinstance(column.type, sa.types.Date):
            return self.meta.date_format

    def type_specific_parameters(self, column):
        """
        Returns type specific parameters for given column.

        :param column: SQLAlchemy Column object
        """
        kwargs = {}
        if (
            hasattr(column.type, 'enums') or
            column.info.get('choices') or
            isinstance(column.type, types.ChoiceType)
        ):
            kwargs.update(self.select_field_kwargs(column))

        date_format = self.date_format(column)
        if date_format:
            kwargs['format'] = date_format

        if hasattr(column.type, 'country_code'):
            kwargs['country_code'] = column.type.country_code

        kwargs['widget'] = self.widget(column)
        return kwargs

    def widget(self, column):
        """
        Returns WTForms widget for given column.

        :param column: SQLAlchemy Column object
        """
        widget = column.info.get('widget', None)
        if widget is not None:
            return widget

        kwargs = {}

        step = column.info.get('step', None)
        if step is not None:
            kwargs['step'] = step
        else:
            if isinstance(column.type, sa.types.Numeric):
                if (
                    column.type.scale is not None and
                    not column.info.get('choices')
                ):
                    kwargs['step'] = self.scale_to_step(column.type.scale)

        if kwargs:
            widget_class = self.WIDGET_MAP[
                self.get_field_class(column)
            ]
            return widget_class(**kwargs)

    def scale_to_step(self, scale):
        """
        Returns HTML5 compatible step attribute for given decimal scale.

        :param scale: an integer that defines a Numeric column's scale
        """
        return str(pow(Decimal('0.1'), scale))

    def type_agnostic_parameters(self, key, column):
        """
        Returns all type agnostic form field parameters for given column.

        :param column: SQLAlchemy Column object
        """
        kwargs = {}
        kwargs['description'] = column.info.get('description', '')
        kwargs['label'] = column.info.get('label', key)
        return kwargs

    def select_field_kwargs(self, column):
        """
        Returns key value args for SelectField based on SQLAlchemy column
        definitions.

        :param column: SQLAlchemy Column object
        """
        kwargs = {}
        kwargs['coerce'] = self.coerce(column)
        if isinstance(column.type, types.ChoiceType):
            kwargs['choices'] = column.type.choices
        elif 'choices' in column.info and column.info['choices']:
            kwargs['choices'] = column.info['choices']
        else:
            kwargs['choices'] = [
                (enum, enum) for enum in column.type.enums
            ]
        return kwargs

    def coerce(self, column):
        """
        Returns coerce callable for given column

        :param column: SQLAlchemy Column object
        """
        if 'coerce' in column.info:
            return column.info['coerce']
        if isinstance(column.type, types.ChoiceType):
            return choice_type_coerce_factory(column.type)
        try:
            python_type = column.type.python_type
        except NotImplementedError:
            return null_or_unicode

        if column.nullable and issubclass(python_type, six.string_types):
            return null_or_unicode
        return python_type

    def create_validators(self, prop, column):
        """
        Returns validators for given column

        :param column: SQLAlchemy Column object
        """
        validators = [
            self.required_validator(column),
            self.length_validator(column),
            self.unique_validator(prop.key, column),
            self.range_validator(column)
        ]
        if isinstance(column.type, types.EmailType):
            validators.append(self.get_validator('email'))
        validators = flatten([v for v in validators if v is not None])

        validators.extend(self.additional_validators(prop.key, column))
        return validators

    def required_validator(self, column):
        """
        Returns required / optional validator for given column based on column
        nullability and form configuration.

        :param column: SQLAlchemy Column object
        """
        if (not self.meta.all_fields_optional and
                not column.default and
                not column.nullable):

            type_map = self.meta.not_null_validator_type_map
            try:
                return type_map[column.type]
            except KeyError:
                if isinstance(column.type, sa.types.TypeDecorator):
                    type_ = column.type.impl

                    try:
                        return type_map[type_]
                    except KeyError:
                        pass
                if self.meta.not_null_validator is not None:
                    return self.meta.not_null_validator
        return self.get_validator('optional')

    def get_validator(self, name, **kwargs):
        attr_name = '%s_validator' % name
        attr = getattr(self.meta, attr_name)
        if inspect.ismethod(attr):
            return six.get_unbound_function(attr)(**kwargs)
        else:
            return attr(**kwargs)

    def additional_validators(self, key, column):
        """
        Returns additional validators for given column

        :param key: String key of the column property
        :param column: SQLAlchemy Column object
        """
        validators = []
        if key in self.meta.validators:
            try:
                validators.extend(self.meta.validators[key])
            except TypeError:
                validators.append(self.meta.validators[key])

        if 'validators' in column.info and column.info['validators']:
            try:
                validators.extend(column.info['validators'])
            except TypeError:
                validators.append(column.info['validators'])
        return validators

    def unique_validator(self, key, column):
        """
        Returns unique validator for given column if column has a unique index

        :param key: String key of the column property
        :param column: SQLAlchemy Column object
        """
        if column.unique:
            return self.get_validator(
                'unique',
                column=getattr(self.model_class, key),
                get_session=self.form_class.get_session
            )

    def range_validator(self, column):
        """
        Returns range validator based on column type and column info min and
        max arguments

        :param column: SQLAlchemy Column object
        """
        min_ = column.info.get('min')
        max_ = column.info.get('max')

        if min_ is not None or max_ is not None:
            if is_number(column.type) or is_number_range(column.type):
                return self.get_validator('number_range', min=min_, max=max_)
            elif is_date_column(column):
                return self.get_validator('date_range', min=min_, max=max_)
            elif isinstance(column.type, sa.types.Time):
                return self.get_validator('time_range', min=min_, max=max_)

    def length_validator(self, column):
        """
        Returns length validator for given column

        :param column: SQLAlchemy Column object
        """
        if (
            isinstance(column.type, sa.types.String) and
            hasattr(column.type, 'length') and
            column.type.length
        ):
            return self.get_validator('length', max=column.type.length)

    def get_field_class(self, column):
        """
        Returns WTForms field class. Class is based on a custom field class
        attribute or SQLAlchemy column type.

        :param column: SQLAlchemy Column object
        """
        if ('form_field_class' in column.info
                and column.info['form_field_class']):
            return column.info['form_field_class']
        if 'choices' in column.info and column.info['choices']:
            return SelectField
        if (
            column.type not in self.TYPE_MAP and
            isinstance(column.type, sa.types.TypeDecorator)
        ):
            check_type = column.type.impl
        else:
            check_type = column.type

        try:
            return self.TYPE_MAP[check_type]
        except KeyError:
            raise UnknownTypeException(column)

########NEW FILE########
__FILENAME__ = utils
from inspect import isclass
import six
import sqlalchemy as sa
from sqlalchemy import types
from sqlalchemy_utils import NumericRangeType, IntRangeType
from sqlalchemy_utils.types.choice import Choice
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict


def choice_type_coerce_factory(type_):
    """
    Return a function needed to coerce a ChoiceTyped column. This function is
    then passed to generated SelectField as the default coerce function.

    :param type_: ChoiceType object
    """
    def choice_coerce(value):
        if value is None:
            return None
        if isinstance(value, Choice):
            return value.code
        return type_.python_type(value)
    return choice_coerce


def strip_string(value):
    if isinstance(value, six.string_types):
        return value.strip()
    return value


def is_scalar(value):
    return isinstance(value, (type(None), six.text_type, int, float, bool))


def null_or_unicode(value):
    return six.text_type(value) or None


def null_or_int(value):
    try:
        return int(value)
    except TypeError:
        return None


def flatten(list_):
    result = []
    if isinstance(list_, list):
        for value in list_:
            result.extend(flatten(value))
    else:
        result.append(list_)
    return result


def is_number(type):
    return isinstance(type, types.Integer) or isinstance(type, types.Numeric)


def is_number_range(type):
    return isinstance(type, IntRangeType) or isinstance(type, NumericRangeType)


def is_date_column(column):
    return (
        isinstance(column.type, types.Date) or
        isinstance(column.type, types.DateTime)
    )


def table(model):
    if isinstance(model, sa.schema.Table):
        return model
    else:
        return model.__table__


def primary_keys(model):
    for column in table(model).c:
        if column.primary_key:
            yield column


def find_entity(coll, model, data):
    for column in primary_keys(model):
        if not column.name in data or not data[column.name]:
            return None
        coerce_func = column.type.python_type
        for related_obj in coll:
            value = getattr(related_obj, column.name)

            try:
                if value == coerce_func(data[column.name]):
                    return related_obj
            except ValueError:
                # coerce failed
                pass
    return None


def translated_attributes(model):
    """
    Return translated attributes for current model class. See
    `SQLAlchemy-i18n package`_ for more information about translatable
    attributes.

    .. _`SQLAlchemy-i18n package`:
        https://github.com/kvesteri/sqlalchemy-i18n

    :param model: SQLAlchemy declarative model class
    """
    try:
        translation_class = model.__translatable__['class']
    except AttributeError:
        return []
    return [
        getattr(translation_class, column.key)
        for column in sa.inspect(translation_class).columns
        if not column.primary_key
    ]


def sorted_classes(classes, reverse=False):
    return sorted(
        classes,
        # We need to map classes to ids, since python 3 throws error when
        # trying to compare unorderable types.
        key=lambda a: tuple(id(v) for v in a.__mro__[::-1]),
        reverse=reverse
    )


class ClassMap(OrderedDict):
    """
    An ordered dictionary with keys as classes. ClassMap has the following
    charasteristics:

        1. Checking if a key exists not only matches exact classes but also
        subclasses and objects which are instances of a ClassMap key.

        2. Getting an item of ClassMap with a key matches subclasses and
        instances also.
    """
    def __init__(self, items=None):
        if items:
            items = dict(items)
            sorted_keys = sorted_classes(items.keys(), reverse=True)
            items = [(key, items[key]) for key in sorted_keys]
        else:
            items = {}
        OrderedDict.__init__(self, items)

    def __contains__(self, key):
        """
        Checks if given key exists in by first trying to find an exact match.
        If no exact match is found then this method iterates trhough keys
        and tries to check if given key is either:

            1. A subclass of one of the keys
            2. An instance of one of the keys

        The first check has the time complexity of O(1) whereas the second
        check has O(n).

        Example::



            class A(object):
                pass


            class B(object):
                pass


            class A2(A):
                pass


            class_map = ClassMap({A: 1, B: 2})
            assert B in class_map
            assert A in class_map
            assert A2 in class_map
            assert B() in class_map
            assert A() in class_map
            assert A2() in class_map
        """
        if OrderedDict.__contains__(self, key):
            return True
        test_func = issubclass if isclass(key) else isinstance
        return any(test_func(key, class_) for class_ in self)

    def __getitem__(self, key):
        """
        Returns the item matching a key. The key matching has the same
        charasteristics as __contains__ method.

        Example::

            class A(object):
                pass


            class B(object):
                pass


            class A2(A):
                pass


            class_map = ClassMap({A: 1, B: 2})
            assert class_map[B] == 2
            assert class_map[A] == 1
            assert class_map[A2] == 1
            assert class_map[B()] == 2
            assert class_map[A()] == 1
            assert class_map[A2()] == 1
        """
        try:
            return OrderedDict.__getitem__(self, key)
        except KeyError:
            if not isclass(key):
                key = type(key)
            for class_ in self:
                if issubclass(key, class_):
                    return OrderedDict.__getitem__(self, class_)
            raise

########NEW FILE########
