__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-permission documentation build configuration file, created by
# sphinx-quickstart on Tue Jan 14 03:12:35 2014.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
BASE_DIR = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(BASE_DIR, 'src'))
sys.path.insert(0, os.path.join(BASE_DIR, 'tests'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'


# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'numpydoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-permission'
copyright = u'2014, Alisue <lambdalisue@hashnote.net>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
import permission
version = permission.__version__
# The full version, including alpha/beta/rc tags.
release = permission.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-permissiondoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-permission.tex', u'django-permission Documentation',
   u'Alisue \\textless{}lambdalisue@hashnote.net\\textgreater{}', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-permission', u'django-permission Documentation',
     [u'Alisue <lambdalisue@hashnote.net>'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-permission', u'django-permission Documentation',
   u'Alisue <lambdalisue@hashnote.net>', 'django-permission', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'django-permission'
epub_author = u'Alisue <lambdalisue@hashnote.net>'
epub_publisher = u'Alisue <lambdalisue@hashnote.net>'
epub_copyright = u'2014, Alisue <lambdalisue@hashnote.net>'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = manage
# coding=utf-8
"""
Django 1.2 - 1.6 compatible manage.py
Modify this script to make your own manage.py
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import os
import sys


if __name__ == '__main__':
    # add extra sys.path
    root = os.path.abspath(os.path.dirname(__file__))
    extra_paths = (root, os.path.join(root, 'src'))
    for extra_path in extra_paths:
        if extra_path in sys.path:
            sys.path.remove(extra_path)
        sys.path.insert(0, extra_path)
    # set DJANGO_SETTINGS_MODULE
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.settings')

    try:
        # django 1.4 and above
        # https://docs.djangoproject.com/en/1.4/releases/1.4/
        from django.core.management import execute_from_command_line
        execute_from_command_line(sys.argv)
    except ImportError:
        from django.core.management import execute_manager
        settings = __import__(os.environ['DJANGO_SETTINGS_MODULE'])
        execute_manager(settings)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
# coding: utf-8
"""
Run Django Test with Python setuptools test command


REFERENCE:
    http://gremu.net/blog/2010/enable-setuppy-test-your-django-apps/

"""
import os
import sys

def parse_args():
    import optparse
    parser = optparse.OptionParser()
    parser.add_option('--where', default=None)
    opts, args = parser.parse_args()
    return opts, args

def run_tests(base_dir=None, apps=None, verbosity=1, interactive=False):
    base_dir = base_dir or os.path.dirname(__file__)
    os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'
    sys.path.insert(0, os.path.join(base_dir, 'src'))
    sys.path.insert(0, os.path.join(base_dir, 'tests'))

    from django.conf import settings
    from django.test.utils import get_runner
    TestRunner = get_runner(settings)
    test_runner = TestRunner(verbosity=verbosity,
                             interactive=interactive, failfast=False)
    if apps:
        app_tests = [x.strip() for x in apps if x]
    else:
        app_tests = [
            'permission',
        ]
    failures = test_runner.run_tests(app_tests)
    sys.exit(bool(failures))

if __name__ == '__main__':
    opts, args = parse_args()
    run_tests(opts.where, args)

########NEW FILE########
__FILENAME__ = backends
# coding=utf-8
"""
Logical permission backends module
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
__all__ = ('PermissionBackend',)
from permission.conf import settings
from permission.utils.handlers import registry
from permission.utils.permissions import perm_to_permission


class PermissionBackend(object):
    """
    A handler based permission backend
    """
    supports_object_permissions = True
    supports_anonymous_user = True
    supports_inactive_user = True

    def authenticate(self, username, password):
        """
        Always return ``None`` to prevent authentication within this backend.
        """
        return None

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object) based on registered handlers.

        It will raise ``ObjectDoesNotExist`` exception when the specified
        string permission does not exist and
        ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``
        module.

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).

        Raises
        ------
        django.core.exceptions.ObjectDoesNotExist
            If the specified string permission does not exist and
            ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``
            module.
        """
        if settings.PERMISSION_CHECK_PERMISSION_PRESENCE:
            # get permission instance from string permission (perm)
            # it raise ObjectDoesNotExists when the permission is not exists
            perm_to_permission(perm)

        # get permission handlers fot this perm
        cache_name = '_%s_cache' % perm
        if hasattr(self, cache_name):
            handlers = getattr(self, cache_name)
        else:
            handlers = [h for h in registry.get_handlers()
                        if perm in h.get_supported_permissions()]
            setattr(self, cache_name, handlers)
        for handler in handlers:
            if handler.has_perm(user_obj, perm, obj=obj):
                return True
        return False

    def has_module_perms(self, user_obj, app_label):
        """
        Check if user have permission of specified app based on registered
        handlers.

        It will raise ``ObjectDoesNotExist`` exception when the specified
        string permission does not exist and
        ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``
        module.

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).

        Raises
        ------
        django.core.exceptions.ObjectDoesNotExist
            If the specified string permission does not exist and
            ``PERMISSION_CHECK_PERMISSION_PRESENCE`` is ``True`` in ``settings``
            module.
        """
        # get permission handlers fot this perm
        cache_name = '_%s_cache' % app_label
        if hasattr(self, cache_name):
            handlers = getattr(self, cache_name)
        else:
            handlers = [h for h in registry.get_handlers()
                        if app_label in h.get_supported_app_labels()]
            setattr(self, cache_name, handlers)
        for handler in handlers:
            if handler.has_module_perms(user_obj, app_label):
                return True
        return False

########NEW FILE########
__FILENAME__ = compat
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
try:
    import collections

    def isiterable(x):
        return isinstance(x, collections.Iterable)
except ImportError:
    def isiterable(x):
        try:
            iter(x)
            return True
        except TypeError:
            return False

########NEW FILE########
__FILENAME__ = conf
# coding=utf-8
"""
django-permission application configure
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
__all__ = ('settings',)
from django.conf import settings
from appconf import AppConf
from permission.handlers import LogicalPermissionHandler

class PermissionConf(AppConf):
    DEFAULT_PERMISSION_HANDLER = LogicalPermissionHandler
    """Default permission handler class"""

    CHECK_PERMISSION_PRESENCE = settings.DEBUG
    """Check if the specified string permission exists"""

    REPLACE_BUILTIN_IF = True
    """Whether replace builtin if templatetag"""

    DEFAULT_APL_FIELD_NAME = 'author'
    DEFAULT_APL_ANY_PERMISSION = False
    DEFAULT_APL_CHANGE_PERMISSION = True
    DEFAULT_APL_DELETE_PERMISSION = True

    DEFAULT_CPL_FIELD_NAME = 'collaborators'
    DEFAULT_CPL_ANY_PERMISSION = False
    DEFAULT_CPL_CHANGE_PERMISSION = True
    DEFAULT_CPL_DELETE_PERMISSION = False

    DEFAULT_GIPL_ANY_PERMISSION = False
    DEFAULT_GIPL_ADD_PERMISSION = True
    DEFAULT_GIPL_CHANGE_PERMISSION = True
    DEFAULT_GIPL_DELETE_PERMISSION = False

    DEFAULT_SPL_ANY_PERMISSION = False
    DEFAULT_SPL_ADD_PERMISSION = True
    DEFAULT_SPL_CHANGE_PERMISSION = True
    DEFAULT_SPL_DELETE_PERMISSION = False

    AUTODISCOVER_MODULE_NAME = 'perms'
    AUTODISCOVER_VARIABLE_NAME = 'PERMISSION_LOGICS'

########NEW FILE########
__FILENAME__ = classbase
# coding=utf-8
"""
permission_required decorator for generic classbased view from django 1.3
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from functools import wraps
from django.utils.decorators import available_attrs
from django.core.exceptions import PermissionDenied

from permission.decorators.utils import redirect_to_login

def permission_required(perm, queryset=None,
                        login_url=None, raise_exception=False):
    """
    Permission check decorator for classbased generic view

    This decorator works as class decorator
    DO NOT use ``method_decorator`` or whatever while this decorator will use
    ``self`` argument for method of classbased generic view.

    Parameters
    ----------
    perm : string
        A permission string
    queryset_or_model : queryset or model
        A queryset or model for finding object.
        With classbased generic view, ``None`` for using view default queryset.
        When the view does not define ``get_queryset``, ``queryset``,
        ``get_object``, or ``object`` then ``obj=None`` is used to check
        permission.
        With functional generic view, ``None`` for using passed queryset.
        When non queryset was passed then ``obj=None`` is used to check
        permission.

    Examples
    --------
    >>> @permission_required('auth.change_user')
    >>> class UpdateAuthUserView(UpdateView):
    ...     pass
    """
    def wrapper(cls):
        def view_wrapper(view_func):
            @wraps(view_func, assigned=available_attrs(view_func))
            def inner(self, request, *args, **kwargs):
                # get object
                obj = get_object_from_classbased_instance(
                        self, queryset, request, *args, **kwargs
                    )

                if not request.user.has_perm(perm, obj=obj):
                    if raise_exception:
                        raise PermissionDenied
                    else:
                        return redirect_to_login(request, login_url)
                return view_func(self, request, *args, **kwargs)
            return inner
        cls.dispatch = view_wrapper(cls.dispatch)
        return cls
    return wrapper


def get_object_from_classbased_instance(
        instance, queryset, request, *args, **kwargs):
    """
    Get object from an instance of classbased generic view
    
    Parameters
    ----------
    instance : instance
        An instance of classbased generic view
    queryset : instance
        A queryset instance
    request : instance
        A instance of HttpRequest

    Returns
    -------
    instance
        An instance of model object or None
    """
    from django.views.generic.edit import BaseCreateView
    # initialize request, args, kwargs of classbased_instance
    # most of methods of classbased view assumed these attributes
    # but these attributes is initialized in ``dispatch`` method.
    instance.request = request
    instance.args = args
    instance.kwargs = kwargs

    # get queryset from class if ``queryset_or_model`` is not specified
    if hasattr(instance, 'get_queryset') and not queryset:
        queryset = instance.get_queryset()
    elif hasattr(instance, 'queryset') and not queryset:
        queryset = instance.queryset
    elif hasattr(instance, 'model') and not queryset:
        queryset = instance.model._default_manager.all()
        
    # get object
    if hasattr(instance, 'get_object'):
        try:
            obj = instance.get_object(queryset)
        except AttributeError as e:
            # CreateView has ``get_object`` method but CreateView
            # should not have any object before thus simply set
            # None
            if isinstance(instance, BaseCreateView):
                obj = None
            else:
                raise e
    elif hasattr(instance, 'object'):
        obj = instance.object
    else:
        obj = None
    return obj


########NEW FILE########
__FILENAME__ = functionbase
# coding=utf-8
"""
permission_required decorator for generic function view
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import copy
from functools import wraps
from django.shortcuts import get_object_or_404
from django.utils.decorators import available_attrs
from django.core.exceptions import PermissionDenied

from permission.decorators.utils import redirect_to_login


def permission_required(perm, queryset=None,
                        login_url=None, raise_exception=False):
    """
    Permission check decorator for function-base generic view

    This decorator works as function decorator

    Parameters
    ----------
    perm : string
        A permission string
    queryset_or_model : queryset or model
        A queryset or model for finding object.
        With classbased generic view, ``None`` for using view default queryset.
        When the view does not define ``get_queryset``, ``queryset``,
        ``get_object``, or ``object`` then ``obj=None`` is used to check
        permission.
        With functional generic view, ``None`` for using passed queryset.
        When non queryset was passed then ``obj=None`` is used to check
        permission.

    Examples
    --------
    >>> @permission_required('auth.change_user')
    >>> def update_auth_user(request, *args, **kwargs):
    ...     pass
    """
    def wrapper(view_func):
        @wraps(view_func, assigned=available_attrs(view_func))
        def inner(request, *args, **kwargs):
            _kwargs = copy.copy(kwargs)
            # overwrite queryset if specified
            if queryset:
                _kwargs['queryset'] = queryset

            # get object from view
            if 'date_field' in _kwargs:
                fn = get_object_from_date_based_view
            else:
                fn = get_object_from_list_detail_view
            if fn.validate(request, *args, **_kwargs):
                obj = fn(request, *args, **_kwargs)
            else:
                # required arguments is not passed
                obj = None

            if not request.user.has_perm(perm, obj=obj):
                if raise_exception:
                    raise PermissionDenied
                else:
                    return redirect_to_login(request, login_url)
            return view_func(request, *args, **_kwargs)
        return inner
    return wrapper


def get_object_from_list_detail_view(request, *args, **kwargs):
    """
    Get object from generic list_detail.detail view

    Parameters
    ----------
    request : instance
        An instance of HttpRequest

    Returns
    -------
    instance
        An instance of model object or None
    """
    queryset = kwargs['queryset']
    object_id = kwargs.get('object_id', None)
    slug = kwargs.get('slug', None)
    slug_field = kwargs.get('slug_field', 'slug')
    if object_id:
        obj = get_object_or_404(queryset, pk=object_id)
    elif slug and slug_field:
        obj = get_object_or_404(queryset, **{slug_field: slug})
    else:
        raise AttributeError(
                "Generic detail view must be called with either an "
                "object_id or a slug/slug_field."
            )
    return obj
def _get_object_from_list_detail_view_validation(request, *args, **kwargs):
    if 'queryset' not in kwargs:
        return False
    elif 'object_id' not in kwargs and 'slug' not in kwargs:
        return False
    return True
get_object_from_list_detail_view.validate = \
        _get_object_from_list_detail_view_validation


def get_object_from_date_based_view(request, *args, **kwargs):
    """
    Get object from generic date_based.detail view

    Parameters
    ----------
    request : instance
        An instance of HttpRequest

    Returns
    -------
    instance
        An instance of model object or None
    """
    import time
    import datetime
    from django.http import Http404
    from django.db.models.fields import DateTimeField
    try:
        from django.utils import timezone
        datetime_now = timezone.now
    except ImportError:
        datetime_now = datetime.datetime.now
    year, month, day = kwargs['year'], kwargs['month'], kwargs['day']
    month_format = kwargs.get('month_format', '%b')
    day_format = kwargs.get('day_format', '%d')
    date_field = kwargs['date_field']
    queryset = kwargs['queryset']
    object_id = kwargs.get('object_id', None)
    slug = kwargs.get('slug', None)
    slug_field = kwargs.get('slug_field', 'slug')
    
    try:
        tt = time.strptime(
                '%s-%s-%s' % (year, month, day),
                '%s-%s-%s' % ('%Y', month_format, day_format)
            )
        date = datetime.date(*tt[:3])
    except ValueError:
        raise Http404

    model = queryset.model

    if isinstance(model._meta.get_field(date_field), DateTimeField):
        lookup_kwargs = {
                '%s__range' % date_field: (
                    datetime.datetime.combine(date, datetime.time.min),
                    datetime.datetime.combine(date, datetime.time.max),
                )}
    else:
        lookup_kwargs = {date_field: date}

    now = datetime_now()
    if date >= now.date() and not kwargs.get('allow_future', False):
        lookup_kwargs['%s__lte' % date_field] = now
    if object_id:
        lookup_kwargs['pk'] = object_id
    elif slug and slug_field:
        lookup_kwargs['%s__exact' % slug_field] = slug
    else:
        raise AttributeError(
                "Generic detail view must be called with either an "
                "object_id or a slug/slug_field."
            )
    return get_object_or_404(queryset, **lookup_kwargs)
def _get_object_from_date_based_view_validation(request, *args, **kwargs):
    if 'queryset' not in kwargs:
        return False
    elif 'year' not in kwargs or 'month' not in kwargs or 'day' not in kwargs:
        return False
    elif 'object_id' not in kwargs and 'slug' not in kwargs:
        return False
    return True
get_object_from_date_based_view.validate = \
        _get_object_from_date_based_view_validation

########NEW FILE########
__FILENAME__ = methodbase
# coding=utf-8
"""
permission_required decorator for generic classbased/functionbased view
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from functools import wraps
from django.http import HttpRequest
from django.utils.decorators import available_attrs
from django.core.exceptions import PermissionDenied

from permission.decorators.utils import redirect_to_login


def permission_required(perm, queryset=None,
                        login_url=None, raise_exception=False):
    """
    Permission check decorator for classbased/functionbased generic view

    This decorator works as method or function decorator
    DO NOT use ``method_decorator`` or whatever while this decorator will use
    ``self`` argument for method of classbased generic view.

    Parameters
    ----------
    perm : string
        A permission string
    queryset_or_model : queryset or model
        A queryset or model for finding object.
        With classbased generic view, ``None`` for using view default queryset.
        When the view does not define ``get_queryset``, ``queryset``,
        ``get_object``, or ``object`` then ``obj=None`` is used to check
        permission.
        With functional generic view, ``None`` for using passed queryset.
        When non queryset was passed then ``obj=None`` is used to check
        permission.

    Examples
    --------
    >>> # As method decorator
    >>> class UpdateAuthUserView(UpdateView):
    >>>     @permission_required('auth.change_user')
    >>>     def dispatch(self, request, *args, **kwargs):
    ...         pass
    >>> # As function decorator
    >>> @permission_required('auth.change_user')
    >>> def update_auth_user(request, *args, **kwargs):
    ...     pass
    """
    def wrapper(view_method):
        @wraps(view_method, assigned=available_attrs(view_method))
        def inner(self, request=None, *args, **kwargs):
            if isinstance(self, HttpRequest):
                from permission.decorators.functionbase import \
                        permission_required as decorator
                # this is a functional view not classbased view.
                decorator = decorator(perm, queryset,
                                      login_url, raise_exception)
                decorator = decorator(view_method)
                if not request:
                    args = list(args)
                    args.insert(0, request)
                request = self
                return decorator(request, *args, **kwargs)
            else:
                from permission.decorators.classbase import \
                        get_object_from_classbased_instance
                # get object
                obj = get_object_from_classbased_instance(
                        self, queryset, request, *args, **kwargs
                    )
                
                if not request.user.has_perm(perm, obj=obj):
                    if raise_exception:
                        raise PermissionDenied
                    else:
                        return redirect_to_login(request, login_url)
                return view_method(self, request, *args, **kwargs)
        return inner
    return wrapper

########NEW FILE########
__FILENAME__ = permission_required
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
# coding=utf-8
"""
Decorator module for permission
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
__all__ = ['permission_required']
import inspect
from django.db.models import Model


def permission_required(perm, queryset_or_model=None,
                        login_url=None, raise_exception=False):
    """
    Permission check decorator for classbased/functional generic view

    This decorator works as class, method or function decorator without any
    modification.
    DO NOT use ``method_decorator`` or whatever while this decorator will use
    ``self`` argument for method of classbased generic view.

    Parameters
    ----------
    perm : string
        A permission string
    queryset_or_model : queryset or model
        A queryset or model for finding object.
        With classbased generic view, ``None`` for using view default queryset.
        When the view does not define ``get_queryset``, ``queryset``,
        ``get_object``, or ``object`` then ``obj=None`` is used to check
        permission.
        With functional generic view, ``None`` for using passed queryset.
        When non queryset was passed then ``obj=None`` is used to check
        permission.

    Examples
    --------
    >>> # As class decorator
    >>> @permission_required('auth.change_user')
    >>> class UpdateAuthUserView(UpdateView):
    ...     pass
    >>> # As method decorator
    >>> class UpdateAuthUserView(UpdateView):
    ...     @permission_required('auth.change_user')
    ...     def dispatch(self, request, *args, **kwargs):
    ...         pass
    >>> # As function decorator
    >>> @permission_required('auth.change_user')
    >>> def update_auth_user(request, *args, **kwargs):
    ...     pass

    .. Note::
        Classbased generic view is recommended while you can regulate the queryset
        with ``get_queryset()`` method.
        Detecting object from passed kwargs may not work correctly.
    """
    # convert model to queryset
    if queryset_or_model and issubclass(queryset_or_model, Model):
        queryset_or_model = queryset_or_model._default_manager.all()

    def wrapper(class_or_method):
        if inspect.isclass(class_or_method):
            from permission.decorators.classbase import \
                    permission_required as decorator
        else:
            # method_permission_required can handle method or function
            # correctly.
            from permission.decorators.methodbase import \
                    permission_required as decorator
        return decorator(perm, queryset_or_model,
                         login_url, raise_exception)(class_or_method)
    return wrapper

########NEW FILE########
__FILENAME__ = utils
# coding=utf-8
"""
Decorator utility module
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
__all__ = ['redirect_to_login']
import urlparse
from django.contrib.auth import REDIRECT_FIELD_NAME
from permission.conf import settings

def redirect_to_login(request, login_url=None,
                      redirect_field_name=REDIRECT_FIELD_NAME):
    """redirect to login"""
    path = request.build_absolute_uri()
    # if the login url is the same scheme and net location then just
    # use the path as the "next" url.
    login_scheme, login_netloc = \
            urlparse.urlparse(login_url or settings.LOGIN_URL)[:2]
    current_scheme, current_netloc = urlparse.urlparse(path)[:2]
    if ((not login_scheme or login_scheme == current_scheme) and
        (not login_netloc or login_netloc == current_netloc)):
        path = request.get_full_path()
    from django.contrib.auth.views import \
            redirect_to_login as auth_redirect_to_login
    return auth_redirect_to_login(path, login_url, redirect_field_name)

########NEW FILE########
__FILENAME__ = handlers
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.conf import settings
from permission.utils.permissions import get_app_perms
from permission.utils.permissions import get_model_perms
import collections


class PermissionHandler(object):
    """
    Abstract permission handler class
    """
    _includes = None
    _excludes = None

    @property
    def includes(self):
        return self._includes
    @includes.setter
    def includes(self, value):
        # clear cache
        if hasattr(self, '_perms_cache'):
            del self._perms_cache
        self._includes = value

    @property
    def excludes(self):
        return self._excludes
    @excludes.setter
    def excludes(self, value):
        # clear cache
        if hasattr(self, '_perms_cache'):
            del self._perms_cache
        self._excludes = value


    def __init__(self, model_or_app_label):
        """
        Constructor

        Parameters
        ----------
        model_or_app_label : django model class or string
            A django model class or application label string.
            Use django model class for model level permission and application
            label for application level permission.
        """
        if isinstance(model_or_app_label, str):
            self.app_label = model_or_app_label
            self.model = None
            if self.includes is None:
                self.includes = self._get_app_perms
        else:
            self.app_label = model_or_app_label._meta.app_label
            self.model = model_or_app_label
            self.model._permission_handler = self
            if self.includes is None:
                self.includes = self._get_model_perms

    def _get_app_perms(self, *args):
        """
        Get permissions related to the application specified in constructor

        Returns
        -------
        set
            A set instance of `app_label.codename` formatted permission strings
        """
        if not hasattr(self, '_app_perms_cache'):
            self._app_perms_cache = get_app_perms(self.app_label)
        return self._app_perms_cache

    def _get_model_perms(self, *args):
        """
        Get permissions related to the model specified in constructor

        Returns
        -------
        set
            A set instance of `app_label.codename` formatted permission strings
        """
        if not hasattr(self, '_model_perms_cache'):
            if self.model is None:
                self._model_perms_cache = set()
            else:
                self._model_perms_cache = get_model_perms(self.model)
        return self._model_perms_cache

    def get_supported_permissions(self):
        """
        Get permissions which this handler can treat.
        Specified with :attr:`includes` and :attr:`excludes` of this instance.

        Returns
        -------
        set
            A set instance of `app_label.codename` formatted permission strings
        """
        if not hasattr(self, '_perms_cache'):
            if self.includes and isinstance(self.includes, collections.Callable):
                includes = self.includes(self)
            else:
                includes = self.includes or []
            if self.excludes and isinstance(self.excludes, collections.Callable):
                excludes = self.excludes(self)
            else:
                excludes = self.excludes or []
            includes = set(includes)
            excludes = set(excludes)
            includes = includes.difference(excludes)
            self._perms_cache = includes
        return self._perms_cache

    def get_supported_app_labels(self):
        """
        Get app labels which this handler can treat.
        Specified with :attr:`includes` and :attr:`excludes` of this instance.

        Returns
        -------
        set
            A set instance of app_label
        """
        get_app_label = lambda x: x.split(".", 1)[0]
        if not hasattr(self, '_app_labels_cache'):
            perms = self.get_supported_permissions()
            self._app_labels_cache = set([get_app_label(x) for x in perms])
        return self._app_labels_cache

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).

        .. note::
            Sub class must override this method.
        """
        raise NotImplementedError(
                "'%s' does not override `has_perm(user_obj, perm, obj=None)` "
                "method. Sub class must override this method." % self.__class__)

    def has_module_perms(self, user_obj, app_label):
        """
        Check if user have permission of specified app

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        app_label : string
            Django application name

        Returns
        -------
        boolean
            Wheter the specified user have any permissions of specified app

        """
        cache_name = "_has_module_perms_%s_%s_cache" % (app_label, user_obj.pk)
        if hasattr(self, cache_name):
            return getattr(self, cache_name)
        if self.app_label != app_label:
            setattr(self, cache_name, False)
        else:
            for permission in self.get_supported_permissions():
                if user_obj.has_perm(permission):
                    setattr(self, cache_name, True)
                    return True
        setattr(self, cache_name, False)
        return False


class LogicalPermissionHandler(PermissionHandler):
    """
    Permission handler class which use permission logics to determine the
    permission
    """

    def __init__(self, model):
        """
        Constructor

        Parameters
        ----------
        model : django model class
            A django model class.

        .. note::
            LogicalPermissionHandler cannot treat application level permission
        """
        # logical permission handler cannot treat application level permission
        if isinstance(model, str):
            raise AttributeError(
                    "'%s' cannot treat application level permission." %
                    self.__class__)
        super(LogicalPermissionHandler, self).__init__(model)

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object) based on
        specified models's ``_permission_logics`` attribute.

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).
        """
        if perm not in self.get_supported_permissions():
            return False
        for permission_logic in getattr(self.model, '_permission_logics', []):
            if permission_logic.has_perm(user_obj, perm, obj):
                return True
        return False

########NEW FILE########
__FILENAME__ = author
# coding=utf-8
"""
Permission logic module for author based permission system
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.conf import settings
from permission.logics.base import PermissionLogic
from permission.utils.field_lookup import field_lookup


class AuthorPermissionLogic(PermissionLogic):
    """
    Permission logic class for author based permission system
    """
    def __init__(self,
                 field_name=None,
                 any_permission=None,
                 change_permission=None,
                 delete_permission=None):
        """
        Constructor

        Parameters
        ----------
        field_name : string
            A field name of object which store the author as django user model.
            You can specify the related object with '__' like django queryset
            filter.
            Default value will be taken from
            ``PERMISSION_DEFAULT_APL_FIELD_NAME`` in
            settings.
        any_permission : boolean
            True for give any permission of the specified object to the author
            Default value will be taken from
            ``PERMISSION_DEFAULT_APL_ANY_PERMISSION`` in
            settings.
        change_permission : boolean
            True for give change permission of the specified object to the
            author.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_APL_CHANGE_PERMISSION`` in
            settings.
        delete_permission : boolean
            True for give delete permission of the specified object to the
            author.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_APL_DELETE_PERMISSION`` in
            settings.
        """
        self.field_name = field_name
        self.any_permission = any_permission
        self.change_permission = change_permission
        self.delete_permission = delete_permission

        if self.field_name is None:
            self.field_name = \
                settings.PERMISSION_DEFAULT_APL_FIELD_NAME
        if self.any_permission is None:
            self.any_permission = \
                settings.PERMISSION_DEFAULT_APL_ANY_PERMISSION
        if self.change_permission is None:
            self.change_permission = \
                settings.PERMISSION_DEFAULT_APL_CHANGE_PERMISSION
        if self.delete_permission is None:
            self.delete_permission = \
                settings.PERMISSION_DEFAULT_APL_DELETE_PERMISSION

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        If the user_obj is not authenticated, it return ``False``.

        If no object is specified, it return ``True`` when the corresponding
        permission was specified to ``True`` (changed from v0.7.0).
        This behavior is based on the django system.
        https://code.djangoproject.com/wiki/RowLevelPermissions

        If an object is specified, it will return ``True`` if the user is
        specified in ``field_name`` of the object (e.g. ``obj.author``).
        So once user create an object and the object store who is the author in
        ``field_name`` attribute (default: ``author``), the author can change
        or delete the object (you can change this behavior to set
        ``any_permission``, ``change_permissino`` or ``delete_permission``
        attributes of this instance).

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).
        """
        if not user_obj.is_authenticated():
            return False
        # construct the permission full name
        change_permission = self.get_full_permission_string('change')
        delete_permission = self.get_full_permission_string('delete')
        # check if the user is authenticated
        if obj is None:
            # object permission without obj should return True
            # Ref: https://code.djangoproject.com/wiki/RowLevelPermissions
            if self.any_permission:
                return True
            if self.change_permission and perm == change_permission:
                return True
            if self.delete_permission and perm == delete_permission:
                return True
            return False
        elif user_obj.is_active:
            # get author instance
            author = field_lookup(obj, self.field_name)
            if author == user_obj:
                if self.any_permission:
                    # have any kind of permissions to the obj
                    return True
                if (self.change_permission and
                        perm == change_permission):
                    return True
                if (self.delete_permission and
                        perm == delete_permission):
                    return True
        return False

########NEW FILE########
__FILENAME__ = base
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'


class PermissionLogic(object):
    """
    Abstract permission logic class
    """
    def get_full_permission_string(self, perm):
        """
        Return full permission string (app_label.perm_model)
        """
        if not getattr(self, 'model', None):
            raise AttributeError("You need to use `add_permission_logic` to "
                                 "register the instance to the model class "
                                 "before calling this method.")
        app_label = self.model._meta.app_label
        model_name = self.model._meta.object_name.lower()
        return "%s.%s_%s" % (app_label, perm, model_name)

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).

        .. note::
            Sub class must override this method.
        """
        raise NotImplementedError(
                "'%s' does not override `has_perm(user_obj, perm, obj=None)` "
                "method. Sub class of `PermissionLogic` must override this "
                "method.")

########NEW FILE########
__FILENAME__ = collaborators
# coding=utf-8
"""
Permission logic module for collaborators based permission system
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.conf import settings
from permission.logics.base import PermissionLogic
from permission.utils.field_lookup import field_lookup


class CollaboratorsPermissionLogic(PermissionLogic):
    """
    Permission logic class for collaborators based permission system
    """
    def __init__(self,
                 field_name=None,
                 any_permission=None,
                 change_permission=None,
                 delete_permission=None):
        """
        Constructor

        Parameters
        ----------
        field_name : string
            A field name of object which store the collaborators as django
            relational fields for django user model.
            You can specify the related object with '__' like django queryset
            filter.
            Default value will be taken from
            ``PERMISSION_DEFAULT_COLLABORATORS_PERMISSION_LOGIC_FIELD_NAME`` in
            settings.
        any_permission : boolean
            True for give any permission of the specified object to the
            collaborators.
            Default value will be taken from
            ``PERMISSION_DEFAULT_COLLABORATORS_PERMISSION_LOGIC_ANY_PERMISSION``
            in settings.
        change_permission : boolean
            True for give change permission of the specified object to the
            collaborators.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_COLLABORATORS_PERMISSION_LOGIC_CHANGE_PERMISSION``
            in settings.
        delete_permission : boolean
            True for give delete permission of the specified object to the
            collaborators.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_COLLABORATORS_PERMISSION_LOGIC_DELETE_PERMISSION``
            in settings.
        """
        self.field_name = field_name
        self.any_permission = any_permission
        self.change_permission = change_permission
        self.delete_permission = delete_permission

        if self.field_name is None:
            self.field_name = \
                settings.PERMISSION_DEFAULT_CPL_FIELD_NAME
        if self.any_permission is None:
            self.any_permission = \
                settings.PERMISSION_DEFAULT_CPL_ANY_PERMISSION
        if self.change_permission is None:
            self.change_permission = \
                settings.PERMISSION_DEFAULT_CPL_CHANGE_PERMISSION
        if self.delete_permission is None:
            self.delete_permission = \
                settings.PERMISSION_DEFAULT_CPL_DELETE_PERMISSION

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        If the user_obj is not authenticated, it return ``False``.

        If no object is specified, it return ``True`` when the corresponding
        permission was specified to ``True`` (changed from v0.7.0).
        This behavior is based on the django system.
        https://code.djangoproject.com/wiki/RowLevelPermissions


        If an object is specified, it will return ``True`` if the user is
        found in ``field_name`` of the object (e.g. ``obj.collaborators``).
        So once the object store the user as a collaborator in
        ``field_name`` attribute (default: ``collaborators``), the collaborator
        can change or delete the object (you can change this behavior to set
        ``any_permission``, ``change_permission`` or ``delete_permission``
        attributes of this instance).

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).
        """
        if not user_obj.is_authenticated():
            return False
        # construct the permission full name
        change_permission = self.get_full_permission_string('change')
        delete_permission = self.get_full_permission_string('delete')
        if obj is None:
            # object permission without obj should return True
            # Ref: https://code.djangoproject.com/wiki/RowLevelPermissions
            if self.any_permission:
                return True
            if self.change_permission and perm == change_permission:
                return True
            if self.delete_permission and perm == delete_permission:
                return True
            return False
        elif user_obj.is_active:
            # get collaborator queryset
            collaborators = field_lookup(obj, self.field_name)
            if hasattr(collaborators, 'all'):
                collaborators = collaborators.all()
            if user_obj in collaborators:
                if self.any_permission:
                    # have any kind of permissions to the obj
                    return True
                if (self.change_permission and
                        perm == change_permission):
                    return True
                if (self.delete_permission and
                        perm == delete_permission):
                    return True
        return False

########NEW FILE########
__FILENAME__ = groupin
# coding=utf-8
"""
Permission logic module for group based permission system
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.conf import settings
from permission.logics.base import PermissionLogic


class GroupInPermissionLogic(PermissionLogic):
    """
    Permission logic class for group based permission system
    """
    def __init__(self,
                 group_names,
                 any_permission=None,
                 add_permission=None,
                 change_permission=None,
                 delete_permission=None):
        """
        Constructor

        Parameters
        ----------
        group_names : string or list
            A group name list of this permission logic treat
        any_permission : boolean
            True for give any permission to the user_obj
            Default value will be taken from
            ``PERMISSION_DEFAULT_GIPL_ANY_PERMISSION`` in
            settings.
        add_permission : boolean
            True for give add permission to the user_obj.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_GIPL_ADD_PERMISSION`` in
            settings.
        change_permission : boolean
            True for give change permission of the specified object to the
            user_obj.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_GIPL_CHANGE_PERMISSION`` in
            settings.
        delete_permission : boolean
            True for give delete permission of the specified object to the
            user_obj.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_GIPL_DELETE_PERMISSION`` in
            settings.
        """
        self.group_names = group_names
        if not isinstance(self.group_names, (list, tuple)):
            self.group_names = [self.group_names]
        self.any_permission = any_permission
        self.add_permission = add_permission
        self.change_permission = change_permission
        self.delete_permission = delete_permission

        if self.any_permission is None:
            self.any_permission = \
                settings.PERMISSION_DEFAULT_GIPL_ANY_PERMISSION
        if self.add_permission is None:
            self.add_permission = \
                settings.PERMISSION_DEFAULT_GIPL_ADD_PERMISSION
        if self.change_permission is None:
            self.change_permission = \
                settings.PERMISSION_DEFAULT_GIPL_CHANGE_PERMISSION
        if self.delete_permission is None:
            self.delete_permission = \
                settings.PERMISSION_DEFAULT_GIPL_DELETE_PERMISSION

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        If the user_obj is not authenticated, it return ``False``.

        If no object is specified, it return ``True`` when the corresponding
        permission was specified to ``True`` (changed from v0.7.0).
        This behavior is based on the django system.
        https://code.djangoproject.com/wiki/RowLevelPermissions

        If an object is specified, it will return ``True`` if the user is
        in group specified in ``group_names`` of this instance.
        This permission logic is used mainly for group based role permission
        system.
        You can change this behavior to set ``any_permission``,
        ``add_permission``, ``change_permissino``, or ``delete_permission``
        attributes of this instance.

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Wheter the specified user have specified permission (of specified
            object).
        """
        if not user_obj.is_authenticated():
            return False
        # construct the permission full name
        add_permission = self.get_full_permission_string('add')
        change_permission = self.get_full_permission_string('change')
        delete_permission = self.get_full_permission_string('delete')
        if obj is None:
            if user_obj.groups.filter(name__in=self.group_names):
                if self.add_permission and perm == add_permission:
                    return True
                if self.change_permission and perm == change_permission:
                    return True
                if self.delete_permission and perm == delete_permission:
                    return True
                return self.any_permission
            return False
        elif user_obj.is_active:
            if user_obj.groups.filter(name__in=self.group_names):
                if self.any_permission:
                    # have any kind of permissions to the obj
                    return True
                if (self.add_permission and
                        perm == add_permission):
                    return True
                if (self.change_permission and
                        perm == change_permission):
                    return True
                if (self.delete_permission and
                        perm == delete_permission):
                    return True
        return False

########NEW FILE########
__FILENAME__ = staff
# coding=utf-8
"""
Permission logic module for author based permission system
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.conf import settings
from permission.logics.base import PermissionLogic


class StaffPermissionLogic(PermissionLogic):
    """
    Permission logic class for is_staff authority based permission system
    """
    def __init__(self,
                 any_permission=None,
                 add_permission=None,
                 change_permission=None,
                 delete_permission=None):
        """
        Constructor

        Parameters
        ----------
        any_permission : boolean
            True for give any permission of the specified object to the staff
            user. Default value will be taken from
            ``PERMISSION_DEFAULT_SPL_ANY_PERMISSION`` in
            settings.
        add_permission : boolean
            True for give change permission of the specified object to the
            staff user.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_SPL_ADD_PERMISSION`` in
            settings.
        change_permission : boolean
            True for give change permission of the specified object to the
            staff user.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_SPL_CHANGE_PERMISSION`` in
            settings.
        delete_permission : boolean
            True for give delete permission of the specified object to the
            staff user.
            It will be ignored if :attr:`any_permission` is True.
            Default value will be taken from
            ``PERMISSION_DEFAULT_SPL_DELETE_PERMISSION`` in
            settings.
        """
        self.any_permission = any_permission
        self.add_permission = add_permission
        self.change_permission = change_permission
        self.delete_permission = delete_permission

        if self.any_permission is None:
            self.any_permission = \
                settings.PERMISSION_DEFAULT_SPL_ANY_PERMISSION
        if self.add_permission is None:
            self.add_permission = \
                settings.PERMISSION_DEFAULT_SPL_ADD_PERMISSION
        if self.change_permission is None:
            self.change_permission = \
                settings.PERMISSION_DEFAULT_SPL_CHANGE_PERMISSION
        if self.delete_permission is None:
            self.delete_permission = \
                settings.PERMISSION_DEFAULT_SPL_DELETE_PERMISSION

    def has_perm(self, user_obj, perm, obj=None):
        """
        Check if user have permission (of object)

        If the user_obj is not authenticated, it return ``False``.

        If no object is specified, it return ``True`` when the corresponding
        permission was specified to ``True`` (changed from v0.7.0).
        This behavior is based on the django system.
        https://code.djangoproject.com/wiki/RowLevelPermissions

        If an object is specified, it will return ``True`` if the user is
        staff. The staff can add, change or delete the object (you can change
        this behavior to set ``any_permission``, ``add_permission``,
        ``change_permission``, or ``delete_permission`` attributes of this
        instance).

        Parameters
        ----------
        user_obj : django user model instance
            A django user model instance which be checked
        perm : string
            `app_label.codename` formatted permission string
        obj : None or django model instance
            None or django model instance for object permission

        Returns
        -------
        boolean
            Weather the specified user have specified permission (of specified
            object).
        """
        if not user_obj.is_authenticated():
            return False
        # construct the permission full name
        add_permission = self.get_full_permission_string('add')
        change_permission = self.get_full_permission_string('change')
        delete_permission = self.get_full_permission_string('delete')
        if obj is None:
            if user_obj.is_staff:
                if self.add_permission and perm == add_permission:
                    return True
                if self.change_permission and perm == change_permission:
                    return True
                if self.delete_permission and perm == delete_permission:
                    return True
                return self.any_permission
            return False
        elif user_obj.is_active:
            if user_obj.is_staff:
                if self.any_permission:
                    # have any kind of permissions to the obj
                    return True
                if (self.add_permission and
                        perm == add_permission):
                    return True
                if (self.change_permission and
                        perm == change_permission):
                    return True
                if (self.delete_permission and
                        perm == delete_permission):
                    return True
        return False

########NEW FILE########
__FILENAME__ = models
# fake

########NEW FILE########
__FILENAME__ = patch
# vim: set fileencoding=utf-8 :
"""
django if templatetag patch
"""
from distutils.version import StrictVersion
from django import get_version

if StrictVersion(get_version()) < '1.4':
    from django.template import Node
    from django.template import NodeList
    from django.template import VariableDoesNotExist
    from django.template import TemplateSyntaxError
    try:
        from django.template.base import TextNode
    except ImportError:
        from django.template import TextNode
    # copied from django 1.4b
    class IfNode(Node):
        def __init__(self, conditions_nodelists):
            self.conditions_nodelists = conditions_nodelists
        def __repr__(self):
            return "<IfNode>"
        def __iter__(self):
            for _, nodelist in self.conditions_nodelists:
                for node in nodelist:
                    yield node
        @property
        def nodelist(self):
            return NodeList(node for _, nodelist in self.conditions_nodelists for node in nodelist)
        def render(self, context):
            for condition, nodelist in self.conditions_nodelists:
                if condition is not None:           # if / elif clause
                    try:
                        match = condition.eval(context)
                    except VariableDoesNotExist:
                        match = None
                else:                               # else clause
                    match = True
                if match:
                    return nodelist.render(context)
            return ''
    # copied from django 1.4b
    def parse(self, parse_until=None):
        if parse_until is None:
            parse_until = []
        nodelist = self.create_nodelist()
        while self.tokens:
            token = self.next_token()
            # Use the raw values here for TOKEN_* for a tiny performance boost.
            if token.token_type == 0: # TOKEN_TEXT
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
            elif token.token_type == 1: # TOKEN_VAR
                if not token.contents:
                    self.empty_variable(token)
                filter_expression = self.compile_filter(token.contents)
                var_node = self.create_variable_node(filter_expression)
                self.extend_nodelist(nodelist, var_node, token)
            elif token.token_type == 2: # TOKEN_BLOCK
                try:
                    command = token.contents.split()[0]
                except IndexError:
                    self.empty_block_tag(token)
                if command in parse_until:
                    # put token back on token list so calling
                    # code knows why it terminated
                    self.prepend_token(token)
                    return nodelist
                # execute callback function for this tag and append
                # resulting node
                self.enter_command(command, token)
                try:
                    compile_func = self.tags[command]
                except KeyError:
                    self.invalid_block_tag(token, command, parse_until)
                try:
                    compiled_result = compile_func(self, token)
                except TemplateSyntaxError as e:
                    if not self.compile_function_error(token, e):
                        raise
                self.extend_nodelist(nodelist, compiled_result, token)
                self.exit_command()
        if parse_until:
            self.unclosed_block_tag(parse_until)
        return nodelist
    def parser_patch(instance):
        instance.__class__.parse = parse
        return instance
else:
    from django.template.defaulttags import IfNode
    parser_patch = lambda instance: instance

########NEW FILE########
__FILENAME__ = permissionif
# vim: set fileencoding=utf-8 :
"""
permissionif templatetag
"""
from django import template
from django.template import TemplateSyntaxError
from django.template import VariableDoesNotExist
from django.template.smartif import infix
from django.template.smartif import IfParser
from django.template.smartif import OPERATORS
from django.template.defaulttags import Node
from django.template.defaulttags import NodeList
from django.template.defaulttags import TemplateLiteral

from permission.conf import settings
from permission.templatetags.patch import IfNode
from permission.templatetags.patch import parser_patch

register = template.Library()

def of_operator(context, x, y):
    """
    'of' operator of permission if

    This operator is used to specify the target object of permission
    """
    return x.eval(context), y.eval(context)

def has_operator(context, x, y):
    """
    'has' operator of permission if
    
    This operator is used to specify the user object of permission
    """
    user = x.eval(context)
    perm = y.eval(context)
    if isinstance(perm, (list, tuple)):
        perm, obj = perm
    else:
        obj = None
    return user.has_perm(perm, obj)

# Add 'of' and 'has' operator to existing operators
EXTRA_OPERATORS = {
    'of': infix(20, of_operator),
    'has': infix(10, has_operator),
}
EXTRA_OPERATORS.update(OPERATORS)
for key, op in list(EXTRA_OPERATORS.items()):
    op.id = key

class PermissionIfParser(IfParser):
    """Permission if parser"""
    OPERATORS = EXTRA_OPERATORS
    """use extra operator"""

    def translate_token(self, token):
        try:
            # use own operators instead of builtin operators
            op = self.OPERATORS[token]
        except (KeyError, TypeError):
            return self.create_var(token)
        else:
            return op()

class TemplatePermissionIfParser(PermissionIfParser):
    error_class = TemplateSyntaxError

    def __init__(self, parser, *args, **kwargs):
        self.template_parser = parser
        super(TemplatePermissionIfParser, self).__init__(*args, **kwargs)

    def create_var(self, value):
        return TemplateLiteral(self.template_parser.compile_filter(value), value)


@register.tag('permission')
def do_permissionif(parser, token):
    """
    Permission if templatetag

    Examples
    --------
    ::

        {% if user has 'blogs.add_article' %}
            <p>This user have 'blogs.add_article' permission</p>
        {% elif user has 'blog.change_article' of object %}
            <p>This user have 'blogs.change_article' permission of {{object}}</p>
        {% endif %}

        {# If you set 'PERMISSION_REPLACE_BUILTIN_IF = False' in settings #}
        {% permission user has 'blogs.add_article' %}
            <p>This user have 'blogs.add_article' permission</p>
        {% elpermission user has 'blog.change_article' of object %}
            <p>This user have 'blogs.change_article' permission of {{object}}</p>
        {% endpermission %}

    """
    # patch parser for django 1.3.1
    parser = parser_patch(parser)

    bits = token.split_contents()
    ELIF = "el%s" % bits[0]
    ELSE = "else"
    ENDIF = "end%s" % bits[0]

    # {% if ... %}
    bits = bits[1:]
    condition = do_permissionif.Parser(parser, bits).parse()
    nodelist = parser.parse((ELIF, ELSE, ENDIF))
    conditions_nodelists = [(condition, nodelist)]
    token = parser.next_token()

    # {% elif ... %} (repeatable)
    while token.contents.startswith(ELIF):
        bits = token.split_contents()[1:]
        condition = do_permissionif.Parser(parser, bits).parse()
        nodelist = parser.parse((ELIF, ELSE, ENDIF))
        conditions_nodelists.append((condition, nodelist))
        token = parser.next_token()

    # {% else %} (optional)
    if token.contents == ELSE:
        nodelist = parser.parse((ENDIF,))
        conditions_nodelists.append((None, nodelist))
        token = parser.next_token()

    # {% endif %}
    assert token.contents == ENDIF

    return IfNode(conditions_nodelists)
do_permissionif.Parser = TemplatePermissionIfParser

if settings.PERMISSION_REPLACE_BUILTIN_IF:
    register.tag('if', do_permissionif)

########NEW FILE########
__FILENAME__ = compatibility
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
try:
    # from django 1.5
    from django.contrib.auth import get_user_model
    User = get_user_model()
except ImportError:
    from django.contrib.auth.models import User

try:
    # Python 3 have mock in unittest
    from unittest.mock import MagicMock
except ImportError:
    from mock import MagicMock

try:
    from django.test.utils import override_settings
except ImportError:
    from override_settings import override_settings

try:
    from unittest import skipIf
except ImportError:
    def skipIf(condition, message):
        def decorator(f):
            return None if condition else f
        return decorator

########NEW FILE########
__FILENAME__ = models
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.db import models
from django.contrib.auth.models import User


class Article(models.Model):
    title = models.CharField('title', max_length=200)
    content = models.TextField('content')

    author = models.ForeignKey(
        User, null=True,
        related_name='permission_test_articles_author')
    editor = models.ForeignKey(
        User, null=True,
        related_name='permission_test_articles_editor')
    authors = models.ManyToManyField(
        User, related_name='permission_test_articles_authors')
    editors = models.ManyToManyField(
        User, related_name='permission_test_articles_editors')

    single_bridge = models.ForeignKey(
        'permission.Bridge', null=True,
        related_name='permission_test_signgle_bridge')
    multiple_bridge = models.ManyToManyField(
        'permission.Bridge',
        related_name='permission_test_multiple_bridge')

    created_at = models.DateTimeField('created_at', auto_now_add=True)

    class Meta:
        app_label = 'permission'

    def __unicode__(self):
        return self.title


class Bridge(models.Model):
    author = models.ForeignKey(
        User, null=True, related_name='permission_test_bridge_author')
    editors = models.ManyToManyField(
        User, related_name='permission_test_bridge_editors')

    class Meta:
        app_label = 'permission'

########NEW FILE########
__FILENAME__ = test_backends
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from django.core.exceptions import ObjectDoesNotExist
from permission.tests.utils import create_user
from permission.tests.utils import create_article
from permission.tests.models import Article
from permission.tests.compatibility import MagicMock
from permission.tests.compatibility import override_settings
from permission.backends import PermissionBackend
from permission.utils.handlers import registry

@override_settings(
    AUTHENTICATION_BACKENDS=(
        'django.contrib.auth.backends.ModelBackend',
        'permission.backends.PermissionBackend',
    ),
)
class PermissionPermissionBackendTestCase(TestCase):
    def setUp(self):
        self.user = create_user('john')
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')
        self.original_get_handlers = registry.get_handlers

    def tearDown(self):
        registry.get_handlers = self.original_get_handlers

    def test_constructor(self):
        backend = PermissionBackend()

    def test_authenticate(self):
        backend = PermissionBackend()
        self.assertEqual(backend.authenticate(None, None), None)

    def test_has_perm_without_obj(self):
        perms = [
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]
        registry.get_handlers = MagicMock(return_value=[
            MagicMock(get_supported_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=False)),
            MagicMock(get_supported_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=True)),
        ])

        backend = PermissionBackend()
        self.assertFalse(registry.get_handlers.called)
        self.assertFalse(registry.get_handlers()[0].get_supported_permissions.called)
        self.assertFalse(registry.get_handlers()[1].get_supported_permissions.called)
        self.assertFalse(registry.get_handlers()[0].has_perm.called)
        self.assertFalse(registry.get_handlers()[1].has_perm.called)

        self.assertTrue(backend.has_perm(self.user, self.perm1))

        self.assertTrue(registry.get_handlers.called)
        self.assertTrue(registry.get_handlers()[0].get_supported_permissions.called)
        self.assertTrue(registry.get_handlers()[1].get_supported_permissions.called)
        self.assertTrue(registry.get_handlers()[0].has_perm.called)
        self.assertTrue(registry.get_handlers()[1].has_perm.called)

    def test_has_perm_with_obj(self):
        perms = [
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]
        registry.get_handlers = MagicMock(return_value=[
            MagicMock(get_supported_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=False)),
            MagicMock(get_supported_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=True)),
        ])

        backend = PermissionBackend()
        self.assertFalse(registry.get_handlers.called)
        self.assertFalse(registry.get_handlers()[0].get_supported_permissions.called)
        self.assertFalse(registry.get_handlers()[1].get_supported_permissions.called)
        self.assertFalse(registry.get_handlers()[0].has_perm.called)
        self.assertFalse(registry.get_handlers()[1].has_perm.called)

        self.assertTrue(backend.has_perm(self.user, self.perm1, self.article))

        self.assertTrue(registry.get_handlers.called)
        self.assertTrue(registry.get_handlers()[0].get_supported_permissions.called)
        self.assertTrue(registry.get_handlers()[1].get_supported_permissions.called)
        self.assertTrue(registry.get_handlers()[0].has_perm.called)
        self.assertTrue(registry.get_handlers()[1].has_perm.called)

    @override_settings(
        PERMISSION_CHECK_PERMISSION_PRESENCE=False,
    )
    def test_has_perm_with_nil_permission(self):
        perms = [
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]
        registry.get_handlers = MagicMock(return_value=[
            MagicMock(get_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=False)),
            MagicMock(get_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=True)),
        ])

        backend = PermissionBackend()
        self.assertFalse(backend.has_perm(None, 'permissions.nil_permission'))

    @override_settings(
        PERMISSION_CHECK_PERMISSION_PRESENCE=True,
    )
    def test_has_perm_with_nil_permission_raise(self):
        perms = [
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]
        registry.get_handlers = MagicMock(return_value=[
            MagicMock(get_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=False)),
            MagicMock(get_permissions=MagicMock(return_value=perms),
                      has_perm=MagicMock(return_value=True)),
        ])

        backend = PermissionBackend()
        self.assertRaises(ObjectDoesNotExist,
                backend.has_perm,
                None, 'permissions.nil_permission')

    @override_settings(
        PERMISSION_CHECK_PERMISSION_PRESENCE=False,
        AUTHENTICATION_BACKENDS = (
            'django.contrib.auth.backends.ModelBackend',
            'permission.backends.PermissionBackend',
        ),
    )
    def test_has_perm_with_nil_permission_with_user(self):
        self.assertFalse(self.user.has_perm('permissions.nil_permission'))

    @override_settings(
        PERMISSION_CHECK_PERMISSION_PRESENCE=True,
        AUTHENTICATION_BACKENDS = (
            'django.contrib.auth.backends.ModelBackend',
            'permission.backends.PermissionBackend',
        ),
    )
    def test_has_perm_with_nil_permission_raise_with_user(self):
        self.assertRaises(ObjectDoesNotExist,
                self.user.has_perm,
                'permissions.nil_permission')

    def test_has_module_perms(self):
        perms = [
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]
        app_labels = ['permission']
        registry.get_handlers = MagicMock(return_value=[
            MagicMock(get_supported_app_labels=MagicMock(return_value=app_labels),
                      has_module_perms=MagicMock(return_value=False)),
            MagicMock(get_supported_app_labels=MagicMock(return_value=app_labels),
                      has_module_perms=MagicMock(return_value=True)),
        ])

        backend = PermissionBackend()
        self.assertFalse(registry.get_handlers.called)
        self.assertFalse(registry.get_handlers()[0].get_supported_app_labels.called)
        self.assertFalse(registry.get_handlers()[1].get_supported_app_labels.called)
        self.assertFalse(registry.get_handlers()[0].has_module_perms.called)
        self.assertFalse(registry.get_handlers()[1].has_module_perms.called)

        self.assertTrue(backend.has_module_perms(self.user, 'permission'))

        self.assertTrue(registry.get_handlers.called)
        self.assertTrue(registry.get_handlers()[0].get_supported_app_labels.called)
        self.assertTrue(registry.get_handlers()[1].get_supported_app_labels.called)
        self.assertTrue(registry.get_handlers()[0].has_module_perms.called)
        self.assertTrue(registry.get_handlers()[1].has_module_perms.called)

########NEW FILE########
__FILENAME__ = test_classbase
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import django
from django.test import TestCase
from django.core.exceptions import PermissionDenied
from permission.utils.handlers import registry
from permission.tests.compatibility import skipIf
from permission.tests.compatibility import MagicMock
from permission.tests.test_decorators.utils import create_mock_handler
from permission.tests.test_decorators.utils import create_mock_request
from permission.tests.test_decorators.utils import create_mock_queryset
from permission.tests.test_decorators.utils import create_mock_model
from permission.tests.test_decorators.utils import create_mock_view_func
from permission.tests.test_decorators.utils import create_mock_view_class
from permission.decorators.classbase import permission_required


@skipIf(
    django.VERSION < (1, 3),
    'Classbase generic view is not supported int his version')
class PermissionClassDecoratorsTestCase(TestCase):
    def setUp(self):
        self.handler = create_mock_handler()
        self.request = create_mock_request(self.handler)
        self.model = create_mock_model()
        self.model_instance = self.model()
        self.queryset = create_mock_queryset(self.model_instance)

        self.view_func = create_mock_view_func()
        self.view_class = permission_required(
                'permission.add_article')(
                    create_mock_view_class(self.view_func)
                )
        self.view_class_exc = permission_required(
                'permission.add_article',
                raise_exception=True)(
                    create_mock_view_class(self.view_func)
                )

        # store original registry
        self._original_registry = registry._registry

        # clear registry and register mock handler
        registry._registry = {}
        registry.register(
                self.model,
                self.handler,
            )

        # clear call history
        self.handler.has_perm.return_value = False

    def tearDown(self):
        # restore original reigstry
        registry._registry = self._original_registry


    def test_with_object(self):
        # set object
        self.view_class.object = self.model_instance
        self.view_class_exc.object = self.model_instance

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_get_object(self):
        # set object
        self.view_class.get_object = MagicMock(
                return_value=self.model_instance)
        self.view_class_exc.get_object = MagicMock(
                return_value=self.model_instance)

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_queryset(self):
        # set object
        get_object = lambda x, y: y.get(*x.args, **x.kwargs)
        self.view_class.get_object = get_object
        self.view_class_exc.get_object = get_object
        self.view_class.queryset = self.queryset
        self.view_class_exc.queryset = self.queryset

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_get_queryset(self):
        # set object
        get_object = lambda x, y: y.get(*x.args, **x.kwargs)
        self.view_class.get_object = get_object
        self.view_class_exc.get_object = get_object
        self.view_class.get_queryset = MagicMock(
                return_value=self.queryset)
        self.view_class_exc.get_queryset = MagicMock(
                return_value=self.queryset)

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)


########NEW FILE########
__FILENAME__ = test_functionbase
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from django.core.exceptions import PermissionDenied
from permission.utils.handlers import registry
from permission.tests.test_decorators.utils import create_mock_handler
from permission.tests.test_decorators.utils import create_mock_request
from permission.tests.test_decorators.utils import create_mock_view_func
from permission.tests.test_decorators.utils import create_mock_queryset
from permission.tests.test_decorators.utils import create_mock_model
from permission.decorators.functionbase import permission_required


class PermissionFunctionDecoratorsTestCase(TestCase):
    def setUp(self):
        self.handler = create_mock_handler()
        self.request = create_mock_request(self.handler)
        self.model = create_mock_model()
        self.model_instance = self.model()
        self.queryset = create_mock_queryset(self.model_instance)
        self.view_func = create_mock_view_func()
        self.decorated = permission_required(
                'permission.add_article')(self.view_func)
        self.decorated_exc = permission_required(
                'permission.add_article', raise_exception=True)(self.view_func)

        # store original registry
        self._original_registry = registry._registry

        # clear registry and register mock handler
        registry._registry = {}
        registry.register(
                self.model,
                self.handler,
            )

    def tearDown(self):
        # restore original reigstry
        registry._registry = self._original_registry


    def test_list_detail_object_id(self):
        # has_perm always return False
        self.view_func.called = False
        self.handler.has_perm.return_value = False
        self.decorated(self.request, 
                       queryset=self.queryset,
                       object_id=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied, self.decorated_exc,
                          self.request, queryset=self.queryset,
                          object_id=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.decorated(
                self.request, 
                queryset=self.queryset,
                object_id=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_list_detail_slug(self):
        self.view_func.called = False
        self.handler.has_perm.return_value = False
        # has_perm always return False
        self.decorated(
                self.request, 
                queryset=self.queryset, 
                slug='permission_test_article1',
                slug_field='title')
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)
        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.decorated(
                self.request, 
                queryset=self.queryset, 
                slug='permission_test_article1',
                slug_field='title')
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_date_based_object_id(self):
        self.view_func.called = False
        self.handler.has_perm.return_value = False
        # has_perm always return False
        self.decorated(
                self.request, 
                queryset=self.queryset, 
                year='2000', month='1', day='1',
                date_field='created_at',
                month_format='%m',
                object_id=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)
        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.decorated(
                self.request, 
                queryset=self.queryset,
                year='2000', month='1', day='1',
                date_field='created_at',
                month_format='%m',
                object_id=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_date_based_slug(self):
        self.view_func.called = False
        self.handler.has_perm.return_value = False
        # has_perm always return False
        self.decorated(
                self.request, 
                queryset=self.queryset, 
                year='2000', month='1', day='1',
                date_field='created_at',
                month_format='%m',
                slug='permission_test_article1',
                slug_field='title')
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)
        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.decorated(
                self.request, 
                queryset=self.queryset, 
                year='2000', month='1', day='1',
                date_field='created_at',
                month_format='%m',
                slug='permission_test_article1',
                slug_field='title')
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)


########NEW FILE########
__FILENAME__ = test_methodbase
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import django
from django.test import TestCase
from django.core.exceptions import PermissionDenied
from permission.utils.handlers import registry
from permission.tests.compatibility import skipIf
from permission.tests.compatibility import MagicMock
from permission.tests.test_decorators.utils import create_mock_handler
from permission.tests.test_decorators.utils import create_mock_request
from permission.tests.test_decorators.utils import create_mock_queryset
from permission.tests.test_decorators.utils import create_mock_model
from permission.tests.test_decorators.utils import create_mock_view_func
from permission.tests.test_decorators.utils import create_mock_view_class
from permission.decorators.methodbase import permission_required


@skipIf(
    django.VERSION < (1, 3),
    'Classbase generic view is not supported int his version')
class PermissionClassDecoratorsTestCase(TestCase):
    def setUp(self):
        self.handler = create_mock_handler()
        self.request = create_mock_request(self.handler)
        self.model = create_mock_model()
        self.model_instance = self.model()
        self.queryset = create_mock_queryset(self.model_instance)

        self.view_func = create_mock_view_func()
        self.view_class = create_mock_view_class(
            permission_required(
                'permission.add_article')(self.view_func))
        self.view_class_exc = create_mock_view_class(
            permission_required(
                'permission.add_article',
                raise_exception=True,
            )(self.view_func))

        # store original registry
        self._original_registry = registry._registry

        # clear registry and register mock handler
        registry._registry = {}
        registry.register(
                self.model,
                self.handler,
            )

        # clear call history
        self.handler.has_perm.return_value = False

    def tearDown(self):
        # restore original reigstry
        registry._registry = self._original_registry


    def test_with_object(self):
        # set object
        self.view_class.object = self.model_instance
        self.view_class_exc.object = self.model_instance

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_get_object(self):
        # set object
        self.view_class.get_object = MagicMock(
                return_value=self.model_instance)
        self.view_class_exc.get_object = MagicMock(
                return_value=self.model_instance)

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_queryset(self):
        # set object
        get_object = lambda x, y: y.get(*x.args, **x.kwargs)
        self.view_class.get_object = get_object
        self.view_class_exc.get_object = get_object
        self.view_class.queryset = self.queryset
        self.view_class_exc.queryset = self.queryset

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)

    def test_with_get_queryset(self):
        # set object
        get_object = lambda x, y: y.get(*x.args, **x.kwargs)
        self.view_class.get_object = get_object
        self.view_class_exc.get_object = get_object
        self.view_class.get_queryset = MagicMock(
                return_value=self.queryset)
        self.view_class_exc.get_queryset = MagicMock(
                return_value=self.queryset)

        # has_perm always return False
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertFalse(self.view_func.called)

        self.assertRaises(PermissionDenied,
                          self.view_class_exc.as_view(),
                          self.request, 
                          pk=1)
        self.assertFalse(self.view_func.called)

        # has_perm always return True
        self.handler.has_perm.return_value = True
        self.view_class.as_view()(self.request, pk=1)
        self.request.user.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.handler.has_perm.assert_called_with(
                'permission.add_article',
                obj=self.model_instance,
            )
        self.assertTrue(self.view_func.called)


########NEW FILE########
__FILENAME__ = test_permission_required
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import django
from django.test import TestCase
from django.http import HttpRequest
from django.core.exceptions import PermissionDenied
from permission.utils.handlers import registry
from permission.tests.compatibility import skipIf
from permission.tests.compatibility import MagicMock
from permission.tests.test_decorators.utils import create_mock_handler
from permission.tests.test_decorators.utils import create_mock_request
from permission.tests.test_decorators.utils import create_mock_queryset
from permission.tests.test_decorators.utils import create_mock_model
from permission.tests.test_decorators.utils import create_mock_view_func
from permission.tests.test_decorators.utils import create_mock_view_class

from permission.decorators.functionbase import permission_required as f
from permission.decorators.methodbase import permission_required as m
from permission.decorators.classbase import permission_required as c
from permission.decorators import permission_required as p

p = p('permission.add_article')
c = c('permission.add_article')
m = m('permission.add_article')
f = f('permission.add_article')

model = create_mock_model()
instance = model()

def view_func(request, *args, **kwargs):
    assert isinstance(request, HttpRequest)
try:
    from django.views.generic import View as BaseView
except ImportError:
    # classbase generic view related test will not be run so never mind.
    BaseView = object

class View(BaseView):
    def dispatch(self, request, *args, **kwargs):
        assert isinstance(self, View)
        assert isinstance(request, HttpRequest)
    def get_object(self, queryset=None):
        return instance

class PermissionDecoratorsTestCase(TestCase):

    def setUp(self):
        self.handler = create_mock_handler()
        self.request = create_mock_request(self.handler)
        self.queryset = create_mock_queryset(instance)

        # store original registry
        self._original_registry = registry._registry

        # clear registry and register mock handler
        registry._registry = {}
        registry.register(
                model,
                self.handler,
            )

    def tearDown(self):
        # restore original reigstry
        registry._registry = self._original_registry

    def test_function_views(self):

        if django.VERSION >= (1, 3):
            # class decorator cannot handle
            self.assertRaises(AttributeError, c, view_func)
            # method decorator can handle
            method_view = m(view_func)
            method_view(self.request, self.queryset, object_id=1)

        # function decorator can handle
        function_view = f(view_func)
        function_view(self.request, self.queryset, object_id=1)

    @skipIf(
        django.VERSION < (1, 3),
        'Classbase generic view is not supported int his version')
    def test_method_views(self):
        view_method = View.dispatch

        # class decorator cannot handle
        self.assertRaises(AttributeError, c, View.dispatch)

        # method decorator can handle
        method_view = m(View.dispatch)
        method_view(View(), self.request, pk=1)

        # function decorators cannot handle
        function_view = f(View.dispatch)
        self.assertRaises(AttributeError, function_view,
                          View(), self.request, pk=1)

    @skipIf(
        django.VERSION < (1, 3),
        'Classbase generic view is not supported int his version')
    def test_class_views(self):
        # class decorator can handle
        class_view = c(View)
        class_view.as_view()(self.request, pk=1)

        # method decorator cannot handle
        method_view = m(View)
        self.assertFalse(hasattr(method_view, 'as_view'))

        # function decorator cannot handle
        function_view = f(View)
        self.assertFalse(hasattr(method_view, 'as_view'))

    @skipIf(
        django.VERSION < (1, 3),
        'Classbase generic view is not supported int his version')
    def test_permission_required(self):
        # function
        functional_view = p(view_func)
        functional_view(self.request, queryset=self.queryset, object_id=1)

        # method
        method_view = p(View.dispatch)
        method_view(View(), self.request, pk=1)

        # class
        class_view = p(View)
        class_view.as_view()(self.request, pk=1)

########NEW FILE########
__FILENAME__ = utils
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.db.models import Model
from django.http import HttpRequest
from django.http import HttpResponse
from permission.handlers import PermissionHandler
from permission.tests.compatibility import MagicMock


def create_mock_class(name, base, instance=None):
    instance = instance or MagicMock()
    mock_class = MagicMock(name=name,
                           return_value=instance)
    mock_class.__bases__ = (type, base)
    mock_class.__class__ = type
    return mock_class

def create_mock_handler():
    instance = MagicMock(**{
            'has_perm.return_value': False,
            'get_permissions.return_value': [
                'permission.add_article',
            ],
        })
    handler = create_mock_class('MockPermissionHandler',
                                base=PermissionHandler,
                                instance=instance)
    return handler


def create_mock_request(mock_permission_handler):
    request = MagicMock(spec=HttpRequest)
    request.build_absolute_uri = MagicMock(return_value="/")
    request.META = MagicMock()
    request.user = MagicMock(**{
            'is_active.return_value': True,
            'is_authenticated.return_value': True,
            'has_perm.side_effect': mock_permission_handler.has_perm,
        })
    return request


def create_mock_view_func():
    response = MagicMock(spec=HttpResponse)
    function = MagicMock(return_value=response)
    return function


def create_mock_view_class(view_func):
    from django.views.generic import View
    view_class = type('MockView', (View,), {})
    view_class.dispatch = view_func
    return view_class


def create_mock_model():
    instance = MagicMock()
    model = MagicMock(name='MockModel')
    model.__bases__ = (type,)
    model.__class__ = type
    model._meta = MagicMock(**{
            'abstract': False,
        })
    return model


def create_mock_queryset(obj):
    from django.db.models.query import QuerySet
    from django.core.exceptions import ObjectDoesNotExist
    def get_side_effect(*args, **kwargs):
        if kwargs.get('pk', None) == 1:
            return obj
        if kwargs.get('title', None) == 'permission_test_article1':
            return obj
        if kwargs.get('title__exact', None) == 'permission_test_article1':
            return obj
        raise queryset.model.DoesNotEixst
    queryset = MagicMock(spec=QuerySet, **{
            'get.side_effect': get_side_effect,
        })
    queryset.model = MagicMock()
    queryset.model.DoesNotEixst = ObjectDoesNotExist
    queryset.model._meta = MagicMock(object_name='MockQuerysetModel')
    return queryset

########NEW FILE########
__FILENAME__ = test_handlers
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_article
from permission.tests.models import Article
from permission.tests.compatibility import MagicMock
from permission.tests.compatibility import override_settings
from permission.handlers import PermissionHandler
from permission.handlers import LogicalPermissionHandler
from permission.utils.handlers import PermissionHandlerRegistry

@override_settings(
    PERMISSION_DEFAULT_PERMISSION_HANDLER=PermissionHandler
)
class PermissionPermissionHandlersTestCase(TestCase):
    def setUp(self):
        self.handler = PermissionHandler
        self.user = create_user('john')
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')

    def test_constructor_with_model(self):
        instance = self.handler(Article)
        self.assertEqual(instance.app_label, 'permission')
        self.assertEqual(instance.model, Article)
        # backward reference
        self.assertEqual(Article._permission_handler, instance)

    def test_constructor_with_app_label(self):
        instance = self.handler('permission')
        self.assertEqual(instance.app_label, 'permission')
        self.assertEqual(instance.model, None)

    def test__get_app_perms_with_app_label(self):
        instance = self.handler('permission')
        perms = instance._get_app_perms()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
            'permission.add_bridge',
            'permission.change_bridge',
            'permission.delete_bridge',
        ]))

    def test__get_app_perms_with_model(self):
        instance = self.handler(Article)
        perms = instance._get_app_perms()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
            'permission.add_bridge',
            'permission.change_bridge',
            'permission.delete_bridge',
        ]))

    def test__get_model_perms(self):
        instance = self.handler(Article)
        perms = instance._get_model_perms()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]))

    def test_get_supported_permissions(self):
        instance = self.handler(Article)
        perms = instance.get_supported_permissions()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]))

    def test_get_supported_permissions_with_includes(self):
        instance = self.handler(Article)
        instance.includes = [
                'permission.add_article',
                'permission.change_article',
            ]
        perms = instance.get_supported_permissions()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
        ]))

    def test_get_supported_permissions_with_includes_change(self):
        instance = self.handler(Article)
        instance.includes = [
                'permission.add_article',
                'permission.change_article',
            ]
        instance.get_supported_permissions()
        instance.includes = [
                'permission.change_article',
            ]
        perms = instance.get_supported_permissions()
        self.assertEquals(perms, set([
            'permission.change_article',
        ]))


    def test_get_supported_permissions_with_excludes(self):
        instance = self.handler(Article)
        instance.excludes = [
                'permission.add_article',
            ]
        perms = instance.get_supported_permissions()
        self.assertEquals(perms, set([
            'permission.change_article',
            'permission.delete_article',
        ]))

    def test_get_supported_permissions_with_excludes_change(self):
        instance = self.handler(Article)
        instance.excludes = [
                'permission.add_article',
            ]
        instance.get_supported_permissions()
        instance.excludes = []
        perms = instance.get_supported_permissions()
        self.assertEquals(perms, set([
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ]))

    def test_get_supported_app_labels(self):
        instance = self.handler(Article)
        app_labels = instance.get_supported_app_labels()
        self.assertEquals(app_labels, set([
            'permission',
        ]))

    def test_get_supported_app_labels_with_includes(self):
        instance = self.handler(Article)
        instance.includes = [
                'permission.add_article',
                'permission.change_article',
            ]
        app_labels = instance.get_supported_app_labels()
        self.assertEquals(app_labels, set([
            'permission',
        ]))

    def test_get_supported_app_labels_with_includes_change(self):
        instance = self.handler(Article)
        instance.includes = [
                'permission.add_article',
                'permission.change_article',
            ]
        instance.get_supported_app_labels()
        instance.includes = [
                'permission.change_article',
            ]
        app_labels = instance.get_supported_app_labels()
        self.assertEquals(app_labels, set([
            'permission',
        ]))


    def test_get_supported_app_labels_with_excludes(self):
        instance = self.handler(Article)
        instance.excludes = [
                'permission.add_article',
            ]
        app_labels = instance.get_supported_app_labels()
        self.assertEquals(app_labels, set([
            'permission',
        ]))

    def test_get_supported_app_labels_with_excludes_change(self):
        instance = self.handler(Article)
        instance.excludes = [
                'permission.add_article',
            ]
        instance.get_supported_app_labels()
        instance.excludes = []
        app_labels = instance.get_supported_app_labels()
        self.assertEquals(app_labels, set([
            'permission',
        ]))

    def test_has_perm_add_wihtout_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm1)
        
    def test_has_perm_change_wihtout_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm2)

    def test_has_perm_delete_wihtout_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm3)

    def test_has_perm_add_wiht_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm1, self.article)
        
    def test_has_perm_change_wiht_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm2, self.article)

    def test_has_perm_delete_wiht_obj(self):
        instance = self.handler(Article)
        self.assertRaises(NotImplementedError,
                instance.has_perm,
                self.user, self.perm3, self.article)

    def test_has_module_perms_success(self):
        instance = self.handler(Article)
        user = MagicMock()
        user.has_perm.return_value = True
        self.assertTrue(instance.has_module_perms(user, 'permission'))
        self.assertTrue(user.has_perm.called)

    def test_has_module_perms_fail(self):
        instance = self.handler(Article)
        user = MagicMock()
        user.has_perm.return_value = True
        self.assertFalse(instance.has_module_perms(user, 'unknown'))
        self.assertFalse(user.has_perm.called)

@override_settings(
    PERMISSION_DEFAULT_PERMISSION_HANDLER=LogicalPermissionHandler
)
class PermissionLogicalPermissionHandlerTestCase(TestCase):
    def setUp(self):
        self.handler = LogicalPermissionHandler
        self.user = create_user('john')
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')

        from permission.logics import PermissionLogic
        from permission import add_permission_logic
        self.mock_logic1 = MagicMock(spec=PermissionLogic)
        self.mock_logic1.has_perm = MagicMock(return_value=False)
        self.mock_logic2 = MagicMock(spec=PermissionLogic)
        self.mock_logic2.has_perm = MagicMock(return_value=False)
        add_permission_logic(Article, self.mock_logic1)
        add_permission_logic(Article, self.mock_logic2)

    def test_constructor_with_app_label(self):
        self.assertRaises(AttributeError,
                          self.handler, 'permission')

    def test_has_perm_non_related_permission(self):
        instance = self.handler(Article)
        instance.get_supported_permissions = MagicMock(return_value=[
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ])
        self.assertFalse(instance.has_perm(self.user, 'unknown'))
        self.assertFalse(instance.has_perm(self.user, 'unknown', self.article))

    def test_has_perm_permission_logics_called(self):
        instance = self.handler(Article)
        instance.get_supported_permissions = MagicMock(return_value=[
            'permission.add_article',
            'permission.change_article',
            'permission.delete_article',
        ])
        self.assertFalse(self.mock_logic1.has_perm.called)
        self.assertFalse(self.mock_logic2.has_perm.called)
        self.assertFalse(instance.has_perm(self.user, 'permission.add_article'))
        self.assertTrue(self.mock_logic1.has_perm.called)
        self.assertTrue(self.mock_logic2.has_perm.called)

########NEW FILE########
__FILENAME__ = test_author
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_anonymous
from permission.tests.utils import create_article
from permission.tests.compatibility import MagicMock
from permission.tests.compatibility import override_settings
from permission import add_permission_logic
from permission.logics import AuthorPermissionLogic


@override_settings(
    PERMISSION_DEFAULT_APL_FIELD_NAME='author',
    PERMISSION_DEFAULT_APL_ANY_PERMISSION=True,
    PERMISSION_DEFAULT_APL_CHANGE_PERMISSION=True,
    PERMISSION_DEFAULT_APL_DELETE_PERMISSION=True,
)
class PermissionLogicsAuthorPermissionLogicTestCase(TestCase):
    def setUp(self):
        self.user1 = create_user('john')
        self.user2 = create_user('tony')
        self.anonymous = create_anonymous()
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test', user=self.user2)

    def test_constructor(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, AuthorPermissionLogic))
        self.assertEqual(permission_logic.field_name, 'author')
        self.assertEqual(permission_logic.any_permission, True)
        self.assertEqual(permission_logic.change_permission, True)
        self.assertEqual(permission_logic.delete_permission, True)

    def test_constructor_with_specifing_field_name(self):
        permission_logic = AuthorPermissionLogic(field_name='specified')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, AuthorPermissionLogic))
        self.assertEqual(permission_logic.field_name, 'specified')

    def test_constructor_with_specifing_any_permission(self):
        permission_logic = AuthorPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, AuthorPermissionLogic))
        self.assertEqual(permission_logic.any_permission, False)

    def test_constructor_with_specifing_change_permission(self):
        permission_logic = AuthorPermissionLogic(change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, AuthorPermissionLogic))
        self.assertEqual(permission_logic.change_permission, False)

    def test_constructor_with_specifing_delete_permission(self):
        permission_logic = AuthorPermissionLogic(delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, AuthorPermissionLogic))
        self.assertEqual(permission_logic.delete_permission, False)

    def test_has_perm_add_without_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))

    def test_has_perm_change_without_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))

    def test_has_perm_delete_without_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))

    def test_has_perm_add_without_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm1))

    def test_has_perm_change_without_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm2))

    def test_has_perm_delete_without_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm3))

    def test_has_perm_add_with_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm1, self.article))

    def test_has_perm_change_with_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm2, self.article))

    def test_has_perm_delete_with_obj(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm3, self.article))

    def test_has_perm_add_with_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm1, self.article))

    def test_has_perm_change_with_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm2, self.article))

    def test_has_perm_delete_with_obj_with_anonymous(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm3, self.article))

    def test_has_perm_add_with_obj_author(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_author(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_author(self):
        permission_logic = AuthorPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_author_diff_field_name(self):
        permission_logic = AuthorPermissionLogic(field_name='editor')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_author_diff_field_name(self):
        permission_logic = AuthorPermissionLogic(field_name='editor')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_author_diff_field_name(self):
        permission_logic = AuthorPermissionLogic(field_name='editor')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_author_non_any(self):
        permission_logic = AuthorPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_author_non_any(self):
        permission_logic = AuthorPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any(self):
        permission_logic = AuthorPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_author_non_any_no_change(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_author_non_any_no_change(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any_no_change(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_author_non_any_no_delete(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_author_non_any_no_delete(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any_no_delete(self):
        permission_logic = AuthorPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

########NEW FILE########
__FILENAME__ = test_base
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_article
from permission.tests.compatibility import User
from permission.tests.compatibility import MagicMock
from permission.logics import PermissionLogic


class PermissionLogicsPermissionLogicTestCase(TestCase):
    def setUp(self):
        self.user = create_user('john')
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')

    def test_constructor(self):
        permission_logic = PermissionLogic()
        self.assertTrue(isinstance(permission_logic, PermissionLogic))

    def test_has_perm_add_wihtout_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm1)
        
    def test_has_perm_change_wihtout_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm2)

    def test_has_perm_delete_wihtout_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm3)

    def test_has_perm_add_wiht_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm1, self.article)

    def test_has_perm_change_wiht_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm2, self.article)

    def test_has_perm_delete_wiht_obj(self):
        permission_logic = PermissionLogic()
        self.assertRaises(NotImplementedError,
                permission_logic.has_perm,
                self.user, self.perm3, self.article)

########NEW FILE########
__FILENAME__ = test_collaborators
# coding=utf-8
"""
"""
__collaborators__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_anonymous
from permission.tests.utils import create_article
from permission.tests.compatibility import override_settings
from permission.tests.compatibility import MagicMock
from permission import add_permission_logic
from permission.logics import CollaboratorsPermissionLogic


@override_settings(
    PERMISSION_DEFAULT_CPL_FIELD_NAME='authors',
    PERMISSION_DEFAULT_CPL_ANY_PERMISSION=True,
    PERMISSION_DEFAULT_CPL_CHANGE_PERMISSION=True,
    PERMISSION_DEFAULT_CPL_DELETE_PERMISSION=True,
)
class PermissionLogicsCollaboratorsPermissionLogicTestCase(TestCase):
    def setUp(self):
        self.user1 = create_user('john')
        self.user2 = create_user('tony')
        self.anonymous = create_anonymous()
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')
        self.article.authors.add(self.user2)

    def test_constructor(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, CollaboratorsPermissionLogic))
        self.assertEqual(permission_logic.field_name, 'authors')
        self.assertEqual(permission_logic.any_permission, True)
        self.assertEqual(permission_logic.change_permission, True)
        self.assertEqual(permission_logic.delete_permission, True)

    def test_constructor_with_specifing_field_name(self):
        permission_logic = CollaboratorsPermissionLogic(field_name='specified')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, CollaboratorsPermissionLogic))
        self.assertEqual(permission_logic.field_name, 'specified')

    def test_constructor_with_specifing_any_permission(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, CollaboratorsPermissionLogic))
        self.assertEqual(permission_logic.any_permission, False)

    def test_constructor_with_specifing_change_permission(self):
        permission_logic = CollaboratorsPermissionLogic(change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, CollaboratorsPermissionLogic))
        self.assertEqual(permission_logic.change_permission, False)

    def test_constructor_with_specifing_delete_permission(self):
        permission_logic = CollaboratorsPermissionLogic(delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, CollaboratorsPermissionLogic))
        self.assertEqual(permission_logic.delete_permission, False)

    def test_has_perm_add_without_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))

    def test_has_perm_change_without_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))

    def test_has_perm_delete_without_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))

    def test_has_perm_add_with_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm1, self.article))

    def test_has_perm_change_with_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm2, self.article))

    def test_has_perm_delete_with_obj(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user1, self.perm3, self.article))

    def test_has_perm_add_without_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm1))

    def test_has_perm_change_without_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm2))

    def test_has_perm_delete_without_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm3))

    def test_has_perm_add_with_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm1, self.article))

    def test_has_perm_change_with_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm2, self.article))

    def test_has_perm_delete_with_obj_with_anonymous(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm3, self.article))

    def test_has_perm_add_with_obj_collaborators(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_collaborators(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_collaborators(self):
        permission_logic = CollaboratorsPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_collaborators_diff_field_name(self):
        permission_logic = CollaboratorsPermissionLogic(field_name='editors')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_collaborators_diff_field_name(self):
        permission_logic = CollaboratorsPermissionLogic(field_name='editors')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_collaborators_diff_field_name(self):
        permission_logic = CollaboratorsPermissionLogic(field_name='editors')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_collaborators_non_any(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_collaborators_non_any(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_collaborators_non_any_no_change(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_collaborators_non_any_no_change(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any_no_change(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_with_obj_collaborators_non_any_no_delete(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_collaborators_non_any_no_delete(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_non_any_no_delete(self):
        permission_logic = CollaboratorsPermissionLogic(any_permission=False,
                                                 delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

########NEW FILE########
__FILENAME__ = test_groupin
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_anonymous
from permission.tests.utils import create_group
from permission.tests.utils import create_article
from permission.tests.compatibility import MagicMock
from permission.tests.compatibility import override_settings
from permission.logics import GroupInPermissionLogic
from permission.utils.logics import add_permission_logic


@override_settings(
    PERMISSION_DEFAULT_GIPL_ANY_PERMISSION=True,
    PERMISSION_DEFAULT_GIPL_ADD_PERMISSION=True,
    PERMISSION_DEFAULT_GIPL_CHANGE_PERMISSION=True,
    PERMISSION_DEFAULT_GIPL_DELETE_PERMISSION=True,
)
class PermissionLogicsAuthorPermissionLogicTestCase(TestCase):
    def setUp(self):
        self.user1 = create_user('john')
        self.user2 = create_user('tony')
        self.user3 = create_user('peter')
        self.anonymous = create_anonymous()
        self.group1 = create_group('admin', self.user1)
        self.group2 = create_group('staff', self.user2)
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')

    def test_constructor(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.group_names, ['admin'])
        self.assertEqual(permission_logic.any_permission, True)
        self.assertEqual(permission_logic.add_permission, True)
        self.assertEqual(permission_logic.change_permission, True)
        self.assertEqual(permission_logic.delete_permission, True)

        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.group_names, ['admin', 'staff'])
        self.assertEqual(permission_logic.any_permission, True)
        self.assertEqual(permission_logic.add_permission, True)
        self.assertEqual(permission_logic.change_permission, True)
        self.assertEqual(permission_logic.delete_permission, True)

    def test_constructor_with_specifing_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.any_permission, False)

    def test_constructor_with_specifing_add_permission(self):
        permission_logic = GroupInPermissionLogic('admin', add_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.add_permission, False)

    def test_constructor_with_specifing_change_permission(self):
        permission_logic = GroupInPermissionLogic('admin', change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.change_permission, False)

    def test_constructor_with_specifing_delete_permission(self):
        permission_logic = GroupInPermissionLogic('admin', delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, GroupInPermissionLogic))
        self.assertEqual(permission_logic.delete_permission, False)

    def test_has_perm_add_without_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm1))

    def test_has_perm_change_without_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm2))

    def test_has_perm_delete_without_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm3))

    def test_has_perm_add_with_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm1, self.article))

    def test_has_perm_change_with_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm2, self.article))

    def test_has_perm_delete_with_obj(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm3, self.article))

    def test_has_perm_add_without_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm1))

    def test_has_perm_change_without_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm2))

    def test_has_perm_delete_without_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm3))

    def test_has_perm_add_with_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm1, self.article))

    def test_has_perm_change_with_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm2, self.article))

    def test_has_perm_delete_with_obj_with_anonymous(self):
        permission_logic = GroupInPermissionLogic('admin')
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm3, self.article))

    def test_has_perm_add_without_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))
        self.assertTrue(permission_logic.has_perm(self.user2, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm1))

    def test_has_perm_change_without_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))
        self.assertTrue(permission_logic.has_perm(self.user2, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm2))

    def test_has_perm_delete_without_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))
        self.assertTrue(permission_logic.has_perm(self.user2, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm3))

    def test_has_perm_add_with_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm1, self.article))
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm1, self.article))

    def test_has_perm_change_with_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm2, self.article))
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm2, self.article))

    def test_has_perm_delete_with_obj_with_two_groups(self):
        permission_logic = GroupInPermissionLogic(['admin', 'staff'])
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm3, self.article))
        self.assertTrue(
                permission_logic.has_perm(self.user2, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm3, self.article))

    def test_has_perm_add_without_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm1))

    def test_has_perm_change_without_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm2))

    def test_has_perm_delete_without_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user3, self.perm3))

    def test_has_perm_add_with_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm1, self.article))

    def test_has_perm_change_with_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm2, self.article))

    def test_has_perm_delete_with_obj_without_any_permission(self):
        permission_logic = GroupInPermissionLogic('admin', any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user3, self.perm3, self.article))


########NEW FILE########
__FILENAME__ = test_staff
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_anonymous
from permission.tests.utils import create_article
from permission.tests.compatibility import override_settings
from permission.logics import StaffPermissionLogic
from permission.utils.logics import add_permission_logic


@override_settings(
    PERMISSION_DEFAULT_SPL_ANY_PERMISSION=True,
    PERMISSION_DEFAULT_SPL_ADD_PERMISSION=True,
    PERMISSION_DEFAULT_SPL_CHANGE_PERMISSION=True,
    PERMISSION_DEFAULT_SPL_DELETE_PERMISSION=True,
)
class PermissionLogicsStaffPermissionLogicTestCase(TestCase):
    def setUp(self):
        self.user1 = create_user('john', is_staff=True)
        self.user2 = create_user('tony')
        self.anonymous = create_anonymous()
        self.perm1 = 'permission.add_article'
        self.perm2 = 'permission.change_article'
        self.perm3 = 'permission.delete_article'
        self.article = create_article('test')

    def test_constructor(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)

        self.assertTrue(isinstance(permission_logic, StaffPermissionLogic))
        self.assertEqual(permission_logic.any_permission, True)
        self.assertEqual(permission_logic.add_permission, True)
        self.assertEqual(permission_logic.change_permission, True)
        self.assertEqual(permission_logic.delete_permission, True)

    def test_constructor_with_specifing_any_permission(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, StaffPermissionLogic))
        self.assertEqual(permission_logic.any_permission, False)

    def test_constructor_with_specifing_add_permission(self):
        permission_logic = StaffPermissionLogic(add_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, StaffPermissionLogic))
        self.assertEqual(permission_logic.add_permission, False)

    def test_constructor_with_specifing_change_permission(self):
        permission_logic = StaffPermissionLogic(change_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, StaffPermissionLogic))
        self.assertEqual(permission_logic.change_permission, False)

    def test_constructor_with_specifing_delete_permission(self):
        permission_logic = StaffPermissionLogic(delete_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(isinstance(permission_logic, StaffPermissionLogic))
        self.assertEqual(permission_logic.delete_permission, False)

    def test_has_perm_add_without_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm1))

    def test_has_perm_change_without_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm2))

    def test_has_perm_delete_without_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm3))

    def test_has_perm_add_with_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

    def test_has_perm_add_without_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm1))

    def test_has_perm_change_without_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm2))

    def test_has_perm_delete_without_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(permission_logic.has_perm(self.anonymous, self.perm3))

    def test_has_perm_add_with_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm1, self.article))

    def test_has_perm_change_with_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm2, self.article))

    def test_has_perm_delete_with_obj_with_anonymous(self):
        permission_logic = StaffPermissionLogic()
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertFalse(
            permission_logic.has_perm(self.anonymous, self.perm3, self.article))

    def test_has_perm_add_without_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm1))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm1))

    def test_has_perm_change_without_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm2))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm2))

    def test_has_perm_delete_without_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(permission_logic.has_perm(self.user1, self.perm3))
        self.assertFalse(permission_logic.has_perm(self.user2, self.perm3))

    def test_has_perm_add_with_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm1, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm1, self.article))

    def test_has_perm_change_with_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm2, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm2, self.article))

    def test_has_perm_delete_with_obj_without_any(self):
        permission_logic = StaffPermissionLogic(any_permission=False)
        add_permission_logic(self.article.__class__, permission_logic)
        self.assertTrue(
                permission_logic.has_perm(self.user1, self.perm3, self.article))
        self.assertFalse(
                permission_logic.has_perm(self.user2, self.perm3, self.article))

########NEW FILE########
__FILENAME__ = test_permissionif
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from django.template import Context
from django.template import Template
from django.template import TemplateSyntaxError

from permission.tests.utils import create_user
from permission.tests.utils import create_article
from permission.tests.utils import create_permission
from permission.tests.compatibility import override_settings
from permission.utils.handlers import registry


@override_settings(
    AUTHENTICATION_BACKENDS=(
        'django.contrib.auth.backends.ModelBackend',
        'permission.backends.PermissionBackend',
    ),
)
class PermissionTemplateTagsTestCase(TestCase):
    def setUp(self):
        # store original registry
        self._original_registry = registry._registry
        # clear registry and register mock handler
        registry._registry = {}

    def tearDown(self):
        # restore original reigstry
        registry._registry = self._original_registry

    def test_permissionif_tag(self):
        user = create_user('permission_templatetag_test_user1')
        perm = create_permission('permission_templatetag_test_perm1')

        user.user_permissions.add(perm)

        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1'))

        context = Context({
            'user': user,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.permission_templatetag_test_perm1' %}"
                "Success"
                "{% else %}"
                "Fail"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")
        

    def test_permissionif_tag_elif(self):
        user = create_user('permission_templatetag_test_user1')
        perm = create_permission('permission_templatetag_test_perm1')

        user.user_permissions.add(perm)

        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1'))

        context = Context({
            'user': user,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.unknown_permission' %}"
                "Fail"
                "{% elpermission user has 'permission.unknown_permisson2' %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' %}"
                "Success"
                "{% else %}"
                "Fail"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")
        
    def test_permissionif_tag_else(self):
        user = create_user('permission_templatetag_test_user1')
        perm = create_permission('permission_templatetag_test_perm1')

        user.user_permissions.add(perm)

        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1'))

        context = Context({
            'user': user,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.unknown_permission' %}"
                "Fail"
                "{% else %}"
                "Success"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")
        

    def test_permissionif_tag_with_obj(self):
        from permission.tests.models import Article
        from permission.handlers import PermissionHandler

        user = create_user('permission_templatetag_test_user1')
        art1 = create_article('permission_templatetag_test_article1')
        art2 = create_article('permission_templatetag_test_article2')
        perm = create_permission('permission_templatetag_test_perm1')

        class ArticlePermissionHandler(PermissionHandler):
            def has_perm(self, user_obj, perm, obj=None):
                if perm == 'permission.permission_templatetag_test_perm1':
                    if obj and obj.title == 'permission_templatetag_test_article2':
                        return True
                return False
        registry.register(Article, ArticlePermissionHandler)

        self.assertFalse(user.has_perm('permission.permission_templatetag_test_perm1'))
        self.assertFalse(user.has_perm('permission.permission_templatetag_test_perm1', art1))
        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1', art2))

        context = Context({
            'user': user,
            'art1': art1,
            'art2': art2,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.permission_templatetag_test_perm1' %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' of art1 %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' of art2 %}"
                "Success"
                "{% else %}"
                "Fail"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")

    def test_permissionif_tag_and(self):
        user = create_user('permission_templatetag_test_user1')
        perm1 = create_permission('permission_templatetag_test_perm1')
        perm2 = create_permission('permission_templatetag_test_perm2')

        user.user_permissions.add(perm1, perm2)

        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1'))
        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm2'))

        context = Context({
            'user': user,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.unknown_perm' "
                "and user has 'permission.permission_templatetag_test_perm2' %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' "
                "and user has 'permission.unknown_perm' %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' "
                "and user has 'permission.permission_templatetag_test_perm2' %}"
                "Success"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")

    def test_permissionif_tag_or(self):

        user = create_user('permission_templatetag_test_user1')
        perm1 = create_permission('permission_templatetag_test_perm1')
        perm2 = create_permission('permission_templatetag_test_perm2')

        user.user_permissions.add(perm1)

        self.assertTrue(user.has_perm('permission.permission_templatetag_test_perm1'))
        self.assertFalse(user.has_perm('permission.permission_templatetag_test_perm2'))

        context = Context({
            'user': user,
        })

        out = Template(
                "{% load permissionif %}"
                "{% permission user has 'permission.permission_templatetag_test_perm1' "
                "and user has 'permission.permission_templatetag_test_perm2' %}"
                "Fail"
                "{% elpermission user has 'permission.permission_templatetag_test_perm1' "
                "or user has 'permission.permission_templatetag_test_perm2' %}"
                "Success"
                "{% endpermission %}"
            ).render(context)

        self.assertEqual(out, "Success")

########NEW FILE########
__FILENAME__ = test_field_lookup
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.utils import create_user
from permission.tests.utils import create_bridge
from permission.tests.utils import create_article
from permission.utils.field_lookup import field_lookup


class PermissionUtilsFieldLookupTestCase(TestCase):
    def setUp(self):
        self.author = create_user('permission_test_articles_author')
        self.editor1 = create_user(
            'permission_test_articles_editor1')
        self.editor2 = create_user(
            'permission_test_articles_editor2')
        self.bridge1 = create_bridge()
        self.bridge2 = create_bridge()
        self.bridge3 = create_bridge()
        self.model = create_article('permission_test_article',
                                    self.author, self.bridge1)
        self.model.editors.add(self.editor1)
        self.model.editors.add(self.editor2)
        self.model.multiple_bridge.add(self.bridge2)
        self.model.multiple_bridge.add(self.bridge3)

    def test_field_lookup_author(self):
        field_value = field_lookup(self.model, 'author')
        self.assertEqual(field_value, self.author)

    def test_field_lookup_author_username(self):
        field_value = field_lookup(self.model, 'author__username')
        self.assertEqual(field_value, self.author.username)

    def test_field_lookup_editors(self):
        field_value = field_lookup(self.model, 'editors')
        field_value = (x for x in field_value.iterator())
        expected_value = map(repr, (self.editor1, self.editor2))
        self.assertQuerysetEqual(field_value, expected_value)

    def test_field_lookup_editors_username(self):
        field_value = list(field_lookup(self.model, 'editors__username'))
        expected_value = [x.username for x in
                          (self.editor1, self.editor2)]
        self.assertEqual(field_value, expected_value)

    def test_field_lookup_single_bridge_author(self):
        field_value = field_lookup(self.model, 'single_bridge__author')
        self.assertEqual(field_value, self.bridge1.author)

    def test_field_lookup_single_bridge_author_username(self):
        field_value = field_lookup(self.model,
                                   'single_bridge__author__username')
        self.assertEqual(field_value, self.bridge1.author.username)

    def test_field_lookup_single_bridge_editors(self):
        field_value = field_lookup(self.model, 'single_bridge__editors')
        field_value = (x for x in field_value.iterator())
        expected_value = list(map(repr, self.bridge1.editors.iterator()))
        self.assertQuerysetEqual(field_value, expected_value)

    def test_field_lookup_single_bridge_editors_username(self):
        field_value = list(field_lookup(self.model,
                                        'single_bridge__editors__username'))
        expected_value = [x.username for x in self.bridge1.editors.iterator()]
        self.assertEqual(field_value, expected_value)

    def test_field_lookup_multiple_bridge_author(self):
        field_value = field_lookup(self.model, 'multiple_bridge__author')
        expected_value = list(map(repr, (self.bridge2.author,
                                         self.bridge3.author)))
        self.assertQuerysetEqual(field_value, expected_value)

    def test_field_lookup_multiple_bridge_author_username(self):
        field_value = field_lookup(self.model,
                                   'multiple_bridge__author__username')
        field_value = list(field_value)
        expected_value = [x.username for x in (self.bridge2.author,
                                               self.bridge3.author)]
        self.assertEqual(field_value, expected_value)

    def test_field_lookup_multiple_bridge_editors(self):
        field_value = list(field_lookup(self.model,
                                        'multiple_bridge__editors'))
        field_value = [
            [repr(x) for x in field_value[0].iterator()],
            [repr(x) for x in field_value[1].iterator()],
        ]
        expected_value1 = [repr(x) for x in self.bridge2.editors.iterator()]
        expected_value2 = [repr(x) for x in self.bridge3.editors.iterator()]
        expected_value = [expected_value1, expected_value2]
        self.assertEqual(field_value, expected_value)

    def test_field_lookup_multiple_bridge_editors__name(self):
        field_value = field_lookup(self.model,
                                   'multiple_bridge__editors__username')
        field_value = list(map(list, field_value))
        expected_value1 = [x.username for x in self.bridge2.editors.iterator()]
        expected_value2 = [x.username for x in self.bridge3.editors.iterator()]
        expected_value = [expected_value1, expected_value2]
        self.assertEqual(field_value, expected_value)


########NEW FILE########
__FILENAME__ = test_handlers
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.compatibility import MagicMock
from permission.tests.compatibility import override_settings
from permission.handlers import PermissionHandler
from permission.utils.handlers import PermissionHandlerRegistry

@override_settings(
    PERMISSION_DEFAULT_PERMISSION_HANDLER=PermissionHandler
)
class PermissionUtilsHandlersTestCase(TestCase):
    def setUp(self):
        self.registry = PermissionHandlerRegistry()
        self.model = MagicMock()
        self.model._meta = MagicMock()
        self.model._meta.abstract = False
        self.handler = PermissionHandler

    def test_register(self):
        self.registry.register(self.model, self.handler)
        self.assertTrue(self.model in self.registry._registry)
        self.assertTrue(isinstance(self.registry._registry[self.model],
                                   self.handler))

    def test_register_without_specifing_handler(self):
        self.registry.register(self.model)
        self.assertTrue(self.model in self.registry._registry)
        self.assertTrue(isinstance(self.registry._registry[self.model],
                                   self.handler))

    def test_register_with_abstract_model(self):
        from django.core.exceptions import ImproperlyConfigured
        abstract_model = MagicMock()
        abstract_model._meta = MagicMock()
        abstract_model._meta.abstract = True
        self.assertRaises(ImproperlyConfigured,
                          self.registry.register,
                          abstract_model, self.handler)

    def test_register_duplicate(self):
        self.registry.register(self.model, self.handler)
        self.assertRaises(KeyError,
                          self.registry.register,
                          self.model, self.handler)

    def test_register_permission_handler_instance(self):
        handler_instance = self.handler(self.model)
        self.assertRaises(AttributeError,
                          self.registry.register,
                          self.model, handler_instance)

    def test_register_non_permission_handler(self):
        self.assertRaises(AttributeError,
                          self.registry.register,
                          self.model, self.__class__)

    def test_unregister(self):
        self.registry.register(self.model, self.handler)
        self.registry.unregister(self.model)
        self.assertFalse(self.model in self.registry._registry)

    def test_unregister_absence(self):
        self.assertRaises(KeyError,
                          self.registry.unregister,
                          self.model)

    def test_get_handlers(self):
        results = self.registry.get_handlers()
        self.assertTrue(isinstance(results, tuple))
        self.assertTrue(len(results) == 0)

        self.registry.register(self.model, self.handler)
        results = self.registry.get_handlers()
        self.assertTrue(isinstance(results, tuple))
        self.assertTrue(len(results) == 1)
        self.assertTrue(isinstance(results[0], PermissionHandler))


########NEW FILE########
__FILENAME__ = test_logics
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.test import TestCase
from permission.tests.models import Article
from permission.tests.compatibility import MagicMock
from permission.logics import PermissionLogic
from permission.handlers import LogicalPermissionHandler
from permission.utils.handlers import registry
from permission.utils.logics import add_permission_logic
from permission.utils.logics import remove_permission_logic


class PermissionUtilsLogicsTestCase(TestCase):
    def setUp(self):
        self.mock_logic = MagicMock(spec=PermissionLogic)
        self.mock_logic2 = MagicMock(spec=PermissionLogic)
        # clear registry
        self.registry_backup = registry._registry
        registry._registry = {}
        # clear attributes
        if hasattr(Article, '_permission_logics'):
            delattr(Article, '_permission_logics')
        if hasattr(Article, '_permission_handler'):
            delattr(Article, '_permission_handler')

    def tearDown(self):
        registry._registry = self.registry_backup

    def test_add_permission_logic_private_attributes(self):
        m = self.mock_logic
        # the following private attribute should not be exists in Article model
        self.assertFalse(hasattr(Article, '_permission_logics'))
        self.assertFalse(hasattr(Article, '_permission_handler'))

        # but after add permission logic, they will be appeared
        add_permission_logic(Article, m)
        self.assertTrue(hasattr(Article, '_permission_logics'))
        self.assertTrue(hasattr(Article, '_permission_handler'))
    
    def test_add_permission_logic_registry(self):
        m = self.mock_logic
        # nothing have been registered in registry
        self.assertEqual(registry._registry, {})
        # but after add permission logic, they will be appeared
        add_permission_logic(Article, m)
        self.assertEqual(Article._permission_logics, set([m]))
        self.assertTrue(isinstance(registry._registry[Article],
                                   LogicalPermissionHandler))

    def test_remove_permission_logic_private_attributes(self):
        m = self.mock_logic
        add_permission_logic(Article, m)
        self.assertTrue(hasattr(Article, '_permission_logics'))
        self.assertTrue(hasattr(Article, '_permission_handler'))

        # private attribute should not be disappeared
        remove_permission_logic(Article, m)
        self.assertTrue(hasattr(Article, '_permission_logics'))
        self.assertTrue(hasattr(Article, '_permission_handler'))
    
    def test_remove_permission_logic_registry(self):
        m = self.mock_logic
        add_permission_logic(Article, m)
        self.assertEqual(Article._permission_logics, set([m]))
        self.assertTrue(isinstance(registry._registry[Article],
                                   LogicalPermissionHandler))

        # permission_logics should be changed but registry
        # should not be changed
        remove_permission_logic(Article, m)
        self.assertEqual(Article._permission_logics, set())
        self.assertTrue(isinstance(registry._registry[Article],
                                   LogicalPermissionHandler))

    def test_remove_permission_logic_registry_with_class(self):
        m = self.mock_logic
        m2 = self.mock_logic2
        add_permission_logic(Article, m)
        add_permission_logic(Article, m2)
        self.assertEqual(Article._permission_logics, set([m, m2]))
        self.assertTrue(isinstance(registry._registry[Article],
                                   LogicalPermissionHandler))

        # permission_logics should be changed but registry
        # should not be changed
        remove_permission_logic(Article, PermissionLogic)
        self.assertEqual(Article._permission_logics, set())
        self.assertTrue(isinstance(registry._registry[Article],
                                   LogicalPermissionHandler))

    def test_remove_permission_logic_exception(self):
        m = self.mock_logic
        add_permission_logic(Article, m)
        remove_permission_logic(Article, m)
        # it shuld not raise exception
        remove_permission_logic(Article, m)
        # it should raise exception if fail_silently is False
        self.assertRaises(KeyError,
                remove_permission_logic, Article, m,
                fail_silently=False)

########NEW FILE########
__FILENAME__ = test_permissions
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
# load to run doctest
import permission.utils.permissions

########NEW FILE########
__FILENAME__ = utils
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'


def create_user(username, **kwargs):
    from django.contrib.auth.models import User
    user = User.objects.create_user(
        username=username,
        email="%s@test.com" % username,
        password="password",
    )
    # attribute assignment
    for key, value in kwargs.items():
        user.__dict__[key] = value
    user.save()
    return user


def create_anonymous(**kwargs):
    from django.contrib.auth.models import AnonymousUser
    return AnonymousUser(**kwargs)


def create_group(name, user=None):
    from django.contrib.auth.models import Group
    group = Group.objects.create(name=name)
    if user is not None:
        user.groups.add(group)
        user.save()
    group.save()
    return group


def create_article(title, user=None, bridge=None):
    import datetime
    from permission.tests.models import Article
    user = user or create_user(str(datetime.datetime.now()))
    article = Article.objects.create(
        title=title,
        content=title*20,
        author=user,
        single_bridge=bridge
    )
    article.save()
    return article


def create_bridge(user=None, editors=None):
    import datetime
    from permission.tests.models import Bridge
    user = user or create_user(str(datetime.datetime.now()))
    editors = editors or [create_user(str(datetime.datetime.now())+str(i))
                          for i in range(2)]
    bridge = Bridge.objects.create(author=user)
    for editor in editors:
        bridge.editors.add(editor)
    bridge.save()
    return bridge


def create_permission(name, model=None):
    from django.contrib.auth.models import Permission
    from django.contrib.contenttypes.models import ContentType
    from permission.tests.models import Article
    model = model or Article
    ct = ContentType.objects.get_for_model(model)
    permission = Permission.objects.create(
        name=name, codename=name,
        content_type=ct
    )
    permission.save()
    return permission

########NEW FILE########
__FILENAME__ = autodiscover
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import copy


def autodiscover(module_name=None):
    """
    Autodiscover INSTALLED_APPS perms.py modules and fail silently when not
    present. This forces an import on them to register any permissions bits
    they may want.
    """
    from django.utils.importlib import import_module
    from django.utils.module_loading import module_has_submodule
    from permission.conf import settings

    module_name = module_name or settings.PERMISSION_AUTODISCOVER_MODULE_NAME

    for app in settings.INSTALLED_APPS:
        mod = import_module(app)
        # Attempt to import the app's perms module
        try:
            # discover the permission module
            discover(app, module_name=module_name)
        except:
            # Decide whether to bubble up this error. If the app just doesn't
            # have an perms module, we can just ignore the error attempting
            # to import it, otherwise we want it to bubble up.
            if module_has_submodule(mod, module_name):
                raise


def discover(app, module_name=None):
    """
    Automatically apply the permission logics written in the specified
    module.
    
    Examples
    --------
    Assume if you have a ``perms.py`` in ``your_app`` as::

        from permission.logics import AuthorPermissionLogic
        PERMISSION_LOGICS = (
            ('your_app.your_model', AuthorPermissionLogic),
        )

    Use this method to apply the permission logics enumerated in
    ``PERMISSION_LOGICS`` variable like:

        >>> discover('your_app')
    """
    from django.db.models.loading import get_model
    from django.utils.importlib import import_module
    from permission.conf import settings
    from permission.utils.logics import add_permission_logic

    variable_name = settings.PERMISSION_AUTODISCOVER_VARIABLE_NAME
    module_name = module_name or settings.PERMISSION_AUTODISCOVER_MODULE_NAME

    # import the module
    m = import_module('%s.%s' % (app, module_name))

    # check if the module have PERMISSION_LOGICS variable
    if hasattr(m, variable_name):
        # apply permission logics automatically
        permission_logic_set = getattr(m, variable_name)
        for model, permission_logic in permission_logic_set:
            if isinstance(model, basestring):
                # convert model string to model instance
                model = get_model(*model.split('.', 1))
            add_permission_logic(model, permission_logic)


########NEW FILE########
__FILENAME__ = field_lookup
# coding=utf-8
"""
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.compat import isiterable


def field_lookup(obj, field_path):
    """
    Lookup django model field in similar way of django query lookup

    Args:
        obj (instance): Django Model instance
        field_path (str): '__' separated field path

    Example:
        >>> from django.db import model
        >>> from django.contrib.auth.models import User
        >>> class Article(models.Model):
        >>>     title = models.CharField('title', max_length=200)
        >>>     author = models.ForeignKey(User, null=True,
        >>>             related_name='permission_test_articles_author')
        >>>     editors = models.ManyToManyField(User,
        >>>             related_name='permission_test_articles_editors')
        >>> user = User.objects.create_user('test_user', 'password')
        >>> article = Article.objects.create(title='test_article',
        ...                                  author=user)
        >>> aritcle.editors.add(user)
        >>> assert 'test_article' == field_lookup(article, 'title')
        >>> assert 'test_user' == field_lookup(article, 'user__username')
        >>> assert ['test_user'] == list(field_lookup(article,
        ...                                           'editors__username'))
    """
    if hasattr(obj, 'iterator'):
        return (field_lookup(x, field_path) for x in obj.iterator())
    elif isiterable(obj):
        return (field_lookup(x, field_path) for x in iter(obj))
    # split the path
    field_path = field_path.split("__", 1)
    if len(field_path) == 1:
        return getattr(obj, field_path[0])
    return field_lookup(field_lookup(obj, field_path[0]), field_path[1])

########NEW FILE########
__FILENAME__ = handlers
# coding=utf-8
"""
A utilities of permission handler
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
import inspect
from permission.conf import settings
from django.core.exceptions import ImproperlyConfigured


class PermissionHandlerRegistry(object):
    """
    A registry class of permission handler
    """
    def __init__(self):
        self._registry = {}

    def register(self, model, handler=None):
        """
        Register a permission handler to the model

        Parameters
        ----------
        model : django model class
            A django model class
        handler : permission handler class or None
            A permission handler class

        Raises
        ------
        ImproperlyConfigured
            Raise when the model is abstract model
        KeyError
            Raise when the model is already registered in registry
            The model cannot have more than one handler.
        """
        from permission.handlers import PermissionHandler
        if model._meta.abstract:
            raise ImproperlyConfigured(
                    'The model %s is abstract, so it cannot be registered '
                    'with permission.' % model)
        if model in self._registry:
            raise KeyError("A permission handler class is already "
                            "registered for '%s'" % model)
        if handler is None:
            handler = settings.PERMISSION_DEFAULT_PERMISSION_HANDLER
        if not inspect.isclass(handler):
            raise AttributeError(
                    "`handler` attribute must be a class. "
                    "An instance was specified.")
        if not issubclass(handler, PermissionHandler):
            raise AttributeError(
                    "`handler` attribute must be a subclass of "
                    "`permission.handlers.PermissionHandler`")

        # Instantiate the handler to save in the registry
        instance = handler(model)
        self._registry[model] = instance

    def unregister(self, model):
        """
        Unregister a permission handler from the model

        Parameters
        ----------
        model : django model class
            A django model class
        handler : permission handler class or None
            A permission handler class

        Raises
        ------
        KeyError
            Raise when the model have not registered in registry yet.
        """
        if model not in self._registry:
            raise KeyError("A permission handler class have not been "
                            "registered for '%s' yet" % model)
        # remove from registry
        del self._registry[model]

    def get_handlers(self):
        """
        Get registered handler instances

        Returns
        -------
        tuple
            permission handler tuple
        """
        return tuple(self._registry.values())

"""Permission handler registry instance"""
registry = PermissionHandlerRegistry()

########NEW FILE########
__FILENAME__ = logics
# coding=utf-8
"""
Permission logic utilities
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from permission.logics import PermissionLogic


def add_permission_logic(model, permission_logic):
    """
    Add permission logic to the model

    Parameters
    ----------
    model : django model class
        A django model class which will be treated by the specified permission
        logic
    permission_logic : permission logic instance
        A permission logic instance which will be used to determine permission
        of the model

    Examples
    --------
    >>> from django.db import models
    >>> from permission.logics import PermissionLogic
    >>> class Mock(models.Model):
    ...     name = models.CharField('name', max_length=120)
    >>> add_permission_logic(Mock, PermissionLogic())
    """
    if not isinstance(permission_logic, PermissionLogic):
        raise AttributeError(
        '`permission_logic` must be an instance of PermissionLogic')
    if not hasattr(model, '_permission_logics'):
        model._permission_logics = set()
    if not hasattr(model, '_permission_handler'):
        from permission.utils.handlers import registry
        # register default permission handler
        registry.register(model, handler=None)
    model._permission_logics.add(permission_logic)
    # store target model to the permission_logic instance
    permission_logic.model = model

def remove_permission_logic(model, permission_logic, fail_silently=True):
    """
    Remove permission logic to the model

    Parameters
    ----------
    model : django model class
        A django model class which will be treated by the specified permission
        logic
    permission_logic : permission logic class or instance
        A permission logic class or instance which will be used to determine
        permission of the model
    fail_silently : boolean
        If `True` then do not raise KeyError even the specified permission logic
        have not registered.
    
    Examples
    --------
    >>> from django.db import models
    >>> from permission.logics import PermissionLogic
    >>> class Mock(models.Model):
    ...     name = models.CharField('name', max_length=120)
    >>> logic = PermissionLogic()
    >>> add_permission_logic(Mock, logic)
    >>> remove_permission_logic(Mock, logic)
    """
    if not hasattr(model, '_permission_logics'):
        model._permission_logics = set()
    if not isinstance(permission_logic, PermissionLogic):
        # remove all permission logic of related
        remove_set = set()
        for _permission_logic in model._permission_logics:
            if _permission_logic.__class__ == permission_logic:
                remove_set.add(_permission_logic)
        # difference
        model._permission_logics = model._permission_logics.difference(remove_set)
    else:
        if fail_silently and permission_logic not in model._permission_logics:
            pass
        else:
            model._permission_logics.remove(permission_logic)


########NEW FILE########
__FILENAME__ = permissions
# coding=utf-8
"""
Permission utility module.

In this module, term *perm* indicate the identifier string permission written
in 'app_label.codename' format.
"""
__author__ = 'Alisue <lambdalisue@hashnote.net>'
from django.contrib.auth.models import Permission


def get_perm_codename(perm, fail_silently=True):
    """
    Get permission codename from permission string

    Examples
    --------
    >>> get_perm_codename('app_label.codename_model') == 'codename_model'
    True
    >>> get_perm_codename('app_label.codename') == 'codename'
    True
    >>> get_perm_codename('codename_model') == 'codename_model'
    True
    >>> get_perm_codename('codename') == 'codename'
    True
    >>> get_perm_codename('app_label.app_label.codename_model') == 'app_label.codename_model'
    True
    """
    try:
        perm = perm.split('.', 1)[1]
    except IndexError as e:
        if not fail_silently:
            raise e
    return perm

def permission_to_perm(permission):
    """
    Convert a django permission instance to a identifier string permission
    format in 'app_label.codename' (termed as *perm*).

    Examples
    --------
    >>> permission = Permission.objects.get(
    ...     content_type__app_label='auth',
    ...     codename='add_user',
    ... )
    >>> permission_to_perm(permission) == 'auth.add_user'
    True
    """
    app_label = permission.content_type.app_label
    codename = permission.codename
    return "%s.%s" % (app_label, codename)

def perm_to_permission(perm):
    """
    Convert a identifier string permission format in 'app_label.codename'
    (teremd as *perm*) to a django permission instance.

    Examples
    --------
    >>> permission = perm_to_permission('auth.add_user')
    >>> permission.content_type.app_label == 'auth'
    True
    >>> permission.codename == 'add_user'
    True
    """
    try:
        app_label, codename = perm.split('.', 1)
    except IndexError:
        raise AttributeError(
                "The format of identifier string permission (perm) is wrong. "
                "It should be in 'app_label.codename'."
            )
    else:
        permission = Permission.objects.get(
                content_type__app_label=app_label,
                codename=codename
            )
        return permission

def get_app_perms(model_or_app_label):
    """
    Get *perm* (a string in format of 'app_label.codename') list of the
    specified django application.

    Parameters
    ----------
    model_or_app_label : model class or string
        A model class or app_label string to specify the particular django
        application.

    Returns
    -------
    set
        A set of perms of the specified django application.

    Examples
    --------
    >>> perms1 = get_app_perms('auth')
    >>> perms2 = get_app_perms(Permission)
    >>> perms1 == perms2
    True
    """
    if not isinstance(model_or_app_label, str):
        # assume model_or_app_label is model class
        app_label = model_or_app_label._meta.app_label
    else:
        app_label = model_or_app_label
    qs = Permission.objects.filter(content_type__app_label=app_label)
    perms = ["%s.%s" % (app_label, p.codename) for p in qs.iterator()]
    return set(perms)

def get_model_perms(model):
    """
    Get *perm* (a string in format of 'app_label.codename') list of the
    specified django model.

    Parameters
    ----------
    model : model class
        A model class to specify the particular django model.

    Returns
    -------
    set
        A set of perms of the specified django model.

    Examples
    --------
    >>> sorted(get_model_perms(Permission)) == ['auth.add_permission', 'auth.change_permission', 'auth.delete_permission']
    True
    """
    app_label = model._meta.app_label
    model_name = model._meta.object_name.lower()
    qs = Permission.objects.filter(content_type__app_label=app_label,
                                   content_type__model=model_name)
    perms = ["%s.%s" % (app_label, p.codename) for p in qs.iterator()]
    return set(perms)


########NEW FILE########
__FILENAME__ = settings
# Django settings for tests project.
import os
import sys
BASE_DIR = os.path.dirname(os.path.dirname(__file__))
# add `src`
sys.path.insert(0, os.path.join(BASE_DIR, 'src'))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'database.db',           # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = ''

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'rbs62_^fuahxz!4k1!&yj$h8a=&-h_%do+3jk&%#v=o2%ep=7@'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'tests.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    'permission',
)

########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls import *
except ImportError:
    from django.conf.urls.defaults import *

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Example:
    # (r'^tests/', include('tests.foo.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
