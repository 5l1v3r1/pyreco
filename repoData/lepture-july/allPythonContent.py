__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# July documentation build configuration file, created by
# sphinx-quickstart on Wed Apr 11 20:43:29 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
sys.path.append(os.path.abspath('_themes'))
sys.path.append(os.path.abspath('.'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'July'
copyright = u'2012, <a href="http://lepture.com">Hsiaoming Yang</a>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask'

html_theme_path = ['_themes']

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'index_logo': None
}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index': ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**': ['localtoc.html', 'relations.html', 'sourcelink.html',
           'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Julydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'July.tex', u'July Documentation',
   u'lepture', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'july', u'July Documentation',
     [u'lepture'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'July', u'July Documentation',
   u'lepture', 'July', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from july.web import JulyHandler, run_server
from july.app import JulyApplication

from tornado.options import options
options.sqlalchemy_master = 'sqlite:////tmp/demo.sqlite'

import os.path
ROOT = os.path.abspath(os.path.dirname(__file__))
from post.models import Post
from post.handlers import post_app


class HomeHandler(JulyHandler):
    def get(self):
        posts = Post.query.all()
        self.render('home.html', posts=posts)


handlers = [
    ('/', HomeHandler),
]


settings = dict(
    template_path=os.path.join(ROOT, 'templates'),
    static_path=os.path.join(ROOT, 'static'),
    static_url_prefix='/static/',
)

application = JulyApplication(handlers=handlers, debug=True, **settings)

application.register_app(post_app, url_prefix='/post')

if __name__ == '__main__':
    run_server(application)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

from july.web import JulyHandler
from july.app import JulyApp
from july.database import db
from tornado.web import URLSpec as url
from models import Post


class CreateHandler(JulyHandler):
    def get(self):
        self.render('inner/create.html')

    def post(self):
        title = self.get_argument('title', '')
        content = self.get_argument('content', '')
        post = Post(title=title, content=content)

        db.master.add(post)
        db.master.commit()
        self.redirect(self.reverse_url('post', post.id))


class PostHandler(JulyHandler):
    def get(self, id):
        post = Post.query.filter_by(id=id).first()
        if not post:
            self.send_error(404)
            return
        self.render('post.html', post=post)


handlers = [
    ('/create', CreateHandler),
    url('/(\d+)', PostHandler, name='post'),
]

post_app = JulyApp('post', __name__, handlers=handlers,
                   template_folder="templates")


if __name__ == '__main__':
    from tornado.options import options
    options.sqlalchemy_master = 'sqlite:////tmp/demo.sqlite'

    from july import run_server, JulyApplication
    run_server(JulyApplication(handlers=handlers, debug=True,
                               template_path="templates"))

########NEW FILE########
__FILENAME__ = models
from july.database import db
from sqlalchemy import Column, Integer, String, Text


class Post(db.Model):
    id = Column(Integer, primary_key=True)
    title = Column(String(200))
    content = Column(Text)

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from tornado.options import define
define('smtp_user', 'root@gmail.com')
define('smtp_password', 'password')
define('smtp_host', 'smtp.gmail.com')
define('smtp_ssl', True)

from july.web import JulyHandler, run_server
from july.app import JulyApplication
from july.ext import webservice

import os.path
ROOT = os.path.abspath(os.path.dirname(__file__))


class HomeHandler(JulyHandler):
    def get(self):
        self.render('home.html')

    def post(self):
        user = self.get_argument('user')
        subject = self.get_argument('subject')
        body = self.get_argument('body')
        dct = dict(user=user, subject=subject, body=body, subtype='html')
        self.redirect('/')
        webservice.post('mail/outbox', dct)


handlers = [
    ('/', HomeHandler),
]


settings = dict(
    template_path=os.path.join(ROOT, 'templates'),
)

application = JulyApplication(handlers=handlers, debug=True, **settings)

application.register_app('july.ext.mail.handlers.app', url_prefix='/mail')

if __name__ == '__main__':
    run_server(application)

########NEW FILE########
__FILENAME__ = app
import sae
from tornado.options import options
from sqlalchemy.pool import NullPool
options.sqlalchemy_master = 'mysql://%s:%s@%s:%s/%s?charset=utf8' %\
        (sae.const.MYSQL_USER, sae.const.MYSQL_PASS, sae.const.MYSQL_HOST,
         sae.const.MYSQL_PORT, sae.const.MYSQL_DB)

options.sqlalchemy_kwargs = {
    'poolclass': NullPool,
}

from july import JulyHandler, JulyApplication
from july.database import db


class HomeHandler(JulyHandler):
    def get(self):
        db._ping_db()
        self.write('hello world')


handlers = [
    ('/', HomeHandler),
]

app = JulyApplication(handlers, wsgi=True, debug=True)

########NEW FILE########
__FILENAME__ = app
import os.path
from tornado.web import Application, URLSpec
from july.template import JulyLoader
from tornado.wsgi import WSGIApplication
from .util import get_root_path, import_object, ObjectDict


__all__ = ["JulyApp", "JulyApplication"]


class JulyApp(object):
    """July App

    July App is like BluePrint in Flask, it splits a tornado project into
    several apps.

    The basic usage, consider your app as::

        myapp/
            __init__.py
            handlers.py

    And in your ``myapp.handlers`` define::

        class MyHandler(RequestHandler):
            def get(self):
                self.write('hello july app')

        handlers = [
            ('/', MyHandler),
        ]

        app = JulyApp('a readable name', __name__, handlers=handlers)

        # you may also add a handler by ``app.add_handler``
        # app.add_handler(('/', MyHandler))

    .. admonition::

        You should always define an app in the same module level of your
        handlers. And it is suggested that you use ``__name__`` all the time.

    :param name: human readable name for the app

    :param template_folder:

        the folder name for templates in your app, for example, in your app::

            myapp/
                __init__.py
                handlers.py
                templates/

        so that template_folder is ``templates``. And you can define your app
        with app template supports::

            app = JulyApp('name', __name__, template_folder='templates')

    """
    _first_register = True

    def __init__(self, name, import_name, template_folder=None,
                 handlers=None, ui_modules=None, **settings):
        self.name = name
        self.import_name = import_name
        self.handlers = handlers
        self.ui_modules = ui_modules
        self.settings = settings
        self.root_path = get_root_path(self.import_name)

        if template_folder:
            self.template_path = os.path.join(self.root_path, template_folder)
        else:
            self.template_path = None

    def add_handler(self, handler):
        if self.handlers is None:
            self.handlers = [handler]
        else:
            self.handlers.append(handler)

    def first_register(self):
        if not self._first_register:
            return False
        print('Register: %s' % self.name)
        self._first_register = False
        return True


class JulyApplication(object):
    """July Application

    This is a wrapper for ``tornado.web.Application``.
    You define a JulyApplication::

        application = JulyApplication()

    and when this application is called, it creates a tornado.web.Application,
    which means, JulyApplication()() equals to tornado.web.Application().

    so, you can do more with application before it is called.

    The most useful task for JulyApplication is registering a July App.
    Define you July App, and register it to your application::

        simple_app = JulyApp('name', __name__, handlers=handlers)
        application.register_app(simple_app)

    And start your application::

        application().listen(8888)
        ioloop.IOLoop.instance().start()
    """

    def __init__(self, handlers=None, default_host="", transforms=None,
                 wsgi=False, **settings):
        self.handlers = handlers
        self.default_host = default_host
        self.transforms = transforms
        self.wsgi = wsgi

        if 'template_path' in settings:
            template_path = settings.pop('template_path')
            if isinstance(template_path, str):
                settings['template_path'] = [template_path]
        else:
            settings['template_path'] = []

        self.settings = settings

    def add_handler(self, handler):
        if not self.handlers:
            self.handlers = []

        self.handlers.append(handler)

    def add_ui_moudle(self, ui_module):
        if 'ui_modules' not in self.settings:
            self.settings['ui_modules'] = {}

        if ui_module:
            self.settings['ui_modules'].update(ui_module)

    def register_filter(self, name, func):
        """Register filter function for template::

            application = JulyApplication()
            application.register_filter('name', function)

        And it will be available in template::

            {{ name(var) }}

        The registered function can be accessed in all JulyHanlder
        subclass.
        """
        if '__july_filters__' not in self.settings:
            self.settings['__july_filters__'] = {}

        self.settings['__july_filters__'].update({name: func})

    def register_context(self, key, value):
        """Register global variables for template::

            application = JulyApplication()
            application.register_global('key', value)

        And it will be available in template::

            {{ g.key }}

        """
        if '__july_global__' not in self.settings:
            self.settings['__july_global__'] = ObjectDict()

        self.settings['__july_global__'][key] = value

    def register_app(self, app, url_prefix=''):
        if isinstance(app, str):
            app = import_object(app)
        if app.first_register():
            self._register_app_handlers(app, url_prefix)
            self._register_app_ui_modules(app)

            if app.template_path:
                self.settings['template_path'].append(app.template_path)

    def _register_app_handlers(self, app, url_prefix):
        if not app.handlers:
            return
        for spec in app.handlers:
            if isinstance(spec, tuple):
                assert len(spec) in (2, 3)
                pattern = spec[0]
                handler = spec[1]

                if isinstance(handler, str):
                    handler = import_object(handler)

                if len(spec) == 3:
                    kwargs = spec[2]
                else:
                    kwargs = {}

                pattern = '%s%s' % (url_prefix, pattern)
                spec = URLSpec(pattern, handler, kwargs)
            elif isinstance(spec, URLSpec):
                pattern = '%s%s' % (url_prefix, spec.regex.pattern)
                spec = URLSpec(pattern, spec.handler_class,
                               spec.kwargs, spec.name)

            self.add_handler(spec)

    def _register_app_ui_modules(self, app):
        self.add_ui_moudle(app.ui_modules)

    def __call__(self):
        kwargs = {}
        if 'autoescape' in self.settings:
            kwargs['autoescape'] = self.settings['autoescape']
        path = self.settings.pop('template_path')
        loader = JulyLoader(path, **kwargs)
        self.settings['template_loader'] = loader
        if self.wsgi:
            app = WSGIApplication(self.handlers, self.default_host,
                                  **self.settings)
            return app
        app = Application(
            self.handlers, self.default_host, self.transforms,
            self.wsgi, **self.settings
        )
        return app

########NEW FILE########
__FILENAME__ = cache
import functools
from time import time as sys_time
from tornado.options import options

__all__ = ['cache', 'cache_decorator']


class _Cache(object):
    """python-memcahe compatable instance cache
    """
    def __init__(self):
        self._app_cache = {}

    @classmethod
    def create_instance(cls):
        if hasattr(cls, '_instance'):
            return cls._instance

        if hasattr(options, 'memcache_clients') and options.memcache_clients:
            try:
                import pylibmc
                cache = pylibmc.Client(options.memcache_clients,
                                       **options.memcache_kwargs)
                cls._instance = cache
                return cls._instance
            except ImportError:
                import memcache
                cache = memcache.Client(options.memcache_clients,
                                        **options.memcache_kwargs)
                cls._instance = cache
                return cls._instance
            except ImportError:
                cls._instance = cls()
                return cls._instance
        else:
            cls._instance = cls()
            return cls._instance

    def flush_all(self):
        self._app_cache = {}

    def set(self, key, val, time=0):
        key = str(key)
        if time < 0:
            time = 0

        self._app_cache[key] = (val, sys_time(), time)
        return val

    def get(self, key):
        key = str(key)
        _store = self._app_cache.get(key, None)
        if not _store:
            return None
        value, begin, seconds = _store
        if seconds and sys_time() > begin + seconds:
            del self._app_cache[key]
            return None
        return value

    def add(self, key, val, time=0):
        key = str(key)
        if key not in self._app_cache:
            return self.set(key, val, time)
        return self.get(key)

    def delete(self, key, time=0):
        key = str(key)
        if key in self._app_cache:
            del self._app_cache[key]
        return None

    def incr(self, key, delta=1):
        key = str(key)
        _store = self._app_cache.get(key, None)
        if not _store:
            return None

        value, begin, seconds = _store
        if seconds and sys_time() > begin + seconds:
            del self._app_cache[key]
            return None

        if isinstance(value, basestring):
            value = int(value)

        value = value + delta
        self.set(key, value)
        return value

    def decr(self, key, delta=1):
        return self.incr(key, -delta)

    def set_multi(self, mapping, time=0, key_prefix=''):
        for key, value in mapping.items():
            self.set('%s%s' % (key_prefix, key), value, time)

        return True

    def get_multi(self, keys, key_prefix=''):
        dct = {}
        for key in keys:
            value = self.get('%s%s' % (key_prefix, key))
            if value:
                dct[key] = value

        return dct

    def delete_multi(self, keys, time=0, key_prefix=''):
        for key in keys:
            self.delete('%s%s' % (key_prefix, key))

        return None


cache = _Cache.create_instance()


class cache_decorator(object):
    """Cache decorator, an easy way to manage cache.
    The result key will be like: prefix:arg1-arg2
    """
    def __init__(self, prefix, time=0):
        self.prefix = prefix
        self.time = time

    def __call__(self, method):
        @functools.wraps(method)
        def wrapper(cls, *args):
            if args:
                key = self.prefix + ':' + '-'.join(map(str, args))
            else:
                key = self.prefix
            value = cache.get(key)
            if value is None:
                value = method(cls, *args)
                cache.set(key, value, self.time)
            return value
        return wrapper


def get_cache_list(model, id_list, key_prefix, time=600):
    if not id_list:
        return {}
    id_list = set(id_list)
    data = cache.get_multi(id_list, key_prefix=key_prefix)
    missing = id_list - set(data)
    if missing:
        dct = {}
        for item in model.query.filter_by(id__in=missing).all():
            dct[item.id] = item

        cache.set_multi(dct, time=time, key_prefix=key_prefix)
        data.update(dct)

    return data

########NEW FILE########
__FILENAME__ = database
#!/usr/bin/env python
#coding=utf-8
"""
    sqlalchemy.py
    ~~~~~~~~~~~~~
    :copyright: (c) 2010 by Armin Ronacher. From flask-sqlalchemy.
    :license: BSD, see LICENSE for more details.
"""
#: convert from flask-sqlalchemy by laoqiu
#: modified and extended by lepture

from __future__ import with_statement, absolute_import
import re
import uuid
import functools
from functools import partial
import sqlalchemy
from sqlalchemy import orm
from sqlalchemy.orm.session import Session
from sqlalchemy.orm import attributes, object_mapper
from sqlalchemy.orm import joinedload, joinedload_all
from sqlalchemy.orm.properties import RelationshipProperty
from sqlalchemy.orm.interfaces import MapperExtension, SessionExtension, \
     EXT_CONTINUE
from sqlalchemy.orm.exc import UnmappedClassError
from sqlalchemy.orm.util import _entity_descriptor
from sqlalchemy.sql import operators, extract
from sqlalchemy.ext.declarative import declarative_base, DeclarativeMeta
from sqlalchemy.util import to_list
from .signals import Namespace
from .util import set_default_option

import tornado.web
from tornado.options import options

_camelcase_re = re.compile(r'([A-Z]+)(?=[a-z0-9])')
_signals = Namespace()

models_committed = _signals.signal('models-committed')
before_models_committed = _signals.signal('before-models-committed')


def _make_table(db):
    def _make_table(*args, **kwargs):
        if len(args) > 1 and isinstance(args[1], db.Column):
            args = (args[0], db.metadata) + args[1:]
        return sqlalchemy.Table(*args, **kwargs)
    return _make_table


def _set_default_query_class(d):
    if 'query_class' not in d:
        d['query_class'] = BaseQuery


def _wrap_with_default_query_class(fn):
    @functools.wraps(fn)
    def newfn(*args, **kwargs):
        _set_default_query_class(kwargs)
        if "backref" in kwargs:
            backref = kwargs['backref']
            if isinstance(backref, basestring):
                backref = (backref, {})
            _set_default_query_class(backref[1])
        return fn(*args, **kwargs)
    return newfn


def _defines_primary_key(d):
    """Figures out if the given dictonary defines a primary key column."""
    return any(v.primary_key for k, v in d.iteritems()
               if isinstance(v, sqlalchemy.Column))


def _include_sqlalchemy(obj):
    for module in sqlalchemy, sqlalchemy.orm:
        for key in module.__all__:
            if not hasattr(obj, key):
                setattr(obj, key, getattr(module, key))
    # Note: obj.Table does not attempt to be a SQLAlchemy Table class.
    obj.Table = _make_table(obj)
    obj.mapper = signalling_mapper
    obj.relationship = _wrap_with_default_query_class(obj.relationship)
    obj.relation = _wrap_with_default_query_class(obj.relation)
    obj.dynamic_loader = _wrap_with_default_query_class(obj.dynamic_loader)


class _BoundDeclarativeMeta(DeclarativeMeta):

    def __new__(cls, name, bases, d):
        tablename = d.get('__tablename__')

        # generate a table name automatically if it's missing and the
        # class dictionary declares a primary key.  We cannot always
        # attach a primary key to support model inheritance that does
        # not use joins.  We also don't want a table name if a whole
        # table is defined
        if not tablename and not d.get('__table__') and \
           _defines_primary_key(d):
            def _join(match):
                word = match.group()
                if len(word) > 1:
                    return ('_%s_%s' % (word[:-1], word[-1])).lower()
                return '_' + word.lower()
            d['__tablename__'] = _camelcase_re.sub(_join, name).lstrip('_')

        return DeclarativeMeta.__new__(cls, name, bases, d)

    def __init__(self, name, bases, d):
        bind_key = d.pop('__bind_key__', None)
        DeclarativeMeta.__init__(self, name, bases, d)
        if bind_key is not None:
            self.__table__.info['bind_key'] = bind_key


class _SignallingSession(Session):

    def __init__(self, db, autocommit=False, autoflush=False, **options):
        self.sender = db.sender
        self._model_changes = {}
        Session.__init__(self, autocommit=autocommit, autoflush=autoflush,
                         expire_on_commit=False,
                         extension=db.session_extensions,
                         bind=db.engine, **options)


class _QueryProperty(object):

    def __init__(self, sa):
        self.sa = sa

    def __get__(self, obj, type):
        try:
            mapper = orm.class_mapper(type)
            if mapper:
                return type.query_class(mapper, session=self.sa.session())
        except UnmappedClassError:
            return None


class _SignalTrackingMapperExtension(MapperExtension):

    def after_delete(self, mapper, connection, instance):
        return self._record(mapper, instance, 'delete')

    def after_insert(self, mapper, connection, instance):
        return self._record(mapper, instance, 'insert')

    def after_update(self, mapper, connection, instance):
        return self._record(mapper, instance, 'update')

    def _record(self, mapper, model, operation):
        pk = tuple(mapper.primary_key_from_instance(model))
        #orm.object_session(model)._model_changes[pk] = (model, operation)
        changes = {}

        for prop in object_mapper(model).iterate_properties:
            if not isinstance(prop, RelationshipProperty):
                try:
                    history = attributes.get_history(model, prop.key)
                except:
                    continue

                added, unchanged, deleted = history

                newvalue = added[0] if added else None

                if operation == 'delete':
                    oldvalue = unchanged[0] if unchanged else None
                else:
                    oldvalue = deleted[0] if deleted else None

                if newvalue or oldvalue:
                    changes[prop.key] = (oldvalue, newvalue)

        orm.object_session(model)._model_changes[pk] = \
                (model.__tablename__, pk[0], changes, operation)
        return EXT_CONTINUE


class _SignallingSessionExtension(SessionExtension):

    def before_commit(self, session):
        d = session._model_changes
        if d:
            before_models_committed.send(session.sender, changes=d.values())
        return EXT_CONTINUE

    def after_commit(self, session):
        d = session._model_changes
        if d:
            models_committed.send(session.sender, changes=d.values())
            d.clear()
        return EXT_CONTINUE

    def after_rollback(self, session):
        session._model_changes.clear()
        return EXT_CONTINUE


def signalling_mapper(*args, **kwargs):
    """Replacement for mapper that injects some extra extensions"""
    extensions = to_list(kwargs.pop('extension', None), [])
    extensions.append(_SignalTrackingMapperExtension())
    kwargs['extension'] = extensions
    return sqlalchemy.orm.mapper(*args, **kwargs)


class _ModelTableNameDescriptor(object):

    def __get__(self, obj, type):
        tablename = type.__dict__.get('__tablename__')
        if not tablename:
            def _join(match):
                word = match.group()
                if len(word) > 1:
                    return ('_%s_%s' % (word[:-1], word[-1])).lower()
                return '_' + word.lower()
            tablename = _camelcase_re.sub(_join, type.__name__).lstrip('_')
            setattr(type, '__tablename__', tablename)
        return tablename


class Pagination(object):
    def __init__(self, query, page, per_page, total=None):
        self.query = query
        self.per_page = per_page
        self.page = page

        self.items = query.offset((self.page - 1) * self.per_page)\
                .limit(self.per_page)

        if total:
            self.total = total
        else:
            self.total = query.count()

        if self.page > 1 and self.page > self.pages:
            raise tornado.web.HTTPError(404)

    def iter_pages(self, edge=4):
        if self.page <= edge:
            return range(1, min(self.pages, 2 * edge + 1) + 1)
        if self.page + edge > self.pages:
            return range(max(self.pages - 2 * edge, 1), self.pages + 1)
        return range(self.page - edge, min(self.pages, self.page + edge) + 1)

    @property
    def pages(self):
        return (self.total - 1) / self.per_page + 1

    @property
    def has_prev(self):
        return self.page > 1

    @property
    def prev_num(self):
        return self.page - 1

    @property
    def has_next(self):
        return self.page < self.pages

    @property
    def next_num(self):
        return self.page + 1


class BaseQuery(orm.Query):
    """The default query object used for models.  This can be subclassed and
    replaced for individual models by setting the :attr:`~Model.query_class`
    attribute.  This is a subclass of a standard SQLAlchemy
    :class:`~sqlalchemy.orm.query.Query` class and has all the methods of a
    standard query as well.
    """
    def get_or_404(self, ident):
        """Like :meth:`get` but aborts with 404 if not found instead of
        returning `None`.
        """
        rv = self.get(ident)
        if rv is None:
            raise tornado.web.HTTPError(404)
        return rv

    def first_or_404(self):
        """Like :meth:`first` but aborts with 404 if not found instead of
        returning `None`.
        """
        rv = self.first()
        if rv is None:
            raise tornado.web.HTTPError(404)
        return rv

    def paginate(self, page, per_page=20, error_out=True, total=None):
        """Returns `per_page` items from page `page`.  By default it will
        abort with 404 if no items were found and the page was larger than
        1.  This behavor can be disabled by setting `error_out` to `False`.

        Returns an :class:`Pagination` object.
        """
        try:
            page = int(page)
        except:
            raise tornado.web.HTTPError(404)
        if error_out and page < 1:
            raise tornado.web.HTTPError(404)
        return Pagination(self, page, per_page, total)

    #: https://github.com/mitsuhiko/sqlalchemy-django-query
    """Can be mixed into any Query class of SQLAlchemy and extends it to
    implements more Django like behavior:

    -   `filter_by` supports implicit joining and subitem accessing with
        double underscores.
    -   `exclude_by` works like `filter_by` just that every expression is
        automatically negated.
    -   `order_by` supports ordering by field name with an optional `-`
        in front.
    """
    _underscore_operators = {
        'gt': operators.gt,
        'lt': operators.lt,
        'gte': operators.ge,
        'lte': operators.le,
        'contains': operators.contains_op,
        'in': operators.in_op,
        'exact': operators.eq,
        'iexact': operators.ilike_op,
        'startswith': operators.startswith_op,
        'istartswith': lambda c, x: c.ilike(x.replace('%', '%%') + '%'),
        'iendswith': lambda c, x: c.ilike('%' + x.replace('%', '%%')),
        'endswith': operators.endswith_op,
        'isnull': lambda c, x: x and c != None or c == None,
        'range': operators.between_op,
        'year': lambda c, x: extract('year', c) == x,
        'month': lambda c, x: extract('month', c) == x,
        'day': lambda c, x: extract('day', c) == x
    }

    def get_first(self, **kwargs):
        return self.filter_by(**kwargs).first()

    def filter_by(self, **kwargs):
        return self._filter_or_exclude(False, kwargs)

    def exclude_by(self, **kwargs):
        return self._filter_or_exclude(True, kwargs)

    def select_related(self, *columns, **options):
        depth = options.pop('depth', None)
        if options:
            raise TypeError('Unexpected argument %r' % iter(options).next())
        if depth not in (None, 1):
            raise TypeError('Depth can only be 1 or None currently')
        need_all = depth is None
        columns = list(columns)
        for idx, column in enumerate(columns):
            column = column.replace('__', '.')
            if '.' in column:
                need_all = True
            columns[idx] = column
        func = (need_all and joinedload_all or joinedload)
        return self.options(func(*columns))

    def order_by(self, *args):
        args = list(args)
        joins_needed = []
        for idx, arg in enumerate(args):
            q = self
            if not isinstance(arg, basestring):
                continue
            if arg[0] in '+-':
                desc = arg[0] == '-'
                arg = arg[1:]
            else:
                desc = False
            q = self
            column = None
            for token in arg.split('__'):
                column = _entity_descriptor(q._joinpoint_zero(), token)
                if column.impl.uses_objects:
                    q = q.join(column)
                    joins_needed.append(column)
                    column = None
            if column is None:
                raise ValueError('Tried to order by table, column expected')
            if desc:
                column = column.desc()
            args[idx] = column

        q = super(BaseQuery, self).order_by(*args)
        for join in joins_needed:
            q = q.join(join)
        return q

    def _filter_or_exclude(self, negate, kwargs):
        q = self
        negate_if = lambda expr: expr if not negate else ~expr
        column = None

        for arg, value in kwargs.iteritems():
            for token in arg.split('__'):
                if column is None:
                    column = _entity_descriptor(q._joinpoint_zero(), token)
                    if column.impl.uses_objects:
                        q = q.join(column)
                        column = None
                elif token in self._underscore_operators:
                    op = self._underscore_operators[token]
                    q = q.filter(negate_if(op(column, *to_list(value))))
                    column = None
                else:
                    raise ValueError('No idea what to do with %r' % token)
            if column is not None:
                q = q.filter(negate_if(column == value))
                column = None
            q = q.reset_joinpoint()
        return q


class Model(object):
    """Baseclass for custom user models."""

    #: the query class used.  The :attr:`query` attribute is an instance
    #: of this class.  By default a :class:`BaseQuery` is used.
    query_class = BaseQuery

    #: an instance of :attr:`query_class`.  Can be used to query the
    #: database for instances of this model.
    query = None

    PER_PAGE = None


class SQLAlchemy(object):
    """
    Example:
        db = SQLAlchemy("sqlite:///test.db", True)

        class User(db.Model):
            username = db.Column(db.String(16), unique=True, index=True)
            password = db.Column(db.String(30), nullable=False)
            email = db.Column(db.String(30), nullable=False)

        >>> user1 = User.query.filter(User.username=='name').first()
        >>> user2 = User.query.get(1)
        >>> user_list = User.query.filter_by(username='name').limit(10)

    """
    def __init__(self, engine_url, echo=False, pool_recycle=3600,
                 pool_size=10, session_extensions=None, session_options=None):
        # create signals sender
        self.sender = str(uuid.uuid4())

        self.session_extensions = to_list(session_extensions, []) + \
                                  [_SignallingSessionExtension()]
        self.session = self.create_scoped_session(session_options)
        self.Model = self.make_declarative_base()

        if engine_url.startswith('sqlite'):
            self.engine = sqlalchemy.create_engine(engine_url, echo=echo)
        else:
            self.engine = sqlalchemy.create_engine(
                engine_url, echo=echo, pool_recycle=pool_recycle,
                pool_size=pool_size
            )

        _include_sqlalchemy(self)

    def create_scoped_session(self, options=None):
        """Helper factory method that creates a scoped session."""
        if options is None:
            options = {}
        return orm.scoped_session(partial(_SignallingSession, self, **options))

    def make_declarative_base(self):
        """Creates the declarative base."""
        base = declarative_base(cls=Model, name='Model',
                                mapper=signalling_mapper,
                                metaclass=_BoundDeclarativeMeta)
        base.query = _QueryProperty(self)
        return base

    def create_all(self):
        """Creates all tables."""
        self.Model.metadata.create_all(bind=self.engine)

    def drop_all(self):
        """Drops all tables."""
        self.Model.metadata.drop_all(bind=self.engine)

    @classmethod
    def create_instance(cls, engine_url, kwargs=None):
        """create single instance SQLAlchemy"""
        if hasattr(cls, '_instance'):
            return cls._instance
        if kwargs is None:
            kwargs = {}
        cls._instance = cls(engine_url, **kwargs)
        return cls._instance


#: sqlalchemy default configuration
set_default_option('sqlalchemy_engine', type=str, help='databse engine')
set_default_option('sqlalchemy_kwargs', default={},
                   type=dict, help='sqlalchemy extra params')

db = SQLAlchemy.create_instance(
    #: string like
    #: mysql://user:pass@host:port/db?charset=utf8
    options.sqlalchemy_engine,

    #: dictionary like
    #: {'pool_recycle': 3600}
    options.sqlalchemy_kwargs,
)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

import logging
from tornado.web import URLSpec as url
from july.web import JulyHandler
from july.app import JulyApp
from .lib import send_mail


class MailHandler(JulyHandler):
    def check_xsrf_cookie(self):
        #: disable xsrf cookie check
        return

    def post(self):
        #: provide as a service
        #: only the server has access to this service
        if self.request.remote_ip != '127.0.0.1':
            self.send_error(403)
            return
        user = self.get_argument('user', None)
        subject = self.get_argument('subject', None)
        body = self.get_argument('body', '')
        subtype = self.get_argument('subtype', 'plain')
        if not (user and subject):
            self.send_error(403)
            logging.warn('Send mail without user or subject')
            return
        try:
            send_mail(user, subject, body, subtype=subtype)
        except Exception as e:
            logging.error(e)

        self.write('')


app = JulyApp(
    'mail', __name__,
    handlers=[url('/outbox', MailHandler, name='mail-outbox')]
)

########NEW FILE########
__FILENAME__ = lib
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from datetime import datetime, timedelta
import logging
import smtplib
from email.mime.text import MIMEText
from email.utils import formatdate, parseaddr
from tornado.escape import utf8
from tornado.options import options

from july.util import set_default_option
set_default_option('smtp_user', 'root@localhost')
set_default_option('smtp_password', '')
set_default_option('smtp_host', 'localhost')
set_default_option('smtp_ssl', False)


_session = None


__all__ = ['send_mail', 'Message']


def send_mail(user, subject, body, **kwargs):
    """send mail

    If you want to send html email, set subtype to html::

        send_mail(user, subject, body, subtype='html')
    """
    message = Message(user, subject, body, **kwargs)
    msg = message.as_msg()
    msg['From'] = options.smtp_user

    global _session
    if _session is None:
        _session = _SMTPSession()

    _session.send_mail(message.email, msg.as_string())


class Message(object):
    def __init__(self, user, subject, body, **kwargs):
        self.user = user  # lepture <lepture@me.com>
        self.name, self.email = parseaddr(user)
        self.subject = subject
        self.body = body
        self.subtype = kwargs.pop('subtype', 'plain')
        self.date = kwargs.pop('date', None)

    def as_msg(self):
        msg = MIMEText(utf8(self.body), self.subtype)
        msg.set_charset('utf-8')
        msg['To'] = utf8(self.email)
        msg['Subject'] = utf8(self.subject)
        if self.date:
            msg['Date'] = self.date
        else:
            msg['Date'] = formatdate()
        return msg


class _SMTPSession(object):
    def __init__(self, duration=30):
        self.host = options.smtp_host
        self.user = parseaddr(options.smtp_user)[1]
        self.password = options.smtp_password
        self.duration = duration
        self.ssl = options.smtp_ssl

        self.renew()

    def send_mail(self, to, message):
        if self.timeout:
            self.renew()

        try:
            self.session.sendmail(self.user, to, message)
        except Exception as e:
            err = "Send email from %s to %s failed!\n Exception: %s!" \
                % (self.user, to, e)
            logging.error(err)

    @property
    def timeout(self):
        if datetime.utcnow() < self.deadline:
            return False
        else:
            return True

    def renew(self):
        try:
            self.session.quit()
        except Exception:
            pass

        if self.ssl:
            self.session = smtplib.SMTP_SSL(self.host)
        else:
            self.session = smtplib.SMTP(self.host)
        if self.user and self.password:
            self.session.login(self.user, self.password)

        self.deadline = datetime.utcnow() + \
                timedelta(seconds=self.duration * 60)

########NEW FILE########
__FILENAME__ = webservice
import urllib
from tornado import escape
from tornado import httpclient
from tornado.options import options


__all__ = ['post']


def post(path, args, callback=None):
    url = 'http://127.0.0.1:%s/%s' % (options.port, path)
    http = httpclient.AsyncHTTPClient()
    post_args = {}
    for key in args:
        #: ensure encodings
        post_args[key] = escape.utf8(args[key])

    http.fetch(url, method="POST", body=urllib.urlencode(post_args),
               callback=callback)

########NEW FILE########
__FILENAME__ = signals

#!/usr/bin/env python
#coding=utf-8
"""
    signals.py
    ~~~~~~~~~~~~~

    Implements signals based on blinker if available, otherwise
    falls silently back to a noop

    :copyright: (c) 2011 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""
try:
    from blinker import Namespace
except ImportError:
    class Namespace(object):
        def signal(self, name, doc=None):
            return _FakeSignal(name, doc)

    class _FakeSignal(object):
        """If blinker is unavailable, create a fake class with the same
        interface that allows sending of signals but will fail with an
        error on anything else.  Instead of doing anything on send, it
        will just ignore the arguments and do nothing instead.
        """

        def __init__(self, name, doc=None):
            self.name = name
            self.__doc__ = doc

        def _fail(self, *args, **kwargs):
            raise RuntimeError('signalling support is unavailable '
                               'because the blinker library is '
                               'not installed.')

        send = lambda *args, **kwargs: None

        connect = disconnect = has_receivers_for = receivers_for = \
            temporarily_connected_to = connected_to = _fail

        del _fail

########NEW FILE########
__FILENAME__ = template
import os.path
from tornado.template import BaseLoader, Template


class JulyLoader(BaseLoader):
    """July Template Loader
    """

    def __init__(self, roots, **kwargs):
        super(JulyLoader, self).__init__(**kwargs)
        if isinstance(roots, str):
            self.roots = [roots]
        else:
            assert isinstance(roots, (list, tuple)), "roots should be lists"
            self.roots = roots

    def resolve_path(self, name, parent_path=None):
        return name

    def _create_template(self, name):
        path = self._detect_template_path(name)
        f = open(path, 'r')
        template = Template(f.read(), name=name, loader=self)
        f.close()
        return template

    def _detect_template_path(self, name):
        """
        First load template from project templates directory.

        If template not in project templates directory, load from app templates
        directories.

        Directory example of an app::

            app/
                templates/
                    appname/   <---- better with an appname
                        layout.html
                        screen.html

        """
        for root in self.roots:
            path = os.path.join(root, name)
            if os.path.exists(path):
                return path

        return name

########NEW FILE########
__FILENAME__ = util
from __future__ import with_statement
import os
import sys
import pkgutil
from tornado.options import define, options


def set_default_option(name, default=None, **kwargs):
    if name in options:
        return
    define(name, default, **kwargs)


def reset_option(name, default=None, **kwargs):
    if name in options:
        options[name].set(default)
        return
    define(name, default, **kwargs)


def parse_config_file(path):
    config = {}
    execfile(path, config, config)
    for name in config:
        if name in options:
            options[name].set(config[name])
        else:
            define(name, config[name])


class ObjectDict(dict):
    def __getattr__(self, key):
        if key in self:
            return self[key]
        return None

    def __setattr__(self, key, value):
        self[key] = value


def import_object(name, arg=None):
    """tornado.util.import_object replacement for july project

    .. attention:: you should not use this function
    """

    if '.' not in name:
        return __import__(name)
    parts = name.split('.')
    try:
        obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)
    except ImportError:
        obj = None
    return getattr(obj, parts[-1], arg)


def get_root_path(import_name):
    """Returns the path to a package or cwd if that cannot be found.  This
    returns the path of a package or the folder that contains a module.

    Not to be confused with the package path returned by :func:`find_package`.
    """
    loader = pkgutil.get_loader(import_name)
    if loader is None or import_name == '__main__':
        # import name is not found, or interactive/main module
        return os.getcwd()
    # For .egg, zipimporter does not have get_filename until Python 2.7.
    if hasattr(loader, 'get_filename'):
        filepath = loader.get_filename(import_name)
    else:
        # Fall back to imports.
        __import__(import_name)
        filepath = sys.modules[import_name].__file__
    # filepath is import_name.py for a module, or __init__.py for a package.
    return os.path.dirname(os.path.abspath(filepath))

########NEW FILE########
__FILENAME__ = web
from tornado import web, escape
from .cache import cache

#: initialize options
from .util import set_default_option

__all__ = ["JulyHandler", "ApiHandler", "init_options", "run_server"]


class JulyHandler(web.RequestHandler):
    """July Handler

    Subclass JulyHandler to make an app, it provides a way to organize a July
    App, and will support more features in the future.
    """

    def flash_message(self, msg=None, category=None):
        """flash_message provide an easy way to communicate with users.

        create message in your handler::

            class HomeHandler(JulyHandler):
                def get(self):
                    self.flash_message('thanks')
                    self.render('home.html')

        and get messages in ``home.html``::

            <ul>
                {% for category, message in flash_message() $}
                <li>{{category}}: {{message}}</li>
                {% end %}
            </ul>
        """
        def get_category_message(messages, category):
            for cat, msg in messages:
                if cat == category:
                    yield (cat, msg)

        #: use xsrf token or not ?
        key = '%s_flash_message' % self.xsrf_token
        if msg is None:
            messages = cache.get(key)
            if messages is None:
                return []
            if category is not None:
                return get_category_message(messages, category)

            #: clear flash message
            cache.delete(key)
            return messages
        message = (category, msg)
        messages = cache.get(key)
        if isinstance(messages, list):
            messages.append(message)
        else:
            messages = [message]
        cache.set(key, messages, 600)
        return message

    def reverse_redirect(self, name, *args):
        self.redirect(self.reverse_url(name, *args))

    def render_string(self, template_name, **kwargs):
        #: add application filters
        if '__july_filters__' in self.settings:
            kwargs.update(self.settings['__july_filters__'])

        #: add application global variables
        if '__july_global__' in self.settings:
            assert "g" not in kwargs, "g is a reserved keyword."
            kwargs["g"] = self.settings['__july_global__']

        #: flash message support
        kwargs['flash_message'] = self.flash_message
        return super(JulyHandler, self).render_string(template_name, **kwargs)


class ApiHandler(web.RequestHandler):
    xsrf_protect = False

    def check_xsrf_cookie(self):
        if not self.xsrf_protect:
            return
        return super(ApiHandler, self).check_xsrf_cookie()

    def is_ajax(self):
        return "XMLHttpRequest" == self.request.headers.get("X-Requested-With")

    def write(self, chunk):
        self.set_header("Content-Type", "application/json; charset=UTF-8")
        if isinstance(chunk, (dict, list)):
            chunk = escape.json_encode(chunk)
            callback = self.get_argument('callback', None)
            if callback:
                chunk = "%s(%s)" % (callback, escape.to_unicode(chunk))
                self.set_header("Content-Type",
                                "application/javascript; charset=UTF-8")
        super(ApiHandler, self).write(chunk)


def init_options():
    import os.path
    from tornado.options import options, parse_command_line
    from .util import parse_config_file
    parse_command_line()

    if options.settings:
        path = os.path.abspath(options.settings)
        print("Load settings from %s" % path)
        parse_config_file(path)

    return


def run_server(app):
    import logging
    import tornado.locale
    from tornado import httpserver, ioloop
    from tornado.options import options

    server = httpserver.HTTPServer(app(), xheaders=True)
    server.listen(int(options.port), options.address)

    if options.locale_path:
        tornado.locale.load_translations(options.locale_path)
        tornado.locale.set_default_locale(options.default_locale)

    logging.info('Start server at %s:%s' % (options.address, options.port))
    ioloop.IOLoop.instance().start()


set_default_option('address', default='127.0.0.1', type=str,
       help='run server at this address')
set_default_option('port', default=8000, type=int,
                   help='run server on this port')
set_default_option('settings', default='', type=str,
                   help='setting file path')

#: application settings
set_default_option('locale_path', type=str,
                   help='absolute path of locale directory')
set_default_option('default_locale', default='en_US', type=str)

########NEW FILE########
__FILENAME__ = test_app
from july.app import JulyApp, JulyApplication
from nose.tools import raises


class TestJulyApp(object):
    def setUp(self):
        self.app = JulyApp('test', __name__)

    def test_first_register(self):
        assert self.app.first_register() == True
        assert self.app.first_register() == False

    def test_add_handler(self):
        self.app.add_handler(('/', 'TestJulyApp'))
        assert self.app.handlers == [('/', 'TestJulyApp')]


class TestJulyApplication(object):
    def setUp(self):
        self.application = JulyApplication()

    def test_register_context(self):
        self.application.register_context('key', 'value')
        assert self.application.settings['__july_global__']['key'] == 'value'

    def test_register_filter(self):
        self.application.register_filter('min', min)

    @raises(ImportError)
    def test_register_app1(self):
        app = JulyApp('app1', __name__)
        app.add_handler(('', 'joking'))
        self.application.register_app(app, '/app')

    def test_register_app2(self):
        #: app without handlers
        app = JulyApp('app2', 'app2')
        assert '__july_apps__' not in self.application.settings
        self.application.register_app(app, '/app')

########NEW FILE########
__FILENAME__ = test_cache
from july.cache import cache


def test_cache():
    cache.set('key1', 'value1')
    assert cache.get('key1') == 'value1'

    cache.set('key1', 'value2')
    assert cache.get('key1') == 'value2'

    assert cache.add('key1', 'value1') == 'value2'
    assert cache.add('key2', 'value1') == 'value1'

    cache.delete('key1')
    assert cache.get('key1') is None

    mapping = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
    cache.set_multi(mapping)
    assert cache.get_multi(['key1', 'key2', 'key3']) == mapping

    cache.delete_multi(['key1', 'key2', 'key3'])

    cache.set_multi(mapping)
    value = cache.get_multi(['1', '2', '3'], key_prefix='key')
    assert value == {'1': 'value1', '2': 'value2', '3': 'value3'}

    cache.flush_all()
    assert cache.get('key1') is None

########NEW FILE########
