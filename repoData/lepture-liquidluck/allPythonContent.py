__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Felix Felicis documentation build configuration file, created by
# sphinx-quickstart on Mon May 14 19:16:09 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os
import time

sys.path.append(os.path.abspath('_themes'))
sys.path.append(os.path.abspath('.'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Felix Felicis'
copyright = (u'2012-%s, <a href="http://lepture.com">Hsiaoming Yang</a>'
             % time.strftime('%Y'))

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.8'
# The full version, including alpha/beta/rc tags.
release = '1.8'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index': ['brand.html', 'sidebarintro.html', 'searchbox.html'],
    '**': ['localtoc.html', 'relations.html', 'sidebarintro.html',
           'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'FelixFelicisdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'FelixFelicis.tex', u'Felix Felicis Documentation',
   u'Hsiaoming Yang', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'felixfelicis', u'Felix Felicis Documentation',
     [u'Hsiaoming Yang'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'FelixFelicis', u'Felix Felicis Documentation',
   u'Hsiaoming Yang', 'FelixFelicis', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = cli
#!/usr/bin/env python
import os
import sys
import liquidluck
from liquidluck.tools import theme
from liquidluck.tools import webhook
from liquidluck.tools import server
from liquidluck import generator
from liquidluck.options import enable_pretty_logging
from liquidluck.options import g, settings
from docopt import docopt

documentation = {}
documentation['help'] = """Felix Felicis %(version)s

Usage:
    liquidluck init [-s <file>|--settings=<file>]
    liquidluck build [-s <file>|--settings=<file>] %(build)s
    liquidluck server [-d|--debug] %(server)s
    liquidluck search [<theme>] [-c|--clean] [-f|--force]
    liquidluck install <theme> [-g|--global]
    liquidluck webhook (start|stop|restart) %(webhook)s
    liquidluck -h | --help
    liquidluck --version

Options:
    -h --help               show this screen.
    -v --verbose            show more log.
    -q --quiet              show less log.
    -d --debug              set theme.debug=True for server
    -s --settings=<file>    specify a setting file.
    -o --output=<output>    overwrite output directory.
    -p --port=<port>        specify the server port.
    -f --force              search a theme without cache
    -c --clean              show theme name only.
    -g --global             install theme to global theme folder.
    --version               show version.
""" % {
    'version': liquidluck.__version__,
    'build': '[-o <output>|--output=<output>] [-q|--quiet] [-v|--verbose]',
    'webhook': '[-s <file>|--settings=<file>] [-p <port>|--port=<port>]',
    'server': '[-s <file>|--settings=<file>] [-p <port>|--port=<port>]',
}

documentation['init'] = """
Usage:
    liquidluck init [-s <file>|--settings=<file>]

Options:
    -h --help               show this screen.
    -s --settings=<file>    specify a setting file.
"""

documentation['build'] = """
Usage:
    liquidluck build [-s <file>|--settings=<file>] %(build)s

Options:
    -h --help               show this screen.
    -v --verbose            show more log.
    -q --quiet              show less log.
    -s --settings=<file>    specify a setting file.
    -o --output=<output>    overwrite output directory.
""" % {
    'build': '[-o <output>|--output=<output>] [-q|--quiet] [-v|--verbose]',
}

documentation['server'] = """
Usage:
    liquidluck server [-d|--debug] %(server)s

Options:
    -h --help               show this screen.
    -d --debug              set theme.debug=True for server
    -s --settings=<file>    specify a setting file.
    -p --port=<port>        specify the server port.
""" % {
    'server': '[-s <file>|--settings=<file>] [-p <port>|--port=<port>]',
}

documentation['search'] = """
Usage:
    liquidluck search [<theme>] [-c|--clean] [-f|--force]

Options:
    -h --help               show this screen.
    -c --clean              show theme name only.
    -f --force              search a theme without cache
"""

documentation['install'] = """
Usage:
    liquidluck install <theme> [-g|--global]

Options:
    -g --global             install theme to global theme folder.
    -h --help               show this screen.
"""

documentation['webhook'] = """
Usage:
    liquidluck webhook (start|stop|restart) %s

Options:
    -h --help               show this screen.
    -s --settings=<file>    specify a setting file.
    -p --port=<port>        specify the server port.
""" % '[-s <file>|--settings=<file>] [-p <port>|--port=<port>]'


def main():
    command = 'help'
    if len(sys.argv) > 1:
        command = sys.argv[1]

    if command in documentation:
        args = docopt(documentation[command])
    else:
        args = docopt(
            documentation['help'],
            version='Felix Felicis v%s' % liquidluck.__version__
        )

    arg_settings = args.get('--settings') or generator.find_settings()
    arg_verbose = args.get('--verbose')
    arg_quiet = args.get('--quiet')
    if arg_verbose:
        enable_pretty_logging('debug')
    elif arg_quiet:
        enable_pretty_logging('warn')
    else:
        enable_pretty_logging('info')
    arg_port = args.get('--port') or '8000'

    arg_theme = args.get('<theme>') or None
    arg_clean = args.get('--clean')
    arg_force = args.get('--force')
    arg_global = args.get('--global')

    if command == 'init':
        generator.create_settings(arg_settings)
    elif command == 'build':
        arg_output = args.get('--output')
        if not arg_settings:
            answer = raw_input(
                "Can't find your setting files, "
                "would you like to create one?(Y/n) "
            )
            if answer.lower() == 'n':
                return
            generator.create_settings(arg_settings)
        else:
            generator.build(arg_settings, arg_output)
    elif command == 'server':
        arg_debug = args.get('--debug')
        if arg_debug:
            print('debug mode on')
        if arg_settings and os.path.exists(arg_settings):
            generator.load_settings(arg_settings)
        else:
            print('setting file not found')
            server.config(arg_port)
            server.start_server(arg_debug)

        permalink = settings.config.get('permalink')
        if permalink.endswith('.html'):
            _type = 'html'
        elif permalink.endswith('/'):
            _type = 'slash'
        else:
            _type = 'clean'
        server.config(arg_port, g.output_directory, _type)
        server.start_server(arg_debug)
    elif command == 'search':
        theme.search(arg_theme, arg_clean, arg_force)
    elif command == 'install':
        theme.install(arg_theme, arg_global)
    elif command == 'webhook':
        action = (args['start'] and 'start') or (args['stop'] and 'stop') \
                or (args['restart'] and 'restart')
        webhook.webhook(arg_port, action, arg_settings)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = filters
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import hashlib
import logging
import datetime
from jinja2 import contextfunction, contextfilter
from liquidluck.options import g, settings
from liquidluck.utils import to_unicode, to_bytes, get_relative_base


def xmldatetime(value):
    """ this is a jinja filter """
    if not isinstance(value, datetime.datetime):
        return value
    value = value.strftime('%Y-%m-%dT%H:%M:%S')
    return '%s%s' % (value, settings.config['timezone'])


def feed_updated(feed):
    latest = None
    for post in feed.posts:
        if not latest:
            latest = post.updated
        elif post.updated > latest:
            latest = post.updated

    return xmldatetime(latest)


@contextfunction
def content_url(ctx, base, *args):
    writer = ctx.get('writer')

    def fix_index(url):
        if url.endswith('/index.html'):
            return url[:-10]
        return url

    args = list(args)
    base = to_unicode(base)
    use_relative_url = settings.config.get('relative_url', False)
    if base.startswith('http://') or base.startswith('https://'):
        prefix = '%s/' % base.rstrip('/')

    elif use_relative_url and writer:
        prefix = '%s/' % get_relative_base(writer['filepath'])
        args.insert(0, base)
    else:
        prefix = '/'
        args.insert(0, base)

    args = map(lambda o: to_unicode(o).strip('/'), args)
    url = '/'.join(args).replace('//', '/').replace(' ', '-')
    url = prefix + url.lstrip('/')
    url = to_unicode(fix_index(url.lower()))

    if url.endswith('/'):
        return url

    permalink = settings.config['permalink']
    if permalink.endswith('.html'):
        if url.endswith('.html'):
            return url
        if url.endswith('.xml'):
            return url
        return '%s.html' % url

    if permalink.endswith('/'):
        if url.endswith('.html'):
            url = fix_index(url)
            url = url.rstrip('.html')
        if url.endswith('.xml'):
            url = url.rstrip('.xml')

        return '%s/' % url

    if url.endswith('.html'):
        url = fix_index(url)
        return url.rstrip('.html')
    if url.endswith('.xml'):
        return url.rstrip('.xml')
    return url


@contextfilter
def tag_url(ctx, tag, prepend_site=False):
    prefix = settings.site.get('prefix', '')
    url = settings.site.get('url')
    writers = settings.writer['active']
    tagcloud = any((True for o in writers if 'TagCloud' in o))

    if prepend_site and tagcloud:
        return '%s#%s' % (content_url(ctx, url, prefix, 'tag', 'index.html'),
                          tag)
    if tagcloud:
        return '%s#%s' % (content_url(ctx, prefix, 'tag', 'index.html'), tag)

    if prepend_site:
        return content_url(ctx, url, prefix, 'tag', tag, 'index.html')

    return content_url(ctx, prefix, 'tag', tag, 'index.html')


@contextfilter
def year_url(ctx, post):
    prefix = settings.site.get('prefix', '')
    return content_url(ctx, prefix, post.date.year, 'index.html')


_Post = {}


@contextfilter
def wiki_link(ctx, content):
    global _Post
    from liquidluck.writers.base import permalink

    def link_post(m):
        if not _Post:
            for item in g.public_posts:
                _Post[item.title] = item

        text = m.group(1)
        if '|' in text:
            title, content = text.split('|')
        else:
            title = content = text
        if title in _Post:
            item = _Post[title]
            link = permalink(ctx, item)
            return '<a href="%s">%s</a>' % (link, content)
        return '<span class="no-reference">%s</span>' % text

    pattern = re.compile(r'\[\[([^\]]+)\]\]', re.M)
    content = pattern.sub(link_post, content)
    return content


_Cache = {}


def static_url(base):
    global _Cache

    def get_hsh(path):
        if path in _Cache:
            return _Cache[path]
        abspath = os.path.join(base, path)
        if not os.path.exists(abspath):
            logging.warn('%s does not exists' % path)
            return ''

        with open(abspath) as f:
            content = f.read()
            hsh = hashlib.md5(to_bytes(content)).hexdigest()
            _Cache[path] = hsh
            return hsh

    @contextfunction
    def create_url(ctx, path):
        hsh = get_hsh(path)[:5]
        prefix = settings.config.get('static_prefix', '/static/').rstrip('/')
        use_relative_url = settings.config.get('relative_url', False)

        if use_relative_url and not prefix.startswith('http'):
            base = get_relative_base(ctx.get('writer')['filepath'])
            prefix = '%s/%s' % (base, prefix.lstrip('/'))

        url = '%s/%s?v=%s' % (prefix, path, hsh)
        return url

    return create_url

########NEW FILE########
__FILENAME__ = generator
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
PROJDIR = os.path.abspath(os.path.dirname(__file__))
import sys
import logging
from liquidluck.options import g, settings
from liquidluck.utils import import_object, walk_dir, parse_settings
from liquidluck.writers.base import load_jinja, find_theme


def create_settings(filepath):
    if not filepath:
        filetype = raw_input(
            'Select a config format ([yaml], python, json):  '
        ) or 'yaml'

        if filetype not in ['yaml', 'python', 'json']:
            print('format not supported')
            return

        suffix = {'yaml': '.yml', 'python': '.py', 'json': '.json'}
        filepath = 'settings%s' % suffix[filetype]

    content = raw_input('posts folder (content): ') or 'content'
    output = raw_input('output folder (deploy): ') or 'deploy'
    if filepath.endswith('.py'):
        f = open(os.path.join(PROJDIR, 'tools', '_settings.py'))
        text = f.read()
        f.close()
    elif filepath.endswith('.json'):
        f = open(os.path.join(PROJDIR, 'tools', '_settings.json'))
        text = f.read()
        f.close()
    else:
        f = open(os.path.join(PROJDIR, 'tools', '_settings.yml'))
        text = f.read()
        f.close()

    text = text.replace('content', content)
    if content and not content.startswith('.') and not os.path.exists(content):
        os.makedirs(content)
    text = text.replace('deploy', output)
    f = open(filepath, 'w')
    f.write(text)
    f.close()


def find_settings(directory=None):
    if not directory:
        directory = os.getcwd()

    config = [
        'settings.yml', 'settings.json', 'settings.yaml', 'settings.py',
    ]

    for f in config:
        path = os.path.join(directory, f)
        if os.path.exists(path):
            return path

    return None


def load_settings(path=None):
    if not path:
        path = find_settings()

    def update_settings(arg):
        if isinstance(arg, dict):
            config = arg
        else:
            config = parse_settings(arg)
        for key in config:
            setting = config[key]
            if isinstance(setting, dict) and key in settings:
                settings[key].update(setting)
            else:
                settings[key] = setting

    #: preload default config
    update_settings(os.path.join(PROJDIR, 'tools', '_settings.py'))
    update_settings(path)

    g.output_directory = os.path.abspath(settings.config.get('output'))
    g.static_directory = os.path.abspath(settings.config.get('static'))
    logging.info('Load Settings Finished')

    sys.path.insert(0, find_theme())
    cwd = os.path.split(os.path.abspath(path))[0]
    sys.path.insert(0, cwd)


def load_posts(path):
    g.source_directory = path
    readers = []
    for name in settings.reader.get('active'):
        try:
            readers.append(import_object(name))
        except ImportError as e:
            logging.error("Can't enable %s" % name)
            if g.interrupt:
                raise e

    def detect_reader(filepath):
        for Reader in readers:
            reader = Reader(filepath)
            if reader.support():
                return reader.run()
        return None

    output = os.path.abspath(g.output_directory)
    source = os.path.abspath(g.source_directory)
    if output == source:
        logging.warn('Output and source are the same directory')

    for filepath in walk_dir(path):
        if source in output and source != output and \
           output in os.path.abspath(filepath):
            continue
        post = detect_reader(filepath)
        if not post:
            g.pure_files.append(filepath)
        elif not post.date:
            g.pure_pages.append(post)
        elif post.public:
            g.public_posts.append(post)
        else:
            g.secure_posts.append(post)

    g.public_posts = sorted(g.public_posts, key=lambda o: o.date, reverse=True)
    g.secure_posts = sorted(g.secure_posts, key=lambda o: o.date, reverse=True)

    logging.info('Load Posts Finished')


def write_posts():
    writers = []
    for name in settings.writer.get('active'):
        writers.append(import_object(name)())

    load_jinja()

    for writer in writers:
        writer.run()


def build(config='settings.py', output=None):
    load_settings(config)
    if output:
        output = os.path.abspath(output)
        g.static_directory = g.static_directory.replace(
            g.output_directory, output, 1)
        g.output_directory = output
    load_posts(settings.config.get('source'))
    write_posts()

########NEW FILE########
__FILENAME__ = options
from __future__ import absolute_import, division, with_statement

import os
import logging
import logging.handlers
import sys
import time


# For pretty log messages, if available
try:
    import curses
except ImportError:
    curses = None


class _Options(dict):
    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            return None

    def __setattr__(self, key, value):
        self[key] = value

    def __delattr__(self, key):
        try:
            del self[key]
        except KeyError:
            raise AttributeError


def enable_pretty_logging(level='info'):
    """Turns on formatted logging output as configured.

    This is called automatically by `parse_command_line`.
    """
    if level == 'debug':
        g.interrupt = True
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, level.upper()))

    if not root_logger.handlers:
        # Set up color if we are in a tty and curses is installed
        color = False
        if curses and sys.stderr.isatty():
            try:
                curses.setupterm()
                if curses.tigetnum("colors") > 0:
                    color = True
            except Exception:
                pass
        channel = logging.StreamHandler()
        channel.setFormatter(_LogFormatter(color=color))
        root_logger.addHandler(channel)


class _LogFormatter(logging.Formatter):
    def __init__(self, color, *args, **kwargs):
        logging.Formatter.__init__(self, *args, **kwargs)
        self._color = color
        if color:
            # The curses module has some str/bytes confusion in
            # python3.  Until version 3.2.3, most methods return
            # bytes, but only accept strings.  In addition, we want to
            # output these strings with the logging module, which
            # works with unicode strings.  The explicit calls to
            # unicode() below are harmless in python2 but will do the
            # right conversion in python 3.
            fg_color = (curses.tigetstr("setaf") or
                        curses.tigetstr("setf") or "")
            if (3, 0) < sys.version_info < (3, 2, 3):
                fg_color = unicode(fg_color, "ascii")
            self._colors = {
                logging.DEBUG: unicode(curses.tparm(fg_color, 4),  # Blue
                                       "ascii"),
                logging.INFO: unicode(curses.tparm(fg_color, 2),  # Green
                                      "ascii"),
                logging.WARNING: unicode(curses.tparm(fg_color, 3),  # Yellow
                                         "ascii"),
                logging.ERROR: unicode(curses.tparm(fg_color, 1),  # Red
                                       "ascii"),
            }
            self._normal = unicode(curses.tigetstr("sgr0"), "ascii")

    def format(self, record):
        try:
            record.message = record.getMessage()
        except Exception as e:
            record.message = "Bad message (%r): %r" % (e, record.__dict__)
        record.asctime = time.strftime(
            "%y%m%d %H:%M:%S", self.converter(record.created))
        prefix = '[%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d]' % \
            record.__dict__
        if self._color:
            prefix = (self._colors.get(record.levelno, self._normal) +
                      prefix + self._normal)
        formatted = prefix + " " + record.message
        if record.exc_info:
            if not record.exc_text:
                record.exc_text = self.formatException(record.exc_info)
        if record.exc_text:
            formatted = formatted.rstrip() + "\n" + record.exc_text
        return formatted.replace("\n", "\n    ")


#: settings for blog user
settings = _Options()
settings.site = {}
settings.config = {}
settings.author = {}
settings.reader = {}
settings.writer = {}
settings.theme = {}


#: settings for liquidluck
g = _Options()
g.interrupt = False
g.liquid_directory = os.path.abspath(os.path.dirname(__file__))
g.source_directory = 'source'
g.output_directory = 'deploy'
g.static_directory = 'static'
g.theme_gallery = os.path.expanduser('~/.liquidluck-themes')
g.theme_directory = os.path.join(
    g.liquid_directory, '_themes', 'default'
)
g.resource = {}
g.public_posts = []
g.secure_posts = []
g.pure_files = []
g.pure_pages = []

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Reader, read content, parse to html.

:copyright: (c) 2012 by Hsiaoming Yang (aka lepture)
:license: BSD
'''

import os
import logging
import datetime
import re
from liquidluck.options import settings, g
from liquidluck.utils import to_datetime, import_object


class BaseReader(object):
    SUPPORT_TYPE = None
    """
    Base Reader, all readers must inherit this module. e.g.:

        ``MarkdownReader(BaseReader)``

    New reader required:
        - ``SUPPORT_TYPE``
        - ``render``

    New reader optional:
        - ``start``
    """
    def __init__(self, filepath=None):
        self.filepath = filepath

    @property
    def relative_filepath(self):
        return self.filepath[len(g.source_directory) + 1:]

    def start(self):
        return None

    def support(self):
        _type = self.SUPPORT_TYPE
        if isinstance(_type, basestring):
            return self.filepath.endswith('.' + _type)
        if isinstance(_type, list) or isinstance(_type, tuple):
            for _t in _type:
                if isinstance(_t, basestring) and \
                   self.filepath.endswith('.' + _t):
                    return True
        return False

    def get(self, key, value=None):
        variables = settings.reader.get('vars') or {}
        return variables.get(key, value)

    @property
    def post_class(self):
        cls = self.get('post_class', Post)
        if isinstance(cls, str):
            return import_object(cls)
        return cls

    def render(self):
        raise NotImplementedError

    def run(self):
        try:
            return self.render()
        except Exception as e:
            logging.error(e)
            if g.interrupt:
                raise e


class Post(object):
    meta = {}

    def __init__(self, filepath, content, title=None, meta=None):
        self.filepath = filepath
        self.content = content
        if title:
            self.title = title
        else:
            self.title = meta.pop('title')

        if meta:
            self.meta = meta

    @property
    def clean_title(self):
        #: https://github.com/lepture/liquidluck/issues/32
        title = re.sub(
            r'[<>,~!#&\{\}\(\)\[\]\.\*\^\$\?]', ' ', self.title
        )
        return '-'.join(title.strip().split())

    @property
    def author(self):
        author = settings.author.get('default', 'admin')
        return Author(self.meta.get('author', author))

    @property
    def date(self):
        return to_datetime(self.meta.get('date'))

    @property
    def updated(self):
        mtime = os.stat(self.filepath).st_mtime
        return datetime.datetime.fromtimestamp(mtime)

    @property
    def public(self):
        return self.meta.get('public', 'true') == 'true'

    @property
    def category(self):
        return self.meta.get('category', None)

    @property
    def tags(self):
        tags = self.meta.get('tags', None)
        if not tags:
            return []
        if isinstance(tags, (list, tuple)):
            return tags
        return [tag.strip() for tag in tags.split(",")]

    @property
    def template(self):
        return self.meta.get('template', None)

    @property
    def folder(self):
        return os.path.split(self.relative_filepath)[0]

    @property
    def filename(self):
        if self.meta.get('filename'):
            return self.meta.get('filename')
        path = os.path.split(self.filepath)[1]
        return os.path.splitext(path)[0]

    @property
    def relative_filepath(self):
        path = self.filepath
        if path.startswith(g.source_directory):
            return path[len(g.source_directory) + 1:]
        return path

    @property
    def clean_filepath(self):
        logging.warn(
            'clean_filepath is deprecated since 3.6, '
            'you should use relative_filepath instead.'
        )
        return self.relative_filepath

    @property
    def clean_folder(self):
        logging.warn(
            'clean_folder is deprecated since 3.6, '
            'you should use folder instead.'
        )
        return self.folder

    def __getattr__(self, key):
        try:
            return super(Post, self).__getattr__(key)
        except:
            pass
        #: won't raise AttributeError
        return self.meta.get(key)


class Author(object):
    def __init__(self, author):
        self.author = author

        __ = settings.author.get('vars') or {}
        self._d = __.get(author, {})

    def __str__(self):
        return self.author

    def __repr__(self):
        return self.author

    @property
    def name(self):
        return self._d.get('name', self.author)

    @property
    def website(self):
        return self._d.get('website', None)

    @property
    def email(self):
        return self._d.get('email', None)

########NEW FILE########
__FILENAME__ = markdown
# -*- coding: utf-8 -*-
'''
Blog content file parser.

Syntax::

    # Title

    - date: 2011-09-01
    - category: life
    - tags: tag1, tag2

    Here is the description.

    -----------------

    Your content here. And it supports code highlight.

    ```python

    def hello():
        return 'Hello World'

    ```


:copyright: (c) 2012 by Hsiaoming Yang (aka lepture)
:license: BSD
'''


import re
import logging
import hoedown as m

from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import get_lexer_by_name

from liquidluck.readers.base import BaseReader
from liquidluck.options import settings
from liquidluck.utils import to_unicode, cjk_nowrap, import_object


class MarkdownReader(BaseReader):
    SUPPORT_TYPE = ['md', 'mkd', 'markdown']

    def render(self):
        f = open(self.filepath)
        logging.debug('read ' + self.relative_filepath)

        header = ''
        body = ''
        recording = True
        for line in f:
            if recording and line.startswith('---'):
                recording = False
            elif recording:
                header += line
            else:
                body += line

        f.close()
        body = to_unicode(body)
        meta = self._parse_meta(header, body)
        content = self._parse_content(body)
        return self.post_class(self.filepath, content, meta=meta)

    def _parse_content(self, body):
        return markdown(body)

    def _parse_meta(self, header, body):
        header = m.html(to_unicode(header))
        titles = re.findall(r'<h1>(.*)</h1>', header)
        if not titles:
            logging.error('There is no title')
            title = None
        else:
            title = titles[0]

        meta = {'title': title}
        items = re.findall(r'<li>(.*?)</li>', header, re.S)
        for item in items:
            index = item.find(':')
            key = item[:index].rstrip()
            value = item[index + 1:].lstrip()
            meta[key] = value

        desc = re.findall(r'<p>(.*?)</p>', header, re.S)
        if desc:
            meta['description'] = '\n\n'.join(desc)

        #: keep body in meta data as source text
        meta['source_text'] = body
        _toc = m.Markdown(m.HtmlTocRenderer(), 0)
        meta['toc'] = _toc.render(body)
        return meta


class LiquidRender(m.HtmlRenderer, m.SmartyPants):
    def paragraph(self, text):
        text = cjk_nowrap(text)
        return '<p>%s</p>\n' % text

    def block_code(self, text, lang):
        if not lang or lang == '+' or lang == '-':
            return '\n<pre><code>%s</code></pre>\n' % escape(text.strip())

        hide = lang.endswith('-')
        inject = lang.endswith('+') or lang.endswith('-')
        if inject:
            lang = lang[:-1]
        inject = inject and lang in ('javascript', 'js', 'css', 'html')

        html = ''
        if inject:
            if lang == 'javascript' or lang == 'js':
                tpl = '\n<script>\n%s</script>\n'
            elif lang == 'css':
                tpl = '\n<style>\n%s</style>\n'
            else:
                tpl = '\n<div class="insert-code">%s</div>\n'

            html = tpl % text

        if hide and inject:
            return html

        variables = settings.reader.get('vars') or {}
        lexer = get_lexer_by_name(lang, stripall=True)
        formatter = HtmlFormatter(
            noclasses=variables.get('highlight_inline', False),
            linenos=variables.get('highlight_linenos', False),
        )
        html += highlight(text, lexer, formatter)
        return html

    def autolink(self, link, is_email):
        if is_email:
            return '<a href="mailto:%(link)s">%(link)s</a>' % {'link': link}

        variables = settings.reader.get('vars') or {}
        for func in variables.get(
            'markdown_transform', [
                'liquidluck.readers.markdown.transform_youtube',
                'liquidluck.readers.markdown.transform_gist',
                'liquidluck.readers.markdown.transform_vimeo',
            ]):
            func = import_object(func)
            value = func(link)
            if value:
                return value
        title = link.replace('http://', '').replace('https://', '')
        return '<a href="%s">%s</a>' % (link, title)


#: compatible
JuneRender = LiquidRender


def markdown(text):
    text = to_unicode(text)
    regex = re.compile(r'^````(\w+)', re.M)
    text = regex.sub(r'````\1+', text)
    regex = re.compile(r'^`````(\w+)', re.M)
    text = regex.sub(r'`````\1-', text)

    render = LiquidRender(flags=m.HTML_USE_XHTML | m.HTML_TOC)
    md = m.Markdown(
        render,
        extensions=(
            m.EXT_FENCED_CODE | m.EXT_AUTOLINK | m.EXT_TABLES |
            m.EXT_NO_INTRA_EMPHASIS | m.EXT_STRIKETHROUGH
        ),
    )
    return md.render(text)


_XHTML_ESCAPE_RE = re.compile('[&<>"]')
_XHTML_ESCAPE_DICT = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;'}


def escape(value):
    """Escapes a string so it is valid within XML or XHTML."""
    if not isinstance(value, (basestring, type(None))):
        value = value.decode('utf-8')
    return _XHTML_ESCAPE_RE.sub(
        lambda match: _XHTML_ESCAPE_DICT[match.group(0)], value)


#: markdown autolink transform

def transform_youtube(link):
    #: youtube.com
    title = link.replace('http://', '')
    pattern = r'http://www.youtube.com/watch\?v=([a-zA-Z0-9\-\_]+)'
    match = re.match(pattern, link)
    if not match:
        pattern = r'http://youtu.be/([a-zA-Z0-9\-\_]+)'
        match = re.match(pattern, link)
    if match:
        value = ('<iframe width="560" height="315" src='
                 '"http://www.youtube.com/embed/%(id)s" '
                 'frameborder="0" allowfullscreen></iframe>'
                 '<div><a rel="nofollow" href="%(link)s">'
                 '%(title)s</a></div>'
                ) % {'id': match.group(1), 'link': link, 'title': title}
        return value
    return None


def transform_gist(link):
    #: gist support
    title = link.replace('http://', '').replace('https://', '')
    pattern = r'(https?://gist.github.com/[\d]+)'
    match = re.match(pattern, link)
    if match:
        value = ('<script src="%(link)s.js"></script>'
                 '<div><a rel="nofollow" href="%(link)s">'
                 '%(title)s</a></div>'
                ) % {'link': match.group(1), 'title': title}
        return value
    return None


def transform_vimeo(link):
    #: vimeo.com
    title = link.replace('http://', '')
    pattern = r'http://vimeo.com/([\d]+)'
    match = re.match(pattern, link)
    if match:
        value = ('<iframe width="500" height="281" frameborder="0" '
                 'src="http://player.vimeo.com/video/%(id)s" '
                 'allowFullScreen></iframe>'
                 '<div><a rel="nofollow" href="%(link)s">'
                 '%(title)s</a></div>'
                ) % {'id': match.group(1), 'link': link, 'title': title}
        return value
    return None


def transform_screenr(link):
    title = link.replace('http://', '')
    pattern = r'http://www.screenr.com/([a-zA-Z0-9]+)'
    match = re.match(pattern, link)
    if match:
        value = ('<iframe width="500" height="305" frameborder="0" '
                 'src="http://www.screenr.com/embed/%(id)s" '
                 'allowFullScreen></iframe>'
                 '<div><a rel="nofollow" href="%(link)s">'
                 '%(title)s</a></div>'
                ) % {'id': match.group(1), 'link': link, 'title': title}
        return value
    return None

########NEW FILE########
__FILENAME__ = restructuredtext
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Blog content file parser.

Syntax::

    title
    ========

    :date: 2011-09-01
    :category: life
    :tags: tag1, tag2

    Your content here. And it supports code highlight.

    Example::

        .. sourcecode:: python

            def hello():
                return 'hello'

:copyright: (c) 2012 by Hsiaoming Yang (aka lepture)
:license: BSD
'''

import logging
from xml.dom import minidom
from docutils import nodes
from docutils.core import publish_parts
from docutils.parsers.rst import directives, Directive
from pygments.formatters import HtmlFormatter
from pygments import highlight
from pygments.lexers import get_lexer_by_name, TextLexer
from liquidluck.readers.base import BaseReader
from liquidluck.options import settings
from liquidluck.utils import to_unicode, utf8


class RestructuredTextReader(BaseReader):
    SUPPORT_TYPE = ['rst', 'rst.txt', 'restructuredtext']

    def render(self):
        f = open(self.filepath)
        logging.debug('read ' + self.relative_filepath)

        content = f.read()
        f.close()

        extra_setting = {'initial_header_level': '2'}
        parts = publish_parts(
            content, writer_name='html',
            settings_overrides=extra_setting,
        )
        title = parts['title']
        body = parts['body']
        meta = parts['docinfo']

        meta = self._parse_meta(meta)
        return self.post_class(self.filepath, body, title=title, meta=meta)

    def _parse_meta(self, meta):
        content = meta.replace('\n', '')
        if not content:
            return {}

        docinfo = {}
        dom = minidom.parseString(utf8(content))
        for node in dom.getElementsByTagName('tr'):
            key, value = self._node_to_pairs(node)
            docinfo[key] = value
        return docinfo

    def _plain_text(self, node):
        child = node.firstChild
        if not child:
            return None
        if child.nodeType == node.TEXT_NODE:
            return to_unicode(child.data)

        return None

    def _node_to_pairs(self, node):
        '''
        parse docinfo to python object

        <tr><th class="docinfo-name">Date:</th>
        <td>2011-10-12</td></tr>
        '''
        keyNode = node.firstChild
        key = self._plain_text(keyNode)
        key = key.lower().rstrip(':')

        valueNode = node.lastChild

        tag = valueNode.firstChild.nodeName
        if 'ul' == tag or 'ol' == tag:
            value = []
            for node in valueNode.getElementsByTagName('li'):
                value.append(self._plain_text(node))
        else:
            value = self._plain_text(valueNode)
        return key, value


INLINESTYLES = settings.get('highlight_inline', False)
DEFAULT = HtmlFormatter(noclasses=INLINESTYLES)
VARIANTS = {
    'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),
}


class Pygments(Directive):
    """ Source code syntax hightlighting.
    """
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True
    option_spec = dict([(key, directives.flag) for key in VARIANTS])
    has_content = True

    def run(self):
        self.assert_has_content()
        try:
            lexer = get_lexer_by_name(self.arguments[0])
        except ValueError:
            # no lexer found - use the text one instead of an exception
            lexer = TextLexer()
        # take an arbitrary option if more than one is given

        formatter = self.options and VARIANTS[self.options.keys()[0]] \
                or DEFAULT
        parsed = highlight('\n'.join(self.content), lexer, formatter)
        return [nodes.raw('', parsed, format='html')]

directives.register_directive('sourcecode', Pygments)
directives.register_directive('code-block', Pygments)

########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python

import os
import mimetypes
import logging
from wsgiref.simple_server import make_server
from liquidluck.options import g, settings
from liquidluck.utils import to_unicode, UnicodeDict, walk_dir
from liquidluck.generator import load_posts, write_posts
try:
    import tornado.web
    import tornado.escape
    import tornado.websocket
    RequestHandler = tornado.web.RequestHandler
    WebSocketHandler = tornado.websocket.WebSocketHandler
    escape = tornado.escape
except ImportError:
    print('Enable Livereload Server by installing tornado')
    escape = None
    RequestHandler = object
    WebSocketHandler = object


HOST = '127.0.0.1'
PORT = 8000
ROOT = os.path.abspath('.')
PERMALINK = 'html'
LIVERELOAD = os.path.join(
    os.path.abspath(os.path.dirname(__file__)), 'livereload.js'
)


def config(port=None, root=None, permalink=None):
    global PORT
    global ROOT
    global PERMALINK

    if port and ':' in port:
        HOST, PORT = port.split(':')
    elif port:
        PORT = port

    if root:
        ROOT = os.path.abspath(root)

    if permalink:
        PERMALINK = permalink


def _autoindex(abspath):
    if not os.path.exists(abspath):
        return None
    html = '<ul>'
    files = os.listdir(abspath)
    for f in files:
        path = os.path.join(abspath, f)
        html += '<li>'
        if os.path.isdir(path):
            html += '<a href="%s/">%s</a>' % (f, f)
        else:
            html += '<a href="%s">%s</a>' % (f, f)

        html += '</li>'

    html += '</ul>'
    return html


def _read(abspath):
    filepath = abspath
    if abspath.endswith('/'):
        #: this is index
        filepath = os.path.join(abspath, 'index.html')
        if not os.path.exists(filepath) and PERMALINK == 'slash':
            filepath = abspath.rstrip('/') + '.html'
        elif not os.path.exists(filepath):
            return _autoindex(abspath)

    elif not os.path.exists(abspath):
        filepath = abspath + '.html'

    if not os.path.exists(filepath):
        return None

    f = open(filepath)
    content = f.read()
    f.close()
    return content


def wsgi_app(environ, start_response):
    path = environ['PATH_INFO'].lstrip('/')
    abspath = os.path.join(ROOT, path)
    headers = []
    mime_type, encoding = mimetypes.guess_type(abspath)
    if mime_type:
        headers.append(('Content-type', mime_type))
    else:
        headers.append(('Content-type', 'text/html'))

    body = _read(abspath)

    if body is None:
        start_response('404 Not Found', headers)
        body = _read(os.path.join(ROOT, '404.html'))
        if body:
            yield body
    else:
        start_response('200 OK', headers)
        yield body


class LiveReloadJSHandler(RequestHandler):
    def get(self):
        f = open(LIVERELOAD)
        content = to_unicode(f.read())
        content = content.replace('{{port}}', str(PORT))
        f.close()

        self.set_header('Content-Type', 'application/javascript')
        self.write(content)


class LiveReloadHandler(WebSocketHandler):
    waiters = set()
    _modified_times = {}
    _watch_running = False

    def allow_draft76(self):
        return True

    def on_close(self):
        if self in LiveReloadHandler.waiters:
            LiveReloadHandler.waiters.remove(self)

    def send_message(self, message):
        if isinstance(message, dict):
            message = escape.json_encode(message)

        try:
            self.write_message(message)
        except:
            logging.error('Error sending message', exc_info=True)

    def on_message(self, message):
        """Handshake with livereload.js

        1. client send 'hello'
        2. server reply 'hello'
        3. client send 'info'

        http://help.livereload.com/kb/ecosystem/livereload-protocol
        """
        message = UnicodeDict(escape.json_decode(message))
        if message.command == 'hello':
            handshake = {}
            handshake['command'] = 'hello'
            protocols = message.protocols
            protocols.append(
                'http://livereload.com/protocols/2.x-remote-control'
            )
            handshake['protocols'] = protocols
            handshake['serverName'] = 'livereload-tornado'
            self.send_message(handshake)

        if message.command == 'info' and 'url' in message:
            logging.info('Browser Connected: %s' % message.url)
            LiveReloadHandler.waiters.add(self)
            if not LiveReloadHandler._watch_running:
                LiveReloadHandler._watch_running = True
                logging.info('Start watching changes')
                tornado.ioloop.PeriodicCallback(self.watch_tasks, 500).start()

    def watch_tasks(self):
        if g.output_directory != ROOT:
            # not a liquidluck project
            if self._is_changed(ROOT):
                self.reload_browser()
            return

        if self._is_changed(g.source_directory):
            # clean posts
            g.public_posts = []
            g.secure_posts = []
            g.pure_files = []
            g.pure_pages = []
            g.resource = {}

            load_posts(settings.config['source'])
            write_posts()
            self.reload_browser()

        if self._is_changed(g.theme_directory):
            write_posts()
            self.reload_browser()

    def reload_browser(self):
        logging.info('Reload')
        msg = {
            'command': 'reload',
            'path': '*',
            'liveCSS': True
        }
        for waiter in LiveReloadHandler.waiters:
            try:
                waiter.write_message(msg)
            except:
                logging.error('Error sending message', exc_info=True)
                LiveReloadHandler.waiters.remove(waiter)

    def _is_changed(self, path):
        def is_file_changed(path):
            if not os.path.isfile(path):
                return False

            _, ext = os.path.splitext(path)
            theme = settings.theme.get('vars') or {}

            if g.output_directory == g.source_directory:
                matches = theme.get('reload_match') or []
                matches.extend(['.md', '.mkd', '.markdown', '.rst'])
                if ext not in matches:
                    return False
            elif os.path.abspath(g.output_directory) in \
                    os.path.abspath(path):
                return False

            modified = int(os.stat(path).st_mtime)

            if path not in self._modified_times:
                self._modified_times[path] = modified
                return False

            if path in self._modified_times and \
               self._modified_times[path] == modified:
                return False

            self._modified_times[path] = modified
            logging.info('file changed: %s' % path)
            return True

        for f in walk_dir(path):
            if is_file_changed(f):
                return True

        return False


class IndexHandler(RequestHandler):
    def get(self, path='/'):
        abspath = os.path.join(os.path.abspath(ROOT), path.lstrip('/'))
        mime_type, encoding = mimetypes.guess_type(abspath)
        if not mime_type:
            mime_type = 'text/html'

        self.set_header('Content-Type', mime_type)

        body = _read(abspath)

        if body is None:
            body = _read(os.path.join(ROOT, '404.html'))
            self.set_status(404)
            self.write(body or 'Not Found')
            return
        ua = self.request.headers.get("User-Agent", 'bot').lower()
        if 'msie' not in ua:
            body = body.replace(
                '</head>', '<script src="/livereload.js"></script></head>'
            )
        # disable google analytics
        body = body.replace('google-analytics.com/ga.js', '')
        self.write(body)


class ThemeStaticHandler(RequestHandler):
    def get(self, filepath):
        abspath = os.path.join(g.theme_directory, 'static', filepath)
        mime_type, encoding = mimetypes.guess_type(abspath)
        if not mime_type:
            mime_type = 'text/html'

        self.set_header('Content-Type', mime_type)
        if not os.path.exists(abspath):
            self.send_error(404)
            return

        f = open(abspath)
        for line in f:
            self.write(line)
        f.close()


def start_server(debug=False):
    message = 'Starting server at http://%s:%s' % (HOST, PORT)
    if debug:
        variables = settings.theme.get('vars', {})
        variables.update({'debug': True})
        settings.theme['vars'] = variables
    if RequestHandler is object:
        logging.info(message)
        make_server(HOST, int(PORT), wsgi_app).serve_forever()
    else:
        import tornado.web
        if g.output_directory == ROOT:
            #: if this is a liquidluck project, build the site
            load_posts(settings.config['source'])
            write_posts()
            logging.info('Theme directory: %s' % g.theme_directory)
        handlers = [
            (r'/livereload', LiveReloadHandler),
            (r'/livereload.js', LiveReloadJSHandler),
            (r'/theme/(.*)', ThemeStaticHandler),
            (r'(.*)', IndexHandler),
        ]
        app = tornado.web.Application(handlers=handlers, default_host=HOST)
        app.listen(int(PORT))
        logging.info(message)
        tornado.ioloop.IOLoop.instance().start()


if __name__ == '__main__':
    start_server()

########NEW FILE########
__FILENAME__ = theme
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
from liquidluck.options import g
from liquidluck.utils import to_unicode, utf8


def __fetch_themes():
    import urllib
    if hasattr(urllib, 'urlopen'):
        urlopen = urllib.urlopen
    else:
        import urllib.request
        urlopen = urllib.request.urlopen

    content = urlopen(
        "https://api.github.com/legacy/repos/search/%22liquidluck-theme-%22"
    ).read()
    content = to_unicode(content)
    return content


def __filter_themes(content):
    try:
        import json
        json_decode = json.loads
    except ImportError:
        import simplejson
        json_decode = simplejson.loads

    repos = json_decode(content)
    themes = {}
    if 'repositories' not in repos and 'message' in repos:
        print repos['message']
        return {}
    for theme in repos['repositories']:
        fork = theme['fork']
        if not fork:
            name = theme['name'].replace('liquidluck-theme-', '')
            name = name.strip().strip('-')
            theme['name'] = name
            themes[name] = theme
    return themes


def __load_themes(force=False):
    import time
    import tempfile
    path = os.path.join(tempfile.gettempdir(), 'liquidluck.json')

    if not os.path.exists(path) or \
       os.stat(path).st_mtime + 600 < time.time() or \
       force:
        content = __fetch_themes()
        if "repositories" not in content:
            return content
        f = open(path, 'w')
        f.write(utf8(content))
        f.close()

    content = to_unicode(open(path).read())
    return __filter_themes(content)


SEARCH_TEMPLATE = '''
Theme: %(name)s
Author: %(username)s
Description: %(description)s
Updated: %(pushed)s
Status: %(forks)s forks | %(followers)s followers
URL: https://github.com/%(username)s/liquidluck-theme-%(name)s
'''


def search(keyword=None, clean=False, force=False):
    themes = __load_themes(force)
    available = {}

    if keyword:
        for name in themes:
            if keyword in name:
                available[name] = themes[name]

    for name in (available or themes):
        if clean:
            print(name)
        else:
            theme = themes[name]
            print(SEARCH_TEMPLATE % theme)
    return


def install(keyword=None, widely=False):
    if not keyword:
        print("You need specify a theme")
        return
    if '/' in keyword:
        user, name = keyword.split('/')
        if not name:
            keyword = user
            name = 'liquidluck-theme'
        elif name.startswith('liquidluck-theme-'):
            keyword = name.replace('liquidluck-theme-', '', 1)
        else:
            keyword = name
            name = 'liquidluck-theme-%s' % name

        repo = 'git://github.com/%s/%s' % (user, name)
    else:
        themes = __load_themes()
        if keyword not in themes:
            print("can't find theme %s" % keyword)
            return
        theme = themes[keyword]
        repo = 'https://github.com/%(username)s/liquidluck-theme-%(name)s' \
                % theme
    if widely:
        output = os.path.join(g.theme_gallery, keyword)
    else:
        output = '_themes/%s' % keyword
    import subprocess
    if os.path.exists(output):
        subprocess.call(['git', 'pull'], cwd=output)
    else:
        subprocess.call(['git', 'clone', repo, output])


if __name__ == '__main__':
    search()

########NEW FILE########
__FILENAME__ = webhook
import sys
import os
import time
import atexit
import subprocess
from signal import SIGTERM
from wsgiref.simple_server import make_server


CWDPATH = os.path.abspath('.')
SETTINGS = 'settings.py'
PORT = 8000


def _call(cmd):
    subprocess.call(cmd.split(), cwd=CWDPATH)


def _update():
    if os.path.isdir(os.path.join(CWDPATH, '.git')):
        _call('git pull')
        if os.path.exists(os.path.join(CWDPATH, '.gitmodules')):
            _call('git submodule init')
            _call('git submodule update')
        return

    if os.path.isdir(os.path.join(CWDPATH, '.hg')):
        _call('hg pull')
        return


def app(environ, start_response):
    path = environ['PATH_INFO']
    start_response('200 OK', [('Content-type', 'text/plain')])
    if path == '/webhook':
        _update()
        _call('liquidluck build -s %s' % SETTINGS)
    yield 'Ok'


class Daemon(object):
    """
    A generic daemon class.

    Usage: subclass the Daemon class and override the run() method
    """
    def __init__(self, pidfile, stdin='/dev/null',
                 stdout='/dev/null', stderr='/dev/null'):
        self.stdin = stdin
        self.stdout = stdout
        self.stderr = stderr
        self.pidfile = pidfile

    def daemonize(self):
        """
        do the UNIX double-fork magic, see Stevens' "Advanced
        Programming in the UNIX Environment" for details (ISBN 0201563177)
        http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
        """
        try:
            pid = os.fork()
            if pid > 0:
                # exit first parent
                sys.exit(0)
        except OSError as e:
            sys.stderr.write(
                "fork #1 failed: %d (%s)\n" % (e.errno, e.strerror)
            )
            sys.exit(1)

        # decouple from parent environment
        os.chdir("/")
        os.setsid()
        os.umask(0)

        # do second fork
        try:
            pid = os.fork()
            if pid > 0:
                # exit from second parent
                sys.exit(0)
        except OSError as e:
            sys.stderr.write(
                "fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
            sys.exit(1)

        # redirect standard file descriptors
        sys.stdout.flush()
        sys.stderr.flush()
        si = file(self.stdin, 'r')
        so = file(self.stdout, 'a+')
        se = file(self.stderr, 'a+', 0)
        os.dup2(si.fileno(), sys.stdin.fileno())
        os.dup2(so.fileno(), sys.stdout.fileno())
        os.dup2(se.fileno(), sys.stderr.fileno())

        # write pidfile
        atexit.register(self.delpid)
        pid = str(os.getpid())
        file(self.pidfile, 'w+').write("%s\n" % pid)

    def delpid(self):
        os.remove(self.pidfile)

    def start(self):
        """
        Start the daemon
        """
        # Check for a pidfile to see if the daemon already runs
        try:
            pf = file(self.pidfile, 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None

        if pid and self.check_pid_exists(pid):
            message = "pidfile %s already exist. Daemon already running?\n"
            sys.stderr.write(message % self.pidfile)
            sys.exit(1)

        # Start the daemon
        self.daemonize()
        self.run()

    def stop(self):
        """
        Stop the daemon
        """
        # Get the pid from the pidfile
        try:
            pf = file(self.pidfile, 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None

        if not pid:
            message = "pidfile %s does not exist. Daemon not running?\n"
            sys.stderr.write(message % self.pidfile)
            return  # not an error in a restart

        # Try killing the daemon process
        try:
            while 1:
                os.kill(pid, SIGTERM)
                time.sleep(0.1)
        except OSError, err:
            err = str(err)
            if err.find("No such process") > 0:
                if os.path.exists(self.pidfile):
                    os.remove(self.pidfile)
                else:
                    print str(err)
                    sys.exit(1)

    def restart(self):
        """
        Restart the daemon
        """
        self.stop()
        self.start()

    def run(self):
        """
        You should override this method when you subclass Daemon.
        It will be called after the process has been daemonized by
        start() or restart().
        """

    def check_pid_exists(self, pid):
        """
        Check a PID is exists or already quit.
        This will be called when first init of this class to avoid some
        fake PID file
        """
        try:
            os.kill(pid, 0)
        except OSError:
            return False
        else:
            return True


class ServerDaemon(Daemon):
    def run(self):
        global PORT
        make_server('', PORT, app).serve_forever()


def webhook(port, command='start', settings='settings.py'):
    global PORT
    global SETTINGS
    PORT = int(port)
    SETTINGS = settings
    d = ServerDaemon('/tmp/liquidluck.pid')
    if command == 'start':
        d.start()
    elif command == 'stop':
        d.stop()
    elif command == 'restart':
        d.restart()
    else:
        print("Invalid Command")

########NEW FILE########
__FILENAME__ = _settings
# -*- coding: utf-8 -*-
#: settings for liquidluck

#: site information
#: all variables can be accessed in template with ``site`` namespace.
#: for instance: {{site.name}}
site = {
    "name": "Felix Felicis",  # your site name
    "url": "http://lab.lepture.com/liquidluck/",  # your site url
    # "prefix": "blog",
}

#: this config defined information of your site
#: 1. where the resources  2. how should the site be generated
config = {
    "source": "content",
    "output": "deploy",
    "static": "deploy/static",
    "static_prefix": "/static/",
    "permalink": "{{date.year}}/{{filename}}.html",
    "relative_url": False,
    "perpage": 30,
    "feedcount": 20,
    "timezone": "+08:00",
}


author = {
    "default": "nickname",
    "vars": {}
}

#: active readers
reader = {
    "active": [
        "liquidluck.readers.markdown.MarkdownReader",
        # uncomment to activate rST reader
        # "liquidluck.readers.restructuredtext.RestructuredTextReader",
    ],
    "vars": {}
}

#: active writers
writer = {
    "active": [
        "liquidluck.writers.core.PostWriter",
        "liquidluck.writers.core.PageWriter",
        "liquidluck.writers.core.ArchiveWriter",
        "liquidluck.writers.core.ArchiveFeedWriter",
        "liquidluck.writers.core.FileWriter",
        "liquidluck.writers.core.StaticWriter",
        "liquidluck.writers.core.YearWriter",
        "liquidluck.writers.core.CategoryWriter",
        # "liquidluck.writers.core.CategoryFeedWriter",
        # "liquidluck.writers.core.TagWriter",
        # "liquidluck.writers.core.TagCloudWriter",
    ],
    "vars": {
        # uncomment if you want to reset archive page
        # "archive_output": "archive.html",
    }
}

#: theme variables
theme = {
    "name": "default",

    # theme variables are defined by theme creator
    # you can access theme in template with ``theme`` namespace
    # for instance: {{theme.disqus}}
    "vars": {
        #"disqus": "your_short_name",
        #"analytics": "UA-21475122-1",
    }
}

#: template variables
template = {
    "vars": {},
    "filters": {},
}

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import os
import shutil
import datetime


def to_unicode(value):
    if isinstance(value, unicode):
        return value
    if isinstance(value, basestring):
        return value.decode('utf-8')
    if isinstance(value, int):
        return str(value)
    if isinstance(value, bytes):
        return value.decode('utf-8')
    return value


def utf8(value):
    if isinstance(value, (bytes, type(None), str)):
        return value
    if isinstance(value, int):
        return str(value)
    assert isinstance(value, unicode)
    return value.encode('utf-8')


def to_bytes(value):
    if isinstance(value, bytes):
        return value
    assert isinstance(value, str)
    return value.encode('utf-8')


def import_object(name):
    if '.' not in name:
        return __import__(name)

    parts = name.split('.')
    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)
    return getattr(obj, parts[-1])


def walk_dir(dest):
    for root, dirs, files in os.walk(dest):
        if '.git' in dirs:
            dirs.remove('.git')
        if '.hg' in dirs:
            dirs.remove('.hg')
        if '.svn' in dirs:
            dirs.remove('.svn')
        for f in files:
            path = os.path.join(root, f)
            yield path


def copy_to(source, dest):
    if os.path.exists(dest) and \
       os.stat(source).st_mtime <= os.stat(dest).st_mtime:
        return

    folder = os.path.split(dest)[0]
    # on Mac OSX, `folder` == `FOLDER`
    # then make sure destination is lowercase
    if folder and not os.path.isdir(folder):
        os.makedirs(folder)

    shutil.copy(source, dest)
    return


class UnicodeDict(dict):
    def __getattr__(self, key):
        try:
            return to_unicode(self[key])
        except KeyError:
            return None

    def __setattr__(self, key, value):
        self[key] = to_unicode(value)

    def __getitem__(self, key):
        return to_unicode(super(UnicodeDict, self).__getitem__(key))

    def __setitem__(self, key, value):
        return super(UnicodeDict, self).__setitem__(key, to_unicode(value))


def cjk_nowrap(text):
    start = u'\u4e00'
    end = u'\u9fff'
    pattern = ur'([%s-%s]+?)' % (start, end)
    cjk = re.compile(pattern + r'(\n|\r\n|\r)' + pattern)
    text = cjk.sub(r'\1\3', text)
    return text


def to_datetime(value):
    if not value:
        return None
    if isinstance(value, datetime.datetime):
        return value
    supported_formats = [
        '%a %b %d %H:%M:%S %Y',
        '%Y-%m-%d %H:%M:%S',
        '%Y-%m-%d %H:%M',
        '%Y-%m-%dT%H:%M',
        '%Y%m%d %H:%M:%S',
        '%Y%m%d %H:%M',
        '%Y-%m-%d',
        '%Y%m%d',
    ]
    for format in supported_formats:
        try:
            return datetime.datetime.strptime(value, format)
        except ValueError:
            pass
    raise ValueError('Unrecognized date/time: %r' % value)


def get_relative_base(path):
    length = len(filter(lambda o: o, path.split(os.path.sep)))
    if length > 1:
        return '/'.join(['..' for i in range(length - 1)])
    return '.'


def parse_settings(path, filetype=None):
    if path.endswith('.py'):
        filetype = 'python'
    elif path.endswith('.json'):
        filetype = 'json'
    else:
        filetype = 'yaml'

    def parse_py_settings(path):
        config = {}
        execfile(path, {}, config)
        return config

    def parse_yaml_settings(path):
        from yaml import load
        try:
            from yaml import CLoader
            MyLoader = CLoader
        except ImportError:
            from yaml import Loader
            MyLoader = Loader

        config = load(open(path), MyLoader)
        return config

    def parse_json_settings(path):
        try:
            import json
        except ImportError:
            import simplejson
            json = simplejson

        f = open(path)
        content = f.read()
        f.close()
        config = json.loads(content)
        return config

    if filetype == 'python':
        return parse_py_settings(path)
    elif filetype == 'json':
        return parse_json_settings(path)
    return parse_yaml_settings(path)

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Writer, write your content to html.

:copyright: (c) 2012 by Hsiaoming Yang (aka lepture)
:license: BSD
'''


import os
import re
import datetime
import logging
from jinja2 import Environment, FileSystemLoader
from jinja2 import contextfilter
import liquidluck
from liquidluck.utils import import_object, get_relative_base
from liquidluck.utils import to_unicode, utf8

# blog settings
from liquidluck.options import settings

# liquidluck settings
from liquidluck.options import g
from liquidluck.filters import xmldatetime, feed_updated, wiki_link
from liquidluck.filters import content_url, tag_url, year_url, static_url


class BaseWriter(object):
    """BaseWriter
    """
    writer_name = 'base'

    def start(self):
        raise NotImplementedError

    def run(self):
        try:
            self.start()
        except Exception as e:
            logging.error(e)
            if g.interrupt:
                raise e

        name = self.__class__.__name__
        logging.info('%s Finished' % name)

    def write(self, content, destination):
        destination = destination.replace(' ', '-')
        folder = os.path.split(destination)[0]
        # on Mac OSX, `folder` == `FOLDER`
        # then make sure destination is lowercase
        if not os.path.isdir(folder):
            os.makedirs(folder)

        f = open(destination, 'w')
        f.write(utf8(content))
        f.close()
        return

    def render(self, params, template, destination):
        filepath = destination[len(g.output_directory) + 1:]
        filepath = filepath.lower()
        logging.debug('write %s' % filepath)
        tpl = g.jinja.get_template(template)

        writer = {
            'class': self.__class__.__name__,
            'name': self.writer_name,
            'filepath': filepath,
        }
        params['writer'] = writer
        html = tpl.render(params)
        self.write(html, os.path.join(g.output_directory, filepath))
        return

    def get(self, key, value=None):
        variables = settings.writer.get('vars')
        if isinstance(variables, dict):
            return variables.get(key, value)
        return value

    @property
    def perpage(self):
        return settings.config['perpage']


class Pagination(object):
    title = None
    root = ''

    def __init__(self, items, page, per_page):
        self.total_items = items
        self.page = page
        self.per_page = per_page

    def iter_pages(self, edge=4):
        if self.page <= edge:
            return range(1, min(self.pages, 2 * edge + 1) + 1)
        if self.page + edge > self.pages:
            return range(max(self.pages - 2 * edge, 1), self.pages + 1)
        return range(self.page - edge, min(self.pages, self.page + edge) + 1)

    @property
    def pages(self):
        return int((self.total - 1) / self.per_page) + 1

    @property
    def has_prev(self):
        return self.page > 1

    @property
    def prev_num(self):
        return self.page - 1

    @property
    def has_next(self):
        return self.page < self.pages

    @property
    def next_num(self):
        return self.page + 1

    @property
    def total(self):
        return len(self.total_items)

    @property
    def items(self):
        start = (self.page - 1) * self.per_page
        end = self.page * self.per_page
        return self.total_items[start:end]


def find_theme():
    theme_name = settings.theme.get('name', 'default')
    theme_gallery = [
        os.path.join(os.path.abspath('_themes'), theme_name),
        os.path.join(g.theme_gallery, theme_name),
        os.path.join(g.liquid_directory, '_themes', theme_name),
    ]
    for path in theme_gallery:
        if os.path.exists(path):
            return path

    raise Exception("Can't find theme: %s" % theme_name)


def load_jinja():
    #: prepare loaders
    #: loaders = ['_templates', theme]
    loaders = []
    tpl = os.path.abspath('_templates')
    if os.path.exists(tpl):
        loaders.append(tpl)

    theme = find_theme()

    #: global variable
    g.theme_directory = theme

    theme_template = os.path.join(theme, 'templates')
    if os.path.exists(theme_template):
        loaders.append(theme_template)

    #: load default theme template always
    default_template = os.path.join(
        g.liquid_directory, '_themes/default/templates'
    )
    if default_template != theme_template:
        loaders.append(default_template)

    #: init jinja
    jinja = Environment(
        loader=FileSystemLoader(loaders),
        autoescape=False,  # blog don't need autoescape
        extensions=settings.writer.get('extensions') or [],
    )
    #: initialize globals
    jinja.globals = {}

    #: load template variables
    jinja.globals.update({
        'site': settings.site,
        'template': settings.template.get("vars") or {},
    })

    #: load theme variables
    config = {}
    theme_config = os.path.join(theme, 'settings.py')
    if os.path.exists(theme_config):
        logging.warn('settings.py in theme is deprecated since 3.4')
        logging.warn('the name should be changed to theme.py')
        execfile(theme_config, {}, config)
    theme_config = os.path.join(theme, 'theme.py')
    if os.path.exists(theme_config):
        execfile(theme_config, {}, config)

    #: user can reset theme variables
    config.update(settings.theme.get('vars') or {})
    #: keep namespace to the latest variables
    settings.theme['vars'] = config
    jinja.globals.update({'theme': config})

    #: default variables
    now = datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')
    jinja.globals.update({
        'system': {
            'name': 'Felix Felicis',
            'version': liquidluck.__version__,
            'homepage': liquidluck.__homepage__,
            'time': now,
        }
    })

    #: function helpers
    jinja.globals.update({
        'content_url': content_url,
        'static_url': static_url(os.path.join(theme, 'static')),
    })

    #: load theme filters
    config = {}
    theme_config = os.path.join(theme, 'filters.py')
    if os.path.exists(theme_config):
        execfile(theme_config, {}, config)

    jinja.filters.update(config)

    #: load filters from settings
    filters = settings.template.get("filters") or {}
    for k, v in filters.items():
        jinja.filters.update({k: import_object(v)})

    #: default filters
    jinja.filters.update({
        'xmldatetime': xmldatetime,
        'feed_updated': feed_updated,
        'permalink': permalink,
        'tag_url': tag_url,
        'year_url': year_url,
        'wiki_link': wiki_link,
    })

    #: load resource
    g.resource['posts'] = g.public_posts
    g.resource['pages'] = g.pure_pages
    jinja.globals.update({
        'resource': g.resource,
    })

    g.jinja = jinja
    return jinja


def get_post_slug(post, slug_format):
    regex = re.compile(r'\{\{(.*?)\}\}')

    def replace(m):
        key = m.group(1)
        bits = key.split('.')
        value = post

        for bit in bits:
            if not hasattr(value, bit):
                return ''
            value = getattr(value, bit)

        if not value:
            return ''

        if isinstance(value, int) and value < 10:
            #: fix on month and date value
            value = '0%d' % value
        return to_unicode(value)

    slug = regex.sub(replace, slug_format)
    slug = slug.lstrip('/').replace('//', '/').replace(' ', '-')
    prefix = settings.site.get('prefix', '').rstrip('/')
    slug = slug.lower()
    if prefix:
        return '%s/%s' % (prefix, slug)
    return slug


def get_post_destination(post, slug_format):
    slug = get_post_slug(post, slug_format)
    if slug.endswith('.html'):
        return slug

    return slug.rstrip('/') + '.html'


@contextfilter
def permalink(ctx, post, prepend_site=False):
    writer = ctx.get('writer')
    slug = get_post_slug(post, settings.config["permalink"])

    if prepend_site:
        url = '%s/%s' % (settings.site['url'].rstrip('/'), slug)
    elif settings.config['relative_url'] and writer:
        base = get_relative_base(writer['filepath'])
        url = '%s/%s' % (base, slug)
    else:
        url = '/%s' % slug

    if url.endswith('/index.html'):
        return url[:-10]
    return url

########NEW FILE########
__FILENAME__ = contrib
#!/usr/bin/env python

"""Writers from contributors
"""

########NEW FILE########
__FILENAME__ = core
#!/usr/bin/env python

import os
import logging
from liquidluck.options import g, settings
from liquidluck.utils import UnicodeDict, walk_dir, copy_to
from liquidluck.writers.base import BaseWriter, Pagination
from liquidluck.writers.base import get_post_destination


class PostWriter(BaseWriter):
    writer_name = 'post'

    def __init__(self):
        self._template = self.get('post_template', 'post.html')

    def start(self):
        for post in g.public_posts:
            template = post.template or self._template
            self.render({'post': post}, template, self._dest_of(post))

        for post in g.secure_posts:
            template = post.template or self._template
            self.render({'post': post}, template, self._dest_of(post))

    def _dest_of(self, post):
        dest = get_post_destination(post, settings.config['permalink'])
        return os.path.join(g.output_directory, dest)


class PageWriter(BaseWriter):
    writer_name = 'page'

    def __init__(self):
        self._template = self.get('page_template', 'page.html')

    def start(self):
        l = len(g.source_directory) + 1
        for post in g.pure_pages:
            template = post.template or self._template
            filename = os.path.splitext(post.filepath[l:])[0] + '.html'
            dest = os.path.join(g.output_directory, filename)
            self.render({'post': post}, template, dest)


class ArchiveWriter(BaseWriter):
    writer_name = 'archive'

    def __init__(self):
        self._template = self.get('archive_template', 'archive.html')
        self._output = self.get(
            'archive_output', self.prefix_dest('index.html'))
        self._title = self.get('archive_title', 'Archive')

    def start(self):
        pagination = Pagination(g.public_posts, 1, self.perpage)
        pagination.title = self._title
        pagination.root = self.prefix_dest('')

        dest = os.path.join(g.output_directory, self._output)
        self.render({'pagination': pagination}, self._template, dest)

        if pagination.pages < 2:
            return

        for page in range(1, pagination.pages + 1):
            pagination = Pagination(g.public_posts, page, self.perpage)
            pagination.title = self._title
            pagination.root = self.prefix_dest('')
            dest = os.path.join(g.output_directory, 'page/%s.html' % page)
            if pagination.root:
                dest = os.path.join(
                    g.output_directory,
                    pagination.root,
                    'page/%s.html' % page
                )
            self.render({'pagination': pagination}, self._template, dest)

    def prefix_dest(self, dest):
        prefix = settings.site.get('prefix', '').rstrip('/')
        if not dest:
            return prefix
        if prefix:
            return '%s/%s' % (prefix, dest)
        if isinstance(dest, int):
            dest = str(dest)
        return dest


class ArchiveFeedWriter(ArchiveWriter):
    writer_name = 'archive_feed'

    def __init__(self):
        self._template = self.get('archive_feed_template', 'feed.xml')
        self._output = self.get(
            'archive_feed_output', self.prefix_dest('feed.xml')
        )

    def start(self):
        feed = UnicodeDict()
        feed.url = self.prefix_dest('index.html')
        feed.feedurl = self._output
        feed.posts = g.public_posts[:settings.config['feedcount']]

        dest = os.path.join(g.output_directory, self._output)
        self.render({'feed': feed}, self._template, dest)


class FileWriter(BaseWriter):
    writer_name = 'file'

    def __init__(self):
        g.resource['files'] = g.pure_files

    def start(self):
        l = len(g.source_directory) + 1
        for f in g.pure_files:
            path = f[l:]
            logging.debug('copy %s' % path)
            dest = os.path.join(g.output_directory, path)
            copy_to(f, dest)


class StaticWriter(BaseWriter):
    def start(self):
        static_path = os.path.join(g.theme_directory, 'static')
        l = len(static_path) + 1
        for f in walk_dir(static_path):
            path = f[l:]
            logging.debug('copy %s' % path)
            dest = os.path.join(g.static_directory, path)
            copy_to(f, dest)


class YearWriter(ArchiveWriter):
    writer_name = 'year'

    def __init__(self):
        self._posts = {}
        self._template = self.get('year_template', 'archive.html')

        for post in g.public_posts:
            if post.date.year not in self._posts:
                self._posts[post.date.year] = [post]
            else:
                self._posts[post.date.year].append(post)

        g.resource['year'] = self._posts

    def start(self):
        for year in self._posts:
            self._write_posts(year)

    def _write_posts(self, year):
        posts = self._posts[year]
        pagination = Pagination(posts, 1, self.perpage)
        pagination.title = year
        pagination.root = self.prefix_dest(year)

        dest = os.path.join(g.output_directory, pagination.root, 'index.html')
        self.render({'pagination': pagination}, self._template, dest)

        if pagination.pages < 2:
            return

        for page in range(1, pagination.pages + 1):
            pagination = Pagination(posts, page, self.perpage)
            pagination.title = year
            pagination.root = self.prefix_dest(year)

            dest = os.path.join(
                g.output_directory,
                pagination.root,
                'page/%s.html' % page
            )
            self.render({'pagination': pagination}, self._template, dest)


class TagWriter(ArchiveWriter):
    writer_name = 'tag'

    def __init__(self):
        self._posts = {}
        self._template = self.get('tag_template', 'archive.html')

        for post in g.public_posts:
            for tag in post.tags:
                if tag not in self._posts:
                    self._posts[tag] = [post]
                else:
                    self._posts[tag].append(post)

        g.resource['tag'] = self._posts

    def start(self):
        for tag in self._posts:
            self._write_posts(tag)

    def _write_posts(self, tag):
        posts = self._posts[tag]
        pagination = Pagination(posts, 1, self.perpage)
        pagination.title = tag
        pagination.root = self.prefix_dest('tag/%s' % tag)

        dest = os.path.join(g.output_directory, pagination.root, 'index.html')
        self.render({'pagination': pagination}, self._template, dest)

        if pagination.pages < 2:
            return

        for page in range(1, pagination.pages + 1):
            pagination = Pagination(posts, page, self.perpage)
            pagination.title = tag
            pagination.root = self.prefix_dest('tag/%s' % tag)

            dest = os.path.join(
                g.output_directory, pagination.root, 'page/%s.html' % page
            )
            self.render({'pagination': pagination}, self._template, dest)


class TagCloudWriter(ArchiveWriter):
    writer_name = 'tagcloud'

    def __init__(self):
        self._posts = {}
        self._template = self.get('tagcloud_template', 'tagcloud.html')
        if 'tag' in g.resource:
            self._posts = g.resource['tag']
            return

        for post in g.public_posts:
            for tag in post.tags:
                if tag not in self._posts:
                    self._posts[tag] = [post]
                else:
                    self._posts[tag].append(post)

        g.resource['tag'] = self._posts

    def start(self):
        dest = os.path.join(
            g.output_directory, self.prefix_dest('tag/index.html')
        )
        self.render({'tags': self._posts}, self._template, dest)


class CategoryWriter(ArchiveWriter):
    writer_name = 'category'

    def __init__(self):
        self._posts = {}
        self._template = self.get('category_template', 'archive.html')
        self._title = self.get('category_title', {})

        for post in g.public_posts:
            if post.category:
                if post.category not in self._posts:
                    self._posts[post.category] = [post]
                else:
                    self._posts[post.category].append(post)

        g.resource['category'] = self._posts

    def start(self):
        for category in self._posts:
            self._write_posts(category)

    def _write_posts(self, category):
        posts = self._posts[category]
        pagination = Pagination(posts, 1, self.perpage)
        pagination.title = self._title.get(category, category)
        pagination.root = self.prefix_dest(category)

        dest = os.path.join(g.output_directory, pagination.root, 'index.html')
        self.render({'pagination': pagination}, self._template, dest)

        if pagination.pages < 2:
            return

        for page in range(1, pagination.pages + 1):
            pagination = Pagination(posts, page, self.perpage)
            pagination.title = self._title.get(category, category)
            pagination.root = self.prefix_dest(category)

            dest = os.path.join(
                g.output_directory, pagination.root, 'page/%s.html' % page
            )
            self.render({'pagination': pagination}, self._template, dest)


class CategoryFeedWriter(ArchiveWriter):
    writer_name = 'category_feed'

    def __init__(self):
        self._posts = {}
        self._template = self.get('category_feed_template', 'feed.xml')
        self._output = self.get('category_feed_output', 'feed.xml')

        if 'category' in g.resource:
            self._posts = g.resource['category']
            return

        for post in g.public_posts:
            if post.category:
                if post.category not in self._posts:
                    self._posts[post.category] = [post]
                else:
                    self._posts[post.category].append(post)

    def start(self):
        for category in self._posts:
            feed = UnicodeDict()
            feed.url = self.prefix_dest('%s/index.html' % category)
            feed.feedurl = self.prefix_dest('%s/%s' % (category, self._output))
            feed.posts = self._posts[category][:settings.config['feedcount']]
            dest = os.path.join(g.output_directory, feed.feedurl)
            self.render({'feed': feed}, self._template, dest)

########NEW FILE########
__FILENAME__ = extends
#!/usr/bin/env python

"""Extends of the core writers
"""

import os
from liquidluck.options import g, settings
from liquidluck.writers.base import BaseWriter
from liquidluck.writers.base import get_post_destination


class PostWriter(BaseWriter):
    """Replace the default post writer, edit settings::

        writers = {
            'post': 'liquidluck.writers.exends.PostWriter',
        }

    Get related posts in template with::

        - {{post.relation.newer}}
        - {{post.relation.older}}
        - {% for item in post.relation.related %}
    """
    writer_name = 'post'

    def __init__(self):
        self._template = self.get('post_template', 'post.html')

    def start(self):
        for index, post in enumerate(g.public_posts):
            template = post.template or self._template

            relation = self._get_relations(post, index)
            post.relation = relation
            self.render({'post': post}, template, self._dest_of(post))

        for post in g.secure_posts:
            post.relation = None
            self.render({'post': post}, template, self._dest_of(post))

    def _dest_of(self, post):
        dest = get_post_destination(post, settings.config['permalink'])
        return os.path.join(g.output_directory, dest)

    def _get_relations(self, post, index):
        total = len(g.public_posts)

        newer = None
        if index > 0:
            newer = g.public_posts[index - 1]

        older = None
        if index < total - 1:
            older = g.public_posts[index + 1]

        def get_related_by_tags():
            tags = set(post.tags)
            base = len(post.tags)

            for p in g.public_posts:
                prior = len(tags - set(p.tags))
                if prior < base and p.title != post.title:
                    p.related_priority = base - prior
                    yield p

        related = sorted(get_related_by_tags(),
                         key=lambda o: o.related_priority,
                         reverse=True)
        relation = {
            'newer': newer,
            'older': older,
            'related': related[:4],
        }
        return relation

########NEW FILE########
__FILENAME__ = theme
#!/usr/bin/env python

name = 'moment'
version = '1.0'
website = 'https://github.com/lepture/liquidluck-theme-moment'
author = {
    'name': 'Hsiaoming Yang',
    'website': 'http://lepture.com',
}


lang = 'en'

navigation = [
    {'title': 'Home', 'link': '/'},
    {'title': 'About', 'link': '/about.html'},
]

twitter = 'lepture'
github = None
disqus = None
analytics = None

allow_comment_on_secret_post = False


#: key-value descriptions
descriptions = {}

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-

author = {
    'default': 'lepture',
}

config = {
    'source': 'post',
    'output': 'build/deploy',
    'static': 'build/deploy/static',
}

#: active readers
reader = {
    'active': [
        'liquidluck.readers.markdown.MarkdownReader',
        'liquidluck.readers.restructuredtext.RestructuredTextReader',
    ],
}

#: active writers
writer = {
    'active': [
        'liquidluck.writers.core.PostWriter',
        'liquidluck.writers.core.PageWriter',
        'liquidluck.writers.core.ArchiveWriter',
        'liquidluck.writers.core.ArchiveFeedWriter',
        'liquidluck.writers.core.FileWriter',
        'liquidluck.writers.core.StaticWriter',
        'liquidluck.writers.core.YearWriter',
        'liquidluck.writers.core.CategoryWriter',
        'liquidluck.writers.core.CategoryFeedWriter',
        'liquidluck.writers.core.TagCloudWriter',
    ],
    'vars': {
    }
}

########NEW FILE########
__FILENAME__ = test_filters
import os
from liquidluck.filters import content_url, static_url
from liquidluck.options import settings
ROOT = os.path.abspath(os.path.dirname(__file__))


def test_content_url():
    ctx = {'writer': {'filepath': 'a/b'}}

    assert content_url(ctx, 'index.html') == '/'

    settings.config['permalink'] = '{{category}}/{{filename}}.html'
    assert content_url(ctx, 10) == '/10.html'
    assert content_url(ctx, 'a') == '/a.html'
    assert content_url(ctx, 'a.html') == '/a.html'
    assert content_url(ctx, 'a/') == '/a.html'
    assert content_url(ctx, 'a', 'b') == '/a/b.html'
    assert content_url(ctx, 'a/index.html') == '/a/'
    assert content_url(ctx, 'a/feed.xml') == '/a/feed.xml'
    assert content_url(ctx, 10) == '/10.html'

    settings.config['permalink'] = '{{category}}/{{filename}}'
    assert content_url(ctx, 'a') == '/a'
    assert content_url(ctx, 'a.html') == '/a'
    assert content_url(ctx, 'a/') == '/a'
    assert content_url(ctx, 'a', 'b') == '/a/b'
    assert content_url(ctx, 'a/index.html') == '/a/'
    assert content_url(ctx, 'a/feed.xml') == '/a/feed'
    assert content_url(ctx, 10) == '/10'

    settings.config['permalink'] = '{{category}}/{{filename}}/'
    assert content_url(ctx, 'a') == '/a/'
    assert content_url(ctx, 'a.html') == '/a/'
    assert content_url(ctx, 'a/') == '/a/'
    assert content_url(ctx, 'a', 'b') == '/a/b/'
    assert content_url(ctx, 'a/index.html') == '/a/'
    assert content_url(ctx, 'a/feed.xml') == '/a/feed/'
    assert content_url(ctx, 10) == '/10/'

    settings.config['permalink'] = '{{category}}/{{filename}}'
    settings.config['relative_url'] = True
    assert content_url(ctx, 'a') == '../a'
    assert content_url(ctx, 'a/b') == '../a/b'
    assert content_url(ctx, '/a/b') == '../a/b'

    settings.config['relative_url'] = False


def test_static_url():
    path = os.path.join(ROOT, 'source')
    ctx = {'writer': {'filepath': 'a/b'}}
    func = static_url(path)
    func(ctx, 'settings.py')
    path = os.path.join(ROOT, 'source', 'post')
    func = static_url(path)
    func(ctx, 'demo-rst-1.rst')

########NEW FILE########
__FILENAME__ = test_generator
#!/usr/bin/env python

import os.path
from liquidluck.generator import load_settings, load_posts

ROOT = os.path.abspath(os.path.dirname(__file__))


def test_load_settings():
    path = os.path.join(ROOT, 'source/settings.py')
    load_settings(path)

    from liquidluck.options import settings
    assert settings.author['default'] == 'lepture'


def test_load_posts():
    load_posts(os.path.join(ROOT, 'source/post'))
    from liquidluck.options import g
    assert len(g.public_posts) > 0

########NEW FILE########
__FILENAME__ = test_readers
#!/usr/bin/env python

import os.path
import datetime
from liquidluck.readers.base import BaseReader, Post
from liquidluck.readers.markdown import MarkdownReader
from liquidluck.readers.restructuredtext import RestructuredTextReader

ROOT = os.path.abspath(os.path.dirname(__file__))


class TestPost(object):
    def setUp(self):
        self.meta = {
            'author': 'lepture',
            'date': '2012-12-12',
            'tags': 'life, work',
        }

    def test_author(self):
        post = Post('filepath', 'content', title='title', meta=self.meta)
        assert str(post.author) == 'lepture'

    def test_date(self):
        post = Post('filepath', 'content', title='title', meta=self.meta)
        assert post.date == datetime.datetime(2012, 12, 12)

    def test_updated(self):
        path = os.path.join(ROOT, 'source', 'post', 'demo-rst-1.rst')
        post = Post(path, 'content', title='title', meta=self.meta)
        assert isinstance(post.updated, datetime.datetime)

    def test_public(self):
        meta = {'public': 'false'}
        post = Post('filepath', 'content', title='title', meta=meta)
        assert post.public is False

        post = Post('filepath', 'content', title='title', meta={})
        assert post.public is True

        meta = {'public': 'true'}
        post = Post('filepath', 'content', title='title', meta=meta)
        assert post.public is True

    def test_tags(self):
        post = Post('filepath', 'content', title='title', meta=self.meta)
        assert post.tags == ['life', 'work']

    def test_getattr(self):
        meta = {'date': '2012-12-12', 'topic': 'getattr'}
        post = Post('filepath', 'content', title='title', meta=meta)

        assert getattr(getattr(post, 'date'), 'year') == 2012
        assert hasattr(post, 'topic') is True
        assert getattr(post, 'topic') == 'getattr'


class TestBaseReade(object):
    def test_support(self):

        class TestReader(BaseReader):
            SUPPORT_TYPE = ['md', 'markdown']

        assert TestReader.SUPPORT_TYPE == ['md', 'markdown']

        reader = TestReader('filename.md')
        assert reader.support() is True

        reader = TestReader('filename.mkd')
        assert reader.support() is False


class TestMarkdownReader(object):
    def setUp(self):
        path = os.path.join(ROOT, 'source/post/demo-markdown-1.md')
        self.reader = MarkdownReader(path)
        self.post = self.reader.render()

    def test_title(self):
        assert self.post.title == 'demo'

    def test_tags(self):
        assert self.post.tags == ['tag1', 'tag2']

    def test_public(self):
        assert self.post.public is True

    def test_pygments(self):
        assert 'highlight' in self.post.content


class TestRestructuredTextReader(object):
    def setUp(self):
        path = os.path.join(ROOT, 'source/post/demo-rst-1.rst')
        self.reader = RestructuredTextReader(path)
        self.post = self.reader.render()

    def test_title(self):
        assert self.post.title == 'rst'

    def test_tags(self):
        assert self.post.tags == ['tag1', 'tag2']

    def test_public(self):
        assert self.post.public is False

    def test_pygments(self):
        assert 'highlight' in self.post.content

########NEW FILE########
__FILENAME__ = test_writers_base
#!/usr/bin/env python

import os
import datetime
from liquidluck.writers.base import Pagination
from liquidluck.writers.base import get_post_slug
from liquidluck.writers.base import load_jinja
from liquidluck.options import settings

ROOT = os.path.abspath(os.path.dirname(__file__))


class TestPagination(object):
    def test_pages(self):
        p = Pagination(range(6), 1, 3)
        assert p.pages == 2

        p = Pagination(range(5), 1, 3)
        assert p.pages == 2

        p = Pagination(range(7), 1, 3)
        assert p.pages == 3

    def test_items(self):
        items = [0, 1, 2, 3, 4, 5]
        p = Pagination(items, 1, 3)
        assert p.items == [0, 1, 2]

        p = Pagination(items, 2, 3)
        assert p.items == [3, 4, 5]


def test_get_post_slug():
    class Post:
        filename = 'demo'

        @property
        def category(self):
            return 'life'

        @property
        def date(self):
            return datetime.datetime(2012, 12, 12)

        @property
        def folder(self):
            return None

    post = Post()

    settings.site['prefix'] = ''
    slug_format = '{{category}}/{{filename}}.html'
    assert get_post_slug(post, slug_format) == 'life/demo.html'

    slug_format = '{{date.year}}/{{filename}}.html'
    assert get_post_slug(post, slug_format) == '2012/demo.html'

    slug_format = '{{folder}}/{{filename}}.html'
    assert get_post_slug(post, slug_format) == 'demo.html'

    settings.site['prefix'] = 'blog'
    slug_format = '{{category}}/{{filename}}.html'
    assert get_post_slug(post, slug_format) == 'blog/life/demo.html'


def test_load_jinja():
    load_jinja()

########NEW FILE########
__FILENAME__ = test_writers_core
#!/usr/bin/env python

import os
from liquidluck.writers.core import PostWriter, PageWriter
from liquidluck.writers.core import ArchiveWriter, ArchiveFeedWriter
from liquidluck.writers.core import FileWriter, StaticWriter
from liquidluck.writers.core import YearWriter, TagWriter
from liquidluck.writers.core import CategoryWriter, CategoryFeedWriter
from liquidluck.options import settings, g

ROOT = os.path.abspath(os.path.dirname(__file__))


class TestPostWriter(object):
    def test_start(self):
        writer = PostWriter()
        settings.config['permalink'] = '{{category}}/{{filename}}.html'
        settings.site['prefix'] = ''
        writer.start()
        f = os.path.join(g.output_directory, 'work/demo-markdown-1.html')
        assert os.path.exists(f)

        f = os.path.join(g.output_directory, 'work/reset/filename.html')
        assert os.path.exists(f)

        settings.config['permalink'] = '{{date.year}}/{{filename}}.html'
        writer.start()
        f = os.path.join(g.output_directory, '2012/demo-markdown-1.html')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer.start()
        f = os.path.join(g.output_directory, 'blog/2012/demo-markdown-1.html')
        assert os.path.exists(f)


class TestPageWriter(object):
    def test_start(self):
        writer = PageWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'demo-page.html')
        assert os.path.exists(f)


class TestArchiveWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = ArchiveWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'index.html')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = ArchiveWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/index.html')
        assert os.path.exists(f)


class TestArchiveFeedWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = ArchiveFeedWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'feed.xml')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = ArchiveFeedWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/feed.xml')
        assert os.path.exists(f)


class TestFileWriter(object):
    def test_start(self):
        writer = FileWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'media/hold.txt')
        assert os.path.exists(f)


class TestStaticWriter(object):
    def test_start(self):
        writer = StaticWriter()
        writer.start()
        f = os.path.join(g.static_directory, 'style.css')
        assert os.path.exists(f)


class TestYearWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = YearWriter()
        writer.start()
        f = os.path.join(g.output_directory, '2012/index.html')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = YearWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/2012/index.html')
        assert os.path.exists(f)


class TestTagWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = TagWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'tag/tag1/index.html')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = TagWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/tag/tag1/index.html')
        assert os.path.exists(f)


class TestCategoryWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = CategoryWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'work/index.html')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = CategoryWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/work/index.html')
        assert os.path.exists(f)


class TestCategoryFeedWriter(object):
    def test_start(self):
        settings.site['prefix'] = ''
        writer = CategoryFeedWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'work/feed.xml')
        assert os.path.exists(f)

        settings.site['prefix'] = 'blog'
        writer = CategoryFeedWriter()
        writer.start()
        f = os.path.join(g.output_directory, 'blog/work/feed.xml')
        assert os.path.exists(f)

########NEW FILE########
__FILENAME__ = test_writers_extends
#!/usr/bin/env python

import os
from liquidluck.writers.extends import PostWriter
from liquidluck.options import g

ROOT = os.path.abspath(os.path.dirname(__file__))


class TestPostWriter(object):
    def test_get_relations(self):
        post = g.public_posts[0]
        writer = PostWriter()
        relation = writer._get_relations(post, 0)
        assert relation['newer'] is None
        assert relation['older'] is not None
        assert relation['related'] is not None

########NEW FILE########
