__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-User documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 22 12:49:47 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

sys.path.append(os.path.abspath('_themes'))
sys.path.append(os.path.abspath('.'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.intersphinx',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-User'
copyright = u'2013, Ling Thio and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The full version, including alpha/beta/rc tags.
release = '0.3.5'
# The short X.Y version.
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'nature'
html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    '**': ['globaltoc.html', 'searchbox.html'],
    }

html_use_modindex = False

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Userdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'Flask-User.tex', u'Flask-User Documentation',
   u'Ling Thio and contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-user', u'Flask-User Documentation',
     [u'Ling Thio and contributors'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Flask-User', u'Flask-User Documentation',
   u'Ling Thio and contributors', 'Flask-User', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = basic_app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.mail import Mail
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import current_user, login_required, UserManager, UserMixin, SQLAlchemyAdapter

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'               # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///basic_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True

    # Configure Flask-Mail -- Required for Confirm email and Forgot password features
    MAIL_SERVER   = 'smtp.gmail.com'
    MAIL_PORT     = 465
    MAIL_USE_SSL  = True                            # Some servers use MAIL_USE_TLS=True instead
    MAIL_USERNAME = 'email@example.com'
    MAIL_PASSWORD = 'password'
    MAIL_DEFAULT_SENDER = '"Sender" <noreply@example.com>'

    # Configure Flask-User
    USER_ENABLE_USERNAME         = True
    USER_ENABLE_CONFIRM_EMAIL    = True
    USER_ENABLE_CHANGE_USERNAME  = True
    USER_ENABLE_CHANGE_PASSWORD  = True
    USER_ENABLE_FORGOT_PASSWORD  = True
    USER_ENABLE_RETYPE_PASSWORD  = True

def create_app(test_config=None):                   # For automated tests
    # Setup Flask and read config from ConfigClass defined above
    app = Flask(__name__)
    app.config.from_object(__name__+'.ConfigClass')

    # Load local_settings.py if file exists         # For automated tests
    try: app.config.from_object('local_settings')
    except: pass

    # Load optional test_config                     # For automated tests
    if test_config:
        app.config.update(test_config)

    # Initialize Flask extensions
    babel = Babel(app)                              # Initialize Flask-Babel
    db = SQLAlchemy(app)                            # Initialize Flask-SQLAlchemy
    mail = Mail(app)                                # Initialize Flask-Mail

    @babel.localeselector
    def get_locale():
        translations = [str(translation) for translation in babel.list_translations()]
        return request.accept_languages.best_match(translations)

    # Define User model. Make sure to add flask.ext.user UserMixin!!
    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        active = db.Column(db.Boolean(), nullable=False, default=False)
        email = db.Column(db.String(255), nullable=False, unique=True)
        password = db.Column(db.String(255), nullable=False, default='')
        username = db.Column(db.String(50), nullable=False, unique=True)
        confirmed_at = db.Column(db.DateTime())
        reset_password_token = db.Column(db.String(100), nullable=False, default='')

    # Create all database tables
    db.create_all()

    # Setup Flask-User
    db_adapter = SQLAlchemyAdapter(db,  User)       # Select database adapter
    user_manager = UserManager(db_adapter, app)     # Init Flask-User and bind to app

    # The '/' page is accessible to anyone
    @app.route('/')
    def home_page():
        if current_user.is_authenticated():
            return profile_page()
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Home Page{%endtrans%}</h2>
            <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/profile' page requires a logged-in user
    @app.route('/profile')
    @login_required                                 # Use of @login_required decorator
    def profile_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
                <h2>{%trans%}Profile Page{%endtrans%}</h2>
                <p> {%trans%}Hello{%endtrans%}
                    {{ current_user.username or current_user.email }},</p>
                <p> <a href="{{ url_for('user.change_username') }}">
                    {%trans%}Change username{%endtrans%}</a></p>
                <p> <a href="{{ url_for('user.change_password') }}">
                    {%trans%}Change password{%endtrans%}</a></p>
                <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                    {%trans%}Sign out{%endtrans%}</a></p>
            {% endblock %}
            """)

    return app

# Start development web server
if __name__=='__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=True)


########NEW FILE########
__FILENAME__ = minimal_app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import current_user, login_required, UserManager, UserMixin, SQLAlchemyAdapter

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'                 # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///minimal_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True

# Setup Flask and read config from ConfigClass defined above
app = Flask(__name__)
app.config.from_object(__name__+'.ConfigClass')

# Initialize Flask extensions
babel = Babel(app)                              # Initialize Flask-Babel
db = SQLAlchemy(app)                            # Initialize Flask-SQLAlchemy

@babel.localeselector
def get_locale():
    translations = [str(translation) for translation in babel.list_translations()]
    return request.accept_languages.best_match(translations)

# Define User model. Make sure to add flask.ext.user UserMixin!!
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    active = db.Column(db.Boolean(), nullable=False, default=False)
    email = db.Column(db.String(255), nullable=False, unique=True)
    password = db.Column(db.String(255), nullable=False, default='')

# Create all database tables
db.create_all()

# Setup Flask-User
db_adapter = SQLAlchemyAdapter(db,  User)       # Select database adapter
user_manager = UserManager(db_adapter, app)     # Init Flask-User and bind to app

# The '/' page is accessible to anyone
@app.route('/')
def home_page():
    if current_user.is_authenticated():
        return profile_page()
    return render_template_string("""
        {% extends "base.html" %}
        {% block content %}
        <h2>{%trans%}Home Page{%endtrans%}</h2>
        <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
        {% endblock %}
        """)

# The '/profile' page requires a logged-in user
@app.route('/profile')
@login_required                                 # Use of @login_required decorator
def profile_page():
    return render_template_string("""
        {% extends "base.html" %}
        {% block content %}
            <h2>{%trans%}Profile Page{%endtrans%}</h2>
            <p> {%trans%}Hello{%endtrans%}
                {{ current_user.username or current_user.email }},</p>
            <p> <a href="{{ url_for('user.change_password') }}">
                {%trans%}Change password{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                {%trans%}Sign out{%endtrans%}</a></p>
        {% endblock %}
        """)

# Start development web server
if __name__=='__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)


########NEW FILE########
__FILENAME__ = app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.mail import Mail
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import current_user, login_required, roles_required, SQLAlchemyAdapter, UserManager, UserMixin
from flask.ext.user.forms import RegisterForm
from wtforms import validators
from wtforms import StringField

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'                       # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///register_form_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True


class MyRegisterForm(RegisterForm):
    first_name = StringField('First name', validators=[
        validators.Required('First name is required')])
    last_name = StringField('Last name', validators=[
        validators.Required('Last name is required')])

def create_app(test_config=None):                   # For automated tests
    # Setup Flask and read config from ConfigClass defined above
    app = Flask(__name__)
    app.config.from_object(__name__+'.ConfigClass')

    # Load local_settings.py if file exists         # For automated tests
    try: app.config.from_object('local_settings')
    except: pass

    # Over-write app config                         # For automated tests
    if test_config:
        for key, value in test_config.items():
            app.config[key] = value

    # Setup Flask-Mail, Flask-Babel and Flask-SQLAlchemy
    app.mail = Mail(app)
    app.babel = babel = Babel(app)
    app.db = db = SQLAlchemy(app)

    @babel.localeselector
    def get_locale():
        translations = [str(translation) for translation in babel.list_translations()]
        return request.accept_languages.best_match(translations)

    # Define the User-Roles pivot table
    user_roles = db.Table('user_roles',
        db.Column('id', db.Integer(), primary_key=True),
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id', ondelete='CASCADE')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id', ondelete='CASCADE')))

    # Define Role model
    class Role(db.Model):
        id = db.Column(db.Integer(), primary_key=True)
        name = db.Column(db.String(50), unique=True)

    # Define User model. Make sure to add flask.ext.user UserMixin!!
    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        # Flask-User fields
        active = db.Column(db.Boolean(), nullable=False, default=False)
        email = db.Column(db.String(255), nullable=False, default='')
        password = db.Column(db.String(255), nullable=False, default='')
        # Application fields
        first_name = db.Column(db.String(50), nullable=False, default='')
        last_name = db.Column(db.String(50), nullable=False, default='')
        # Relationships
        roles = db.relationship('Role', secondary=user_roles,
                backref=db.backref('users', lazy='dynamic'))

    # Reset all the database tables
    db.create_all()

    # Setup Flask-User
    db_adapter = SQLAlchemyAdapter(db,  User)
    user_manager = UserManager(db_adapter, app,
            register_form=MyRegisterForm)

    # The '/' page is accessible to anyone
    @app.route('/')
    def home_page():
        if current_user.is_authenticated():
            return profile_page()
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Home Page{%endtrans%}</h2>
            <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/profile' page requires a logged-in user
    @app.route('/profile')
    @login_required                                 # Use of @login_required decorator
    def profile_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Profile Page{%endtrans%}</h2>
            <p> {%trans%}Hello{%endtrans%}
                {{ current_user.first_name }},</p>
            <p> <a href="{{ url_for('user.change_password') }}">
                {%trans%}Change password{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                {%trans%}Sign out{%endtrans%}</a></p>
            {% endblock %}
            """)

    return app

# Start development web server
if __name__=='__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=True)

########NEW FILE########
__FILENAME__ = roles_required_app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.mail import Mail
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import current_user, login_required, SQLAlchemyAdapter, UserManager, UserMixin
from flask.ext.user import roles_required

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'                        # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///roles_required_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True

    # Configure Flask-Mail -- Required for Confirm email and Forgot password features
    MAIL_SERVER   = 'smtp.gmail.com'
    MAIL_PORT     = 465
    MAIL_USE_SSL  = True                            # Some servers use MAIL_USE_TLS=True instead
    MAIL_USERNAME = 'email@example.com'
    MAIL_PASSWORD = 'password'
    MAIL_DEFAULT_SENDER = '"Sender" <noreply@example.com>'

    # Configure Flask-User
    USER_ENABLE_USERNAME        = True              # Register and Login with username
    USER_ENABLE_EMAIL           = True              # Register with email
    USER_ENABLE_CONFIRM_EMAIL   = True              # Require email confirmation
    USER_ENABLE_CHANGE_USERNAME = True
    USER_ENABLE_CHANGE_PASSWORD = True
    USER_ENABLE_FORGOT_PASSWORD = True

def create_app(test_config=None):                   # For automated tests
    # Setup Flask and read config from ConfigClass defined above
    app = Flask(__name__)
    app.config.from_object(__name__+'.ConfigClass')

    # Load local_settings.py if file exists         # For automated tests
    try: app.config.from_object('local_settings')
    except: pass

    # Load optional test_config                     # For automated tests
    if test_config:
        app.config.update(test_config)

    # Initialize Flask extensions
    babel = Babel(app)                              # Initialize Flask-Babel
    mail = Mail(app)                                # Initialize Flask-Mail
    db = SQLAlchemy(app)                            # Initialize Flask-SQLAlchemy

    @babel.localeselector
    def get_locale():
        translations = [str(translation) for translation in babel.list_translations()]
        return request.accept_languages.best_match(translations)

    # Define the User-Roles pivot table
    user_roles = db.Table('user_roles',
        db.Column('id', db.Integer(), primary_key=True),
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id', ondelete='CASCADE')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id', ondelete='CASCADE')))

    # Define Role model
    class Role(db.Model):
        id = db.Column(db.Integer(), primary_key=True)
        name = db.Column(db.String(50), unique=True)

    # Define User model. Make sure to add flask.ext.user UserMixin!!
    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        active = db.Column(db.Boolean(), nullable=False, default=False)
        username = db.Column(db.String(50), nullable=False, unique=True)
        email = db.Column(db.String(255), nullable=False, unique=True)
        confirmed_at = db.Column(db.DateTime())
        password = db.Column(db.String(255), nullable=False, default='')
        reset_password_token = db.Column(db.String(100), nullable=False, default='')
        # Relationships
        roles = db.relationship('Role', secondary=user_roles,
                backref=db.backref('users', lazy='dynamic'))

    # Reset all the database tables
    db.create_all()

    # Setup Flask-User
    db_adapter = SQLAlchemyAdapter(db,  User)
    user_manager = UserManager(db_adapter, app)

    # Create 'user007' user with 'secret' and 'agent' roles
    if not User.query.filter(User.username=='user007').first():
        user1 = User(username='user007', email='user007@example.com', active=True,
                password=user_manager.hash_password('Password1'))
        user1.roles.append(Role(name='secret'))
        user1.roles.append(Role(name='agent'))
        db.session.add(user1)
        db.session.commit()

    # The '/' page is accessible to anyone
    @app.route('/')
    def home_page():
        if current_user.is_authenticated():
            return profile_page()
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Home Page{%endtrans%}</h2>
            <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/profile' page requires a logged-in user
    @app.route('/profile')
    @login_required                                 # Use of @login_required decorator
    def profile_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Profile Page{%endtrans%}</h2>
            <p> {%trans%}Hello{%endtrans%}
                {{ current_user.username or current_user.email }},</p>
            <p> <a href="{{ url_for('user.change_username') }}">
                {%trans%}Change username{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.change_password') }}">
                {%trans%}Change password{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                {%trans%}Sign out{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/special' page requires a user that has the 'special' AND ('sauce' OR 'agent') role.
    @app.route('/special')
    @roles_required('secret', ['sauce', 'agent'])   # Use of @roles_required decorator
    def special_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Special Page{%endtrans%}</h2>
            {% endblock %}
            """)

    return app

# Start development web server
if __name__=='__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=True)

########NEW FILE########
__FILENAME__ = app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.mail import Mail
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import current_user, login_required, roles_required, SQLAlchemyAdapter, UserManager, UserMixin
from flask.ext.user.forms import RegisterForm
from wtforms import validators
from wtforms import StringField

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'                      # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///user_profile_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True


class MyRegisterForm(RegisterForm):
    first_name = StringField('First name', validators=[
        validators.Required('First name is required')])
    last_name = StringField('Last name', validators=[
        validators.Required('Last name is required')])

def create_app(test_config=None):                   # For automated tests
    # Setup Flask and read config from ConfigClass defined above
    app = Flask(__name__)
    app.config.from_object(__name__+'.ConfigClass')

    # Load local_settings.py if file exists         # For automated tests
    try: app.config.from_object('local_settings')
    except: pass

    # Over-write app config                         # For automated tests
    if test_config:
        for key, value in test_config.items():
            app.config[key] = value

    # Setup Flask-Mail, Flask-Babel and Flask-SQLAlchemy
    app.mail = Mail(app)
    app.babel = babel = Babel(app)
    app.db = db = SQLAlchemy(app)

    @babel.localeselector
    def get_locale():
        translations = [str(translation) for translation in babel.list_translations()]
        return request.accept_languages.best_match(translations)

    # Define the User-Roles pivot table
    user_roles = db.Table('user_roles',
        db.Column('id', db.Integer(), primary_key=True),
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id', ondelete='CASCADE')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id', ondelete='CASCADE')))

    # Define Role model
    class Role(db.Model):
        id = db.Column(db.Integer(), primary_key=True)
        name = db.Column(db.String(50), unique=True)

    # Define User model. Make sure to add flask.ext.user UserMixin!!
    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        user_profile_id = db.Column(db.Integer, db.ForeignKey('user_profile.id'), nullable=True, default=None)
        # Flask-User fields
        active = db.Column(db.Boolean(), nullable=False, default=False)
        email = db.Column(db.String(255), nullable=False, default='')
        password = db.Column(db.String(255), nullable=False, default='')
        # Relationships
        user_profile = db.relationship('UserProfile', uselist=False, foreign_keys=[user_profile_id])
        roles = db.relationship('Role', secondary=user_roles,
                backref=db.backref('users', lazy='dynamic'))

    class UserProfile(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        first_name = db.Column(db.String(50), nullable=False, default='')
        last_name = db.Column(db.String(50), nullable=False, default='')

    # Reset all the database tables
    db.create_all()

    # Setup Flask-User
    db_adapter = SQLAlchemyAdapter(db, UserClass=User, UserProfileClass=UserProfile)
    user_manager = UserManager(db_adapter, app,
            register_form=MyRegisterForm)

    # The '/' page is accessible to anyone
    @app.route('/')
    def home_page():
        if current_user.is_authenticated():
            return profile_page()
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Home Page{%endtrans%}</h2>
            <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/profile' page requires a logged-in user
    @app.route('/profile')
    @login_required                                 # Use of @login_required decorator
    def profile_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Profile Page{%endtrans%}</h2>
            <p> {%trans%}Hello{%endtrans%}
                {{ current_user.user_profile.first_name }},</p>
            <p> <a href="{{ url_for('user.change_password') }}">
                {%trans%}Change password{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                {%trans%}Sign out{%endtrans%}</a></p>
            {% endblock %}
            """)

    return app

# Start development web server
if __name__=='__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=True)

########NEW FILE########
__FILENAME__ = fabfile
from fabric.operations import local
from fabric.api import cd, env, task, prefix, run
from contextlib import contextmanager

@task
def runserver():
    local('python runserver.py')

@task
def test():
    local('python flask_user/tests/run_tests.py')

@task
def coverage():
    local('coverage run --source=flask_user flask_user/tests/run_tests.py')
    local('coverage report -m')

@task
def babel():
    local('pybabel extract -F flask_user/translations/babel.cfg -c NOTE -o flask_user/translations/flask_user.pot flask_user flask_user')
    local('pybabel update -i flask_user/translations/flask_user.pot --domain=flask_user --output-dir flask_user/translations -l en')
    local('pybabel update -i flask_user/translations/flask_user.pot --domain=flask_user --output-dir flask_user/translations -l nl')
    local('pybabel compile -f --domain=flask_user --directory flask_user/translations')

@task
def babel_init():
    local('pybabel extract -F flask_user/translations/babel.cfg -c NOTE -o flask_user/translations/flask_user.pot flask_user flask_user')
    local('pybabel init -i flask_user/translations/flask_user.pot --domain=flask_user --output-dir flask_user/translations -l en')
    local('pybabel init -i flask_user/translations/flask_user.pot --domain=flask_user --output-dir flask_user/translations -l nl')
    local('pybabel compile -f --domain=flask_user --directory flask_user/translations')

@task
def docs():
    local('cp example_apps/*_app.py docs/source/includes/.')
    #local('touch docs/source/*.rst')
    local('sphinx-build -b html docs/source ../builds/flask_user/docs')
    local('cd ../builds/flask_user/docs && zip -u -r flask_user_docs *')

@task
def upload_to_pypi():
    local('python setup.py sdist upload')
########NEW FILE########
__FILENAME__ = db_adapters
""" This file shields Flask-User code from database/ORM specific functions.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

from datetime import datetime
from flask_login import current_user

class DBAdapter(object):
    """ This object is used to shield Flask-User from ORM specific functions.
        It's used as the base class for ORM specific adapters like SQLAlchemyAdapter."""
    def __init__(self, db, UserClass, UserProfileClass=None, EmailClass=None):
        self.db = db
        self.UserClass = UserClass          # email, password, etc.
        self.UserProfileClass = UserProfileClass    # For Additional registration fields
        self.EmailClass = EmailClass        # For multiple emails per user


class SQLAlchemyAdapter(DBAdapter):
    """ This object is used to shield Flask-User from SQLAlchemy specific functions."""
    def __init__(self, db, UserClass, UserProfileClass=None, EmailClass=None):
        super(SQLAlchemyAdapter, self).__init__(db, UserClass, UserProfileClass, EmailClass)

    def find_object(self, ObjectClass, **kwargs):
        """ Find object of class 'ObjectClass' by specified '**kwargs' -- case sensitive!! """
        # Prepare base query
        query = ObjectClass.query
        # For all name/value pairs in **kwargs
        for field_name, field_value in kwargs.items():
            # Retrieve Class attribute from field_name
            field = getattr(ObjectClass, field_name, None)
            if not field:
                raise KeyError("SQLAlchemyAdapter.find_object(): Class '%s' has no field '%s'." % (ObjectClass, field_name))
            # Add query filter
            query = query.filter(field==field_value)  # case sensitive!!
        # Execute query
        return query.first()

    def ifind_object(self, ObjectClass, **kwargs):
        """ Find object of class 'ObjectClass' by specified '**kwargs' -- case INsensitive!! """
        # Prepare base query
        query = ObjectClass.query
        # For all name/value pairs in **kwargs
        for field_name, field_value in kwargs.items():
            # Retrieve Class attribute from field_name
            field = getattr(ObjectClass, field_name, None)
            if not field:
                raise KeyError("SQLAlchemyAdapter.find_object(): Class '%s' has no field '%s'." % (ObjectClass, field_name))
            # Add query filter
            query = query.filter(field.ilike(field_value))  # case INsensitive!!
        # Execute query
        return query.first()

    def add_object(self, ObjectClass, **kwargs):
        """ Add an object of class 'ObjectClass' with fields and values specified in '**kwargs'. """
        object=ObjectClass(**kwargs)
        self.db.session.add(object)
        return object

    def update_object(self, object, **kwargs):
        """ Update object 'object' with the fields and values specified in '**kwargs'. """
        for key,value in kwargs.items():
            if hasattr(object, key):
                setattr(object, key, value)
            else:
                raise KeyError("Object '%s' has no field '%s'." % (type(object), key))

    def delete_object(self, object):
        """ Delete object 'object'. """
        self.db.session.delete(object)
        self.db.session.commit()

    def commit(self):
        self.db.session.commit()
########NEW FILE########
__FILENAME__ = decorators
""" This file implements Flask-User decorators: @login_required and @roles_required.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

from functools import wraps
from flask import current_app
from flask.ext.login import current_user

def login_required(func):
    """ This decorator ensures that the current user is logged in before calling the actual view.
        Calls the unauthorized_view_function() when the user is not logged in."""
    @wraps(func)
    def decorated_view(*args, **kwargs):
        # User must be authenticated
        if not current_user.is_authenticated():
            # Redirect to unauthenticated page
            return current_app.user_manager.unauthenticated_view_function()

        # Call the actual view
        return func(*args, **kwargs)
    return decorated_view


def roles_required(*required_roles):
    """ This decorator ensures that the current user has all the required roles
        before calling the actual view.
        Calls the unauthorized_view_function() when requirements fail.

        roles_required() accepts a list of requirements:
            roles_required(requirement1, requirement2, requirement3).

        Each requirement is either a role_name, or a tuple_of_role_names.
            role_name example:   'manager'
            tuple_of_role_names: ('funny', 'witty', 'hilarious')
        A role_name-requirement is accepted when the user has this role.
        A tuple_of_role_names-requirement is accepted when the user has ONE of these roles.
        roles_required() returns true if ALL of the requirements have been accepted.

        For example:
            roles_required('a', ('b', 'c'), d)
        Translates to:
            User must have role 'a' AND (role 'b' OR role 'c') AND role 'd'"""
    def wrapper(func):
        @wraps(func)
        def decorated_view(*args, **kwargs):
            # User must be logged
            if not current_user.is_authenticated():
                # Redirect to the unauthenticated page
                return current_app.user_manager.unauthenticated_view_function()

            # User must have the required roles
            if not current_user.has_roles(*required_roles):
                # Redirect to the unauthorized page
                return current_app.user_manager.unauthorized_view_function()

            # Call the actual view
            return func(*args, **kwargs)
        return decorated_view
    return wrapper

########NEW FILE########
__FILENAME__ = emails
""" This file contains email sending functions for Flask-User.
    It uses Jinja2 to render email subject and email message. It uses Flask-Mail to send email.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

import smtplib
import socket
from flask import current_app, render_template

def _render_email(filename, **kwargs):
    # Render subject
    subject = render_template(filename+'_subject.txt', **kwargs)
    # Make sure that subject lines do not contain newlines
    subject = subject.replace('\n', ' ')
    subject = subject.replace('\r', ' ')
    # Render HTML message
    html_message = render_template(filename+'_message.html', **kwargs)
    # Render text message
    text_message = render_template(filename+'_message.txt', **kwargs)

    return (subject, html_message, text_message)

def send_email(recipient, subject, html_message, text_message):
    """ Send email from default sender to 'recipient' """

    class SendEmailError(Exception):
        pass

    # Make sure that Flask-Mail has been installed
    try:
        from flask_mail import Message
    except:
        raise SendEmailError("Flask-Mail has not been installed. Use 'pip install Flask-Mail' to install Flask-Mail.")

    # Make sure that Flask-Mail has been initialized
    mail_engine = current_app.extensions.get('mail', None)
    if not mail_engine:
        raise SendEmailError('Flask-Mail has not been initialized.')

    try:

        # Construct Flash-Mail message
        message = Message(subject,
                recipients=[recipient],
                html = html_message,
                body = text_message)
        mail_engine.send(message)

    # Print helpful error messages on exceptions
    except (socket.gaierror, socket.error) as e:
        raise SendEmailError('SMTP Connection error: Check your MAIL_HOSTNAME or MAIL_PORT settings.')
    except smtplib.SMTPAuthenticationError:
        raise SendEmailError('SMTP Authentication error: Check your MAIL_USERNAME and MAIL_PASSWORD settings.')

def send_confirm_email_email(email, user, confirm_email_link):
    # Verify certain conditions
    user_manager =  current_app.user_manager
    if not user_manager.enable_email: return
    if not user_manager.send_registered_email and not user_manager.enable_confirm_email: return
    assert(email)

    # Render subject, html message and text message
    subject, html_message, text_message = _render_email(
            user_manager.confirm_email_email_template,
            user=user,
            confirm_email_link=confirm_email_link)

    # Send email message using Flask-Mail
    user_manager.send_email_function(email, subject, html_message, text_message)

def send_forgot_password_email(email, user, reset_password_link):
    # Verify certain conditions
    user_manager =  current_app.user_manager
    if not user_manager.enable_email: return
    assert user_manager.enable_forgot_password
    assert email

    # Render subject, html message and text message
    subject, html_message, text_message = _render_email(
            user_manager.forgot_password_email_template,
            user=user,
            reset_password_link=reset_password_link)

    # Send email message using Flask-Mail
    user_manager.send_email_function(email, subject, html_message, text_message)

def send_password_changed_email(email, user):
    # Verify certain conditions
    user_manager =  current_app.user_manager
    if not user_manager.enable_email: return
    if not user_manager.send_password_changed_email: return
    assert(email)

    # Render subject, html message and text message
    subject, html_message, text_message = _render_email(
            user_manager.password_changed_email_template,
            user=user)

    # Send email message using Flask-Mail
    user_manager.send_email_function(email, subject, html_message, text_message)

def send_registered_email(email, user):
    # Verify certain conditions
    user_manager =  current_app.user_manager
    if not user_manager.enable_email: return
    if not user_manager.send_registered_email: return
    assert(email)

    # Render subject, html message and text message
    subject, html_message, text_message = _render_email(
            user_manager.registered_email_template,
            user=user)

    # Send email message using Flask-Mail
    user_manager.send_email_function(email, subject, html_message, text_message)

def send_username_changed_email(email, user):
    # Verify certain conditions
    user_manager =  current_app.user_manager
    if not user_manager.enable_email: return
    if not user_manager.send_username_changed_email: return
    assert(email)

    # Render subject, html message and text message
    subject, html_message, text_message = _render_email(
            user_manager.username_changed_email_template,
            user=user)

    # Send email message using Flask-Mail
    user_manager.send_email_function(email, subject, html_message, text_message)


########NEW FILE########
__FILENAME__ = forms
""" This file defines and validates Flask-User forms. Forms are based on the WTForms module.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

import string
from flask import current_app
from flask.ext.login import current_user
from flask.ext.wtf import Form
from wtforms import BooleanField, HiddenField, PasswordField, SubmitField, StringField
from wtforms import validators, ValidationError
from .translations import lazy_gettext as _

# **************************
# ** Validation Functions **
# **************************

def password_validator(form, field):
    """ Password must have one lowercase letter, one uppercase letter and one digit."""
    # Convert string to list of characters
    password = list(field.data)
    password_length = len(password)

    # Count lowercase, uppercase and numbers
    lowers = uppers = digits = 0
    for ch in password:
        if ch.islower(): lowers+=1
        if ch.isupper(): uppers+=1
        if ch.isdigit(): digits+=1

    # Password must have one lowercase letter, one uppercase letter and one digit
    is_valid = password_length>=6 and lowers and uppers and digits
    if not is_valid:
        raise ValidationError(_('Password must have at least 6 characters with one lowercase letter, one uppercase letter and one number'))

def username_validator(form, field):
    """ Username must cont at least 3 alphanumeric characters long"""
    username = field.data
    if len(username) < 3:
        raise ValidationError(_('Username must be at least 3 characters long'))
    valid_chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._'
    chars = list(username)
    for char in chars:
        if char not in valid_chars:
            raise ValidationError(_("Username may only contain letters, numbers, '-', '.' and '_'."))

def unique_username_validator(form, field):
    """ Username must be unique"""
    user_manager =  current_app.user_manager
    if not user_manager.username_is_available(field.data):
        raise ValidationError(_('This Username is no longer available. Please try another one.'))


def unique_email_validator(form, field):
    """ Username must be unique"""
    user_manager =  current_app.user_manager
    if not user_manager.email_is_available(field.data):
        raise ValidationError(_('This Email is no longer available. Please try another one.'))

# ***********
# ** Forms **
# ***********

class ChangeUsernameForm(Form):
    new_username = StringField(_('New Username'), validators=[
        validators.Required(_('Username is required')),
        unique_username_validator,
    ])
    old_password = PasswordField(_('Old Password'), validators=[
        validators.Required(_('Old Password is required')),
    ])
    next = HiddenField()
    submit = SubmitField(_('Change Username'))

    def validate(self):
        user_manager =  current_app.user_manager

        # Add custom username validator if needed
        has_been_added = False
        for v in self.new_username.validators:
            if v==user_manager.username_validator:
                has_been_added = True
        if not has_been_added:
            self.new_username.validators.append(user_manager.username_validator)

        # Validate field-validators
        if not super(ChangeUsernameForm, self).validate():
            return False

        # Verify current_user and current_password
        if not current_user or not user_manager.verify_password(self.old_password.data, current_user.password):
            self.old_password.errors.append(_('Old Password is incorrect'))
            return False

        # All is well
        return True

class ChangePasswordForm(Form):
    old_password = PasswordField(_('Old Password'), validators=[
        validators.Required(_('Old Password is required')),
        ])
    new_password = PasswordField(_('New Password'), validators=[
        validators.Required(_('New Password is required')),
        ])
    retype_password = PasswordField(_('Retype New Password'), validators=[
        validators.EqualTo('new_password', message=_('New Password and Retype Password did not match'))
        ])
    next = HiddenField()
    submit = SubmitField(_('Change Password'))

    def validate(self):
        # Use feature config to remove unused form fields
        user_manager =  current_app.user_manager
        if not user_manager.enable_retype_password:
            delattr(self, 'retype_password')

        # Add custom password validator if needed
        has_been_added = False
        for v in self.new_password.validators:
            if v==user_manager.password_validator:
                has_been_added = True
        if not has_been_added:
            self.new_password.validators.append(user_manager.password_validator)

        # Validate field-validators
        if not super(ChangePasswordForm, self).validate():
            return False

        # Verify current_user and current_password
        if not current_user or not user_manager.verify_password(self.old_password.data, current_user.password):
            self.old_password.errors.append(_('Old Password is incorrect'))
            return False

        # All is well
        return True

class ForgotPasswordForm(Form):
    email = StringField(_('Email'), validators=[
        validators.Required(_('Email is required')),
        validators.Email(_('Invalid Email')),
        ])
    submit = SubmitField(_('Send reset password email'))

class LoginForm(Form):
    username = StringField(_('Username'), validators=[
        validators.Required(_('Username is required')),
    ])
    email = StringField(_('Email'), validators=[
        validators.Required(_('Email is required')),
        validators.Email(_('Invalid Email'))
    ])
    password = PasswordField(_('Password'), validators=[
        validators.Required(_('Password is required')),
    ])
    remember = BooleanField(_('Remember me'))
    next = HiddenField()
    submit = SubmitField(_('Sign in'))

    def __init__(self, *args, **kwargs):
        super(LoginForm, self).__init__(*args, **kwargs)
        user_manager =  current_app.user_manager
        if user_manager.enable_username and user_manager.enable_email:
            # Renamed 'Username' label to 'Username or Email'
            self.username.label.text = _('Username or Email')

    def validate(self):
        # Remove fields depending on configuration
        user_manager =  current_app.user_manager
        if user_manager.enable_username:
            delattr(self, 'email')
        else:
            delattr(self, 'username')

        # Validate field-validators
        if not super(LoginForm, self).validate():
            return False

        if user_manager.enable_username:
            # Find user by username or email address
            user = user_manager.find_user_by_username(self.username.data)
            if not user and user_manager.enable_email:
                user = user_manager.find_user_by_email(self.username.data)
        else:
            # Find user by email address
            user = user_manager.find_user_by_email(self.email.data)

        # Validate user and password
        if not user or not user_manager.verify_password(self.password.data, user.password):
            if user_manager.enable_username:
                self.username.errors.append(_('Incorrect Username and Password'))
            else:
                self.email.errors.append(_('Incorrect Email and Password'))
            self.password.errors.append('')
            return False

        # All is well
        return True

class RegisterForm(Form):
    password_validator_added = False

    username = StringField(_('Username'), validators=[
        validators.Required(_('Username is required')),
        unique_username_validator])
    email = StringField(_('Email'), validators=[
        validators.Required(_('Email is required')),
        validators.Email(_('Invalid Email')),
        unique_email_validator])
    password = PasswordField(_('Password'), validators=[
        validators.Required(_('Password is required'))])
    retype_password = PasswordField(_('Retype Password'), validators=[
        validators.EqualTo('password', message=_('Password and Retype Password did not match'))])
    submit = SubmitField(_('Register'))

    def validate(self):
        # remove certain form fields depending on user manager config
        user_manager =  current_app.user_manager
        if not user_manager.enable_username:
            delattr(self, 'username')
        if not user_manager.enable_email:
            delattr(self, 'email')
        if not user_manager.enable_retype_password:
            delattr(self, 'retype_password')
        # Add custom username validator if needed
        if user_manager.enable_username:
            has_been_added = False
            for v in self.username.validators:
                if v==user_manager.username_validator:
                    has_been_added = True
            if not has_been_added:
                self.username.validators.append(user_manager.username_validator)
        # Add custom password validator if needed
        has_been_added = False
        for v in self.password.validators:
            if v==user_manager.password_validator:
                has_been_added = True
        if not has_been_added:
            self.password.validators.append(user_manager.password_validator)
        # Validate field-validators
        if not super(RegisterForm, self).validate():
            return False
        # All is well
        return True

class ResetPasswordForm(Form):
    new_password = PasswordField(_('New Password'), validators=[
        validators.Required(_('New Password is required'))])
    retype_password = PasswordField(_('Retype New Password'), validators=[
        validators.EqualTo('new_password', message=_('New Password and Retype Password did not match'))])
    next = HiddenField()
    submit = SubmitField(_('Change Password'))

    def validate(self):
        # Use feature config to remove unused form fields
        user_manager =  current_app.user_manager
        if not user_manager.enable_retype_password:
            delattr(self, 'retype_password')
        # Add custom password validator if needed
        has_been_added = False
        for v in self.new_password.validators:
            if v==user_manager.password_validator:
                has_been_added = True
        if not has_been_added:
            self.new_password.validators.append(user_manager.password_validator)
        # Validate field-validators
        if not super(ResetPasswordForm, self).validate():
            return False
        # All is well
        return True

########NEW FILE########
__FILENAME__ = passwords
""" This file hashes and verifies passwords for Flask-User.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

from __future__ import print_function
import hashlib
import hmac
import base64

def generate_sha512_hmac(password_salt, password):
    """ Generate SHA512 HMAC -- for compatibility with Flask-Security """
    return base64.b64encode(hmac.new(password_salt, password.encode('utf-8'), hashlib.sha512).digest())

def hash_password(user_manager, password):
    """ Generate hashed password using SHA512 HMAC and the USER_PASSWORD_HASH hash function."""
    # Handle plaintext storage
    if user_manager.password_hash == 'plaintext':
        return password
    # Generate SHA512 HMAC -- For compatibility with Flask-Security
    if user_manager.password_hash_mode == 'Flask-Security':
        password = generate_sha512_hmac(user_manager.password_salt, password)
    # Use passlib to hash password
    hashed_password = user_manager.password_crypt_context.encrypt(password)

    return hashed_password

def verify_password(user_manager, password, hashed_password):
    """ Verify password with previously hashed password.
        Returns True on matching password.
        Returns False otherwise."""
    # Handle plaintext storage
    if user_manager.password_hash == 'plaintext':
        return password==hashed_password
    # Generate SHA512 HMAC -- For compatibility with Flask-Security
    if user_manager.password_hash_mode == 'Flask-Security':
        password = generate_sha512_hmac(user_manager.password_salt, password)

    return user_manager.password_crypt_context.verify(password, hashed_password)


########NEW FILE########
__FILENAME__ = settings
""" This file handles default application config settings for Flask-User.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

def set_default_settings(user_manager, app_config):
    """ Set default app.config settings, but only if they have not been set before """
    # define short names
    um = user_manager
    sd = app_config.setdefault
    # Retrieve obsoleted settings
    # These plural settings have been replaced by singular settings
    obsoleted_enable_emails            = sd('USER_ENABLE_EMAILS',              True)
    obsoleted_enable_retype_passwords  = sd('USER_ENABLE_RETYPE_PASSWORDS',    False)
    obsoleted_enable_usernames         = sd('USER_ENABLE_USERNAMES',           False)
    # Set default features
    um.enable_change_password   = sd('USER_ENABLE_CHANGE_PASSWORD',     True)
    um.enable_change_username   = sd('USER_ENABLE_CHANGE_USERNAME',     False)
    um.enable_confirm_email     = sd('USER_ENABLE_CONFIRM_EMAIL',       False)
    um.enable_email             = sd('USER_ENABLE_EMAIL',               obsoleted_enable_emails)
    um.enable_forgot_password   = sd('USER_ENABLE_FORGOT_PASSWORD',     False)
    um.enable_register          = sd('USER_ENABLE_REGISTRATION',        True)
    um.enable_retype_password   = sd('USER_ENABLE_RETYPE_PASSWORD',     obsoleted_enable_retype_passwords)
    um.enable_username          = sd('USER_ENABLE_USERNAME',            obsoleted_enable_usernames)
    um.enable_multiple_emails   = sd('USER_ENABLE_MULTIPLE_EMAILS',     False)
    # Set default settings
    um.confirm_email_expiration = sd('USER_CONFIRM_EMAIL_EXPIRATION',   2*24*3600)   # 2 days
    um.invite_expiration        = sd('USER_INVITE_EXPIRATION',          90*24*3600)  # 90 days
    um.password_hash_mode       = sd('USER_PASSWORD_HASH_MODE',         'passlib')
    um.password_hash            = sd('USER_PASSWORD_HASH',              'bcrypt')
    um.password_salt            = sd('USER_PASSWORD_SALT',              app_config['SECRET_KEY'])
    um.reset_password_expiration= sd('USER_RESET_PASSWORD_EXPIRATION',  2*24*3600)   # 2 days
    um.require_invitation       = sd('USER_REQUIRE_INVITATION',         False)
    um.send_password_changed_email = sd('USER_SEND_REGISTERED_EMAIL',   True)
    um.send_registered_email       = sd('USER_SEND_REGISTERED_EMAIL',   True)
    um.send_username_changed_email = sd('USER_SEND_REGISTERED_EMAIL',   True)
    # Set default URLs
    um.change_password_url      = sd('USER_CHANGE_PASSWORD_URL',        '/user/change-password')
    um.change_username_url      = sd('USER_CHANGE_USERNAME_URL',        '/user/change-username')
    um.confirm_email_url        = sd('USER_CONFIRM_EMAIL_URL',          '/user/confirm-email/<token>')
    um.forgot_password_url      = sd('USER_FORGOT_PASSWORD_URL',        '/user/forgot-password')
    um.login_url                = sd('USER_LOGIN_URL',                  '/user/sign-in')
    um.logout_url               = sd('USER_LOGOUT_URL',                 '/user/sign-out')
    um.register_url             = sd('USER_REGISTER_URL',               '/user/register')
    um.resend_confirm_email_url = sd('USER_RESEND_CONFIRM_EMAIL_URL',   '/user/resend-confirmation-email')
    um.reset_password_url       = sd('USER_RESET_PASSWORD_URL',         '/user/reset-password/<token>')
    um.unauthenticated_url      = sd('USER_UNAUTHENTICATED_URL',        um.login_url)
    um.unauthorized_url         = sd('USER_UNAUTHORIZED_URL',           '/')
    # Set default template files
    um.change_password_template = sd('USER_CHANGE_PASSWORD_TEMPLATE',  'flask_user/change_password.html')
    um.change_username_template = sd('USER_CHANGE_USERNAME_TEMPLATE',  'flask_user/change_username.html')
    um.forgot_password_template = sd('USER_FORGOT_PASSWORD_TEMPLATE',  'flask_user/forgot_password.html')
    um.login_template           = sd('USER_LOGIN_TEMPLATE',            'flask_user/login.html')
    um.register_template        = sd('USER_REGISTER_TEMPLATE',         'flask_user/register.html')
    um.resend_confirm_email_template = sd('USER_RESEND_CONFIRM_EMAIL_TEMPLATE', 'flask_user/resend_confirm_email.html')
    um.reset_password_template       = sd('USER_RESET_PASSWORD_TEMPLATE',       'flask_user/reset_password.html')
    # Set default email template files
    um.confirm_email_email_template    = sd('USER_CONFIRM_EMAIL_EMAIL_TEMPLATE',    'flask_user/emails/confirm_email')
    um.forgot_password_email_template  = sd('USER_FORGOT_PASSWORD_EMAIL_TEMPLATE',  'flask_user/emails/forgot_password')
    um.password_changed_email_template = sd('USER_PASSWORD_CHANGED_EMAIL_TEMPLATE', 'flask_user/emails/password_changed')
    um.registered_email_template       = sd('USER_REGISTERED_EMAIL_TEMPLATE',       'flask_user/emails/registered')
    um.username_changed_email_template = sd('USER_USERNAME_CHANGED_EMAIL_TEMPLATE', 'flask_user/emails/username_changed')

def check_settings(user_manager):
    """ Verify config combinations. Produce a helpful error messages for inconsistent combinations."""
    # Define custom Exception
    class ConfigurationError(Exception):
        pass
    um = user_manager

    # USER_ENABLE_REGISTER=True must have USER_ENABLE_USERNAME=True or USER_ENABLE_EMAIL=True or both.
    if um.enable_register and not(um.enable_username or um.enable_email):
        raise ConfigurationError('USER_ENABLE_REGISTER=True must have USER_ENABLE_USERNAME=True or USER_ENABLE_EMAIL=True or both.')
    # USER_ENABLE_CONFIRM_EMAIL=True must have USER_ENABLE_EMAIL=True
    if um.enable_confirm_email and not um.enable_email:
        raise ConfigurationError('USER_ENABLE_CONFIRM_EMAIL=True must have USER_ENABLE_EMAIL=True.')
    # USER_ENABLE_MULTIPLE_EMAILS=True must have USER_ENABLE_EMAIL=True
    if um.enable_multiple_emails and not um.enable_email:
        raise ConfigurationError('USER_ENABLE_MULTIPLE_EMAILS=True must have USER_ENABLE_EMAIL=True.')
    # USER_ENABLE_CHANGE_USERNAME=True must have USER_ENABLE_USERNAME=True.
    if um.enable_change_username and not um.enable_username:
        raise ConfigurationError('USER_ENABLE_CHANGE_USERNAME=True must have USER_ENABLE_USERNAME=True.')
    # USER_SEND_REGISTERED_EMAIL=True must have USER_ENABLE_EMAIL=True
    if um.send_registered_email and not um.enable_email:
        raise ConfigurationError('USER_SEND_REGISTERED_EMAIL=True must have USER_ENABLE_EMAIL=True.')

########NEW FILE########
__FILENAME__ = signals
""" This file creates event notification signals for Flask-User.
    Signals are based on Flask.signals which are based on the blinker signals.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

from flask.signals import Namespace

_signals = Namespace()                              # Place Flask-User signals in our own namespace

# *******************
# ** Flask Signals **
# *******************
# Flask signals are based on blinker. Neither Flask nor Flask-User installs blinker
# If you plan to use signals, please install blinker with 'pip install blinker'
# See http://flask.pocoo.org/docs/signals/

# Sent when a user changed their password
user_changed_password = _signals.signal('user.user_changed_password')

# Sent when a user changed their username
user_changed_username = _signals.signal('user.user_changed_username')

# Sent when a user confirmed their email
user_confirmed_email = _signals.signal('user.user_confirmed_email')

# Sent when a user submitted a password reset request
user_forgot_password = _signals.signal('user.forgot_password')

# Sent when a user logged in
user_logged_in = _signals.signal('user.user_logged_in')

# Sent when a user logged out
user_logged_out = _signals.signal('user.user_logged_out')

# Sent when a user registered a new account
user_registered = _signals.signal('user.user_registered')

# Signal sent just after a password was reset
user_reset_password = _signals.signal('user.user_reset_password')

# Signal sent just after a user sent an invitation  # TODO: Not yet implemented
user_sent_invitation = _signals.signal('user.user_sent_invitation')


########NEW FILE########
__FILENAME__ = run_tests
"""
    flask_user.tests
    ----------------
    Automated tests for Flask-User

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""

from __future__ import print_function
import unittest

# Configure app
from flask_user.tests import test_valid_forms, test_authorization, tst_app, test_invalid_forms, tstutils

test_config = dict(
    SQLALCHEMY_DATABASE_URI='sqlite:///:memory:',   # In-memory sqlite DB
    WTF_CSRF_ENABLED=False,  # Disable CSRF token in Flask-Wtf
    LOGIN_DISABLED=False,    # Enable @register_required while app.testing=True
    MAIL_SUPPRESS_SEND=True, # Suppress the sending of emails
    SERVER_NAME='localhost'  # Enable url_for() without request context
)

# Create app
app = tst_app.create_app(test_config)
app.testing = True           # Propagate exceptions (don't show 500 error page)
db = app.user_manager.db_adapter.db

# create client
client = tstutils.TstClient(app.test_client(), db)

# Create test case
class TestFlaskUserForms(unittest.TestCase):
    """
    Automated tests for Flask-User forms
    """
    def test_authorization(self):
        with app.app_context():
            test_authorization.test_authorization(client)

    def test_valid_forms_with_email_login(self):
        with app.app_context():
            test_valid_forms.test_with_email(client)

    def test_valid_forms_with_username_login(self):
        with app.app_context():
            test_valid_forms.test_with_username(client)

    def test_invalid_forms(self):
        with app.app_context():
            test_invalid_forms.run_all_tests(client)

if __name__=='__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_authorization
"""
    tests.test_all_forms.py
    ---------------------------
    Flask-User automated tests:
    Tests posting a sequence of valid forms for all possible config combinations

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""

from __future__ import print_function

import datetime

from flask import current_app, url_for


# **********************
# ** Global Variables **
# **********************
# Using global variable for speed
user1 = None

# ********************************
# ** Automatically called Tests **
# ********************************
# The 'client' and 'app' parameters are set up in conftest.py
# Functions that start with 'test' will be run automatically by the test suite runner (py.test)

def test_authorization(client):
    """
    Test various authorization scenarios
    """
    um = current_app.user_manager
    um.enable_register = True
    um.enable_username = True
    um.enable_email = False
    um.enable_confirm_email = False
    um.enable_retype_password = False

    # Test as anonymous user
    client.get_valid_page(url_for('home_page'))
    client.get_invalid_page(url_for('profile_page'), "You must be signed in to access ")
    client.get_invalid_page(url_for('special_page'), "You must be signed in to access ")

    # Register and Log in as user1 without any roles
    client.post_valid_form(url_for('user.register'),
            username='userX', password='Password1')
    client.login(username='userX', password='Password1')

    client.get_valid_page(url_for('home_page'))
    client.get_valid_page(url_for('profile_page'))
    client.get_invalid_page(url_for('special_page'), "You do not have permission to access ")

    # Delete userX
    User = um.db_adapter.UserClass
    user = User.query.filter(User.username=='userX').first()
    assert(user)
    client.db.session.delete(user)
    client.db.session.commit()

    # Log in as user007 without roles 'special' and 'agent'
    client.login(username='user007', password='Password1')

    client.get_valid_page(url_for('home_page'))
    client.get_valid_page(url_for('profile_page'))
    client.get_valid_page(url_for('special_page'))

    # Test translations.ngettext
    from flask_user.translations import ngettext
    count = 1
    text = ngettext('I have %(count)s apple', 'I have %(count)s apples', count, count=count)
    assert(text=='I have 1 apple')
    count = 2
    text = ngettext('I have %(count)s apple', 'I have %(count)s apples', count, count=count)
    assert(text=='I have 2 apples')


# Workaround for py.test coverage issue
def run_all_tests(client, db):
    test_authorization(client)

########NEW FILE########
__FILENAME__ = test_invalid_forms
"""
    tests.test_invalid_forms.py
    ---------------------------
    Flask-User automated tests:
    Tests all forms with as many invalid field values as possible

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""

from __future__ import print_function

from datetime import datetime
import time

from flask import current_app, url_for

from flask_user.tests.tstutils import response_has_string



# **********************
# ** Global Variables **
# **********************
# Using global variable for speed
user1 = None
user2 = None
user3 = None
user4 = None

# *************
# ** Defines **
# *************
SHORT_USERNAME = 'Aa'
INVALID_EMAIL = 'user1.example.com'
invalid_usernames = (
    'with space',
    'with&symbol',
    "with'symbol",
    )
invalid_passwords = (
    'Abcd1',        # too short
    'ABCabc',       # no digits
    'ABC123',       # no lower case letters
    'abc123',       # no upper case letters
    )


# *********************
# ** Automated tests **
# *********************
# Function names must start with 'test'
# The 'client' parameter is set up in conftest.py

def test_init(db):
    """
    Set up two test users
    """
    global user1, user2, user3, user4

    # Enable all features
    um =  current_app.user_manager
    um.enable_register = True
    um.enable_change_username = True
    um.enable_change_password = True
    um.enable_confirm_email = True
    um.enable_reset_password = True
    um.enable_email = True
    um.enable_retype_password = True

    hashed_password = um.hash_password('Password1')
    User = um.db_adapter.UserClass

    # Create user1 with username and email
    user1 = User(username='user1', email='user1@example.com', password=hashed_password, active=True)
    assert user1
    db.session.add(user1)

    # Create user1 with email only
    user2 = User(email='user2@example.com', password=hashed_password, active=True)
    assert user2
    db.session.add(user2)

    # Create user3 with username and email
    user3 = User(username='user3', email='user3@example.com', password=hashed_password, active=True)
    assert user3
    db.session.add(user3)

    # Create user4 with email only
    user4 = User(email='user4@example.com', password=hashed_password, active=True)
    assert user4
    db.session.add(user4)

    db.session.commit()


def test_invalid_register_with_username_form(client):
    print("test_invalid_register_with_username_form")

    # Choose config
    um =  current_app.user_manager
    um.enable_username = True
    User = um.db_adapter.UserClass

    # Set default values
    url = url_for('user.register')
    username = 'user3'
    email = 'user3@example.com'
    password = 'Password1'

    # Test empty username
    client.post_invalid_form(url, 'Username is required',
            username='', email=email, password=password, retype_password=password)

    # Test short username
    client.post_invalid_form(url, 'Username must be at least 3 characters long',
            username=SHORT_USERNAME, email=email, password=password, retype_password=password)

    # Test invalid usernames
    for invalid_username in invalid_usernames:
        client.post_invalid_form(url, 'Username may only contain letters, numbers, ',
                username=invalid_username, email=email, password=password, retype_password=password)

    # Test existing username (case INsensitive!)
    client.post_invalid_form(url, 'This Username is no longer available. Please try another one.',
            username='UsEr1', email=email, password=password, retype_password=password)

    # Test empty password
    client.post_invalid_form(url, 'Password is required',
            username=username, email=email, password='', retype_password='')

    # Test invalid passwords
    for invalid_password in invalid_passwords:
        client.post_invalid_form(url, 'Password must have at least 6 characters with one lowercase letter, one uppercase letter and one number',
                username=username, email=email, password=invalid_password, retype_password=invalid_password)

    # Test non-matching passwords
    client.post_invalid_form(url, 'Password and Retype Password did not match',
            username=username, email=email, password='Password1', retype_password='Password9')

def test_invalid_register_with_email_form(client):
    print("test_invalid_register_with_email_form")

    # Choose config
    um =  current_app.user_manager
    um.enable_username = False
    User = um.db_adapter.UserClass

    # Set default values
    url = url_for('user.register')
    email = 'user3@example.com'
    password = 'Password1'

    # Test empty email
    client.post_invalid_form(url, 'Email is required',
            email='', password=password, retype_password=password)

    # Test invalid email
    client.post_invalid_form(url, 'Invalid Email',
            email=INVALID_EMAIL, password=password, retype_password=password)

    # Test existing email (case INsensitive!)
    # TODO: Debug
    #client.post_invalid_form(url, 'This Email is no longer available. Please try another one.',
    #        email='UsEr1@ExAmPlE.CoM', password=password, retype_password=password)

    # Test empty password
    client.post_invalid_form(url, 'Password is required',
            email=email, password='', retype_password='')

    # Test invalid passwords
    for invalid_password in invalid_passwords:
        client.post_invalid_form(url, 'Password must have at least 6 characters with one lowercase letter, one uppercase letter and one number',
                email=email, password=invalid_password, retype_password=invalid_password)

    # Test non-matching passwords
    client.post_invalid_form(url, 'Password and Retype Password did not match',
            email=email, password='Password1', retype_password='Password9')

def test_invalid_confirm_email_page(client):
    print("test_invalid_confirm_email_page")

    # Test Invalid token
    url = url_for('user.confirm_email', token='InvalidToken')
    client.get_invalid_page(url, 'Invalid confirmation token.')

    # Generate valid token
    um = current_app.user_manager
    token = um.generate_token(user1.id)
    url = url_for('user.confirm_email', token=token)

    # Test Expired token
    um.confirm_email_expiration = 1   # set 1 second expiration
    time.sleep(2)                     # wait for 2 seconds
    client.get_invalid_page(url, 'Your confirmation token has expired.')


def test_invalid_login_with_username_form(client):
    print("test_invalid_login_with_username_form")

    # Choose config
    um = current_app.user_manager
    um.enable_username = True

    # Set default values
    url = url_for('user.login')
    username = 'user1'
    password = 'Password1'

    # Test empty username
    client.post_invalid_form(url, 'Username is required',
            username='', password=password)

    # Test incorrect username
    client.post_invalid_form(url, 'Incorrect Username and Password',
            username='Xuser1', password=password)

    # Test empty password
    client.post_invalid_form(url, 'Password is required',
            username=username, password='')

    # Test incorrect password
    client.post_invalid_form(url, 'Incorrect Username and Password',
            username=username, password='XPassword1')

def test_invalid_login_with_email_form(client):
    print("test_invalid_login_with_email_form")

    # Choose config
    um = current_app.user_manager
    um.enable_username = False

    # Set default values
    url = url_for('user.login')
    email = 'user2@example.com'
    password = 'Password1'

    # Test empty email
    client.post_invalid_form(url, 'Email is required',
            email='', password=password)

    # Test incorrect email
    client.post_invalid_form(url, 'Incorrect Email and Password',
            email='Xuser2@example.com', password=password)

    # Test empty password
    client.post_invalid_form(url, 'Password is required',
            email=email, password='')

    # Test incorrect password
    client.post_invalid_form(url, 'Incorrect Email and Password',
            email=email, password='XPassword1')

def test_invalid_change_username_form(client):
    print("test_invalid_change_username_form")

    # Set user manager config
    um =  current_app.user_manager
    um.enable_username = True

    # Set default values
    username = 'user1'
    password = 'Password1'
    new_username = 'user4'
    url = url_for('user.change_username')

    # Log in as 'user1'
    client.login(username=username, password=password)

    # Test empty username
    client.post_invalid_form(url, 'Username is required',
            new_username='', old_password=password)

    # Test short username
    client.post_invalid_form(url, 'Username must be at least 3 characters long',
            new_username=SHORT_USERNAME, old_password=password)

    # Test existing username
    client.post_invalid_form(url, 'This Username is no longer available. Please try another one.',
            new_username='user3', old_password=password)

    # Test empty password
    client.post_invalid_form(url, 'Old Password is required',
            new_username=username, old_password='')

    # Test incorrect password
    client.post_invalid_form(url, 'Old Password is incorrect',
            new_username=username, old_password='XPassword1')

    client.logout()

def test_invalid_change_password_form(client):
    print("test_invalid_change_password_form")

    # Set user manager config
    um =  current_app.user_manager
    um.enable_username = False

    # Set default values
    email = 'user2@example.com'
    old_password = 'Password1'
    new_password = 'Password5'
    url = url_for('user.change_password')

    # Log in as 'user1'
    client.login(email=email, password=old_password)

    # Test empty old password
    client.post_invalid_form(url, 'Old Password is required',
            old_password='', new_password=new_password, retype_password=new_password)

    # Test incorrect old password
    client.post_invalid_form(url, 'Old Password is incorrect',
            old_password='XPassword1', new_password=new_password, retype_password=new_password)

    # Test empty password
    client.post_invalid_form(url, 'New Password is required',
            old_password=old_password, new_password='', retype_password=new_password)

    # Test invalid passwords
    for invalid_password in invalid_passwords:
        client.post_invalid_form(url, 'Password must have at least 6 characters with one lowercase letter, one uppercase letter and one number',
            old_password=old_password, new_password=invalid_password, retype_password=new_password)

    # Test non-matching passwords
    client.post_invalid_form(url, 'New Password and Retype Password did not match',
            old_password=old_password, new_password=new_password, retype_password='Xpassword5')

    client.logout()


def test_invalid_forgot_password_form(client):
    print("test_invalid_forgot_password_form")

    url = url_for('user.forgot_password')

    # Test invalid email
    client.post_invalid_form(url, 'Invalid Email',
            email=INVALID_EMAIL)


def test_invalid_reset_password(client):
    print("test_invalid_reset_password")

    # Set user manager config
    um =  current_app.user_manager

    # Set default values
    new_password = 'Password5'
    # Simulate a valid forgot password form
    user1.reset_password_token = um.generate_token(user1.id)
    token = user1.reset_password_token

    # Test invalid token
    url = url_for('user.reset_password', token='InvalidToken')
    client.post_invalid_form(url, 'Your reset password token is invalid.',
            new_password=new_password, retype_password=new_password)

    # Expired Token
    url = url_for('user.reset_password', token=token)
    um.reset_password_expiration = 1    # set 1 second expiration
    time.sleep(2)                       # wait for 2 seconds
    client.post_invalid_form(url, 'Your reset password token has expired.',
            new_password=new_password, retype_password=new_password)
    um.reset_password_expiration = 2*24*3600  # 2 days

    # Invalid retype password
    client.post_invalid_form(url, 'New Password and Retype Password did not match',
            new_password = new_password, retype_password='XPassword5')

def test_valid_roles(client):
    um =  current_app.user_manager
    User = um.db_adapter.UserClass

    # Perform only for roles_required_app
    user007 = User.query.filter(User.username=='user007').first()
    if not user007: return

    print("test_valid_roles")
    um.enable_username = True

    client.login(username='user007', password='Password1')
    url = url_for('special_page')
    response = client.get_valid_page(url)
    assert not response_has_string(response, 'You must be signed in to access')
    client.logout()

def test_invalid_roles(client):
    um =  current_app.user_manager
    User = um.db_adapter.UserClass

    # Perform only for roles_required_app
    user007 = User.query.filter(User.username=='user007').first()
    if not user007: return

    print("test_invalid_roles")
    um.enable_username = True

    client.login(username='user1', password='Password1')
    url = url_for('special_page')
    response = client.get_valid_page(url)
    assert response_has_string(response, 'You do not have permission to access')
    client.logout()

def test_login_without_confirm(client):
    print("test_login_without_confirm")

    um = current_app.user_manager
    um.enable_username = False
    um.enable_email = True
    um.enable_confirm_email = True
    um.enable_retype_password = False

    email = 'notconfirmed@example.com'
    password = 'Password1'

    # register user
    client.post_valid_form(url_for('user.register'),
            email=email,
            password=password)

    # Try logging in without confirming email
    client.post_invalid_form(url_for('user.login'),
            'Your email address has not yet been confirmed.',
            email=email,
            password=password)

    # Confirm email manually, but disable account
    User = um.db_adapter.UserClass
    user = User.query.filter(User.email==email).first()
    assert(user)
    user.active = False
    user.confirmed_at = datetime.utcnow()

    # Try logging in into  disabled account
    client.post_invalid_form(url_for('user.login'),
            'Your account has been disabled.',
            email=email,
            password=password)

def test_cleanup(db):
    """
    Delete user1 and user2
    """
    global user1, user2, user3, user4
    db.session.delete(user1)
    db.session.delete(user2)
    db.session.delete(user3)
    db.session.delete(user4)
    db.session.commit()
    user1 = None
    user2 = None
    user3 = None
    user4 = None

# Workaround for py.test coverage issue
def run_all_tests(client):
    print()
    test_init(client.db)
    test_invalid_register_with_username_form(client)
    test_invalid_register_with_email_form(client)
    test_invalid_confirm_email_page(client)
    test_invalid_login_with_username_form(client)
    test_invalid_login_with_email_form(client)
    test_invalid_change_username_form(client)
    test_invalid_change_password_form(client)
    test_invalid_forgot_password_form(client)
    test_invalid_reset_password(client)

    test_valid_roles(client)
    test_invalid_roles(client)

    test_login_without_confirm(client)

    test_cleanup(client.db)

# TODO:
# Register without confirming email and try to log in
# 'Your email address has not yet been confirmed. Check your email Inbox and Spam folders for the confirmation email and follow the instructions to activate your account.'
#
# Disable account and try to login
# 'Your account has been disabled.'
#
# Logout with user_manager.logout_next set
#
# Reset password with custom user_manager.password_validator
#
# Change password with custom user_manager.password_validator:
#
# Custom db_adapter.EmailClass
########NEW FILE########
__FILENAME__ = test_valid_forms
"""
    tests.test_all_forms.py
    ---------------------------
    Flask-User automated tests:
    Tests posting a sequence of valid forms for all possible config combinations

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""

from __future__ import print_function

import datetime

from flask import current_app, url_for

# **********************
# ** Global Variables **
# **********************
# Using global variable for speed
user1 = None

# ********************************
# ** Automatically called Tests **
# ********************************
# The 'client' and 'app' parameters are set up in conftest.py
# Functions that start with 'test' will be run automatically by the test suite runner (py.test)

def test_with_email(client):
    """
    Test all forms with all enabled features and enable_username=False
    """
    print()

    um = current_app.user_manager
    um.enable_register = True
    um.enable_confirm_email = True
    um.enable_username = False
    um.enable_change_username = False
    um.enable_change_password = True
    um.enable_forgot_password = True

    um.enable_username = False      # Login with email
    check_all_valid_forms(um, client)

def test_with_username(client):
    """
    Test all forms with all enabled features and enable_username=True
    """
    print()

    # Enable all features
    um = current_app.user_manager
    um.enable_register = True
    um.enable_email = False
    um.enable_confirm_email = False
    um.enable_change_username = True
    um.enable_change_password = True
    um.enable_forgot_password = True

    # Login with username
    um.enable_username = True       # Login with username
    check_all_valid_forms(um, client)

# *****************************
# ** Explicitly called Tests **
# *****************************
# These function names may not start with 'test'

def do_test_all_possible_config_combinations(client, db):
    """
    Test all forms with all possible config combinations
    """
    print()
    print("Testing all forms for all possible config combinations")
    um =  current_app.user_manager
    
    for um.enable_register in (True, False):
      for um.enable_email in (True, False):
        for um.enable_retype_password in (True, False):
          for um.enable_confirm_email in (True, False):
            print("Config:", um.enable_register, um.enable_email, um.enable_retype_password, um.enable_confirm_email, "...")
            for um.enable_username in (True, False):
              for um.enable_change_password in (True, False):
                for um.enable_change_username in (True, False):
                  for um.enable_forgot_password in (True, False):
                    check_all_valid_forms(um, client, db)

# **************************
# ** Check Form Functions **
# **************************
# Below we check each form by submitting fields depending on the config settings.

def check_all_valid_forms(um, client):
    # ** Skip tests for invalid config combinations
    # USER_ENABLE_REGISTER=True must have USER_ENABLE_USERNAME=True or USER_ENABLE_EMAIL=True or both.
    if um.enable_register and not um.enable_email and not um.enable_username: return
    # USER_ENABLE_CONFIRM_EMAIL=True must have USER_ENABLE_EMAIL=True
    if um.enable_confirm_email and not um.enable_email: return
    # USER_ENABLE_MULTIPLE_EMAILS=True must have USER_ENABLE_EMAIL=True
    if um.enable_multiple_emails and not um.enable_email: return
    # ENABLE_CHANGE_USERNAME=True must have ENABLE_USERNAME=True.
    if um.enable_change_username and not um.enable_username: return

    check_valid_register_form(um, client, client.db)
    check_valid_confirm_email_page(um, client)
    check_valid_login_form(um, client)
    check_valid_change_password_form(um, client)
    check_valid_change_username_form(um, client)
    check_valid_logout_link(um, client)
    check_valid_forgot_password_form(um, client)
    check_valid_reset_password_page(um, client)

    delete_user1(client.db)

def check_valid_register_form(um, client, db):
    # Using global variable for speed
    global user1
    User = um.db_adapter.UserClass

    # Define defaults
    username = 'user1'
    email = username+'@example.com'
    password = 'Password1'

    # Build variable argument list depending on config settings
    kwargs = {}
    if um.enable_username:
        kwargs['username'] = username
    if um.enable_email:
        kwargs['email'] = email
    kwargs['password'] = password

    if um.enable_register:
        print("test_valid_register_form")

        # Create User by submitting a form
        if um.enable_retype_password:
            kwargs['retype_password'] = password

        # Submit form and verify that response has no errors
        client.post_valid_form(url_for('user.register'), **kwargs)

        if um.enable_username:
            user1 = User.query.filter(User.username==username).first()
        else:
            user1 = User.query.filter(User.email==email).first()
        assert user1

        # Verify operations
        if um.enable_confirm_email:
            assert not user1.active
        else:
            assert user1.active

    else:
        # Create user record manually

        # hash password
        kwargs['password'] = um.hash_password(password)

        # Create User
        user1 = User(active=True, confirmed_at=datetime.datetime.utcnow(), **kwargs)
        db.session.add(user1)
        db.session.commit()
        assert user1

def check_valid_confirm_email_page(um, client):
    # Skip test for certain config combinations
    if not um.enable_register: return
    if not um.enable_email: return
    if not um.enable_confirm_email: return

    print("test_valid_confirm_email_page")

    # Generate confirmation token for user 1
    confirmation_token = um.generate_token(user1.id)

    # Retrieve page and verify that response has no errors
    client.get_valid_page(url_for('user.confirm_email', token=confirmation_token))

    # Verify operations
    assert user1.active
    assert user1.confirmed_at != None

def check_valid_login_form(um, client):
    print("test_valid_login_form")

    # Define defaults
    username = 'user1'
    email = username+'@example.com'
    password = 'Password1'

    # Build variable argument list depending on config settings
    kwargs = {}
    if um.enable_username:
        kwargs['username'] = username
    if um.enable_email:
        kwargs['email'] = email
    kwargs['password'] = password

    # Submit form and verify that response has no errors
    client.post_valid_form(url_for('user.login'), **kwargs)

    # Verify operations
    # TODO:

def check_valid_change_password_form(um, client):
    # Skip test for certain config combinations
    if not um.enable_change_password: return

    print("test_valid_change_password_form")

    # Define defaults
    password = 'Password1'
    new_password = 'Password9'
    old_hashed_password = user1.password

    # Build variable argument list depending on config settings
    kwargs = {}
    kwargs['old_password'] = password
    kwargs['new_password'] = new_password
    if um.enable_retype_password:
        kwargs['retype_password'] = new_password

    # Submit form and verify that response has no errors
    client.post_valid_form(url_for('user.change_password'), **kwargs)

    # Verify operations
    assert um.verify_password(new_password, user1.password)

    # Change password back to old password for subsequent tests
    user1.password = old_hashed_password

def check_valid_change_username_form(um, client):
    # Skip test for certain config combinations
    if not um.enable_change_username: return

    print("test_valid_change_username_form")

    # Define defaults
    username = 'user1'
    password = 'Password1'
    new_username = 'user9'

    # Submit form and verify that response has no errors
    client.post_valid_form(url_for('user.change_username'), new_username=new_username, old_password=password)

    # Verify operations
    assert user1.username == new_username

    # Change username back to old password for subsequent tests
    user1.username = username

def check_valid_logout_link(um, client):
    print("test_valid_logout_link")
    # Retrieve page and verify that response has no errors
    client.get_valid_page(url_for('user.logout'))

def check_valid_forgot_password_form(um, client):
    # Skip test for certain config combinations
    if not um.enable_email: return
    if not um.enable_forgot_password: return

    print("test_valid_forgot_password_form")

    # Define defaults
    email = 'user1@example.com'

    # Submit form and verify that response has no errors
    client.post_valid_form(url_for('user.forgot_password'), email=email)

def check_valid_reset_password_page(um, client):
    # Skip test for certain config combinations
    if not um.enable_email: return
    if not um.enable_forgot_password: return

    print("test_valid_reset_password_page")

    # Simulate a valid forgot password form
    user1.reset_password_token = um.generate_token(user1.id)
    token = user1.reset_password_token

    # Define defaults
    password = 'Password1'
    new_password = 'Password9'
    old_hashed_password = user1.password
    url = url_for('user.reset_password', token=token)

    # Build variable argument list depending on config settings
    kwargs = {}
    kwargs['new_password'] = new_password
    if um.enable_retype_password:
        kwargs['retype_password'] = new_password

    # Submit form and verify that response has no errors
    client.post_valid_form(url, **kwargs)

    # Verify operations
    assert um.verify_password(new_password, user1.password)

    # Change password back to old password for subsequent tests
    user1.password = old_hashed_password


def delete_user1(db):
    # Using global variable for speed
    global user1

    # Delete user1
    db.session.delete(user1)
    db.session.commit()
    user1 = None

# Workaround for py.test coverage issue
def run_all_tests(client, db):
    test_with_username(client, db)
    test_with_email(client, db)

########NEW FILE########
__FILENAME__ = tstutils
"""
    tests.utils
    -----------
    Utility class for Flask-User automated tests

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""
from __future__ import print_function
from flask import url_for

# Checks to see if response.data contains the specified string.
def response_has_string(response, string):
    assert response.status_code == 200
    # In Python3, response.data is <class 'bytes'> and string is <class 'str'>
    # hence the use of 'str.encode(string)'
    return response.data.find(str.encode(string)) >= 0

# Checks to see if response.data contains the string 'has-error'.
def response_has_errors(response):
    return response_has_string(response, 'has-error')

# Checks to see if response.data contains no 'has-error' strings
def response_has_no_errors(response):
    has_errors = response_has_errors(response)
    if has_errors:
        print(response.data)
    return not has_errors

class TstClient(object):
    """
    Utility class for tests
    """
    def __init__(self, client, db):
        self.client = client
        self.db = db

    def get_valid_page(self, url):
        """
        GET url and assert that the response contains no errors.
        """
        response = self.client.get(url, follow_redirects=True)
        assert response.status_code == 200, "GET %s returned %d" % (url, response.status_code)
        assert response_has_no_errors(response), "GET %s returned an error" % url
        return response

    def get_invalid_page(self, url, expected_error):
        """
        GET url and assert that the response contains an expected error.
        """
        response = self.client.get(url, follow_redirects=True)
        assert response.status_code == 200, "POST %s returned %d" % (url, response.status_code)
        response_has_error = response_has_string(response, expected_error)
        if not response_has_error:
            print(response.data)
        assert response_has_error, "POST %s did not contain '%s' error" % (url, expected_error)
        return response

    def post_valid_form(self, url, **kwargs):
        """
        POST url and assert that the response contains no errors.
        """
        response = self.client.post(url, data=kwargs, follow_redirects=True)
        assert response.status_code == 200, "POST %s returned %d" % (url, response.status_code)
        assert response_has_no_errors(response), "post_valid_form(%s) returned an error" % url
        return response

    def post_invalid_form(self, url, expected_error, **kwargs):
        """
        POST url and assert that the response contains an expected error.
        """
        response = self.client.post(url, data=kwargs, follow_redirects=True)
        assert response.status_code == 200, "POST %s returned %d" % (url, response.status_code)
        response_has_error = response_has_string(response, expected_error)
        if not response_has_error:
            print(response.data)
        assert response_has_error, "POST %s did not contain '%s' error" % (url, expected_error)
        return response

    def login(self, **kwargs):
        """
        Log new user in with username/password or email/password.
        """
        url = url_for('user.login')
        return self.post_valid_form(url, **kwargs)

    def logout(self, **kwargs):
        """
        Log current user out.
        """
        url = url_for('user.logout')
        response = self.client.get(url, follow_redirects=True)
        assert response.status_code == 200


########NEW FILE########
__FILENAME__ = tst_app
from flask import Flask, render_template_string, request
from flask.ext.babel import Babel
from flask.ext.mail import Mail
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.user import login_required, SQLAlchemyAdapter, UserManager, UserMixin
from flask.ext.user import roles_required

# Use a Class-based config to avoid needing a 2nd file
class ConfigClass(object):
    # Configure Flask
    SECRET_KEY = 'THIS IS AN INSECURE SECRET'                        # Change this for production!!!
    SQLALCHEMY_DATABASE_URI = 'sqlite:///roles_required_app.sqlite'  # Use Sqlite file db
    CSRF_ENABLED = True

    # Configure Flask-Mail -- Required for Confirm email and Forgot password features
    MAIL_SERVER   = 'smtp.gmail.com'
    MAIL_PORT     = 465
    MAIL_USE_SSL  = True                            # Some servers use MAIL_USE_TLS=True instead
    MAIL_USERNAME = 'email@example.com'
    MAIL_PASSWORD = 'password'
    MAIL_DEFAULT_SENDER = '"Sender" <noreply@example.com>'

    # Configure Flask-User
    USER_ENABLE_USERNAME        = True              # Register and Login with username
    USER_ENABLE_EMAIL           = True              # Register with email
    USER_ENABLE_CONFIRM_EMAIL   = True              # Require email confirmation
    USER_ENABLE_CHANGE_USERNAME = True
    USER_ENABLE_CHANGE_PASSWORD = True
    USER_ENABLE_FORGOT_PASSWORD = True

def create_app(test_config=None):                   # For automated tests
    # Setup Flask and read config from ConfigClass defined above
    app = Flask(__name__)
    app.config.from_object(__name__+'.ConfigClass')

    # Load local_settings.py if file exists         # For automated tests
    try: app.config.from_object('local_settings')
    except: pass

    # Load optional test_config                     # For automated tests
    if test_config:
        app.config.update(test_config)

    # Initialize Flask extensions
    babel = Babel(app)                              # Initialize Flask-Babel
    db = SQLAlchemy(app)                            # Initialize Flask-SQLAlchemy
    mail = Mail(app)                                # Initialize Flask-Mail

    @babel.localeselector
    def get_locale():
        return request.accept_languages.best_match(['en', 'nl'])

    # Define the User-Roles pivot table
    user_roles = db.Table('user_roles',
        db.Column('id', db.Integer(), primary_key=True),
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id', ondelete='CASCADE')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id', ondelete='CASCADE')))

    # Define Role model
    class Role(db.Model):
        id = db.Column(db.Integer(), primary_key=True)
        name = db.Column(db.String(50), unique=True)

    # Define User model. Make sure to add flask.ext.user UserMixin!!
    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        active = db.Column(db.Boolean(), nullable=False, default=False)
        username = db.Column(db.String(50), nullable=True, unique=True)
        email = db.Column(db.String(255), nullable=True, unique=True)
        confirmed_at = db.Column(db.DateTime())
        password = db.Column(db.String(255), nullable=False, default='')
        reset_password_token = db.Column(db.String(100), nullable=False, default='')
        # Relationships
        roles = db.relationship('Role', secondary=user_roles,
                backref=db.backref('users', lazy='dynamic'))

    # Reset all the database tables
    db.create_all()

    # Setup Flask-User
    db_adapter = SQLAlchemyAdapter(db,  User)
    user_manager = UserManager(db_adapter, app)

    # Create 'user007' user with 'secret' and 'agent' roles
    if not User.query.filter(User.username=='user007').first():
        user1 = User(username='user007', email='user007@example.com', active=True,
                password=user_manager.hash_password('Password1'))
        user1.roles.append(Role(name='secret'))
        user1.roles.append(Role(name='agent'))
        db.session.add(user1)
        db.session.commit()

    # The '/' page is accessible to anyone
    @app.route('/')
    def home_page():
        # if current_user.is_authenticated():
        #     return profile_page()
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Home Page{%endtrans%}</h2>
            <p><a href="{{ url_for('user.login') }}">{%trans%}Sign in{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/profile' page requires a logged-in user
    @app.route('/profile')
    @login_required                                 # Use of @login_required decorator
    def profile_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Profile Page{%endtrans%}</h2>
            <p> {%trans%}Hello{%endtrans%}
                {{ current_user.username or current_user.email }},</p>
            <p> <a href="{{ url_for('user.change_username') }}">
                {%trans%}Change username{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.change_password') }}">
                {%trans%}Change password{%endtrans%}</a></p>
            <p> <a href="{{ url_for('user.logout') }}?next={{ url_for('user.login') }}">
                {%trans%}Sign out{%endtrans%}</a></p>
            {% endblock %}
            """)

    # The '/special' page requires a user that has the 'special' AND ('sauce' OR 'agent') role.
    @app.route('/special')
    @roles_required('secret', ['sauce', 'agent'])   # Use of @roles_required decorator
    def special_page():
        return render_template_string("""
            {% extends "base.html" %}
            {% block content %}
            <h2>{%trans%}Special Page{%endtrans%}</h2>
            {% endblock %}
            """)

    return app

# Start development web server
if __name__=='__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5001, debug=True)

########NEW FILE########
__FILENAME__ = tokens
""" This file contains functions to generate and verify tokens for Flask-User.
    Tokens contain an encoded user ID and a signature. The signature is managed by the itsdangerous module.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

import base64
from Crypto.Cipher import AES
from itsdangerous import BadSignature, SignatureExpired, TimestampSigner

class TokenManager(object):
    def setup(self, secret):
        """ Create a cypher to encrypt IDs and a signer to sign tokens."""
        # Create cypher to encrypt IDs
        key = secret + '0123456789abcdef'  # ensure >=16 characters
        sixteen_byte_key = key[0:16]  # get first 16 characters
        self.cipher = AES.new(sixteen_byte_key)

        # Create signer to sign tokens
        self.signer = TimestampSigner(secret)

    def encrypt_id(self, id):
        """ Encrypts integer ID to url-safe base64 string."""
        str1 = '%016d' % id                             # --> 16 byte integer string
        str2 = self.cipher.encrypt(str1)                # --> encrypted data
        str3 = base64.urlsafe_b64encode(str2)           # --> URL safe base64 string with '=='
        return str3[0:-2]                               # --> base64 string without '=='

    def decrypt_id(self, encrypted_id):
        """ Decrypts url-safe base64 string to integer ID"""
        # In Python3, encrypted_id is <type 'str'> and needs to be converted to bytes
        if type(encrypted_id)=='str':   # pragma: no covers
            encrypted_id = encrypted_id.encode('ascii')

        try:
            str3 = encrypted_id + b'=='             # --> base64 string with '=='
            str2 = base64.urlsafe_b64decode(str3)   # --> encrypted data
            str1 = self.cipher.decrypt(str2)        # --> 16 byte integer string
            return int(str1)                        # --> integer id
        except Exception as e:                      # pragma: no cover
            print('!!!Exception in decrypt_id!!!')
            return 0

    def generate_token(self, id):
        """ Return token with id, timestamp and signature"""
        # In Python3 we must make sure that bytes are converted to strings.
        # Hence the addition of '.decode()'
        return self.signer.sign(self.encrypt_id(id)).decode()

    def verify_token(self, token, expiration_in_seconds):
        """ Verify token and return (is_valid, has_expired, id).
            Returns (True, False, id) on success.
            Returns (False, True, None) on expired tokens.
            Returns (False, False, None) on invalid tokens."""
        try:
            data = self.signer.unsign(token, max_age=expiration_in_seconds)
            is_valid = True
            has_expired = False
            id = self.decrypt_id(data)
        except SignatureExpired:
            is_valid = False
            has_expired = True
            id = None
        except BadSignature:
            is_valid = False
            has_expired = False
            id = None
        return (is_valid, has_expired, id)
########NEW FILE########
__FILENAME__ = translations
""" This module contains functions to translate strings for Flask-User.
    The functions are based on Flask-Babel.

    It redefines flask_babel.get_translations() to change the following:
    - look for translations first in the app.root_dir, then in the flask_user dir
    - change the domain from 'messages' to 'flask_user'

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

import os
import gettext as python_gettext

from flask import _request_ctx_stack, current_app, render_template
from flask.ext.babel import get_locale, support

def get_translations():
    """ Search the Application directory and the Flask-User directory for the
        Flask-User translations file and return a Translations() object."""
    ctx = _request_ctx_stack.top
    if ctx is None:
        return None
    translations = getattr(ctx, 'flask_user_translations', None)
    if translations is None:
        # Prepare settings
        domain = 'flask_user'
        locales = [get_locale()]
        languages = [str(locale) for locale in locales]
        # Search Application directory
        app_dir = os.path.join(current_app.root_path, 'translations')
        filename = python_gettext.find(domain, app_dir, languages)
        if filename:
            translations = support.Translations.load(app_dir, locales, domain=domain)
        else:
            # Search Flask-User directory
            flask_user_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'translations')
            translations = support.Translations.load(flask_user_dir, locales, domain=domain)

        ctx.flask_user_translations = translations

    return ctx.flask_user_translations

def gettext(string, **variables):
    """ Translate specified string."""
    translations = get_translations()
    if not translations:
        return string % variables
    return translations.ugettext(string) % variables

def ngettext(singular, plural, num, **variables):
    """ Translate a singular/plural string based on the number 'num'."""
    translations = get_translations()
    variables.setdefault('num', num)
    if not translations:
        return (singular if num == 1 else plural) % variables
    return translations.ungettext(singular, plural, num) % variables

def lazy_gettext(string, **variables):
    """ Similar to 'gettext' but the string returned is lazy which means
        it will be translated when it is used as an actual string."""
    from speaklater import make_lazy_string
    return make_lazy_string(gettext, string, **variables)

_ = lazy_gettext
_home_page = _('Home Page')
_profile_page = _('Profile Page')
_special_page = _('Special Page')

########NEW FILE########
__FILENAME__ = views
""" This file contains view functions for Flask-User forms.

    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details."""

from datetime import datetime
from flask import current_app, flash, redirect, render_template, request, url_for
from flask.ext.login import current_user, login_user, logout_user
from .decorators import login_required
from . import emails
from . import signals
from .translations import gettext as _

def confirm_email(token):
    """ Verify email confirmation token and activate the user account."""
    # Verify token
    user_manager = current_app.user_manager
    db_adapter = user_manager.db_adapter
    is_valid, has_expired, object_id = user_manager.verify_token(
            token,
            user_manager.confirm_email_expiration)

    if has_expired:
        flash(_('Your confirmation token has expired.'), 'error')
        return redirect(user_manager.login_url)

    if not is_valid:
        flash(_('Invalid confirmation token.'), 'error')
        return redirect(user_manager.login_url)

    # Confirm email by setting User.active=True and User.confirmed_at=utcnow()
    if not db_adapter.EmailClass:
        user = user_manager.find_user_by_id(object_id)
        if user:
            db_adapter.update_object(user,
                    active=True,
                    confirmed_at=datetime.utcnow(),
                    )
            db_adapter.commit()
        else:                                               # pragma: no cover
            flash(_('Invalid confirmation token.'), 'error')
            return redirect(user_manager.login_url)
    else:
        raise NotImplementedError   # TODO:

    # Send email_confirmed signal
    signals.user_confirmed_email.send(current_app._get_current_object(), user=user)

    # Prepare one-time system message
    flash(_('Your email has been confirmed. Please sign in.'), 'success')

    # Retrieve 'next' query parameter
    next = request.args.get('next', '/')

    # Redirect to the login page with the specified 'next' query parameter
    return redirect(user_manager.login_url+'?next='+next)


@login_required
def change_password():
    """ Prompt for old password and new password and change the user's password."""
    user_manager =  current_app.user_manager
    db_adapter = user_manager.db_adapter

    # Initialize form
    form = user_manager.change_password_form(request.form)
    form.next.data = request.args.get('next', '/')  # Place ?next query param in next form field

    # Process valid POST
    if request.method=='POST' and form.validate():
        # Hash password
        hashed_password = user_manager.hash_password(form.new_password.data)

        # Change password
        db_adapter.update_object(current_user, password=hashed_password)
        db_adapter.commit()

        # Send 'password_changed' email
        if user_manager.enable_email and user_manager.send_password_changed_email:
            emails.send_password_changed_email(current_user.email, current_user)

        # Send password_changed signal
        signals.user_changed_password.send(current_app._get_current_object(), user=current_user)

        # Prepare one-time system message
        flash(_('Your password has been changed successfully.'), 'success')

        # Redirect to 'next' URL
        return redirect(form.next.data)

    # Process GET or invalid POST
    return render_template(user_manager.change_password_template, form=form)

@login_required
def change_username():
    """ Prompt for new username and old password and change the user's username."""
    user_manager =  current_app.user_manager
    db_adapter = user_manager.db_adapter

    # Initialize form
    form = user_manager.change_username_form(request.form)
    form.next.data = request.args.get('next', '/')  # Place ?next query param in next form field

    # Process valid POST
    if request.method=='POST' and form.validate():
        new_username = form.new_username.data

        # Change username
        db_adapter.update_object(current_user, username=new_username)
        db_adapter.commit()

        # Send 'username_changed' email
        if user_manager.enable_email and user_manager.send_username_changed_email:
            emails.send_username_changed_email(current_user.email, current_user)

        # Send username_changed signal
        signals.user_changed_username.send(current_app._get_current_object(), user=current_user)

        # Prepare one-time system message
        flash(_("Your username has been changed to '%(username)s'.", username=new_username), 'success')

        # Redirect to 'next' URL
        return redirect(form.next.data)

    # Process GET or invalid POST
    return render_template(user_manager.change_username_template, form=form)


def forgot_password():
    """Prompt for email and send reset password email."""
    user_manager =  current_app.user_manager
    db_adapter = user_manager.db_adapter

    # Initialize form
    form = user_manager.forgot_password_form(request.form)

    # Process valid POST
    if request.method=='POST' and form.validate():
        email = form.email.data

        # Find user by email
        user = user_manager.find_user_by_email(email)
        if user:
            # Generate reset password link
            token = user_manager.generate_token(user.id)
            reset_password_link = url_for('user.reset_password', token=token, _external=True)

            # Send forgot password email
            emails.send_forgot_password_email(email, user, reset_password_link)

            # Store token
            if hasattr(user, 'reset_password_token'):
                db_adapter.update_object(user, reset_password_token=token)
                db_adapter.commit()

            # Send forgot_password signal
            signals.user_forgot_password.send(current_app._get_current_object(), user=user)

        # Prepare one-time system message
        flash(_("A reset password email has been sent to '%(email)s'. Open that email and follow the instructions to reset your password.", email=email), 'success')

        # Redirect to the login page
        return redirect(url_for('user.login'))

    # Process GET or invalid POST
    return render_template(user_manager.forgot_password_template, form=form)


def login():
    """ Prompt for username/email and password and sign the user in."""
    user_manager =  current_app.user_manager

    # Initialize form
    form = user_manager.login_form(request.form)
    form.next.data = request.args.get('next', '/')  # Place ?next query param in next form field

    # Process valid POST
    if request.method=='POST' and form.validate():
        # Retrieve User
        if user_manager.enable_username:
            # Find user by username or email address
            user = user_manager.find_user_by_username(form.username.data)
            if not user and user_manager.enable_email:
                user = user_manager.find_user_by_email(form.username.data)
        else:
            # Find user by email address
            user = user_manager.find_user_by_email(form.email.data)

        if user:
            if user.active:
                # Use Flask-Login to sign in user
                login_user(user)

                # Send user_logged_in signal
                signals.user_logged_in.send(current_app._get_current_object(), user=user)

                # Prepare one-time system message
                flash(_('You have signed in successfully.'), 'success')

                # Redirect to 'next' URL
                return redirect(form.next.data)
            else:
                if user_manager.enable_confirm_email and not user.confirmed_at:
                    flash(_('Your email address has not yet been confirmed. Check your email Inbox and Spam folders for the confirmation email and follow the instructions to activate your account.'), 'error')
                else:
                    flash(_('Your account has been disabled.'), 'error')

    # Process GET or invalid POST
    return render_template(user_manager.login_template, form=form)

def logout():
    """ Sign the user out."""
    user_manager =  current_app.user_manager

    # Send user_logged_out signal
    signals.user_logged_out.send(current_app._get_current_object(), user=current_user)

    # Use Flask-Login to sign out user
    logout_user()

    # Prepare one-time system message
    flash(_('You have signed out successfully.'), 'success')

    # Redirect to logout_next endpoint or '/'
    next = request.args.get('next', '/')  # Get 'next' query param
    return redirect(next)


def register():
    """ Display registration form and create new User."""
    user_manager =  current_app.user_manager
    db_adapter = user_manager.db_adapter

    # Initialize form
    form = user_manager.register_form(request.form)

    # Process valid POST
    if request.method=='POST' and form.validate():

        # Create a User object using Form fields that have a corresponding User field
        User = user_manager.db_adapter.UserClass
        user_class_fields = User.__dict__
        user_fields = {}

        # Create a UserProfile object using Form fields that have a corresponding UserProfile field
        if user_manager.db_adapter.UserProfileClass:
            UserProfile = user_manager.db_adapter.UserProfileClass
            user_profile_class_fields = UserProfile.__dict__
            user_profile_fields = {}

        # User.active is True if not USER_ENABLE_CONFIRM_EMAIL and False otherwise
        user_fields['active'] = not user_manager.enable_confirm_email

        # For all form fields
        for field_name, field_value in form.data.items():
            # Hash password field
            if field_name=='password':
                user_fields['password'] = user_manager.hash_password(form.password.data)
            # Store corresponding Form fields into the User object and/or UserProfile object
            else:
                if field_name in user_class_fields:
                    user_fields[field_name] = field_value
                if user_manager.db_adapter.UserProfileClass:
                    if field_name in user_profile_class_fields:
                        user_profile_fields[field_name] = field_value

        # Add User record using named arguments 'user_fields'
        user = db_adapter.add_object(User, **user_fields)

        # Add UserProfile record using named arguments 'user_profile_fields'
        if user_manager.db_adapter.UserProfileClass:
            user.user_profile = db_adapter.add_object(UserProfile, **user_profile_fields)

        db_adapter.commit()

        # Send 'confirm_email' or 'registered' email
        if user_manager.enable_email:
            email_address = form.email.data

            try:
                if user_manager.enable_confirm_email:
                    # Send 'confirm_email' email

                    # Generate confirm email link
                    token = user_manager.generate_token(user.id)
                    confirm_email_link = url_for('user.confirm_email', token=token, _external=True)

                    # Send email
                    emails.send_confirm_email_email(email_address, user, confirm_email_link)
                else:
                    if user_manager.send_registered_email:
                        # Send 'registered' email
                        emails.send_registered_email(email_address, user)

            except Exception as e:
                # delete newly registered user if send email fails
                db_adapter.delete_object(user)
                db_adapter.commit()
                raise e

        # Send user_registered signal
        signals.user_registered.send(current_app._get_current_object(), user=user)

        # Prepare one-time system message
        if user_manager.enable_confirm_email:
            flash(_('A confirmation email has been sent to %(email)s with instructions to complete your registration.', email=email_address), 'success')
        else:
            flash(_('You have registered successfully. Please sign in.'), 'success')

        # Redirect to the login page
        return redirect(url_for('user.login'))

    # Process GET or invalid POST
    return render_template(user_manager.register_template, form=form)


# TODO:
def resend_confirm_email():
    pass

def reset_password(token):
    """ Verify the password reset token, Prompt for new password, and set the user's password."""
    # Verify token
    user_manager = current_app.user_manager
    db_adapter = user_manager.db_adapter

    is_valid, has_expired, user_id = user_manager.verify_token(
            token,
            user_manager.reset_password_expiration)

    if has_expired:
        flash(_('Your reset password token has expired.'), 'error')
        return redirect(user_manager.login_url)

    if not is_valid:
        flash(_('Your reset password token is invalid.'), 'error')
        return redirect(user_manager.login_url)

    user = user_manager.find_user_by_id(user_id)
    if user:
        # Avoid re-using old tokens
        if hasattr(user, 'reset_password_token'):
            verified = user.reset_password_token == token
        else:
            verified = True
    if not user or not verified:
        flash(_('Your reset password token is invalid.'), 'error')
        return redirect(user_manager.login_url)

    # Initialize form
    form = user_manager.reset_password_form(request.form)

    # Process valid POST
    if request.method=='POST' and form.validate():
        # Invalidate the token by clearing the stored token
        if hasattr(user, 'reset_password_token'):
            db_adapter.update_object(user, reset_password_token='')

        # Change password
        hashed_password = user_manager.hash_password(form.new_password.data)
        db_adapter.update_object(user, password=hashed_password)
        db_adapter.commit()

        # Send 'password_changed' email
        if user_manager.enable_email and user_manager.send_password_changed_email:
            emails.send_password_changed_email(user.email, user)

        # Prepare one-time system message
        flash(_("Your password has been reset successfully. Please sign in with your new password"), 'success')

        # Redirect to the login page
        return redirect(url_for('user.login'))

    # Process GET or invalid POST
    return render_template(user_manager.reset_password_template, form=form)

def unauthenticated():
    """ Prepare a Flash message and redirect to USER_UNAUTHENTICATED_URL"""
    # Prepare Flash message
    url = request.script_root + request.path
    flash(_("You must be signed in to access '%(url)s'.", url=url), 'error')

    # Redirect to USER_UNAUTHENTICATED_URL
    user_manager = current_app.user_manager
    return redirect(user_manager.unauthenticated_url+'?next='+url)

def unauthorized():
    """ Prepare a Flash message and redirect to USER_UNAUTHORIZED_URL"""
    # Prepare Flash message
    url = request.script_root + request.path
    flash(_("You do not have permission to access '%(url)s'.", url=url), 'error')

    # Redirect to USER_UNAUTHORIZED_URL
    user_manager = current_app.user_manager
    return redirect(user_manager.unauthorized_url)

########NEW FILE########
__FILENAME__ = runserver
from example_apps.minimal_app import app

app.run(host='0.0.0.0', port=5000, debug=True)


########NEW FILE########
