__FILENAME__ = api
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import logging
import string
import random
import base64

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.ext.cookies import Cookies

from django.utils import simplejson as json

template.register_template_library('v2ex.templatetags.filters')

from topic import TOPIC_PAGE_SIZE

class ApiHandler(webapp.RequestHandler):
    def write(self, output):
        if output is None:
            output = ''
        callback = self.request.get('callback', None)
        if callback:
            if not isinstance(output, unicode):
                output = output.decode('utf-8')
            self.response.headers['Content-type'] = 'application/javascript; charset=utf-8'
            output = '%s(%s)' % (callback, output)
        else:
            self.response.headers['Content-type'] = 'application/json; charset=utf-8'
        self.response.out.write(output)

# Site
# /api/site/stats.json
class SiteStatsHandler(ApiHandler):
    def get(self):
        template_values = {}
        template_values['topic_max'] = GetKindByName('Counter', 'topic.max')
        template_values['member_max'] = GetKindByName('Counter', 'member.max')
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'site_stats.json')
        output = template.render(path, template_values)
        self.write(output)

# /api/site/info.json
class SiteInfoHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'site_info.json')
        output = template.render(path, template_values)
        self.write(output)

# Nodes
# /api/nodes/all.json
class NodesAllHandler(ApiHandler):
    def get(self):
        output = memcache.get('api_nodes_all')
        if output is None:
            site = GetSite()
            template_values = {}
            template_values['site'] = site
            nodes = memcache.get('api_nodes_all')
            if nodes is None:
                nodes = db.GqlQuery("SELECT * FROM Node")
                memcache.set('api_nodes_all', nodes, 3600)
            template_values['nodes'] = nodes
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'nodes_all.json')
            output = template.render(path, template_values)
            memcache.set('api_nodes_all', output, 86400)
        self.write(output)

# /api/nodes/show.json
class NodesShowHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        method_determined = False
        parameter_id = self.request.get('id')
        if parameter_id:
            method_determined = True
        if method_determined is not True:
            parameter_name = self.request.get('name')
            if parameter_name:
                method_determined = True
        if method_determined is True:
            if parameter_id:
                node = GetKindByNum('Node', int(parameter_id))
            else:
                node = GetKindByName('Node', str(parameter_name))
            if node is not False:
                template_values['node'] = node
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'nodes_show.json')
                output = template.render(path, template_values)
                self.write(output)
            else:
                template_values['message'] = 'Node not found'
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
                output = template.render(path, template_values)
                self.write(output)
        else:
            template_values['message'] = "Required parameter id or name is missing"
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
            output = template.render(path, template_values)
            self.write(output)

# Topics
# /api/topics/latest.json
class TopicsLatestHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        topics = memcache.get('api_topics_latest')
        if topics is None:
            topics = db.GqlQuery("SELECT * FROM Topic ORDER BY created DESC LIMIT 20")
            memcache.set('api_topics_latest', topics, 120)
        template_values['topics'] = topics
        template_values['topics_count'] = topics.count()
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'topics_latest.json')
        output = template.render(path, template_values)
        self.write(output)

# /api/topics/show.json
class TopicsShowHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        method_determined = False
        parameter_id = self.request.get('id')
        parameter_username = False
        parameter_node_id = False
        parameter_node_name = False
        if parameter_id:
            method_determined = True
        if method_determined is False:
            parameter_username = self.request.get('username')
            if parameter_username:
                method_determined = True
        if method_determined is False:
            parameter_node_id = self.request.get('node_id')
            if parameter_node_id:
                method_determined = True
        if method_determined is False:
            parameter_node_name = self.request.get('node_name')
            if parameter_node_name:
                method_determined = True
        if method_determined is False:
            template_values['message'] = "Required parameter id, username, node_id or node_name is missing"
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
            output = template.render(path, template_values)
            self.response.set_status(400, 'Bad Request')
            self.write(output)
        else:
            topics = False
            topic = False
            if parameter_id:
                try:
                    topic = GetKindByNum('Topic', int(parameter_id))
                    if topic is not False:
                        topics = []
                        topics.append(topic)
                        template_values['topic'] = topic
                except:
                    topics = False
            if topics is False:
                if parameter_username:
                    one = GetMemberByUsername(parameter_username)
                    if one is not False:
                        topics = db.GqlQuery("SELECT * FROM Topic WHERE member_num = :1 ORDER BY created DESC LIMIT 20", one.num)
                        template_values['topics'] = topics
            if topics is False:
                try:
                    if parameter_node_id:
                        node = GetKindByNum('Node', int(parameter_node_id))
                        if node is not False:
                            topics = db.GqlQuery("SELECT * FROM Topic WHERE node_num = :1 ORDER BY last_touched DESC LIMIT 20", node.num)
                            template_values['topics'] = topics
                except:
                    topics = False
            if topics is False:
                if parameter_node_name:
                    node = GetKindByName('Node', str(parameter_node_name))
                    if node is not False:
                        topics = db.GqlQuery("SELECT * FROM Topic WHERE node_num = :1 ORDER BY last_touched DESC LIMIT 20", node.num)
                        template_values['topics'] = topics
            if topic or topics:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'topics_show.json')
                output = template.render(path, template_values)
                self.write(output)
            else:
                template_values['message'] = "Failed to get topics"
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
                output = template.render(path, template_values)
                self.response.set_status(400, 'Bad Request')
                self.write(output)

# /api/topics/create.json
class TopicsCreateHandler(webapp.RequestHandler):
    def post(self):
        authenticated = False
        if 'Authorization' in self.request.headers:
            auth = self.request.headers['Authorization']
            decoded = base64.b64decode(auth[6:])
            authenticated = True
        if authenticated:
            self.response.out.write('OK')
        else:    
            site = GetSite()
            template_values = {}
            template_values['site'] = site
            template_values['message'] = "Authentication required"
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
            output = template.render(path, template_values)
            self.response.set_status(401, 'Unauthorized')
            self.response.headers['Content-type'] = 'application/json'
            self.response.headers['WWW-Authenticate'] = 'Basic realm="' + site.domain + '"'
            self.response.out.write(output)

# Replies
# /api/replies/show.json
class RepliesShowHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        method_determined = False
        topic_id = self.request.get('topic_id')
        page = self.request.get('page', 1)
        page_size = TOPIC_PAGE_SIZE

        if topic_id:
            page_start = (int(page) - 1) * page_size
            replies = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 ORDER BY created ASC LIMIT " + str(page_start) + "," + str(page_size), int(topic_id))

            if replies:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'replies_show.json')
                template_values['replies'] = replies
                output = template.render(path, template_values)
                self.write(output)
            else:
                template_values['message'] = "Failed to get replies"
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
                output = template.render(path, template_values)
                self.response.set_status(400, 'Bad Request')
                self.write(output)
        else:
            template_values['message'] = "Required parameter topic_id is missing"
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
            output = template.render(path, template_values)
            self.response.set_status(400, 'Bad Request')
            self.write(output)

# Members
# /api/members/show.json
class MembersShowHandler(ApiHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        username = self.request.get('username')
        if username:
            one = GetMemberByUsername(username)
            if one is not False:
                if one.avatar_mini_url:
                    if (one.avatar_mini_url[0:1] == '/'):
                        one.avatar_mini_url = 'http://' + site.domain + one.avatar_mini_url
                        one.avatar_normal_url = 'http://' +  site.domain + one.avatar_normal_url
                        one.avatar_large_url = 'http://' + site.domain + one.avatar_large_url
                template_values['member'] = one
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'members_show.json')
                output = template.render(path, template_values)
                self.write(output)
            else:
                template_values['message'] = "Member not found"
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
                output = template.render(path, template_values)
                self.response.set_status(400, 'Bad Request')
                self.write(output)
        else:
            template_values['message'] = "Required parameter username is missing"
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'error.json')
            output = template.render(path, template_values)
            self.response.set_status(400, 'Bad Request')
            self.write(output)
                
class CurrencyHandler(ApiHandler):
    def get(self):
        codes = ['EUR', 'JPY', 'CNY', 'CHF', 'AUD', 'TWD', 'CAD', 'GBP', 'HKD', 'MYR', 'NZD', 'PHP', 'SGD', 'THB']
        template_values = {}
        o = memcache.get('currency.json')
        if o is not None:
            pass
        else:
            for code in codes:
                url = 'http://www.google.com/ig/calculator?hl=en&q=1USD=?' + code
                response = urlfetch.fetch(url)
                m = re.findall('rhs: "([0-9\.]+)', response.content)
                if len(m) > 0:
                    value = m[0].strip().replace(' ', '')
                else:
                    value = 0
                template_values[code.lower()] = value
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'currency.json')
            o = template.render(path, template_values)
            memcache.set('currency.json', o, 86400)
        self.write(o)

def main():
    application = webapp.WSGIApplication([
    ('/api/site/stats.json', SiteStatsHandler),
    ('/api/site/info.json', SiteInfoHandler),
    ('/api/nodes/all.json', NodesAllHandler),
    ('/api/nodes/show.json', NodesShowHandler),
    ('/api/topics/latest.json', TopicsLatestHandler),
    ('/api/topics/show.json', TopicsShowHandler),
    ('/api/topics/create.json', TopicsCreateHandler),
    ('/api/replies/show.json', RepliesShowHandler),
    ('/api/members/show.json', MembersShowHandler),
    ('/api/currency.json', CurrencyHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = appengine_console
#!/usr/bin/python
import code
import getpass
import sys

sys.path.append("/Applications/GoogleAppEngineLauncher.app/Contents/Resources/GoogleAppEngine-default.bundle/Contents/Resources/google_appengine")
sys.path.append("/Applications/GoogleAppEngineLauncher.app/Contents/Resources/GoogleAppEngine-default.bundle/Contents/Resources/google_appengine/lib/yaml/lib")

from google.appengine.ext.remote_api import remote_api_stub
from google.appengine.ext import db

def auth_func():
    return raw_input('Username:'), getpass.getpass('Password:')

if len(sys.argv) < 2:
    print "Usage: %s app_id [host]" % (sys.argv[0],)
app_id = sys.argv[1]
if len(sys.argv) > 2:
    host = sys.argv[2]
else:
    host = '%s.appspot.com' % app_id

remote_api_stub.ConfigureRemoteDatastore(app_id, '/remote_api', auth_func, host)

code.interact('App Engine interactive console for %s' % (app_id,), None, locals())
########NEW FILE########
__FILENAME__ = avatar
#!/usr/bin/env python
# coding=utf-8

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util

from v2ex.babel import Avatar

from v2ex.babel.security import *
from v2ex.babel.da import *
        
class AvatarHandler(webapp.RequestHandler):
    def get(self, member_num, size):
        avatar = GetKindByName('Avatar', 'avatar_' + str(member_num) + '_' + str(size))
        if avatar:
            self.response.headers['Content-Type'] = "image/png"
            self.response.headers['Cache-Control'] = "max-age=172800, public, must-revalidate"
            self.response.headers['Expires'] = "Sun, 25 Apr 2011 20:00:00 GMT"
            self.response.out.write(avatar.content)
        else:
            self.redirect('/static/img/avatar_' + str(size) + '.png')

class NodeAvatarHandler(webapp.RequestHandler):
    def get(self, node_num, size):
        avatar = GetKindByName('Avatar', 'node_' + str(node_num) + '_' + str(size))
        if avatar:
            self.response.headers['Content-Type'] = "image/png"
            self.response.headers['Cache-Control'] = "max-age=172800, public, must-revalidate"
            self.response.headers['Expires'] = "Sun, 25 Apr 2011 20:00:00 GMT"
            self.response.out.write(avatar.content)
        else:
            self.error(404)
            
def main():
    application = webapp.WSGIApplication([
    ('/avatar/([0-9]+)/(large|normal|mini)', AvatarHandler),
    ('/navatar/([0-9]+)/(large|normal|mini)', NodeAvatarHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = backstage
#!/usr/bin/env python
# coding=utf-8

import base64
import os
import re
import time
import datetime
import hashlib
import logging
import string
import StringIO
import random
import math

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import images
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Avatar
from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Site
from v2ex.babel import Minisite
from v2ex.babel import Page

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *

from v2ex.babel.handlers import BaseHandler

template.register_template_library('v2ex.templatetags.filters')

import config

class BackstageHomeHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values = {}
        template_values['l10n'] = l10n
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        template_values['system_version'] = SYSTEM_VERSION
        template_values['member'] = member
        template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8')
        member_total = memcache.get('member_total')
        if member_total is None:
            q3 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'member.total'")
            if (q3.count() > 0):
                member_total = q3[0].value
            else:
                member_total = 0
            memcache.set('member_total', member_total, 600)
        template_values['member_total'] = member_total
        topic_total = memcache.get('topic_total')
        if topic_total is None:
            q4 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'topic.total'")
            if (q4.count() > 0):
                topic_total = q4[0].value
            else:
                topic_total = 0
            memcache.set('topic_total', topic_total, 600)
        template_values['topic_total'] = topic_total
        reply_total = memcache.get('reply_total')
        if reply_total is None:
            q5 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'reply.total'")
            if (q5.count() > 0):
                reply_total = q5[0].value
            else:
                reply_total = 0
            memcache.set('reply_total', reply_total, 600)
        template_values['reply_total'] = reply_total
        if (member):
            if (member.level == 0):
                q = db.GqlQuery("SELECT * FROM Section ORDER BY nodes DESC")
                template_values['sections'] = q
                q2 = db.GqlQuery("SELECT * FROM Member ORDER BY created DESC LIMIT 5")
                template_values['latest_members'] = q2
                q3 = db.GqlQuery("SELECT * FROM Minisite ORDER BY created DESC")
                template_values['minisites'] = q3
                q4 = db.GqlQuery("SELECT * FROM Node ORDER BY last_modified DESC LIMIT 8")
                template_values['latest_nodes'] = q4
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_home.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_home.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
            
class BackstageNewMinisiteHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 添加新站点'
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):    
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_new_minisite.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 添加新站点'
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                errors = 0
                # Verification: name
                minisite_name_error = 0
                minisite_name_error_messages = ['',
                    u'请输入站点名',
                    u'站点名长度不能超过 32 个字符',
                    u'站点名只能由 a-Z 0-9 及 - 和 _ 组成',
                    u'抱歉这个站点名已经存在了']
                minisite_name = self.request.get('name').strip().lower()
                if (len(minisite_name) == 0):
                    errors = errors + 1
                    minisite_name_error = 1
                else:
                    if (len(minisite_name) > 32):
                        errors = errors + 1
                        minisite_name_error = 2
                    else:
                        if (re.search('^[a-zA-Z0-9\-\_]+$', minisite_name)):
                            q = db.GqlQuery('SELECT __key__ FROM Minisite WHERE name = :1', minisite_name.lower())
                            if (q.count() > 0):
                                errors = errors + 1
                                minisite_name_error = 4
                        else:
                            errors = errors + 1
                            minisite_name_error = 3
                template_values['minisite_name'] = minisite_name
                template_values['minisite_name_error'] = minisite_name_error
                template_values['minisite_name_error_message'] = minisite_name_error_messages[minisite_name_error]
                # Verification: title
                minisite_title_error = 0
                minisite_title_error_messages = ['',
                    u'请输入站点标题',
                    u'站点标题长度不能超过 32 个字符'
                ]
                minisite_title = self.request.get('title').strip()
                if (len(minisite_title) == 0):
                    errors = errors + 1
                    minisite_title_error = 1
                else:
                    if (len(minisite_title) > 32):
                        errors = errors + 1
                        minisite_title_error = 2
                template_values['minisite_title'] = minisite_title
                template_values['minisite_title_error'] = minisite_title_error
                template_values['minisite_title_error_message'] = minisite_title_error_messages[minisite_title_error]
                # Verification: description
                minisite_description_error = 0
                minisite_description_error_messages = ['',
                    u'请输入站点描述',
                    u'站点描述长度不能超过 2000 个字符'
                ]
                minisite_description = self.request.get('description').strip()
                if (len(minisite_description) == 0):
                    errors = errors + 1
                    minisite_description_error = 1
                else:
                    if (len(minisite_description) > 2000):
                        errors = errors + 1
                        minisite_description_error = 2
                template_values['minisite_description'] = minisite_description
                template_values['minisite_description_error'] = minisite_description_error
                template_values['minisite_description_error_message'] = minisite_description_error_messages[minisite_description_error]
                template_values['errors'] = errors
                if (errors == 0):
                    minisite = Minisite()
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'minisite.max')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value + 1
                    else:
                        counter = Counter()
                        counter.name = 'minisite.max'
                        counter.value = 1
                    minisite.num = counter.value
                    minisite.name = minisite_name
                    minisite.title = minisite_title
                    minisite.description = minisite_description
                    minisite.put()
                    counter.put()
                    self.redirect('/backstage')
                else:    
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_new_minisite.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
            
class BackstageMinisiteHandler(webapp.RequestHandler):
    def get(self, minisite_name):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › Minisite'
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                minisite = GetKindByName('Minisite', minisite_name)
                if minisite is not False:
                    template_values['minisite'] = minisite
                    template_values['page_title'] = site.title + u' › ' + minisite.title
                    q = db.GqlQuery("SELECT * FROM Page WHERE minisite = :1 ORDER BY weight ASC", minisite)
                    template_values['pages'] = q
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_minisite.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageNewPageHandler(webapp.RequestHandler):
    def get(self, minisite_name):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                minisite = GetKindByName('Minisite', minisite_name)
                if minisite is not False:
                    template_values['minisite'] = minisite
                    template_values['page_title'] = site.title + u' › ' + minisite.title + u' › 添加新页面'
                    template_values['page_content_type'] = 'text/html;charset=utf-8'
                    template_values['page_weight'] = 0
                    template_values['page_mode'] = 0
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_new_page.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

    def post(self, minisite_name):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                minisite = GetKindByName('Minisite', minisite_name)
                if minisite is False:
                    self.redirect('/backstage')
                else:
                    template_values['minisite'] = minisite
                    template_values['page_title'] = site.title + u' › ' + minisite.title + u' › 添加新页面'
                    errors = 0
                    # Verification: name
                    page_name_error = 0
                    page_name_error_messages = ['',
                        u'请输入页面名',
                        u'页面名长度不能超过 64 个字符',
                        u'页面名只能由 a-Z 0-9 及 . - _ 组成',
                        u'抱歉这个页面名已经存在了']
                    page_name = self.request.get('name').strip().lower()
                    if (len(page_name) == 0):
                        errors = errors + 1
                        page_name_error = 1
                    else:
                        if (len(page_name) > 64):
                            errors = errors + 1
                            page_name_error = 2
                        else:
                            if (re.search('^[a-zA-Z0-9\-\_\.]+$', page_name)):
                                q = db.GqlQuery('SELECT * FROM Page WHERE name = :1', page_name.lower())
                                if (q.count() > 0):
                                    if q[0].minisite.name == minisite.name:
                                        errors = errors + 1
                                        page_name_error = 4
                            else:
                                errors = errors + 1
                                page_name_error = 3
                    template_values['page_name'] = page_name
                    template_values['page_name_error'] = page_name_error
                    template_values['page_name_error_message'] = page_name_error_messages[page_name_error]
                    # Verification: title
                    page_t_error = 0
                    page_t_error_messages = ['',
                        u'请输入页面标题',
                        u'页面标题长度不能超过 100 个字符'
                    ]
                    page_t = self.request.get('t').strip()
                    if (len(page_t) == 0):
                        errors = errors + 1
                        page_t_error = 1
                    else:
                        if (len(page_t) > 100):
                            errors = errors + 1
                            page_t_error = 2
                    template_values['page_t'] = page_t
                    template_values['page_t_error'] = page_t_error
                    template_values['page_t_error_message'] = page_t_error_messages[page_t_error]
                    # Verification: content
                    page_content_error = 0
                    page_content_error_messages = ['',
                        u'请输入页面内容',
                        u'页面内容长度不能超过 200000 个字符'
                    ]
                    page_content = self.request.get('content').strip()
                    if (len(page_content) == 0):
                        errors = errors + 1
                        page_content_error = 1
                    else:
                        if (len(page_content) > 200000):
                            errors = errors + 1
                            page_content_error = 2
                    template_values['page_content'] = page_content
                    template_values['page_content_error'] = page_content_error
                    template_values['page_content_error_message'] = page_content_error_messages[page_content_error]
                    # Verification: mode
                    page_mode = 0
                    page_mode = self.request.get('mode').strip()
                    if page_mode == '1':
                        page_mode = 1
                    else:
                        page_mode = 0
                    # Verification: content_type
                    page_content_type = self.request.get('content_type').strip()
                    if (len(page_content_type) == 0):
                        page_content_type = 'text/html;charset=utf-8'
                    else:
                        if (len(page_content_type) > 40):
                            page_content_type = 'text/html;charset=utf-8'
                    template_values['page_content_type'] = page_content_type
                    # Verification: weight
                    page_weight = self.request.get('weight').strip()
                    if (len(page_content_type) == 0):
                        page_content_type = 0
                    else:
                        if (len(page_weight) > 9):
                            page_weight = 0
                        else:
                            try:
                                page_weight = int(page_weight)
                            except:
                                page_weight = 0
                    template_values['page_weight'] = page_weight
                    template_values['errors'] = errors
                    if (errors == 0):
                        page = Page(parent=minisite)
                        q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'page.max')
                        if (q.count() == 1):
                            counter = q[0]
                            counter.value = counter.value + 1
                        else:
                            counter = Counter()
                            counter.name = 'page.max'
                            counter.value = 1
                        q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'page.total')
                        if (q2.count() == 1):
                            counter2 = q[0]
                            counter2.value = counter.value + 1
                        else:
                            counter2 = Counter()
                            counter2.name = 'page.total'
                            counter2.value = 1
                        page.num = counter.value
                        page.name = page_name
                        page.title = page_t
                        page.content = page_content
                        if page_mode == 1:
                            from django.template import Context, Template
                            t = Template(page_content)
                            c = Context({"site" : site, "minisite" : page.minisite, "page" : page})
                            output = t.render(c)
                            page.content_rendered = output
                        else:
                            page.content_rendered = page_content
                        page.content_type = page_content_type
                        page.weight = page_weight
                        page.mode = page_mode
                        page.minisite = minisite
                        page.put()
                        counter.put()
                        counter2.put()
                        minisite.pages = minisite.pages + 1
                        minisite.put()
                        memcache.delete('Minisite_' + str(minisite.num))
                        memcache.delete('Minisite::' + str(minisite.name))
                        self.redirect('/backstage/minisite/' + minisite.name)
                    else:    
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_new_page.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageRemoveMinisiteHandler(webapp.RequestHandler):
    def get(self, minisite_key):
        member = CheckAuth(self)
        if member:
            if member.level == 0:
                minisite = db.get(db.Key(minisite_key))
                if minisite:
                    # Delete all contents
                    pages = db.GqlQuery("SELECT * FROM Page WHERE minisite = :1", minisite)
                    for page in pages:
                        memcache.delete('Page_' + str(page.num))
                        memcache.delete('Page::' + str(page.name))
                        memcache.delete(minisite.name + '/' + page.name)
                        page.delete()
                    minisite.pages = 0
                    minisite.put()
                    # Delete the minisite
                    memcache.delete('Minisite_' + str(minisite.num))
                    memcache.delete('Minisite::' + str(minisite.name))
                    minisite.delete()
                    self.redirect('/backstage')
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstagePageHandler(webapp.RequestHandler):
    def get(self, page_key):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                page = db.get(db.Key(page_key))
                if page:
                    minisite = page.minisite
                    template_values['page'] = page
                    template_values['minisite'] = minisite
                    template_values['page_title'] = site.title + u' › ' + minisite.title + u' › ' + page.title + u' › 编辑'
                    template_values['page_name'] = page.name
                    template_values['page_t'] = page.title
                    template_values['page_content'] = page.content
                    template_values['page_content_type'] = page.content_type
                    template_values['page_mode'] = page.mode
                    template_values['page_weight'] = page.weight
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_page.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

    def post(self, page_key):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                page = db.get(db.Key(page_key))
                if page:
                    minisite = page.minisite
                    template_values['minisite'] = minisite
                    template_values['page_title'] = site.title + u' › ' + minisite.title + u' › 添加新页面'
                    errors = 0
                    # Verification: name
                    page_name_error = 0
                    page_name_error_messages = ['',
                        u'请输入页面名',
                        u'页面名长度不能超过 64 个字符',
                        u'页面名只能由 a-Z 0-9 及 . - _ 组成',
                        u'抱歉这个页面名已经存在了']
                    page_name = self.request.get('name').strip().lower()
                    if (len(page_name) == 0):
                        errors = errors + 1
                        page_name_error = 1
                    else:
                        if (len(page_name) > 64):
                            errors = errors + 1
                            page_name_error = 2
                        else:
                            if (re.search('^[a-zA-Z0-9\-\_\.]+$', page_name)):
                                q = db.GqlQuery('SELECT * FROM Page WHERE name = :1 AND minisite = :2', page_name.lower(), page.minisite)
                                if (q.count() > 0):
                                    if q[0].num != page.num:
                                        errors = errors + 1
                                        page_name_error = 4
                            else:
                                errors = errors + 1
                                page_name_error = 3
                    template_values['page_name'] = page_name
                    template_values['page_name_error'] = page_name_error
                    template_values['page_name_error_message'] = page_name_error_messages[page_name_error]
                    # Verification: title
                    page_t_error = 0
                    page_t_error_messages = ['',
                        u'请输入页面标题',
                        u'页面标题长度不能超过 100 个字符'
                    ]
                    page_t = self.request.get('t').strip()
                    if (len(page_t) == 0):
                        errors = errors + 1
                        page_t_error = 1
                    else:
                        if (len(page_t) > 100):
                            errors = errors + 1
                            page_t_error = 2
                    template_values['page_t'] = page_t
                    template_values['page_t_error'] = page_t_error
                    template_values['page_t_error_message'] = page_t_error_messages[page_t_error]
                    # Verification: content
                    page_content_error = 0
                    page_content_error_messages = ['',
                        u'请输入页面内容',
                        u'页面内容长度不能超过 200000 个字符'
                    ]
                    page_content = self.request.get('content').strip()
                    if (len(page_content) == 0):
                        errors = errors + 1
                        page_content_error = 1
                    else:
                        if (len(page_content) > 200000):
                            errors = errors + 1
                            page_content_error = 2
                    template_values['page_content'] = page_content
                    template_values['page_content_error'] = page_content_error
                    template_values['page_content_error_message'] = page_content_error_messages[page_content_error]
                    # Verification: mode
                    page_mode = 0
                    page_mode = self.request.get('mode').strip()
                    if page_mode == '1':
                        page_mode = 1
                    else:
                        page_mode = 0
                    # Verification: content_type
                    page_content_type = self.request.get('content_type').strip()
                    if (len(page_content_type) == 0):
                        page_content_type = 'text/html;charset=utf-8'
                    else:
                        if (len(page_content_type) > 40):
                            page_content_type = 'text/html;charset=utf-8'
                    template_values['page_content_type'] = page_content_type
                    # Verification: weight
                    page_weight = self.request.get('weight').strip()
                    if (len(page_content_type) == 0):
                        page_content_type = 0
                    else:
                        if (len(page_weight) > 9):
                            page_weight = 0
                        else:
                            try:
                                page_weight = int(page_weight)
                            except:
                                page_weight = 0
                    template_values['page_weight'] = page_weight
                    template_values['errors'] = errors
                    if (errors == 0):
                        page.name = page_name
                        page.title = page_t
                        page.content = page_content
                        if page.mode == 1:
                            from django.template import Context, Template
                            t = Template(page_content)
                            c = Context({"site" : site, "minisite" : page.minisite, "page" : page})
                            output = t.render(c)
                            page.content_rendered = output
                        else:
                            page.content_rendered = page_content
                        page.content_type = page_content_type
                        page.mode = page_mode
                        page.weight = page_weight
                        page.put()
                        memcache.delete('Page_' + str(page.num))
                        memcache.delete('Page::' + str(page.name))
                        memcache.delete(minisite.name + '/' + page.name)
                        self.redirect('/backstage/minisite/' + minisite.name)
                    else:    
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_page.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
class BackstageRemovePageHandler(webapp.RequestHandler):
    def get(self, page_key):
        member = CheckAuth(self)
        if member:
            if member.level == 0:
                page = db.get(db.Key(page_key))
                if page:
                    memcache.delete('Page_' + str(page.num))
                    memcache.delete('Page::' + str(page.name))
                    memcache.delete(page.minisite.name + '/' + page.name)
                    minisite = page.minisite
                    page.delete()
                    minisite.pages = minisite.pages - 1
                    minisite.put()
                    self.redirect('/backstage/minisite/' + minisite.name)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageNewSectionHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):    
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_new_section.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                errors = 0
                # Verification: name
                section_name_error = 0
                section_name_error_messages = ['',
                    u'请输入区域名',
                    u'区域名长度不能超过 32 个字符',
                    u'区域名只能由 a-Z 0-9 及 - 和 _ 组成',
                    u'抱歉这个区域名已经存在了']
                section_name = self.request.get('name').strip().lower()
                if (len(section_name) == 0):
                    errors = errors + 1
                    section_name_error = 1
                else:
                    if (len(section_name) > 32):
                        errors = errors + 1
                        section_name_error = 2
                    else:
                        if (re.search('^[a-zA-Z0-9\-\_]+$', section_name)):
                            q = db.GqlQuery('SELECT __key__ FROM Section WHERE name = :1', section_name.lower())
                            if (q.count() > 0):
                                errors = errors + 1
                                section_name_error = 4
                        else:
                            errors = errors + 1
                            section_name_error = 3
                template_values['section_name'] = section_name
                template_values['section_name_error'] = section_name_error
                template_values['section_name_error_message'] = section_name_error_messages[section_name_error]
                # Verification: title
                section_title_error = 0
                section_title_error_messages = ['',
                    u'请输入区域标题',
                    u'区域标题长度不能超过 32 个字符'
                ]
                section_title = self.request.get('title').strip()
                if (len(section_title) == 0):
                    errors = errors + 1
                    section_title_error = 1
                else:
                    if (len(section_title) > 32):
                        errors = errors + 1
                        section_title_error = 2
                template_values['section_title'] = section_title
                template_values['section_title_error'] = section_title_error
                template_values['section_title_error_message'] = section_title_error_messages[section_title_error]
                # Verification: title
                section_title_alternative_error = 0
                section_title_alternative_error_messages = ['',
                    u'请输入区域副标题',
                    u'区域标题长度不能超过 32 个字符'
                ]
                section_title_alternative = self.request.get('title_alternative').strip()
                if (len(section_title_alternative) == 0):
                    errors = errors + 1
                    section_title_alternative_error = 1
                else:
                    if (len(section_title_alternative) > 32):
                        errors = errors + 1
                        section_title_alternative_error = 2
                template_values['section_title_alternative'] = section_title_alternative
                template_values['section_title_alternative_error'] = section_title_alternative_error
                template_values['section_title_alternative_error_message'] = section_title_alternative_error_messages[section_title_alternative_error]
                template_values['errors'] = errors
                if (errors == 0):
                    section = Section()
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'section.max')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value + 1
                    else:
                        counter = Counter()
                        counter.name = 'section.max'
                        counter.value = 1
                    section.num = counter.value
                    section.name = section_name
                    section.title = section_title
                    section.title_alternative = section_title_alternative
                    section.put()
                    counter.put()
                    self.redirect('/backstage')
                else:    
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_new_section.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageSectionHandler(webapp.RequestHandler):
    def get(self, section_name):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['rnd'] = random.randrange(1, 100)
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                template_values['member'] = member
                q = db.GqlQuery("SELECT * FROM Section WHERE name = :1", section_name)
                section = False
                if (q.count() == 1):
                    section = q[0]
                    template_values['section'] = section
                    template_values['page_title'] = site.title + u' › 后台 › ' + section.title
                    template_values['section_name'] = section.name
                    template_values['section_title'] = section.title
                    template_values['section_title_alternative'] = section.title_alternative
                    if section.header:
                        template_values['section_header'] = section.header
                    else:
                        template_values['section_header'] = ''
                    if section.footer:
                        template_values['section_footer'] = section.footer
                    else:
                        template_values['section_footer'] = ''
                else:
                    template_values['section'] = section
                if (section):
                    template_values['section'] = section
                    q2 = db.GqlQuery("SELECT * FROM Node WHERE section_num = :1 ORDER BY last_modified DESC LIMIT 10", section.num)
                    template_values['recent_modified'] = q2
                else:
                    template_values['nodes'] = False
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_section.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_section.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self, section_name):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['rnd'] = random.randrange(1, 100)
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['member'] = member
                section = GetKindByName('Section', section_name)
                if section is not False:
                    template_values['section'] = section
                    errors = 0
                    # Verification: name
                    section_name_error = 0
                    section_name_error_messages = ['',
                        u'请输入区域名',
                        u'区域名长度不能超过 32 个字符',
                        u'区域名只能由 a-Z 0-9 及 - 和 _ 组成',
                        u'抱歉这个区域名已经存在了']
                    section_name = self.request.get('name').strip().lower()
                    if (len(section_name) == 0):
                        errors = errors + 1
                        section_name_error = 1
                    else:
                        if (len(section_name) > 32):
                            errors = errors + 1
                            section_name_error = 2
                        else:
                            if (re.search('^[a-zA-Z0-9\-\_]+$', section_name)):
                                q = db.GqlQuery('SELECT * FROM Section WHERE name = :1', section_name.lower())
                                if (q.count() > 0):
                                    for possible_conflict in q:
                                        if possible_conflict.num != section.num:
                                            errors = errors + 1
                                            section_name_error = 4
                            else:
                                errors = errors + 1
                                section_name_error = 3
                    template_values['section_name'] = section_name
                    template_values['section_name_error'] = section_name_error
                    template_values['section_name_error_message'] = section_name_error_messages[section_name_error]
                    # Verification: title
                    section_title_error = 0
                    section_title_error_messages = ['',
                        u'请输入区域标题',
                        u'区域标题长度不能超过 32 个字符'
                    ]
                    section_title = self.request.get('title').strip()
                    if (len(section_title) == 0):
                        errors = errors + 1
                        section_title_error = 1
                    else:
                        if (len(section_title) > 32):
                            errors = errors + 1
                            section_title_error = 2
                    template_values['section_title'] = section_title
                    template_values['section_title_error'] = section_title_error
                    template_values['section_title_error_message'] = section_title_error_messages[section_title_error]
                    # Verification: title_alternative
                    section_title_alternative_error = 0
                    section_title_alternative_error_messages = ['',
                        u'请输入区域副标题',
                        u'区域标题长度不能超过 32 个字符'
                    ]
                    section_title_alternative = self.request.get('title_alternative').strip()
                    if (len(section_title_alternative) == 0):
                        errors = errors + 1
                        section_title_alternative_error = 1
                    else:
                        if (len(section_title_alternative) > 32):
                            errors = errors + 1
                            section_title_alternative_error = 2
                    template_values['section_title_alternative'] = section_title_alternative
                    template_values['section_title_alternative_error'] = section_title_alternative_error
                    template_values['section_title_alternative_error_message'] = section_title_alternative_error_messages[section_title_alternative_error]
                    # Verification: header
                    section_header_error = 0
                    section_header_error_messages = ['',
                        u'区域头部信息不能超过 1000 个字符'
                    ]
                    section_header = self.request.get('header').strip()
                    if len(section_header) > 1000:
                        errors = errors + 1
                        section_header_error = 1
                    template_values['section_header'] = section_header
                    template_values['section_header_error'] = section_header_error
                    template_values['section_header_error_message'] = section_header_error_messages[section_header_error]
                    # Verification: footer
                    section_footer_error = 0
                    section_footer_error_messages = ['',
                        u'区域尾部信息不能超过 1000 个字符'
                    ]
                    section_footer = self.request.get('footer').strip()
                    if len(section_footer) > 1000:
                        errors = errors + 1
                        section_footer_error = 1
                    template_values['section_footer'] = section_footer
                    template_values['section_footer_error'] = section_footer_error
                    template_values['section_footer_error_message'] = section_footer_error_messages[section_footer_error]
                    template_values['errors'] = errors
                    if (errors == 0):
                        memcache.delete('Section::' + section.name)
                        section.name = section_name
                        section.title = section_title
                        section.title_alternative = section_title_alternative
                        section.header = section_header
                        section.footer = section_footer
                        section.put()
                        memcache.delete('Section_' + str(section.num))
                        memcache.delete('Section::' + section_name)
                        self.redirect('/backstage')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_section.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    self.redirect('/backstage')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageNewNodeHandler(webapp.RequestHandler):
    def get(self, section_name):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                template_values['member'] = CheckAuth(self)
                q = db.GqlQuery("SELECT * FROM Section WHERE name = :1", section_name)
                if (q.count() == 1):
                    template_values['section'] = q[0]
                else:
                    template_values['section'] = False
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_new_node.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

    def post(self, section_name):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):        
                template_values['member'] = member
                section = False
                q = db.GqlQuery("SELECT * FROM Section WHERE name = :1", section_name)
                if (q.count() == 1):
                    section = q[0]
                    template_values['section'] = section
                else:
                    template_values['section'] = False
                errors = 0
                # Verification: name
                node_name_error = 0
                node_name_error_messages = ['',
                    u'请输入节点名',
                    u'节点名长度不能超过 32 个字符',
                    u'节点名只能由 a-Z 0-9 及 - 和 _ 组成',
                    u'抱歉这个节点名已经存在了']
                node_name = self.request.get('name').strip().lower()
                if (len(node_name) == 0):
                    errors = errors + 1
                    node_name_error = 1
                else:
                    if (len(node_name) > 32):
                        errors = errors + 1
                        node_name_error = 2
                    else:
                        if (re.search('^[a-zA-Z0-9\-\_]+$', node_name)):
                            q = db.GqlQuery('SELECT __key__ FROM Node WHERE name = :1', node_name.lower())
                            if (q.count() > 0):
                                errors = errors + 1
                                node_name_error = 4
                        else:
                            errors = errors + 1
                            node_name_error = 3
                template_values['node_name'] = node_name
                template_values['node_name_error'] = node_name_error
                template_values['node_name_error_message'] = node_name_error_messages[node_name_error]
                # Verification: title
                node_title_error = 0
                node_title_error_messages = ['',
                    u'请输入节点标题',
                    u'节点标题长度不能超过 32 个字符'
                ]
                node_title = self.request.get('title').strip()
                if (len(node_title) == 0):
                    errors = errors + 1
                    node_title_error = 1
                else:
                    if (len(node_title) > 32):
                        errors = errors + 1
                        node_title_error = 2
                template_values['node_title'] = node_title
                template_values['node_title_error'] = node_title_error
                template_values['node_title_error_message'] = node_title_error_messages[node_title_error]
                # Verification: title
                node_title_alternative_error = 0
                node_title_alternative_error_messages = ['',
                    u'请输入节点副标题',
                    u'节点标题长度不能超过 32 个字符'
                ]
                node_title_alternative = self.request.get('title_alternative').strip()
                if (len(node_title_alternative) == 0):
                    errors = errors + 1
                    node_title_alternative_error = 1
                else:
                    if (len(node_title_alternative) > 32):
                        errors = errors + 1
                        node_title_alternative_error = 2
                template_values['node_title_alternative'] = node_title_alternative
                template_values['node_title_alternative_error'] = node_title_alternative_error
                template_values['node_title_alternative_error_message'] = node_title_alternative_error_messages[node_title_alternative_error]
                template_values['errors'] = errors
                if (errors == 0):
                    node = Node()
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'node.max')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value + 1
                    else:
                        counter = Counter()
                        counter.name = 'node.max'
                        counter.value = 1
                    node.num = counter.value
                    node.section_num = section.num
                    node.name = node_name
                    node.title = node_title
                    node.title_alternative = node_title_alternative
                    node.put()
                    counter.put()
                    memcache.delete('index_categories')
                    memcache.delete('home_nodes_new')
                    self.redirect('/backstage/node/' + node.name)
                else:    
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_new_node.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')


class BackstageNodeHandler(webapp.RequestHandler):
    def get(self, node_name):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):
                template_values['member'] = member
                q = db.GqlQuery("SELECT * FROM Node WHERE name = :1", node_name)
                if (q.count() == 1):
                    node = q[0]
                    if node.parent_node_name is None:
                        siblings = []
                    else:
                        siblings = db.GqlQuery("SELECT * FROM Node WHERE parent_node_name = :1 AND name != :2", node.parent_node_name, node.name)
                    template_values['siblings'] = siblings
                    template_values['node'] = node
                    template_values['node_name'] = node.name
                    template_values['node_title'] = node.title
                    template_values['node_title_alternative'] = q[0].title_alternative
                    if q[0].category is None:
                        template_values['node_category'] = ''
                    else:
                        template_values['node_category'] = q[0].category
                    if q[0].parent_node_name is None:
                        template_values['node_parent_node_name'] = ''
                    else:
                        template_values['node_parent_node_name'] = q[0].parent_node_name
                    if q[0].header is None:
                        template_values['node_header'] = ''
                    else:
                        template_values['node_header'] = q[0].header
                    if q[0].footer is None:
                        template_values['node_footer'] = ''
                    else:
                        template_values['node_footer'] = q[0].footer
                    if q[0].sidebar is None:
                        template_values['node_sidebar'] = ''
                    else:
                        template_values['node_sidebar'] = q[0].sidebar
                    if q[0].sidebar_ads is None:
                        template_values['node_sidebar_ads'] = ''
                    else:
                        template_values['node_sidebar_ads'] = q[0].sidebar_ads
                    template_values['node_topics'] = q[0].topics
                else:
                    template_values['node'] = False
                section = GetKindByNum('Section', node.section_num)
                template_values['section'] = section
                if section is not False:
                    template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + section.title + u' › ' + node.title
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_node.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_node.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self, node_name):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if (member.level == 0):        
                template_values['member'] = member
                node = False
                q = db.GqlQuery("SELECT * FROM Node WHERE name = :1", node_name)
                if (q.count() == 1):
                    node = q[0]
                    template_values['node'] = q[0]
                    template_values['node_name'] = q[0].name
                    template_values['node_title'] = q[0].title
                    template_values['node_title_alternative'] = q[0].title_alternative
                    if q[0].category is None:
                        template_values['node_category'] = ''
                    else:
                        template_values['node_category'] = q[0].category
                    if q[0].parent_node_name is None:
                        template_values['node_parent_node_name'] = ''
                    else:
                        template_values['node_parent_node_name'] = q[0].parent_node_name
                    if q[0].header is None:
                        template_values['node_header'] = ''
                    else:
                        template_values['node_header'] = q[0].header
                    if q[0].footer is None:
                        template_values['node_footer'] = ''
                    else:
                        template_values['node_footer'] = q[0].footer
                    if q[0].sidebar is None:
                        template_values['node_sidebar'] = ''
                    else:
                        template_values['node_sidebar'] = q[0].sidebar
                    if q[0].sidebar_ads is None:
                        template_values['node_sidebar_ads'] = ''
                    else:
                        template_values['node_sidebar_ads'] = q[0].sidebar_ads
                    template_values['node_topics'] = q[0].topics
                else:
                    template_values['node'] = False
                section = False
                q2 = db.GqlQuery("SELECT * FROM Section WHERE num = :1", q[0].section_num)
                if (q2.count() == 1):
                    section = q2[0]
                    template_values['section'] = q2[0]
                else:
                    template_values['section'] = False
                if section is not False:
                    template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + section.title + u' › ' + node.title
                errors = 0
                # Verification: name
                node_name_error = 0
                node_name_error_messages = ['',
                    u'请输入节点名',
                    u'节点名长度不能超过 32 个字符',
                    u'节点名只能由 a-Z 0-9 及 - 和 _ 组成',
                    u'抱歉这个节点名已经存在了']
                node_name = self.request.get('name').strip().lower()
                if (len(node_name) == 0):
                    errors = errors + 1
                    node_name_error = 1
                else:
                    if (len(node_name) > 32):
                        errors = errors + 1
                        node_name_error = 2
                    else:
                        if (re.search('^[a-zA-Z0-9\-\_]+$', node_name)):
                            q = db.GqlQuery('SELECT * FROM Node WHERE name = :1 AND num != :2', node_name.lower(), node.num)
                            if (q.count() > 0):
                                errors = errors + 1
                                node_name_error = 4
                        else:
                            errors = errors + 1
                            node_name_error = 3
                template_values['node_name'] = node_name
                template_values['node_name_error'] = node_name_error
                template_values['node_name_error_message'] = node_name_error_messages[node_name_error]
                # Verification: title
                node_title_error = 0
                node_title_error_messages = ['',
                    u'请输入节点标题',
                    u'节点标题长度不能超过 32 个字符'
                ]
                node_title = self.request.get('title').strip()
                if (len(node_title) == 0):
                    errors = errors + 1
                    node_title_error = 1
                else:
                    if (len(node_title) > 32):
                        errors = errors + 1
                        node_title_error = 2
                template_values['node_title'] = node_title
                template_values['node_title_error'] = node_title_error
                template_values['node_title_error_message'] = node_title_error_messages[node_title_error]
                # Verification: title_alternative
                node_title_alternative_error = 0
                node_title_alternative_error_messages = ['',
                    u'请输入节点副标题',
                    u'节点标题长度不能超过 32 个字符'
                ]
                node_title_alternative = self.request.get('title_alternative').strip()
                if (len(node_title_alternative) == 0):
                    errors = errors + 1
                    node_title_alternative_error = 1
                else:
                    if (len(node_title_alternative) > 32):
                        errors = errors + 1
                        node_title_alternative_error = 2
                template_values['node_title_alternative'] = node_title_alternative
                template_values['node_title_alternative_error'] = node_title_alternative_error
                template_values['node_title_alternative_error_message'] = node_title_alternative_error_messages[node_title_alternative_error]
                # Verification: node_category
                node_category = self.request.get('category').strip()
                template_values['node_category'] = node_category
                # Verification: node_parent_node_name
                node_parent_node_name = self.request.get('parent_node_name').strip()
                template_values['node_parent_node_name'] = node_parent_node_name
                # Verification: node_header
                node_header = self.request.get('header').strip()
                template_values['node_header'] = node_header
                # Verification: node_footer
                node_footer = self.request.get('footer').strip()
                template_values['node_footer'] = node_footer
                # Verification: node_sidebar
                node_sidebar = self.request.get('sidebar').strip()
                template_values['node_sidebar'] = node_sidebar
                # Verification: node_sidebar_ads
                node_sidebar_ads = self.request.get('sidebar_ads').strip()
                template_values['node_sidebar_ads'] = node_sidebar_ads
                template_values['errors'] = errors
                if (errors == 0):
                    node.name = node_name
                    node.title = node_title
                    node.title_alternative = node_title_alternative
                    node.category = node_category
                    node.parent_node_name = node_parent_node_name
                    node.header = node_header
                    node.footer = node_footer
                    node.sidebar = node_sidebar
                    node.sidebar_ads = node_sidebar_ads
                    node.put()
                    memcache.delete('Node_' + str(node.num))
                    memcache.delete('Node::' + node.name)
                    memcache.delete('index_categories')
                    memcache.delete('home_nodes_new')
                    self.redirect('/backstage/section/' + section.name)
                else:    
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'backstage_node.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')


class BackstageNodeAvatarHandler(BaseHandler):
    def get(self, node_name):
        self.redirect('/backstage/node/' + node_name)
    
    def post(self, node_name):
        if self.member:
            if self.member.level == 0:
                node = GetKindByName('Node', node_name)
                if node is None:
                    return self.redirect('/backstage')
                dest = '/backstage/node/' + node.name
                timestamp = str(int(time.time()))
                try:
                    avatar = self.request.get('avatar')
                except:
                    return self.redirect(dest)
                if avatar is None:
                    return self.redirect(dest)
                avatar_len = len(avatar)
                if avatar_len == 0:
                    return self.redirect(dest)
                avatar_73 = images.resize(avatar, 73, 73)
                avatar_48 = images.resize(avatar, 48, 48)
                avatar_24 = images.resize(avatar, 24, 24)
                # Large 73x73
                q1 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'node_' + str(node.num) + '_large')
                if (q1.count() == 1):
                    avatar_large = q1[0]
                    avatar_large.content = db.Blob(avatar_73)
                    avatar_large.put()
                else:
                    qc1 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                    if (qc1.count() == 1):
                        counter1 = qc1[0]
                        counter1.value = counter1.value + 1
                    else:
                        counter1 = Counter()
                        counter1.name = 'avatar.max'
                        counter1.value = 1
                    counter1.put()
                    avatar_large = Avatar()
                    avatar_large.name = 'node_' + str(node.num) + '_large'
                    avatar_large.content = db.Blob(avatar_73)
                    avatar_large.num = counter1.value
                    avatar_large.put()
                node.avatar_large_url = '/navatar/' + str(node.num) + '/large?r=' + timestamp
                node.put()
                # Normal 48x48
                q2 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'node_' + str(node.num) + '_normal')
                if (q2.count() == 1):
                    avatar_normal = q2[0]
                    avatar_normal.content = db.Blob(avatar_48)
                    avatar_normal.put()
                else:
                    qc2 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                    if (qc2.count() == 1):
                        counter2 = qc2[0]
                        counter2.value = counter2.value + 1
                    else:
                        counter2 = Counter()
                        counter2.name = 'avatar.max'
                        counter2.value = 1
                    counter2.put()
                    avatar_normal = Avatar()
                    avatar_normal.name = 'node_' + str(node.num) + '_normal'
                    avatar_normal.content = db.Blob(avatar_48)
                    avatar_normal.num = counter2.value
                    avatar_normal.put()
                node.avatar_normal_url = '/navatar/' + str(node.num) + '/normal?r=' + timestamp
                node.put() 
                # Mini 24x24
                q3 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'node_' + str(node.num) + '_mini')
                if (q3.count() == 1):
                    avatar_mini = q3[0]
                    avatar_mini.content = db.Blob(avatar_24)
                    avatar_mini.put()
                else:
                    qc3 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                    if (qc3.count() == 1):
                        counter3 = qc3[0]
                        counter3.value = counter3.value + 1
                    else:
                        counter3 = Counter()
                        counter3.name = 'avatar.max'
                        counter3.value = 1
                    counter3.put()
                    avatar_mini = Avatar()
                    avatar_mini.name = 'node_' + str(node.num) + '_mini'
                    avatar_mini.content = db.Blob(avatar_24)
                    avatar_mini.num = counter3.value
                    avatar_mini.put()
                node.avatar_mini_url = '/navatar/' + str(node.num) + '/mini?r=' + timestamp
                node.put()
                # Upload to MobileMe
                use_this = False
                if config.mobileme_enabled and use_this:
                    headers = {'Authorization' : 'Basic ' + base64.b64encode(config.mobileme_username + ':' + config.mobileme_password)}
                    host = 'idisk.me.com'
                    # Sharding
                    timestamp = str(int(time.time()))
                    shard = node.num % 31
                    root = '/' + config.mobileme_username + '/Web/Sites/v2ex/navatars/' + str(shard)
                    root_mini = root + '/mini'
                    root_normal = root + '/normal'
                    root_large = root + '/large'
                    h = httplib.HTTPConnection(host)
                    # Mini
                    h.request('PUT', root_mini + '/' + str(node.num) + '.png', str(avatar_24), headers)
                    response = h.getresponse()
                    if response.status == 201 or response.status == 204:
                        node.avatar_mini_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/navatars/' + str(shard) + '/mini/' + str(node.num) + '.png?r=' + timestamp
                    # Normal
                    h.request('PUT', root_normal + '/' + str(node.num) + '.png', str(avatar_48), headers)
                    response = h.getresponse()
                    if response.status == 201 or response.status == 204:
                        node.avatar_normal_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/navatars/' + str(shard) + '/normal/' + str(node.num) + '.png?r=' + timestamp
                    # Large
                    h.request('PUT', root_large + '/' + str(node.num) + '.png', str(avatar_73), headers)
                    response = h.getresponse()
                    if response.status == 201 or response.status == 204:
                        node.avatar_large_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/navatars/' + str(shard) + '/large/' + str(node.num) + '.png?r=' + timestamp
                    node.put()
                memcache.set('Node_' + str(node.num), node, 86400 * 14)
                memcache.set('Node::' + node.name, node, 86400 * 14)
                memcache.delete('Avatar::node_' + str(node.num) + '_large')
                memcache.delete('Avatar::node_' + str(node.num) + '_normal')
                memcache.delete('Avatar::node_' + str(node.num) + '_mini')
                #self.session['message'] = '新节点头像设置成功'
                self.redirect(dest)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
        

class BackstageRemoveReplyHandler(webapp.RequestHandler):
    def get(self, reply_key):
        member = CheckAuth(self)
        t = self.request.get('t')
        if (member):
            if (member.level == 0) and (str(member.created_ts) == str(t)):
                reply = db.get(db.Key(reply_key))
                if reply:
                    topic = reply.topic
                    reply.delete()
                    q = db.GqlQuery("SELECT __key__ FROM Reply WHERE topic = :1", topic)
                    topic.replies = q.count()
                    if (topic.replies == 0):
                        topic.last_reply_by = None
                    topic.put()
                    pages = 1
                    memcache.delete('Topic_' + str(topic.num))
                    memcache.delete('topic_' + str(topic.num) + '_replies_desc_compressed')
                    memcache.delete('topic_' + str(topic.num) + '_replies_asc_compressed')
                    memcache.delete('topic_' + str(topic.num) + '_replies_filtered_compressed')
                    memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_desktop_' + str(pages))
                    memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_desktop_' + str(pages))
                    memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_desktop_' + str(pages))
                    memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_ios_' + str(pages))
                    memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_ios_' + str(pages))
                    memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_ios_' + str(pages))
                    self.redirect('/t/' + str(topic.num))
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageTidyReplyHandler(webapp.RequestHandler):
    def get(self, reply_num):
        member = CheckAuth(self)
        if (member):
            if (member.level == 0):
                q = db.GqlQuery("SELECT * FROM Reply WHERE num = :1", int(reply_num))
                if (q.count() == 1):
                    reply = q[0]
                    topic_num = reply.topic_num
                    q2 = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1", reply.created_by.lower())
                    member = q2[0]
                    reply.member = member
                    reply.member_num = member.num
                    q3 = db.GqlQuery("SELECT * FROM Topic WHERE num = :1", topic_num)
                    topic = q3[0]
                    # Begin to do real stuff
                    reply2 = Reply(parent=topic)
                    reply2.num = reply.num
                    reply2.content = reply.content
                    reply2.topic = topic
                    reply2.topic_num = topic.num
                    reply2.member = reply.member
                    reply2.member_num = reply.member_num
                    reply2.created_by = reply.created_by
                    reply2.source = reply.source
                    reply2.created = reply.created
                    reply2.last_modified = reply.last_modified
                    reply2.put()
                    reply.delete()
                    self.redirect('/t/' + str(topic_num))
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
            
class BackstageTidyTopicHandler(webapp.RequestHandler):
    def get(self, topic_num):
        member = CheckAuth(self)
        if (member):
            if (member.level == 0):
                q = db.GqlQuery("SELECT * FROM Topic WHERE num = :1", int(topic_num))
                if (q.count() == 1):
                    topic = q[0]
                    q2 = db.GqlQuery("SELECT * FROM Member WHERE num = :1", topic.member_num)
                    member = q2[0]
                    topic.member = member
                    q3 = db.GqlQuery("SELECT * FROM Node WHERE num = :1", topic.node_num)
                    node = q3[0]
                    topic.node = node
                    topic.put()
                    memcache.delete('Topic_' + str(topic.num))
                    self.redirect('/t/' + str(topic.num))
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageDeactivateUserHandler(webapp.RequestHandler):
    def get(self, key):
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if (member.level == 0) and (str(member.created_ts) == str(t)):
                one = db.get(db.Key(key))
                if one:
                    if one.num != 1:
                        memcache.delete(one.auth)
                        one.deactivated = int(time.time())
                        one.password = hashlib.sha1(str(time.time())).hexdigest()
                        one.auth = hashlib.sha1(str(one.num) + ':' + one.password).hexdigest()
                        one.newbie = 1
                        one.noob = 1
                        one.put()
                        memcache.delete('Member_' + str(one.num))
                        return self.redirect('/member/' + one.username)
        return self.redirect('/')               

class BackstageMoveTopicHandler(webapp.RequestHandler):
    def get(self, key):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        topic = db.get(db.Key(key))
        can_move = False
        ttl = 0
        if member:
            if member.level == 0:
                can_move = True
            if topic:
                if topic.member_num == member.num:
                    now = datetime.datetime.now()
                    ttl = 300 - int((now - topic.created).seconds)
                    if ttl > 0:
                        can_move = True
                        template_values['ttl'] = ttl
        template_values['can_move'] = can_move
        if member:
            template_values['member'] = member
            if can_move:
                template_values['page_title'] = site.title + u' › 移动主题'
                template_values['site'] = site
                if topic is not None:
                    node = topic.node
                    template_values['topic'] = topic
                    template_values['node'] = node
                    template_values['system_version'] = SYSTEM_VERSION
                    themes = os.listdir(os.path.join(os.path.dirname(__file__), 'tpl', 'themes'))
                    template_values['themes'] = themes
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_move_topic.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self, key):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        topic = db.get(db.Key(key))
        can_move = False
        ttl = 0
        if member:
            if member.level == 0:
                can_move = True
            if topic:
                if topic.member_num == member.num:
                    now = datetime.datetime.now()
                    ttl = 300 - int((now - topic.created).seconds)
                    if ttl > 0:
                        can_move = True
                        template_values['ttl'] = ttl
        template_values['can_move'] = can_move
        if member:
            template_values['member'] = member
            if can_move:
                template_values['page_title'] = site.title + u' › 移动主题'
                template_values['site'] = site
                if topic is not None:
                    errors = 0
                    node = topic.node
                    template_values['topic'] = topic
                    template_values['node'] = node
                    template_values['system_version'] = SYSTEM_VERSION
                    destination = self.request.get('destination')
                    if destination is not None:
                        node_new = GetKindByName('Node', destination)
                        if node_new is not False:
                            node_new = db.get(node_new.key())
                            node_old = topic.node
                            node_old.topics = node_old.topics - 1
                            node_old.put()
                            node_new.topics = node_new.topics + 1
                            node_new.put()
                            topic.node = node_new
                            topic.node_num = node_new.num
                            topic.node_name = node_new.name
                            topic.node_title = node_new.title
                            topic.put()
                            memcache.delete('Topic_' + str(topic.num))
                            memcache.delete('Node_' + str(node_old.num))
                            memcache.delete('Node_' + str(node_new.num))
                            memcache.delete('Node::' + str(node_old.name))
                            memcache.delete('Node::' + str(node_new.name))
                            memcache.delete('q_latest_16')
                            memcache.delete('home_rendered')
                            memcache.delete('home_rendered_mobile')
                            self.redirect('/t/' + str(topic.num))
                        else:
                            errors = errors + 1
                    else:
                        errors = errors + 1
                    if errors > 0:
                        themes = os.listdir(os.path.join(os.path.dirname(__file__), 'tpl', 'themes'))
                        template_values['themes'] = themes
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_move_topic.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
        
class BackstageSiteHandler(webapp.RequestHandler):
    def get(self):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › 站点设置'
                template_values['site'] = site
                template_values['site_title'] = site.title
                template_values['site_slogan'] = site.slogan
                template_values['site_domain'] = site.domain
                template_values['site_description'] = site.description
                if site.home_categories is not None:
                    template_values['site_home_categories'] = site.home_categories
                else:
                    template_values['site_home_categories'] = ''
                if site.analytics is not None:
                    template_values['site_analytics'] = site.analytics
                else:
                    template_values['site_analytics'] = ''
                if site.topic_view_level is not None:
                    template_values['site_topic_view_level'] = site.topic_view_level
                else:
                    template_values['site_topic_view_level'] = -1
                if site.topic_create_level is not None:
                    template_values['site_topic_create_level'] = site.topic_create_level
                else:
                    template_values['site_topic_create_level'] = 1000
                if site.topic_reply_level is not None:
                    template_values['site_topic_reply_level'] = site.topic_reply_level
                else:
                    template_values['site_topic_reply_level'] = 1000
                if site.meta is not None:
                    template_values['site_meta'] = site.meta
                else:
                    template_values['site_meta'] = ''
                if site.home_top is not None:
                    template_values['site_home_top'] = site.home_top
                else:
                    template_values['site_home_top'] = ''
                if site.theme is not None:
                    template_values['site_theme'] = site.theme
                else:
                    template_values['site_theme'] = 'default'
                if site.data_migration_mode is not None:
                    template_values['site_data_migration_mode'] = site.data_migration_mode
                else:
                    template_values['site_data_migration_mode'] = 0
                s = GetLanguageSelect(site.l10n)
                template_values['s'] = s
                template_values['member'] = member
                template_values['system_version'] = SYSTEM_VERSION
                themes = os.listdir(os.path.join(os.path.dirname(__file__), 'tpl', 'themes'))
                template_values['themes'] = themes
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_site.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/')
    
    def post(self):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › 站点设置'
                template_values['site'] = site
                template_values['member'] = member
                template_values['system_version'] = SYSTEM_VERSION
                errors = 0
                # Verification: title (required)
                site_title_error = 0
                site_title_error_messages = ['',
                    u'请输入站点名',
                    u'站点名长度不能超过 40 个字符'
                ]
                site_title = self.request.get('title').strip()
                if (len(site_title) == 0):
                    errors = errors + 1
                    site_title_error = 1    
                else:
                    if (len(site_title) > 40):
                        errors = errors + 1
                        site_title_error = 1
                template_values['site_title'] = site_title
                template_values['site_title_error'] = site_title_error
                template_values['site_title_error_message'] = site_title_error_messages[site_title_error]
                # Verification: slogan (required)
                site_slogan_error = 0
                site_slogan_error_messages = ['',
                    u'请输入站点标语',
                    u'站点标语长度不能超过 140 个字符'
                ]
                site_slogan = self.request.get('slogan').strip()
                if (len(site_slogan) == 0):
                    errors = errors + 1
                    site_slogan_error = 1    
                else:
                    if (len(site_slogan) > 140):
                        errors = errors + 1
                        site_slogan_error = 1
                template_values['site_slogan'] = site_slogan
                template_values['site_slogan_error'] = site_slogan_error
                template_values['site_slogan_error_message'] = site_slogan_error_messages[site_slogan_error]
                # Verification: domain (required)
                site_domain_error = 0
                site_domain_error_messages = ['',
                    u'请输入主要域名',
                    u'主要域名长度不能超过 40 个字符'
                ]
                site_domain = self.request.get('domain').strip()
                if (len(site_domain) == 0):
                    errors = errors + 1
                    site_domain_error = 1    
                else:
                    if (len(site_domain) > 40):
                        errors = errors + 1
                        site_domain_error = 1
                template_values['site_domain'] = site_domain
                template_values['site_domain_error'] = site_domain_error
                template_values['site_domain_error_message'] = site_domain_error_messages[site_domain_error]
                # Verification: description (required)
                site_description_error = 0
                site_description_error_messages = ['',
                    u'请输入站点简介',
                    u'站点简介长度不能超过 200 个字符'
                ]
                site_description = self.request.get('description').strip()
                if (len(site_description) == 0):
                    errors = errors + 1
                    site_description_error = 1    
                else:
                    if (len(site_description) > 200):
                        errors = errors + 1
                        site_description_error = 1
                template_values['site_description'] = site_description
                template_values['site_description_error'] = site_description_error
                template_values['site_description_error_message'] = site_description_error_messages[site_description_error]
                # Verification: analytics (optional)
                site_analytics_error = 0
                site_analytics_error_messages = ['',
                    u'Analytics ID 格式不正确'
                ]
                site_analytics = self.request.get('analytics').strip()
                if len(site_analytics) > 0:
                    if re.findall('^UA\-[0-9]+\-[0-9]+$', site_analytics):
                        site_analytics_error = 0
                    else:
                        errors = errors + 1
                        site_analytics_error = 1
                else:
                    site_analytics = ''
                template_values['site_analytics'] = site_analytics
                template_values['site_analytics_error'] = site_analytics_error
                template_values['site_analytics_error_message'] = site_analytics_error_messages[site_analytics_error]
                # Verification: l10n (required)
                site_l10n = self.request.get('l10n').strip()
                supported = GetSupportedLanguages()
                if site_l10n == '':
                    site_l10n = site.l10n
                else:
                    if site_l10n not in supported:
                        site_l10n = site.l10n
                s = GetLanguageSelect(site_l10n)
                template_values['s'] = s
                template_values['site_l10n'] = site_l10n
                # Verification: home_categories (optional)
                site_home_categories_error = 0
                site_home_categories_error_messages = ['',
                    u'首页分类信息不要超过 2000 个字符'
                ]
                site_home_categories = self.request.get('home_categories').strip()
                site_home_categories_length = len(site_home_categories)
                if len(site_home_categories) > 0:
                    if site_home_categories_length > 2000:
                        errors = errors + 1
                        site_home_categories_error = 1
                else:
                    site_home_categories = ''
                template_values['site_home_categories'] = site_home_categories
                template_values['site_home_categories_error'] = site_home_categories_error
                template_values['site_home_categories_error_message'] = site_home_categories_error_messages[site_home_categories_error]
                # Verification: topic_view_level (default=-1)
                site_topic_view_level = self.request.get('topic_view_level')
                try:
                    site_topic_view_level = int(site_topic_view_level)
                    if site_topic_view_level < -1:
                        site_topic_view_level = -1
                except:
                    site_topic_view_level = -1
                template_values['site_topic_view_level'] = site_topic_view_level
                # Verification: topic_create_level (default=1000)
                site_topic_create_level = self.request.get('topic_create_level')
                try:
                    site_topic_create_level = int(site_topic_create_level)
                    if site_topic_create_level < -1:
                        site_topic_create_level = 1000
                except:
                    site_topic_create_level = 1000
                template_values['site_topic_create_level'] = site_topic_create_level
                # Verification: topic_reply_level (default=1000)
                site_topic_reply_level = self.request.get('topic_reply_level')
                try:
                    site_topic_reply_level = int(site_topic_reply_level)
                    if site_topic_reply_level < -1:
                        site_topic_reply_level = 1000
                except:
                    site_topic_reply_level = 1000
                template_values['site_topic_reply_level'] = site_topic_reply_level
                # Verification: meta
                site_meta = self.request.get('meta')
                template_values['site_meta'] = site_meta
                # Verification: home_top
                site_home_top = self.request.get('home_top')
                template_values['site_home_top'] = site_home_top
                # Verification: theme
                site_theme = self.request.get('theme')
                themes = os.listdir(os.path.join(os.path.dirname(__file__), 'tpl', 'themes'))
                template_values['themes'] = themes
                if site_theme in themes:
                    template_values['site_theme'] = site_theme
                else:
                    site_theme = 'default'
                    template_values['site_theme'] = site_theme
                # Verification: data_migration_mode
                site_data_migration_mode = self.request.get('data_migration_mode')
                if site_data_migration_mode == 'on':
                    template_values['site_data_migration_mode'] = 1
                else:
                    template_values['site_data_migration_mode'] = 0
                
                template_values['errors'] = errors
                
                if errors == 0:
                    site.title = site_title
                    site.slogan = site_slogan
                    site.domain = site_domain
                    site.description = site_description
                    if site_home_categories != '':
                        site.home_categories = site_home_categories
                    if site_analytics != '':
                        site.analytics = site_analytics
                    site.l10n = site_l10n
                    site.topic_view_level = site_topic_view_level
                    site.topic_create_level = site_topic_create_level
                    site.topic_reply_level = site_topic_reply_level
                    site.meta = site_meta
                    site.home_top = site_home_top
                    site.theme = site_theme
                    site.data_migration_mode = template_values['site_data_migration_mode']
                    site.put()
                    memcache.delete('index_categories')
                    template_values['message'] = l10n.site_settings_updated;
                    template_values['site'] = site
                    memcache.delete('site')
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_site.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/')

class BackstageTopicHandler(webapp.RequestHandler):
    def get(self):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + l10n.topic_settings.decode('utf-8')
                template_values['site'] = site
                template_values['site_use_topic_types'] = site.use_topic_types
                if site.topic_types is None:
                    template_values['site_topic_types'] = ''
                else:
                    template_values['site_topic_types'] = site.topic_types
                if site.use_topic_types is not True:
                    s = '<select name="use_topic_types"><option value="1">Enabled</option><option value="0" selected="selected">Disabled</option></select>'
                else:
                    s = '<select name="use_topic_types"><option value="1" selected="selected">Enabled</option><option value="0">Disabled</option></select>'
                template_values['s'] = s
                template_values['member'] = member
                template_values['system_version'] = SYSTEM_VERSION
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_topic.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/')

    def post(self):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + l10n.topic_settings.decode('utf-8')
                template_values['site'] = site
                template_values['site_use_topic_types'] = site.use_topic_types
                if site.topic_types is None:
                    template_values['site_topic_types'] = ''
                else:
                    template_values['site_topic_types'] = site.topic_types
                if site.use_topic_types is not True:
                    s = '<select name="use_topic_types"><option value="1">Enabled</option><option value="0" selected="selected">Disabled</option></select>'
                else:
                    s = '<select name="use_topic_types"><option value="1" selected="selected">Enabled</option><option value="0">Disabled</option></select>'
                template_values['s'] = s
                template_values['member'] = member
                template_values['system_version'] = SYSTEM_VERSION
                errors = 0
                # Verification: use_topic_types
                site_use_topic_types = self.request.get('use_topic_types').strip()
                if site_use_topic_types is None:
                    s = '<select name="use_topic_types"><option value="1">Enabled</option><option value="0" selected="selected">Disabled</option></select>'
                else:
                    if site_use_topic_types == '1':
                        s = '<select name="use_topic_types"><option value="1" selected="selected">Enabled</option><option value="0">Disabled</option></select>'
                    else:
                        s = '<select name="use_topic_types"><option value="1">Enabled</option><option value="0" selected="selected">Disabled</option></select>'
                template_values['s'] = s
                # Verification: topic_types
                site_topic_types = self.request.get('topic_types').strip()
                if errors == 0:
                    if site_use_topic_types == '1':
                        site.use_topic_types = True
                    else:
                        site.use_topic_types = False
                    site.topic_types = site_topic_types
                    site.put()
                    memcache.delete('site')
                    self.redirect('/backstage')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_topic.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
        else:
            self.redirect('/')


class BackstageRemoveMemcacheHandler(webapp.RequestHandler):
    def post(self):
        member = CheckAuth(self)
        if member:
            if member.level == 0:
                mc = self.request.get('mc')
                if mc is not None:
                    memcache.delete(mc)
        self.redirect('/backstage')


class BackstageMemberHandler(webapp.RequestHandler):
    def get(self, member_username):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                member_username_lower = member_username.lower()
                q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1", member_username_lower)
                if (q.count() == 1):
                    one = q[0]
                    template_values['one'] = one
                    errors = 0
                    template_values['one_username'] = one.username
                    template_values['one_email'] = one.email
                    if one.avatar_large_url is None:
                        template_values['one_avatar_large_url'] = ''
                    else:
                        template_values['one_avatar_large_url'] = one.avatar_large_url
                    if one.avatar_normal_url is None:
                        template_values['one_avatar_normal_url'] = ''
                    else:
                        template_values['one_avatar_normal_url'] = one.avatar_normal_url
                    if one.avatar_mini_url is None:
                        template_values['one_avatar_mini_url'] = ''
                    else:
                        template_values['one_avatar_mini_url'] = one.avatar_mini_url
                    if one.bio is None:
                        template_values['one_bio'] = ''
                    else:
                        template_values['one_bio'] = one.bio
                    template_values['one_level'] = one.level
                    template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + one.username
                    template_values['site'] = site
                    template_values['member'] = member
                    template_values['system_version'] = SYSTEM_VERSION
                    template_values['latest_members'] = db.GqlQuery("SELECT * FROM Member ORDER BY created DESC LIMIT 5")
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_member.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/backstage')
                
        else:
            self.redirect('/')
            

    def post(self, member_username):
        template_values = {}
        site = GetSite()
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                member_username_lower = member_username.lower()
                q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1", member_username_lower)
                if (q.count() == 1):
                    one = q[0]
                    template_values['one'] = one
                    errors = 0
                    # Verification: username
                    one_username_error = 0
                    one_username_error_messages = ['',
                        l10n.username_empty,
                        l10n.username_too_long,
                        l10n.username_too_short,
                        l10n.username_invalid,
                        l10n.username_taken]
                    one_username = self.request.get('username').strip()
                    if (len(one_username) == 0):
                        errors = errors + 1
                        one_username_error = 1
                    else:
                        if (len(one_username) > 32):
                            errors = errors + 1
                            one_username_error = 2
                        else:
                            if (len(one_username) < 3):
                                errors = errors + 1
                                one_username_error = 3
                            else:
                                if (re.search('^[a-zA-Z0-9\_]+$', one_username)):
                                    q = db.GqlQuery('SELECT * FROM Member WHERE username_lower = :1 AND num != :2', one_username.lower(), one.num)
                                    if (q.count() > 0):
                                        errors = errors + 1
                                        one_username_error = 5
                                else:
                                    errors = errors + 1
                                    one_username_error = 4
                    template_values['one_username'] = one_username
                    template_values['one_username_error'] = one_username_error
                    template_values['one_username_error_message'] = one_username_error_messages[one_username_error]
                    # Verification: email
                    one_email_error = 0
                    one_email_error_messages = ['',
                        u'请输入电子邮件地址',
                        u'电子邮件地址长度不能超过 32 个字符',
                        u'输入的电子邮件地址不符合规则',
                        u'这个电子邮件地址已经有人注册过了']
                    one_email = self.request.get('email').strip()
                    if (len(one_email) == 0):
                        errors = errors + 1
                        one_email_error = 1
                    else:
                        if (len(one_email) > 32):
                            errors = errors + 1
                            one_email_error = 2
                        else:
                            p = re.compile(r"(?:^|\s)[-a-z0-9_.]+@(?:[-a-z0-9]+\.)+[a-z]{2,6}(?:\s|$)", re.IGNORECASE)
                            if (p.search(one_email)):
                                q = db.GqlQuery('SELECT * FROM Member WHERE email = :1 AND num != :2', one_email.lower(), one.num)
                                if (q.count() > 0):
                                    errors = errors + 1
                                    one_email_error = 4
                            else:
                                errors = errors + 1
                                one_email_error = 3
                    template_values['one_email'] = one_email.lower()
                    template_values['one_email_error'] = one_email_error
                    template_values['one_email_error_message'] = one_email_error_messages[one_email_error]
                    # Verification: avatar
                    one_avatar_large_url = self.request.get('avatar_large_url')
                    template_values['one_avatar_large_url'] = one_avatar_large_url
                    one_avatar_normal_url = self.request.get('avatar_normal_url')
                    template_values['one_avatar_normal_url'] = one_avatar_normal_url
                    one_avatar_mini_url = self.request.get('avatar_mini_url')
                    template_values['one_avatar_mini_url'] = one_avatar_mini_url
                    # Verification: bio
                    one_bio = self.request.get('bio')
                    template_values['one_bio'] = one_bio
                    # Verification: level
                    one_level = self.request.get('level')
                    try:
                        one_level = int(one_level)
                    except:
                        if one.num == 1:
                            one_level = 0
                        else:
                            one_level = 1000
                    template_values['one_level'] = one_level
                    if errors == 0:
                        one.username = one_username
                        one.username_lower = one_username.lower()
                        one.email = one_email
                        one.avatar_large_url = one_avatar_large_url
                        one.avatar_normal_url = one_avatar_normal_url
                        one.avatar_mini_url = one_avatar_mini_url
                        one.bio = one_bio
                        one.level = one_level
                        one.put()
                        memcache.delete('Member_' + str(one.num))
                        memcache.delete('Member::' + one_username.lower())
                        self.redirect('/backstage')
                    else:
                        template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › ' + one.username
                        template_values['site'] = site
                        template_values['member'] = member
                        template_values['system_version'] = SYSTEM_VERSION
                        template_values['latest_members'] = db.GqlQuery("SELECT * FROM Member ORDER BY created DESC LIMIT 5")
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_member.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    self.redirect('/backstage')

        else:
            self.redirect('/')

class BackstageMembersHandler(webapp.RequestHandler):
    def get(self):
        template_values = {}
        site = GetSite()
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['member'] = member
                template_values['page_title'] = site.title + u' › ' + l10n.backstage.decode('utf-8') + u' › 浏览所有会员'
                member_total = memcache.get('member_total')
                if member_total is None:
                    q3 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'member.total'")
                    if (q3.count() > 0):
                        member_total = q3[0].value
                    else:
                        member_total = 0
                    memcache.set('member_total', member_total, 600)
                template_values['member_total'] = member_total
                page_size = 60
                pages = 1
                if member_total > page_size:
                    if (member_total % page_size) > 0:
                        pages = int(math.floor(member_total / page_size)) + 1
                    else:
                        pages = int(math.floor(member_total / page_size))
                try:
                    page_current = int(self.request.get('p'))
                    if page_current < 1:
                        page_current = 1
                    if page_current > pages:
                        page_current = pages
                except:
                    page_current = 1
                page_start = (page_current - 1) * page_size
                template_values['pages'] = pages
                template_values['page_current'] = page_current
                i = 1
                ps = []
                while i <= pages:
                    ps.append(i)
                    i = i + 1
                template_values['ps'] = ps
                q = db.GqlQuery("SELECT * FROM Member ORDER BY created DESC LIMIT " + str(page_start )+ "," + str(page_size))
                template_values['members'] = q
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'backstage_members.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class BackstageRemoveNotificationHandler(BaseHandler):
    def get(self, key):
        o = db.get(db.Key(key))
        if o and self.member:
            if type(o).__name__ == 'Notification':
                if o.for_member_num == self.member.num:
                    o.delete()
                    memcache.delete('nn::' + self.member.username_lower)
        self.redirect('/notifications')

def main():
    application = webapp.WSGIApplication([
    ('/backstage', BackstageHomeHandler),
    ('/backstage/new/minisite', BackstageNewMinisiteHandler),
    ('/backstage/minisite/(.*)', BackstageMinisiteHandler),
    ('/backstage/remove/minisite/(.*)', BackstageRemoveMinisiteHandler),
    ('/backstage/new/page/(.*)', BackstageNewPageHandler),
    ('/backstage/page/(.*)', BackstagePageHandler),
    ('/backstage/remove/page/(.*)', BackstageRemovePageHandler),
    ('/backstage/new/section', BackstageNewSectionHandler),
    ('/backstage/section/(.*)', BackstageSectionHandler),
    ('/backstage/new/node/(.*)', BackstageNewNodeHandler),
    ('/backstage/node/([a-z0-9A-Z]+)', BackstageNodeHandler),
    ('/backstage/node/([a-z0-9A-Z]+)/avatar', BackstageNodeAvatarHandler),
    ('/backstage/remove/reply/(.*)', BackstageRemoveReplyHandler),
    ('/backstage/tidy/reply/([0-9]+)', BackstageTidyReplyHandler),
    ('/backstage/tidy/topic/([0-9]+)', BackstageTidyTopicHandler),
    ('/backstage/deactivate/user/(.*)', BackstageDeactivateUserHandler),
    ('/backstage/move/topic/(.*)', BackstageMoveTopicHandler),
    ('/backstage/site', BackstageSiteHandler),
    ('/backstage/topic', BackstageTopicHandler),
    ('/backstage/remove/mc', BackstageRemoveMemcacheHandler),
    ('/backstage/member/(.*)', BackstageMemberHandler),
    ('/backstage/members', BackstageMembersHandler),
    ('/backstage/remove/notification/(.*)', BackstageRemoveNotificationHandler),
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = blog
#!/usr/bin/env python
# coding=utf-8

import os
import base64
import re
import time
import datetime
import hashlib
import httplib
import string
import pickle

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import images
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Avatar
from v2ex.babel import Counter
from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.handlers import BaseHandler

import config

template.register_template_library('v2ex.templatetags.filters')

class BlogHandler(BaseHandler):
    def get(self, member_username):
        one = GetMemberByUsername(member_username)
        if one:
            self.values['one'] = one
            topics = db.GqlQuery("SELECT * FROM Topic WHERE node_name = 'blog' AND member_num = :1 ORDER BY created DESC", one.num)
            self.values['topics'] = topics
            friends = db.GqlQuery("SELECT * FROM MemberBookmark WHERE member_num = :1", one.num)
            self.values['friends'] = friends
            self.set_title(u'Blog')
            self.finalize(template_name='blog')
        else:
            self.set_title(u'Member Not Found')
            self.finalize(template_name='member_not_found')

class BlogEntryHandler(BaseHandler):
    def get(self, topic_num):
        topic = GetKindByNum('Topic', int(topic_num))
        if topic:
            if topic.node_name == 'blog':
                self.values['one'] = topic.member
                self.values['topic'] = topic
                if topic.replies > 0:
                    self.values['replies'] = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1", topic.num)
                self.values['page_title'] = topic.title
                self.finalize(template_name='blog_entry')
            else:
                self.redirect('/t/' + str(topic.num) + '#reply' + str(topic.replies))
        else:
            self.set_title(u'Topic Not Found')
            self.finalize(template_name='topic_not_found')

def main():
    application = webapp.WSGIApplication([
    ('/blog/([a-z0-9A-Z\_\-]+)', BlogHandler),
    ('/entry/([0-9]+)', BlogEntryHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = css
#!/usr/bin/env python
# coding=utf-8

import os
import datetime

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import SYSTEM_VERSION

template.register_template_library('v2ex.templatetags.filters')

class CSSHandler(webapp.RequestHandler):
    def get(self, theme):
        template_values = {}
        themes = os.listdir(os.path.join(os.path.dirname(__file__), 'tpl', 'themes'))
        if theme in themes:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'themes', theme, 'style.css')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'themes', 'default', 'style.css')
        output = template.render(path, template_values)
        expires_date = datetime.datetime.utcnow() + datetime.timedelta(days=7)
        expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
        self.response.headers.add_header("Expires", expires_str)
        self.response.headers['Cache-Control'] = 'max-age=120, must-revalidate'
        self.response.headers['Content-type'] = 'text/css;charset=UTF-8'
        self.response.out.write(output)

def main():
    application = webapp.WSGIApplication([
    ('/css/([a-zA-Z0-9]+).css', CSSHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = data
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import urllib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from django.utils import simplejson as json

from mapreduce import operation as op

def tidy_node(entity):
    # Recalculate exact topics counter
    q = db.GqlQuery("SELECT __key__ FROM Topic WHERE node_num = :1", entity.num)
    entity.topics = q.count()
    memcache.set('Node_' + str(entity.num), entity, 86400)
    memcache.set('Node::' + entity.name, entity, 86400)
    yield op.db.Put(entity)
    
def tidy_topic(entity):
    # Recalculate exact replies counter
    q = db.GqlQuery("SELECT __key__ FROM Reply WHERE topic_num = :1", entity.num)
    entity.replies = q.count()
    # Ensure member field is correctly set
    q2 = db.GqlQuery("SELECT * FROM Member WHERE num = :1", entity.member_num)
    if q2.count() == 1:
        entity.member = q2[0]
    memcache.set('Topic_' + str(entity.num), entity, 86400)
    yield op.db.Put(entity)
    
def tidy_reply(entity):
    # Ensure member field is correctly set
    q = db.GqlQuery("SELECT * FROM Member WHERE num = :1", entity.member_num)
    if q.count() == 1:
        entity.member = q[0]
    # Ensure topic field is correctly set
    q2 = db.GqlQuery("SELECT * FROM Topic WHERE num = :1", entity.topic_num)
    if q2.count() == 1:
        entity.topic = q2[0]
    yield op.db.Put(entity)
########NEW FILE########
__FILENAME__ = favorite
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template
from google.appengine.api.labs import taskqueue

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note
from v2ex.babel import NodeBookmark
from v2ex.babel import TopicBookmark
from v2ex.babel import MemberBookmark

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *

from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

class FavoriteNodeHandler(webapp.RequestHandler):
    def get(self, node_name):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if str(member.created_ts) == str(t):
                node = GetKindByName('Node', node_name)
                if node is not False:
                    q = db.GqlQuery("SELECT * FROM NodeBookmark WHERE node = :1 AND member = :2", node, member)
                    if q.count() == 0:
                        bookmark = NodeBookmark(parent=member)
                        bookmark.node = node
                        bookmark.member = member
                        bookmark.put()
                        member = db.get(member.key())
                        member.favorited_nodes = member.favorited_nodes + 1
                        member.put()
                        memcache.set('Member_' + str(member.num), member, 86400)
                        n = 'r/n' + str(node.num) + '/m' + str(member.num)
                        memcache.set(n, True, 86400 * 14)
        self.redirect(go)
    
class UnfavoriteNodeHandler(webapp.RequestHandler):
    def get(self, node_name):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if str(member.created_ts) == str(t):
                node = GetKindByName('Node', node_name)
                if node is not False:
                    q = db.GqlQuery("SELECT * FROM NodeBookmark WHERE node = :1 AND member = :2", node, member)
                    if q.count() > 0:
                        bookmark = q[0]
                        bookmark.delete()
                        member = db.get(member.key())
                        member.favorited_nodes = member.favorited_nodes - 1
                        member.put()
                        memcache.set('Member_' + str(member.num), member, 86400)
                        n = 'r/n' + str(node.num) + '/m' + str(member.num)
                        memcache.delete(n)
        self.redirect(go)

class FavoriteTopicHandler(webapp.RequestHandler):
    def get(self, topic_num):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t').strip()
        if member:
            if member.username_lower_md5 == t:
                topic = GetKindByNum('Topic', int(topic_num))
                if topic is not False:
                    q = db.GqlQuery("SELECT * FROM TopicBookmark WHERE topic = :1 AND member = :2", topic, member)
                    if q.count() == 0:
                        bookmark = TopicBookmark(parent=member)
                        bookmark.topic = topic
                        bookmark.member = member
                        bookmark.put()
                        member = db.get(member.key())
                        member.favorited_topics = member.favorited_topics + 1
                        member.put()
                        memcache.set('Member_' + str(member.num), member, 86400)
                        n = 'r/t' + str(topic.num) + '/m' + str(member.num)
                        memcache.set(n, True, 86400 * 14)
                        taskqueue.add(url='/add/star/topic/' + str(topic.key()))
        self.redirect(go)

class UnfavoriteTopicHandler(webapp.RequestHandler):
    def get(self, topic_num):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t').strip()
        if member:
            if member.username_lower_md5 == t:
                topic = GetKindByNum('Topic', int(topic_num))
                if topic is not False:
                    q = db.GqlQuery("SELECT * FROM TopicBookmark WHERE topic = :1 AND member = :2", topic, member)
                    if q.count() > 0:
                        bookmark = q[0]
                        bookmark.delete()
                        member = db.get(member.key())
                        member.favorited_topics = member.favorited_topics - 1
                        member.put()
                        memcache.set('Member_' + str(member.num), member, 86400)
                        n = 'r/t' + str(topic.num) + '/m' + str(member.num)
                        memcache.delete(n)
                        taskqueue.add(url='/minus/star/topic/' + str(topic.key()))
        self.redirect(go)
        
class FollowMemberHandler(webapp.RequestHandler):
    def get(self, one_num):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if str(member.created_ts) == str(t):
                one = GetKindByNum('Member', int(one_num))
                if one is not False:
                    if one.num != member.num:
                        q = db.GqlQuery("SELECT * FROM MemberBookmark WHERE one = :1 AND member_num = :2", one, member.num)
                        if q.count() == 0:
                            member = db.get(member.key())
                            member.favorited_members = member.favorited_members + 1
                            if member.favorited_members > 30:
                                self.session = Session()
                                self.session['message'] = '最多只能添加 30 位特别关注'
                            else:
                                bookmark = MemberBookmark(parent=member)
                                bookmark.one = one
                                bookmark.member_num = member.num
                                bookmark.put()
                                member.put()
                                memcache.set('Member_' + str(member.num), member, 86400)
                                n = 'r/m' + str(one.num) + '/m' + str(member.num)
                                memcache.set(n, True, 86400 * 14)
                                one = db.get(one.key())
                                one.followers_count = one.followers_count + 1
                                one.put()
                                memcache.set('Member_' + str(one.num), one, 86400)
                                memcache.set('Member::' + str(one.username_lower), one, 86400)
                                self.session = Session()
                                self.session['message'] = '特别关注添加成功，还可以添加 ' + str(30 - member.favorited_members) + ' 位'
        self.redirect(go)

class UnfollowMemberHandler(webapp.RequestHandler):
    def get(self, one_num):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if str(member.created_ts) == str(t):
                one = GetKindByNum('Member', int(one_num))
                if one is not False:
                    if one.num != member.num:
                        q = db.GqlQuery("SELECT * FROM MemberBookmark WHERE one = :1 AND member_num = :2", one, member.num)
                        if q.count() > 0:
                            bookmark = q[0]
                            bookmark.delete()
                            member = db.get(member.key())
                            member.favorited_members = member.favorited_members - 1
                            member.put()
                            memcache.set('Member_' + str(member.num), member, 86400)
                            n = 'r/m' + str(one.num) + '/m' + str(member.num)
                            memcache.delete(n)
                            one = db.get(one.key())
                            one.followers_count = one.followers_count - 1
                            one.put()
                            memcache.set('Member_' + str(one.num), one, 86400)
                            memcache.set('Member::' + str(one.username_lower), one, 86400)
        self.redirect(go)

def main():
    application = webapp.WSGIApplication([
    ('/favorite/node/([a-zA-Z0-9]+)', FavoriteNodeHandler),
    ('/unfavorite/node/([a-zA-Z0-9]+)', UnfavoriteNodeHandler),
    ('/favorite/topic/([0-9]+)', FavoriteTopicHandler),
    ('/unfavorite/topic/([0-9]+)', UnfavoriteTopicHandler),
    ('/follow/([0-9]+)', FollowMemberHandler),
    ('/unfollow/([0-9]+)', UnfollowMemberHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = feed
#!/usr/bin/env python
# coding=utf-8

import os
import datetime

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply

from v2ex.babel.da import *

from v2ex.babel.handlers import BaseHandler

template.register_template_library('v2ex.templatetags.filters')

class FeedHomeHandler(BaseHandler):
    def head(self):
        self.response.out.write('')
        
    def get(self):
        output = memcache.get('feed_index')
        if output is None:
            self.values['site_domain'] = self.site.domain
            self.values['site_name'] = self.site.title
            self.values['site_slogan'] = self.site.slogan
            self.values['feed_url'] = 'http://' + self.values['site_domain'] + '/index.xml'
            self.values['site_updated'] = datetime.datetime.now()
            topics = memcache.get('feed_home')
            if topics is None:
                q = db.GqlQuery("SELECT * FROM Topic ORDER BY created DESC LIMIT 10")
                topics = []
                IGNORED = ['newbie', 'in', 'flamewar', 'pointless', 'tuan', '528491', 'chamber', 'autistic', 'blog', 'love', 'flood', 'fanfou', 'closed']
                for topic in q:
                    if topic.node.name not in IGNORED:
                        topics.append(topic)
                memcache.set('feed_home', topics, 3600)
            self.values['topics'] = topics
            self.values['feed_title'] = self.site.title
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'feed', 'index.xml')
            output = template.render(path, self.values)
            memcache.set('feed_index', output, 3600)
        self.response.headers['Content-type'] = 'application/xml;charset=UTF-8'
        self.response.out.write(output)

        
class FeedReadHandler(BaseHandler):
    def head(self):
        self.response.out.write('')
        
    def get(self):
        output = memcache.get('feed_read_output')
        if output is None:
            self.values['site_domain'] = self.site.domain
            self.values['site_name'] = self.site.title
            self.values['site_slogan'] = self.site.slogan
            self.values['feed_url'] = 'http://' + self.values['site_domain'] + '/read.xml'
            self.values['site_updated'] = datetime.datetime.now()
            topics = memcache.get('feed_home')
            if topics is None:
                q = db.GqlQuery("SELECT * FROM Topic ORDER BY created DESC LIMIT 10")
                topics = []
                IGNORED = ['newbie', 'in', 'flamewar', 'pointless', 'tuan', '528491', 'chamber', 'autistic', 'blog', 'love', 'flood']
                for topic in q:
                    if topic.node.name not in IGNORED:
                        topics.append(topic)
                memcache.set('feed_home', topics, 3600)
            self.values['topics'] = topics
            self.values['feed_title'] = self.site.title
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'feed', 'read.xml')
            output = template.render(path, self.values)
            memcache.set('feed_read_output', output, 3600)
        self.response.headers['Content-type'] = 'application/xml;charset=UTF-8'
        self.response.out.write(output)


class FeedNodeHandler(webapp.RequestHandler):
    def head(self):
        self.response.out.write('')
    
    def get(self, node_name):
        node_name = node_name.lower()
        site = GetSite()
        node = GetKindByName('Node', node_name)
        if node is False:
            return self.response.out.write('node not found')
        output = memcache.get('feed_node_' + node_name)
        if output is None:
            template_values = {}
            template_values['site'] = site
            template_values['site_domain'] = site.domain
            template_values['site_name'] = site.title
            template_values['site_slogan'] = site.slogan
            template_values['feed_url'] = 'http://' + template_values['site_domain'] + '/index.xml'
            template_values['site_updated'] = datetime.datetime.now()
            q = db.GqlQuery("SELECT * FROM Topic WHERE node = :1 ORDER BY created DESC LIMIT 10", node)
            topics = []
            for topic in q:
                topics.append(topic)
            template_values['topics'] = topics
            template_values['feed_title'] = site.title + u' › ' + node.title
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'feed', 'index.xml')
            output = template.render(path, template_values)
            memcache.set('feed_node_' + node.name, output, 7200)
        self.response.headers['Content-type'] = 'application/xml;charset=UTF-8'
        self.response.out.write(output)

def main():
    application = webapp.WSGIApplication([
    ('/index.xml', FeedHomeHandler),
    ('/read.xml', FeedReadHandler),
    ('/feed/v2ex.rss', FeedHomeHandler),
    ('/feed/([0-9a-zA-Z\-\_]+).xml', FeedNodeHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = constants
import string, gettext
_ = gettext.gettext

try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import Set as set
    from sets import ImmutableSet as frozenset

EOF = None

E = {
    "null-character": 
       _(u"Null character in input stream, replaced with U+FFFD."),
    "invalid-codepoint": 
       _(u"Invalid codepoint in stream."),
    "incorrectly-placed-solidus":
       _(u"Solidus (/) incorrectly placed in tag."),
    "incorrect-cr-newline-entity":
       _(u"Incorrect CR newline entity, replaced with LF."),
    "illegal-windows-1252-entity":
       _(u"Entity used with illegal number (windows-1252 reference)."),
    "cant-convert-numeric-entity":
       _(u"Numeric entity couldn't be converted to character "
         u"(codepoint U+%(charAsInt)08x)."),
    "illegal-codepoint-for-numeric-entity":
       _(u"Numeric entity represents an illegal codepoint: "
         u"U+%(charAsInt)08x."),
    "numeric-entity-without-semicolon":
       _(u"Numeric entity didn't end with ';'."),
    "expected-numeric-entity-but-got-eof":
       _(u"Numeric entity expected. Got end of file instead."),
    "expected-numeric-entity":
       _(u"Numeric entity expected but none found."),
    "named-entity-without-semicolon":
       _(u"Named entity didn't end with ';'."),
    "expected-named-entity":
       _(u"Named entity expected. Got none."),
    "attributes-in-end-tag":
       _(u"End tag contains unexpected attributes."),
    'self-closing-flag-on-end-tag':
        _(u"End tag contains unexpected self-closing flag."),
    "expected-tag-name-but-got-right-bracket":
       _(u"Expected tag name. Got '>' instead."),
    "expected-tag-name-but-got-question-mark":
       _(u"Expected tag name. Got '?' instead. (HTML doesn't "
         u"support processing instructions.)"),
    "expected-tag-name":
       _(u"Expected tag name. Got something else instead"),
    "expected-closing-tag-but-got-right-bracket":
       _(u"Expected closing tag. Got '>' instead. Ignoring '</>'."),
    "expected-closing-tag-but-got-eof":
       _(u"Expected closing tag. Unexpected end of file."),
    "expected-closing-tag-but-got-char":
       _(u"Expected closing tag. Unexpected character '%(data)s' found."),
    "eof-in-tag-name":
       _(u"Unexpected end of file in the tag name."),
    "expected-attribute-name-but-got-eof":
       _(u"Unexpected end of file. Expected attribute name instead."),
    "eof-in-attribute-name":
       _(u"Unexpected end of file in attribute name."),
    "invalid-character-in-attribute-name":
        _(u"Invalid chracter in attribute name"),
    "duplicate-attribute":
       _(u"Dropped duplicate attribute on tag."),
    "expected-end-of-tag-name-but-got-eof":
       _(u"Unexpected end of file. Expected = or end of tag."),
    "expected-attribute-value-but-got-eof":
       _(u"Unexpected end of file. Expected attribute value."),
    "expected-attribute-value-but-got-right-bracket":
       _(u"Expected attribute value. Got '>' instead."),
    'equals-in-unquoted-attribute-value':
        _(u"Unexpected = in unquoted attribute"),
    'unexpected-character-in-unquoted-attribute-value':
        _(u"Unexpected character in unquoted attribute"),
    "invalid-character-after-attribute-name":
       _(u"Unexpected character after attribute name."),
    "unexpected-character-after-attribute-value":
       _(u"Unexpected character after attribute value."),
    "eof-in-attribute-value-double-quote":
       _(u"Unexpected end of file in attribute value (\")."),
    "eof-in-attribute-value-single-quote":
       _(u"Unexpected end of file in attribute value (')."),
    "eof-in-attribute-value-no-quotes":
       _(u"Unexpected end of file in attribute value."),
    "unexpected-EOF-after-solidus-in-tag":
        _(u"Unexpected end of file in tag. Expected >"),
    "unexpected-character-after-soldius-in-tag":
        _(u"Unexpected character after / in tag. Expected >"),
    "expected-dashes-or-doctype":
       _(u"Expected '--' or 'DOCTYPE'. Not found."),
    "unexpected-bang-after-double-dash-in-comment":
        _(u"Unexpected ! after -- in comment"),
    "unexpected-space-after-double-dash-in-comment":
        _(u"Unexpected space after -- in comment"),
    "incorrect-comment":
       _(u"Incorrect comment."),
    "eof-in-comment":
       _(u"Unexpected end of file in comment."),
    "eof-in-comment-end-dash":
       _(u"Unexpected end of file in comment (-)"),
    "unexpected-dash-after-double-dash-in-comment":
       _(u"Unexpected '-' after '--' found in comment."),
    "eof-in-comment-double-dash":
       _(u"Unexpected end of file in comment (--)."),
    "eof-in-comment-end-space-state":
       _(u"Unexpected end of file in comment."),
    "eof-in-comment-end-bang-state":
       _(u"Unexpected end of file in comment."),
    "unexpected-char-in-comment":
       _(u"Unexpected character in comment found."),
    "need-space-after-doctype":
       _(u"No space after literal string 'DOCTYPE'."),
    "expected-doctype-name-but-got-right-bracket":
       _(u"Unexpected > character. Expected DOCTYPE name."),
    "expected-doctype-name-but-got-eof":
       _(u"Unexpected end of file. Expected DOCTYPE name."),
    "eof-in-doctype-name":
       _(u"Unexpected end of file in DOCTYPE name."),
    "eof-in-doctype":
       _(u"Unexpected end of file in DOCTYPE."),
    "expected-space-or-right-bracket-in-doctype":
       _(u"Expected space or '>'. Got '%(data)s'"),
    "unexpected-end-of-doctype":
       _(u"Unexpected end of DOCTYPE."),
    "unexpected-char-in-doctype":
       _(u"Unexpected character in DOCTYPE."),
    "eof-in-innerhtml":
       _(u"XXX innerHTML EOF"),
    "unexpected-doctype":
       _(u"Unexpected DOCTYPE. Ignored."),
    "non-html-root":
       _(u"html needs to be the first start tag."),
    "expected-doctype-but-got-eof":
       _(u"Unexpected End of file. Expected DOCTYPE."),
    "unknown-doctype":
       _(u"Erroneous DOCTYPE."),
    "expected-doctype-but-got-chars":
       _(u"Unexpected non-space characters. Expected DOCTYPE."),
    "expected-doctype-but-got-start-tag":
       _(u"Unexpected start tag (%(name)s). Expected DOCTYPE."),
    "expected-doctype-but-got-end-tag":
       _(u"Unexpected end tag (%(name)s). Expected DOCTYPE."),
    "end-tag-after-implied-root":
       _(u"Unexpected end tag (%(name)s) after the (implied) root element."),
    "expected-named-closing-tag-but-got-eof":
       _(u"Unexpected end of file. Expected end tag (%(name)s)."),
    "two-heads-are-not-better-than-one":
       _(u"Unexpected start tag head in existing head. Ignored."),
    "unexpected-end-tag":
       _(u"Unexpected end tag (%(name)s). Ignored."),
    "unexpected-start-tag-out-of-my-head":
       _(u"Unexpected start tag (%(name)s) that can be in head. Moved."),
    "unexpected-start-tag":
       _(u"Unexpected start tag (%(name)s)."),
    "missing-end-tag":
       _(u"Missing end tag (%(name)s)."),
    "missing-end-tags":
       _(u"Missing end tags (%(name)s)."),
    "unexpected-start-tag-implies-end-tag":
       _(u"Unexpected start tag (%(startName)s) "
         u"implies end tag (%(endName)s)."),
    "unexpected-start-tag-treated-as":
       _(u"Unexpected start tag (%(originalName)s). Treated as %(newName)s."),
    "deprecated-tag":
       _(u"Unexpected start tag %(name)s. Don't use it!"),
    "unexpected-start-tag-ignored":
       _(u"Unexpected start tag %(name)s. Ignored."),
    "expected-one-end-tag-but-got-another":
       _(u"Unexpected end tag (%(gotName)s). "
         u"Missing end tag (%(expectedName)s)."),
    "end-tag-too-early":
       _(u"End tag (%(name)s) seen too early. Expected other end tag."),
    "end-tag-too-early-named":
       _(u"Unexpected end tag (%(gotName)s). Expected end tag (%(expectedName)s)."),
    "end-tag-too-early-ignored":
       _(u"End tag (%(name)s) seen too early. Ignored."),
    "adoption-agency-1.1":
       _(u"End tag (%(name)s) violates step 1, "
         u"paragraph 1 of the adoption agency algorithm."),
    "adoption-agency-1.2":
       _(u"End tag (%(name)s) violates step 1, "
         u"paragraph 2 of the adoption agency algorithm."),
    "adoption-agency-1.3":
       _(u"End tag (%(name)s) violates step 1, "
         u"paragraph 3 of the adoption agency algorithm."),
    "unexpected-end-tag-treated-as":
       _(u"Unexpected end tag (%(originalName)s). Treated as %(newName)s."),
    "no-end-tag":
       _(u"This element (%(name)s) has no end tag."),
    "unexpected-implied-end-tag-in-table":
       _(u"Unexpected implied end tag (%(name)s) in the table phase."),
    "unexpected-implied-end-tag-in-table-body":
       _(u"Unexpected implied end tag (%(name)s) in the table body phase."),
    "unexpected-char-implies-table-voodoo":
       _(u"Unexpected non-space characters in "
         u"table context caused voodoo mode."),
    "unexpected-hidden-input-in-table":
       _(u"Unexpected input with type hidden in table context."),
    "unexpected-form-in-table":
       _(u"Unexpected form in table context."),
    "unexpected-start-tag-implies-table-voodoo":
       _(u"Unexpected start tag (%(name)s) in "
         u"table context caused voodoo mode."),
    "unexpected-end-tag-implies-table-voodoo":
       _(u"Unexpected end tag (%(name)s) in "
         u"table context caused voodoo mode."),
    "unexpected-cell-in-table-body":
       _(u"Unexpected table cell start tag (%(name)s) "
         u"in the table body phase."),
    "unexpected-cell-end-tag":
       _(u"Got table cell end tag (%(name)s) "
         u"while required end tags are missing."),
    "unexpected-end-tag-in-table-body":
       _(u"Unexpected end tag (%(name)s) in the table body phase. Ignored."),
    "unexpected-implied-end-tag-in-table-row":
       _(u"Unexpected implied end tag (%(name)s) in the table row phase."),
    "unexpected-end-tag-in-table-row":
       _(u"Unexpected end tag (%(name)s) in the table row phase. Ignored."),
    "unexpected-select-in-select":
       _(u"Unexpected select start tag in the select phase "
         u"treated as select end tag."),
    "unexpected-input-in-select":
       _(u"Unexpected input start tag in the select phase."),
    "unexpected-start-tag-in-select":
       _(u"Unexpected start tag token (%(name)s in the select phase. "
         u"Ignored."),
    "unexpected-end-tag-in-select":
       _(u"Unexpected end tag (%(name)s) in the select phase. Ignored."),
    "unexpected-table-element-start-tag-in-select-in-table":
       _(u"Unexpected table element start tag (%(name)s) in the select in table phase."),
    "unexpected-table-element-end-tag-in-select-in-table":
       _(u"Unexpected table element end tag (%(name)s) in the select in table phase."),
    "unexpected-char-after-body":
       _(u"Unexpected non-space characters in the after body phase."),
    "unexpected-start-tag-after-body":
       _(u"Unexpected start tag token (%(name)s)"
         u" in the after body phase."),
    "unexpected-end-tag-after-body":
       _(u"Unexpected end tag token (%(name)s)"
         u" in the after body phase."),
    "unexpected-char-in-frameset":
       _(u"Unepxected characters in the frameset phase. Characters ignored."),
    "unexpected-start-tag-in-frameset":
       _(u"Unexpected start tag token (%(name)s)"
         u" in the frameset phase. Ignored."),
    "unexpected-frameset-in-frameset-innerhtml":
       _(u"Unexpected end tag token (frameset) "
         u"in the frameset phase (innerHTML)."),
    "unexpected-end-tag-in-frameset":
       _(u"Unexpected end tag token (%(name)s)"
         u" in the frameset phase. Ignored."),
    "unexpected-char-after-frameset":
       _(u"Unexpected non-space characters in the "
         u"after frameset phase. Ignored."),
    "unexpected-start-tag-after-frameset":
       _(u"Unexpected start tag (%(name)s)"
         u" in the after frameset phase. Ignored."),
    "unexpected-end-tag-after-frameset":
       _(u"Unexpected end tag (%(name)s)"
         u" in the after frameset phase. Ignored."),
    "unexpected-end-tag-after-body-innerhtml":
       _(u"Unexpected end tag after body(innerHtml)"),
    "expected-eof-but-got-char":
       _(u"Unexpected non-space characters. Expected end of file."),
    "expected-eof-but-got-start-tag":
       _(u"Unexpected start tag (%(name)s)"
         u". Expected end of file."),
    "expected-eof-but-got-end-tag":
       _(u"Unexpected end tag (%(name)s)"
         u". Expected end of file."),
    "eof-in-table":
       _(u"Unexpected end of file. Expected table content."),
    "eof-in-select":
       _(u"Unexpected end of file. Expected select content."),
    "eof-in-frameset":
       _(u"Unexpected end of file. Expected frameset content."),
    "eof-in-script-in-script":
       _(u"Unexpected end of file. Expected script content."),
    "eof-in-foreign-lands":
       _(u"Unexpected end of file. Expected foreign content"),
    "non-void-element-with-trailing-solidus":
       _(u"Trailing solidus not allowed on element %(name)s"),
    "unexpected-html-element-in-foreign-content":
       _(u"Element %(name)s not allowed in a non-html context"),
    "unexpected-end-tag-before-html":
        _(u"Unexpected end tag (%(name)s) before html."),
    "XXX-undefined-error":
        (u"Undefined error (this sucks and should be fixed)"),
}

namespaces = {
    "html":"http://www.w3.org/1999/xhtml",
    "mathml":"http://www.w3.org/1998/Math/MathML",
    "svg":"http://www.w3.org/2000/svg",
    "xlink":"http://www.w3.org/1999/xlink",
    "xml":"http://www.w3.org/XML/1998/namespace",
    "xmlns":"http://www.w3.org/2000/xmlns/"
}

scopingElements = frozenset((
    (namespaces["html"], "applet"),
    (namespaces["html"], "caption"),
    (namespaces["html"], "html"),
    (namespaces["html"], "marquee"),
    (namespaces["html"], "object"),
    (namespaces["html"], "table"),
    (namespaces["html"], "td"),
    (namespaces["html"], "th"),
    (namespaces["mathml"], "mi"),
    (namespaces["mathml"], "mo"),
    (namespaces["mathml"], "mn"),
    (namespaces["mathml"], "ms"),
    (namespaces["mathml"], "mtext"),
    (namespaces["mathml"], "annotation-xml"),
    (namespaces["svg"], "foreignObject"),
    (namespaces["svg"], "desc"),
    (namespaces["svg"], "title"),
))

formattingElements = frozenset((
    (namespaces["html"], "a"),
    (namespaces["html"], "b"),
    (namespaces["html"], "big"),
    (namespaces["html"], "code"),
    (namespaces["html"], "em"),
    (namespaces["html"], "font"),
    (namespaces["html"], "i"),
    (namespaces["html"], "nobr"),
    (namespaces["html"], "s"),
    (namespaces["html"], "small"),
    (namespaces["html"], "strike"),
    (namespaces["html"], "strong"),
    (namespaces["html"], "tt"),
    (namespaces["html"], "u")
))

specialElements = frozenset((
    (namespaces["html"], "address"),
    (namespaces["html"], "applet"),
    (namespaces["html"], "area"),
    (namespaces["html"], "article"),
    (namespaces["html"], "aside"),
    (namespaces["html"], "base"),
    (namespaces["html"], "basefont"),
    (namespaces["html"], "bgsound"),
    (namespaces["html"], "blockquote"),
    (namespaces["html"], "body"),
    (namespaces["html"], "br"),
    (namespaces["html"], "button"),
    (namespaces["html"], "caption"),
    (namespaces["html"], "center"),
    (namespaces["html"], "col"),
    (namespaces["html"], "colgroup"),
    (namespaces["html"], "command"),
    (namespaces["html"], "dd"),
    (namespaces["html"], "details"),
    (namespaces["html"], "dir"),
    (namespaces["html"], "div"),
    (namespaces["html"], "dl"),
    (namespaces["html"], "dt"),
    (namespaces["html"], "embed"),
    (namespaces["html"], "fieldset"),
    (namespaces["html"], "figure"),
    (namespaces["html"], "footer"),
    (namespaces["html"], "form"),
    (namespaces["html"], "frame"),
    (namespaces["html"], "frameset"),
    (namespaces["html"], "h1"),
    (namespaces["html"], "h2"),
    (namespaces["html"], "h3"),
    (namespaces["html"], "h4"),
    (namespaces["html"], "h5"),
    (namespaces["html"], "h6"),
    (namespaces["html"], "head"),
    (namespaces["html"], "header"),
    (namespaces["html"], "hr"),
    (namespaces["html"], "html"),
    (namespaces["html"], "iframe"),
    # Note that image is commented out in the spec as "this isn't an
    # element that can end up on the stack, so it doesn't matter,"
    (namespaces["html"], "image"), 
    (namespaces["html"], "img"),
    (namespaces["html"], "input"),
    (namespaces["html"], "isindex"),
    (namespaces["html"], "li"),
    (namespaces["html"], "link"),
    (namespaces["html"], "listing"),
    (namespaces["html"], "marquee"),
    (namespaces["html"], "menu"),
    (namespaces["html"], "meta"),
    (namespaces["html"], "nav"),
    (namespaces["html"], "noembed"),
    (namespaces["html"], "noframes"),
    (namespaces["html"], "noscript"),
    (namespaces["html"], "object"),
    (namespaces["html"], "ol"),
    (namespaces["html"], "p"),
    (namespaces["html"], "param"),
    (namespaces["html"], "plaintext"),
    (namespaces["html"], "pre"),
    (namespaces["html"], "script"),
    (namespaces["html"], "section"),
    (namespaces["html"], "select"),
    (namespaces["html"], "style"),
    (namespaces["html"], "table"),
    (namespaces["html"], "tbody"),
    (namespaces["html"], "td"),
    (namespaces["html"], "textarea"),
    (namespaces["html"], "tfoot"),
    (namespaces["html"], "th"),
    (namespaces["html"], "thead"),
    (namespaces["html"], "title"),
    (namespaces["html"], "tr"),
    (namespaces["html"], "ul"),
    (namespaces["html"], "wbr"),
    (namespaces["html"], "xmp"),
    (namespaces["svg"], "foreignObject")
))

htmlIntegrationPointElements = frozenset((
    (namespaces["mathml"], "annotaion-xml"),
    (namespaces["svg"], "foreignObject"),
    (namespaces["svg"], "desc"),
    (namespaces["svg"], "title")
))

mathmlTextIntegrationPointElements = frozenset((
    (namespaces["mathml"], "mi"),
    (namespaces["mathml"], "mo"),
    (namespaces["mathml"], "mn"),
    (namespaces["mathml"], "ms"),
    (namespaces["mathml"], "mtext")
))

spaceCharacters = frozenset((
    u"\t",
    u"\n",
    u"\u000C",
    u" ",
    u"\r"
))

tableInsertModeElements = frozenset((
    "table",
    "tbody",
    "tfoot",
    "thead",
    "tr"
))

asciiLowercase = frozenset(string.ascii_lowercase)
asciiUppercase = frozenset(string.ascii_uppercase)
asciiLetters = frozenset(string.ascii_letters)
digits = frozenset(string.digits)
hexDigits = frozenset(string.hexdigits)

asciiUpper2Lower = dict([(ord(c),ord(c.lower()))
    for c in string.ascii_uppercase])

# Heading elements need to be ordered
headingElements = (
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6"
)

voidElements = frozenset((
    "base",
    "command",
    "event-source",
    "link",
    "meta",
    "hr",
    "br",
    "img",
    "embed",
    "param",
    "area",
    "col",
    "input",
    "source",
    "track"
))

cdataElements = frozenset(('title', 'textarea'))

rcdataElements = frozenset((
    'style',
    'script',
    'xmp',
    'iframe',
    'noembed',
    'noframes',
    'noscript'
))

booleanAttributes = {
    "": frozenset(("irrelevant",)),
    "style": frozenset(("scoped",)),
    "img": frozenset(("ismap",)),
    "audio": frozenset(("autoplay","controls")),
    "video": frozenset(("autoplay","controls")),
    "script": frozenset(("defer", "async")),
    "details": frozenset(("open",)),
    "datagrid": frozenset(("multiple", "disabled")),
    "command": frozenset(("hidden", "disabled", "checked", "default")),
    "hr": frozenset(("noshade")),
    "menu": frozenset(("autosubmit",)),
    "fieldset": frozenset(("disabled", "readonly")),
    "option": frozenset(("disabled", "readonly", "selected")),
    "optgroup": frozenset(("disabled", "readonly")),
    "button": frozenset(("disabled", "autofocus")),
    "input": frozenset(("disabled", "readonly", "required", "autofocus", "checked", "ismap")),
    "select": frozenset(("disabled", "readonly", "autofocus", "multiple")),
    "output": frozenset(("disabled", "readonly")),
}

# entitiesWindows1252 has to be _ordered_ and needs to have an index. It
# therefore can't be a frozenset.
entitiesWindows1252 = (
    8364,  # 0x80  0x20AC  EURO SIGN
    65533, # 0x81          UNDEFINED
    8218,  # 0x82  0x201A  SINGLE LOW-9 QUOTATION MARK
    402,   # 0x83  0x0192  LATIN SMALL LETTER F WITH HOOK
    8222,  # 0x84  0x201E  DOUBLE LOW-9 QUOTATION MARK
    8230,  # 0x85  0x2026  HORIZONTAL ELLIPSIS
    8224,  # 0x86  0x2020  DAGGER
    8225,  # 0x87  0x2021  DOUBLE DAGGER
    710,   # 0x88  0x02C6  MODIFIER LETTER CIRCUMFLEX ACCENT
    8240,  # 0x89  0x2030  PER MILLE SIGN
    352,   # 0x8A  0x0160  LATIN CAPITAL LETTER S WITH CARON
    8249,  # 0x8B  0x2039  SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    338,   # 0x8C  0x0152  LATIN CAPITAL LIGATURE OE
    65533, # 0x8D          UNDEFINED
    381,   # 0x8E  0x017D  LATIN CAPITAL LETTER Z WITH CARON
    65533, # 0x8F          UNDEFINED
    65533, # 0x90          UNDEFINED
    8216,  # 0x91  0x2018  LEFT SINGLE QUOTATION MARK
    8217,  # 0x92  0x2019  RIGHT SINGLE QUOTATION MARK
    8220,  # 0x93  0x201C  LEFT DOUBLE QUOTATION MARK
    8221,  # 0x94  0x201D  RIGHT DOUBLE QUOTATION MARK
    8226,  # 0x95  0x2022  BULLET
    8211,  # 0x96  0x2013  EN DASH
    8212,  # 0x97  0x2014  EM DASH
    732,   # 0x98  0x02DC  SMALL TILDE
    8482,  # 0x99  0x2122  TRADE MARK SIGN
    353,   # 0x9A  0x0161  LATIN SMALL LETTER S WITH CARON
    8250,  # 0x9B  0x203A  SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    339,   # 0x9C  0x0153  LATIN SMALL LIGATURE OE
    65533, # 0x9D          UNDEFINED
    382,   # 0x9E  0x017E  LATIN SMALL LETTER Z WITH CARON
    376    # 0x9F  0x0178  LATIN CAPITAL LETTER Y WITH DIAERESIS
)

xmlEntities = frozenset(('lt;', 'gt;', 'amp;', 'apos;', 'quot;'))

entities = {
    "AElig": u"\xc6",
    "AElig;": u"\xc6",
    "AMP": u"&",
    "AMP;": u"&",
    "Aacute": u"\xc1",
    "Aacute;": u"\xc1",
    "Abreve;": u"\u0102",
    "Acirc": u"\xc2",
    "Acirc;": u"\xc2",
    "Acy;": u"\u0410",
    "Afr;": u"\U0001d504",
    "Agrave": u"\xc0",
    "Agrave;": u"\xc0",
    "Alpha;": u"\u0391",
    "Amacr;": u"\u0100",
    "And;": u"\u2a53",
    "Aogon;": u"\u0104",
    "Aopf;": u"\U0001d538",
    "ApplyFunction;": u"\u2061",
    "Aring": u"\xc5",
    "Aring;": u"\xc5",
    "Ascr;": u"\U0001d49c",
    "Assign;": u"\u2254",
    "Atilde": u"\xc3",
    "Atilde;": u"\xc3",
    "Auml": u"\xc4",
    "Auml;": u"\xc4",
    "Backslash;": u"\u2216",
    "Barv;": u"\u2ae7",
    "Barwed;": u"\u2306",
    "Bcy;": u"\u0411",
    "Because;": u"\u2235",
    "Bernoullis;": u"\u212c",
    "Beta;": u"\u0392",
    "Bfr;": u"\U0001d505",
    "Bopf;": u"\U0001d539",
    "Breve;": u"\u02d8",
    "Bscr;": u"\u212c",
    "Bumpeq;": u"\u224e",
    "CHcy;": u"\u0427",
    "COPY": u"\xa9",
    "COPY;": u"\xa9",
    "Cacute;": u"\u0106",
    "Cap;": u"\u22d2",
    "CapitalDifferentialD;": u"\u2145",
    "Cayleys;": u"\u212d",
    "Ccaron;": u"\u010c",
    "Ccedil": u"\xc7",
    "Ccedil;": u"\xc7",
    "Ccirc;": u"\u0108",
    "Cconint;": u"\u2230",
    "Cdot;": u"\u010a",
    "Cedilla;": u"\xb8",
    "CenterDot;": u"\xb7",
    "Cfr;": u"\u212d",
    "Chi;": u"\u03a7",
    "CircleDot;": u"\u2299",
    "CircleMinus;": u"\u2296",
    "CirclePlus;": u"\u2295",
    "CircleTimes;": u"\u2297",
    "ClockwiseContourIntegral;": u"\u2232",
    "CloseCurlyDoubleQuote;": u"\u201d",
    "CloseCurlyQuote;": u"\u2019",
    "Colon;": u"\u2237",
    "Colone;": u"\u2a74",
    "Congruent;": u"\u2261",
    "Conint;": u"\u222f",
    "ContourIntegral;": u"\u222e",
    "Copf;": u"\u2102",
    "Coproduct;": u"\u2210",
    "CounterClockwiseContourIntegral;": u"\u2233",
    "Cross;": u"\u2a2f",
    "Cscr;": u"\U0001d49e",
    "Cup;": u"\u22d3",
    "CupCap;": u"\u224d",
    "DD;": u"\u2145",
    "DDotrahd;": u"\u2911",
    "DJcy;": u"\u0402",
    "DScy;": u"\u0405",
    "DZcy;": u"\u040f",
    "Dagger;": u"\u2021",
    "Darr;": u"\u21a1",
    "Dashv;": u"\u2ae4",
    "Dcaron;": u"\u010e",
    "Dcy;": u"\u0414",
    "Del;": u"\u2207",
    "Delta;": u"\u0394",
    "Dfr;": u"\U0001d507",
    "DiacriticalAcute;": u"\xb4",
    "DiacriticalDot;": u"\u02d9",
    "DiacriticalDoubleAcute;": u"\u02dd",
    "DiacriticalGrave;": u"`",
    "DiacriticalTilde;": u"\u02dc",
    "Diamond;": u"\u22c4",
    "DifferentialD;": u"\u2146",
    "Dopf;": u"\U0001d53b",
    "Dot;": u"\xa8",
    "DotDot;": u"\u20dc",
    "DotEqual;": u"\u2250",
    "DoubleContourIntegral;": u"\u222f",
    "DoubleDot;": u"\xa8",
    "DoubleDownArrow;": u"\u21d3",
    "DoubleLeftArrow;": u"\u21d0",
    "DoubleLeftRightArrow;": u"\u21d4",
    "DoubleLeftTee;": u"\u2ae4",
    "DoubleLongLeftArrow;": u"\u27f8",
    "DoubleLongLeftRightArrow;": u"\u27fa",
    "DoubleLongRightArrow;": u"\u27f9",
    "DoubleRightArrow;": u"\u21d2",
    "DoubleRightTee;": u"\u22a8",
    "DoubleUpArrow;": u"\u21d1",
    "DoubleUpDownArrow;": u"\u21d5",
    "DoubleVerticalBar;": u"\u2225",
    "DownArrow;": u"\u2193",
    "DownArrowBar;": u"\u2913",
    "DownArrowUpArrow;": u"\u21f5",
    "DownBreve;": u"\u0311",
    "DownLeftRightVector;": u"\u2950",
    "DownLeftTeeVector;": u"\u295e",
    "DownLeftVector;": u"\u21bd",
    "DownLeftVectorBar;": u"\u2956",
    "DownRightTeeVector;": u"\u295f",
    "DownRightVector;": u"\u21c1",
    "DownRightVectorBar;": u"\u2957",
    "DownTee;": u"\u22a4",
    "DownTeeArrow;": u"\u21a7",
    "Downarrow;": u"\u21d3",
    "Dscr;": u"\U0001d49f",
    "Dstrok;": u"\u0110",
    "ENG;": u"\u014a",
    "ETH": u"\xd0",
    "ETH;": u"\xd0",
    "Eacute": u"\xc9",
    "Eacute;": u"\xc9",
    "Ecaron;": u"\u011a",
    "Ecirc": u"\xca",
    "Ecirc;": u"\xca",
    "Ecy;": u"\u042d",
    "Edot;": u"\u0116",
    "Efr;": u"\U0001d508",
    "Egrave": u"\xc8",
    "Egrave;": u"\xc8",
    "Element;": u"\u2208",
    "Emacr;": u"\u0112",
    "EmptySmallSquare;": u"\u25fb",
    "EmptyVerySmallSquare;": u"\u25ab",
    "Eogon;": u"\u0118",
    "Eopf;": u"\U0001d53c",
    "Epsilon;": u"\u0395",
    "Equal;": u"\u2a75",
    "EqualTilde;": u"\u2242",
    "Equilibrium;": u"\u21cc",
    "Escr;": u"\u2130",
    "Esim;": u"\u2a73",
    "Eta;": u"\u0397",
    "Euml": u"\xcb",
    "Euml;": u"\xcb",
    "Exists;": u"\u2203",
    "ExponentialE;": u"\u2147",
    "Fcy;": u"\u0424",
    "Ffr;": u"\U0001d509",
    "FilledSmallSquare;": u"\u25fc",
    "FilledVerySmallSquare;": u"\u25aa",
    "Fopf;": u"\U0001d53d",
    "ForAll;": u"\u2200",
    "Fouriertrf;": u"\u2131",
    "Fscr;": u"\u2131",
    "GJcy;": u"\u0403",
    "GT": u">",
    "GT;": u">",
    "Gamma;": u"\u0393",
    "Gammad;": u"\u03dc",
    "Gbreve;": u"\u011e",
    "Gcedil;": u"\u0122",
    "Gcirc;": u"\u011c",
    "Gcy;": u"\u0413",
    "Gdot;": u"\u0120",
    "Gfr;": u"\U0001d50a",
    "Gg;": u"\u22d9",
    "Gopf;": u"\U0001d53e",
    "GreaterEqual;": u"\u2265",
    "GreaterEqualLess;": u"\u22db",
    "GreaterFullEqual;": u"\u2267",
    "GreaterGreater;": u"\u2aa2",
    "GreaterLess;": u"\u2277",
    "GreaterSlantEqual;": u"\u2a7e",
    "GreaterTilde;": u"\u2273",
    "Gscr;": u"\U0001d4a2",
    "Gt;": u"\u226b",
    "HARDcy;": u"\u042a",
    "Hacek;": u"\u02c7",
    "Hat;": u"^",
    "Hcirc;": u"\u0124",
    "Hfr;": u"\u210c",
    "HilbertSpace;": u"\u210b",
    "Hopf;": u"\u210d",
    "HorizontalLine;": u"\u2500",
    "Hscr;": u"\u210b",
    "Hstrok;": u"\u0126",
    "HumpDownHump;": u"\u224e",
    "HumpEqual;": u"\u224f",
    "IEcy;": u"\u0415",
    "IJlig;": u"\u0132",
    "IOcy;": u"\u0401",
    "Iacute": u"\xcd",
    "Iacute;": u"\xcd",
    "Icirc": u"\xce",
    "Icirc;": u"\xce",
    "Icy;": u"\u0418",
    "Idot;": u"\u0130",
    "Ifr;": u"\u2111",
    "Igrave": u"\xcc",
    "Igrave;": u"\xcc",
    "Im;": u"\u2111",
    "Imacr;": u"\u012a",
    "ImaginaryI;": u"\u2148",
    "Implies;": u"\u21d2",
    "Int;": u"\u222c",
    "Integral;": u"\u222b",
    "Intersection;": u"\u22c2",
    "InvisibleComma;": u"\u2063",
    "InvisibleTimes;": u"\u2062",
    "Iogon;": u"\u012e",
    "Iopf;": u"\U0001d540",
    "Iota;": u"\u0399",
    "Iscr;": u"\u2110",
    "Itilde;": u"\u0128",
    "Iukcy;": u"\u0406",
    "Iuml": u"\xcf",
    "Iuml;": u"\xcf",
    "Jcirc;": u"\u0134",
    "Jcy;": u"\u0419",
    "Jfr;": u"\U0001d50d",
    "Jopf;": u"\U0001d541",
    "Jscr;": u"\U0001d4a5",
    "Jsercy;": u"\u0408",
    "Jukcy;": u"\u0404",
    "KHcy;": u"\u0425",
    "KJcy;": u"\u040c",
    "Kappa;": u"\u039a",
    "Kcedil;": u"\u0136",
    "Kcy;": u"\u041a",
    "Kfr;": u"\U0001d50e",
    "Kopf;": u"\U0001d542",
    "Kscr;": u"\U0001d4a6",
    "LJcy;": u"\u0409",
    "LT": u"<",
    "LT;": u"<",
    "Lacute;": u"\u0139",
    "Lambda;": u"\u039b",
    "Lang;": u"\u27ea",
    "Laplacetrf;": u"\u2112",
    "Larr;": u"\u219e",
    "Lcaron;": u"\u013d",
    "Lcedil;": u"\u013b",
    "Lcy;": u"\u041b",
    "LeftAngleBracket;": u"\u27e8",
    "LeftArrow;": u"\u2190",
    "LeftArrowBar;": u"\u21e4",
    "LeftArrowRightArrow;": u"\u21c6",
    "LeftCeiling;": u"\u2308",
    "LeftDoubleBracket;": u"\u27e6",
    "LeftDownTeeVector;": u"\u2961",
    "LeftDownVector;": u"\u21c3",
    "LeftDownVectorBar;": u"\u2959",
    "LeftFloor;": u"\u230a",
    "LeftRightArrow;": u"\u2194",
    "LeftRightVector;": u"\u294e",
    "LeftTee;": u"\u22a3",
    "LeftTeeArrow;": u"\u21a4",
    "LeftTeeVector;": u"\u295a",
    "LeftTriangle;": u"\u22b2",
    "LeftTriangleBar;": u"\u29cf",
    "LeftTriangleEqual;": u"\u22b4",
    "LeftUpDownVector;": u"\u2951",
    "LeftUpTeeVector;": u"\u2960",
    "LeftUpVector;": u"\u21bf",
    "LeftUpVectorBar;": u"\u2958",
    "LeftVector;": u"\u21bc",
    "LeftVectorBar;": u"\u2952",
    "Leftarrow;": u"\u21d0",
    "Leftrightarrow;": u"\u21d4",
    "LessEqualGreater;": u"\u22da",
    "LessFullEqual;": u"\u2266",
    "LessGreater;": u"\u2276",
    "LessLess;": u"\u2aa1",
    "LessSlantEqual;": u"\u2a7d",
    "LessTilde;": u"\u2272",
    "Lfr;": u"\U0001d50f",
    "Ll;": u"\u22d8",
    "Lleftarrow;": u"\u21da",
    "Lmidot;": u"\u013f",
    "LongLeftArrow;": u"\u27f5",
    "LongLeftRightArrow;": u"\u27f7",
    "LongRightArrow;": u"\u27f6",
    "Longleftarrow;": u"\u27f8",
    "Longleftrightarrow;": u"\u27fa",
    "Longrightarrow;": u"\u27f9",
    "Lopf;": u"\U0001d543",
    "LowerLeftArrow;": u"\u2199",
    "LowerRightArrow;": u"\u2198",
    "Lscr;": u"\u2112",
    "Lsh;": u"\u21b0",
    "Lstrok;": u"\u0141",
    "Lt;": u"\u226a",
    "Map;": u"\u2905",
    "Mcy;": u"\u041c",
    "MediumSpace;": u"\u205f",
    "Mellintrf;": u"\u2133",
    "Mfr;": u"\U0001d510",
    "MinusPlus;": u"\u2213",
    "Mopf;": u"\U0001d544",
    "Mscr;": u"\u2133",
    "Mu;": u"\u039c",
    "NJcy;": u"\u040a",
    "Nacute;": u"\u0143",
    "Ncaron;": u"\u0147",
    "Ncedil;": u"\u0145",
    "Ncy;": u"\u041d",
    "NegativeMediumSpace;": u"\u200b",
    "NegativeThickSpace;": u"\u200b",
    "NegativeThinSpace;": u"\u200b",
    "NegativeVeryThinSpace;": u"\u200b",
    "NestedGreaterGreater;": u"\u226b",
    "NestedLessLess;": u"\u226a",
    "NewLine;": u"\n",
    "Nfr;": u"\U0001d511",
    "NoBreak;": u"\u2060",
    "NonBreakingSpace;": u"\xa0",
    "Nopf;": u"\u2115",
    "Not;": u"\u2aec",
    "NotCongruent;": u"\u2262",
    "NotCupCap;": u"\u226d",
    "NotDoubleVerticalBar;": u"\u2226",
    "NotElement;": u"\u2209",
    "NotEqual;": u"\u2260",
    "NotEqualTilde;": u"\u2242\u0338",
    "NotExists;": u"\u2204",
    "NotGreater;": u"\u226f",
    "NotGreaterEqual;": u"\u2271",
    "NotGreaterFullEqual;": u"\u2267\u0338",
    "NotGreaterGreater;": u"\u226b\u0338",
    "NotGreaterLess;": u"\u2279",
    "NotGreaterSlantEqual;": u"\u2a7e\u0338",
    "NotGreaterTilde;": u"\u2275",
    "NotHumpDownHump;": u"\u224e\u0338",
    "NotHumpEqual;": u"\u224f\u0338",
    "NotLeftTriangle;": u"\u22ea",
    "NotLeftTriangleBar;": u"\u29cf\u0338",
    "NotLeftTriangleEqual;": u"\u22ec",
    "NotLess;": u"\u226e",
    "NotLessEqual;": u"\u2270",
    "NotLessGreater;": u"\u2278",
    "NotLessLess;": u"\u226a\u0338",
    "NotLessSlantEqual;": u"\u2a7d\u0338",
    "NotLessTilde;": u"\u2274",
    "NotNestedGreaterGreater;": u"\u2aa2\u0338",
    "NotNestedLessLess;": u"\u2aa1\u0338",
    "NotPrecedes;": u"\u2280",
    "NotPrecedesEqual;": u"\u2aaf\u0338",
    "NotPrecedesSlantEqual;": u"\u22e0",
    "NotReverseElement;": u"\u220c",
    "NotRightTriangle;": u"\u22eb",
    "NotRightTriangleBar;": u"\u29d0\u0338",
    "NotRightTriangleEqual;": u"\u22ed",
    "NotSquareSubset;": u"\u228f\u0338",
    "NotSquareSubsetEqual;": u"\u22e2",
    "NotSquareSuperset;": u"\u2290\u0338",
    "NotSquareSupersetEqual;": u"\u22e3",
    "NotSubset;": u"\u2282\u20d2",
    "NotSubsetEqual;": u"\u2288",
    "NotSucceeds;": u"\u2281",
    "NotSucceedsEqual;": u"\u2ab0\u0338",
    "NotSucceedsSlantEqual;": u"\u22e1",
    "NotSucceedsTilde;": u"\u227f\u0338",
    "NotSuperset;": u"\u2283\u20d2",
    "NotSupersetEqual;": u"\u2289",
    "NotTilde;": u"\u2241",
    "NotTildeEqual;": u"\u2244",
    "NotTildeFullEqual;": u"\u2247",
    "NotTildeTilde;": u"\u2249",
    "NotVerticalBar;": u"\u2224",
    "Nscr;": u"\U0001d4a9",
    "Ntilde": u"\xd1",
    "Ntilde;": u"\xd1",
    "Nu;": u"\u039d",
    "OElig;": u"\u0152",
    "Oacute": u"\xd3",
    "Oacute;": u"\xd3",
    "Ocirc": u"\xd4",
    "Ocirc;": u"\xd4",
    "Ocy;": u"\u041e",
    "Odblac;": u"\u0150",
    "Ofr;": u"\U0001d512",
    "Ograve": u"\xd2",
    "Ograve;": u"\xd2",
    "Omacr;": u"\u014c",
    "Omega;": u"\u03a9",
    "Omicron;": u"\u039f",
    "Oopf;": u"\U0001d546",
    "OpenCurlyDoubleQuote;": u"\u201c",
    "OpenCurlyQuote;": u"\u2018",
    "Or;": u"\u2a54",
    "Oscr;": u"\U0001d4aa",
    "Oslash": u"\xd8",
    "Oslash;": u"\xd8",
    "Otilde": u"\xd5",
    "Otilde;": u"\xd5",
    "Otimes;": u"\u2a37",
    "Ouml": u"\xd6",
    "Ouml;": u"\xd6",
    "OverBar;": u"\u203e",
    "OverBrace;": u"\u23de",
    "OverBracket;": u"\u23b4",
    "OverParenthesis;": u"\u23dc",
    "PartialD;": u"\u2202",
    "Pcy;": u"\u041f",
    "Pfr;": u"\U0001d513",
    "Phi;": u"\u03a6",
    "Pi;": u"\u03a0",
    "PlusMinus;": u"\xb1",
    "Poincareplane;": u"\u210c",
    "Popf;": u"\u2119",
    "Pr;": u"\u2abb",
    "Precedes;": u"\u227a",
    "PrecedesEqual;": u"\u2aaf",
    "PrecedesSlantEqual;": u"\u227c",
    "PrecedesTilde;": u"\u227e",
    "Prime;": u"\u2033",
    "Product;": u"\u220f",
    "Proportion;": u"\u2237",
    "Proportional;": u"\u221d",
    "Pscr;": u"\U0001d4ab",
    "Psi;": u"\u03a8",
    "QUOT": u"\"",
    "QUOT;": u"\"",
    "Qfr;": u"\U0001d514",
    "Qopf;": u"\u211a",
    "Qscr;": u"\U0001d4ac",
    "RBarr;": u"\u2910",
    "REG": u"\xae",
    "REG;": u"\xae",
    "Racute;": u"\u0154",
    "Rang;": u"\u27eb",
    "Rarr;": u"\u21a0",
    "Rarrtl;": u"\u2916",
    "Rcaron;": u"\u0158",
    "Rcedil;": u"\u0156",
    "Rcy;": u"\u0420",
    "Re;": u"\u211c",
    "ReverseElement;": u"\u220b",
    "ReverseEquilibrium;": u"\u21cb",
    "ReverseUpEquilibrium;": u"\u296f",
    "Rfr;": u"\u211c",
    "Rho;": u"\u03a1",
    "RightAngleBracket;": u"\u27e9",
    "RightArrow;": u"\u2192",
    "RightArrowBar;": u"\u21e5",
    "RightArrowLeftArrow;": u"\u21c4",
    "RightCeiling;": u"\u2309",
    "RightDoubleBracket;": u"\u27e7",
    "RightDownTeeVector;": u"\u295d",
    "RightDownVector;": u"\u21c2",
    "RightDownVectorBar;": u"\u2955",
    "RightFloor;": u"\u230b",
    "RightTee;": u"\u22a2",
    "RightTeeArrow;": u"\u21a6",
    "RightTeeVector;": u"\u295b",
    "RightTriangle;": u"\u22b3",
    "RightTriangleBar;": u"\u29d0",
    "RightTriangleEqual;": u"\u22b5",
    "RightUpDownVector;": u"\u294f",
    "RightUpTeeVector;": u"\u295c",
    "RightUpVector;": u"\u21be",
    "RightUpVectorBar;": u"\u2954",
    "RightVector;": u"\u21c0",
    "RightVectorBar;": u"\u2953",
    "Rightarrow;": u"\u21d2",
    "Ropf;": u"\u211d",
    "RoundImplies;": u"\u2970",
    "Rrightarrow;": u"\u21db",
    "Rscr;": u"\u211b",
    "Rsh;": u"\u21b1",
    "RuleDelayed;": u"\u29f4",
    "SHCHcy;": u"\u0429",
    "SHcy;": u"\u0428",
    "SOFTcy;": u"\u042c",
    "Sacute;": u"\u015a",
    "Sc;": u"\u2abc",
    "Scaron;": u"\u0160",
    "Scedil;": u"\u015e",
    "Scirc;": u"\u015c",
    "Scy;": u"\u0421",
    "Sfr;": u"\U0001d516",
    "ShortDownArrow;": u"\u2193",
    "ShortLeftArrow;": u"\u2190",
    "ShortRightArrow;": u"\u2192",
    "ShortUpArrow;": u"\u2191",
    "Sigma;": u"\u03a3",
    "SmallCircle;": u"\u2218",
    "Sopf;": u"\U0001d54a",
    "Sqrt;": u"\u221a",
    "Square;": u"\u25a1",
    "SquareIntersection;": u"\u2293",
    "SquareSubset;": u"\u228f",
    "SquareSubsetEqual;": u"\u2291",
    "SquareSuperset;": u"\u2290",
    "SquareSupersetEqual;": u"\u2292",
    "SquareUnion;": u"\u2294",
    "Sscr;": u"\U0001d4ae",
    "Star;": u"\u22c6",
    "Sub;": u"\u22d0",
    "Subset;": u"\u22d0",
    "SubsetEqual;": u"\u2286",
    "Succeeds;": u"\u227b",
    "SucceedsEqual;": u"\u2ab0",
    "SucceedsSlantEqual;": u"\u227d",
    "SucceedsTilde;": u"\u227f",
    "SuchThat;": u"\u220b",
    "Sum;": u"\u2211",
    "Sup;": u"\u22d1",
    "Superset;": u"\u2283",
    "SupersetEqual;": u"\u2287",
    "Supset;": u"\u22d1",
    "THORN": u"\xde",
    "THORN;": u"\xde",
    "TRADE;": u"\u2122",
    "TSHcy;": u"\u040b",
    "TScy;": u"\u0426",
    "Tab;": u"\t",
    "Tau;": u"\u03a4",
    "Tcaron;": u"\u0164",
    "Tcedil;": u"\u0162",
    "Tcy;": u"\u0422",
    "Tfr;": u"\U0001d517",
    "Therefore;": u"\u2234",
    "Theta;": u"\u0398",
    "ThickSpace;": u"\u205f\u200a",
    "ThinSpace;": u"\u2009",
    "Tilde;": u"\u223c",
    "TildeEqual;": u"\u2243",
    "TildeFullEqual;": u"\u2245",
    "TildeTilde;": u"\u2248",
    "Topf;": u"\U0001d54b",
    "TripleDot;": u"\u20db",
    "Tscr;": u"\U0001d4af",
    "Tstrok;": u"\u0166",
    "Uacute": u"\xda",
    "Uacute;": u"\xda",
    "Uarr;": u"\u219f",
    "Uarrocir;": u"\u2949",
    "Ubrcy;": u"\u040e",
    "Ubreve;": u"\u016c",
    "Ucirc": u"\xdb",
    "Ucirc;": u"\xdb",
    "Ucy;": u"\u0423",
    "Udblac;": u"\u0170",
    "Ufr;": u"\U0001d518",
    "Ugrave": u"\xd9",
    "Ugrave;": u"\xd9",
    "Umacr;": u"\u016a",
    "UnderBar;": u"_",
    "UnderBrace;": u"\u23df",
    "UnderBracket;": u"\u23b5",
    "UnderParenthesis;": u"\u23dd",
    "Union;": u"\u22c3",
    "UnionPlus;": u"\u228e",
    "Uogon;": u"\u0172",
    "Uopf;": u"\U0001d54c",
    "UpArrow;": u"\u2191",
    "UpArrowBar;": u"\u2912",
    "UpArrowDownArrow;": u"\u21c5",
    "UpDownArrow;": u"\u2195",
    "UpEquilibrium;": u"\u296e",
    "UpTee;": u"\u22a5",
    "UpTeeArrow;": u"\u21a5",
    "Uparrow;": u"\u21d1",
    "Updownarrow;": u"\u21d5",
    "UpperLeftArrow;": u"\u2196",
    "UpperRightArrow;": u"\u2197",
    "Upsi;": u"\u03d2",
    "Upsilon;": u"\u03a5",
    "Uring;": u"\u016e",
    "Uscr;": u"\U0001d4b0",
    "Utilde;": u"\u0168",
    "Uuml": u"\xdc",
    "Uuml;": u"\xdc",
    "VDash;": u"\u22ab",
    "Vbar;": u"\u2aeb",
    "Vcy;": u"\u0412",
    "Vdash;": u"\u22a9",
    "Vdashl;": u"\u2ae6",
    "Vee;": u"\u22c1",
    "Verbar;": u"\u2016",
    "Vert;": u"\u2016",
    "VerticalBar;": u"\u2223",
    "VerticalLine;": u"|",
    "VerticalSeparator;": u"\u2758",
    "VerticalTilde;": u"\u2240",
    "VeryThinSpace;": u"\u200a",
    "Vfr;": u"\U0001d519",
    "Vopf;": u"\U0001d54d",
    "Vscr;": u"\U0001d4b1",
    "Vvdash;": u"\u22aa",
    "Wcirc;": u"\u0174",
    "Wedge;": u"\u22c0",
    "Wfr;": u"\U0001d51a",
    "Wopf;": u"\U0001d54e",
    "Wscr;": u"\U0001d4b2",
    "Xfr;": u"\U0001d51b",
    "Xi;": u"\u039e",
    "Xopf;": u"\U0001d54f",
    "Xscr;": u"\U0001d4b3",
    "YAcy;": u"\u042f",
    "YIcy;": u"\u0407",
    "YUcy;": u"\u042e",
    "Yacute": u"\xdd",
    "Yacute;": u"\xdd",
    "Ycirc;": u"\u0176",
    "Ycy;": u"\u042b",
    "Yfr;": u"\U0001d51c",
    "Yopf;": u"\U0001d550",
    "Yscr;": u"\U0001d4b4",
    "Yuml;": u"\u0178",
    "ZHcy;": u"\u0416",
    "Zacute;": u"\u0179",
    "Zcaron;": u"\u017d",
    "Zcy;": u"\u0417",
    "Zdot;": u"\u017b",
    "ZeroWidthSpace;": u"\u200b",
    "Zeta;": u"\u0396",
    "Zfr;": u"\u2128",
    "Zopf;": u"\u2124",
    "Zscr;": u"\U0001d4b5",
    "aacute": u"\xe1",
    "aacute;": u"\xe1",
    "abreve;": u"\u0103",
    "ac;": u"\u223e",
    "acE;": u"\u223e\u0333",
    "acd;": u"\u223f",
    "acirc": u"\xe2",
    "acirc;": u"\xe2",
    "acute": u"\xb4",
    "acute;": u"\xb4",
    "acy;": u"\u0430",
    "aelig": u"\xe6",
    "aelig;": u"\xe6",
    "af;": u"\u2061",
    "afr;": u"\U0001d51e",
    "agrave": u"\xe0",
    "agrave;": u"\xe0",
    "alefsym;": u"\u2135",
    "aleph;": u"\u2135",
    "alpha;": u"\u03b1",
    "amacr;": u"\u0101",
    "amalg;": u"\u2a3f",
    "amp": u"&",
    "amp;": u"&",
    "and;": u"\u2227",
    "andand;": u"\u2a55",
    "andd;": u"\u2a5c",
    "andslope;": u"\u2a58",
    "andv;": u"\u2a5a",
    "ang;": u"\u2220",
    "ange;": u"\u29a4",
    "angle;": u"\u2220",
    "angmsd;": u"\u2221",
    "angmsdaa;": u"\u29a8",
    "angmsdab;": u"\u29a9",
    "angmsdac;": u"\u29aa",
    "angmsdad;": u"\u29ab",
    "angmsdae;": u"\u29ac",
    "angmsdaf;": u"\u29ad",
    "angmsdag;": u"\u29ae",
    "angmsdah;": u"\u29af",
    "angrt;": u"\u221f",
    "angrtvb;": u"\u22be",
    "angrtvbd;": u"\u299d",
    "angsph;": u"\u2222",
    "angst;": u"\xc5",
    "angzarr;": u"\u237c",
    "aogon;": u"\u0105",
    "aopf;": u"\U0001d552",
    "ap;": u"\u2248",
    "apE;": u"\u2a70",
    "apacir;": u"\u2a6f",
    "ape;": u"\u224a",
    "apid;": u"\u224b",
    "apos;": u"'",
    "approx;": u"\u2248",
    "approxeq;": u"\u224a",
    "aring": u"\xe5",
    "aring;": u"\xe5",
    "ascr;": u"\U0001d4b6",
    "ast;": u"*",
    "asymp;": u"\u2248",
    "asympeq;": u"\u224d",
    "atilde": u"\xe3",
    "atilde;": u"\xe3",
    "auml": u"\xe4",
    "auml;": u"\xe4",
    "awconint;": u"\u2233",
    "awint;": u"\u2a11",
    "bNot;": u"\u2aed",
    "backcong;": u"\u224c",
    "backepsilon;": u"\u03f6",
    "backprime;": u"\u2035",
    "backsim;": u"\u223d",
    "backsimeq;": u"\u22cd",
    "barvee;": u"\u22bd",
    "barwed;": u"\u2305",
    "barwedge;": u"\u2305",
    "bbrk;": u"\u23b5",
    "bbrktbrk;": u"\u23b6",
    "bcong;": u"\u224c",
    "bcy;": u"\u0431",
    "bdquo;": u"\u201e",
    "becaus;": u"\u2235",
    "because;": u"\u2235",
    "bemptyv;": u"\u29b0",
    "bepsi;": u"\u03f6",
    "bernou;": u"\u212c",
    "beta;": u"\u03b2",
    "beth;": u"\u2136",
    "between;": u"\u226c",
    "bfr;": u"\U0001d51f",
    "bigcap;": u"\u22c2",
    "bigcirc;": u"\u25ef",
    "bigcup;": u"\u22c3",
    "bigodot;": u"\u2a00",
    "bigoplus;": u"\u2a01",
    "bigotimes;": u"\u2a02",
    "bigsqcup;": u"\u2a06",
    "bigstar;": u"\u2605",
    "bigtriangledown;": u"\u25bd",
    "bigtriangleup;": u"\u25b3",
    "biguplus;": u"\u2a04",
    "bigvee;": u"\u22c1",
    "bigwedge;": u"\u22c0",
    "bkarow;": u"\u290d",
    "blacklozenge;": u"\u29eb",
    "blacksquare;": u"\u25aa",
    "blacktriangle;": u"\u25b4",
    "blacktriangledown;": u"\u25be",
    "blacktriangleleft;": u"\u25c2",
    "blacktriangleright;": u"\u25b8",
    "blank;": u"\u2423",
    "blk12;": u"\u2592",
    "blk14;": u"\u2591",
    "blk34;": u"\u2593",
    "block;": u"\u2588",
    "bne;": u"=\u20e5",
    "bnequiv;": u"\u2261\u20e5",
    "bnot;": u"\u2310",
    "bopf;": u"\U0001d553",
    "bot;": u"\u22a5",
    "bottom;": u"\u22a5",
    "bowtie;": u"\u22c8",
    "boxDL;": u"\u2557",
    "boxDR;": u"\u2554",
    "boxDl;": u"\u2556",
    "boxDr;": u"\u2553",
    "boxH;": u"\u2550",
    "boxHD;": u"\u2566",
    "boxHU;": u"\u2569",
    "boxHd;": u"\u2564",
    "boxHu;": u"\u2567",
    "boxUL;": u"\u255d",
    "boxUR;": u"\u255a",
    "boxUl;": u"\u255c",
    "boxUr;": u"\u2559",
    "boxV;": u"\u2551",
    "boxVH;": u"\u256c",
    "boxVL;": u"\u2563",
    "boxVR;": u"\u2560",
    "boxVh;": u"\u256b",
    "boxVl;": u"\u2562",
    "boxVr;": u"\u255f",
    "boxbox;": u"\u29c9",
    "boxdL;": u"\u2555",
    "boxdR;": u"\u2552",
    "boxdl;": u"\u2510",
    "boxdr;": u"\u250c",
    "boxh;": u"\u2500",
    "boxhD;": u"\u2565",
    "boxhU;": u"\u2568",
    "boxhd;": u"\u252c",
    "boxhu;": u"\u2534",
    "boxminus;": u"\u229f",
    "boxplus;": u"\u229e",
    "boxtimes;": u"\u22a0",
    "boxuL;": u"\u255b",
    "boxuR;": u"\u2558",
    "boxul;": u"\u2518",
    "boxur;": u"\u2514",
    "boxv;": u"\u2502",
    "boxvH;": u"\u256a",
    "boxvL;": u"\u2561",
    "boxvR;": u"\u255e",
    "boxvh;": u"\u253c",
    "boxvl;": u"\u2524",
    "boxvr;": u"\u251c",
    "bprime;": u"\u2035",
    "breve;": u"\u02d8",
    "brvbar": u"\xa6",
    "brvbar;": u"\xa6",
    "bscr;": u"\U0001d4b7",
    "bsemi;": u"\u204f",
    "bsim;": u"\u223d",
    "bsime;": u"\u22cd",
    "bsol;": u"\\",
    "bsolb;": u"\u29c5",
    "bsolhsub;": u"\u27c8",
    "bull;": u"\u2022",
    "bullet;": u"\u2022",
    "bump;": u"\u224e",
    "bumpE;": u"\u2aae",
    "bumpe;": u"\u224f",
    "bumpeq;": u"\u224f",
    "cacute;": u"\u0107",
    "cap;": u"\u2229",
    "capand;": u"\u2a44",
    "capbrcup;": u"\u2a49",
    "capcap;": u"\u2a4b",
    "capcup;": u"\u2a47",
    "capdot;": u"\u2a40",
    "caps;": u"\u2229\ufe00",
    "caret;": u"\u2041",
    "caron;": u"\u02c7",
    "ccaps;": u"\u2a4d",
    "ccaron;": u"\u010d",
    "ccedil": u"\xe7",
    "ccedil;": u"\xe7",
    "ccirc;": u"\u0109",
    "ccups;": u"\u2a4c",
    "ccupssm;": u"\u2a50",
    "cdot;": u"\u010b",
    "cedil": u"\xb8",
    "cedil;": u"\xb8",
    "cemptyv;": u"\u29b2",
    "cent": u"\xa2",
    "cent;": u"\xa2",
    "centerdot;": u"\xb7",
    "cfr;": u"\U0001d520",
    "chcy;": u"\u0447",
    "check;": u"\u2713",
    "checkmark;": u"\u2713",
    "chi;": u"\u03c7",
    "cir;": u"\u25cb",
    "cirE;": u"\u29c3",
    "circ;": u"\u02c6",
    "circeq;": u"\u2257",
    "circlearrowleft;": u"\u21ba",
    "circlearrowright;": u"\u21bb",
    "circledR;": u"\xae",
    "circledS;": u"\u24c8",
    "circledast;": u"\u229b",
    "circledcirc;": u"\u229a",
    "circleddash;": u"\u229d",
    "cire;": u"\u2257",
    "cirfnint;": u"\u2a10",
    "cirmid;": u"\u2aef",
    "cirscir;": u"\u29c2",
    "clubs;": u"\u2663",
    "clubsuit;": u"\u2663",
    "colon;": u":",
    "colone;": u"\u2254",
    "coloneq;": u"\u2254",
    "comma;": u",",
    "commat;": u"@",
    "comp;": u"\u2201",
    "compfn;": u"\u2218",
    "complement;": u"\u2201",
    "complexes;": u"\u2102",
    "cong;": u"\u2245",
    "congdot;": u"\u2a6d",
    "conint;": u"\u222e",
    "copf;": u"\U0001d554",
    "coprod;": u"\u2210",
    "copy": u"\xa9",
    "copy;": u"\xa9",
    "copysr;": u"\u2117",
    "crarr;": u"\u21b5",
    "cross;": u"\u2717",
    "cscr;": u"\U0001d4b8",
    "csub;": u"\u2acf",
    "csube;": u"\u2ad1",
    "csup;": u"\u2ad0",
    "csupe;": u"\u2ad2",
    "ctdot;": u"\u22ef",
    "cudarrl;": u"\u2938",
    "cudarrr;": u"\u2935",
    "cuepr;": u"\u22de",
    "cuesc;": u"\u22df",
    "cularr;": u"\u21b6",
    "cularrp;": u"\u293d",
    "cup;": u"\u222a",
    "cupbrcap;": u"\u2a48",
    "cupcap;": u"\u2a46",
    "cupcup;": u"\u2a4a",
    "cupdot;": u"\u228d",
    "cupor;": u"\u2a45",
    "cups;": u"\u222a\ufe00",
    "curarr;": u"\u21b7",
    "curarrm;": u"\u293c",
    "curlyeqprec;": u"\u22de",
    "curlyeqsucc;": u"\u22df",
    "curlyvee;": u"\u22ce",
    "curlywedge;": u"\u22cf",
    "curren": u"\xa4",
    "curren;": u"\xa4",
    "curvearrowleft;": u"\u21b6",
    "curvearrowright;": u"\u21b7",
    "cuvee;": u"\u22ce",
    "cuwed;": u"\u22cf",
    "cwconint;": u"\u2232",
    "cwint;": u"\u2231",
    "cylcty;": u"\u232d",
    "dArr;": u"\u21d3",
    "dHar;": u"\u2965",
    "dagger;": u"\u2020",
    "daleth;": u"\u2138",
    "darr;": u"\u2193",
    "dash;": u"\u2010",
    "dashv;": u"\u22a3",
    "dbkarow;": u"\u290f",
    "dblac;": u"\u02dd",
    "dcaron;": u"\u010f",
    "dcy;": u"\u0434",
    "dd;": u"\u2146",
    "ddagger;": u"\u2021",
    "ddarr;": u"\u21ca",
    "ddotseq;": u"\u2a77",
    "deg": u"\xb0",
    "deg;": u"\xb0",
    "delta;": u"\u03b4",
    "demptyv;": u"\u29b1",
    "dfisht;": u"\u297f",
    "dfr;": u"\U0001d521",
    "dharl;": u"\u21c3",
    "dharr;": u"\u21c2",
    "diam;": u"\u22c4",
    "diamond;": u"\u22c4",
    "diamondsuit;": u"\u2666",
    "diams;": u"\u2666",
    "die;": u"\xa8",
    "digamma;": u"\u03dd",
    "disin;": u"\u22f2",
    "div;": u"\xf7",
    "divide": u"\xf7",
    "divide;": u"\xf7",
    "divideontimes;": u"\u22c7",
    "divonx;": u"\u22c7",
    "djcy;": u"\u0452",
    "dlcorn;": u"\u231e",
    "dlcrop;": u"\u230d",
    "dollar;": u"$",
    "dopf;": u"\U0001d555",
    "dot;": u"\u02d9",
    "doteq;": u"\u2250",
    "doteqdot;": u"\u2251",
    "dotminus;": u"\u2238",
    "dotplus;": u"\u2214",
    "dotsquare;": u"\u22a1",
    "doublebarwedge;": u"\u2306",
    "downarrow;": u"\u2193",
    "downdownarrows;": u"\u21ca",
    "downharpoonleft;": u"\u21c3",
    "downharpoonright;": u"\u21c2",
    "drbkarow;": u"\u2910",
    "drcorn;": u"\u231f",
    "drcrop;": u"\u230c",
    "dscr;": u"\U0001d4b9",
    "dscy;": u"\u0455",
    "dsol;": u"\u29f6",
    "dstrok;": u"\u0111",
    "dtdot;": u"\u22f1",
    "dtri;": u"\u25bf",
    "dtrif;": u"\u25be",
    "duarr;": u"\u21f5",
    "duhar;": u"\u296f",
    "dwangle;": u"\u29a6",
    "dzcy;": u"\u045f",
    "dzigrarr;": u"\u27ff",
    "eDDot;": u"\u2a77",
    "eDot;": u"\u2251",
    "eacute": u"\xe9",
    "eacute;": u"\xe9",
    "easter;": u"\u2a6e",
    "ecaron;": u"\u011b",
    "ecir;": u"\u2256",
    "ecirc": u"\xea",
    "ecirc;": u"\xea",
    "ecolon;": u"\u2255",
    "ecy;": u"\u044d",
    "edot;": u"\u0117",
    "ee;": u"\u2147",
    "efDot;": u"\u2252",
    "efr;": u"\U0001d522",
    "eg;": u"\u2a9a",
    "egrave": u"\xe8",
    "egrave;": u"\xe8",
    "egs;": u"\u2a96",
    "egsdot;": u"\u2a98",
    "el;": u"\u2a99",
    "elinters;": u"\u23e7",
    "ell;": u"\u2113",
    "els;": u"\u2a95",
    "elsdot;": u"\u2a97",
    "emacr;": u"\u0113",
    "empty;": u"\u2205",
    "emptyset;": u"\u2205",
    "emptyv;": u"\u2205",
    "emsp13;": u"\u2004",
    "emsp14;": u"\u2005",
    "emsp;": u"\u2003",
    "eng;": u"\u014b",
    "ensp;": u"\u2002",
    "eogon;": u"\u0119",
    "eopf;": u"\U0001d556",
    "epar;": u"\u22d5",
    "eparsl;": u"\u29e3",
    "eplus;": u"\u2a71",
    "epsi;": u"\u03b5",
    "epsilon;": u"\u03b5",
    "epsiv;": u"\u03f5",
    "eqcirc;": u"\u2256",
    "eqcolon;": u"\u2255",
    "eqsim;": u"\u2242",
    "eqslantgtr;": u"\u2a96",
    "eqslantless;": u"\u2a95",
    "equals;": u"=",
    "equest;": u"\u225f",
    "equiv;": u"\u2261",
    "equivDD;": u"\u2a78",
    "eqvparsl;": u"\u29e5",
    "erDot;": u"\u2253",
    "erarr;": u"\u2971",
    "escr;": u"\u212f",
    "esdot;": u"\u2250",
    "esim;": u"\u2242",
    "eta;": u"\u03b7",
    "eth": u"\xf0",
    "eth;": u"\xf0",
    "euml": u"\xeb",
    "euml;": u"\xeb",
    "euro;": u"\u20ac",
    "excl;": u"!",
    "exist;": u"\u2203",
    "expectation;": u"\u2130",
    "exponentiale;": u"\u2147",
    "fallingdotseq;": u"\u2252",
    "fcy;": u"\u0444",
    "female;": u"\u2640",
    "ffilig;": u"\ufb03",
    "fflig;": u"\ufb00",
    "ffllig;": u"\ufb04",
    "ffr;": u"\U0001d523",
    "filig;": u"\ufb01",
    "fjlig;": u"fj",
    "flat;": u"\u266d",
    "fllig;": u"\ufb02",
    "fltns;": u"\u25b1",
    "fnof;": u"\u0192",
    "fopf;": u"\U0001d557",
    "forall;": u"\u2200",
    "fork;": u"\u22d4",
    "forkv;": u"\u2ad9",
    "fpartint;": u"\u2a0d",
    "frac12": u"\xbd",
    "frac12;": u"\xbd",
    "frac13;": u"\u2153",
    "frac14": u"\xbc",
    "frac14;": u"\xbc",
    "frac15;": u"\u2155",
    "frac16;": u"\u2159",
    "frac18;": u"\u215b",
    "frac23;": u"\u2154",
    "frac25;": u"\u2156",
    "frac34": u"\xbe",
    "frac34;": u"\xbe",
    "frac35;": u"\u2157",
    "frac38;": u"\u215c",
    "frac45;": u"\u2158",
    "frac56;": u"\u215a",
    "frac58;": u"\u215d",
    "frac78;": u"\u215e",
    "frasl;": u"\u2044",
    "frown;": u"\u2322",
    "fscr;": u"\U0001d4bb",
    "gE;": u"\u2267",
    "gEl;": u"\u2a8c",
    "gacute;": u"\u01f5",
    "gamma;": u"\u03b3",
    "gammad;": u"\u03dd",
    "gap;": u"\u2a86",
    "gbreve;": u"\u011f",
    "gcirc;": u"\u011d",
    "gcy;": u"\u0433",
    "gdot;": u"\u0121",
    "ge;": u"\u2265",
    "gel;": u"\u22db",
    "geq;": u"\u2265",
    "geqq;": u"\u2267",
    "geqslant;": u"\u2a7e",
    "ges;": u"\u2a7e",
    "gescc;": u"\u2aa9",
    "gesdot;": u"\u2a80",
    "gesdoto;": u"\u2a82",
    "gesdotol;": u"\u2a84",
    "gesl;": u"\u22db\ufe00",
    "gesles;": u"\u2a94",
    "gfr;": u"\U0001d524",
    "gg;": u"\u226b",
    "ggg;": u"\u22d9",
    "gimel;": u"\u2137",
    "gjcy;": u"\u0453",
    "gl;": u"\u2277",
    "glE;": u"\u2a92",
    "gla;": u"\u2aa5",
    "glj;": u"\u2aa4",
    "gnE;": u"\u2269",
    "gnap;": u"\u2a8a",
    "gnapprox;": u"\u2a8a",
    "gne;": u"\u2a88",
    "gneq;": u"\u2a88",
    "gneqq;": u"\u2269",
    "gnsim;": u"\u22e7",
    "gopf;": u"\U0001d558",
    "grave;": u"`",
    "gscr;": u"\u210a",
    "gsim;": u"\u2273",
    "gsime;": u"\u2a8e",
    "gsiml;": u"\u2a90",
    "gt": u">",
    "gt;": u">",
    "gtcc;": u"\u2aa7",
    "gtcir;": u"\u2a7a",
    "gtdot;": u"\u22d7",
    "gtlPar;": u"\u2995",
    "gtquest;": u"\u2a7c",
    "gtrapprox;": u"\u2a86",
    "gtrarr;": u"\u2978",
    "gtrdot;": u"\u22d7",
    "gtreqless;": u"\u22db",
    "gtreqqless;": u"\u2a8c",
    "gtrless;": u"\u2277",
    "gtrsim;": u"\u2273",
    "gvertneqq;": u"\u2269\ufe00",
    "gvnE;": u"\u2269\ufe00",
    "hArr;": u"\u21d4",
    "hairsp;": u"\u200a",
    "half;": u"\xbd",
    "hamilt;": u"\u210b",
    "hardcy;": u"\u044a",
    "harr;": u"\u2194",
    "harrcir;": u"\u2948",
    "harrw;": u"\u21ad",
    "hbar;": u"\u210f",
    "hcirc;": u"\u0125",
    "hearts;": u"\u2665",
    "heartsuit;": u"\u2665",
    "hellip;": u"\u2026",
    "hercon;": u"\u22b9",
    "hfr;": u"\U0001d525",
    "hksearow;": u"\u2925",
    "hkswarow;": u"\u2926",
    "hoarr;": u"\u21ff",
    "homtht;": u"\u223b",
    "hookleftarrow;": u"\u21a9",
    "hookrightarrow;": u"\u21aa",
    "hopf;": u"\U0001d559",
    "horbar;": u"\u2015",
    "hscr;": u"\U0001d4bd",
    "hslash;": u"\u210f",
    "hstrok;": u"\u0127",
    "hybull;": u"\u2043",
    "hyphen;": u"\u2010",
    "iacute": u"\xed",
    "iacute;": u"\xed",
    "ic;": u"\u2063",
    "icirc": u"\xee",
    "icirc;": u"\xee",
    "icy;": u"\u0438",
    "iecy;": u"\u0435",
    "iexcl": u"\xa1",
    "iexcl;": u"\xa1",
    "iff;": u"\u21d4",
    "ifr;": u"\U0001d526",
    "igrave": u"\xec",
    "igrave;": u"\xec",
    "ii;": u"\u2148",
    "iiiint;": u"\u2a0c",
    "iiint;": u"\u222d",
    "iinfin;": u"\u29dc",
    "iiota;": u"\u2129",
    "ijlig;": u"\u0133",
    "imacr;": u"\u012b",
    "image;": u"\u2111",
    "imagline;": u"\u2110",
    "imagpart;": u"\u2111",
    "imath;": u"\u0131",
    "imof;": u"\u22b7",
    "imped;": u"\u01b5",
    "in;": u"\u2208",
    "incare;": u"\u2105",
    "infin;": u"\u221e",
    "infintie;": u"\u29dd",
    "inodot;": u"\u0131",
    "int;": u"\u222b",
    "intcal;": u"\u22ba",
    "integers;": u"\u2124",
    "intercal;": u"\u22ba",
    "intlarhk;": u"\u2a17",
    "intprod;": u"\u2a3c",
    "iocy;": u"\u0451",
    "iogon;": u"\u012f",
    "iopf;": u"\U0001d55a",
    "iota;": u"\u03b9",
    "iprod;": u"\u2a3c",
    "iquest": u"\xbf",
    "iquest;": u"\xbf",
    "iscr;": u"\U0001d4be",
    "isin;": u"\u2208",
    "isinE;": u"\u22f9",
    "isindot;": u"\u22f5",
    "isins;": u"\u22f4",
    "isinsv;": u"\u22f3",
    "isinv;": u"\u2208",
    "it;": u"\u2062",
    "itilde;": u"\u0129",
    "iukcy;": u"\u0456",
    "iuml": u"\xef",
    "iuml;": u"\xef",
    "jcirc;": u"\u0135",
    "jcy;": u"\u0439",
    "jfr;": u"\U0001d527",
    "jmath;": u"\u0237",
    "jopf;": u"\U0001d55b",
    "jscr;": u"\U0001d4bf",
    "jsercy;": u"\u0458",
    "jukcy;": u"\u0454",
    "kappa;": u"\u03ba",
    "kappav;": u"\u03f0",
    "kcedil;": u"\u0137",
    "kcy;": u"\u043a",
    "kfr;": u"\U0001d528",
    "kgreen;": u"\u0138",
    "khcy;": u"\u0445",
    "kjcy;": u"\u045c",
    "kopf;": u"\U0001d55c",
    "kscr;": u"\U0001d4c0",
    "lAarr;": u"\u21da",
    "lArr;": u"\u21d0",
    "lAtail;": u"\u291b",
    "lBarr;": u"\u290e",
    "lE;": u"\u2266",
    "lEg;": u"\u2a8b",
    "lHar;": u"\u2962",
    "lacute;": u"\u013a",
    "laemptyv;": u"\u29b4",
    "lagran;": u"\u2112",
    "lambda;": u"\u03bb",
    "lang;": u"\u27e8",
    "langd;": u"\u2991",
    "langle;": u"\u27e8",
    "lap;": u"\u2a85",
    "laquo": u"\xab",
    "laquo;": u"\xab",
    "larr;": u"\u2190",
    "larrb;": u"\u21e4",
    "larrbfs;": u"\u291f",
    "larrfs;": u"\u291d",
    "larrhk;": u"\u21a9",
    "larrlp;": u"\u21ab",
    "larrpl;": u"\u2939",
    "larrsim;": u"\u2973",
    "larrtl;": u"\u21a2",
    "lat;": u"\u2aab",
    "latail;": u"\u2919",
    "late;": u"\u2aad",
    "lates;": u"\u2aad\ufe00",
    "lbarr;": u"\u290c",
    "lbbrk;": u"\u2772",
    "lbrace;": u"{",
    "lbrack;": u"[",
    "lbrke;": u"\u298b",
    "lbrksld;": u"\u298f",
    "lbrkslu;": u"\u298d",
    "lcaron;": u"\u013e",
    "lcedil;": u"\u013c",
    "lceil;": u"\u2308",
    "lcub;": u"{",
    "lcy;": u"\u043b",
    "ldca;": u"\u2936",
    "ldquo;": u"\u201c",
    "ldquor;": u"\u201e",
    "ldrdhar;": u"\u2967",
    "ldrushar;": u"\u294b",
    "ldsh;": u"\u21b2",
    "le;": u"\u2264",
    "leftarrow;": u"\u2190",
    "leftarrowtail;": u"\u21a2",
    "leftharpoondown;": u"\u21bd",
    "leftharpoonup;": u"\u21bc",
    "leftleftarrows;": u"\u21c7",
    "leftrightarrow;": u"\u2194",
    "leftrightarrows;": u"\u21c6",
    "leftrightharpoons;": u"\u21cb",
    "leftrightsquigarrow;": u"\u21ad",
    "leftthreetimes;": u"\u22cb",
    "leg;": u"\u22da",
    "leq;": u"\u2264",
    "leqq;": u"\u2266",
    "leqslant;": u"\u2a7d",
    "les;": u"\u2a7d",
    "lescc;": u"\u2aa8",
    "lesdot;": u"\u2a7f",
    "lesdoto;": u"\u2a81",
    "lesdotor;": u"\u2a83",
    "lesg;": u"\u22da\ufe00",
    "lesges;": u"\u2a93",
    "lessapprox;": u"\u2a85",
    "lessdot;": u"\u22d6",
    "lesseqgtr;": u"\u22da",
    "lesseqqgtr;": u"\u2a8b",
    "lessgtr;": u"\u2276",
    "lesssim;": u"\u2272",
    "lfisht;": u"\u297c",
    "lfloor;": u"\u230a",
    "lfr;": u"\U0001d529",
    "lg;": u"\u2276",
    "lgE;": u"\u2a91",
    "lhard;": u"\u21bd",
    "lharu;": u"\u21bc",
    "lharul;": u"\u296a",
    "lhblk;": u"\u2584",
    "ljcy;": u"\u0459",
    "ll;": u"\u226a",
    "llarr;": u"\u21c7",
    "llcorner;": u"\u231e",
    "llhard;": u"\u296b",
    "lltri;": u"\u25fa",
    "lmidot;": u"\u0140",
    "lmoust;": u"\u23b0",
    "lmoustache;": u"\u23b0",
    "lnE;": u"\u2268",
    "lnap;": u"\u2a89",
    "lnapprox;": u"\u2a89",
    "lne;": u"\u2a87",
    "lneq;": u"\u2a87",
    "lneqq;": u"\u2268",
    "lnsim;": u"\u22e6",
    "loang;": u"\u27ec",
    "loarr;": u"\u21fd",
    "lobrk;": u"\u27e6",
    "longleftarrow;": u"\u27f5",
    "longleftrightarrow;": u"\u27f7",
    "longmapsto;": u"\u27fc",
    "longrightarrow;": u"\u27f6",
    "looparrowleft;": u"\u21ab",
    "looparrowright;": u"\u21ac",
    "lopar;": u"\u2985",
    "lopf;": u"\U0001d55d",
    "loplus;": u"\u2a2d",
    "lotimes;": u"\u2a34",
    "lowast;": u"\u2217",
    "lowbar;": u"_",
    "loz;": u"\u25ca",
    "lozenge;": u"\u25ca",
    "lozf;": u"\u29eb",
    "lpar;": u"(",
    "lparlt;": u"\u2993",
    "lrarr;": u"\u21c6",
    "lrcorner;": u"\u231f",
    "lrhar;": u"\u21cb",
    "lrhard;": u"\u296d",
    "lrm;": u"\u200e",
    "lrtri;": u"\u22bf",
    "lsaquo;": u"\u2039",
    "lscr;": u"\U0001d4c1",
    "lsh;": u"\u21b0",
    "lsim;": u"\u2272",
    "lsime;": u"\u2a8d",
    "lsimg;": u"\u2a8f",
    "lsqb;": u"[",
    "lsquo;": u"\u2018",
    "lsquor;": u"\u201a",
    "lstrok;": u"\u0142",
    "lt": u"<",
    "lt;": u"<",
    "ltcc;": u"\u2aa6",
    "ltcir;": u"\u2a79",
    "ltdot;": u"\u22d6",
    "lthree;": u"\u22cb",
    "ltimes;": u"\u22c9",
    "ltlarr;": u"\u2976",
    "ltquest;": u"\u2a7b",
    "ltrPar;": u"\u2996",
    "ltri;": u"\u25c3",
    "ltrie;": u"\u22b4",
    "ltrif;": u"\u25c2",
    "lurdshar;": u"\u294a",
    "luruhar;": u"\u2966",
    "lvertneqq;": u"\u2268\ufe00",
    "lvnE;": u"\u2268\ufe00",
    "mDDot;": u"\u223a",
    "macr": u"\xaf",
    "macr;": u"\xaf",
    "male;": u"\u2642",
    "malt;": u"\u2720",
    "maltese;": u"\u2720",
    "map;": u"\u21a6",
    "mapsto;": u"\u21a6",
    "mapstodown;": u"\u21a7",
    "mapstoleft;": u"\u21a4",
    "mapstoup;": u"\u21a5",
    "marker;": u"\u25ae",
    "mcomma;": u"\u2a29",
    "mcy;": u"\u043c",
    "mdash;": u"\u2014",
    "measuredangle;": u"\u2221",
    "mfr;": u"\U0001d52a",
    "mho;": u"\u2127",
    "micro": u"\xb5",
    "micro;": u"\xb5",
    "mid;": u"\u2223",
    "midast;": u"*",
    "midcir;": u"\u2af0",
    "middot": u"\xb7",
    "middot;": u"\xb7",
    "minus;": u"\u2212",
    "minusb;": u"\u229f",
    "minusd;": u"\u2238",
    "minusdu;": u"\u2a2a",
    "mlcp;": u"\u2adb",
    "mldr;": u"\u2026",
    "mnplus;": u"\u2213",
    "models;": u"\u22a7",
    "mopf;": u"\U0001d55e",
    "mp;": u"\u2213",
    "mscr;": u"\U0001d4c2",
    "mstpos;": u"\u223e",
    "mu;": u"\u03bc",
    "multimap;": u"\u22b8",
    "mumap;": u"\u22b8",
    "nGg;": u"\u22d9\u0338",
    "nGt;": u"\u226b\u20d2",
    "nGtv;": u"\u226b\u0338",
    "nLeftarrow;": u"\u21cd",
    "nLeftrightarrow;": u"\u21ce",
    "nLl;": u"\u22d8\u0338",
    "nLt;": u"\u226a\u20d2",
    "nLtv;": u"\u226a\u0338",
    "nRightarrow;": u"\u21cf",
    "nVDash;": u"\u22af",
    "nVdash;": u"\u22ae",
    "nabla;": u"\u2207",
    "nacute;": u"\u0144",
    "nang;": u"\u2220\u20d2",
    "nap;": u"\u2249",
    "napE;": u"\u2a70\u0338",
    "napid;": u"\u224b\u0338",
    "napos;": u"\u0149",
    "napprox;": u"\u2249",
    "natur;": u"\u266e",
    "natural;": u"\u266e",
    "naturals;": u"\u2115",
    "nbsp": u"\xa0",
    "nbsp;": u"\xa0",
    "nbump;": u"\u224e\u0338",
    "nbumpe;": u"\u224f\u0338",
    "ncap;": u"\u2a43",
    "ncaron;": u"\u0148",
    "ncedil;": u"\u0146",
    "ncong;": u"\u2247",
    "ncongdot;": u"\u2a6d\u0338",
    "ncup;": u"\u2a42",
    "ncy;": u"\u043d",
    "ndash;": u"\u2013",
    "ne;": u"\u2260",
    "neArr;": u"\u21d7",
    "nearhk;": u"\u2924",
    "nearr;": u"\u2197",
    "nearrow;": u"\u2197",
    "nedot;": u"\u2250\u0338",
    "nequiv;": u"\u2262",
    "nesear;": u"\u2928",
    "nesim;": u"\u2242\u0338",
    "nexist;": u"\u2204",
    "nexists;": u"\u2204",
    "nfr;": u"\U0001d52b",
    "ngE;": u"\u2267\u0338",
    "nge;": u"\u2271",
    "ngeq;": u"\u2271",
    "ngeqq;": u"\u2267\u0338",
    "ngeqslant;": u"\u2a7e\u0338",
    "nges;": u"\u2a7e\u0338",
    "ngsim;": u"\u2275",
    "ngt;": u"\u226f",
    "ngtr;": u"\u226f",
    "nhArr;": u"\u21ce",
    "nharr;": u"\u21ae",
    "nhpar;": u"\u2af2",
    "ni;": u"\u220b",
    "nis;": u"\u22fc",
    "nisd;": u"\u22fa",
    "niv;": u"\u220b",
    "njcy;": u"\u045a",
    "nlArr;": u"\u21cd",
    "nlE;": u"\u2266\u0338",
    "nlarr;": u"\u219a",
    "nldr;": u"\u2025",
    "nle;": u"\u2270",
    "nleftarrow;": u"\u219a",
    "nleftrightarrow;": u"\u21ae",
    "nleq;": u"\u2270",
    "nleqq;": u"\u2266\u0338",
    "nleqslant;": u"\u2a7d\u0338",
    "nles;": u"\u2a7d\u0338",
    "nless;": u"\u226e",
    "nlsim;": u"\u2274",
    "nlt;": u"\u226e",
    "nltri;": u"\u22ea",
    "nltrie;": u"\u22ec",
    "nmid;": u"\u2224",
    "nopf;": u"\U0001d55f",
    "not": u"\xac",
    "not;": u"\xac",
    "notin;": u"\u2209",
    "notinE;": u"\u22f9\u0338",
    "notindot;": u"\u22f5\u0338",
    "notinva;": u"\u2209",
    "notinvb;": u"\u22f7",
    "notinvc;": u"\u22f6",
    "notni;": u"\u220c",
    "notniva;": u"\u220c",
    "notnivb;": u"\u22fe",
    "notnivc;": u"\u22fd",
    "npar;": u"\u2226",
    "nparallel;": u"\u2226",
    "nparsl;": u"\u2afd\u20e5",
    "npart;": u"\u2202\u0338",
    "npolint;": u"\u2a14",
    "npr;": u"\u2280",
    "nprcue;": u"\u22e0",
    "npre;": u"\u2aaf\u0338",
    "nprec;": u"\u2280",
    "npreceq;": u"\u2aaf\u0338",
    "nrArr;": u"\u21cf",
    "nrarr;": u"\u219b",
    "nrarrc;": u"\u2933\u0338",
    "nrarrw;": u"\u219d\u0338",
    "nrightarrow;": u"\u219b",
    "nrtri;": u"\u22eb",
    "nrtrie;": u"\u22ed",
    "nsc;": u"\u2281",
    "nsccue;": u"\u22e1",
    "nsce;": u"\u2ab0\u0338",
    "nscr;": u"\U0001d4c3",
    "nshortmid;": u"\u2224",
    "nshortparallel;": u"\u2226",
    "nsim;": u"\u2241",
    "nsime;": u"\u2244",
    "nsimeq;": u"\u2244",
    "nsmid;": u"\u2224",
    "nspar;": u"\u2226",
    "nsqsube;": u"\u22e2",
    "nsqsupe;": u"\u22e3",
    "nsub;": u"\u2284",
    "nsubE;": u"\u2ac5\u0338",
    "nsube;": u"\u2288",
    "nsubset;": u"\u2282\u20d2",
    "nsubseteq;": u"\u2288",
    "nsubseteqq;": u"\u2ac5\u0338",
    "nsucc;": u"\u2281",
    "nsucceq;": u"\u2ab0\u0338",
    "nsup;": u"\u2285",
    "nsupE;": u"\u2ac6\u0338",
    "nsupe;": u"\u2289",
    "nsupset;": u"\u2283\u20d2",
    "nsupseteq;": u"\u2289",
    "nsupseteqq;": u"\u2ac6\u0338",
    "ntgl;": u"\u2279",
    "ntilde": u"\xf1",
    "ntilde;": u"\xf1",
    "ntlg;": u"\u2278",
    "ntriangleleft;": u"\u22ea",
    "ntrianglelefteq;": u"\u22ec",
    "ntriangleright;": u"\u22eb",
    "ntrianglerighteq;": u"\u22ed",
    "nu;": u"\u03bd",
    "num;": u"#",
    "numero;": u"\u2116",
    "numsp;": u"\u2007",
    "nvDash;": u"\u22ad",
    "nvHarr;": u"\u2904",
    "nvap;": u"\u224d\u20d2",
    "nvdash;": u"\u22ac",
    "nvge;": u"\u2265\u20d2",
    "nvgt;": u">\u20d2",
    "nvinfin;": u"\u29de",
    "nvlArr;": u"\u2902",
    "nvle;": u"\u2264\u20d2",
    "nvlt;": u"<\u20d2",
    "nvltrie;": u"\u22b4\u20d2",
    "nvrArr;": u"\u2903",
    "nvrtrie;": u"\u22b5\u20d2",
    "nvsim;": u"\u223c\u20d2",
    "nwArr;": u"\u21d6",
    "nwarhk;": u"\u2923",
    "nwarr;": u"\u2196",
    "nwarrow;": u"\u2196",
    "nwnear;": u"\u2927",
    "oS;": u"\u24c8",
    "oacute": u"\xf3",
    "oacute;": u"\xf3",
    "oast;": u"\u229b",
    "ocir;": u"\u229a",
    "ocirc": u"\xf4",
    "ocirc;": u"\xf4",
    "ocy;": u"\u043e",
    "odash;": u"\u229d",
    "odblac;": u"\u0151",
    "odiv;": u"\u2a38",
    "odot;": u"\u2299",
    "odsold;": u"\u29bc",
    "oelig;": u"\u0153",
    "ofcir;": u"\u29bf",
    "ofr;": u"\U0001d52c",
    "ogon;": u"\u02db",
    "ograve": u"\xf2",
    "ograve;": u"\xf2",
    "ogt;": u"\u29c1",
    "ohbar;": u"\u29b5",
    "ohm;": u"\u03a9",
    "oint;": u"\u222e",
    "olarr;": u"\u21ba",
    "olcir;": u"\u29be",
    "olcross;": u"\u29bb",
    "oline;": u"\u203e",
    "olt;": u"\u29c0",
    "omacr;": u"\u014d",
    "omega;": u"\u03c9",
    "omicron;": u"\u03bf",
    "omid;": u"\u29b6",
    "ominus;": u"\u2296",
    "oopf;": u"\U0001d560",
    "opar;": u"\u29b7",
    "operp;": u"\u29b9",
    "oplus;": u"\u2295",
    "or;": u"\u2228",
    "orarr;": u"\u21bb",
    "ord;": u"\u2a5d",
    "order;": u"\u2134",
    "orderof;": u"\u2134",
    "ordf": u"\xaa",
    "ordf;": u"\xaa",
    "ordm": u"\xba",
    "ordm;": u"\xba",
    "origof;": u"\u22b6",
    "oror;": u"\u2a56",
    "orslope;": u"\u2a57",
    "orv;": u"\u2a5b",
    "oscr;": u"\u2134",
    "oslash": u"\xf8",
    "oslash;": u"\xf8",
    "osol;": u"\u2298",
    "otilde": u"\xf5",
    "otilde;": u"\xf5",
    "otimes;": u"\u2297",
    "otimesas;": u"\u2a36",
    "ouml": u"\xf6",
    "ouml;": u"\xf6",
    "ovbar;": u"\u233d",
    "par;": u"\u2225",
    "para": u"\xb6",
    "para;": u"\xb6",
    "parallel;": u"\u2225",
    "parsim;": u"\u2af3",
    "parsl;": u"\u2afd",
    "part;": u"\u2202",
    "pcy;": u"\u043f",
    "percnt;": u"%",
    "period;": u".",
    "permil;": u"\u2030",
    "perp;": u"\u22a5",
    "pertenk;": u"\u2031",
    "pfr;": u"\U0001d52d",
    "phi;": u"\u03c6",
    "phiv;": u"\u03d5",
    "phmmat;": u"\u2133",
    "phone;": u"\u260e",
    "pi;": u"\u03c0",
    "pitchfork;": u"\u22d4",
    "piv;": u"\u03d6",
    "planck;": u"\u210f",
    "planckh;": u"\u210e",
    "plankv;": u"\u210f",
    "plus;": u"+",
    "plusacir;": u"\u2a23",
    "plusb;": u"\u229e",
    "pluscir;": u"\u2a22",
    "plusdo;": u"\u2214",
    "plusdu;": u"\u2a25",
    "pluse;": u"\u2a72",
    "plusmn": u"\xb1",
    "plusmn;": u"\xb1",
    "plussim;": u"\u2a26",
    "plustwo;": u"\u2a27",
    "pm;": u"\xb1",
    "pointint;": u"\u2a15",
    "popf;": u"\U0001d561",
    "pound": u"\xa3",
    "pound;": u"\xa3",
    "pr;": u"\u227a",
    "prE;": u"\u2ab3",
    "prap;": u"\u2ab7",
    "prcue;": u"\u227c",
    "pre;": u"\u2aaf",
    "prec;": u"\u227a",
    "precapprox;": u"\u2ab7",
    "preccurlyeq;": u"\u227c",
    "preceq;": u"\u2aaf",
    "precnapprox;": u"\u2ab9",
    "precneqq;": u"\u2ab5",
    "precnsim;": u"\u22e8",
    "precsim;": u"\u227e",
    "prime;": u"\u2032",
    "primes;": u"\u2119",
    "prnE;": u"\u2ab5",
    "prnap;": u"\u2ab9",
    "prnsim;": u"\u22e8",
    "prod;": u"\u220f",
    "profalar;": u"\u232e",
    "profline;": u"\u2312",
    "profsurf;": u"\u2313",
    "prop;": u"\u221d",
    "propto;": u"\u221d",
    "prsim;": u"\u227e",
    "prurel;": u"\u22b0",
    "pscr;": u"\U0001d4c5",
    "psi;": u"\u03c8",
    "puncsp;": u"\u2008",
    "qfr;": u"\U0001d52e",
    "qint;": u"\u2a0c",
    "qopf;": u"\U0001d562",
    "qprime;": u"\u2057",
    "qscr;": u"\U0001d4c6",
    "quaternions;": u"\u210d",
    "quatint;": u"\u2a16",
    "quest;": u"?",
    "questeq;": u"\u225f",
    "quot": u"\"",
    "quot;": u"\"",
    "rAarr;": u"\u21db",
    "rArr;": u"\u21d2",
    "rAtail;": u"\u291c",
    "rBarr;": u"\u290f",
    "rHar;": u"\u2964",
    "race;": u"\u223d\u0331",
    "racute;": u"\u0155",
    "radic;": u"\u221a",
    "raemptyv;": u"\u29b3",
    "rang;": u"\u27e9",
    "rangd;": u"\u2992",
    "range;": u"\u29a5",
    "rangle;": u"\u27e9",
    "raquo": u"\xbb",
    "raquo;": u"\xbb",
    "rarr;": u"\u2192",
    "rarrap;": u"\u2975",
    "rarrb;": u"\u21e5",
    "rarrbfs;": u"\u2920",
    "rarrc;": u"\u2933",
    "rarrfs;": u"\u291e",
    "rarrhk;": u"\u21aa",
    "rarrlp;": u"\u21ac",
    "rarrpl;": u"\u2945",
    "rarrsim;": u"\u2974",
    "rarrtl;": u"\u21a3",
    "rarrw;": u"\u219d",
    "ratail;": u"\u291a",
    "ratio;": u"\u2236",
    "rationals;": u"\u211a",
    "rbarr;": u"\u290d",
    "rbbrk;": u"\u2773",
    "rbrace;": u"}",
    "rbrack;": u"]",
    "rbrke;": u"\u298c",
    "rbrksld;": u"\u298e",
    "rbrkslu;": u"\u2990",
    "rcaron;": u"\u0159",
    "rcedil;": u"\u0157",
    "rceil;": u"\u2309",
    "rcub;": u"}",
    "rcy;": u"\u0440",
    "rdca;": u"\u2937",
    "rdldhar;": u"\u2969",
    "rdquo;": u"\u201d",
    "rdquor;": u"\u201d",
    "rdsh;": u"\u21b3",
    "real;": u"\u211c",
    "realine;": u"\u211b",
    "realpart;": u"\u211c",
    "reals;": u"\u211d",
    "rect;": u"\u25ad",
    "reg": u"\xae",
    "reg;": u"\xae",
    "rfisht;": u"\u297d",
    "rfloor;": u"\u230b",
    "rfr;": u"\U0001d52f",
    "rhard;": u"\u21c1",
    "rharu;": u"\u21c0",
    "rharul;": u"\u296c",
    "rho;": u"\u03c1",
    "rhov;": u"\u03f1",
    "rightarrow;": u"\u2192",
    "rightarrowtail;": u"\u21a3",
    "rightharpoondown;": u"\u21c1",
    "rightharpoonup;": u"\u21c0",
    "rightleftarrows;": u"\u21c4",
    "rightleftharpoons;": u"\u21cc",
    "rightrightarrows;": u"\u21c9",
    "rightsquigarrow;": u"\u219d",
    "rightthreetimes;": u"\u22cc",
    "ring;": u"\u02da",
    "risingdotseq;": u"\u2253",
    "rlarr;": u"\u21c4",
    "rlhar;": u"\u21cc",
    "rlm;": u"\u200f",
    "rmoust;": u"\u23b1",
    "rmoustache;": u"\u23b1",
    "rnmid;": u"\u2aee",
    "roang;": u"\u27ed",
    "roarr;": u"\u21fe",
    "robrk;": u"\u27e7",
    "ropar;": u"\u2986",
    "ropf;": u"\U0001d563",
    "roplus;": u"\u2a2e",
    "rotimes;": u"\u2a35",
    "rpar;": u")",
    "rpargt;": u"\u2994",
    "rppolint;": u"\u2a12",
    "rrarr;": u"\u21c9",
    "rsaquo;": u"\u203a",
    "rscr;": u"\U0001d4c7",
    "rsh;": u"\u21b1",
    "rsqb;": u"]",
    "rsquo;": u"\u2019",
    "rsquor;": u"\u2019",
    "rthree;": u"\u22cc",
    "rtimes;": u"\u22ca",
    "rtri;": u"\u25b9",
    "rtrie;": u"\u22b5",
    "rtrif;": u"\u25b8",
    "rtriltri;": u"\u29ce",
    "ruluhar;": u"\u2968",
    "rx;": u"\u211e",
    "sacute;": u"\u015b",
    "sbquo;": u"\u201a",
    "sc;": u"\u227b",
    "scE;": u"\u2ab4",
    "scap;": u"\u2ab8",
    "scaron;": u"\u0161",
    "sccue;": u"\u227d",
    "sce;": u"\u2ab0",
    "scedil;": u"\u015f",
    "scirc;": u"\u015d",
    "scnE;": u"\u2ab6",
    "scnap;": u"\u2aba",
    "scnsim;": u"\u22e9",
    "scpolint;": u"\u2a13",
    "scsim;": u"\u227f",
    "scy;": u"\u0441",
    "sdot;": u"\u22c5",
    "sdotb;": u"\u22a1",
    "sdote;": u"\u2a66",
    "seArr;": u"\u21d8",
    "searhk;": u"\u2925",
    "searr;": u"\u2198",
    "searrow;": u"\u2198",
    "sect": u"\xa7",
    "sect;": u"\xa7",
    "semi;": u";",
    "seswar;": u"\u2929",
    "setminus;": u"\u2216",
    "setmn;": u"\u2216",
    "sext;": u"\u2736",
    "sfr;": u"\U0001d530",
    "sfrown;": u"\u2322",
    "sharp;": u"\u266f",
    "shchcy;": u"\u0449",
    "shcy;": u"\u0448",
    "shortmid;": u"\u2223",
    "shortparallel;": u"\u2225",
    "shy": u"\xad",
    "shy;": u"\xad",
    "sigma;": u"\u03c3",
    "sigmaf;": u"\u03c2",
    "sigmav;": u"\u03c2",
    "sim;": u"\u223c",
    "simdot;": u"\u2a6a",
    "sime;": u"\u2243",
    "simeq;": u"\u2243",
    "simg;": u"\u2a9e",
    "simgE;": u"\u2aa0",
    "siml;": u"\u2a9d",
    "simlE;": u"\u2a9f",
    "simne;": u"\u2246",
    "simplus;": u"\u2a24",
    "simrarr;": u"\u2972",
    "slarr;": u"\u2190",
    "smallsetminus;": u"\u2216",
    "smashp;": u"\u2a33",
    "smeparsl;": u"\u29e4",
    "smid;": u"\u2223",
    "smile;": u"\u2323",
    "smt;": u"\u2aaa",
    "smte;": u"\u2aac",
    "smtes;": u"\u2aac\ufe00",
    "softcy;": u"\u044c",
    "sol;": u"/",
    "solb;": u"\u29c4",
    "solbar;": u"\u233f",
    "sopf;": u"\U0001d564",
    "spades;": u"\u2660",
    "spadesuit;": u"\u2660",
    "spar;": u"\u2225",
    "sqcap;": u"\u2293",
    "sqcaps;": u"\u2293\ufe00",
    "sqcup;": u"\u2294",
    "sqcups;": u"\u2294\ufe00",
    "sqsub;": u"\u228f",
    "sqsube;": u"\u2291",
    "sqsubset;": u"\u228f",
    "sqsubseteq;": u"\u2291",
    "sqsup;": u"\u2290",
    "sqsupe;": u"\u2292",
    "sqsupset;": u"\u2290",
    "sqsupseteq;": u"\u2292",
    "squ;": u"\u25a1",
    "square;": u"\u25a1",
    "squarf;": u"\u25aa",
    "squf;": u"\u25aa",
    "srarr;": u"\u2192",
    "sscr;": u"\U0001d4c8",
    "ssetmn;": u"\u2216",
    "ssmile;": u"\u2323",
    "sstarf;": u"\u22c6",
    "star;": u"\u2606",
    "starf;": u"\u2605",
    "straightepsilon;": u"\u03f5",
    "straightphi;": u"\u03d5",
    "strns;": u"\xaf",
    "sub;": u"\u2282",
    "subE;": u"\u2ac5",
    "subdot;": u"\u2abd",
    "sube;": u"\u2286",
    "subedot;": u"\u2ac3",
    "submult;": u"\u2ac1",
    "subnE;": u"\u2acb",
    "subne;": u"\u228a",
    "subplus;": u"\u2abf",
    "subrarr;": u"\u2979",
    "subset;": u"\u2282",
    "subseteq;": u"\u2286",
    "subseteqq;": u"\u2ac5",
    "subsetneq;": u"\u228a",
    "subsetneqq;": u"\u2acb",
    "subsim;": u"\u2ac7",
    "subsub;": u"\u2ad5",
    "subsup;": u"\u2ad3",
    "succ;": u"\u227b",
    "succapprox;": u"\u2ab8",
    "succcurlyeq;": u"\u227d",
    "succeq;": u"\u2ab0",
    "succnapprox;": u"\u2aba",
    "succneqq;": u"\u2ab6",
    "succnsim;": u"\u22e9",
    "succsim;": u"\u227f",
    "sum;": u"\u2211",
    "sung;": u"\u266a",
    "sup1": u"\xb9",
    "sup1;": u"\xb9",
    "sup2": u"\xb2",
    "sup2;": u"\xb2",
    "sup3": u"\xb3",
    "sup3;": u"\xb3",
    "sup;": u"\u2283",
    "supE;": u"\u2ac6",
    "supdot;": u"\u2abe",
    "supdsub;": u"\u2ad8",
    "supe;": u"\u2287",
    "supedot;": u"\u2ac4",
    "suphsol;": u"\u27c9",
    "suphsub;": u"\u2ad7",
    "suplarr;": u"\u297b",
    "supmult;": u"\u2ac2",
    "supnE;": u"\u2acc",
    "supne;": u"\u228b",
    "supplus;": u"\u2ac0",
    "supset;": u"\u2283",
    "supseteq;": u"\u2287",
    "supseteqq;": u"\u2ac6",
    "supsetneq;": u"\u228b",
    "supsetneqq;": u"\u2acc",
    "supsim;": u"\u2ac8",
    "supsub;": u"\u2ad4",
    "supsup;": u"\u2ad6",
    "swArr;": u"\u21d9",
    "swarhk;": u"\u2926",
    "swarr;": u"\u2199",
    "swarrow;": u"\u2199",
    "swnwar;": u"\u292a",
    "szlig": u"\xdf",
    "szlig;": u"\xdf",
    "target;": u"\u2316",
    "tau;": u"\u03c4",
    "tbrk;": u"\u23b4",
    "tcaron;": u"\u0165",
    "tcedil;": u"\u0163",
    "tcy;": u"\u0442",
    "tdot;": u"\u20db",
    "telrec;": u"\u2315",
    "tfr;": u"\U0001d531",
    "there4;": u"\u2234",
    "therefore;": u"\u2234",
    "theta;": u"\u03b8",
    "thetasym;": u"\u03d1",
    "thetav;": u"\u03d1",
    "thickapprox;": u"\u2248",
    "thicksim;": u"\u223c",
    "thinsp;": u"\u2009",
    "thkap;": u"\u2248",
    "thksim;": u"\u223c",
    "thorn": u"\xfe",
    "thorn;": u"\xfe",
    "tilde;": u"\u02dc",
    "times": u"\xd7",
    "times;": u"\xd7",
    "timesb;": u"\u22a0",
    "timesbar;": u"\u2a31",
    "timesd;": u"\u2a30",
    "tint;": u"\u222d",
    "toea;": u"\u2928",
    "top;": u"\u22a4",
    "topbot;": u"\u2336",
    "topcir;": u"\u2af1",
    "topf;": u"\U0001d565",
    "topfork;": u"\u2ada",
    "tosa;": u"\u2929",
    "tprime;": u"\u2034",
    "trade;": u"\u2122",
    "triangle;": u"\u25b5",
    "triangledown;": u"\u25bf",
    "triangleleft;": u"\u25c3",
    "trianglelefteq;": u"\u22b4",
    "triangleq;": u"\u225c",
    "triangleright;": u"\u25b9",
    "trianglerighteq;": u"\u22b5",
    "tridot;": u"\u25ec",
    "trie;": u"\u225c",
    "triminus;": u"\u2a3a",
    "triplus;": u"\u2a39",
    "trisb;": u"\u29cd",
    "tritime;": u"\u2a3b",
    "trpezium;": u"\u23e2",
    "tscr;": u"\U0001d4c9",
    "tscy;": u"\u0446",
    "tshcy;": u"\u045b",
    "tstrok;": u"\u0167",
    "twixt;": u"\u226c",
    "twoheadleftarrow;": u"\u219e",
    "twoheadrightarrow;": u"\u21a0",
    "uArr;": u"\u21d1",
    "uHar;": u"\u2963",
    "uacute": u"\xfa",
    "uacute;": u"\xfa",
    "uarr;": u"\u2191",
    "ubrcy;": u"\u045e",
    "ubreve;": u"\u016d",
    "ucirc": u"\xfb",
    "ucirc;": u"\xfb",
    "ucy;": u"\u0443",
    "udarr;": u"\u21c5",
    "udblac;": u"\u0171",
    "udhar;": u"\u296e",
    "ufisht;": u"\u297e",
    "ufr;": u"\U0001d532",
    "ugrave": u"\xf9",
    "ugrave;": u"\xf9",
    "uharl;": u"\u21bf",
    "uharr;": u"\u21be",
    "uhblk;": u"\u2580",
    "ulcorn;": u"\u231c",
    "ulcorner;": u"\u231c",
    "ulcrop;": u"\u230f",
    "ultri;": u"\u25f8",
    "umacr;": u"\u016b",
    "uml": u"\xa8",
    "uml;": u"\xa8",
    "uogon;": u"\u0173",
    "uopf;": u"\U0001d566",
    "uparrow;": u"\u2191",
    "updownarrow;": u"\u2195",
    "upharpoonleft;": u"\u21bf",
    "upharpoonright;": u"\u21be",
    "uplus;": u"\u228e",
    "upsi;": u"\u03c5",
    "upsih;": u"\u03d2",
    "upsilon;": u"\u03c5",
    "upuparrows;": u"\u21c8",
    "urcorn;": u"\u231d",
    "urcorner;": u"\u231d",
    "urcrop;": u"\u230e",
    "uring;": u"\u016f",
    "urtri;": u"\u25f9",
    "uscr;": u"\U0001d4ca",
    "utdot;": u"\u22f0",
    "utilde;": u"\u0169",
    "utri;": u"\u25b5",
    "utrif;": u"\u25b4",
    "uuarr;": u"\u21c8",
    "uuml": u"\xfc",
    "uuml;": u"\xfc",
    "uwangle;": u"\u29a7",
    "vArr;": u"\u21d5",
    "vBar;": u"\u2ae8",
    "vBarv;": u"\u2ae9",
    "vDash;": u"\u22a8",
    "vangrt;": u"\u299c",
    "varepsilon;": u"\u03f5",
    "varkappa;": u"\u03f0",
    "varnothing;": u"\u2205",
    "varphi;": u"\u03d5",
    "varpi;": u"\u03d6",
    "varpropto;": u"\u221d",
    "varr;": u"\u2195",
    "varrho;": u"\u03f1",
    "varsigma;": u"\u03c2",
    "varsubsetneq;": u"\u228a\ufe00",
    "varsubsetneqq;": u"\u2acb\ufe00",
    "varsupsetneq;": u"\u228b\ufe00",
    "varsupsetneqq;": u"\u2acc\ufe00",
    "vartheta;": u"\u03d1",
    "vartriangleleft;": u"\u22b2",
    "vartriangleright;": u"\u22b3",
    "vcy;": u"\u0432",
    "vdash;": u"\u22a2",
    "vee;": u"\u2228",
    "veebar;": u"\u22bb",
    "veeeq;": u"\u225a",
    "vellip;": u"\u22ee",
    "verbar;": u"|",
    "vert;": u"|",
    "vfr;": u"\U0001d533",
    "vltri;": u"\u22b2",
    "vnsub;": u"\u2282\u20d2",
    "vnsup;": u"\u2283\u20d2",
    "vopf;": u"\U0001d567",
    "vprop;": u"\u221d",
    "vrtri;": u"\u22b3",
    "vscr;": u"\U0001d4cb",
    "vsubnE;": u"\u2acb\ufe00",
    "vsubne;": u"\u228a\ufe00",
    "vsupnE;": u"\u2acc\ufe00",
    "vsupne;": u"\u228b\ufe00",
    "vzigzag;": u"\u299a",
    "wcirc;": u"\u0175",
    "wedbar;": u"\u2a5f",
    "wedge;": u"\u2227",
    "wedgeq;": u"\u2259",
    "weierp;": u"\u2118",
    "wfr;": u"\U0001d534",
    "wopf;": u"\U0001d568",
    "wp;": u"\u2118",
    "wr;": u"\u2240",
    "wreath;": u"\u2240",
    "wscr;": u"\U0001d4cc",
    "xcap;": u"\u22c2",
    "xcirc;": u"\u25ef",
    "xcup;": u"\u22c3",
    "xdtri;": u"\u25bd",
    "xfr;": u"\U0001d535",
    "xhArr;": u"\u27fa",
    "xharr;": u"\u27f7",
    "xi;": u"\u03be",
    "xlArr;": u"\u27f8",
    "xlarr;": u"\u27f5",
    "xmap;": u"\u27fc",
    "xnis;": u"\u22fb",
    "xodot;": u"\u2a00",
    "xopf;": u"\U0001d569",
    "xoplus;": u"\u2a01",
    "xotime;": u"\u2a02",
    "xrArr;": u"\u27f9",
    "xrarr;": u"\u27f6",
    "xscr;": u"\U0001d4cd",
    "xsqcup;": u"\u2a06",
    "xuplus;": u"\u2a04",
    "xutri;": u"\u25b3",
    "xvee;": u"\u22c1",
    "xwedge;": u"\u22c0",
    "yacute": u"\xfd",
    "yacute;": u"\xfd",
    "yacy;": u"\u044f",
    "ycirc;": u"\u0177",
    "ycy;": u"\u044b",
    "yen": u"\xa5",
    "yen;": u"\xa5",
    "yfr;": u"\U0001d536",
    "yicy;": u"\u0457",
    "yopf;": u"\U0001d56a",
    "yscr;": u"\U0001d4ce",
    "yucy;": u"\u044e",
    "yuml": u"\xff",
    "yuml;": u"\xff",
    "zacute;": u"\u017a",
    "zcaron;": u"\u017e",
    "zcy;": u"\u0437",
    "zdot;": u"\u017c",
    "zeetrf;": u"\u2128",
    "zeta;": u"\u03b6",
    "zfr;": u"\U0001d537",
    "zhcy;": u"\u0436",
    "zigrarr;": u"\u21dd",
    "zopf;": u"\U0001d56b",
    "zscr;": u"\U0001d4cf",
    "zwj;": u"\u200d",
    "zwnj;": u"\u200c",
}

replacementCharacters = {
    0x0:u"\uFFFD",
    0x0d:u"\u000D",
    0x80:u"\u20AC",
    0x81:u"\u0081",
    0x81:u"\u0081",
    0x82:u"\u201A",
    0x83:u"\u0192",
    0x84:u"\u201E",
    0x85:u"\u2026",
    0x86:u"\u2020",
    0x87:u"\u2021",
    0x88:u"\u02C6",
    0x89:u"\u2030",
    0x8A:u"\u0160",
    0x8B:u"\u2039",
    0x8C:u"\u0152",
    0x8D:u"\u008D",
    0x8E:u"\u017D",
    0x8F:u"\u008F",
    0x90:u"\u0090",
    0x91:u"\u2018",
    0x92:u"\u2019",
    0x93:u"\u201C",
    0x94:u"\u201D",
    0x95:u"\u2022",
    0x96:u"\u2013",
    0x97:u"\u2014",
    0x98:u"\u02DC",
    0x99:u"\u2122",
    0x9A:u"\u0161",
    0x9B:u"\u203A",
    0x9C:u"\u0153",
    0x9D:u"\u009D",
    0x9E:u"\u017E",
    0x9F:u"\u0178",
}

encodings = {
    '437': 'cp437',
    '850': 'cp850',
    '852': 'cp852',
    '855': 'cp855',
    '857': 'cp857',
    '860': 'cp860',
    '861': 'cp861',
    '862': 'cp862',
    '863': 'cp863',
    '865': 'cp865',
    '866': 'cp866',
    '869': 'cp869',
    'ansix341968': 'ascii',
    'ansix341986': 'ascii',
    'arabic': 'iso8859-6',
    'ascii': 'ascii',
    'asmo708': 'iso8859-6',
    'big5': 'big5',
    'big5hkscs': 'big5hkscs',
    'chinese': 'gbk',
    'cp037': 'cp037',
    'cp1026': 'cp1026',
    'cp154': 'ptcp154',
    'cp367': 'ascii',
    'cp424': 'cp424',
    'cp437': 'cp437',
    'cp500': 'cp500',
    'cp775': 'cp775',
    'cp819': 'windows-1252',
    'cp850': 'cp850',
    'cp852': 'cp852',
    'cp855': 'cp855',
    'cp857': 'cp857',
    'cp860': 'cp860',
    'cp861': 'cp861',
    'cp862': 'cp862',
    'cp863': 'cp863',
    'cp864': 'cp864',
    'cp865': 'cp865',
    'cp866': 'cp866',
    'cp869': 'cp869',
    'cp936': 'gbk',
    'cpgr': 'cp869',
    'cpis': 'cp861',
    'csascii': 'ascii',
    'csbig5': 'big5',
    'cseuckr': 'cp949',
    'cseucpkdfmtjapanese': 'euc_jp',
    'csgb2312': 'gbk',
    'cshproman8': 'hp-roman8',
    'csibm037': 'cp037',
    'csibm1026': 'cp1026',
    'csibm424': 'cp424',
    'csibm500': 'cp500',
    'csibm855': 'cp855',
    'csibm857': 'cp857',
    'csibm860': 'cp860',
    'csibm861': 'cp861',
    'csibm863': 'cp863',
    'csibm864': 'cp864',
    'csibm865': 'cp865',
    'csibm866': 'cp866',
    'csibm869': 'cp869',
    'csiso2022jp': 'iso2022_jp',
    'csiso2022jp2': 'iso2022_jp_2',
    'csiso2022kr': 'iso2022_kr',
    'csiso58gb231280': 'gbk',
    'csisolatin1': 'windows-1252',
    'csisolatin2': 'iso8859-2',
    'csisolatin3': 'iso8859-3',
    'csisolatin4': 'iso8859-4',
    'csisolatin5': 'windows-1254',
    'csisolatin6': 'iso8859-10',
    'csisolatinarabic': 'iso8859-6',
    'csisolatincyrillic': 'iso8859-5',
    'csisolatingreek': 'iso8859-7',
    'csisolatinhebrew': 'iso8859-8',
    'cskoi8r': 'koi8-r',
    'csksc56011987': 'cp949',
    'cspc775baltic': 'cp775',
    'cspc850multilingual': 'cp850',
    'cspc862latinhebrew': 'cp862',
    'cspc8codepage437': 'cp437',
    'cspcp852': 'cp852',
    'csptcp154': 'ptcp154',
    'csshiftjis': 'shift_jis',
    'csunicode11utf7': 'utf-7',
    'cyrillic': 'iso8859-5',
    'cyrillicasian': 'ptcp154',
    'ebcdiccpbe': 'cp500',
    'ebcdiccpca': 'cp037',
    'ebcdiccpch': 'cp500',
    'ebcdiccphe': 'cp424',
    'ebcdiccpnl': 'cp037',
    'ebcdiccpus': 'cp037',
    'ebcdiccpwt': 'cp037',
    'ecma114': 'iso8859-6',
    'ecma118': 'iso8859-7',
    'elot928': 'iso8859-7',
    'eucjp': 'euc_jp',
    'euckr': 'cp949',
    'extendedunixcodepackedformatforjapanese': 'euc_jp',
    'gb18030': 'gb18030',
    'gb2312': 'gbk',
    'gb231280': 'gbk',
    'gbk': 'gbk',
    'greek': 'iso8859-7',
    'greek8': 'iso8859-7',
    'hebrew': 'iso8859-8',
    'hproman8': 'hp-roman8',
    'hzgb2312': 'hz',
    'ibm037': 'cp037',
    'ibm1026': 'cp1026',
    'ibm367': 'ascii',
    'ibm424': 'cp424',
    'ibm437': 'cp437',
    'ibm500': 'cp500',
    'ibm775': 'cp775',
    'ibm819': 'windows-1252',
    'ibm850': 'cp850',
    'ibm852': 'cp852',
    'ibm855': 'cp855',
    'ibm857': 'cp857',
    'ibm860': 'cp860',
    'ibm861': 'cp861',
    'ibm862': 'cp862',
    'ibm863': 'cp863',
    'ibm864': 'cp864',
    'ibm865': 'cp865',
    'ibm866': 'cp866',
    'ibm869': 'cp869',
    'iso2022jp': 'iso2022_jp',
    'iso2022jp2': 'iso2022_jp_2',
    'iso2022kr': 'iso2022_kr',
    'iso646irv1991': 'ascii',
    'iso646us': 'ascii',
    'iso88591': 'windows-1252',
    'iso885910': 'iso8859-10',
    'iso8859101992': 'iso8859-10',
    'iso885911987': 'windows-1252',
    'iso885913': 'iso8859-13',
    'iso885914': 'iso8859-14',
    'iso8859141998': 'iso8859-14',
    'iso885915': 'iso8859-15',
    'iso885916': 'iso8859-16',
    'iso8859162001': 'iso8859-16',
    'iso88592': 'iso8859-2',
    'iso885921987': 'iso8859-2',
    'iso88593': 'iso8859-3',
    'iso885931988': 'iso8859-3',
    'iso88594': 'iso8859-4',
    'iso885941988': 'iso8859-4',
    'iso88595': 'iso8859-5',
    'iso885951988': 'iso8859-5',
    'iso88596': 'iso8859-6',
    'iso885961987': 'iso8859-6',
    'iso88597': 'iso8859-7',
    'iso885971987': 'iso8859-7',
    'iso88598': 'iso8859-8',
    'iso885981988': 'iso8859-8',
    'iso88599': 'windows-1254',
    'iso885991989': 'windows-1254',
    'isoceltic': 'iso8859-14',
    'isoir100': 'windows-1252',
    'isoir101': 'iso8859-2',
    'isoir109': 'iso8859-3',
    'isoir110': 'iso8859-4',
    'isoir126': 'iso8859-7',
    'isoir127': 'iso8859-6',
    'isoir138': 'iso8859-8',
    'isoir144': 'iso8859-5',
    'isoir148': 'windows-1254',
    'isoir149': 'cp949',
    'isoir157': 'iso8859-10',
    'isoir199': 'iso8859-14',
    'isoir226': 'iso8859-16',
    'isoir58': 'gbk',
    'isoir6': 'ascii',
    'koi8r': 'koi8-r',
    'koi8u': 'koi8-u',
    'korean': 'cp949',
    'ksc5601': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'l1': 'windows-1252',
    'l10': 'iso8859-16',
    'l2': 'iso8859-2',
    'l3': 'iso8859-3',
    'l4': 'iso8859-4',
    'l5': 'windows-1254',
    'l6': 'iso8859-10',
    'l8': 'iso8859-14',
    'latin1': 'windows-1252',
    'latin10': 'iso8859-16',
    'latin2': 'iso8859-2',
    'latin3': 'iso8859-3',
    'latin4': 'iso8859-4',
    'latin5': 'windows-1254',
    'latin6': 'iso8859-10',
    'latin8': 'iso8859-14',
    'latin9': 'iso8859-15',
    'ms936': 'gbk',
    'mskanji': 'shift_jis',
    'pt154': 'ptcp154',
    'ptcp154': 'ptcp154',
    'r8': 'hp-roman8',
    'roman8': 'hp-roman8',
    'shiftjis': 'shift_jis',
    'tis620': 'cp874',
    'unicode11utf7': 'utf-7',
    'us': 'ascii',
    'usascii': 'ascii',
    'utf16': 'utf-16',
    'utf16be': 'utf-16-be',
    'utf16le': 'utf-16-le',
    'utf8': 'utf-8',
    'windows1250': 'cp1250',
    'windows1251': 'cp1251',
    'windows1252': 'cp1252',
    'windows1253': 'cp1253',
    'windows1254': 'cp1254',
    'windows1255': 'cp1255',
    'windows1256': 'cp1256',
    'windows1257': 'cp1257',
    'windows1258': 'cp1258',
    'windows936': 'gbk',
    'x-x-big5': 'big5'}

tokenTypes = {
    "Doctype":0,
    "Characters":1,
    "SpaceCharacters":2,
    "StartTag":3,
    "EndTag":4,
    "EmptyTag":5,
    "Comment":6,
    "ParseError":7
}

tagTokenTypes = frozenset((tokenTypes["StartTag"], tokenTypes["EndTag"], 
                           tokenTypes["EmptyTag"]))


prefixes = dict([(v,k) for k,v in namespaces.iteritems()])
prefixes["http://www.w3.org/1998/Math/MathML"] = "math"

class DataLossWarning(UserWarning):
    pass

class ReparseException(Exception):
    pass

########NEW FILE########
__FILENAME__ = formfiller
#
# The goal is to finally have a form filler where you pass data for
# each form, using the algorithm for "Seeding a form with initial values"
# See http://www.whatwg.org/specs/web-forms/current-work/#seeding
#

import _base

from html5lib.constants import spaceCharacters
spaceCharacters = u"".join(spaceCharacters)

class SimpleFilter(_base.Filter):
    def __init__(self, source, fieldStorage):
        _base.Filter.__init__(self, source)
        self.fieldStorage = fieldStorage

    def __iter__(self):
        field_indices = {}
        state = None
        field_name = None
        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type in ("StartTag", "EmptyTag"):
                name = token["name"].lower()
                if name == "input":
                    field_name = None
                    field_type = None
                    input_value_index = -1
                    input_checked_index = -1
                    for i,(n,v) in enumerate(token["data"]):
                        n = n.lower()
                        if n == u"name":
                            field_name = v.strip(spaceCharacters)
                        elif n == u"type":
                            field_type = v.strip(spaceCharacters)
                        elif n == u"checked":
                            input_checked_index = i
                        elif n == u"value":
                            input_value_index = i

                    value_list = self.fieldStorage.getlist(field_name)
                    field_index = field_indices.setdefault(field_name, 0)
                    if field_index < len(value_list):
                        value = value_list[field_index]
                    else:
                        value = ""

                    if field_type in (u"checkbox", u"radio"):
                        if value_list:
                            if token["data"][input_value_index][1] == value:
                                if input_checked_index < 0:
                                    token["data"].append((u"checked", u""))
                                field_indices[field_name] = field_index + 1
                            elif input_checked_index >= 0:
                                del token["data"][input_checked_index]

                    elif field_type not in (u"button", u"submit", u"reset"):
                        if input_value_index >= 0:
                            token["data"][input_value_index] = (u"value", value)
                        else:
                            token["data"].append((u"value", value))
                        field_indices[field_name] = field_index + 1

                    field_type = None
                    field_name = None

                elif name == "textarea":
                    field_type = "textarea"
                    field_name = dict((token["data"])[::-1])["name"]

                elif name == "select":
                    field_type = "select"
                    attributes = dict(token["data"][::-1])
                    field_name = attributes.get("name")
                    is_select_multiple = "multiple" in attributes
                    is_selected_option_found = False

                elif field_type == "select" and field_name and name == "option":
                    option_selected_index = -1
                    option_value = None
                    for i,(n,v) in enumerate(token["data"]):
                        n = n.lower()
                        if n == "selected":
                            option_selected_index = i
                        elif n == "value":
                            option_value = v.strip(spaceCharacters)
                    if option_value is None:
                        raise NotImplementedError("<option>s without a value= attribute")
                    else:
                        value_list = self.fieldStorage.getlist(field_name)
                        if value_list:
                            field_index = field_indices.setdefault(field_name, 0)
                            if field_index < len(value_list):
                                value = value_list[field_index]
                            else:
                                value = ""
                            if (is_select_multiple or not is_selected_option_found) and option_value == value:
                                if option_selected_index < 0:
                                    token["data"].append((u"selected", u""))
                                field_indices[field_name] = field_index + 1
                                is_selected_option_found = True
                            elif option_selected_index >= 0:
                                del token["data"][option_selected_index]

            elif field_type is not None and field_name and type == "EndTag":
                name = token["name"].lower()
                if name == field_type:
                    if name == "textarea":
                        value_list = self.fieldStorage.getlist(field_name)
                        if value_list:
                            field_index = field_indices.setdefault(field_name, 0)
                            if field_index < len(value_list):
                                value = value_list[field_index]
                            else:
                                value = ""
                            yield {"type": "Characters", "data": value}
                            field_indices[field_name] = field_index + 1

                    field_name = None

                elif name == "option" and field_type == "select":
                    pass # TODO: part of "option without value= attribute" processing

            elif field_type == "textarea":
                continue # ignore token

            yield token

########NEW FILE########
__FILENAME__ = inject_meta_charset
import _base

class Filter(_base.Filter):
    def __init__(self, source, encoding):
        _base.Filter.__init__(self, source)
        self.encoding = encoding

    def __iter__(self):
        state = "pre_head"
        meta_found = (self.encoding is None)
        pending = []

        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type == "StartTag":
                if token["name"].lower() == u"head":
                    state = "in_head"

            elif type == "EmptyTag":
                if token["name"].lower() == u"meta":
                   # replace charset with actual encoding
                   has_http_equiv_content_type = False
                   for (namespace,name),value in token["data"].iteritems():
                       if namespace != None:
                           continue
                       elif name.lower() == u'charset':
                          token["data"][(namespace,name)] = self.encoding
                          meta_found = True
                          break
                       elif name == u'http-equiv' and value.lower() == u'content-type':
                           has_http_equiv_content_type = True
                   else:
                       if has_http_equiv_content_type and (None, u"content") in token["data"]:
                           token["data"][(None, u"content")] = u'text/html; charset=%s' % self.encoding
                           meta_found = True

                elif token["name"].lower() == u"head" and not meta_found:
                    # insert meta into empty head
                    yield {"type": "StartTag", "name": u"head",
                           "data": token["data"]}
                    yield {"type": "EmptyTag", "name": u"meta",
                           "data": {(None, u"charset"): self.encoding}}
                    yield {"type": "EndTag", "name": u"head"}
                    meta_found = True
                    continue

            elif type == "EndTag":
                if token["name"].lower() == u"head" and pending:
                    # insert meta into head (if necessary) and flush pending queue
                    yield pending.pop(0)
                    if not meta_found:
                        yield {"type": "EmptyTag", "name": u"meta",
                               "data": {(None, u"charset"): self.encoding}}
                    while pending:
                        yield pending.pop(0)
                    meta_found = True
                    state = "post_head"

            if state == "in_head":
                pending.append(token)
            else:
                yield token

########NEW FILE########
__FILENAME__ = lint
from gettext import gettext
_ = gettext

import _base
from html5lib.constants import cdataElements, rcdataElements, voidElements

from html5lib.constants import spaceCharacters
spaceCharacters = u"".join(spaceCharacters)

class LintError(Exception): pass

class Filter(_base.Filter):
    def __iter__(self):
        open_elements = []
        contentModelFlag = "PCDATA"
        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type in ("StartTag", "EmptyTag"):
                name = token["name"]
                if contentModelFlag != "PCDATA":
                    raise LintError(_("StartTag not in PCDATA content model flag: %s") % name)
                if not isinstance(name, unicode):
                    raise LintError(_(u"Tag name is not a string: %r") % name)
                if not name:
                    raise LintError(_(u"Empty tag name"))
                if type == "StartTag" and name in voidElements:
                    raise LintError(_(u"Void element reported as StartTag token: %s") % name)
                elif type == "EmptyTag" and name not in voidElements:
                    raise LintError(_(u"Non-void element reported as EmptyTag token: %s") % token["name"])
                if type == "StartTag":
                    open_elements.append(name)
                for name, value in token["data"]:
                    if not isinstance(name, unicode):
                        raise LintError(_("Attribute name is not a string: %r") % name)
                    if not name:
                        raise LintError(_(u"Empty attribute name"))
                    if not isinstance(value, unicode):
                        raise LintError(_("Attribute value is not a string: %r") % value)
                if name in cdataElements:
                    contentModelFlag = "CDATA"
                elif name in rcdataElements:
                    contentModelFlag = "RCDATA"
                elif name == "plaintext":
                    contentModelFlag = "PLAINTEXT"

            elif type == "EndTag":
                name = token["name"]
                if not isinstance(name, unicode):
                    raise LintError(_(u"Tag name is not a string: %r") % name)
                if not name:
                    raise LintError(_(u"Empty tag name"))
                if name in voidElements:
                    raise LintError(_(u"Void element reported as EndTag token: %s") % name)
                start_name = open_elements.pop()
                if start_name != name:
                    raise LintError(_(u"EndTag (%s) does not match StartTag (%s)") % (name, start_name))
                contentModelFlag = "PCDATA"

            elif type == "Comment":
                if contentModelFlag != "PCDATA":
                    raise LintError(_("Comment not in PCDATA content model flag"))

            elif type in ("Characters", "SpaceCharacters"):
                data = token["data"]
                if not isinstance(data, unicode):
                    raise LintError(_("Attribute name is not a string: %r") % data)
                if not data:
                    raise LintError(_(u"%s token with empty data") % type)
                if type == "SpaceCharacters":
                    data = data.strip(spaceCharacters)
                    if data:
                        raise LintError(_(u"Non-space character(s) found in SpaceCharacters token: ") % data)

            elif type == "Doctype":
                name = token["name"]
                if contentModelFlag != "PCDATA":
                    raise LintError(_("Doctype not in PCDATA content model flag: %s") % name)
                if not isinstance(name, unicode):
                    raise LintError(_(u"Tag name is not a string: %r") % name)
                # XXX: what to do with token["data"] ?

            elif type in ("ParseError", "SerializeError"):
                pass

            else:
                raise LintError(_(u"Unknown token type: %s") % type)

            yield token

########NEW FILE########
__FILENAME__ = optionaltags
import _base

class Filter(_base.Filter):
    def slider(self):
        previous1 = previous2 = None
        for token in self.source:
            if previous1 is not None:
                yield previous2, previous1, token
            previous2 = previous1
            previous1 = token
        yield previous2, previous1, None

    def __iter__(self):
        for previous, token, next in self.slider():
            type = token["type"]
            if type == "StartTag":
                if (token["data"] or 
                    not self.is_optional_start(token["name"], previous, next)):
                    yield token
            elif type == "EndTag":
                if not self.is_optional_end(token["name"], next):
                    yield token
            else:
                yield token

    def is_optional_start(self, tagname, previous, next):
        type = next and next["type"] or None
        if tagname in 'html':
            # An html element's start tag may be omitted if the first thing
            # inside the html element is not a space character or a comment.
            return type not in ("Comment", "SpaceCharacters")
        elif tagname == 'head':
            # A head element's start tag may be omitted if the first thing
            # inside the head element is an element.
            # XXX: we also omit the start tag if the head element is empty
            if type in ("StartTag", "EmptyTag"):
                return True
            elif type == "EndTag":
                return next["name"] == "head"
        elif tagname == 'body':
            # A body element's start tag may be omitted if the first thing
            # inside the body element is not a space character or a comment,
            # except if the first thing inside the body element is a script
            # or style element and the node immediately preceding the body
            # element is a head element whose end tag has been omitted.
            if type in ("Comment", "SpaceCharacters"):
                return False
            elif type == "StartTag":
                # XXX: we do not look at the preceding event, so we never omit
                # the body element's start tag if it's followed by a script or
                # a style element.
                return next["name"] not in ('script', 'style')
            else:
                return True
        elif tagname == 'colgroup':
            # A colgroup element's start tag may be omitted if the first thing
            # inside the colgroup element is a col element, and if the element
            # is not immediately preceeded by another colgroup element whose
            # end tag has been omitted.
            if type in ("StartTag", "EmptyTag"):
                # XXX: we do not look at the preceding event, so instead we never
                # omit the colgroup element's end tag when it is immediately
                # followed by another colgroup element. See is_optional_end.
                return next["name"] == "col"
            else:
                return False
        elif tagname == 'tbody':
            # A tbody element's start tag may be omitted if the first thing
            # inside the tbody element is a tr element, and if the element is
            # not immediately preceeded by a tbody, thead, or tfoot element
            # whose end tag has been omitted.
            if type == "StartTag":
                # omit the thead and tfoot elements' end tag when they are
                # immediately followed by a tbody element. See is_optional_end.
                if previous and previous['type'] == 'EndTag' and \
                  previous['name'] in ('tbody','thead','tfoot'):
                    return False
                return next["name"] == 'tr'
            else:
                return False
        return False

    def is_optional_end(self, tagname, next):
        type = next and next["type"] or None
        if tagname in ('html', 'head', 'body'):
            # An html element's end tag may be omitted if the html element
            # is not immediately followed by a space character or a comment.
            return type not in ("Comment", "SpaceCharacters")
        elif tagname in ('li', 'optgroup', 'tr'):
            # A li element's end tag may be omitted if the li element is
            # immediately followed by another li element or if there is
            # no more content in the parent element.
            # An optgroup element's end tag may be omitted if the optgroup
            # element is immediately followed by another optgroup element,
            # or if there is no more content in the parent element.
            # A tr element's end tag may be omitted if the tr element is
            # immediately followed by another tr element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] == tagname
            else:
                return type == "EndTag" or type is None
        elif tagname in ('dt', 'dd'):
            # A dt element's end tag may be omitted if the dt element is
            # immediately followed by another dt element or a dd element.
            # A dd element's end tag may be omitted if the dd element is
            # immediately followed by another dd element or a dt element,
            # or if there is no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('dt', 'dd')
            elif tagname == 'dd':
                return type == "EndTag" or type is None
            else:
                return False
        elif tagname == 'p':
            # A p element's end tag may be omitted if the p element is
            # immediately followed by an address, article, aside,
            # blockquote, datagrid, dialog, dir, div, dl, fieldset,
            # footer, form, h1, h2, h3, h4, h5, h6, header, hr, menu,
            # nav, ol, p, pre, section, table, or ul, element, or if
            # there is no more content in the parent element.
            if type in ("StartTag", "EmptyTag"):
                return next["name"] in ('address', 'article', 'aside',
                                        'blockquote', 'datagrid', 'dialog', 
                                        'dir', 'div', 'dl', 'fieldset', 'footer',
                                        'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                                        'header', 'hr', 'menu', 'nav', 'ol', 
                                        'p', 'pre', 'section', 'table', 'ul')
            else:
                return type == "EndTag" or type is None
        elif tagname == 'option':
            # An option element's end tag may be omitted if the option
            # element is immediately followed by another option element,
            # or if it is immediately followed by an <code>optgroup</code>
            # element, or if there is no more content in the parent
            # element.
            if type == "StartTag":
                return next["name"] in ('option', 'optgroup')
            else:
                return type == "EndTag" or type is None
        elif tagname in ('rt', 'rp'):
            # An rt element's end tag may be omitted if the rt element is
            # immediately followed by an rt or rp element, or if there is
            # no more content in the parent element.
            # An rp element's end tag may be omitted if the rp element is
            # immediately followed by an rt or rp element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('rt', 'rp')
            else:
                return type == "EndTag" or type is None
        elif tagname == 'colgroup':
            # A colgroup element's end tag may be omitted if the colgroup
            # element is not immediately followed by a space character or
            # a comment.
            if type in ("Comment", "SpaceCharacters"):
                return False
            elif type == "StartTag":
                # XXX: we also look for an immediately following colgroup
                # element. See is_optional_start.
                return next["name"] != 'colgroup'
            else:
                return True
        elif tagname in ('thead', 'tbody'):
            # A thead element's end tag may be omitted if the thead element
            # is immediately followed by a tbody or tfoot element.
            # A tbody element's end tag may be omitted if the tbody element
            # is immediately followed by a tbody or tfoot element, or if
            # there is no more content in the parent element.
            # A tfoot element's end tag may be omitted if the tfoot element
            # is immediately followed by a tbody element, or if there is no
            # more content in the parent element.
            # XXX: we never omit the end tag when the following element is
            # a tbody. See is_optional_start.
            if type == "StartTag":
                return next["name"] in ['tbody', 'tfoot']
            elif tagname == 'tbody':
                return type == "EndTag" or type is None
            else:
                return False
        elif tagname == 'tfoot':
            # A tfoot element's end tag may be omitted if the tfoot element
            # is immediately followed by a tbody element, or if there is no
            # more content in the parent element.
            # XXX: we never omit the end tag when the following element is
            # a tbody. See is_optional_start.
            if type == "StartTag":
                return next["name"] == 'tbody'
            else:
                return type == "EndTag" or type is None
        elif tagname in ('td', 'th'):
            # A td element's end tag may be omitted if the td element is
            # immediately followed by a td or th element, or if there is
            # no more content in the parent element.
            # A th element's end tag may be omitted if the th element is
            # immediately followed by a td or th element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('td', 'th')
            else:
                return type == "EndTag" or type is None
        return False

########NEW FILE########
__FILENAME__ = sanitizer
import _base
from html5lib.sanitizer import HTMLSanitizerMixin

class Filter(_base.Filter, HTMLSanitizerMixin):
    def __iter__(self):
        for token in _base.Filter.__iter__(self):
            token = self.sanitize_token(token)
            if token: yield token

########NEW FILE########
__FILENAME__ = whitespace
try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import ImmutableSet as frozenset

import re

import _base
from html5lib.constants import rcdataElements, spaceCharacters
spaceCharacters = u"".join(spaceCharacters)

SPACES_REGEX = re.compile(u"[%s]+" % spaceCharacters)

class Filter(_base.Filter):

    spacePreserveElements = frozenset(["pre", "textarea"] + list(rcdataElements))

    def __iter__(self):
        preserve = 0
        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type == "StartTag" \
              and (preserve or token["name"] in self.spacePreserveElements):
                preserve += 1

            elif type == "EndTag" and preserve:
                preserve -= 1

            elif not preserve and type == "SpaceCharacters" and token["data"]:
                # Test on token["data"] above to not introduce spaces where there were not
                token["data"] = u" "

            elif not preserve and type == "Characters":
                token["data"] = collapse_spaces(token["data"])

            yield token

def collapse_spaces(text):
    return SPACES_REGEX.sub(' ', text)


########NEW FILE########
__FILENAME__ = _base

class Filter(object):
    def __init__(self, source):
        self.source = source

    def __iter__(self):
        return iter(self.source)

    def __getattr__(self, name):
        return getattr(self.source, name)

########NEW FILE########
__FILENAME__ = html5parser
try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import Set as set
    from sets import ImmutableSet as frozenset

try:
    any
except:
    # Implement 'any' for python 2.4 and previous
    def any(iterable):
        for element in iterable:
            if element:
                return True
        return False
        
try:
    "abc".startswith(("a", "b"))
    def startswithany(str, prefixes):
        return str.startswith(prefixes)
except:
    # Python 2.4 doesn't accept a tuple as argument to string startswith
    def startswithany(str, prefixes):
        for prefix in prefixes:
            if str.startswith(prefix):
                return True
        return False

import sys
import types

import inputstream
import tokenizer

import treebuilders
from treebuilders._base import Marker
from treebuilders import simpletree

import utils
import constants
from constants import spaceCharacters, asciiUpper2Lower
from constants import formattingElements, specialElements
from constants import headingElements, tableInsertModeElements
from constants import cdataElements, rcdataElements, voidElements
from constants import tokenTypes, ReparseException, namespaces, spaceCharacters
from constants import htmlIntegrationPointElements, mathmlTextIntegrationPointElements

def parse(doc, treebuilder="simpletree", encoding=None,
          namespaceHTMLElements=True):
    """Parse a string or file-like object into a tree"""
    tb = treebuilders.getTreeBuilder(treebuilder)
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
    return p.parse(doc, encoding=encoding)

def parseFragment(doc, container="div", treebuilder="simpletree", encoding=None, 
                  namespaceHTMLElements=True):
    tb = treebuilders.getTreeBuilder(treebuilder)
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
    return p.parseFragment(doc, container=container, encoding=encoding)

def method_decorator_metaclass(function):
    class Decorated(type):
        def __new__(meta, classname, bases, classDict):
            for attributeName, attribute in classDict.iteritems():
                if type(attribute) == types.FunctionType:
                    attribute = function(attribute)

                classDict[attributeName] = attribute
            return  type.__new__(meta, classname, bases, classDict)
    return Decorated

class HTMLParser(object):
    """HTML parser. Generates a tree structure from a stream of (possibly
        malformed) HTML"""

    def __init__(self, tree = simpletree.TreeBuilder,
                 tokenizer = tokenizer.HTMLTokenizer, strict = False,
                 namespaceHTMLElements = True, debug=False):
        """
        strict - raise an exception when a parse error is encountered

        tree - a treebuilder class controlling the type of tree that will be
        returned. Built in treebuilders can be accessed through
        html5lib.treebuilders.getTreeBuilder(treeType)
        
        tokenizer - a class that provides a stream of tokens to the treebuilder.
        This may be replaced for e.g. a sanitizer which converts some tags to
        text
        """

        # Raise an exception on the first error encountered
        self.strict = strict

        self.tree = tree(namespaceHTMLElements)
        self.tokenizer_class = tokenizer
        self.errors = []

        self.phases = dict([(name, cls(self, self.tree)) for name, cls in
                            getPhases(debug).iteritems()])

    def _parse(self, stream, innerHTML=False, container="div",
               encoding=None, parseMeta=True, useChardet=True, **kwargs):

        self.innerHTMLMode = innerHTML
        self.container = container
        self.tokenizer = self.tokenizer_class(stream, encoding=encoding,
                                              parseMeta=parseMeta,
                                              useChardet=useChardet, 
                                              parser=self, **kwargs)
        self.reset()

        while True:
            try:
                self.mainLoop()
                break
            except ReparseException, e:
                self.reset()

    def reset(self):
        self.tree.reset()
        self.firstStartTag = False
        self.errors = []
        self.log = [] #only used with debug mode
        # "quirks" / "limited quirks" / "no quirks"
        self.compatMode = "no quirks"

        if self.innerHTMLMode:
            self.innerHTML = self.container.lower()

            if self.innerHTML in cdataElements:
                self.tokenizer.state = self.tokenizer.rcdataState
            elif self.innerHTML in rcdataElements:
                self.tokenizer.state = self.tokenizer.rawtextState
            elif self.innerHTML == 'plaintext':
                self.tokenizer.state = self.tokenizer.plaintextState
            else:
                # state already is data state
                # self.tokenizer.state = self.tokenizer.dataState
                pass
            self.phase = self.phases["beforeHtml"]
            self.phase.insertHtmlElement()
            self.resetInsertionMode()
        else:
            self.innerHTML = False
            self.phase = self.phases["initial"]

        self.lastPhase = None

        self.beforeRCDataPhase = None

        self.framesetOK = True

    def isHTMLIntegrationPoint(self, element):
        if (element.name == "annotation-xml" and 
            element.namespace == namespaces["mathml"]):
            return ("encoding" in element.attributes and
                    element.attributes["encoding"].translate(
                        asciiUpper2Lower) in 
                    ("text/html", "application/xhtml+xml"))
        else:
            return (element.namespace, element.name) in htmlIntegrationPointElements

    def isMathMLTextIntegrationPoint(self, element):
        return (element.namespace, element.name) in mathmlTextIntegrationPointElements
        
    def mainLoop(self):
        CharactersToken = tokenTypes["Characters"]
        SpaceCharactersToken = tokenTypes["SpaceCharacters"]
        StartTagToken = tokenTypes["StartTag"]
        EndTagToken = tokenTypes["EndTag"]
        CommentToken = tokenTypes["Comment"]
        DoctypeToken = tokenTypes["Doctype"]
        ParseErrorToken = tokenTypes["ParseError"]
        
        for token in self.normalizedTokens():
            new_token = token
            while new_token is not None:
                currentNode = self.tree.openElements[-1] if self.tree.openElements else None
                currentNodeNamespace = currentNode.namespace if currentNode else None
                currentNodeName = currentNode.name if currentNode else None

                type = new_token["type"]
                
                if type == ParseErrorToken:
                    self.parseError(new_token["data"], new_token.get("datavars", {}))
                    new_token = None
                else:
                    if (len(self.tree.openElements) == 0 or
                        currentNodeNamespace == self.tree.defaultNamespace or
                        (self.isMathMLTextIntegrationPoint(currentNode) and
                         ((type == StartTagToken and
                           token["name"] not in frozenset(["mglyph", "malignmark"])) or
                         type in (CharactersToken, SpaceCharactersToken))) or
                        (currentNodeNamespace == namespaces["mathml"] and
                         currentNodeName == "annotation-xml" and
                         token["name"] == "svg") or
                        (self.isHTMLIntegrationPoint(currentNode) and
                         type in (StartTagToken, CharactersToken, SpaceCharactersToken))):
                        phase = self.phase
                    else:
                        phase = self.phases["inForeignContent"]

                    if type == CharactersToken:
                        new_token = phase.processCharacters(new_token)
                    elif type == SpaceCharactersToken:
                         new_token= phase.processSpaceCharacters(new_token)
                    elif type == StartTagToken:
                        new_token = phase.processStartTag(new_token)
                    elif type == EndTagToken:
                        new_token = phase.processEndTag(new_token)
                    elif type == CommentToken:
                        new_token = phase.processComment(new_token)
                    elif type == DoctypeToken:
                        new_token = phase.processDoctype(new_token)

            if (type == StartTagToken and token["selfClosing"]
                and not token["selfClosingAcknowledged"]):
                self.parseError("non-void-element-with-trailing-solidus",
                                {"name":token["name"]})


        # When the loop finishes it's EOF
        reprocess = True
        phases = []
        while reprocess:
            phases.append(self.phase)
            reprocess = self.phase.processEOF()
            if reprocess:
                assert self.phase not in phases

    def normalizedTokens(self):
        for token in self.tokenizer:
            yield self.normalizeToken(token)

    def parse(self, stream, encoding=None, parseMeta=True, useChardet=True):
        """Parse a HTML document into a well-formed tree

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)
        """
        self._parse(stream, innerHTML=False, encoding=encoding, 
                    parseMeta=parseMeta, useChardet=useChardet)
        return self.tree.getDocument()
    
    def parseFragment(self, stream, container="div", encoding=None,
                      parseMeta=False, useChardet=True):
        """Parse a HTML fragment into a well-formed tree fragment
        
        container - name of the element we're setting the innerHTML property
        if set to None, default to 'div'

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)
        """
        self._parse(stream, True, container=container, encoding=encoding)
        return self.tree.getFragment()

    def parseError(self, errorcode="XXX-undefined-error", datavars={}):
        # XXX The idea is to make errorcode mandatory.
        self.errors.append((self.tokenizer.stream.position(), errorcode, datavars))
        if self.strict:
            raise ParseError

    def normalizeToken(self, token):
        """ HTML5 specific normalizations to the token stream """

        if token["type"] == tokenTypes["StartTag"]:
            token["data"] = dict(token["data"][::-1])

        return token

    def adjustMathMLAttributes(self, token):
        replacements = {"definitionurl":u"definitionURL"}
        for k,v in replacements.iteritems():
            if k in token["data"]:
                token["data"][v] = token["data"][k]
                del token["data"][k]

    def adjustSVGAttributes(self, token):
        replacements = {
            "attributename":u"attributeName",
            "attributetype":u"attributeType",
            "basefrequency":u"baseFrequency",
            "baseprofile":u"baseProfile",
            "calcmode":u"calcMode",
            "clippathunits":u"clipPathUnits",
            "contentscripttype":u"contentScriptType",
            "contentstyletype":u"contentStyleType",
            "diffuseconstant":u"diffuseConstant",
            "edgemode":u"edgeMode",
            "externalresourcesrequired":u"externalResourcesRequired",
            "filterres":u"filterRes",
            "filterunits":u"filterUnits",
            "glyphref":u"glyphRef",
            "gradienttransform":u"gradientTransform",
            "gradientunits":u"gradientUnits",
            "kernelmatrix":u"kernelMatrix",
            "kernelunitlength":u"kernelUnitLength",
            "keypoints":u"keyPoints",
            "keysplines":u"keySplines",
            "keytimes":u"keyTimes",
            "lengthadjust":u"lengthAdjust",
            "limitingconeangle":u"limitingConeAngle",
            "markerheight":u"markerHeight",
            "markerunits":u"markerUnits",
            "markerwidth":u"markerWidth",
            "maskcontentunits":u"maskContentUnits",
            "maskunits":u"maskUnits",
            "numoctaves":u"numOctaves",
            "pathlength":u"pathLength",
            "patterncontentunits":u"patternContentUnits",
            "patterntransform":u"patternTransform",
            "patternunits":u"patternUnits",
            "pointsatx":u"pointsAtX",
            "pointsaty":u"pointsAtY",
            "pointsatz":u"pointsAtZ",
            "preservealpha":u"preserveAlpha",
            "preserveaspectratio":u"preserveAspectRatio",
            "primitiveunits":u"primitiveUnits",
            "refx":u"refX",
            "refy":u"refY",
            "repeatcount":u"repeatCount",
            "repeatdur":u"repeatDur",
            "requiredextensions":u"requiredExtensions",
            "requiredfeatures":u"requiredFeatures",
            "specularconstant":u"specularConstant",
            "specularexponent":u"specularExponent",
            "spreadmethod":u"spreadMethod",
            "startoffset":u"startOffset",
            "stddeviation":u"stdDeviation",
            "stitchtiles":u"stitchTiles",
            "surfacescale":u"surfaceScale",
            "systemlanguage":u"systemLanguage",
            "tablevalues":u"tableValues",
            "targetx":u"targetX",
            "targety":u"targetY",
            "textlength":u"textLength",
            "viewbox":u"viewBox",
            "viewtarget":u"viewTarget",
            "xchannelselector":u"xChannelSelector",
            "ychannelselector":u"yChannelSelector",
            "zoomandpan":u"zoomAndPan"
            }
        for originalName in token["data"].keys():
            if originalName in replacements:
                svgName = replacements[originalName]
                token["data"][svgName] = token["data"][originalName]
                del token["data"][originalName]

    def adjustForeignAttributes(self, token):
        replacements = {
            "xlink:actuate":("xlink", "actuate", namespaces["xlink"]),
            "xlink:arcrole":("xlink", "arcrole", namespaces["xlink"]),
            "xlink:href":("xlink", "href", namespaces["xlink"]),
            "xlink:role":("xlink", "role", namespaces["xlink"]),
            "xlink:show":("xlink", "show", namespaces["xlink"]),
            "xlink:title":("xlink", "title", namespaces["xlink"]),
            "xlink:type":("xlink", "type", namespaces["xlink"]),
            "xml:base":("xml", "base", namespaces["xml"]),
            "xml:lang":("xml", "lang", namespaces["xml"]),
            "xml:space":("xml", "space", namespaces["xml"]),
            "xmlns":(None, "xmlns", namespaces["xmlns"]),
            "xmlns:xlink":("xmlns", "xlink", namespaces["xmlns"])
            }

        for originalName in token["data"].iterkeys():
            if originalName in replacements:
                foreignName = replacements[originalName]
                token["data"][foreignName] = token["data"][originalName]
                del token["data"][originalName]

    def reparseTokenNormal(self, token):
        self.parser.phase()

    def resetInsertionMode(self):
        # The name of this method is mostly historical. (It's also used in the
        # specification.)
        last = False
        newModes = {
            "select":"inSelect",
            "td":"inCell",
            "th":"inCell",
            "tr":"inRow",
            "tbody":"inTableBody",
            "thead":"inTableBody",
            "tfoot":"inTableBody",
            "caption":"inCaption",
            "colgroup":"inColumnGroup",
            "table":"inTable",
            "head":"inBody",
            "body":"inBody",
            "frameset":"inFrameset",
            "html":"beforeHead"
        }
        for node in self.tree.openElements[::-1]:
            nodeName = node.name
            new_phase = None
            if node == self.tree.openElements[0]:
                assert self.innerHTML
                last = True
                nodeName = self.innerHTML
            # Check for conditions that should only happen in the innerHTML
            # case
            if nodeName in ("select", "colgroup", "head", "html"):
                assert self.innerHTML

            if not last and node.namespace != self.tree.defaultNamespace:
                continue

            if nodeName in newModes:
                new_phase = self.phases[newModes[nodeName]]
                break
            elif last:
                new_phase = self.phases["inBody"]
                break

        self.phase = new_phase

    def parseRCDataRawtext(self, token, contentType):
        """Generic RCDATA/RAWTEXT Parsing algorithm
        contentType - RCDATA or RAWTEXT
        """
        assert contentType in ("RAWTEXT", "RCDATA")
        
        element = self.tree.insertElement(token)
        
        if contentType == "RAWTEXT":
            self.tokenizer.state = self.tokenizer.rawtextState
        else:
            self.tokenizer.state = self.tokenizer.rcdataState

        self.originalPhase = self.phase

        self.phase = self.phases["text"]

def getPhases(debug):
    def log(function):
        """Logger that records which phase processes each token"""
        type_names = dict((value, key) for key, value in 
                          constants.tokenTypes.iteritems())
        def wrapped(self, *args, **kwargs):
            if function.__name__.startswith("process") and len(args) > 0:
                token = args[0]
                try:
                    info = {"type":type_names[token['type']]}
                except:
                    raise
                if token['type'] in constants.tagTokenTypes:
                    info["name"] = token['name']

                self.parser.log.append((self.parser.tokenizer.state.__name__,
                                        self.parser.phase.__class__.__name__, 
                                        self.__class__.__name__, 
                                        function.__name__, 
                                        info))
                return function(self, *args, **kwargs)
            else:
                return function(self, *args, **kwargs)
        return wrapped

    def getMetaclass(use_metaclass, metaclass_func):
        if use_metaclass:
            return method_decorator_metaclass(metaclass_func)
        else:
            return type

    class Phase(object):
        """Base class for helper object that implements each phase of processing
        """
        # Order should be (they can be omitted):
        # * EOF
        # * Comment
        # * Doctype
        # * SpaceCharacters
        # * Characters
        # * StartTag
        #   - startTag* methods
        # * EndTag
        #   - endTag* methods

        __metaclass__ = getMetaclass(debug, log)

        def __init__(self, parser, tree):
            self.parser = parser
            self.tree = tree

        def processEOF(self):
            raise NotImplementedError

        def processComment(self, token):
            # For most phases the following is correct. Where it's not it will be
            # overridden.
            self.tree.insertComment(token, self.tree.openElements[-1])

        def processDoctype(self, token):
            self.parser.parseError("unexpected-doctype")

        def processCharacters(self, token):
            self.tree.insertText(token["data"])

        def processSpaceCharacters(self, token):
            self.tree.insertText(token["data"])

        def processStartTag(self, token):
            return self.startTagHandler[token["name"]](token)

        def startTagHtml(self, token):
            if self.parser.firstStartTag == False and token["name"] == "html":
               self.parser.parseError("non-html-root")
            # XXX Need a check here to see if the first start tag token emitted is
            # this token... If it's not, invoke self.parser.parseError().
            for attr, value in token["data"].iteritems():
                if attr not in self.tree.openElements[0].attributes:
                    self.tree.openElements[0].attributes[attr] = value
            self.parser.firstStartTag = False

        def processEndTag(self, token):
            return self.endTagHandler[token["name"]](token)

    class InitialPhase(Phase):
        def processSpaceCharacters(self, token):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processDoctype(self, token):
            name = token["name"]
            publicId = token["publicId"]
            systemId = token["systemId"]
            correct = token["correct"]

            if (name != "html" or publicId != None or
                systemId != None and systemId != "about:legacy-compat"):
                self.parser.parseError("unknown-doctype")

            if publicId is None:
                publicId = ""

            self.tree.insertDoctype(token)

            if publicId != "":
                publicId = publicId.translate(asciiUpper2Lower)

            if (not correct or token["name"] != "html"
                or startswithany(publicId,
                ("+//silmaril//dtd html pro v0r11 19970101//",
                 "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
                 "-//as//dtd html 3.0 aswedit + extensions//",
                 "-//ietf//dtd html 2.0 level 1//",
                 "-//ietf//dtd html 2.0 level 2//",
                 "-//ietf//dtd html 2.0 strict level 1//",
                 "-//ietf//dtd html 2.0 strict level 2//",
                 "-//ietf//dtd html 2.0 strict//",
                 "-//ietf//dtd html 2.0//",
                 "-//ietf//dtd html 2.1e//",
                 "-//ietf//dtd html 3.0//",
                 "-//ietf//dtd html 3.2 final//",
                 "-//ietf//dtd html 3.2//",
                 "-//ietf//dtd html 3//",
                 "-//ietf//dtd html level 0//",
                 "-//ietf//dtd html level 1//",
                 "-//ietf//dtd html level 2//",
                 "-//ietf//dtd html level 3//",
                 "-//ietf//dtd html strict level 0//",
                 "-//ietf//dtd html strict level 1//",
                 "-//ietf//dtd html strict level 2//",
                 "-//ietf//dtd html strict level 3//",
                 "-//ietf//dtd html strict//",
                 "-//ietf//dtd html//",
                 "-//metrius//dtd metrius presentational//",
                 "-//microsoft//dtd internet explorer 2.0 html strict//",
                 "-//microsoft//dtd internet explorer 2.0 html//",
                 "-//microsoft//dtd internet explorer 2.0 tables//",
                 "-//microsoft//dtd internet explorer 3.0 html strict//",
                 "-//microsoft//dtd internet explorer 3.0 html//",
                 "-//microsoft//dtd internet explorer 3.0 tables//",
                 "-//netscape comm. corp.//dtd html//",
                 "-//netscape comm. corp.//dtd strict html//",
                 "-//o'reilly and associates//dtd html 2.0//",
                 "-//o'reilly and associates//dtd html extended 1.0//",
                 "-//o'reilly and associates//dtd html extended relaxed 1.0//",
                 "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
                 "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
                 "-//spyglass//dtd html 2.0 extended//",
                 "-//sq//dtd html 2.0 hotmetal + extensions//",
                 "-//sun microsystems corp.//dtd hotjava html//",
                 "-//sun microsystems corp.//dtd hotjava strict html//",
                 "-//w3c//dtd html 3 1995-03-24//",
                 "-//w3c//dtd html 3.2 draft//",
                 "-//w3c//dtd html 3.2 final//",
                 "-//w3c//dtd html 3.2//",
                 "-//w3c//dtd html 3.2s draft//",
                 "-//w3c//dtd html 4.0 frameset//",
                 "-//w3c//dtd html 4.0 transitional//",
                 "-//w3c//dtd html experimental 19960712//",
                 "-//w3c//dtd html experimental 970421//",
                 "-//w3c//dtd w3 html//",
                 "-//w3o//dtd w3 html 3.0//",
                 "-//webtechs//dtd mozilla html 2.0//",
                 "-//webtechs//dtd mozilla html//"))
                or publicId in
                    ("-//w3o//dtd w3 html strict 3.0//en//",
                     "-/w3c/dtd html 4.0 transitional/en",
                     "html")
                or startswithany(publicId,
                    ("-//w3c//dtd html 4.01 frameset//",
                     "-//w3c//dtd html 4.01 transitional//")) and 
                    systemId == None
                or systemId and systemId.lower() == "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"):
                self.parser.compatMode = "quirks"
            elif (startswithany(publicId,
                    ("-//w3c//dtd xhtml 1.0 frameset//",
                     "-//w3c//dtd xhtml 1.0 transitional//"))
                  or startswithany(publicId,
                      ("-//w3c//dtd html 4.01 frameset//",
                       "-//w3c//dtd html 4.01 transitional//")) and 
                      systemId != None):
                self.parser.compatMode = "limited quirks"

            self.parser.phase = self.parser.phases["beforeHtml"]

        def anythingElse(self):
            self.parser.compatMode = "quirks"
            self.parser.phase = self.parser.phases["beforeHtml"]

        def processCharacters(self, token):
            self.parser.parseError("expected-doctype-but-got-chars")
            self.anythingElse()
            return token

        def processStartTag(self, token):
            self.parser.parseError("expected-doctype-but-got-start-tag",
              {"name": token["name"]})
            self.anythingElse()
            return token

        def processEndTag(self, token):
            self.parser.parseError("expected-doctype-but-got-end-tag",
              {"name": token["name"]})
            self.anythingElse()
            return token

        def processEOF(self):
            self.parser.parseError("expected-doctype-but-got-eof")
            self.anythingElse()
            return True


    class BeforeHtmlPhase(Phase):
        # helper methods
        def insertHtmlElement(self):
            self.tree.insertRoot(impliedTagToken("html", "StartTag"))
            self.parser.phase = self.parser.phases["beforeHead"]

        # other
        def processEOF(self):
            self.insertHtmlElement()
            return True

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            pass

        def processCharacters(self, token):
            self.insertHtmlElement()
            return token

        def processStartTag(self, token):
            if token["name"] == "html":
                self.parser.firstStartTag = True
            self.insertHtmlElement()
            return token

        def processEndTag(self, token):
            if token["name"] not in ("head", "body", "html", "br"):
                self.parser.parseError("unexpected-end-tag-before-html",
                  {"name": token["name"]})
            else:
                self.insertHtmlElement()
                return token


    class BeforeHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("head", "body", "html", "br"), self.endTagImplyHead)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return True

        def processSpaceCharacters(self, token):
            pass

        def processCharacters(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagHead(self, token):
            self.tree.insertElement(token)
            self.tree.headPointer = self.tree.openElements[-1]
            self.parser.phase = self.parser.phases["inHead"]

        def startTagOther(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def endTagImplyHead(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def endTagOther(self, token):
            self.parser.parseError("end-tag-after-implied-root",
              {"name": token["name"]})

    class InHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler =  utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("title", self.startTagTitle),
                (("noscript", "noframes", "style"), self.startTagNoScriptNoFramesStyle),
                ("script", self.startTagScript),
                (("base", "basefont", "bgsound", "command", "link"), 
                 self.startTagBaseLinkCommand),
                ("meta", self.startTagMeta),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther

            self. endTagHandler = utils.MethodDispatcher([
                ("head", self.endTagHead),
                (("br", "html", "body"), self.endTagHtmlBodyBr)
            ])
            self.endTagHandler.default = self.endTagOther

        # the real thing
        def processEOF (self):
            self.anythingElse()
            return True

        def processCharacters(self, token):
            self.anythingElse()
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagHead(self, token):
            self.parser.parseError("two-heads-are-not-better-than-one")

        def startTagBaseLinkCommand(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

        def startTagMeta(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

            attributes = token["data"]
            if self.parser.tokenizer.stream.charEncoding[1] == "tentative":
                if "charset" in attributes:
                    self.parser.tokenizer.stream.changeEncoding(attributes["charset"])
                elif "content" in attributes:
                    # Encoding it as UTF-8 here is a hack, as really we should pass
                    # the abstract Unicode string, and just use the
                    # ContentAttrParser on that, but using UTF-8 allows all chars
                    # to be encoded and as a ASCII-superset works.
                    data = inputstream.EncodingBytes(attributes["content"].encode("utf-8"))
                    parser = inputstream.ContentAttrParser(data)
                    codec = parser.parse()
                    self.parser.tokenizer.stream.changeEncoding(codec)

        def startTagTitle(self, token):
            self.parser.parseRCDataRawtext(token, "RCDATA")

        def startTagNoScriptNoFramesStyle(self, token):
            #Need to decide whether to implement the scripting-disabled case
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagScript(self, token):
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.scriptDataState
            self.parser.originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["text"]

        def startTagOther(self, token):
            self.anythingElse()
            return token

        def endTagHead(self, token):
            node = self.parser.tree.openElements.pop()
            assert node.name == "head", "Expected head got %s"%node.name
            self.parser.phase = self.parser.phases["afterHead"]

        def endTagHtmlBodyBr(self, token):
            self.anythingElse()
            return token

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def anythingElse(self):
            self.endTagHead(impliedTagToken("head"))


    # XXX If we implement a parser for which scripting is disabled we need to
    # implement this phase.
    #
    # class InHeadNoScriptPhase(Phase):

    class AfterHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("body", self.startTagBody),
                ("frameset", self.startTagFrameset),
                (("base", "basefont", "bgsound", "link", "meta", "noframes", "script", 
                  "style", "title"),
                  self.startTagFromHead),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([(("body", "html", "br"), 
                                                          self.endTagHtmlBodyBr)])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.anythingElse()
            return True

        def processCharacters(self, token):
            self.anythingElse()
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagBody(self, token):
            self.parser.framesetOK = False
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inBody"]

        def startTagFrameset(self, token):
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inFrameset"]

        def startTagFromHead(self, token):
            self.parser.parseError("unexpected-start-tag-out-of-my-head",
              {"name": token["name"]})
            self.tree.openElements.append(self.tree.headPointer)
            self.parser.phases["inHead"].processStartTag(token)
            for node in self.tree.openElements[::-1]:
                if node.name == "head":
                    self.tree.openElements.remove(node)
                    break

        def startTagHead(self, token):
            self.parser.parseError("unexpected-start-tag", {"name":token["name"]})

        def startTagOther(self, token):
            self.anythingElse()
            return token

        def endTagHtmlBodyBr(self, token):
            self.anythingElse()
            return token

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag", {"name":token["name"]})

        def anythingElse(self):
            self.tree.insertElement(impliedTagToken("body", "StartTag"))
            self.parser.phase = self.parser.phases["inBody"]
            self.parser.framesetOK = True


    class InBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
        # the really-really-really-very crazy mode
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            #Keep a ref to this for special handling of whitespace in <pre>
            self.processSpaceCharactersNonPre = self.processSpaceCharacters

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("base", "basefont", "bgsound", "command", "link", "meta", 
                  "noframes", "script", "style", "title"), 
                 self.startTagProcessInHead),
                ("body", self.startTagBody),
                ("frameset", self.startTagFrameset),
                (("address", "article", "aside", "blockquote", "center", "details",
                  "details", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "menu", "nav", "ol", "p",
                  "section", "summary", "ul"),
                  self.startTagCloseP),
                (headingElements, self.startTagHeading),
                (("pre", "listing"), self.startTagPreListing),
                ("form", self.startTagForm),
                (("li", "dd", "dt"), self.startTagListItem),
                ("plaintext",self.startTagPlaintext),
                ("a", self.startTagA),
                (("b", "big", "code", "em", "font", "i", "s", "small", "strike", 
                  "strong", "tt", "u"),self.startTagFormatting),
                ("nobr", self.startTagNobr),
                ("button", self.startTagButton),
                (("applet", "marquee", "object"), self.startTagAppletMarqueeObject),
                ("xmp", self.startTagXmp),
                ("table", self.startTagTable),
                (("area", "br", "embed", "img", "keygen", "wbr"),
                 self.startTagVoidFormatting),
                (("param", "source", "track"), self.startTagParamSource),
                ("input", self.startTagInput),
                ("hr", self.startTagHr),
                ("image", self.startTagImage),
                ("isindex", self.startTagIsIndex),
                ("textarea", self.startTagTextarea),
                ("iframe", self.startTagIFrame),
                (("noembed", "noframes", "noscript"), self.startTagRawtext),
                ("select", self.startTagSelect),
                (("rp", "rt"), self.startTagRpRt),
                (("option", "optgroup"), self.startTagOpt),
                (("math"), self.startTagMath),
                (("svg"), self.startTagSvg),
                (("caption", "col", "colgroup", "frame", "head",
                  "tbody", "td", "tfoot", "th", "thead",
                  "tr"), self.startTagMisplaced)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("body",self.endTagBody),
                ("html",self.endTagHtml),
                (("address", "article", "aside", "blockquote", "center",
                  "details", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "listing", "menu", "nav", "ol", "pre", 
                  "section", "summary", "ul"), self.endTagBlock),
                ("form", self.endTagForm),
                ("p",self.endTagP),
                (("dd", "dt", "li"), self.endTagListItem),
                (headingElements, self.endTagHeading),
                (("a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small",
                  "strike", "strong", "tt", "u"), self.endTagFormatting),
                (("applet",  "marquee", "object"), self.endTagAppletMarqueeObject),
                ("br", self.endTagBr),
                ])
            self.endTagHandler.default = self.endTagOther

        def isMatchingFormattingElement(self, node1, node2):
            if node1.name != node2.name or node1.namespace != node2.namespace:
                return False
            elif len(node1.attributes) != len(node2.attributes):
                return False
            else:
                attributes1 = sorted(node1.attributes.items())
                attributes2 = sorted(node2.attributes.items())
                for attr1, attr2 in zip(attributes1, attributes2):
                    if attr1 != attr2:
                        return False
            return True

        # helper
        def addFormattingElement(self, token):
            self.tree.insertElement(token)
            element = self.tree.openElements[-1]
            
            matchingElements = []
            for node in self.tree.activeFormattingElements[::-1]:
                if node is Marker:
                    break
                elif self.isMatchingFormattingElement(node, element):
                    matchingElements.append(node)
                    
            assert len(matchingElements) <= 3
            if len(matchingElements) == 3:
                self.tree.activeFormattingElements.remove(matchingElements[-1])
            self.tree.activeFormattingElements.append(element)

        # the real deal
        def processEOF(self):
            allowed_elements = frozenset(("dd", "dt", "li", "p", "tbody", "td",
                                          "tfoot", "th", "thead", "tr", "body",
                                          "html"))
            for node in self.tree.openElements[::-1]:
                if node.name not in allowed_elements:
                    self.parser.parseError("expected-closing-tag-but-got-eof")
                    break
            #Stop parsing

        def processSpaceCharactersDropNewline(self, token):
            # Sometimes (start of <pre>, <listing>, and <textarea> blocks) we
            # want to drop leading newlines
            data = token["data"]
            self.processSpaceCharacters = self.processSpaceCharactersNonPre
            if (data.startswith("\n") and
                self.tree.openElements[-1].name in ("pre", "listing", "textarea")
                and not self.tree.openElements[-1].hasContent()):
                data = data[1:]
            if data:
                self.tree.reconstructActiveFormattingElements()
                self.tree.insertText(data)

        def processCharacters(self, token):
            if token["data"] == u"\u0000":
                #The tokenizer should always emit null on its own
                return
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertText(token["data"])
            #This must be bad for performance
            if (self.parser.framesetOK and
                any([char not in spaceCharacters
                     for char in token["data"]])):
                self.parser.framesetOK = False

        def processSpaceCharacters(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertText(token["data"])

        def startTagProcessInHead(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagBody(self, token):
            self.parser.parseError("unexpected-start-tag", {"name": "body"})
            if (len(self.tree.openElements) == 1
                or self.tree.openElements[1].name != "body"):
                assert self.parser.innerHTML
            else:
                self.parser.framesetOK = False
                for attr, value in token["data"].iteritems():
                    if attr not in self.tree.openElements[1].attributes:
                        self.tree.openElements[1].attributes[attr] = value

        def startTagFrameset(self, token):
            self.parser.parseError("unexpected-start-tag", {"name": "frameset"})
            if (len(self.tree.openElements) == 1 or self.tree.openElements[1].name != "body"):
                assert self.parser.innerHTML
            elif not self.parser.framesetOK:
                pass
            else:
                if self.tree.openElements[1].parent:
                    self.tree.openElements[1].parent.removeChild(self.tree.openElements[1])
                while self.tree.openElements[-1].name != "html":
                    self.tree.openElements.pop()
                self.tree.insertElement(token)
                self.parser.phase = self.parser.phases["inFrameset"]

        def startTagCloseP(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)

        def startTagPreListing(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline

        def startTagForm(self, token):
            if self.tree.formPointer:
                self.parser.parseError(u"unexpected-start-tag", {"name": "form"})
            else:
                if self.tree.elementInScope("p", variant="button"):
                    self.endTagP(impliedTagToken("p"))
                self.tree.insertElement(token)
                self.tree.formPointer = self.tree.openElements[-1]

        def startTagListItem(self, token):
            self.parser.framesetOK = False

            stopNamesMap = {"li":["li"],
                            "dt":["dt", "dd"],
                            "dd":["dt", "dd"]}
            stopNames = stopNamesMap[token["name"]]
            for node in reversed(self.tree.openElements):
                if node.name in stopNames:
                    self.parser.phase.processEndTag(
                        impliedTagToken(node.name, "EndTag"))
                    break
                if (node.nameTuple in specialElements and
                    node.name not in ("address", "div", "p")):
                    break

            if self.tree.elementInScope("p", variant="button"):
                self.parser.phase.processEndTag(
                    impliedTagToken("p", "EndTag"))

            self.tree.insertElement(token)

        def startTagPlaintext(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.plaintextState

        def startTagHeading(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            if self.tree.openElements[-1].name in headingElements:
                self.parser.parseError("unexpected-start-tag", {"name": token["name"]})
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagA(self, token):
            afeAElement = self.tree.elementInActiveFormattingElements("a")
            if afeAElement:
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                  {"startName": "a", "endName": "a"})
                self.endTagFormatting(impliedTagToken("a"))
                if afeAElement in self.tree.openElements:
                    self.tree.openElements.remove(afeAElement)
                if afeAElement in self.tree.activeFormattingElements:
                    self.tree.activeFormattingElements.remove(afeAElement)
            self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagFormatting(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagNobr(self, token):
            self.tree.reconstructActiveFormattingElements()
            if self.tree.elementInScope("nobr"):
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                  {"startName": "nobr", "endName": "nobr"})
                self.processEndTag(impliedTagToken("nobr"))
                # XXX Need tests that trigger the following
                self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagButton(self, token):
            if self.tree.elementInScope("button"):
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                  {"startName": "button", "endName": "button"})
                self.processEndTag(impliedTagToken("button"))
                return token
            else:
                self.tree.reconstructActiveFormattingElements()
                self.tree.insertElement(token)
                self.parser.framesetOK = False

        def startTagAppletMarqueeObject(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.tree.activeFormattingElements.append(Marker)
            self.parser.framesetOK = False

        def startTagXmp(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.reconstructActiveFormattingElements()
            self.parser.framesetOK = False
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagTable(self, token):
            if self.parser.compatMode != "quirks":
                if self.tree.elementInScope("p", variant="button"):
                    self.processEndTag(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            self.parser.phase = self.parser.phases["inTable"]

        def startTagVoidFormatting(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True
            self.parser.framesetOK = False

        def startTagInput(self, token):
            framesetOK = self.parser.framesetOK
            self.startTagVoidFormatting(token)
            if ("type" in token["data"] and
                token["data"]["type"].translate(asciiUpper2Lower) == "hidden"):
                #input type=hidden doesn't change framesetOK
                self.parser.framesetOK = framesetOK

        def startTagParamSource(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

        def startTagHr(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True
            self.parser.framesetOK = False

        def startTagImage(self, token):
            # No really...
            self.parser.parseError("unexpected-start-tag-treated-as",
              {"originalName": "image", "newName": "img"})
            self.processStartTag(impliedTagToken("img", "StartTag",
                                                 attributes=token["data"],
                                                 selfClosing=token["selfClosing"]))

        def startTagIsIndex(self, token):
            self.parser.parseError("deprecated-tag", {"name": "isindex"})
            if self.tree.formPointer:
                return
            form_attrs = {}
            if "action" in token["data"]:
                form_attrs["action"] = token["data"]["action"]
            self.processStartTag(impliedTagToken("form", "StartTag",
                                                 attributes=form_attrs))
            self.processStartTag(impliedTagToken("hr", "StartTag"))
            self.processStartTag(impliedTagToken("label", "StartTag"))
            # XXX Localization ...
            if "prompt" in token["data"]:
                prompt = token["data"]["prompt"]
            else:
                prompt = u"This is a searchable index. Enter search keywords: "
            self.processCharacters(
                {"type":tokenTypes["Characters"], "data":prompt})
            attributes = token["data"].copy()
            if "action" in attributes:
                del attributes["action"]
            if "prompt" in attributes:
                del attributes["prompt"]
            attributes["name"] = "isindex"
            self.processStartTag(impliedTagToken("input", "StartTag", 
                                                 attributes = attributes,
                                                 selfClosing = 
                                                 token["selfClosing"]))
            self.processEndTag(impliedTagToken("label"))
            self.processStartTag(impliedTagToken("hr", "StartTag"))
            self.processEndTag(impliedTagToken("form"))

        def startTagTextarea(self, token):
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.rcdataState
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline
            self.parser.framesetOK = False

        def startTagIFrame(self, token):
            self.parser.framesetOK = False
            self.startTagRawtext(token)

        def startTagRawtext(self, token):
            """iframe, noembed noframes, noscript(if scripting enabled)"""
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagOpt(self, token):
            if self.tree.openElements[-1].name == "option":
                self.parser.phase.processEndTag(impliedTagToken("option"))
            self.tree.reconstructActiveFormattingElements()
            self.parser.tree.insertElement(token)

        def startTagSelect(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            if self.parser.phase in (self.parser.phases["inTable"],
                                     self.parser.phases["inCaption"],
                                     self.parser.phases["inColumnGroup"],
                                     self.parser.phases["inTableBody"], 
                                     self.parser.phases["inRow"],
                                     self.parser.phases["inCell"]):
                self.parser.phase = self.parser.phases["inSelectInTable"]
            else:
                self.parser.phase = self.parser.phases["inSelect"]

        def startTagRpRt(self, token):
            if self.tree.elementInScope("ruby"):
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "ruby":
                    self.parser.parseError()
            self.tree.insertElement(token)

        def startTagMath(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.parser.adjustMathMLAttributes(token)
            self.parser.adjustForeignAttributes(token)
            token["namespace"] = namespaces["mathml"]
            self.tree.insertElement(token)
            #Need to get the parse error right for the case where the token 
            #has a namespace not equal to the xmlns attribute
            if token["selfClosing"]:
                self.tree.openElements.pop()
                token["selfClosingAcknowledged"] = True

        def startTagSvg(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.parser.adjustSVGAttributes(token)
            self.parser.adjustForeignAttributes(token)
            token["namespace"] = namespaces["svg"]
            self.tree.insertElement(token)
            #Need to get the parse error right for the case where the token 
            #has a namespace not equal to the xmlns attribute
            if token["selfClosing"]:
                self.tree.openElements.pop()
                token["selfClosingAcknowledged"] = True

        def startTagMisplaced(self, token):
            """ Elements that should be children of other elements that have a
            different insertion mode; here they are ignored
            "caption", "col", "colgroup", "frame", "frameset", "head",
            "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
            "tr", "noscript"
            """
            self.parser.parseError("unexpected-start-tag-ignored", {"name": token["name"]})

        def startTagOther(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)

        def endTagP(self, token):
            if not self.tree.elementInScope("p", variant="button"):
                self.startTagCloseP(impliedTagToken("p", "StartTag"))
                self.parser.parseError("unexpected-end-tag", {"name": "p"})
                self.endTagP(impliedTagToken("p", "EndTag"))
            else:
                self.tree.generateImpliedEndTags("p")
                if self.tree.openElements[-1].name != "p":
                    self.parser.parseError("unexpected-end-tag", {"name": "p"})
                node = self.tree.openElements.pop()
                while node.name != "p":
                    node = self.tree.openElements.pop()

        def endTagBody(self, token):
            if not self.tree.elementInScope("body"):
                self.parser.parseError()
                return
            elif self.tree.openElements[-1].name != "body":
                for node in self.tree.openElements[2:]:
                    if node.name not in frozenset(("dd", "dt", "li", "optgroup",
                                                   "option", "p", "rp", "rt",
                                                   "tbody", "td", "tfoot",
                                                   "th", "thead", "tr", "body",
                                                   "html")):
                        #Not sure this is the correct name for the parse error
                        self.parser.parseError(
                            "expected-one-end-tag-but-got-another",
                            {"expectedName": "body", "gotName": node.name})
                        break
            self.parser.phase = self.parser.phases["afterBody"]

        def endTagHtml(self, token):
            #We repeat the test for the body end tag token being ignored here
            if self.tree.elementInScope("body"):
                self.endTagBody(impliedTagToken("body"))
                return token

        def endTagBlock(self, token):
            #Put us back in the right whitespace handling mode
            if token["name"] == "pre":
                self.processSpaceCharacters = self.processSpaceCharactersNonPre
            inScope = self.tree.elementInScope(token["name"])
            if inScope:
                self.tree.generateImpliedEndTags()
            if self.tree.openElements[-1].name != token["name"]:
                 self.parser.parseError("end-tag-too-early", {"name": token["name"]})
            if inScope:
                node = self.tree.openElements.pop()
                while node.name != token["name"]:
                    node = self.tree.openElements.pop()

        def endTagForm(self, token):
            node = self.tree.formPointer
            self.tree.formPointer = None
            if node is None or not self.tree.elementInScope(node):
                self.parser.parseError("unexpected-end-tag",
                                       {"name":"form"})
            else:
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1] != node:
                    self.parser.parseError("end-tag-too-early-ignored",
                                           {"name": "form"})
                self.tree.openElements.remove(node)

        def endTagListItem(self, token):
            if token["name"] == "li":
                variant = "list"
            else:
                variant = None
            if not self.tree.elementInScope(token["name"], variant=variant):
                self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
            else:
                self.tree.generateImpliedEndTags(exclude = token["name"])
                if self.tree.openElements[-1].name != token["name"]:
                    self.parser.parseError(
                        "end-tag-too-early",
                        {"name": token["name"]})
                node = self.tree.openElements.pop()
                while node.name != token["name"]:
                    node = self.tree.openElements.pop()

        def endTagHeading(self, token):
            for item in headingElements:
                if self.tree.elementInScope(item):
                    self.tree.generateImpliedEndTags()
                    break
            if self.tree.openElements[-1].name != token["name"]:
                self.parser.parseError("end-tag-too-early", {"name": token["name"]})

            for item in headingElements:
                if self.tree.elementInScope(item):
                    item = self.tree.openElements.pop()
                    while item.name not in headingElements:
                        item = self.tree.openElements.pop()
                    break

        def endTagFormatting(self, token):
            """The much-feared adoption agency algorithm"""
            # http://www.whatwg.org/specs/web-apps/current-work/#adoptionAgency
            # XXX Better parseError messages appreciated.
            name = token["name"]

            outerLoopCounter = 0
            while outerLoopCounter < 8:
                outerLoopCounter += 1

                # Step 1 paragraph 1
                formattingElement = self.tree.elementInActiveFormattingElements(
                    token["name"])
                if (not formattingElement or 
                    (formattingElement in self.tree.openElements and
                     not self.tree.elementInScope(formattingElement.name))):
                    self.parser.parseError("adoption-agency-1.1", {"name": token["name"]})
                    return

                # Step 1 paragraph 2
                elif formattingElement not in self.tree.openElements:
                    self.parser.parseError("adoption-agency-1.2", {"name": token["name"]})
                    self.tree.activeFormattingElements.remove(formattingElement)
                    return

                # Step 1 paragraph 3
                if formattingElement != self.tree.openElements[-1]:
                    self.parser.parseError("adoption-agency-1.3", {"name": token["name"]})

                # Step 2
                # Start of the adoption agency algorithm proper
                afeIndex = self.tree.openElements.index(formattingElement)
                furthestBlock = None
                for element in self.tree.openElements[afeIndex:]:
                    if element.nameTuple in specialElements:
                        furthestBlock = element
                        break
                # Step 3
                if furthestBlock is None:
                    element = self.tree.openElements.pop()
                    while element != formattingElement:
                        element = self.tree.openElements.pop()
                    self.tree.activeFormattingElements.remove(element)
                    return
                commonAncestor = self.tree.openElements[afeIndex-1]

                # Step 5
                #if furthestBlock.parent:
                #    furthestBlock.parent.removeChild(furthestBlock)

                # Step 5
                # The bookmark is supposed to help us identify where to reinsert
                # nodes in step 12. We have to ensure that we reinsert nodes after
                # the node before the active formatting element. Note the bookmark
                # can move in step 7.4
                bookmark = self.tree.activeFormattingElements.index(formattingElement)

                # Step 6
                lastNode = node = furthestBlock
                innerLoopCounter = 0
                
                index = self.tree.openElements.index(node)
                while innerLoopCounter < 3:
                    innerLoopCounter += 1
                    # Node is element before node in open elements
                    index -= 1
                    node = self.tree.openElements[index]
                    if node not in self.tree.activeFormattingElements:
                        self.tree.openElements.remove(node)
                        continue
                    # Step 6.3
                    if node == formattingElement:
                        break
                    # Step 6.4
                    if lastNode == furthestBlock:
                        bookmark = (self.tree.activeFormattingElements.index(node)
                                    + 1)
                    # Step 6.5
                    #cite = node.parent
                    clone = node.cloneNode()
                    # Replace node with clone
                    self.tree.activeFormattingElements[
                        self.tree.activeFormattingElements.index(node)] = clone
                    self.tree.openElements[
                        self.tree.openElements.index(node)] = clone
                    node = clone

                    # Step 6.6
                    # Remove lastNode from its parents, if any
                    if lastNode.parent:
                        lastNode.parent.removeChild(lastNode)
                    node.appendChild(lastNode)
                    # Step 7.7
                    lastNode = node
                    # End of inner loop 

                # Step 7
                # Foster parent lastNode if commonAncestor is a
                # table, tbody, tfoot, thead, or tr we need to foster parent the 
                # lastNode
                if lastNode.parent:
                    lastNode.parent.removeChild(lastNode)

                if commonAncestor.name in frozenset(("table", "tbody", "tfoot", "thead", "tr")):
                    parent, insertBefore = self.tree.getTableMisnestedNodePosition()
                    parent.insertBefore(lastNode, insertBefore)
                else:
                    commonAncestor.appendChild(lastNode)

                # Step 8
                clone = formattingElement.cloneNode()

                # Step 9
                furthestBlock.reparentChildren(clone)

                # Step 10
                furthestBlock.appendChild(clone)

                # Step 11
                self.tree.activeFormattingElements.remove(formattingElement)
                self.tree.activeFormattingElements.insert(bookmark, clone)

                # Step 12
                self.tree.openElements.remove(formattingElement)
                self.tree.openElements.insert(
                  self.tree.openElements.index(furthestBlock) + 1, clone)

        def endTagAppletMarqueeObject(self, token):
            if self.tree.elementInScope(token["name"]):
                self.tree.generateImpliedEndTags()
            if self.tree.openElements[-1].name != token["name"]:
                self.parser.parseError("end-tag-too-early", {"name": token["name"]})

            if self.tree.elementInScope(token["name"]):
                element = self.tree.openElements.pop()
                while element.name != token["name"]:
                    element = self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()

        def endTagBr(self, token):
            self.parser.parseError("unexpected-end-tag-treated-as",
              {"originalName": "br", "newName": "br element"})
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(impliedTagToken("br", "StartTag"))
            self.tree.openElements.pop()

        def endTagOther(self, token):
            for node in self.tree.openElements[::-1]:
                if node.name == token["name"]:
                    self.tree.generateImpliedEndTags(exclude=token["name"])
                    if self.tree.openElements[-1].name != token["name"]:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
                    while self.tree.openElements.pop() != node:
                        pass
                    break
                else:
                    if node.nameTuple in specialElements:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
                        break

    class TextPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([])
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([
                    ("script", self.endTagScript)])
            self.endTagHandler.default = self.endTagOther

        def processCharacters(self, token):
            self.tree.insertText(token["data"])

        def processEOF(self):
            self.parser.parseError("expected-named-closing-tag-but-got-eof", 
                                   self.tree.openElements[-1].name)
            self.tree.openElements.pop()
            self.parser.phase = self.parser.originalPhase
            return True

        def startTagOther(self, token):
            assert False, "Tried to process start tag %s in RCDATA/RAWTEXT mode"%token['name']

        def endTagScript(self, token):
            node = self.tree.openElements.pop()
            assert node.name == "script"
            self.parser.phase = self.parser.originalPhase
            #The rest of this method is all stuff that only happens if
            #document.write works

        def endTagOther(self, token):
            node = self.tree.openElements.pop()
            self.parser.phase = self.parser.originalPhase

    class InTablePhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("caption", self.startTagCaption),
                ("colgroup", self.startTagColgroup),
                ("col", self.startTagCol),
                (("tbody", "tfoot", "thead"), self.startTagRowGroup),
                (("td", "th", "tr"), self.startTagImplyTbody),
                ("table", self.startTagTable),
                (("style", "script"), self.startTagStyleScript),
                ("input", self.startTagInput),
                ("form", self.startTagForm)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("table", self.endTagTable),
                (("body", "caption", "col", "colgroup", "html", "tbody", "td",
                  "tfoot", "th", "thead", "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableContext(self):
            # "clear the stack back to a table context"
            while self.tree.openElements[-1].name not in ("table", "html"):
                #self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name":  self.tree.openElements[-1].name})
                self.tree.openElements.pop()
            # When the current node is <html> it's an innerHTML case

        # processing methods
        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-table")
            else:
                assert self.parser.innerHTML
            #Stop parsing

        def processSpaceCharacters(self, token):
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"]
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processSpaceCharacters(token)

        def processCharacters(self, token):
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"]
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processCharacters(token)

        def insertText(self, token):
            #If we get here there must be at least one non-whitespace character
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processCharacters(token)
            self.tree.insertFromTable = False

        def startTagCaption(self, token):
            self.clearStackToTableContext()
            self.tree.activeFormattingElements.append(Marker)
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inCaption"]

        def startTagColgroup(self, token):
            self.clearStackToTableContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inColumnGroup"]

        def startTagCol(self, token):
            self.startTagColgroup(impliedTagToken("colgroup", "StartTag"))
            return token

        def startTagRowGroup(self, token):
            self.clearStackToTableContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inTableBody"]

        def startTagImplyTbody(self, token):
            self.startTagRowGroup(impliedTagToken("tbody", "StartTag"))
            return token

        def startTagTable(self, token):
            self.parser.parseError("unexpected-start-tag-implies-end-tag",
              {"startName": "table", "endName": "table"})
            self.parser.phase.processEndTag(impliedTagToken("table"))
            if not self.parser.innerHTML:
                return token

        def startTagStyleScript(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagInput(self, token):
            if ("type" in token["data"] and 
                token["data"]["type"].translate(asciiUpper2Lower) == "hidden"):
                self.parser.parseError("unexpected-hidden-input-in-table")
                self.tree.insertElement(token)
                # XXX associate with form
                self.tree.openElements.pop()
            else:
                self.startTagOther(token)

        def startTagForm(self, token):
            self.parser.parseError("unexpected-form-in-table")
            if self.tree.formPointer is None:
                self.tree.insertElement(token)
                self.tree.formPointer = self.tree.openElements[-1]
                self.tree.openElements.pop()

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processStartTag(token)
            self.tree.insertFromTable = False

        def endTagTable(self, token):
            if self.tree.elementInScope("table", variant="table"):
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "table":
                    self.parser.parseError("end-tag-too-early-named",
                      {"gotName": "table",
                       "expectedName": self.tree.openElements[-1].name})
                while self.tree.openElements[-1].name != "table":
                    self.tree.openElements.pop()
                self.tree.openElements.pop()
                self.parser.resetInsertionMode()
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processEndTag(token)
            self.tree.insertFromTable = False

    class InTableTextPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.originalPhase = None
            self.characterTokens = []

        def flushCharacters(self):
            data = "".join([item["data"] for item in self.characterTokens])
            if any([item not in spaceCharacters for item in data]):
                token = {"type":tokenTypes["Characters"], "data":data}
                self.parser.phases["inTable"].insertText(token)
            elif data:
                self.tree.insertText(data)
            self.characterTokens = []

        def processComment(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token

        def processEOF(self):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return True

        def processCharacters(self, token):
            if token["data"] == u"\u0000":
                return
            self.characterTokens.append(token)

        def processSpaceCharacters(self, token):
            #pretty sure we should never reach here
            self.characterTokens.append(token)
    #        assert False

        def processStartTag(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token

        def processEndTag(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token


    class InCaptionPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-caption
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.startTagTableElement)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("caption", self.endTagCaption),
                ("table", self.endTagTable),
                (("body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagCaption(self):
            return not self.tree.elementInScope("caption", variant="table")

        def processEOF(self):
            self.parser.phases["inBody"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inBody"].processCharacters(token)

        def startTagTableElement(self, token):
            self.parser.parseError()
            #XXX Have to duplicate logic here to find out if the tag is ignored
            ignoreEndTag = self.ignoreEndTagCaption()
            self.parser.phase.processEndTag(impliedTagToken("caption"))
            if not ignoreEndTag:
                return token

        def startTagOther(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def endTagCaption(self, token):
            if not self.ignoreEndTagCaption():
                # AT this code is quite similar to endTagTable in "InTable"
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "caption":
                    self.parser.parseError("expected-one-end-tag-but-got-another",
                      {"gotName": "caption",
                       "expectedName": self.tree.openElements[-1].name})
                while self.tree.openElements[-1].name != "caption":
                    self.tree.openElements.pop()
                self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()
                self.parser.phase = self.parser.phases["inTable"]
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagTable(self, token):
            self.parser.parseError()
            ignoreEndTag = self.ignoreEndTagCaption()
            self.parser.phase.processEndTag(impliedTagToken("caption"))
            if not ignoreEndTag:
                return token

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inBody"].processEndTag(token)


    class InColumnGroupPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-column

        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("col", self.startTagCol)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("colgroup", self.endTagColgroup),
                ("col", self.endTagCol)
            ])
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagColgroup(self):
            return self.tree.openElements[-1].name == "html"

        def processEOF(self):
            if self.tree.openElements[-1].name == "html":
                assert self.parser.innerHTML
                return
            else:
                ignoreEndTag = self.ignoreEndTagColgroup()
                self.endTagColgroup(impliedTagToken("colgroup"))
                if not ignoreEndTag:
                    return True

        def processCharacters(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token

        def startTagCol(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()

        def startTagOther(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token

        def endTagColgroup(self, token):
            if self.ignoreEndTagColgroup():
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()
            else:
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTable"]

        def endTagCol(self, token):
            self.parser.parseError("no-end-tag", {"name": "col"})

        def endTagOther(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token


    class InTableBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table0
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("tr", self.startTagTr),
                (("td", "th"), self.startTagTableCell),
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead"),
                 self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("tbody", "tfoot", "thead"), self.endTagTableRowGroup),
                ("table", self.endTagTable),
                (("body", "caption", "col", "colgroup", "html", "td", "th",
                  "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableBodyContext(self):
            while self.tree.openElements[-1].name not in ("tbody", "tfoot",
              "thead", "html"):
                #self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name": self.tree.openElements[-1].name})
                self.tree.openElements.pop()
            if self.tree.openElements[-1].name == "html":
                assert self.parser.innerHTML

        # the rest
        def processEOF(self):
            self.parser.phases["inTable"].processEOF()

        def processSpaceCharacters(self, token):
            return self.parser.phases["inTable"].processSpaceCharacters(token)

        def processCharacters(self, token):
            return self.parser.phases["inTable"].processCharacters(token)

        def startTagTr(self, token):
            self.clearStackToTableBodyContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inRow"]

        def startTagTableCell(self, token):
            self.parser.parseError("unexpected-cell-in-table-body", 
                                   {"name": token["name"]})
            self.startTagTr(impliedTagToken("tr", "StartTag"))
            return token

        def startTagTableOther(self, token):
            # XXX AT Any ideas on how to share this with endTagTable?
            if (self.tree.elementInScope("tbody", variant="table") or
                self.tree.elementInScope("thead", variant="table") or
                self.tree.elementInScope("tfoot", variant="table")):
                self.clearStackToTableBodyContext()
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1].name))
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def startTagOther(self, token):
            return self.parser.phases["inTable"].processStartTag(token)

        def endTagTableRowGroup(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.clearStackToTableBodyContext()
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTable"]
            else:
                self.parser.parseError("unexpected-end-tag-in-table-body",
                  {"name": token["name"]})

        def endTagTable(self, token):
            if (self.tree.elementInScope("tbody", variant="table") or
                self.tree.elementInScope("thead", variant="table") or
                self.tree.elementInScope("tfoot", variant="table")):
                self.clearStackToTableBodyContext()
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1].name))
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag-in-table-body",
              {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inTable"].processEndTag(token)


    class InRowPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-row
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("td", "th"), self.startTagTableCell),
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead",
                  "tr"), self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("tr", self.endTagTr),
                ("table", self.endTagTable),
                (("tbody", "tfoot", "thead"), self.endTagTableRowGroup),
                (("body", "caption", "col", "colgroup", "html", "td", "th"),
                  self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods (XXX unify this with other table helper methods)
        def clearStackToTableRowContext(self):
            while self.tree.openElements[-1].name not in ("tr", "html"):
                self.parser.parseError("unexpected-implied-end-tag-in-table-row",
                  {"name": self.tree.openElements[-1].name})
                self.tree.openElements.pop()

        def ignoreEndTagTr(self):
            return not self.tree.elementInScope("tr", variant="table")

        # the rest
        def processEOF(self):
            self.parser.phases["inTable"].processEOF()

        def processSpaceCharacters(self, token):
            return self.parser.phases["inTable"].processSpaceCharacters(token)        

        def processCharacters(self, token):
            return self.parser.phases["inTable"].processCharacters(token)

        def startTagTableCell(self, token):
            self.clearStackToTableRowContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inCell"]
            self.tree.activeFormattingElements.append(Marker)

        def startTagTableOther(self, token):
            ignoreEndTag = self.ignoreEndTagTr()
            self.endTagTr(impliedTagToken("tr"))
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def startTagOther(self, token):
            return self.parser.phases["inTable"].processStartTag(token)

        def endTagTr(self, token):
            if not self.ignoreEndTagTr():
                self.clearStackToTableRowContext()
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTableBody"]
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagTable(self, token):
            ignoreEndTag = self.ignoreEndTagTr()
            self.endTagTr(impliedTagToken("tr"))
            # Reprocess the current tag if the tr end tag was not ignored
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def endTagTableRowGroup(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.endTagTr(impliedTagToken("tr"))
                return token
            else:
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag-in-table-row",
                {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inTable"].processEndTag(token)

    class InCellPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-cell
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("td", "th"), self.endTagTableCell),
                (("body", "caption", "col", "colgroup", "html"), self.endTagIgnore),
                (("table", "tbody", "tfoot", "thead", "tr"), self.endTagImply)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper
        def closeCell(self):
            if self.tree.elementInScope("td", variant="table"):
                self.endTagTableCell(impliedTagToken("td"))
            elif self.tree.elementInScope("th", variant="table"):
                self.endTagTableCell(impliedTagToken("th"))

        # the rest
        def processEOF(self):
            self.parser.phases["inBody"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inBody"].processCharacters(token)

        def startTagTableOther(self, token):
            if (self.tree.elementInScope("td", variant="table") or
                self.tree.elementInScope("th", variant="table")):
                self.closeCell()
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def startTagOther(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def endTagTableCell(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.tree.generateImpliedEndTags(token["name"])
                if self.tree.openElements[-1].name != token["name"]:
                    self.parser.parseError("unexpected-cell-end-tag",
                      {"name": token["name"]})
                    while True:
                        node = self.tree.openElements.pop()
                        if node.name == token["name"]:
                            break
                else:
                    self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()
                self.parser.phase = self.parser.phases["inRow"]
            else:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagImply(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.closeCell()
                return token
            else:
                # sometimes innerHTML case
                self.parser.parseError()

        def endTagOther(self, token):
            return self.parser.phases["inBody"].processEndTag(token)

    class InSelectPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("option", self.startTagOption),
                ("optgroup", self.startTagOptgroup),
                ("select", self.startTagSelect),
                (("input", "keygen", "textarea"), self.startTagInput),
                ("script", self.startTagScript)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("option", self.endTagOption),
                ("optgroup", self.endTagOptgroup),
                ("select", self.endTagSelect)
            ])
            self.endTagHandler.default = self.endTagOther

        # http://www.whatwg.org/specs/web-apps/current-work/#in-select
        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-select")
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token):
            if token["data"] == u"\u0000":
                return
            self.tree.insertText(token["data"])

        def startTagOption(self, token):
            # We need to imply </option> if <option> is the current node.
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagOptgroup(self, token):
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            if self.tree.openElements[-1].name == "optgroup":
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagSelect(self, token):
            self.parser.parseError("unexpected-select-in-select")
            self.endTagSelect(impliedTagToken("select"))

        def startTagInput(self, token):
            self.parser.parseError("unexpected-input-in-select")
            if self.tree.elementInScope("select", variant="select"):
                self.endTagSelect(impliedTagToken("select"))
                return token
            else:
                assert self.parser.innerHTML

        def startTagScript(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-in-select",
              {"name": token["name"]})

        def endTagOption(self, token):
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                  {"name": "option"})

        def endTagOptgroup(self, token):
            # </optgroup> implicitly closes <option>
            if (self.tree.openElements[-1].name == "option" and
                self.tree.openElements[-2].name == "optgroup"):
                self.tree.openElements.pop()
            # It also closes </optgroup>
            if self.tree.openElements[-1].name == "optgroup":
                self.tree.openElements.pop()
            # But nothing else
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                  {"name": "optgroup"})

        def endTagSelect(self, token):
            if self.tree.elementInScope("select", variant="select"):
                node = self.tree.openElements.pop()
                while node.name != "select":
                    node = self.tree.openElements.pop()
                self.parser.resetInsertionMode()
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-in-select",
              {"name": token["name"]})


    class InSelectInTablePhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
                 self.startTagTable)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
                 self.endTagTable)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.parser.phases["inSelect"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inSelect"].processCharacters(token)

        def startTagTable(self, token):
            self.parser.parseError("unexpected-table-element-start-tag-in-select-in-table", {"name": token["name"]})
            self.endTagOther(impliedTagToken("select"))
            return token

        def startTagOther(self, token):
            return self.parser.phases["inSelect"].processStartTag(token)

        def endTagTable(self, token):
            self.parser.parseError("unexpected-table-element-end-tag-in-select-in-table", {"name": token["name"]})
            if self.tree.elementInScope(token["name"], variant="table"):
                self.endTagOther(impliedTagToken("select"))
                return token

        def endTagOther(self, token):
            return self.parser.phases["inSelect"].processEndTag(token)


    class InForeignContentPhase(Phase):
        breakoutElements = frozenset(["b", "big", "blockquote", "body", "br", 
                                      "center", "code", "dd", "div", "dl", "dt",
                                      "em", "embed", "h1", "h2", "h3", 
                                      "h4", "h5", "h6", "head", "hr", "i", "img",
                                      "li", "listing", "menu", "meta", "nobr", 
                                      "ol", "p", "pre", "ruby", "s",  "small", 
                                      "span", "strong", "strike",  "sub", "sup", 
                                      "table", "tt", "u", "ul", "var"])
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

        def adjustSVGTagNames(self, token):
            replacements = {u"altglyph":u"altGlyph",
                            u"altglyphdef":u"altGlyphDef",
                            u"altglyphitem":u"altGlyphItem",
                            u"animatecolor":u"animateColor",
                            u"animatemotion":u"animateMotion",
                            u"animatetransform":u"animateTransform",
                            u"clippath":u"clipPath",
                            u"feblend":u"feBlend",
                            u"fecolormatrix":u"feColorMatrix",
                            u"fecomponenttransfer":u"feComponentTransfer",
                            u"fecomposite":u"feComposite",
                            u"feconvolvematrix":u"feConvolveMatrix",
                            u"fediffuselighting":u"feDiffuseLighting",
                            u"fedisplacementmap":u"feDisplacementMap",
                            u"fedistantlight":u"feDistantLight",
                            u"feflood":u"feFlood",
                            u"fefunca":u"feFuncA",
                            u"fefuncb":u"feFuncB",
                            u"fefuncg":u"feFuncG",
                            u"fefuncr":u"feFuncR",
                            u"fegaussianblur":u"feGaussianBlur",
                            u"feimage":u"feImage",
                            u"femerge":u"feMerge",
                            u"femergenode":u"feMergeNode",
                            u"femorphology":u"feMorphology",
                            u"feoffset":u"feOffset",
                            u"fepointlight":u"fePointLight",
                            u"fespecularlighting":u"feSpecularLighting",
                            u"fespotlight":u"feSpotLight",
                            u"fetile":u"feTile",
                            u"feturbulence":u"feTurbulence",
                            u"foreignobject":u"foreignObject",
                            u"glyphref":u"glyphRef",
                            u"lineargradient":u"linearGradient",
                            u"radialgradient":u"radialGradient",
                            u"textpath":u"textPath"}

            if token["name"] in replacements:
                token["name"] = replacements[token["name"]]

        def processCharacters(self, token):
            if token["data"] == u"\u0000":
                token["data"] = u"\uFFFD"
            elif (self.parser.framesetOK and 
                  any(char not in spaceCharacters for char in token["data"])):
                self.parser.framesetOK = False
            Phase.processCharacters(self, token)

        def processStartTag(self, token):
            currentNode = self.tree.openElements[-1]
            if (token["name"] in self.breakoutElements or
                (token["name"] == "font" and
                 set(token["data"].keys()) & set(["color", "face", "size"]))):
                self.parser.parseError("unexpected-html-element-in-foreign-content",
                                       token["name"])
                while (self.tree.openElements[-1].namespace !=
                       self.tree.defaultNamespace and 
                       not self.parser.isHTMLIntegrationPoint(self.tree.openElements[-1]) and
                       not self.parser.isMathMLTextIntegrationPoint(self.tree.openElements[-1])):
                    self.tree.openElements.pop()
                return token

            else:
                if currentNode.namespace == namespaces["mathml"]:
                    self.parser.adjustMathMLAttributes(token)
                elif currentNode.namespace == namespaces["svg"]:
                    self.adjustSVGTagNames(token)
                    self.parser.adjustSVGAttributes(token)
                self.parser.adjustForeignAttributes(token)
                token["namespace"] = currentNode.namespace
                self.tree.insertElement(token)
                if token["selfClosing"]:
                    self.tree.openElements.pop()
                    token["selfClosingAcknowledged"] = True

        def processEndTag(self, token):
            nodeIndex = len(self.tree.openElements) - 1
            node = self.tree.openElements[-1]
            if node.name != token["name"]:
                self.parser.parseError("unexpected-end-tag", token["name"])

            while True:
                if node.name.translate(asciiUpper2Lower) == token["name"]:
                    #XXX this isn't in the spec but it seems necessary
                    if self.parser.phase == self.parser.phases["inTableText"]:
                        self.parser.phase.flushCharacters()
                        self.parser.phase = self.parser.phase.originalPhase
                    while self.tree.openElements.pop() != node:
                        assert self.tree.openElements
                    new_token = None
                    break
                nodeIndex -= 1

                node = self.tree.openElements[nodeIndex]
                if node.namespace != self.tree.defaultNamespace:
                    continue
                else:
                    new_token = self.parser.phase.processEndTag(token)
                    break
            return new_token


    class AfterBodyPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                    ("html", self.startTagHtml)
                    ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([("html", self.endTagHtml)])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            #Stop parsing
            pass

        def processComment(self, token):
            # This is needed because data is to be appended to the <html> element
            # here and not to whatever is currently open.
            self.tree.insertComment(token, self.tree.openElements[0])

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-after-body")
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-after-body",
              {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def endTagHtml(self,name):
            if self.parser.innerHTML:
                self.parser.parseError("unexpected-end-tag-after-body-innerhtml")
            else:
                self.parser.phase = self.parser.phases["afterAfterBody"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-after-body",
              {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

    class InFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-frameset
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("frameset", self.startTagFrameset),
                ("frame", self.startTagFrame),
                ("noframes", self.startTagNoframes)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("frameset", self.endTagFrameset)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-frameset")
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-in-frameset")

        def startTagFrameset(self, token):
            self.tree.insertElement(token)

        def startTagFrame(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()

        def startTagNoframes(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-in-frameset",
              {"name": token["name"]})

        def endTagFrameset(self, token):
            if self.tree.openElements[-1].name == "html":
                # innerHTML case
                self.parser.parseError("unexpected-frameset-in-frameset-innerhtml")
            else:
                self.tree.openElements.pop()
            if (not self.parser.innerHTML and
                self.tree.openElements[-1].name != "frameset"):
                # If we're not in innerHTML mode and the the current node is not a
                # "frameset" element (anymore) then switch.
                self.parser.phase = self.parser.phases["afterFrameset"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-in-frameset",
              {"name": token["name"]})


    class AfterFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#after3
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("noframes", self.startTagNoframes)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("html", self.endTagHtml)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            #Stop parsing
            pass

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-after-frameset")

        def startTagNoframes(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-after-frameset",
              {"name": token["name"]})

        def endTagHtml(self, token):
            self.parser.phase = self.parser.phases["afterAfterFrameset"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-after-frameset",
              {"name": token["name"]})


    class AfterAfterBodyPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml)
            ])
            self.startTagHandler.default = self.startTagOther

        def processEOF(self):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            return self.parser.phases["inBody"].processSpaceCharacters(token)

        def processCharacters(self, token):
            self.parser.parseError("expected-eof-but-got-char")
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("expected-eof-but-got-start-tag",
              {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def processEndTag(self, token):
            self.parser.parseError("expected-eof-but-got-end-tag",
              {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

    class AfterAfterFramesetPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("noframes", self.startTagNoFrames)
            ])
            self.startTagHandler.default = self.startTagOther

        def processEOF(self):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            return self.parser.phases["inBody"].processSpaceCharacters(token)

        def processCharacters(self, token):
            self.parser.parseError("expected-eof-but-got-char")

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagNoFrames(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("expected-eof-but-got-start-tag",
              {"name": token["name"]})

        def processEndTag(self, token):
            self.parser.parseError("expected-eof-but-got-end-tag",
              {"name": token["name"]})


    return {
        "initial": InitialPhase,
        "beforeHtml": BeforeHtmlPhase,
        "beforeHead": BeforeHeadPhase,
        "inHead": InHeadPhase,
        # XXX "inHeadNoscript": InHeadNoScriptPhase,
        "afterHead": AfterHeadPhase,
        "inBody": InBodyPhase,
        "text": TextPhase,
        "inTable": InTablePhase,
        "inTableText": InTableTextPhase,
        "inCaption": InCaptionPhase,
        "inColumnGroup": InColumnGroupPhase,
        "inTableBody": InTableBodyPhase,
        "inRow": InRowPhase,
        "inCell": InCellPhase,
        "inSelect": InSelectPhase,
        "inSelectInTable": InSelectInTablePhase,
        "inForeignContent": InForeignContentPhase,
        "afterBody": AfterBodyPhase,
        "inFrameset": InFramesetPhase,
        "afterFrameset": AfterFramesetPhase,
        "afterAfterBody": AfterAfterBodyPhase,
        "afterAfterFrameset": AfterAfterFramesetPhase,
        # XXX after after frameset
        }

def impliedTagToken(name, type="EndTag", attributes = None, 
                    selfClosing = False):
    if attributes is None:
        attributes = {}
    return {"type":tokenTypes[type], "name":unicode(name), "data":attributes,
            "selfClosing":selfClosing}

class ParseError(Exception):
    """Error in parsed document"""
    pass

########NEW FILE########
__FILENAME__ = ihatexml
import re

baseChar = """[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E] | [#x0141-#x0148] | [#x014A-#x017E] | [#x0180-#x01C3] | [#x01CD-#x01F0] | [#x01F4-#x01F5] | [#x01FA-#x0217] | [#x0250-#x02A8] | [#x02BB-#x02C1] | #x0386 | [#x0388-#x038A] | #x038C | [#x038E-#x03A1] | [#x03A3-#x03CE] | [#x03D0-#x03D6] | #x03DA | #x03DC | #x03DE | #x03E0 | [#x03E2-#x03F3] | [#x0401-#x040C] | [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] | [#x0490-#x04C4] | [#x04C7-#x04C8] | [#x04CB-#x04CC] | [#x04D0-#x04EB] | [#x04EE-#x04F5] | [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559 | [#x0561-#x0586] | [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] | [#x0641-#x064A] | [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] | [#x06D0-#x06D3] | #x06D5 | [#x06E5-#x06E6] | [#x0905-#x0939] | #x093D | [#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] | [#x0993-#x09A8] | [#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD] | [#x09DF-#x09E1] | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10] | [#x0A13-#x0A28] | [#x0A2A-#x0A30] | [#x0A32-#x0A33] | [#x0A35-#x0A36] | [#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74] | [#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8] | [#x0AAA-#x0AB0] | [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD | #x0AE0 | [#x0B05-#x0B0C] | [#x0B0F-#x0B10] | [#x0B13-#x0B28] | [#x0B2A-#x0B30] | [#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D | [#x0B5C-#x0B5D] | [#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90] | [#x0B92-#x0B95] | [#x0B99-#x0B9A] | #x0B9C | [#x0B9E-#x0B9F] | [#x0BA3-#x0BA4] | [#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9] | [#x0C05-#x0C0C] | [#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33] | [#x0C35-#x0C39] | [#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90] | [#x0C92-#x0CA8] | [#x0CAA-#x0CB3] | [#x0CB5-#x0CB9] | #x0CDE | [#x0CE0-#x0CE1] | [#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28] | [#x0D2A-#x0D39] | [#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30 | [#x0E32-#x0E33] | [#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84 | [#x0E87-#x0E88] | #x0E8A | #x0E8D | [#x0E94-#x0E97] | [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 | #x0EA7 | [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] | #x0EB0 | [#x0EB2-#x0EB3] | #x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69] | [#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103] | [#x1105-#x1107] | #x1109 | [#x110B-#x110C] | [#x110E-#x1112] | #x113C | #x113E | #x1140 | #x114C | #x114E | #x1150 | [#x1154-#x1155] | #x1159 | [#x115F-#x1161] | #x1163 | #x1165 | #x1167 | #x1169 | [#x116D-#x116E] | [#x1172-#x1173] | #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF] | [#x11B7-#x11B8] | #x11BA | [#x11BC-#x11C2] | #x11EB | #x11F0 | #x11F9 | [#x1E00-#x1E9B] | [#x1EA0-#x1EF9] | [#x1F00-#x1F15] | [#x1F18-#x1F1D] | [#x1F20-#x1F45] | [#x1F48-#x1F4D] | [#x1F50-#x1F57] | #x1F59 | #x1F5B | #x1F5D | [#x1F5F-#x1F7D] | [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE | [#x1FC2-#x1FC4] | [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] | [#x1FE0-#x1FEC] | [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 | [#x212A-#x212B] | #x212E | [#x2180-#x2182] | [#x3041-#x3094] | [#x30A1-#x30FA] | [#x3105-#x312C] | [#xAC00-#xD7A3]"""

ideographic = """[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]"""

combiningCharacter = """[#x0300-#x0345] | [#x0360-#x0361] | [#x0483-#x0486] | [#x0591-#x05A1] | [#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF | [#x05C1-#x05C2] | #x05C4 | [#x064B-#x0652] | #x0670 | [#x06D6-#x06DC] | [#x06DD-#x06DF] | [#x06E0-#x06E4] | [#x06E7-#x06E8] | [#x06EA-#x06ED] | [#x0901-#x0903] | #x093C | [#x093E-#x094C] | #x094D | [#x0951-#x0954] | [#x0962-#x0963] | [#x0981-#x0983] | #x09BC | #x09BE | #x09BF | [#x09C0-#x09C4] | [#x09C7-#x09C8] | [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02 | #x0A3C | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48] | [#x0A4B-#x0A4D] | [#x0A70-#x0A71] | [#x0A81-#x0A83] | #x0ABC | [#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03] | #x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D] | [#x0B56-#x0B57] | [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8] | [#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03] | [#x0C3E-#x0C44] | [#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83] | [#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6] | [#x0D02-#x0D03] | [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D] | #x0D57 | #x0E31 | [#x0E34-#x0E3A] | [#x0E47-#x0E4E] | #x0EB1 | [#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD] | [#x0F18-#x0F19] | #x0F35 | #x0F37 | #x0F39 | #x0F3E | #x0F3F | [#x0F71-#x0F84] | [#x0F86-#x0F8B] | [#x0F90-#x0F95] | #x0F97 | [#x0F99-#x0FAD] | [#x0FB1-#x0FB7] | #x0FB9 | [#x20D0-#x20DC] | #x20E1 | [#x302A-#x302F] | #x3099 | #x309A"""

digit = """[#x0030-#x0039] | [#x0660-#x0669] | [#x06F0-#x06F9] | [#x0966-#x096F] | [#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF] | [#x0B66-#x0B6F] | [#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF] | [#x0D66-#x0D6F] | [#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29]"""

extender = """#x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] | [#x30FC-#x30FE]"""

letter = " | ".join([baseChar, ideographic])

#Without the 
name = " | ".join([letter, digit, ".", "-", "_", combiningCharacter, 
                       extender])
nameFirst = " | ".join([letter, "_"])

reChar = re.compile(r"#x([\d|A-F]{4,4})")
reCharRange = re.compile(r"\[#x([\d|A-F]{4,4})-#x([\d|A-F]{4,4})\]")

def charStringToList(chars):
    charRanges = [item.strip() for item in chars.split(" | ")]
    rv = []
    for item in charRanges:
        foundMatch = False
        for regexp in (reChar, reCharRange):
            match = regexp.match(item)
            if match is not None:
                rv.append([hexToInt(item) for item in match.groups()])
                if len(rv[-1]) == 1:
                    rv[-1] = rv[-1]*2
                foundMatch = True
                break
        if not foundMatch:
            assert len(item) == 1
            
            rv.append([ord(item)] * 2)
    rv = normaliseCharList(rv)
    return rv

def normaliseCharList(charList):
    charList = sorted(charList)
    for item in charList:
        assert item[1] >= item[0]
    rv = []
    i = 0
    while i < len(charList):
        j = 1
        rv.append(charList[i])
        while i + j < len(charList) and charList[i+j][0] <= rv[-1][1] + 1:
            rv[-1][1] = charList[i+j][1]
            j += 1
        i += j
    return rv

#We don't really support characters above the BMP :(
max_unicode = int("FFFF", 16)
    
def missingRanges(charList):
    rv = []
    if charList[0] != 0:
        rv.append([0, charList[0][0] - 1])
    for i, item in enumerate(charList[:-1]):
        rv.append([item[1]+1, charList[i+1][0] - 1])
    if charList[-1][1] != max_unicode:
        rv.append([charList[-1][1] + 1, max_unicode])
    return rv

def listToRegexpStr(charList):
    rv = []
    for item in charList:
        if item[0] == item[1]:
           rv.append(escapeRegexp(unichr(item[0])))
        else:
            rv.append(escapeRegexp(unichr(item[0])) + "-" +
                      escapeRegexp(unichr(item[1])))
    return "[%s]"%"".join(rv)

def hexToInt(hex_str):
    return int(hex_str, 16)

def escapeRegexp(string):
    specialCharacters = (".", "^", "$", "*", "+", "?", "{", "}",
                          "[", "]", "|", "(", ")", "-")
    for char in specialCharacters:
        string = string.replace(char, "\\" + char)
        if char in string:
            print string

    return string

#output from the above
nonXmlNameBMPRegexp = re.compile(u'[\x00-,/:-@\\[-\\^`\\{-\xb6\xb8-\xbf\xd7\xf7\u0132-\u0133\u013f-\u0140\u0149\u017f\u01c4-\u01cc\u01f1-\u01f3\u01f6-\u01f9\u0218-\u024f\u02a9-\u02ba\u02c2-\u02cf\u02d2-\u02ff\u0346-\u035f\u0362-\u0385\u038b\u038d\u03a2\u03cf\u03d7-\u03d9\u03db\u03dd\u03df\u03e1\u03f4-\u0400\u040d\u0450\u045d\u0482\u0487-\u048f\u04c5-\u04c6\u04c9-\u04ca\u04cd-\u04cf\u04ec-\u04ed\u04f6-\u04f7\u04fa-\u0530\u0557-\u0558\u055a-\u0560\u0587-\u0590\u05a2\u05ba\u05be\u05c0\u05c3\u05c5-\u05cf\u05eb-\u05ef\u05f3-\u0620\u063b-\u063f\u0653-\u065f\u066a-\u066f\u06b8-\u06b9\u06bf\u06cf\u06d4\u06e9\u06ee-\u06ef\u06fa-\u0900\u0904\u093a-\u093b\u094e-\u0950\u0955-\u0957\u0964-\u0965\u0970-\u0980\u0984\u098d-\u098e\u0991-\u0992\u09a9\u09b1\u09b3-\u09b5\u09ba-\u09bb\u09bd\u09c5-\u09c6\u09c9-\u09ca\u09ce-\u09d6\u09d8-\u09db\u09de\u09e4-\u09e5\u09f2-\u0a01\u0a03-\u0a04\u0a0b-\u0a0e\u0a11-\u0a12\u0a29\u0a31\u0a34\u0a37\u0a3a-\u0a3b\u0a3d\u0a43-\u0a46\u0a49-\u0a4a\u0a4e-\u0a58\u0a5d\u0a5f-\u0a65\u0a75-\u0a80\u0a84\u0a8c\u0a8e\u0a92\u0aa9\u0ab1\u0ab4\u0aba-\u0abb\u0ac6\u0aca\u0ace-\u0adf\u0ae1-\u0ae5\u0af0-\u0b00\u0b04\u0b0d-\u0b0e\u0b11-\u0b12\u0b29\u0b31\u0b34-\u0b35\u0b3a-\u0b3b\u0b44-\u0b46\u0b49-\u0b4a\u0b4e-\u0b55\u0b58-\u0b5b\u0b5e\u0b62-\u0b65\u0b70-\u0b81\u0b84\u0b8b-\u0b8d\u0b91\u0b96-\u0b98\u0b9b\u0b9d\u0ba0-\u0ba2\u0ba5-\u0ba7\u0bab-\u0bad\u0bb6\u0bba-\u0bbd\u0bc3-\u0bc5\u0bc9\u0bce-\u0bd6\u0bd8-\u0be6\u0bf0-\u0c00\u0c04\u0c0d\u0c11\u0c29\u0c34\u0c3a-\u0c3d\u0c45\u0c49\u0c4e-\u0c54\u0c57-\u0c5f\u0c62-\u0c65\u0c70-\u0c81\u0c84\u0c8d\u0c91\u0ca9\u0cb4\u0cba-\u0cbd\u0cc5\u0cc9\u0cce-\u0cd4\u0cd7-\u0cdd\u0cdf\u0ce2-\u0ce5\u0cf0-\u0d01\u0d04\u0d0d\u0d11\u0d29\u0d3a-\u0d3d\u0d44-\u0d45\u0d49\u0d4e-\u0d56\u0d58-\u0d5f\u0d62-\u0d65\u0d70-\u0e00\u0e2f\u0e3b-\u0e3f\u0e4f\u0e5a-\u0e80\u0e83\u0e85-\u0e86\u0e89\u0e8b-\u0e8c\u0e8e-\u0e93\u0e98\u0ea0\u0ea4\u0ea6\u0ea8-\u0ea9\u0eac\u0eaf\u0eba\u0ebe-\u0ebf\u0ec5\u0ec7\u0ece-\u0ecf\u0eda-\u0f17\u0f1a-\u0f1f\u0f2a-\u0f34\u0f36\u0f38\u0f3a-\u0f3d\u0f48\u0f6a-\u0f70\u0f85\u0f8c-\u0f8f\u0f96\u0f98\u0fae-\u0fb0\u0fb8\u0fba-\u109f\u10c6-\u10cf\u10f7-\u10ff\u1101\u1104\u1108\u110a\u110d\u1113-\u113b\u113d\u113f\u1141-\u114b\u114d\u114f\u1151-\u1153\u1156-\u1158\u115a-\u115e\u1162\u1164\u1166\u1168\u116a-\u116c\u116f-\u1171\u1174\u1176-\u119d\u119f-\u11a7\u11a9-\u11aa\u11ac-\u11ad\u11b0-\u11b6\u11b9\u11bb\u11c3-\u11ea\u11ec-\u11ef\u11f1-\u11f8\u11fa-\u1dff\u1e9c-\u1e9f\u1efa-\u1eff\u1f16-\u1f17\u1f1e-\u1f1f\u1f46-\u1f47\u1f4e-\u1f4f\u1f58\u1f5a\u1f5c\u1f5e\u1f7e-\u1f7f\u1fb5\u1fbd\u1fbf-\u1fc1\u1fc5\u1fcd-\u1fcf\u1fd4-\u1fd5\u1fdc-\u1fdf\u1fed-\u1ff1\u1ff5\u1ffd-\u20cf\u20dd-\u20e0\u20e2-\u2125\u2127-\u2129\u212c-\u212d\u212f-\u217f\u2183-\u3004\u3006\u3008-\u3020\u3030\u3036-\u3040\u3095-\u3098\u309b-\u309c\u309f-\u30a0\u30fb\u30ff-\u3104\u312d-\u4dff\u9fa6-\uabff\ud7a4-\uffff]')

nonXmlNameFirstBMPRegexp = re.compile(u'[\x00-@\\[-\\^`\\{-\xbf\xd7\xf7\u0132-\u0133\u013f-\u0140\u0149\u017f\u01c4-\u01cc\u01f1-\u01f3\u01f6-\u01f9\u0218-\u024f\u02a9-\u02ba\u02c2-\u0385\u0387\u038b\u038d\u03a2\u03cf\u03d7-\u03d9\u03db\u03dd\u03df\u03e1\u03f4-\u0400\u040d\u0450\u045d\u0482-\u048f\u04c5-\u04c6\u04c9-\u04ca\u04cd-\u04cf\u04ec-\u04ed\u04f6-\u04f7\u04fa-\u0530\u0557-\u0558\u055a-\u0560\u0587-\u05cf\u05eb-\u05ef\u05f3-\u0620\u063b-\u0640\u064b-\u0670\u06b8-\u06b9\u06bf\u06cf\u06d4\u06d6-\u06e4\u06e7-\u0904\u093a-\u093c\u093e-\u0957\u0962-\u0984\u098d-\u098e\u0991-\u0992\u09a9\u09b1\u09b3-\u09b5\u09ba-\u09db\u09de\u09e2-\u09ef\u09f2-\u0a04\u0a0b-\u0a0e\u0a11-\u0a12\u0a29\u0a31\u0a34\u0a37\u0a3a-\u0a58\u0a5d\u0a5f-\u0a71\u0a75-\u0a84\u0a8c\u0a8e\u0a92\u0aa9\u0ab1\u0ab4\u0aba-\u0abc\u0abe-\u0adf\u0ae1-\u0b04\u0b0d-\u0b0e\u0b11-\u0b12\u0b29\u0b31\u0b34-\u0b35\u0b3a-\u0b3c\u0b3e-\u0b5b\u0b5e\u0b62-\u0b84\u0b8b-\u0b8d\u0b91\u0b96-\u0b98\u0b9b\u0b9d\u0ba0-\u0ba2\u0ba5-\u0ba7\u0bab-\u0bad\u0bb6\u0bba-\u0c04\u0c0d\u0c11\u0c29\u0c34\u0c3a-\u0c5f\u0c62-\u0c84\u0c8d\u0c91\u0ca9\u0cb4\u0cba-\u0cdd\u0cdf\u0ce2-\u0d04\u0d0d\u0d11\u0d29\u0d3a-\u0d5f\u0d62-\u0e00\u0e2f\u0e31\u0e34-\u0e3f\u0e46-\u0e80\u0e83\u0e85-\u0e86\u0e89\u0e8b-\u0e8c\u0e8e-\u0e93\u0e98\u0ea0\u0ea4\u0ea6\u0ea8-\u0ea9\u0eac\u0eaf\u0eb1\u0eb4-\u0ebc\u0ebe-\u0ebf\u0ec5-\u0f3f\u0f48\u0f6a-\u109f\u10c6-\u10cf\u10f7-\u10ff\u1101\u1104\u1108\u110a\u110d\u1113-\u113b\u113d\u113f\u1141-\u114b\u114d\u114f\u1151-\u1153\u1156-\u1158\u115a-\u115e\u1162\u1164\u1166\u1168\u116a-\u116c\u116f-\u1171\u1174\u1176-\u119d\u119f-\u11a7\u11a9-\u11aa\u11ac-\u11ad\u11b0-\u11b6\u11b9\u11bb\u11c3-\u11ea\u11ec-\u11ef\u11f1-\u11f8\u11fa-\u1dff\u1e9c-\u1e9f\u1efa-\u1eff\u1f16-\u1f17\u1f1e-\u1f1f\u1f46-\u1f47\u1f4e-\u1f4f\u1f58\u1f5a\u1f5c\u1f5e\u1f7e-\u1f7f\u1fb5\u1fbd\u1fbf-\u1fc1\u1fc5\u1fcd-\u1fcf\u1fd4-\u1fd5\u1fdc-\u1fdf\u1fed-\u1ff1\u1ff5\u1ffd-\u2125\u2127-\u2129\u212c-\u212d\u212f-\u217f\u2183-\u3006\u3008-\u3020\u302a-\u3040\u3095-\u30a0\u30fb-\u3104\u312d-\u4dff\u9fa6-\uabff\ud7a4-\uffff]')

class InfosetFilter(object):
    replacementRegexp = re.compile(r"U[\dA-F]{5,5}")
    def __init__(self, replaceChars = None,  
                 dropXmlnsLocalName = False, 
                 dropXmlnsAttrNs = False,
                 preventDoubleDashComments = False,
                 preventDashAtCommentEnd = False,
                 replaceFormFeedCharacters = True):

        self.dropXmlnsLocalName = dropXmlnsLocalName
        self.dropXmlnsAttrNs = dropXmlnsAttrNs

        self.preventDoubleDashComments = preventDoubleDashComments
        self.preventDashAtCommentEnd = preventDashAtCommentEnd

        self.replaceFormFeedCharacters = replaceFormFeedCharacters

        self.replaceCache = {}

    def coerceAttribute(self, name, namespace=None):
        if self.dropXmlnsLocalName and name.startswith("xmlns:"):
            #Need a datalosswarning here
            return None
        elif (self.dropXmlnsAttrNs and 
              namespace == "http://www.w3.org/2000/xmlns/"):
            return None
        else:
            return self.toXmlName(name)

    def coerceElement(self, name, namespace=None):
        return self.toXmlName(name)

    def coerceComment(self, data):
        if self.preventDoubleDashComments:
            while "--" in data:
                data = data.replace("--", "- -")
        return data
    
    def coerceCharacters(self, data):
        if self.replaceFormFeedCharacters:
            data = data.replace("\x0C", " ")
        #Other non-xml characters
        return data

    def toXmlName(self, name):
        nameFirst = name[0]
        nameRest = name[1:]
        m = nonXmlNameFirstBMPRegexp.match(nameFirst)
        if m:
            nameFirstOutput = self.getReplacementCharacter(nameFirst)
        else:
            nameFirstOutput = nameFirst

        nameRestOutput = nameRest
        replaceChars = set(nonXmlNameBMPRegexp.findall(nameRest))
        for char in replaceChars:
            replacement = self.getReplacementCharacter(char)
            nameRestOutput = nameRestOutput.replace(char, replacement)
        return nameFirstOutput + nameRestOutput
    
    def getReplacementCharacter(self, char):
        if char in self.replaceCache:
            replacement = self.replaceCache[char]
        else:
            replacement = self.escapeChar(char)
        return replacement

    def fromXmlName(self, name):
        for item in set(self.replacementRegexp.findall(name)):
            name = name.replace(item, self.unescapeChar(item))
        return name

    def escapeChar(self, char):
        replacement = "U" + hex(ord(char))[2:].upper().rjust(5, "0")
        self.replaceCache[char] = replacement
        return replacement

    def unescapeChar(self, charcode):
        return unichr(int(charcode[1:], 16))

########NEW FILE########
__FILENAME__ = inputstream
import codecs
import re
import types
import sys

from constants import EOF, spaceCharacters, asciiLetters, asciiUppercase
from constants import encodings, ReparseException
import utils

#Non-unicode versions of constants for use in the pre-parser
spaceCharactersBytes = frozenset([str(item) for item in spaceCharacters])
asciiLettersBytes = frozenset([str(item) for item in asciiLetters])
asciiUppercaseBytes = frozenset([str(item) for item in asciiUppercase])
spacesAngleBrackets = spaceCharactersBytes | frozenset([">", "<"])

invalid_unicode_re = re.compile(u"[\u0001-\u0008\u000B\u000E-\u001F\u007F-\u009F\uD800-\uDFFF\uFDD0-\uFDEF\uFFFE\uFFFF\U0001FFFE\U0001FFFF\U0002FFFE\U0002FFFF\U0003FFFE\U0003FFFF\U0004FFFE\U0004FFFF\U0005FFFE\U0005FFFF\U0006FFFE\U0006FFFF\U0007FFFE\U0007FFFF\U0008FFFE\U0008FFFF\U0009FFFE\U0009FFFF\U000AFFFE\U000AFFFF\U000BFFFE\U000BFFFF\U000CFFFE\U000CFFFF\U000DFFFE\U000DFFFF\U000EFFFE\U000EFFFF\U000FFFFE\U000FFFFF\U0010FFFE\U0010FFFF]")

non_bmp_invalid_codepoints = set([0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
                                  0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF,
                                  0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE,
                                  0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF,
                                  0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
                                  0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF,
                                  0x10FFFE, 0x10FFFF])

ascii_punctuation_re = re.compile(ur"[\u0009-\u000D\u0020-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]")

# Cache for charsUntil()
charsUntilRegEx = {}
        
class BufferedStream:
    """Buffering for streams that do not have buffering of their own

    The buffer is implemented as a list of chunks on the assumption that 
    joining many strings will be slow since it is O(n**2)
    """
    
    def __init__(self, stream):
        self.stream = stream
        self.buffer = []
        self.position = [-1,0] #chunk number, offset

    def tell(self):
        pos = 0
        for chunk in self.buffer[:self.position[0]]:
            pos += len(chunk)
        pos += self.position[1]
        return pos

    def seek(self, pos):
        assert pos < self._bufferedBytes()
        offset = pos
        i = 0
        while len(self.buffer[i]) < offset:
            offset -= pos
            i += 1
        self.position = [i, offset]

    def read(self, bytes):
        if not self.buffer:
            return self._readStream(bytes)
        elif (self.position[0] == len(self.buffer) and
              self.position[1] == len(self.buffer[-1])):
            return self._readStream(bytes)
        else:
            return self._readFromBuffer(bytes)
    
    def _bufferedBytes(self):
        return sum([len(item) for item in self.buffer])

    def _readStream(self, bytes):
        data = self.stream.read(bytes)
        self.buffer.append(data)
        self.position[0] += 1
        self.position[1] = len(data)
        return data

    def _readFromBuffer(self, bytes):
        remainingBytes = bytes
        rv = []
        bufferIndex = self.position[0]
        bufferOffset = self.position[1]
        while bufferIndex < len(self.buffer) and remainingBytes != 0:
            assert remainingBytes > 0
            bufferedData = self.buffer[bufferIndex]
            
            if remainingBytes <= len(bufferedData) - bufferOffset:
                bytesToRead = remainingBytes
                self.position = [bufferIndex, bufferOffset + bytesToRead]
            else:
                bytesToRead = len(bufferedData) - bufferOffset
                self.position = [bufferIndex, len(bufferedData)]
                bufferIndex += 1
            data = rv.append(bufferedData[bufferOffset: 
                                          bufferOffset + bytesToRead])
            remainingBytes -= bytesToRead

            bufferOffset = 0

        if remainingBytes:
            rv.append(self._readStream(remainingBytes))
        
        return "".join(rv)
        


class HTMLInputStream:
    """Provides a unicode stream of characters to the HTMLTokenizer.

    This class takes care of character encoding and removing or replacing
    incorrect byte-sequences and also provides column and line tracking.

    """

    _defaultChunkSize = 10240

    def __init__(self, source, encoding=None, parseMeta=True, chardet=True):
        """Initialises the HTMLInputStream.

        HTMLInputStream(source, [encoding]) -> Normalized stream from source
        for use by html5lib.

        source can be either a file-object, local filename or a string.

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)
        
        parseMeta - Look for a <meta> element containing encoding information

        """

        #Craziness
        if len(u"\U0010FFFF") == 1:
            self.reportCharacterErrors = self.characterErrorsUCS4
            self.replaceCharactersRegexp = re.compile(u"[\uD800-\uDFFF]")
        else:
            self.reportCharacterErrors = self.characterErrorsUCS2
            self.replaceCharactersRegexp = re.compile(u"([\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?<![\uD800-\uDBFF])[\uDC00-\uDFFF])")

        # List of where new lines occur
        self.newLines = [0]

        self.charEncoding = (codecName(encoding), "certain")

        # Raw Stream - for unicode objects this will encode to utf-8 and set
        #              self.charEncoding as appropriate
        self.rawStream = self.openStream(source)

        # Encoding Information
        #Number of bytes to use when looking for a meta element with
        #encoding information
        self.numBytesMeta = 512
        #Number of bytes to use when using detecting encoding using chardet
        self.numBytesChardet = 100
        #Encoding to use if no other information can be found
        self.defaultEncoding = "windows-1252"
        
        #Detect encoding iff no explicit "transport level" encoding is supplied
        if (self.charEncoding[0] is None):
            self.charEncoding = self.detectEncoding(parseMeta, chardet)


        self.reset()

    def reset(self):
        self.dataStream = codecs.getreader(self.charEncoding[0])(self.rawStream,
                                                                 'replace')

        self.chunk = u""
        self.chunkSize = 0
        self.chunkOffset = 0
        self.errors = []

        # number of (complete) lines in previous chunks
        self.prevNumLines = 0
        # number of columns in the last line of the previous chunk
        self.prevNumCols = 0
        
        #Deal with CR LF and surrogates split over chunk boundaries
        self._bufferedCharacter = None

    def openStream(self, source):
        """Produces a file object from source.

        source can be either a file object, local filename or a string.

        """
        # Already a file object
        if hasattr(source, 'read'):
            stream = source
        else:
            # Otherwise treat source as a string and convert to a file object
            if isinstance(source, unicode):
                source = source.encode('utf-8')
                self.charEncoding = ("utf-8", "certain")
            try:
                from io import BytesIO
            except:
                # 2to3 converts this line to: from io import StringIO  
                from cStringIO import StringIO as BytesIO
            stream = BytesIO(source)

        if (not(hasattr(stream, "tell") and hasattr(stream, "seek")) or
            stream is sys.stdin):
            stream = BufferedStream(stream)

        return stream

    def detectEncoding(self, parseMeta=True, chardet=True):
        #First look for a BOM
        #This will also read past the BOM if present
        encoding = self.detectBOM()
        confidence = "certain"
        #If there is no BOM need to look for meta elements with encoding 
        #information
        if encoding is None and parseMeta:
            encoding = self.detectEncodingMeta()
            confidence = "tentative"
        #Guess with chardet, if avaliable
        if encoding is None and chardet:
            confidence = "tentative"
            try:
                from chardet.universaldetector import UniversalDetector
                buffers = []
                detector = UniversalDetector()
                while not detector.done:
                    buffer = self.rawStream.read(self.numBytesChardet)
                    if not buffer:
                        break
                    buffers.append(buffer)
                    detector.feed(buffer)
                detector.close()
                encoding = detector.result['encoding']
                self.rawStream.seek(0)
            except ImportError:
                pass
        # If all else fails use the default encoding
        if encoding is None:
            confidence="tentative"
            encoding = self.defaultEncoding
        
        #Substitute for equivalent encodings:
        encodingSub = {"iso-8859-1":"windows-1252"}

        if encoding.lower() in encodingSub:
            encoding = encodingSub[encoding.lower()]

        return encoding, confidence

    def changeEncoding(self, newEncoding):
        newEncoding = codecName(newEncoding)
        if newEncoding in ("utf-16", "utf-16-be", "utf-16-le"):
            newEncoding = "utf-8"
        if newEncoding is None:
            return
        elif newEncoding == self.charEncoding[0]:
            self.charEncoding = (self.charEncoding[0], "certain")
        else:
            self.rawStream.seek(0)
            self.reset()
            self.charEncoding = (newEncoding, "certain")
            raise ReparseException, "Encoding changed from %s to %s"%(self.charEncoding[0], newEncoding)
            
    def detectBOM(self):
        """Attempts to detect at BOM at the start of the stream. If
        an encoding can be determined from the BOM return the name of the
        encoding otherwise return None"""
        bomDict = {
            codecs.BOM_UTF8: 'utf-8',
            codecs.BOM_UTF16_LE: 'utf-16-le', codecs.BOM_UTF16_BE: 'utf-16-be',
            codecs.BOM_UTF32_LE: 'utf-32-le', codecs.BOM_UTF32_BE: 'utf-32-be'
        }

        # Go to beginning of file and read in 4 bytes
        string = self.rawStream.read(4)

        # Try detecting the BOM using bytes from the string
        encoding = bomDict.get(string[:3])         # UTF-8
        seek = 3
        if not encoding:
            # Need to detect UTF-32 before UTF-16
            encoding = bomDict.get(string)         # UTF-32
            seek = 4
            if not encoding:
                encoding = bomDict.get(string[:2]) # UTF-16
                seek = 2

        # Set the read position past the BOM if one was found, otherwise
        # set it to the start of the stream
        self.rawStream.seek(encoding and seek or 0)

        return encoding

    def detectEncodingMeta(self):
        """Report the encoding declared by the meta element
        """
        buffer = self.rawStream.read(self.numBytesMeta)
        parser = EncodingParser(buffer)
        self.rawStream.seek(0)
        encoding = parser.getEncoding()
        
        if encoding in ("utf-16", "utf-16-be", "utf-16-le"):
            encoding = "utf-8"

        return encoding

    def _position(self, offset):
        chunk = self.chunk
        nLines = chunk.count(u'\n', 0, offset)
        positionLine = self.prevNumLines + nLines
        lastLinePos = chunk.rfind(u'\n', 0, offset)
        if lastLinePos == -1:
            positionColumn = self.prevNumCols + offset
        else:
            positionColumn = offset - (lastLinePos + 1)
        return (positionLine, positionColumn)

    def position(self):
        """Returns (line, col) of the current position in the stream."""
        line, col = self._position(self.chunkOffset)
        return (line+1, col)

    def char(self):
        """ Read one character from the stream or queue if available. Return
            EOF when EOF is reached.
        """
        # Read a new chunk from the input stream if necessary
        if self.chunkOffset >= self.chunkSize:
            if not self.readChunk():
                return EOF

        chunkOffset = self.chunkOffset
        char = self.chunk[chunkOffset]
        self.chunkOffset = chunkOffset + 1

        return char

    def readChunk(self, chunkSize=None):
        if chunkSize is None:
            chunkSize = self._defaultChunkSize

        self.prevNumLines, self.prevNumCols = self._position(self.chunkSize)

        self.chunk = u""
        self.chunkSize = 0
        self.chunkOffset = 0

        data = self.dataStream.read(chunkSize)
        
        #Deal with CR LF and surrogates broken across chunks
        if self._bufferedCharacter:
            data = self._bufferedCharacter + data
            self._bufferedCharacter = None
        elif not data:
            # We have no more data, bye-bye stream
            return False
        
        if len(data) > 1:
            lastv = ord(data[-1])
            if lastv == 0x0D or 0xD800 <= lastv <= 0xDBFF:
                self._bufferedCharacter = data[-1]
                data = data[:-1]
        
        self.reportCharacterErrors(data)
        
        # Replace invalid characters
        # Note U+0000 is dealt with in the tokenizer
        data = self.replaceCharactersRegexp.sub(u"\ufffd", data)
                    
        data = data.replace(u"\r\n", u"\n")
        data = data.replace(u"\r", u"\n")

        self.chunk = data
        self.chunkSize = len(data)

        return True

    def characterErrorsUCS4(self, data):
        for i in xrange(len(invalid_unicode_re.findall(data))):
            self.errors.append("invalid-codepoint")

    def characterErrorsUCS2(self, data):
        #Someone picked the wrong compile option
        #You lose
        skip = False
        import sys
        for match in invalid_unicode_re.finditer(data):
            if skip:
                continue
            codepoint = ord(match.group())
            pos = match.start()
            #Pretty sure there should be endianness issues here
            if utils.isSurrogatePair(data[pos:pos+2]):
                #We have a surrogate pair!
                char_val = utils.surrogatePairToCodepoint(data[pos:pos+2])
                if char_val in non_bmp_invalid_codepoints:
                    self.errors.append("invalid-codepoint")
                skip = True
            elif (codepoint >= 0xD800 and codepoint <= 0xDFFF and
                  pos == len(data) - 1):
                self.errors.append("invalid-codepoint")
            else:
                skip = False
                self.errors.append("invalid-codepoint")

    def charsUntil(self, characters, opposite = False):
        """ Returns a string of characters from the stream up to but not
        including any character in 'characters' or EOF. 'characters' must be
        a container that supports the 'in' method and iteration over its
        characters.
        """

        # Use a cache of regexps to find the required characters
        try:
            chars = charsUntilRegEx[(characters, opposite)]
        except KeyError:
            if __debug__:
                for c in characters: 
                    assert(ord(c) < 128)
            regex = u"".join([u"\\x%02x" % ord(c) for c in characters])
            if not opposite:
                regex = u"^%s" % regex
            chars = charsUntilRegEx[(characters, opposite)] = re.compile(u"[%s]+" % regex)

        rv = []

        while True:
            # Find the longest matching prefix
            m = chars.match(self.chunk, self.chunkOffset)
            if m is None:
                # If nothing matched, and it wasn't because we ran out of chunk,
                # then stop
                if self.chunkOffset != self.chunkSize:
                    break
            else:
                end = m.end()
                # If not the whole chunk matched, return everything
                # up to the part that didn't match
                if end != self.chunkSize:
                    rv.append(self.chunk[self.chunkOffset:end])
                    self.chunkOffset = end
                    break
            # If the whole remainder of the chunk matched,
            # use it all and read the next chunk
            rv.append(self.chunk[self.chunkOffset:])
            if not self.readChunk():
                # Reached EOF
                break

        r = u"".join(rv)
        return r

    def unget(self, char):
        # Only one character is allowed to be ungotten at once - it must
        # be consumed again before any further call to unget
        if char is not None:
            if self.chunkOffset == 0:
                # unget is called quite rarely, so it's a good idea to do
                # more work here if it saves a bit of work in the frequently
                # called char and charsUntil.
                # So, just prepend the ungotten character onto the current
                # chunk:
                self.chunk = char + self.chunk
                self.chunkSize += 1
            else:
                self.chunkOffset -= 1
                assert self.chunk[self.chunkOffset] == char

class EncodingBytes(str):
    """String-like object with an associated position and various extra methods
    If the position is ever greater than the string length then an exception is
    raised"""
    def __new__(self, value):
        return str.__new__(self, value.lower())

    def __init__(self, value):
        self._position=-1
    
    def __iter__(self):
        return self
    
    def next(self):
        p = self._position = self._position + 1
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        return self[p]

    def previous(self):
        p = self._position
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        self._position = p = p - 1
        return self[p]
    
    def setPosition(self, position):
        if self._position >= len(self):
            raise StopIteration
        self._position = position
    
    def getPosition(self):
        if self._position >= len(self):
            raise StopIteration
        if self._position >= 0:
            return self._position
        else:
            return None
    
    position = property(getPosition, setPosition)

    def getCurrentByte(self):
        return self[self.position]
    
    currentByte = property(getCurrentByte)

    def skip(self, chars=spaceCharactersBytes):
        """Skip past a list of characters"""
        p = self.position               # use property for the error-checking
        while p < len(self):
            c = self[p]
            if c not in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def skipUntil(self, chars):
        p = self.position
        while p < len(self):
            c = self[p]
            if c in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def matchBytes(self, bytes):
        """Look for a sequence of bytes at the start of a string. If the bytes 
        are found return True and advance the position to the byte after the 
        match. Otherwise return False and leave the position alone"""
        p = self.position
        data = self[p:p+len(bytes)]
        rv = data.startswith(bytes)
        if rv:
            self.position += len(bytes)
        return rv
    
    def jumpTo(self, bytes):
        """Look for the next sequence of bytes matching a given sequence. If
        a match is found advance the position to the last byte of the match"""
        newPosition = self[self.position:].find(bytes)
        if newPosition > -1:
            # XXX: This is ugly, but I can't see a nicer way to fix this.
            if self._position == -1:
                self._position = 0
            self._position += (newPosition + len(bytes)-1)
            return True
        else:
            raise StopIteration

class EncodingParser(object):
    """Mini parser for detecting character encoding from meta elements"""

    def __init__(self, data):
        """string - the data to work on for encoding detection"""
        self.data = EncodingBytes(data)
        self.encoding = None

    def getEncoding(self):
        methodDispatch = (
            ("<!--",self.handleComment),
            ("<meta",self.handleMeta),
            ("</",self.handlePossibleEndTag),
            ("<!",self.handleOther),
            ("<?",self.handleOther),
            ("<",self.handlePossibleStartTag))
        for byte in self.data:
            keepParsing = True
            for key, method in methodDispatch:
                if self.data.matchBytes(key):
                    try:
                        keepParsing = method()    
                        break
                    except StopIteration:
                        keepParsing=False
                        break
            if not keepParsing:
                break
        
        return self.encoding

    def handleComment(self):
        """Skip over comments"""
        return self.data.jumpTo("-->")

    def handleMeta(self):
        if self.data.currentByte not in spaceCharactersBytes:
            #if we have <meta not followed by a space so just keep going
            return True
        #We have a valid meta element we want to search for attributes
        while True:
            #Try to find the next attribute after the current position
            attr = self.getAttribute()
            if attr is None:
                return True
            else:
                if attr[0] == "charset":
                    tentativeEncoding = attr[1]
                    codec = codecName(tentativeEncoding)
                    if codec is not None:
                        self.encoding = codec
                        return False
                elif attr[0] == "content":
                    contentParser = ContentAttrParser(EncodingBytes(attr[1]))
                    tentativeEncoding = contentParser.parse()
                    codec = codecName(tentativeEncoding)
                    if codec is not None:
                        self.encoding = codec
                        return False

    def handlePossibleStartTag(self):
        return self.handlePossibleTag(False)

    def handlePossibleEndTag(self):
        self.data.next()
        return self.handlePossibleTag(True)

    def handlePossibleTag(self, endTag):
        data = self.data
        if data.currentByte not in asciiLettersBytes:
            #If the next byte is not an ascii letter either ignore this
            #fragment (possible start tag case) or treat it according to 
            #handleOther
            if endTag:
                data.previous()
                self.handleOther()
            return True
        
        c = data.skipUntil(spacesAngleBrackets)
        if c == "<":
            #return to the first step in the overall "two step" algorithm
            #reprocessing the < byte
            data.previous()
        else:
            #Read all attributes
            attr = self.getAttribute()
            while attr is not None:
                attr = self.getAttribute()
        return True

    def handleOther(self):
        return self.data.jumpTo(">")

    def getAttribute(self):
        """Return a name,value pair for the next attribute in the stream, 
        if one is found, or None"""
        data = self.data
        # Step 1 (skip chars)
        c = data.skip(spaceCharactersBytes | frozenset("/"))
        # Step 2
        if c in (">", None):
            return None
        # Step 3
        attrName = []
        attrValue = []
        #Step 4 attribute name
        while True:
            if c == "=" and attrName:   
                break
            elif c in spaceCharactersBytes:
                #Step 6!
                c = data.skip()
                c = data.next()
                break
            elif c in ("/", ">"):
                return "".join(attrName), ""
            elif c in asciiUppercaseBytes:
                attrName.append(c.lower())
            elif c == None:
                return None
            else:
                attrName.append(c)
            #Step 5
            c = data.next()
        #Step 7
        if c != "=":
            data.previous()
            return "".join(attrName), ""
        #Step 8
        data.next()
        #Step 9
        c = data.skip()
        #Step 10
        if c in ("'", '"'):
            #10.1
            quoteChar = c
            while True:
                #10.2
                c = data.next()
                #10.3
                if c == quoteChar:
                    data.next()
                    return "".join(attrName), "".join(attrValue)
                #10.4
                elif c in asciiUppercaseBytes:
                    attrValue.append(c.lower())
                #10.5
                else:
                    attrValue.append(c)
        elif c == ">":
            return "".join(attrName), ""
        elif c in asciiUppercaseBytes:
            attrValue.append(c.lower())
        elif c is None:
            return None
        else:
            attrValue.append(c)
        # Step 11
        while True:
            c = data.next()
            if c in spacesAngleBrackets:
                return "".join(attrName), "".join(attrValue)
            elif c in asciiUppercaseBytes:
                attrValue.append(c.lower())
            elif c is None:
                return None
            else:
                attrValue.append(c)


class ContentAttrParser(object):
    def __init__(self, data):
        self.data = data
    def parse(self):
        try:
            #Check if the attr name is charset 
            #otherwise return
            self.data.jumpTo("charset")
            self.data.position += 1
            self.data.skip()
            if not self.data.currentByte == "=":
                #If there is no = sign keep looking for attrs
                return None
            self.data.position += 1
            self.data.skip()
            #Look for an encoding between matching quote marks
            if self.data.currentByte in ('"', "'"):
                quoteMark = self.data.currentByte
                self.data.position += 1
                oldPosition = self.data.position
                if self.data.jumpTo(quoteMark):
                    return self.data[oldPosition:self.data.position]
                else:
                    return None
            else:
                #Unquoted value
                oldPosition = self.data.position
                try:
                    self.data.skipUntil(spaceCharactersBytes)
                    return self.data[oldPosition:self.data.position]
                except StopIteration:
                    #Return the whole remaining value
                    return self.data[oldPosition:]
        except StopIteration:
            return None


def codecName(encoding):
    """Return the python codec name corresponding to an encoding or None if the
    string doesn't correspond to a valid encoding."""
    if (encoding is not None and type(encoding) in types.StringTypes):
        canonicalName = ascii_punctuation_re.sub("", encoding).lower()
        return encodings.get(canonicalName, None)
    else:
        return None

########NEW FILE########
__FILENAME__ = sanitizer
import re
from xml.sax.saxutils import escape, unescape

from tokenizer import HTMLTokenizer
from constants import tokenTypes

class HTMLSanitizerMixin(object):
    """ sanitization of XHTML+MathML+SVG and of inline style attributes."""

    acceptable_elements = ['a', 'abbr', 'acronym', 'address', 'area',
        'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',
        'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',
        'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',
        'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',
        'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',
        'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'input', 'ins',
        'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',
        'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',
        'p', 'pre', 'progress', 'q', 's', 'samp', 'section', 'select',
        'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong',
        'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',
        'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video']
      
    mathml_elements = ['maction', 'math', 'merror', 'mfrac', 'mi',
        'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',
        'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',
        'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',
        'munderover', 'none']
      
    svg_elements = ['a', 'animate', 'animateColor', 'animateMotion',
        'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',
        'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',
        'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',
        'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',
        'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use']
        
    acceptable_attributes = ['abbr', 'accept', 'accept-charset', 'accesskey',
        'action', 'align', 'alt', 'autocomplete', 'autofocus', 'axis',
        'background', 'balance', 'bgcolor', 'bgproperties', 'border',
        'bordercolor', 'bordercolordark', 'bordercolorlight', 'bottompadding',
        'cellpadding', 'cellspacing', 'ch', 'challenge', 'char', 'charoff',
        'choff', 'charset', 'checked', 'cite', 'class', 'clear', 'color',
        'cols', 'colspan', 'compact', 'contenteditable', 'controls', 'coords',
        'data', 'datafld', 'datapagesize', 'datasrc', 'datetime', 'default',
        'delay', 'dir', 'disabled', 'draggable', 'dynsrc', 'enctype', 'end',
        'face', 'for', 'form', 'frame', 'galleryimg', 'gutter', 'headers',
        'height', 'hidefocus', 'hidden', 'high', 'href', 'hreflang', 'hspace',
        'icon', 'id', 'inputmode', 'ismap', 'keytype', 'label', 'leftspacing',
        'lang', 'list', 'longdesc', 'loop', 'loopcount', 'loopend',
        'loopstart', 'low', 'lowsrc', 'max', 'maxlength', 'media', 'method',
        'min', 'multiple', 'name', 'nohref', 'noshade', 'nowrap', 'open',
        'optimum', 'pattern', 'ping', 'point-size', 'prompt', 'pqg',
        'radiogroup', 'readonly', 'rel', 'repeat-max', 'repeat-min',
        'replace', 'required', 'rev', 'rightspacing', 'rows', 'rowspan',
        'rules', 'scope', 'selected', 'shape', 'size', 'span', 'src', 'start',
        'step', 'style', 'summary', 'suppress', 'tabindex', 'target',
        'template', 'title', 'toppadding', 'type', 'unselectable', 'usemap',
        'urn', 'valign', 'value', 'variable', 'volume', 'vspace', 'vrml',
        'width', 'wrap', 'xml:lang']

    mathml_attributes = ['actiontype', 'align', 'columnalign', 'columnalign',
        'columnalign', 'columnlines', 'columnspacing', 'columnspan', 'depth',
        'display', 'displaystyle', 'equalcolumns', 'equalrows', 'fence',
        'fontstyle', 'fontweight', 'frame', 'height', 'linethickness', 'lspace',
        'mathbackground', 'mathcolor', 'mathvariant', 'mathvariant', 'maxsize',
        'minsize', 'other', 'rowalign', 'rowalign', 'rowalign', 'rowlines',
        'rowspacing', 'rowspan', 'rspace', 'scriptlevel', 'selection',
        'separator', 'stretchy', 'width', 'width', 'xlink:href', 'xlink:show',
        'xlink:type', 'xmlns', 'xmlns:xlink']
  
    svg_attributes = ['accent-height', 'accumulate', 'additive', 'alphabetic',
        'arabic-form', 'ascent', 'attributeName', 'attributeType',
        'baseProfile', 'bbox', 'begin', 'by', 'calcMode', 'cap-height',
        'class', 'clip-path', 'color', 'color-rendering', 'content', 'cx',
        'cy', 'd', 'dx', 'dy', 'descent', 'display', 'dur', 'end', 'fill',
        'fill-opacity', 'fill-rule', 'font-family', 'font-size',
        'font-stretch', 'font-style', 'font-variant', 'font-weight', 'from',
        'fx', 'fy', 'g1', 'g2', 'glyph-name', 'gradientUnits', 'hanging',
        'height', 'horiz-adv-x', 'horiz-origin-x', 'id', 'ideographic', 'k',
        'keyPoints', 'keySplines', 'keyTimes', 'lang', 'marker-end',
        'marker-mid', 'marker-start', 'markerHeight', 'markerUnits',
        'markerWidth', 'mathematical', 'max', 'min', 'name', 'offset',
        'opacity', 'orient', 'origin', 'overline-position',
        'overline-thickness', 'panose-1', 'path', 'pathLength', 'points',
        'preserveAspectRatio', 'r', 'refX', 'refY', 'repeatCount',
        'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart',
        'rotate', 'rx', 'ry', 'slope', 'stemh', 'stemv', 'stop-color',
        'stop-opacity', 'strikethrough-position', 'strikethrough-thickness',
        'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap',
        'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity',
        'stroke-width', 'systemLanguage', 'target', 'text-anchor', 'to',
        'transform', 'type', 'u1', 'u2', 'underline-position',
        'underline-thickness', 'unicode', 'unicode-range', 'units-per-em',
        'values', 'version', 'viewBox', 'visibility', 'width', 'widths', 'x',
        'x-height', 'x1', 'x2', 'xlink:actuate', 'xlink:arcrole',
        'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type',
        'xml:base', 'xml:lang', 'xml:space', 'xmlns', 'xmlns:xlink', 'y',
        'y1', 'y2', 'zoomAndPan']

    attr_val_is_uri = ['href', 'src', 'cite', 'action', 'longdesc',
        'xlink:href', 'xml:base']

    svg_attr_val_allows_ref = ['clip-path', 'color-profile', 'cursor', 'fill',
        'filter', 'marker', 'marker-start', 'marker-mid', 'marker-end',
        'mask', 'stroke']

    svg_allow_local_href = ['altGlyph', 'animate', 'animateColor',
        'animateMotion', 'animateTransform', 'cursor', 'feImage', 'filter',
        'linearGradient', 'pattern', 'radialGradient', 'textpath', 'tref',
        'set', 'use']
  
    acceptable_css_properties = ['azimuth', 'background-color',
        'border-bottom-color', 'border-collapse', 'border-color',
        'border-left-color', 'border-right-color', 'border-top-color', 'clear',
        'color', 'cursor', 'direction', 'display', 'elevation', 'float', 'font',
        'font-family', 'font-size', 'font-style', 'font-variant', 'font-weight',
        'height', 'letter-spacing', 'line-height', 'overflow', 'pause',
        'pause-after', 'pause-before', 'pitch', 'pitch-range', 'richness',
        'speak', 'speak-header', 'speak-numeral', 'speak-punctuation',
        'speech-rate', 'stress', 'text-align', 'text-decoration', 'text-indent',
        'unicode-bidi', 'vertical-align', 'voice-family', 'volume',
        'white-space', 'width']
  
    acceptable_css_keywords = ['auto', 'aqua', 'black', 'block', 'blue',
        'bold', 'both', 'bottom', 'brown', 'center', 'collapse', 'dashed',
        'dotted', 'fuchsia', 'gray', 'green', '!important', 'italic', 'left',
        'lime', 'maroon', 'medium', 'none', 'navy', 'normal', 'nowrap', 'olive',
        'pointer', 'purple', 'red', 'right', 'solid', 'silver', 'teal', 'top',
        'transparent', 'underline', 'white', 'yellow']
  
    acceptable_svg_properties = [ 'fill', 'fill-opacity', 'fill-rule',
        'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
        'stroke-opacity']
  
    acceptable_protocols = [ 'ed2k', 'ftp', 'http', 'https', 'irc',
        'mailto', 'news', 'gopher', 'nntp', 'telnet', 'webcal',
        'xmpp', 'callto', 'feed', 'urn', 'aim', 'rsync', 'tag',
        'ssh', 'sftp', 'rtsp', 'afs' ]
  
    # subclasses may define their own versions of these constants
    allowed_elements = acceptable_elements + mathml_elements + svg_elements
    allowed_attributes = acceptable_attributes + mathml_attributes + svg_attributes
    allowed_css_properties = acceptable_css_properties
    allowed_css_keywords = acceptable_css_keywords
    allowed_svg_properties = acceptable_svg_properties
    allowed_protocols = acceptable_protocols

    # Sanitize the +html+, escaping all elements not in ALLOWED_ELEMENTS, and
    # stripping out all # attributes not in ALLOWED_ATTRIBUTES. Style
    # attributes are parsed, and a restricted set, # specified by
    # ALLOWED_CSS_PROPERTIES and ALLOWED_CSS_KEYWORDS, are allowed through.
    # attributes in ATTR_VAL_IS_URI are scanned, and only URI schemes specified
    # in ALLOWED_PROTOCOLS are allowed.
    #
    #   sanitize_html('<script> do_nasty_stuff() </script>')
    #    => &lt;script> do_nasty_stuff() &lt;/script>
    #   sanitize_html('<a href="javascript: sucker();">Click here for $100</a>')
    #    => <a>Click here for $100</a>
    def sanitize_token(self, token):

        # accommodate filters which use token_type differently
        token_type = token["type"]
        if token_type in tokenTypes.keys():
          token_type = tokenTypes[token_type]

        if token_type in (tokenTypes["StartTag"], tokenTypes["EndTag"], 
                             tokenTypes["EmptyTag"]):
            if token["name"] in self.allowed_elements:
                if token.has_key("data"):
                    attrs = dict([(name,val) for name,val in
                                  token["data"][::-1] 
                                  if name in self.allowed_attributes])
                    for attr in self.attr_val_is_uri:
                        if not attrs.has_key(attr):
                            continue
                        val_unescaped = re.sub("[`\000-\040\177-\240\s]+", '',
                                               unescape(attrs[attr])).lower()
                        #remove replacement characters from unescaped characters
                        val_unescaped = val_unescaped.replace(u"\ufffd", "")
                        if (re.match("^[a-z0-9][-+.a-z0-9]*:",val_unescaped) and
                            (val_unescaped.split(':')[0] not in 
                             self.allowed_protocols)):
                            del attrs[attr]
                    for attr in self.svg_attr_val_allows_ref:
                        if attr in attrs:
                            attrs[attr] = re.sub(r'url\s*\(\s*[^#\s][^)]+?\)',
                                                 ' ',
                                                 unescape(attrs[attr]))
                    if (token["name"] in self.svg_allow_local_href and
                        'xlink:href' in attrs and re.search('^\s*[^#\s].*',
                                                            attrs['xlink:href'])):
                        del attrs['xlink:href']
                    if attrs.has_key('style'):
                        attrs['style'] = self.sanitize_css(attrs['style'])
                    token["data"] = [[name,val] for name,val in attrs.items()]
                return token
            else:
                if token_type == tokenTypes["EndTag"]:
                    token["data"] = "</%s>" % token["name"]
                elif token["data"]:
                    attrs = ''.join([' %s="%s"' % (k,escape(v)) for k,v in token["data"]])
                    token["data"] = "<%s%s>" % (token["name"],attrs)
                else:
                    token["data"] = "<%s>" % token["name"]
                if token.get("selfClosing"):
                    token["data"]=token["data"][:-1] + "/>"

                if token["type"] in tokenTypes.keys():
                    token["type"] = "Characters"
                else:
                    token["type"] = tokenTypes["Characters"]

                del token["name"]
                return token
        elif token_type == tokenTypes["Comment"]:
            pass
        else:
            return token

    def sanitize_css(self, style):
        # disallow urls
        style=re.compile('url\s*\(\s*[^\s)]+?\s*\)\s*').sub(' ',style)

        # gauntlet
        if not re.match("""^([:,;#%.\sa-zA-Z0-9!]|\w-\w|'[\s\w]+'|"[\s\w]+"|\([\d,\s]+\))*$""", style): return ''
        if not re.match("^\s*([-\w]+\s*:[^:;]*(;\s*|$))*$", style): return ''

        clean = []
        for prop,value in re.findall("([-\w]+)\s*:\s*([^:;]*)",style):
          if not value: continue
          if prop.lower() in self.allowed_css_properties:
              clean.append(prop + ': ' + value + ';')
          elif prop.split('-')[0].lower() in ['background','border','margin',
                                              'padding']:
              for keyword in value.split():
                  if not keyword in self.acceptable_css_keywords and \
                      not re.match("^(#[0-9a-f]+|rgb\(\d+%?,\d*%?,?\d*%?\)?|\d{0,2}\.?\d{0,2}(cm|em|ex|in|mm|pc|pt|px|%|,|\))?)$",keyword):
                      break
              else:
                  clean.append(prop + ': ' + value + ';')
          elif prop.lower() in self.allowed_svg_properties:
              clean.append(prop + ': ' + value + ';')

        return ' '.join(clean)

class HTMLSanitizer(HTMLTokenizer, HTMLSanitizerMixin):
    def __init__(self, stream, encoding=None, parseMeta=True, useChardet=True,
                 lowercaseElementName=False, lowercaseAttrName=False, parser=None):
        #Change case matching defaults as we only output lowercase html anyway
        #This solution doesn't seem ideal...
        HTMLTokenizer.__init__(self, stream, encoding, parseMeta, useChardet,
                               lowercaseElementName, lowercaseAttrName, parser=parser)

    def __iter__(self):
        for token in HTMLTokenizer.__iter__(self):
            token = self.sanitize_token(token)
            if token:
                yield token

########NEW FILE########
__FILENAME__ = htmlserializer
try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import ImmutableSet as frozenset

import gettext
_ = gettext.gettext

from html5lib.constants import voidElements, booleanAttributes, spaceCharacters
from html5lib.constants import rcdataElements, entities, xmlEntities
from html5lib import utils
from xml.sax.saxutils import escape

spaceCharacters = u"".join(spaceCharacters)

try:
    from codecs import register_error, xmlcharrefreplace_errors
except ImportError:
    unicode_encode_errors = "strict"
else:
    unicode_encode_errors = "htmlentityreplace"

    from html5lib.constants import entities

    encode_entity_map = {}
    is_ucs4 = len(u"\U0010FFFF") == 1
    for k, v in entities.items():
        #skip multi-character entities
        if ((is_ucs4 and len(v) > 1) or
            (not is_ucs4 and len(v) > 2)):
            continue
        if v != "&":
            if len(v) == 2:
                v = utils.surrogatePairToCodepoint(v)
            else:
                try:
                    v = ord(v)
                except:
                    print v
                    raise
            if not v in encode_entity_map or k.islower():
                # prefer &lt; over &LT; and similarly for &amp;, &gt;, etc.
                encode_entity_map[v] = k

    def htmlentityreplace_errors(exc):
        if isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):
            res = []
            codepoints = []
            skip = False
            for i, c in enumerate(exc.object[exc.start:exc.end]):
                if skip:
                    skip = False
                    continue
                index = i + exc.start
                if utils.isSurrogatePair(exc.object[index:min([exc.end, index+2])]):
                    codepoint = utils.surrogatePairToCodepoint(exc.object[index:index+2])
                    skip = True
                else:
                    codepoint = ord(c)
                codepoints.append(codepoint)
            for cp in codepoints:
                e = encode_entity_map.get(cp)
                if e:
                    res.append("&")
                    res.append(e)
                    if not e.endswith(";"):
                        res.append(";")
                else:
                    res.append("&#x%s;"%(hex(cp)[2:]))
            return (u"".join(res), exc.end)
        else:
            return xmlcharrefreplace_errors(exc)

    register_error(unicode_encode_errors, htmlentityreplace_errors)

    del register_error


class HTMLSerializer(object):

    # attribute quoting options
    quote_attr_values = False
    quote_char = u'"'
    use_best_quote_char = True

    # tag syntax options
    omit_optional_tags = True
    minimize_boolean_attributes = True
    use_trailing_solidus = False
    space_before_trailing_solidus = True

    # escaping options
    escape_lt_in_attrs = False
    escape_rcdata = False
    resolve_entities = True

    # miscellaneous options
    inject_meta_charset = True
    strip_whitespace = False
    sanitize = False

    options = ("quote_attr_values", "quote_char", "use_best_quote_char",
          "minimize_boolean_attributes", "use_trailing_solidus",
          "space_before_trailing_solidus", "omit_optional_tags",
          "strip_whitespace", "inject_meta_charset", "escape_lt_in_attrs",
          "escape_rcdata", "resolve_entities", "sanitize")

    def __init__(self, **kwargs):
        """Initialize HTMLSerializer.

        Keyword options (default given first unless specified) include:

        inject_meta_charset=True|False
          Whether it insert a meta element to define the character set of the
          document.
        quote_attr_values=True|False
          Whether to quote attribute values that don't require quoting
          per HTML5 parsing rules.
        quote_char=u'"'|u"'"
          Use given quote character for attribute quoting. Default is to
          use double quote unless attribute value contains a double quote,
          in which case single quotes are used instead.
        escape_lt_in_attrs=False|True
          Whether to escape < in attribute values.
        escape_rcdata=False|True
          Whether to escape characters that need to be escaped within normal
          elements within rcdata elements such as style.
        resolve_entities=True|False
          Whether to resolve named character entities that appear in the
          source tree. The XML predefined entities &lt; &gt; &amp; &quot; &apos;
          are unaffected by this setting.
        strip_whitespace=False|True
          Whether to remove semantically meaningless whitespace. (This
          compresses all whitespace to a single space except within pre.)
        minimize_boolean_attributes=True|False
          Shortens boolean attributes to give just the attribute value,
          for example <input disabled="disabled"> becomes <input disabled>.
        use_trailing_solidus=False|True
          Includes a close-tag slash at the end of the start tag of void
          elements (empty elements whose end tag is forbidden). E.g. <hr/>.
        space_before_trailing_solidus=True|False
          Places a space immediately before the closing slash in a tag
          using a trailing solidus. E.g. <hr />. Requires use_trailing_solidus.
        sanitize=False|True
          Strip all unsafe or unknown constructs from output.
          See `html5lib user documentation`_
        omit_optional_tags=True|False
          Omit start/end tags that are optional.

        .. _html5lib user documentation: http://code.google.com/p/html5lib/wiki/UserDocumentation
        """
        if kwargs.has_key('quote_char'):
            self.use_best_quote_char = False
        for attr in self.options:
            setattr(self, attr, kwargs.get(attr, getattr(self, attr)))
        self.errors = []
        self.strict = False

    def encode(self, string):
        assert(isinstance(string, unicode))
        if self.encoding:
            return string.encode(self.encoding, unicode_encode_errors)
        else:
            return string

    def encodeStrict(self, string):
        assert(isinstance(string, unicode))
        if self.encoding:
            return string.encode(self.encoding, "strict")
        else:
            return string

    def serialize(self, treewalker, encoding=None):
        self.encoding = encoding
        in_cdata = False
        self.errors = []
        if encoding and self.inject_meta_charset:
            from html5lib.filters.inject_meta_charset import Filter
            treewalker = Filter(treewalker, encoding)
        # XXX: WhitespaceFilter should be used before OptionalTagFilter
        # for maximum efficiently of this latter filter
        if self.strip_whitespace:
            from html5lib.filters.whitespace import Filter
            treewalker = Filter(treewalker)
        if self.sanitize:
            from html5lib.filters.sanitizer import Filter
            treewalker = Filter(treewalker)
        if self.omit_optional_tags:
            from html5lib.filters.optionaltags import Filter
            treewalker = Filter(treewalker)
        for token in treewalker:
            type = token["type"]
            if type == "Doctype":
                doctype = u"<!DOCTYPE %s" % token["name"]
                
                if token["publicId"]:
                    doctype += u' PUBLIC "%s"' % token["publicId"]
                elif token["systemId"]:
                    doctype += u" SYSTEM"
                if token["systemId"]:                
                    if token["systemId"].find(u'"') >= 0:
                        if token["systemId"].find(u"'") >= 0:
                            self.serializeError(_("System identifer contains both single and double quote characters"))
                        quote_char = u"'"
                    else:
                        quote_char = u'"'
                    doctype += u" %s%s%s" % (quote_char, token["systemId"], quote_char)
                
                doctype += u">"
                yield self.encodeStrict(doctype)

            elif type in ("Characters", "SpaceCharacters"):
                if type == "SpaceCharacters" or in_cdata:
                    if in_cdata and token["data"].find("</") >= 0:
                        self.serializeError(_("Unexpected </ in CDATA"))
                    yield self.encode(token["data"])
                else:
                    yield self.encode(escape(token["data"]))

            elif type in ("StartTag", "EmptyTag"):
                name = token["name"]
                yield self.encodeStrict(u"<%s" % name)
                if name in rcdataElements and not self.escape_rcdata:
                    in_cdata = True
                elif in_cdata:
                    self.serializeError(_("Unexpected child element of a CDATA element"))
                attributes = []
                for (attr_namespace,attr_name),attr_value in sorted(token["data"].items()):
                    #TODO: Add namespace support here
                    k = attr_name
                    v = attr_value
                    yield self.encodeStrict(u' ')

                    yield self.encodeStrict(k)
                    if not self.minimize_boolean_attributes or \
                      (k not in booleanAttributes.get(name, tuple()) \
                      and k not in booleanAttributes.get("", tuple())):
                        yield self.encodeStrict(u"=")
                        if self.quote_attr_values or not v:
                            quote_attr = True
                        else:
                            quote_attr = reduce(lambda x,y: x or (y in v),
                                spaceCharacters + u">\"'=", False)
                        v = v.replace(u"&", u"&amp;")
                        if self.escape_lt_in_attrs: v = v.replace(u"<", u"&lt;")
                        if quote_attr:
                            quote_char = self.quote_char
                            if self.use_best_quote_char:
                                if u"'" in v and u'"' not in v:
                                    quote_char = u'"'
                                elif u'"' in v and u"'" not in v:
                                    quote_char = u"'"
                            if quote_char == u"'":
                                v = v.replace(u"'", u"&#39;")
                            else:
                                v = v.replace(u'"', u"&quot;")
                            yield self.encodeStrict(quote_char)
                            yield self.encode(v)
                            yield self.encodeStrict(quote_char)
                        else:
                            yield self.encode(v)
                if name in voidElements and self.use_trailing_solidus:
                    if self.space_before_trailing_solidus:
                        yield self.encodeStrict(u" /")
                    else:
                        yield self.encodeStrict(u"/")
                yield self.encode(u">")

            elif type == "EndTag":
                name = token["name"]
                if name in rcdataElements:
                    in_cdata = False
                elif in_cdata:
                    self.serializeError(_("Unexpected child element of a CDATA element"))
                yield self.encodeStrict(u"</%s>" % name)

            elif type == "Comment":
                data = token["data"]
                if data.find("--") >= 0:
                    self.serializeError(_("Comment contains --"))
                yield self.encodeStrict(u"<!--%s-->" % token["data"])

            elif type == "Entity":
                name = token["name"]
                key = name + ";"
                if not key in entities:
                    self.serializeError(_("Entity %s not recognized" % name))
                if self.resolve_entities and key not in xmlEntities:
                    data = entities[key]
                else:
                    data = u"&%s;" % name
                yield self.encodeStrict(data)

            else:
                self.serializeError(token["data"])

    def render(self, treewalker, encoding=None):
        if encoding:
            return "".join(list(self.serialize(treewalker, encoding)))
        else:
            return u"".join(list(self.serialize(treewalker)))

    def serializeError(self, data="XXX ERROR MESSAGE NEEDED"):
        # XXX The idea is to make data mandatory.
        self.errors.append(data)
        if self.strict:
            raise SerializeError

def SerializeError(Exception):
    """Error in serialized tree"""
    pass

########NEW FILE########
__FILENAME__ = xhtmlserializer
from htmlserializer import HTMLSerializer

class XHTMLSerializer(HTMLSerializer):
    quote_attr_values = True
    minimize_boolean_attributes = False
    use_trailing_solidus = True
    escape_lt_in_attrs = True
    omit_optional_tags = False
    escape_rcdata = True

########NEW FILE########
__FILENAME__ = mockParser
import sys
import os

if __name__ == '__main__':
    #Allow us to import from the src directory
    os.chdir(os.path.split(os.path.abspath(__file__))[0])
    sys.path.insert(0, os.path.abspath(os.path.join(os.pardir, "src")))

from tokenizer import HTMLTokenizer

class HTMLParser(object):
    """ Fake parser to test tokenizer output """
    def parse(self, stream, output=True):
        tokenizer = HTMLTokenizer(stream)
        for token in tokenizer:
            if output:
                print token

if __name__ == "__main__":
    x = HTMLParser()
    if len(sys.argv) > 1:
        if len(sys.argv) > 2:
            import hotshot, hotshot.stats
            prof = hotshot.Profile('stats.prof')
            prof.runcall(x.parse, sys.argv[1], False)
            prof.close()
            stats = hotshot.stats.load('stats.prof')
            stats.strip_dirs()
            stats.sort_stats('time')
            stats.print_stats()
        else:
            x.parse(sys.argv[1])
    else:
        print """Usage: python mockParser.py filename [stats]
        If stats is specified the hotshots profiler will run and output the
        stats instead.
        """

########NEW FILE########
__FILENAME__ = runparsertests
import sys
import os
import glob
import unittest

#Allow us to import the parent module
os.chdir(os.path.split(os.path.abspath(__file__))[0])
sys.path.insert(0, os.path.abspath(os.curdir))
sys.path.insert(0, os.path.abspath(os.pardir))
sys.path.insert(0, os.path.join(os.path.abspath(os.pardir), "src"))

def buildTestSuite():
    suite = unittest.TestSuite()
    for testcase in glob.glob('test_*.py'):
        if testcase in ("test_tokenizer.py", "test_parser.py", "test_parser2.py"):
            module = os.path.splitext(testcase)[0]
            suite.addTest(__import__(module).buildTestSuite())
    return suite

def main():
    results = unittest.TextTestRunner().run(buildTestSuite())
    return results

if __name__ == "__main__":
    results = main()
    if not results.wasSuccessful():
        sys.exit(1)

########NEW FILE########
__FILENAME__ = runtests
import sys
import os
import glob
import unittest

def buildTestSuite():
    suite = unittest.TestSuite()
    for testcase in glob.glob('test_*.py'):
        module = os.path.splitext(testcase)[0]
        suite.addTest(__import__(module).buildTestSuite())
    return suite

def main():
    results = unittest.TextTestRunner().run(buildTestSuite())
    return results

if __name__ == "__main__":
    results = main()
    if not results.wasSuccessful():
        sys.exit(1)

########NEW FILE########
__FILENAME__ = support
import os
import sys
import codecs
import glob

base_path = os.path.split(__file__)[0]

if os.path.exists(os.path.join(base_path, 'testdata')):
    #release
    test_dir = os.path.join(base_path, 'testdata')
else:
    #development
    test_dir = os.path.abspath(
        os.path.join(base_path,
                     os.path.pardir, os.path.pardir,
                     os.path.pardir, 'testdata'))
    assert os.path.exists(test_dir), "Test data not found"
    #import the development html5lib
    sys.path.insert(0, os.path.abspath(os.path.join(base_path, 
                                                    os.path.pardir,
                                                    os.path.pardir)))

import html5lib
from html5lib import html5parser, treebuilders
del base_path

#Build a dict of avaliable trees
treeTypes = {"simpletree":treebuilders.getTreeBuilder("simpletree"),
             "DOM":treebuilders.getTreeBuilder("dom")}

#Try whatever etree implementations are avaliable from a list that are
#"supposed" to work
try:
    import xml.etree.ElementTree as ElementTree
    treeTypes['ElementTree'] = treebuilders.getTreeBuilder("etree", ElementTree, fullTree=True)
except ImportError:
    try:
        import elementtree.ElementTree as ElementTree
        treeTypes['ElementTree'] = treebuilders.getTreeBuilder("etree", ElementTree, fullTree=True)
    except ImportError:
        pass

try:
    import xml.etree.cElementTree as cElementTree
    treeTypes['cElementTree'] = treebuilders.getTreeBuilder("etree", cElementTree, fullTree=True)
except ImportError:
    try:
        import cElementTree
        treeTypes['cElementTree'] = treebuilders.getTreeBuilder("etree", cElementTree, fullTree=True)
    except ImportError:
        pass
    
try:
    import lxml.etree as lxml
    treeTypes['lxml'] = treebuilders.getTreeBuilder("etree", lxml, fullTree=True)
except ImportError:
    pass

try:
    import BeautifulSoup
    treeTypes["beautifulsoup"] = treebuilders.getTreeBuilder("beautifulsoup", fullTree=True)
except ImportError:
    pass

def html5lib_test_files(subdirectory, files='*.dat'):
    return glob.glob(os.path.join(test_dir,subdirectory,files))

class DefaultDict(dict):
    def __init__(self, default, *args, **kwargs):
        self.default = default
        dict.__init__(self, *args, **kwargs)
    
    def __getitem__(self, key):
        return dict.get(self, key, self.default)

class TestData(object):
    def __init__(self, filename, newTestHeading="data"):
        self.f = codecs.open(filename, encoding="utf8")
        self.newTestHeading = newTestHeading
    
    def __iter__(self):
        data = DefaultDict(None)
        key=None
        for line in self.f:
            heading = self.isSectionHeading(line)
            if heading:
                if data and heading == self.newTestHeading:
                    #Remove trailing newline
                    data[key] = data[key][:-1]
                    yield self.normaliseOutput(data)
                    data = DefaultDict(None)
                key = heading
                data[key]=""
            elif key is not None:
                data[key] += line
        if data:
            yield self.normaliseOutput(data)
        
    def isSectionHeading(self, line):
        """If the current heading is a test section heading return the heading,
        otherwise return False"""
        if line.startswith("#"):
            return line[1:].strip()
        else:
            return False
    
    def normaliseOutput(self, data):
        #Remove trailing newlines
        for key,value in data.iteritems():
            if value.endswith("\n"):
                data[key] = value[:-1]
        return data

def convert(stripChars):
    def convertData(data):
        """convert the output of str(document) to the format used in the testcases"""
        data = data.split("\n")
        rv = []
        for line in data:
            if line.startswith("|"):
                rv.append(line[stripChars:])
            else:
                rv.append(line)
        return "\n".join(rv)
    return convertData

convertExpected = convert(2)

########NEW FILE########
__FILENAME__ = test_encoding
import os
import unittest
from support import html5lib_test_files, TestData, test_dir

from html5lib import HTMLParser, inputstream

import re, unittest

class Html5EncodingTestCase(unittest.TestCase):
    def test_codec_name(self):
        self.assertEquals(inputstream.codecName("utf-8"), "utf-8")
        self.assertEquals(inputstream.codecName("utf8"), "utf-8")
        self.assertEquals(inputstream.codecName("  utf8  "), "utf-8")
        self.assertEquals(inputstream.codecName("ISO_8859--1"), "windows-1252")

def buildTestSuite():
    for filename in html5lib_test_files("encoding"):
        test_name = os.path.basename(filename).replace('.dat',''). \
            replace('-','')
        tests = TestData(filename, "data")
        for idx, test in enumerate(tests):
            def encodingTest(self, data=test['data'], 
                             encoding=test['encoding']):
                p = HTMLParser()
                t = p.parse(data, useChardet=False)
                
                errorMessage = ("Input:\n%s\nExpected:\n%s\nRecieved\n%s\n"%
                                (data, repr(encoding.lower()), 
                                 repr(p.tokenizer.stream.charEncoding)))
                self.assertEquals(encoding.lower(),
                                  p.tokenizer.stream.charEncoding[0], 
                                  errorMessage)
            setattr(Html5EncodingTestCase, 'test_%s_%d' % (test_name, idx+1),
                encodingTest)

    try:
        import chardet
        def test_chardet(self):
            data = open(os.path.join(test_dir, "encoding" , "chardet", "test_big5.txt")).read()
            encoding = inputstream.HTMLInputStream(data).charEncoding
            assert encoding[0].lower() == "big5"
        setattr(Html5EncodingTestCase, 'test_chardet', test_chardet)
    except ImportError:
        print "chardet not found, skipping chardet tests"
        

    return unittest.defaultTestLoader.loadTestsFromName(__name__)

def main():
    buildTestSuite()
    unittest.main()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_formfiller
import sys
import unittest

from html5lib.filters.formfiller import SimpleFilter

class FieldStorage(dict):
    def getlist(self, name):
        l = self[name]
        if isinstance(l, list):
            return l
        elif isinstance(l, tuple) or hasattr(l, '__iter__'):
            return list(l)
        return [l]

class TestCase(unittest.TestCase):
    def runTest(self, input, formdata, expected):
        try:
            output = list(SimpleFilter(input, formdata))
        except NotImplementedError, nie:
            # Amnesty for those that confess...
            print >>sys.stderr, "Not implemented:", str(nie)
        else:
            errorMsg = "\n".join(["\n\nInput:", str(input),
                                  "\nForm data:", str(formdata),
                                  "\nExpected:", str(expected),
                                  "\nReceived:", str(output)])
            self.assertEquals(output, expected, errorMsg)

    def testSingleTextInputWithValue(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"text"), (u"name", u"foo"), (u"value", u"quux")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"text"), (u"name", u"foo"), (u"value", u"bar")]}])

    def testSingleTextInputWithoutValue(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"text"), (u"name", u"foo")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"text"), (u"name", u"foo"), (u"value", u"bar")]}])

    def testSingleCheckbox(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"bar")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"bar"), (u"checked", u"")]}])

    def testSingleCheckboxShouldBeUnchecked(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"quux")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"quux")]}])

    def testSingleCheckboxCheckedByDefault(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"bar"), (u"checked", u"")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"bar"), (u"checked", u"")]}])

    def testSingleCheckboxCheckedByDefaultShouldBeUnchecked(self):
        self.runTest(
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"quux"), (u"checked", u"")]}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"EmptyTag", "name": u"input",
                "data": [(u"type", u"checkbox"), (u"name", u"foo"), (u"value", u"quux")]}])

    def testSingleTextareaWithValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"textarea", "data": [(u"name", u"foo")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"textarea", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"textarea", "data": [(u"name", u"foo")]},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"textarea", "data": []}])

    def testSingleTextareaWithoutValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"textarea", "data": [(u"name", u"foo")]},
             {"type": u"EndTag", "name": u"textarea", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"textarea", "data": [(u"name", u"foo")]},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"textarea", "data": []}])

    def testSingleSelectWithValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectWithValueShouldBeUnselected(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "quux"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectWithoutValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"selected", u"")]},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectWithoutValueShouldBeUnselected(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "quux"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectTwoOptionsWithValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectTwoOptionsWithValueShouldBeUnselected(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"baz")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "quux"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"baz")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectTwoOptionsWithoutValue(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "bar"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"selected", u"")]},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectTwoOptionsWithoutValueShouldBeUnselected(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"baz"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": "quux"}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"bar"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": []},
             {"type": u"Characters", "data": u"baz"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testSingleSelectMultiple(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo"), (u"multiple", u"")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": ["bar", "quux"]}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo"), (u"multiple", u"")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

    def testTwoSelect(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []},
             {"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}],
            FieldStorage({"foo": ["bar", "quux"]}),
            [{"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []},
             {"type": u"StartTag", "name": u"select", "data": [(u"name", u"foo")]},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"bar")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"StartTag", "name": u"option", "data": [(u"value", u"quux"), (u"selected", u"")]},
             {"type": u"Characters", "data": u"quux"},
             {"type": u"EndTag", "name": u"option", "data": []},
             {"type": u"EndTag", "name": u"select", "data": []}])

def buildTestSuite():
    return unittest.defaultTestLoader.loadTestsFromName(__name__)

def main():
    buildTestSuite()
    unittest.main()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_parser
import os
import sys
import traceback
import StringIO
import warnings
import re

warnings.simplefilter("error")

from support import html5lib_test_files as data_files
from support import TestData, convert, convertExpected
import html5lib
from html5lib import html5parser, treebuilders, constants

treeTypes = {"simpletree":treebuilders.getTreeBuilder("simpletree"),
             "DOM":treebuilders.getTreeBuilder("dom")}

#Try whatever etree implementations are avaliable from a list that are
#"supposed" to work
try:
    import xml.etree.ElementTree as ElementTree
    treeTypes['ElementTree'] = treebuilders.getTreeBuilder("etree", ElementTree, fullTree=True)
except ImportError:
    try:
        import elementtree.ElementTree as ElementTree
        treeTypes['ElementTree'] = treebuilders.getTreeBuilder("etree", ElementTree, fullTree=True)
    except ImportError:
        pass

try:
    import xml.etree.cElementTree as cElementTree
    treeTypes['cElementTree'] = treebuilders.getTreeBuilder("etree", cElementTree, fullTree=True)
except ImportError:
    try:
        import cElementTree
        treeTypes['cElementTree'] = treebuilders.getTreeBuilder("etree", cElementTree, fullTree=True)
    except ImportError:
        pass
    
try:
    try:
        import lxml.html as lxml
    except ImportError:
        import lxml.etree as lxml
    treeTypes['lxml'] = treebuilders.getTreeBuilder("lxml", lxml, fullTree=True)
except ImportError:
    pass

try:
    import BeautifulSoup
    treeTypes["beautifulsoup"] = treebuilders.getTreeBuilder("beautifulsoup", fullTree=True)
except ImportError:
    pass

#Try whatever dom implementations are avaliable from a list that are
#"supposed" to work
try:
    import pxdom
    treeTypes["pxdom"] = treebuilders.getTreeBuilder("dom", pxdom)
except ImportError:
    pass

#Run the parse error checks
checkParseErrors = False

#XXX - There should just be one function here but for some reason the testcase
#format differs from the treedump format by a single space character
def convertTreeDump(data):
    return "\n".join(convert(3)(data).split("\n")[1:])

namespaceExpected = re.compile(r"^(\s*)<(\S+)>", re.M).sub


def runParserTest(innerHTML, input, expected, errors, treeClass,
                  namespaceHTMLElements):
    #XXX - move this out into the setup function
    #concatenate all consecutive character tokens into a single token
    try:
        p = html5parser.HTMLParser(tree = treeClass,
                                   namespaceHTMLElements=namespaceHTMLElements)
    except constants.DataLossWarning:
        return

    try:
        if innerHTML:
            document = p.parseFragment(input, innerHTML)
        else:
            try:
                document = p.parse(input)
            except constants.DataLossWarning:
                return 
    except:
        errorMsg = u"\n".join([u"\n\nInput:", input, u"\nExpected:", expected,
                               u"\nTraceback:", traceback.format_exc()])
        assert False, errorMsg.encode("utf8")

    output = convertTreeDump(p.tree.testSerializer(document))

    expected = convertExpected(expected)
    if namespaceHTMLElements:
        expected = namespaceExpected(r"\1<html \2>", expected)

    errorMsg = u"\n".join([u"\n\nInput:", input, u"\nExpected:", expected,
                           u"\nReceived:", output])
    assert expected == output, errorMsg.encode("utf8")
    errStr = [u"Line: %i Col: %i %s"%(line, col, 
                                      constants.E[errorcode] % datavars if isinstance(datavars, dict) else (datavars,)) for
              ((line,col), errorcode, datavars) in p.errors]

    errorMsg2 = u"\n".join([u"\n\nInput:", input,
                            u"\nExpected errors (" + str(len(errors)) + u"):\n" + u"\n".join(errors),
                            u"\nActual errors (" + str(len(p.errors)) + u"):\n" + u"\n".join(errStr)])
    if checkParseErrors:
            assert len(p.errors) == len(errors), errorMsg2.encode("utf-8")

def test_parser():
    sys.stderr.write('Testing tree builders '+ " ".join(treeTypes.keys()) + "\n")
    files = data_files('tree-construction')
    
    for filename in files:
        testName = os.path.basename(filename).replace(".dat","")

        tests = TestData(filename, "data")
        
        for index, test in enumerate(tests):
            input, errors, innerHTML, expected = [test[key] for key in
                                                      'data', 'errors',
                                                      'document-fragment',
                                                      'document']
            if errors:
                errors = errors.split("\n")

            for treeName, treeCls in treeTypes.iteritems():
                for namespaceHTMLElements in (True, False):
                    print input
                    yield (runParserTest, innerHTML, input, expected, errors, treeCls,
                           namespaceHTMLElements)
                    break
                
                

########NEW FILE########
__FILENAME__ = test_parser2
import support
from html5lib import html5parser
from html5lib.constants import namespaces
from html5lib.treebuilders import dom

import unittest

# tests that aren't autogenerated from text files
class MoreParserTests(unittest.TestCase):

  def test_assertDoctypeCloneable(self):
    parser = html5parser.HTMLParser(tree=dom.TreeBuilder)
    doc = parser.parse('<!DOCTYPE HTML>')
    self.assert_(doc.cloneNode(True))

  def test_line_counter(self):
    # http://groups.google.com/group/html5lib-discuss/browse_frm/thread/f4f00e4a2f26d5c0
    parser = html5parser.HTMLParser(tree=dom.TreeBuilder)
    parser.parse("<pre>\nx\n&gt;\n</pre>")

  def test_namespace_html_elements_0(self): 
    parser = html5parser.HTMLParser(namespaceHTMLElements=True)
    doc = parser.parse("<html></html>")
    self.assert_(doc.childNodes[0].namespace == namespaces["html"])

  def test_namespace_html_elements_1(self): 
    parser = html5parser.HTMLParser(namespaceHTMLElements=False)
    doc = parser.parse("<html></html>")
    self.assert_(doc.childNodes[0].namespace == None)

def buildTestSuite():
  return unittest.defaultTestLoader.loadTestsFromName(__name__)

def main():
    buildTestSuite()
    unittest.main()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_sanitizer
import os
import sys
import unittest

try:
    import json
except ImportError:
    import simplejson as json

from html5lib import html5parser, sanitizer, constants

def runSanitizerTest(name, expected, input):
    expected = ''.join([token.toxml() for token in html5parser.HTMLParser().
                         parseFragment(expected).childNodes])
    expected = json.loads(json.dumps(expected))
    assert expected == sanitize_html(input)

def sanitize_html(stream):
    return ''.join([token.toxml() for token in
                    html5parser.HTMLParser(tokenizer=sanitizer.HTMLSanitizer).
                     parseFragment(stream).childNodes])

def test_should_handle_astral_plane_characters():
    assert u"<p>\U0001d4b5 \U0001d538</p>" == sanitize_html("<p>&#x1d4b5; &#x1d538;</p>")

def test_sanitizer():
    for tag_name in sanitizer.HTMLSanitizer.allowed_elements:
        if tag_name in ['caption', 'col', 'colgroup', 'optgroup', 'option', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr']:
            continue ### TODO
        if tag_name != tag_name.lower():
            continue ### TODO
        if tag_name == 'image':
            yield (runSanitizerTest, "test_should_allow_%s_tag" % tag_name,
              "<img title=\"1\"/>foo &lt;bad&gt;bar&lt;/bad&gt; baz",
              "<%s title='1'>foo <bad>bar</bad> baz</%s>" % (tag_name,tag_name))
        elif tag_name == 'br':
            yield (runSanitizerTest, "test_should_allow_%s_tag" % tag_name,
              "<br title=\"1\"/>foo &lt;bad&gt;bar&lt;/bad&gt; baz<br/>",
              "<%s title='1'>foo <bad>bar</bad> baz</%s>" % (tag_name,tag_name))
        elif tag_name in constants.voidElements:
            yield (runSanitizerTest, "test_should_allow_%s_tag" % tag_name,
              "<%s title=\"1\"/>foo &lt;bad&gt;bar&lt;/bad&gt; baz" % tag_name,
              "<%s title='1'>foo <bad>bar</bad> baz</%s>" % (tag_name,tag_name))
        else:
            yield (runSanitizerTest, "test_should_allow_%s_tag" % tag_name,
              "<%s title=\"1\">foo &lt;bad&gt;bar&lt;/bad&gt; baz</%s>" % (tag_name,tag_name),
              "<%s title='1'>foo <bad>bar</bad> baz</%s>" % (tag_name,tag_name))

    for tag_name in sanitizer.HTMLSanitizer.allowed_elements:
        tag_name = tag_name.upper()
        yield (runSanitizerTest, "test_should_forbid_%s_tag" % tag_name,
          "&lt;%s title=\"1\"&gt;foo &lt;bad&gt;bar&lt;/bad&gt; baz&lt;/%s&gt;" % (tag_name,tag_name),
          "<%s title='1'>foo <bad>bar</bad> baz</%s>" % (tag_name,tag_name))

    for attribute_name in sanitizer.HTMLSanitizer.allowed_attributes:
        if attribute_name != attribute_name.lower(): continue ### TODO
        if attribute_name == 'style': continue
        yield (runSanitizerTest, "test_should_allow_%s_attribute" % attribute_name,
          "<p %s=\"foo\">foo &lt;bad&gt;bar&lt;/bad&gt; baz</p>" % attribute_name,
          "<p %s='foo'>foo <bad>bar</bad> baz</p>" % attribute_name)

    for attribute_name in sanitizer.HTMLSanitizer.allowed_attributes:
        attribute_name = attribute_name.upper()
        yield (runSanitizerTest, "test_should_forbid_%s_attribute" % attribute_name,
          "<p>foo &lt;bad&gt;bar&lt;/bad&gt; baz</p>",
          "<p %s='display: none;'>foo <bad>bar</bad> baz</p>" % attribute_name)

    for protocol in sanitizer.HTMLSanitizer.allowed_protocols:
        yield (runSanitizerTest, "test_should_allow_%s_uris" % protocol,
          "<a href=\"%s\">foo</a>" % protocol,
          """<a href="%s">foo</a>""" % protocol)

    for protocol in sanitizer.HTMLSanitizer.allowed_protocols:
        yield (runSanitizerTest, "test_should_allow_uppercase_%s_uris" % protocol,
          "<a href=\"%s\">foo</a>" % protocol,
        """<a href="%s">foo</a>""" % protocol)

########NEW FILE########
__FILENAME__ = test_serializer
import os
import unittest
from support import html5lib_test_files

try:
    import json
except ImportError:
    import simplejson as json

import html5lib
from html5lib import html5parser, serializer, constants
from html5lib.treewalkers._base import TreeWalker

optionals_loaded = []

try:
    from lxml import etree
    optionals_loaded.append("lxml")
except ImportError:
    pass

default_namespace = constants.namespaces["html"]

class JsonWalker(TreeWalker):
    def __iter__(self):
        for token in self.tree:
            type = token[0]
            if type == "StartTag":
                if len(token) == 4:
                    namespace, name, attrib = token[1:4]
                else:
                    namespace = default_namespace
                    name, attrib = token[1:3]
                yield self.startTag(namespace, name, self._convertAttrib(attrib))
            elif type == "EndTag":
                if len(token) == 3:
                    namespace, name = token[1:3]
                else:
                    namespace = default_namespace
                    name = token[1]
                yield self.endTag(namespace, name)
            elif type == "EmptyTag":
                if len(token) == 4:
                    namespace, name, attrib = token[1:]
                else:
                    namespace = default_namespace
                    name, attrib = token[1:]
                for token in self.emptyTag(namespace, name, self._convertAttrib(attrib)):
                    yield token
            elif type == "Comment":
                yield self.comment(token[1])
            elif type in ("Characters", "SpaceCharacters"):
                for token in self.text(token[1]):
                    yield token
            elif type == "Doctype":
                if len(token) == 4:
                    yield self.doctype(token[1], token[2], token[3])
                elif len(token) == 3:
                    yield self.doctype(token[1], token[2])
                else:
                    yield self.doctype(token[1])
            else:
                raise ValueError("Unknown token type: " + type)
    
    def _convertAttrib(self, attribs):
        """html5lib tree-walkers use a dict of (namespace, name): value for
        attributes, but JSON cannot represent this. Convert from the format
        in the serializer tests (a list of dicts with "namespace", "name",
        and "value" as keys) to html5lib's tree-walker format."""
        attrs = {}
        for attrib in attribs:
            name = (attrib["namespace"], attrib["name"])
            assert(name not in attrs)
            attrs[name] = attrib["value"]
        return attrs


def serialize_html(input, options):
    options = dict([(str(k),v) for k,v in options.iteritems()])
    return serializer.HTMLSerializer(**options).render(JsonWalker(input),options.get("encoding",None))

def serialize_xhtml(input, options):
    options = dict([(str(k),v) for k,v in options.iteritems()])
    return serializer.XHTMLSerializer(**options).render(JsonWalker(input),options.get("encoding",None))

def make_test(input, expected, xhtml, options):
    result = serialize_html(input, options)
    if len(expected) == 1:
        assert expected[0] == result, "Expected:\n%s\nActual:\n%s\nOptions\nxhtml:False\n%s"%(expected[0], result, str(options))
    elif result not in expected:
        assert False, "Expected: %s, Received: %s" % (expected, result)

    if not xhtml:
        return

    result = serialize_xhtml(input, options)
    if len(xhtml) == 1:
        assert xhtml[0] == result, "Expected:\n%s\nActual:\n%s\nOptions\nxhtml:True\n%s"%(xhtml[0], result, str(options))
    elif result not in xhtml:
        assert False, "Expected: %s, Received: %s" % (xhtml, result)


class EncodingTestCase(unittest.TestCase):
    def throwsWithLatin1(self, input):
        self.assertRaises(UnicodeEncodeError, serialize_html, input, {"encoding": "iso-8859-1"})

    def testDoctypeName(self):
        self.throwsWithLatin1([["Doctype", u"\u0101"]])

    def testDoctypePublicId(self):
        self.throwsWithLatin1([["Doctype", u"potato", u"\u0101"]])

    def testDoctypeSystemId(self):
        self.throwsWithLatin1([["Doctype", u"potato", u"potato", u"\u0101"]])

    def testCdataCharacters(self):
        self.assertEquals("<style>&amacr;", serialize_html([["StartTag", "http://www.w3.org/1999/xhtml", "style", {}],
                                                            ["Characters", u"\u0101"]],
                                                           {"encoding": "iso-8859-1"}))

    def testCharacters(self):
        self.assertEquals("&amacr;", serialize_html([["Characters", u"\u0101"]],
                                                    {"encoding": "iso-8859-1"}))

    def testStartTagName(self):
        self.throwsWithLatin1([["StartTag", u"http://www.w3.org/1999/xhtml", u"\u0101", []]])

    def testEmptyTagName(self):
        self.throwsWithLatin1([["EmptyTag", u"http://www.w3.org/1999/xhtml", u"\u0101", []]])

    def testAttributeName(self):
        self.throwsWithLatin1([["StartTag", u"http://www.w3.org/1999/xhtml", u"span", [{"namespace": None, "name": u"\u0101", "value": u"potato"}]]])

    def testAttributeValue(self):
        self.assertEquals("<span potato=&amacr;>", serialize_html([["StartTag", u"http://www.w3.org/1999/xhtml", u"span",
                                                                    [{"namespace": None, "name": u"potato", "value": u"\u0101"}]]],
                                                                  {"encoding": "iso-8859-1"}))

    def testEndTagName(self):
        self.throwsWithLatin1([["EndTag", u"http://www.w3.org/1999/xhtml", u"\u0101"]])

    def testComment(self):
        self.throwsWithLatin1([["Comment", u"\u0101"]])


if "lxml" in optionals_loaded:
    class LxmlTestCase(unittest.TestCase):
        def setUp(self):
            self.parser = etree.XMLParser(resolve_entities=False)
            self.treewalker = html5lib.getTreeWalker("lxml")
            self.serializer = serializer.HTMLSerializer()

        def testEntityReplacement(self):
            doc = """<!DOCTYPE html SYSTEM "about:legacy-compat"><html>&beta;</html>"""
            tree = etree.fromstring(doc, parser = self.parser).getroottree()
            result = serializer.serialize(tree, tree="lxml", omit_optional_tags=False)
            self.assertEquals(u"""<!DOCTYPE html SYSTEM "about:legacy-compat"><html>\u03B2</html>""", result)

        def testEntityXML(self):
            doc = """<!DOCTYPE html SYSTEM "about:legacy-compat"><html>&gt;</html>"""
            tree = etree.fromstring(doc, parser = self.parser).getroottree()
            result = serializer.serialize(tree, tree="lxml", omit_optional_tags=False)
            self.assertEquals(u"""<!DOCTYPE html SYSTEM "about:legacy-compat"><html>&gt;</html>""", result)

        def testEntityNoResolve(self):
            doc = """<!DOCTYPE html SYSTEM "about:legacy-compat"><html>&beta;</html>"""
            tree = etree.fromstring(doc, parser = self.parser).getroottree()
            result = serializer.serialize(tree, tree="lxml", omit_optional_tags=False,
                                          resolve_entities=False)
            self.assertEquals(u"""<!DOCTYPE html SYSTEM "about:legacy-compat"><html>&beta;</html>""", result)

def test_serializer():
    for filename in html5lib_test_files('serializer', '*.test'):
        tests = json.load(file(filename))
        test_name = os.path.basename(filename).replace('.test','')
        for index, test in enumerate(tests['tests']):
            xhtml = test.get("xhtml", test["expected"])
            if test_name == 'optionaltags': 
                xhtml = None
            yield make_test, test["input"], test["expected"], xhtml, test.get("options", {})

########NEW FILE########
__FILENAME__ = test_stream
import support
import unittest, codecs

from html5lib.inputstream import HTMLInputStream

class HTMLInputStreamShortChunk(HTMLInputStream):
    _defaultChunkSize = 2

class HTMLInputStreamTest(unittest.TestCase):

    def test_char_ascii(self):
        stream = HTMLInputStream("'", encoding='ascii')
        self.assertEquals(stream.charEncoding[0], 'ascii')
        self.assertEquals(stream.char(), "'")

    def test_char_null(self):
        stream = HTMLInputStream("\x00")
        self.assertEquals(stream.char(), u'\ufffd')

    def test_char_utf8(self):
        stream = HTMLInputStream(u'\u2018'.encode('utf-8'), encoding='utf-8')
        self.assertEquals(stream.charEncoding[0], 'utf-8')
        self.assertEquals(stream.char(), u'\u2018')

    def test_char_win1252(self):
        stream = HTMLInputStream(u"\xa9\xf1\u2019".encode('windows-1252'))
        self.assertEquals(stream.charEncoding[0], 'windows-1252')
        self.assertEquals(stream.char(), u"\xa9")
        self.assertEquals(stream.char(), u"\xf1")
        self.assertEquals(stream.char(), u"\u2019")

    def test_bom(self):
        stream = HTMLInputStream(codecs.BOM_UTF8 + "'")
        self.assertEquals(stream.charEncoding[0], 'utf-8')
        self.assertEquals(stream.char(), "'")

    def test_utf_16(self):
        stream = HTMLInputStream((' '*1025).encode('utf-16'))
        self.assert_(stream.charEncoding[0] in ['utf-16-le', 'utf-16-be'], stream.charEncoding)
        self.assertEquals(len(stream.charsUntil(' ', True)), 1025)

    def test_newlines(self):
        stream = HTMLInputStreamShortChunk(codecs.BOM_UTF8 + "a\nbb\r\nccc\rddddxe")
        self.assertEquals(stream.position(), (1, 0))
        self.assertEquals(stream.charsUntil('c'), u"a\nbb\n")
        self.assertEquals(stream.position(), (3, 0))
        self.assertEquals(stream.charsUntil('x'), u"ccc\ndddd")
        self.assertEquals(stream.position(), (4, 4))
        self.assertEquals(stream.charsUntil('e'), u"x")
        self.assertEquals(stream.position(), (4, 5))

    def test_newlines2(self):
        size = HTMLInputStream._defaultChunkSize
        stream = HTMLInputStream("\r" * size + "\n")
        self.assertEquals(stream.charsUntil('x'), "\n" * size)

    def test_position(self):
        stream = HTMLInputStreamShortChunk(codecs.BOM_UTF8 + "a\nbb\nccc\nddde\nf\ngh")
        self.assertEquals(stream.position(), (1, 0))
        self.assertEquals(stream.charsUntil('c'), u"a\nbb\n")
        self.assertEquals(stream.position(), (3, 0))
        stream.unget(u"\n")
        self.assertEquals(stream.position(), (2, 2))
        self.assertEquals(stream.charsUntil('c'), u"\n")
        self.assertEquals(stream.position(), (3, 0))
        stream.unget(u"\n")
        self.assertEquals(stream.position(), (2, 2))
        self.assertEquals(stream.char(), u"\n")
        self.assertEquals(stream.position(), (3, 0))
        self.assertEquals(stream.charsUntil('e'), u"ccc\nddd")
        self.assertEquals(stream.position(), (4, 3))
        self.assertEquals(stream.charsUntil('h'), u"e\nf\ng")
        self.assertEquals(stream.position(), (6, 1))

    def test_position2(self):
        stream = HTMLInputStreamShortChunk("abc\nd")
        self.assertEquals(stream.position(), (1, 0))
        self.assertEquals(stream.char(), u"a")
        self.assertEquals(stream.position(), (1, 1))
        self.assertEquals(stream.char(), u"b")
        self.assertEquals(stream.position(), (1, 2))
        self.assertEquals(stream.char(), u"c")
        self.assertEquals(stream.position(), (1, 3))
        self.assertEquals(stream.char(), u"\n")
        self.assertEquals(stream.position(), (2, 0))
        self.assertEquals(stream.char(), u"d")
        self.assertEquals(stream.position(), (2, 1))

def buildTestSuite():
    return unittest.defaultTestLoader.loadTestsFromName(__name__)

def main():
    buildTestSuite()
    unittest.main()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_tokenizer
import sys
import os
import unittest
import cStringIO
import warnings
import re

try:
    import json
except ImportError:
    import simplejson as json

from support import html5lib_test_files
from html5lib.tokenizer import HTMLTokenizer
from html5lib import constants

class TokenizerTestParser(object):
    def __init__(self, initialState, lastStartTag=None):
        self.tokenizer = HTMLTokenizer
        self._state = initialState
        self._lastStartTag = lastStartTag

    def parse(self, stream, encoding=None, innerHTML=False):
        tokenizer = self.tokenizer(stream, encoding)
        self.outputTokens = []

        tokenizer.state = getattr(tokenizer, self._state)
        if self._lastStartTag is not None:
            tokenizer.currentToken = {"type": "startTag", 
                                      "name":self._lastStartTag}

        types = dict((v,k) for k,v in constants.tokenTypes.iteritems())
        for token in tokenizer:
            getattr(self, 'process%s' % types[token["type"]])(token)

        return self.outputTokens

    def processDoctype(self, token):
        self.outputTokens.append([u"DOCTYPE", token["name"], token["publicId"],
                                  token["systemId"], token["correct"]])

    def processStartTag(self, token):
        self.outputTokens.append([u"StartTag", token["name"], 
                                  dict(token["data"][::-1]), token["selfClosing"]])

    def processEmptyTag(self, token):
        if token["name"] not in constants.voidElements:
            self.outputTokens.append(u"ParseError")
        self.outputTokens.append([u"StartTag", token["name"], dict(token["data"][::-1])])

    def processEndTag(self, token):
        self.outputTokens.append([u"EndTag", token["name"], 
                                  token["selfClosing"]])

    def processComment(self, token):
        self.outputTokens.append([u"Comment", token["data"]])

    def processSpaceCharacters(self, token):
        self.outputTokens.append([u"Character", token["data"]])
        self.processSpaceCharacters = self.processCharacters

    def processCharacters(self, token):
        self.outputTokens.append([u"Character", token["data"]])

    def processEOF(self, token):
        pass

    def processParseError(self, token):
        self.outputTokens.append([u"ParseError", token["data"]])

def concatenateCharacterTokens(tokens):
    outputTokens = []
    for token in tokens:
        if not "ParseError" in token and token[0] == "Character":
            if (outputTokens and not "ParseError" in outputTokens[-1] and
                outputTokens[-1][0] == "Character"):
                outputTokens[-1][1] += token[1]
            else:
                outputTokens.append(token)
        else:
            outputTokens.append(token)
    return outputTokens

def normalizeTokens(tokens):
    # TODO: convert tests to reflect arrays
    for i, token in enumerate(tokens):
        if token[0] == u'ParseError':
            tokens[i] = token[0]
    return tokens

def tokensMatch(expectedTokens, receivedTokens, ignoreErrorOrder,
                ignoreErrors=False):
    """Test whether the test has passed or failed

    If the ignoreErrorOrder flag is set to true we don't test the relative
    positions of parse errors and non parse errors
    """
    checkSelfClosing= False
    for token in expectedTokens:
        if (token[0] == "StartTag" and len(token) == 4
            or token[0] == "EndTag" and len(token) == 3):
            checkSelfClosing = True
            break

    if not checkSelfClosing:
        for token in receivedTokens:
            if token[0] == "StartTag" or token[0] == "EndTag":
                token.pop()

    if not ignoreErrorOrder and not ignoreErrors:
        return expectedTokens == receivedTokens
    else:
        #Sort the tokens into two groups; non-parse errors and parse errors
        tokens = {"expected":[[],[]], "received":[[],[]]}
        for tokenType, tokenList in zip(tokens.keys(),
                                         (expectedTokens, receivedTokens)):
            for token in tokenList:
                if token != "ParseError":
                    tokens[tokenType][0].append(token)
                else:
                    if not ignoreErrors:
                        tokens[tokenType][1].append(token)
        return tokens["expected"] == tokens["received"]

def unescape_test(test):
    def decode(inp):
        return inp.decode("unicode-escape")

    test["input"] = decode(test["input"])
    for token in test["output"]:
        if token == "ParseError":
            continue
        else:
            token[1] = decode(token[1])
            if len(token) > 2:
                for key, value in token[2]:
                    del token[2][key]
                    token[2][decode(key)] = decode(value)
    return test


def runTokenizerTest(test):
    #XXX - move this out into the setup function
    #concatenate all consecutive character tokens into a single token
    if 'doubleEscaped' in test:
        test = unescape_test(test)

    expected = concatenateCharacterTokens(test['output'])            
    if 'lastStartTag' not in test:
        test['lastStartTag'] = None
    outBuffer = cStringIO.StringIO()
    stdout = sys.stdout
    sys.stdout = outBuffer
    parser = TokenizerTestParser(test['initialState'], 
                                 test['lastStartTag'])
    tokens = parser.parse(test['input'])
    tokens = concatenateCharacterTokens(tokens)
    received = normalizeTokens(tokens)
    errorMsg = u"\n".join(["\n\nInitial state:",
                          test['initialState'] ,
                          "\nInput:", unicode(test['input']),
                          "\nExpected:", unicode(expected),
                          "\nreceived:", unicode(tokens)])
    errorMsg = errorMsg.encode("utf-8")
    ignoreErrorOrder = test.get('ignoreErrorOrder', False)
    assert tokensMatch(expected, received, ignoreErrorOrder), errorMsg


def _doCapitalize(match):
    return match.group(1).upper()

_capitalizeRe = re.compile(r"\W+(\w)").sub

def capitalize(s):
    s = s.lower()
    s = _capitalizeRe(_doCapitalize, s)
    return s


def test_tokenizer():
    for filename in html5lib_test_files('tokenizer', '*.test'):
        tests = json.load(file(filename))
        testName = os.path.basename(filename).replace(".test","")
        if 'tests' in tests:
            for index,test in enumerate(tests['tests']):
                #Skip tests with a self closing flag
                skip = False
                if 'initialStates' not in test:
                    test["initialStates"] = ["Data state"]
                for initialState in test["initialStates"]:
                    test["initialState"] = capitalize(initialState)
                    yield runTokenizerTest, test


########NEW FILE########
__FILENAME__ = test_treewalkers
import os
import sys
import StringIO
import unittest
import warnings

warnings.simplefilter("error")

from support import html5lib_test_files, TestData, convertExpected

from html5lib import html5parser, treewalkers, treebuilders, constants
from html5lib.filters.lint import Filter as LintFilter, LintError

def PullDOMAdapter(node):
    from xml.dom import Node
    from xml.dom.pulldom import START_ELEMENT, END_ELEMENT, COMMENT, CHARACTERS

    if node.nodeType in (Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE):
        for childNode in node.childNodes:
            for event in PullDOMAdapter(childNode):
                yield event

    elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
        raise NotImplementedError("DOCTYPE nodes are not supported by PullDOM")

    elif node.nodeType == Node.COMMENT_NODE:
        yield COMMENT, node

    elif node.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
        yield CHARACTERS, node

    elif node.nodeType == Node.ELEMENT_NODE:
        yield START_ELEMENT, node
        for childNode in node.childNodes:
            for event in PullDOMAdapter(childNode):
                yield event
        yield END_ELEMENT, node

    else:
        raise NotImplementedError("Node type not supported: " + str(node.nodeType))

treeTypes = {
"simpletree":  {"builder": treebuilders.getTreeBuilder("simpletree"),
                "walker":  treewalkers.getTreeWalker("simpletree")},
"DOM":         {"builder": treebuilders.getTreeBuilder("dom"),
                "walker":  treewalkers.getTreeWalker("dom")},
"PullDOM":     {"builder": treebuilders.getTreeBuilder("dom"),
                "adapter": PullDOMAdapter,
                "walker":  treewalkers.getTreeWalker("pulldom")},
}

#Try whatever etree implementations are available from a list that are
#"supposed" to work
try:
    import xml.etree.ElementTree as ElementTree
    treeTypes['ElementTree'] = \
        {"builder": treebuilders.getTreeBuilder("etree", ElementTree),
         "walker":  treewalkers.getTreeWalker("etree", ElementTree)}
except ImportError:
    try:
        import elementtree.ElementTree as ElementTree
        treeTypes['ElementTree'] = \
            {"builder": treebuilders.getTreeBuilder("etree", ElementTree),
             "walker":  treewalkers.getTreeWalker("etree", ElementTree)}
    except ImportError:
        pass

try:
    import xml.etree.cElementTree as ElementTree
    treeTypes['cElementTree'] = \
        {"builder": treebuilders.getTreeBuilder("etree", ElementTree),
         "walker":  treewalkers.getTreeWalker("etree", ElementTree)}
except ImportError:
    try:
        import cElementTree as ElementTree
        treeTypes['cElementTree'] = \
            {"builder": treebuilders.getTreeBuilder("etree", ElementTree),
             "walker":  treewalkers.getTreeWalker("etree", ElementTree)}
    except ImportError:
        pass

try:
    import lxml.etree as ElementTree
#    treeTypes['lxml_as_etree'] = \
#        {"builder": treebuilders.getTreeBuilder("etree", ElementTree),
#         "walker":  treewalkers.getTreeWalker("etree", ElementTree)}
    treeTypes['lxml_native'] = \
        {"builder": treebuilders.getTreeBuilder("lxml"),
         "walker":  treewalkers.getTreeWalker("lxml")}
except ImportError:
    pass

try:
    import BeautifulSoup
    treeTypes["beautifulsoup"] = \
        {"builder": treebuilders.getTreeBuilder("beautifulsoup"),
         "walker":  treewalkers.getTreeWalker("beautifulsoup")}
except ImportError:
    pass
    
#Try whatever etree implementations are available from a list that are
#"supposed" to work
try:
    import pxdom
    treeTypes['pxdom'] = \
        {"builder": treebuilders.getTreeBuilder("dom", pxdom),
         "walker":  treewalkers.getTreeWalker("dom")}
except ImportError:
    pass

try:
    from genshi.core import QName, Attrs
    from genshi.core import START, END, TEXT, COMMENT, DOCTYPE

    def GenshiAdapter(tree):
        text = None
        for token in treewalkers.getTreeWalker("simpletree")(tree):
            type = token["type"]
            if type in ("Characters", "SpaceCharacters"):
                if text is None:
                    text = token["data"]
                else:
                    text += token["data"]
            elif text is not None:
                yield TEXT, text, (None, -1, -1)
                text = None

            if type in ("StartTag", "EmptyTag"):
                if token["namespace"]:
                    name = u"{%s}%s" % (token["namespace"], token["name"])
                else:
                    name = token["name"]
                yield (START,
                       (QName(name),
                        Attrs([(QName(attr),value) for attr,value in token["data"]])),
                       (None, -1, -1))
                if type == "EmptyTag":
                    type = "EndTag"

            if type == "EndTag":
                yield END, QName(token["name"]), (None, -1, -1)

            elif type == "Comment":
                yield COMMENT, token["data"], (None, -1, -1)

            elif type == "Doctype":
                yield DOCTYPE, (token["name"], token["publicId"], 
                                token["systemId"]), (None, -1, -1)

            else:
                pass # FIXME: What to do?

        if text is not None:
            yield TEXT, text, (None, -1, -1)

    #treeTypes["genshi"] = \
    #    {"builder": treebuilders.getTreeBuilder("simpletree"),
    #     "adapter": GenshiAdapter,
    #     "walker":  treewalkers.getTreeWalker("genshi")}
except ImportError:
    pass

def concatenateCharacterTokens(tokens):
    charactersToken = None
    for token in tokens:
        type = token["type"]
        if type in ("Characters", "SpaceCharacters"):
            if charactersToken is None:
                charactersToken = {"type": "Characters", "data": token["data"]}
            else:
                charactersToken["data"] += token["data"]
        else:
            if charactersToken is not None:
                yield charactersToken
                charactersToken = None
            yield token
    if charactersToken is not None:
        yield charactersToken

def convertTokens(tokens):
    output = []
    indent = 0
    for token in concatenateCharacterTokens(tokens):
        type = token["type"]
        if type in ("StartTag", "EmptyTag"):
            if (token["namespace"] and
                token["namespace"] != constants.namespaces["html"]):
                if token["namespace"] in constants.prefixes:
                    name = constants.prefixes[token["namespace"]]
                else:
                    name = token["namespace"]
                name += u" " + token["name"]
            else:
                name = token["name"]
            output.append(u"%s<%s>" % (" "*indent, name))
            indent += 2
            attrs = token["data"]
            if attrs:
                #TODO: Remove this if statement, attrs should always exist
                for (namespace,name),value in sorted(attrs.items()):
                    if namespace:
                        if namespace in constants.prefixes:
                            outputname = constants.prefixes[namespace]
                        else:
                            outputname = namespace
                        outputname += u" " + name
                    else:
                        outputname = name
                    output.append(u"%s%s=\"%s\"" % (" "*indent, outputname, value))
            if type == "EmptyTag":
                indent -= 2
        elif type == "EndTag":
            indent -= 2
        elif type == "Comment":
            output.append("%s<!-- %s -->" % (" "*indent, token["data"]))
        elif type == "Doctype":
            if token["name"]:
                if token["publicId"]:
                    output.append("""%s<!DOCTYPE %s "%s" "%s">"""% 
                                  (" "*indent, token["name"], 
                                   token["publicId"],
                                   token["systemId"] and token["systemId"] or ""))
                elif token["systemId"]:
                    output.append("""%s<!DOCTYPE %s "" "%s">"""% 
                                  (" "*indent, token["name"], 
                                   token["systemId"]))
                else:
                    output.append("%s<!DOCTYPE %s>"%(" "*indent,
                                                     token["name"]))
            else:
                output.append("%s<!DOCTYPE >" % (" "*indent,))
        elif type in ("Characters", "SpaceCharacters"):
            output.append("%s\"%s\"" % (" "*indent, token["data"]))
        else:
            pass # TODO: what to do with errors?
    return u"\n".join(output)

import re
attrlist = re.compile(r"^(\s+)\w+=.*(\n\1\w+=.*)+",re.M)
def sortattrs(x):
  lines = x.group(0).split("\n")
  lines.sort()
  return "\n".join(lines)


class TokenTestCase(unittest.TestCase):
    def test_all_tokens(self):
        expected = [
            {'data': {}, 'type': 'StartTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'html'},
            {'data': {}, 'type': 'StartTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'head'},
            {'data': {}, 'type': 'EndTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'head'},
            {'data': {}, 'type': 'StartTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'body'},
            {'data': u'a', 'type': 'Characters'},
            {'data': {}, 'type': 'StartTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'div'},
            {'data': u'b', 'type': 'Characters'},
            {'data': {}, 'type': 'EndTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'div'},
            {'data': u'c', 'type': 'Characters'},
            {'data': {}, 'type': 'EndTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'body'},
            {'data': {}, 'type': 'EndTag', 'namespace': u'http://www.w3.org/1999/xhtml', 'name': u'html'}
            ]
        for treeName, treeCls in treeTypes.iteritems():
            p = html5parser.HTMLParser(tree = treeCls["builder"])
            document = p.parse("<html><head></head><body>a<div>b</div>c</body></html>")
            document = treeCls.get("adapter", lambda x: x)(document)
            output = treeCls["walker"](document)
            for expectedToken, outputToken in zip(expected, output):
                self.assertEquals(expectedToken, outputToken)

def run_test(innerHTML, input, expected, errors, treeClass):
    try:
        p = html5parser.HTMLParser(tree = treeClass["builder"])
        if innerHTML:
            document = p.parseFragment(StringIO.StringIO(input), innerHTML)
        else:
            document = p.parse(StringIO.StringIO(input))
    except constants.DataLossWarning:
        #Ignore testcases we know we don't pass
        return

    document = treeClass.get("adapter", lambda x: x)(document)
    try:
        output = convertTokens(treeClass["walker"](document))
        output = attrlist.sub(sortattrs, output)
        expected = attrlist.sub(sortattrs, convertExpected(expected))
        assert expected == output, "\n".join([
                "", "Input:", input,
                "", "Expected:", expected,
                "", "Received:", output
                ])
    except NotImplementedError:
        pass # Amnesty for those that confess...
            
def test_treewalker():
    sys.stdout.write('Testing tree walkers '+ " ".join(treeTypes.keys()) + "\n")

    for treeName, treeCls in treeTypes.iteritems():
        files = html5lib_test_files('tree-construction')
        for filename in files:
            testName = os.path.basename(filename).replace(".dat","")

            tests = TestData(filename, "data")

            for index, test in enumerate(tests):
                (input, errors,
                 innerHTML, expected) = [test[key] for key in ("data", "errors",
                                                               "document-fragment",
                                                               "document")]
                errors = errors.split("\n")
                yield run_test, innerHTML, input, expected, errors, treeCls



########NEW FILE########
__FILENAME__ = test_whitespace_filter
import unittest

from html5lib.filters.whitespace import Filter
from html5lib.constants import spaceCharacters
spaceCharacters = u"".join(spaceCharacters)

class TestCase(unittest.TestCase):
    def runTest(self, input, expected):
        output = list(Filter(input))
        errorMsg = "\n".join(["\n\nInput:", str(input),
                              "\nExpected:", str(expected),
                              "\nReceived:", str(output)])
        self.assertEquals(output, expected, errorMsg)

    def runTestUnmodifiedOutput(self, input):
        self.runTest(input, input)

    def testPhrasingElements(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"Characters", "data": u"This is a " },
             {"type": u"StartTag", "name": u"span", "data": [] },
             {"type": u"Characters", "data": u"phrase" },
             {"type": u"EndTag", "name": u"span", "data": []},
             {"type": u"SpaceCharacters", "data": u" " },
             {"type": u"Characters", "data": u"with" },
             {"type": u"SpaceCharacters", "data": u" " },
             {"type": u"StartTag", "name": u"em", "data": [] },
             {"type": u"Characters", "data": u"emphasised text" },
             {"type": u"EndTag", "name": u"em", "data": []},
             {"type": u"Characters", "data": u" and an " },
             {"type": u"StartTag", "name": u"img", "data": [[u"alt", u"image"]] },
             {"type": u"Characters", "data": u"." }])

    def testLeadingWhitespace(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"SpaceCharacters", "data": spaceCharacters},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"EndTag", "name": u"p", "data": []}],
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"SpaceCharacters", "data": u" "},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"EndTag", "name": u"p", "data": []}])

    def testLeadingWhitespaceAsCharacters(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": spaceCharacters + u"foo"},
             {"type": u"EndTag", "name": u"p", "data": []}],
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u" foo"},
             {"type": u"EndTag", "name": u"p", "data": []}])

    def testTrailingWhitespace(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"SpaceCharacters", "data": spaceCharacters},
             {"type": u"EndTag", "name": u"p", "data": []}],
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"SpaceCharacters", "data": u" "},
             {"type": u"EndTag", "name": u"p", "data": []}])

    def testTrailingWhitespaceAsCharacters(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo" + spaceCharacters},
             {"type": u"EndTag", "name": u"p", "data": []}],
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo "},
             {"type": u"EndTag", "name": u"p", "data": []}])

    def testWhitespace(self):
        self.runTest(
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo" + spaceCharacters + "bar"},
             {"type": u"EndTag", "name": u"p", "data": []}],
            [{"type": u"StartTag", "name": u"p", "data": []},
             {"type": u"Characters", "data": u"foo bar"},
             {"type": u"EndTag", "name": u"p", "data": []}])

    def testLeadingWhitespaceInPre(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"StartTag", "name": u"pre", "data": []},
             {"type": u"SpaceCharacters", "data": spaceCharacters},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"EndTag", "name": u"pre", "data": []}])

    def testLeadingWhitespaceAsCharactersInPre(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"StartTag", "name": u"pre", "data": []},
             {"type": u"Characters", "data": spaceCharacters + u"foo"},
             {"type": u"EndTag", "name": u"pre", "data": []}])

    def testTrailingWhitespaceInPre(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"StartTag", "name": u"pre", "data": []},
             {"type": u"Characters", "data": u"foo"},
             {"type": u"SpaceCharacters", "data": spaceCharacters},
             {"type": u"EndTag", "name": u"pre", "data": []}])

    def testTrailingWhitespaceAsCharactersInPre(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"StartTag", "name": u"pre", "data": []},
             {"type": u"Characters", "data": u"foo" + spaceCharacters},
             {"type": u"EndTag", "name": u"pre", "data": []}])

    def testWhitespaceInPre(self):
        self.runTestUnmodifiedOutput(
            [{"type": u"StartTag", "name": u"pre", "data": []},
             {"type": u"Characters", "data": u"foo" + spaceCharacters + "bar"},
             {"type": u"EndTag", "name": u"pre", "data": []}])

def buildTestSuite():
    return unittest.defaultTestLoader.loadTestsFromName(__name__)

def main():
    buildTestSuite()
    unittest.main()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = tokenizertotree
import sys
import os
import json
import re

import html5lib
import support
import test_parser
import test_tokenizer

p = html5lib.HTMLParser()

unnamespaceExpected = re.compile(r"^(\|\s*)<html ([^>]+)>", re.M).sub

def main(out_path):
    if not os.path.exists(out_path):
        sys.stderr.write("Path %s does not exist"%out_path)
        sys.exit(1)

    for filename in support.html5lib_test_files('tokenizer', '*.test'):
        run_file(filename, out_path)

def run_file(filename, out_path):
    try:
        tests_data = json.load(file(filename))
    except ValueError:
        sys.stderr.write("Failed to load %s\n"%filename)
        return
    name = os.path.splitext(os.path.split(filename)[1])[0]
    output_file = open(os.path.join(out_path, "tokenizer_%s.dat"%name), "w")

    if 'tests' in tests_data:
        for test_data in tests_data['tests']:
            if 'initialStates' not in test_data:
                test_data["initialStates"] = ["Data state"]
                
            for initial_state in test_data["initialStates"]:
                if initial_state != "Data state":
                    #don't support this yet
                    continue
                test = make_test(test_data)
                output_file.write(test)

    output_file.close()

def make_test(test_data):
    if 'doubleEscaped' in test_data:
        test_data = test_tokenizer.unescape_test(test_data)

    rv = []
    rv.append("#data")
    rv.append(test_data["input"].encode("utf8"))
    rv.append("#errors")
    tree = p.parse(test_data["input"])
    output = p.tree.testSerializer(tree)
    output  = "\n".join(("| "+ line[3:]) if line.startswith("|  ") else line
                        for line in output.split("\n"))
    output = unnamespaceExpected(r"\1<\2>", output)
    rv.append(output.encode("utf8"))
    rv.append("")
    return "\n".join(rv)

if __name__ == "__main__":
    main(sys.argv[1])

########NEW FILE########
__FILENAME__ = tokenizer
try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import Set as set
    from sets import ImmutableSet as frozenset
try:
    from collections import deque
except ImportError:
    from utils import deque
    
from constants import spaceCharacters
from constants import entitiesWindows1252, entities
from constants import asciiLowercase, asciiLetters, asciiUpper2Lower
from constants import digits, hexDigits, EOF
from constants import tokenTypes, tagTokenTypes
from constants import replacementCharacters

from inputstream import HTMLInputStream

# Group entities by their first character, for faster lookups
entitiesByFirstChar = {}
for e in entities:
    entitiesByFirstChar.setdefault(e[0], []).append(e)

class HTMLTokenizer(object):
    """ This class takes care of tokenizing HTML.

    * self.currentToken
      Holds the token that is currently being processed.

    * self.state
      Holds a reference to the method to be invoked... XXX

    * self.stream
      Points to HTMLInputStream object.
    """

    def __init__(self, stream, encoding=None, parseMeta=True, useChardet=True,
                 lowercaseElementName=True, lowercaseAttrName=True, parser=None):

        self.stream = HTMLInputStream(stream, encoding, parseMeta, useChardet)
        self.parser = parser

        #Perform case conversions?
        self.lowercaseElementName = lowercaseElementName
        self.lowercaseAttrName = lowercaseAttrName
        
        # Setup the initial tokenizer state
        self.escapeFlag = False
        self.lastFourChars = []
        self.state = self.dataState
        self.escape = False

        # The current token being created
        self.currentToken = None
        super(HTMLTokenizer, self).__init__()

    def __iter__(self):
        """ This is where the magic happens.

        We do our usually processing through the states and when we have a token
        to return we yield the token which pauses processing until the next token
        is requested.
        """
        self.tokenQueue = deque([])
        # Start processing. When EOF is reached self.state will return False
        # instead of True and the loop will terminate.
        while self.state():
            while self.stream.errors:
                yield {"type": tokenTypes["ParseError"], "data": self.stream.errors.pop(0)}
            while self.tokenQueue:
                yield self.tokenQueue.popleft()

    def consumeNumberEntity(self, isHex):
        """This function returns either U+FFFD or the character based on the
        decimal or hexadecimal representation. It also discards ";" if present.
        If not present self.tokenQueue.append({"type": tokenTypes["ParseError"]}) is invoked.
        """

        allowed = digits
        radix = 10
        if isHex:
            allowed = hexDigits
            radix = 16

        charStack = []

        # Consume all the characters that are in range while making sure we
        # don't hit an EOF.
        c = self.stream.char()
        while c in allowed and c is not EOF:
            charStack.append(c)
            c = self.stream.char()

        # Convert the set of characters consumed to an int.
        charAsInt = int("".join(charStack), radix)

        # Certain characters get replaced with others
        if charAsInt in replacementCharacters:
            char = replacementCharacters[charAsInt]
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "illegal-codepoint-for-numeric-entity",
              "datavars": {"charAsInt": charAsInt}})
        elif ((0xD800 <= charAsInt <= 0xDFFF) or 
              (charAsInt > 0x10FFFF)):
            char = u"\uFFFD"
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "illegal-codepoint-for-numeric-entity",
              "datavars": {"charAsInt": charAsInt}})
        else:
            #Should speed up this check somehow (e.g. move the set to a constant)
            if ((0x0001 <= charAsInt <= 0x0008) or 
                (0x000E <= charAsInt <= 0x001F) or 
                (0x007F  <= charAsInt <= 0x009F) or
                (0xFDD0  <= charAsInt <= 0xFDEF) or 
                charAsInt in frozenset([0x000B, 0xFFFE, 0xFFFF, 0x1FFFE, 
                                        0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
                                        0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 
                                        0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE,
                                        0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
                                        0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE, 
                                        0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE, 
                                        0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 
                                        0xFFFFF, 0x10FFFE, 0x10FFFF])):
                self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                        "data":
                                            "illegal-codepoint-for-numeric-entity",
                                        "datavars": {"charAsInt": charAsInt}})
            try:
                # Try/except needed as UCS-2 Python builds' unichar only works
                # within the BMP.
                char = unichr(charAsInt)
            except ValueError:
                char = eval("u'\\U%08x'" % charAsInt)

        # Discard the ; if present. Otherwise, put it back on the queue and
        # invoke parseError on parser.
        if c != u";":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "numeric-entity-without-semicolon"})
            self.stream.unget(c)

        return char

    def consumeEntity(self, allowedChar=None, fromAttribute=False):
        # Initialise to the default output for when no entity is matched
        output = u"&"

        charStack = [self.stream.char()]
        if (charStack[0] in spaceCharacters or charStack[0] in (EOF, u"<", u"&") 
            or (allowedChar is not None and allowedChar == charStack[0])):
            self.stream.unget(charStack[0])

        elif charStack[0] == u"#":
            # Read the next character to see if it's hex or decimal
            hex = False
            charStack.append(self.stream.char())
            if charStack[-1] in (u"x", u"X"):
                hex = True
                charStack.append(self.stream.char())

            # charStack[-1] should be the first digit
            if (hex and charStack[-1] in hexDigits) \
             or (not hex and charStack[-1] in digits):
                # At least one digit found, so consume the whole number
                self.stream.unget(charStack[-1])
                output = self.consumeNumberEntity(hex)
            else:
                # No digits found
                self.tokenQueue.append({"type": tokenTypes["ParseError"],
                    "data": "expected-numeric-entity"})
                self.stream.unget(charStack.pop())
                output = u"&" + u"".join(charStack)

        else:
            # At this point in the process might have named entity. Entities
            # are stored in the global variable "entities".
            #
            # Consume characters and compare to these to a substring of the
            # entity names in the list until the substring no longer matches.
            filteredEntityList = entitiesByFirstChar.get(charStack[0], [])

            def entitiesStartingWith(name):
                return [e for e in filteredEntityList if e.startswith(name)]

            while (charStack[-1] is not EOF and
                   entitiesStartingWith("".join(charStack))):
                charStack.append(self.stream.char())

            # At this point we have a string that starts with some characters
            # that may match an entity
            entityName = None

            # Try to find the longest entity the string will match to take care
            # of &noti for instance.
            for entityLength in xrange(len(charStack)-1, 1, -1):
                possibleEntityName = "".join(charStack[:entityLength])
                if possibleEntityName in entities:
                    entityName = possibleEntityName
                    break

            if entityName is not None:
                if entityName[-1] != ";":
                    self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                      "named-entity-without-semicolon"})
                if (entityName[-1] != ";" and fromAttribute and
                    (charStack[entityLength] in asciiLetters or
                     charStack[entityLength] in digits or
                    charStack[entityLength] == "=")):
                    self.stream.unget(charStack.pop())
                    output = u"&" + u"".join(charStack)
                else:
                    output = entities[entityName]
                    self.stream.unget(charStack.pop())
                    output += u"".join(charStack[entityLength:])
            else:
                self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                  "expected-named-entity"})
                self.stream.unget(charStack.pop())
                output = u"&" + u"".join(charStack)

        if fromAttribute:
            self.currentToken["data"][-1][1] += output
        else:
            if output in spaceCharacters:
                tokenType = "SpaceCharacters"
            else:
                tokenType = "Characters"
            self.tokenQueue.append({"type": tokenTypes[tokenType], "data": output})

    def processEntityInAttribute(self, allowedChar):
        """This method replaces the need for "entityInAttributeValueState".
        """
        self.consumeEntity(allowedChar=allowedChar, fromAttribute=True)

    def emitCurrentToken(self):
        """This method is a generic handler for emitting the tags. It also sets
        the state to "data" because that's what's needed after a token has been
        emitted.
        """
        token = self.currentToken
        # Add token to the queue to be yielded
        if (token["type"] in tagTokenTypes):
            if self.lowercaseElementName:
                token["name"] = token["name"].translate(asciiUpper2Lower)
            if token["type"] == tokenTypes["EndTag"]:
                if token["data"]:
                    self.tokenQueue.append({"type":tokenTypes["ParseError"],
                                            "data":"attributes-in-end-tag"})
                if token["selfClosing"]:
                    self.tokenQueue.append({"type":tokenTypes["ParseError"],
                                            "data":"self-closing-flag-on-end-tag"})
        self.tokenQueue.append(token)
        self.state = self.dataState


    # Below are the various tokenizer states worked out.

    def dataState(self):
        data = self.stream.char()
        if data == "&":
            self.state = self.entityDataState
        elif data == "<":
            self.state = self.tagOpenState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data":"invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\u0000"})
        elif data is EOF:
            # Tokenization ends.
            return False
        elif data in spaceCharacters:
            # Directly after emitting a token you switch back to the "data
            # state". At that point spaceCharacters are important so they are
            # emitted separately.
            self.tokenQueue.append({"type": tokenTypes["SpaceCharacters"], "data":
              data + self.stream.charsUntil(spaceCharacters, True)})
            # No need to update lastFourChars here, since the first space will
            # have already been appended to lastFourChars and will have broken
            # any <!-- or --> sequences
        else:
            chars = self.stream.charsUntil((u"&", u"<", u"\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
              data + chars})
        return True

    def entityDataState(self):
        self.consumeEntity()
        self.state = self.dataState
        return True
    
    def rcdataState(self):
        data = self.stream.char()
        if data == "&":
            self.state = self.characterReferenceInRcdata
        elif data == "<":
            self.state = self.rcdataLessThanSignState
        elif data == EOF:
            # Tokenization ends.
            return False
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        elif data in spaceCharacters:
            # Directly after emitting a token you switch back to the "data
            # state". At that point spaceCharacters are important so they are
            # emitted separately.
            self.tokenQueue.append({"type": tokenTypes["SpaceCharacters"], "data":
              data + self.stream.charsUntil(spaceCharacters, True)})
            # No need to update lastFourChars here, since the first space will
            # have already been appended to lastFourChars and will have broken
            # any <!-- or --> sequences
        else:
            chars = self.stream.charsUntil((u"&", u"<"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
              data + chars})
        return True

    def characterReferenceInRcdata(self):
        self.consumeEntity()
        self.state = self.rcdataState
        return True
    
    def rawtextState(self):
        data = self.stream.char()
        if data == "<":
            self.state = self.rawtextLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        elif data == EOF:
            # Tokenization ends.
            return False
        else:
            chars = self.stream.charsUntil((u"<", u"\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
              data + chars})
        return True
    
    def scriptDataState(self):
        data = self.stream.char()
        if data == "<":
            self.state = self.scriptDataLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        elif data == EOF:
            # Tokenization ends.
            return False
        else:
            chars = self.stream.charsUntil((u"<", u"\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
              data + chars})
        return True
    
    def plaintextState(self):
        data = self.stream.char()
        if data == EOF:
            # Tokenization ends.
            return False
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
                                    data + self.stream.charsUntil(u"\u0000")})
        return True

    def tagOpenState(self):
        data = self.stream.char()
        if data == u"!":
            self.state = self.markupDeclarationOpenState
        elif data == u"/":
            self.state = self.closeTagOpenState
        elif data in asciiLetters:
            self.currentToken = {"type": tokenTypes["StartTag"], 
                                 "name": data, "data": [],
                                 "selfClosing": False,
                                 "selfClosingAcknowledged": False}
            self.state = self.tagNameState
        elif data == u">":
            # XXX In theory it could be something besides a tag name. But
            # do we really care?
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-tag-name-but-got-right-bracket"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<>"})
            self.state = self.dataState
        elif data == u"?":
            # XXX In theory it could be something besides a tag name. But
            # do we really care?
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-tag-name-but-got-question-mark"})
            self.stream.unget(data)
            self.state = self.bogusCommentState
        else:
            # XXX
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-tag-name"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.stream.unget(data)
            self.state = self.dataState
        return True

    def closeTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.currentToken = {"type": tokenTypes["EndTag"], "name": data,
                                 "data": [], "selfClosing":False}
            self.state = self.tagNameState
        elif data == u">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-closing-tag-but-got-right-bracket"})
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-closing-tag-but-got-eof"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"</"})
            self.state = self.dataState
        else:
            # XXX data can be _'_...
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-closing-tag-but-got-char",
              "datavars": {"data": data}})
            self.stream.unget(data)
            self.state = self.bogusCommentState
        return True

    def tagNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == u">":
            self.emitCurrentToken()
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-tag-name"})
            self.state = self.dataState
        elif data == u"/":
            self.state = self.selfClosingStartTagState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] += u"\uFFFD"
        else:
            self.currentToken["name"] += data
            # (Don't use charsUntil here, because tag names are
            # very short and it's faster to not do anything fancy)
        return True
    
    def rcdataLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.rcdataEndTagOpenState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True
    
    def rcdataEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.rcdataEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"</"})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True
    
    def rcdataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": u"</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True
    
    def rawtextLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.rawtextEndTagOpenState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True
    
    def rawtextEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.rawtextEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"</"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True
    
    def rawtextEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": u"</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True
    
    def scriptDataLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEndTagOpenState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<!"})
            self.state = self.scriptDataEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True
    
    def scriptDataEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.scriptDataEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"</"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True
    
    def scriptDataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": u"</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True
    
    def scriptDataEscapeStartState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataEscapeStartDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True
    
    def scriptDataEscapeStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataEscapedDashDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True
    
    def scriptDataEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataEscapedDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        elif data == EOF:
            self.state = self.dataState
        else:
            chars = self.stream.charsUntil((u"<", u"-", u"\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": 
              data + chars})
        return True
    
    def scriptDataEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataEscapedDashDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataEscapedDashDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u">"})
            self.state = self.scriptDataState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEscapedEndTagOpenState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<" + data})
            self.temporaryBuffer = data
            self.state = self.scriptDataDoubleEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataEscapedEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer = data
            self.state = self.scriptDataEscapedEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"</"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataEscapedEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing":False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": u"</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataDoubleEscapeStartState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataDoubleEscapedState
            else:
                self.state = self.scriptDataEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True
    
    def scriptDataDoubleEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataDoubleEscapedDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
        return True
    
    def scriptDataDoubleEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
            self.state = self.scriptDataDoubleEscapedDashDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True
    
    def scriptDataDoubleEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"-"})
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u">"})
            self.state = self.scriptDataState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": u"\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True
    
    def scriptDataDoubleEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": u"/"})
            self.temporaryBuffer = ""
            self.state = self.scriptDataDoubleEscapeEndState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True
    
    def scriptDataDoubleEscapeEndState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataEscapedState
            else:
                self.state = self.scriptDataDoubleEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True

    def beforeAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == u">":
            self.emitCurrentToken()
        elif data == u"/":
            self.state = self.selfClosingStartTagState
        elif data in (u"'", u'"', u"=", u"<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "invalid-character-in-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append([u"\uFFFD", ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-attribute-name-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def attributeNameState(self):
        data = self.stream.char()
        leavingThisState = True
        emitToken = False
        if data == u"=":
            self.state = self.beforeAttributeValueState
        elif data in asciiLetters:
            self.currentToken["data"][-1][0] += data +\
              self.stream.charsUntil(asciiLetters, True)
            leavingThisState = False
        elif data == u">":
            # XXX If we emit here the attributes are converted to a dict
            # without being checked and when the code below runs we error
            # because data is a dict not a list
            emitToken = True
        elif data in spaceCharacters:
            self.state = self.afterAttributeNameState
        elif data == u"/":
            self.state = self.selfClosingStartTagState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][0] += u"\uFFFD"
            leavingThisState = False
        elif data in (u"'", u'"', u"<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data":
                                        "invalid-character-in-attribute-name"})
            self.currentToken["data"][-1][0] += data
            leavingThisState = False
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "eof-in-attribute-name"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][0] += data
            leavingThisState = False

        if leavingThisState:
            # Attributes are not dropped at this stage. That happens when the
            # start tag token is emitted so values can still be safely appended
            # to attributes, but we do want to report the parse error in time.
            if self.lowercaseAttrName:
                self.currentToken["data"][-1][0] = (
                    self.currentToken["data"][-1][0].translate(asciiUpper2Lower))
            for name, value in self.currentToken["data"][:-1]:
                if self.currentToken["data"][-1][0] == name:
                    self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                      "duplicate-attribute"})
                    break
            # XXX Fix for above XXX
            if emitToken:
                self.emitCurrentToken()
        return True

    def afterAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == u"=":
            self.state = self.beforeAttributeValueState
        elif data == u">":
            self.emitCurrentToken()
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == u"/":
            self.state = self.selfClosingStartTagState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append([u"\uFFFD", ""])
            self.state = self.attributeNameState
        elif data in (u"'", u'"', u"<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "invalid-character-after-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-end-of-tag-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def beforeAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == u"\"":
            self.state = self.attributeValueDoubleQuotedState
        elif data == u"&":
            self.state = self.attributeValueUnQuotedState
            self.stream.unget(data);
        elif data == u"'":
            self.state = self.attributeValueSingleQuotedState
        elif data == u">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-attribute-value-but-got-right-bracket"})
            self.emitCurrentToken()
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += u"\uFFFD"
            self.state = self.attributeValueUnQuotedState
        elif data in (u"=", u"<", u"`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "equals-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-attribute-value-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        return True

    def attributeValueDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterAttributeValueState
        elif data == u"&":
            self.processEntityInAttribute(u'"')
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += u"\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-attribute-value-double-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
              self.stream.charsUntil(("\"", u"&"))
        return True

    def attributeValueSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterAttributeValueState
        elif data == u"&":
            self.processEntityInAttribute(u"'")
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += u"\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-attribute-value-single-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
              self.stream.charsUntil(("'", u"&"))
        return True

    def attributeValueUnQuotedState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == u"&":
            self.processEntityInAttribute(">")
        elif data == u">":
            self.emitCurrentToken()
        elif data in (u'"', u"'", u"=", u"<", u"`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-character-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += u"\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-attribute-value-no-quotes"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data + self.stream.charsUntil(
              frozenset((u"&", u">", u'"', u"'", u"=", u"<", u"`")) | spaceCharacters)
        return True

    def afterAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == u">":
            self.emitCurrentToken()
        elif data == u"/":
            self.state = self.selfClosingStartTagState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-EOF-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-character-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def selfClosingStartTagState(self):
        data = self.stream.char()
        if data == ">":
            self.currentToken["selfClosing"] = True
            self.emitCurrentToken()
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data":
                                        "unexpected-EOF-after-solidus-in-tag"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-character-after-soldius-in-tag"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def bogusCommentState(self):
        # Make a new comment token and give it as value all the characters
        # until the first > or EOF (charsUntil checks for EOF automatically)
        # and emit it.
        data = self.stream.charsUntil(u">")
        data = data.replace(u"\u0000", u"\uFFFD")
        self.tokenQueue.append(
          {"type": tokenTypes["Comment"], "data": data})

        # Eat the character directly after the bogus comment which is either a
        # ">" or an EOF.
        self.stream.char()
        self.state = self.dataState
        return True

    def markupDeclarationOpenState(self):
        charStack = [self.stream.char()]
        if charStack[-1] == u"-":
            charStack.append(self.stream.char())
            if charStack[-1] == u"-":
                self.currentToken = {"type": tokenTypes["Comment"], "data": u""}
                self.state = self.commentStartState
                return True
        elif charStack[-1] in (u'd', u'D'):
            matched = True
            for expected in ((u'o', u'O'), (u'c', u'C'), (u't', u'T'),
                             (u'y', u'Y'), (u'p', u'P'), (u'e', u'E')):
                charStack.append(self.stream.char())
                if charStack[-1] not in expected:
                    matched = False
                    break
            if matched:
                self.currentToken = {"type": tokenTypes["Doctype"],
                                     "name": u"",
                                     "publicId": None, "systemId": None, 
                                     "correct": True}
                self.state = self.doctypeState
                return True
        elif (charStack[-1] == "[" and 
              self.parser is not None and
              self.parser.tree.openElements and
              self.parser.tree.openElements[-1].namespace != self.parser.tree.defaultNamespace):
            matched = True
            for expected in ["C", "D", "A", "T", "A", "["]:
                charStack.append(self.stream.char())
                if charStack[-1] != expected:
                    matched = False
                    break
            if matched:
                self.state = self.cdataSectionState
                return True

        self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
          "expected-dashes-or-doctype"})

        while charStack:
            self.stream.unget(charStack.pop())
        self.state = self.bogusCommentState
        return True

    def commentStartState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentStartDashState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data
            self.state = self.commentState
        return True
    
    def commentStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"-\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "-" + data
            self.state = self.commentState
        return True

    
    def commentState(self):
        data = self.stream.char()
        if data == u"-":
            self.state = self.commentEndDashState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data + \
                self.stream.charsUntil((u"-", u"\u0000"))
        return True

    def commentEndDashState(self):
        data = self.stream.char()
        if data == u"-":
            self.state = self.commentEndState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"-\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-comment-end-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += u"-" + data
            self.state = self.commentState
        return True

    def commentEndState(self):
        data = self.stream.char()
        if data == u">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"--\uFFFD"
            self.state = self.commentState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-bang-after-double-dash-in-comment"})
            self.state = self.commentEndBangState
        elif data == u"-":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
             "unexpected-dash-after-double-dash-in-comment"})
            self.currentToken["data"] += data
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-comment-double-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            # XXX
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-comment"})
            self.currentToken["data"] += u"--" + data
            self.state = self.commentState
        return True

    def commentEndBangState(self):
        data = self.stream.char()
        if data == u">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == u"-":
            self.currentToken["data"] += "--!"
            self.state = self.commentEndDashState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += u"--!\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-comment-end-bang-state"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += u"--!" + data
            self.state = self.commentState
        return True

    def doctypeState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "need-space-after-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeNameState
        return True

    def beforeDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == u">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-doctype-name-but-got-right-bracket"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] = u"\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] = data
            self.state = self.doctypeNameState
        return True

    def doctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.state = self.afterDoctypeNameState
        elif data == u">":
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] += u"\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype-name"})
            self.currentToken["correct"] = False
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] += data
        return True

    def afterDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == u">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.currentToken["correct"] = False
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            if data in (u"p", u"P"):
                matched = True
                for expected in ((u"u", u"U"), (u"b", u"B"), (u"l", u"L"),
                                 (u"i", u"I"), (u"c", u"C")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypePublicKeywordState
                    return True
            elif data in (u"s", u"S"):
                matched = True
                for expected in ((u"y", u"Y"), (u"s", u"S"), (u"t", u"T"),
                                 (u"e", u"E"), (u"m", u"M")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypeSystemKeywordState
                    return True

            # All the characters read before the current 'data' will be
            # [a-zA-Z], so they're garbage in the bogus doctype and can be
            # discarded; only the latest character might be '>' or EOF
            # and needs to be ungetted
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                "expected-space-or-right-bracket-in-doctype", "datavars":
                {"data": data}})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState

        return True
    
    def afterDoctypePublicKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypePublicIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        return True

    def beforeDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["publicId"] = u""
            self.state = self.doctypePublicIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["publicId"] = u""
            self.state = self.doctypePublicIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypePublicIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += u"\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def doctypePublicIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += u"\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def afterDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.betweenDoctypePublicAndSystemIdentifiersState
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True
    
    def betweenDoctypePublicAndSystemIdentifiersState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True
    
    def afterDoctypeSystemKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        return True
    
    def beforeDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = u""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypeSystemIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += u"\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def doctypeSystemIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == u"\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += u"\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def afterDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
              "unexpected-char-in-doctype"})
            self.state = self.bogusDoctypeState
        return True

    def bogusDoctypeState(self):
        data = self.stream.char()
        if data == u">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            # XXX EMIT
            self.stream.unget(data)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            pass
        return True

    def cdataSectionState(self):
        data = []
        while True:
            data.append(self.stream.charsUntil(u"]"))
            charStack = []

            for expected in ["]", "]", ">"]:
                charStack.append(self.stream.char())
                matched = True
                if charStack[-1] == EOF:
                    data.extend(charStack[:-1])
                    break
                elif charStack[-1] != expected:
                    matched = False
                    data.extend(charStack)
                    break

            if matched:
                break
        data = "".join(data)
        #Deal with null here rather than in the parser
        nullCount = data.count(u"\u0000")
        if nullCount > 0:
            for i in xrange(nullCount):
                self.tokenQueue.append({"type": tokenTypes["ParseError"], 
                                        "data": "invalid-codepoint"})
            data = data.replace(u"\u0000", u"\uFFFD")
        if data:
            self.tokenQueue.append({"type": tokenTypes["Characters"], 
                                    "data": data})
        self.state = self.dataState
        return True

########NEW FILE########
__FILENAME__ = dom

from xml.dom import minidom, Node, XML_NAMESPACE, XMLNS_NAMESPACE
try:
    from types import ModuleType
except:
    from new import module as ModuleType
import re
import weakref

import _base
from html5lib import constants, ihatexml
from html5lib.constants import namespaces

moduleCache = {}

def getDomModule(DomImplementation):
    name = "_" + DomImplementation.__name__+"builder"
    if name in moduleCache:
        return moduleCache[name]
    else:
        mod = ModuleType(name)
        objs = getDomBuilder(DomImplementation)
        mod.__dict__.update(objs)
        moduleCache[name] = mod    
        return mod

def getDomBuilder(DomImplementation):
    Dom = DomImplementation
    class AttrList(object):
        def __init__(self, element):
            self.element = element
        def __iter__(self):
            return self.element.attributes.items().__iter__()
        def __setitem__(self, name, value):
            self.element.setAttribute(name, value)
        def __len__(self):
            return len(self.element.attributes.items())
        def items(self):
            return [(item[0], item[1]) for item in
                     self.element.attributes.items()]
        def keys(self):
            return self.element.attributes.keys()
        def __getitem__(self, name):
            return self.element.getAttribute(name)

        def __contains__(self, name):
            if isinstance(name, tuple):
                raise NotImplementedError
            else:
                return self.element.hasAttribute(name)
    
    class NodeBuilder(_base.Node):
        def __init__(self, element):
            _base.Node.__init__(self, element.nodeName)
            self.element = element

        namespace = property(lambda self:hasattr(self.element, "namespaceURI")
                             and self.element.namespaceURI or None)

        def appendChild(self, node):
            node.parent = self
            self.element.appendChild(node.element)
    
        def insertText(self, data, insertBefore=None):
            text = self.element.ownerDocument.createTextNode(data)
            if insertBefore:
                self.element.insertBefore(text, insertBefore.element)
            else:
                self.element.appendChild(text)
    
        def insertBefore(self, node, refNode):
            self.element.insertBefore(node.element, refNode.element)
            node.parent = self
    
        def removeChild(self, node):
            if node.element.parentNode == self.element:
                self.element.removeChild(node.element)
            node.parent = None
    
        def reparentChildren(self, newParent):
            while self.element.hasChildNodes():
                child = self.element.firstChild
                self.element.removeChild(child)
                newParent.element.appendChild(child)
            self.childNodes = []
    
        def getAttributes(self):
            return AttrList(self.element)
    
        def setAttributes(self, attributes):
            if attributes:
                for name, value in attributes.items():
                    if isinstance(name, tuple):
                        if name[0] is not None:
                            qualifiedName = (name[0] + ":" + name[1])
                        else:
                            qualifiedName = name[1]
                        self.element.setAttributeNS(name[2], qualifiedName, 
                                                    value)
                    else:
                        self.element.setAttribute(
                            name, value)
        attributes = property(getAttributes, setAttributes)
    
        def cloneNode(self):
            return NodeBuilder(self.element.cloneNode(False))
    
        def hasContent(self):
            return self.element.hasChildNodes()

        def getNameTuple(self):
            if self.namespace == None:
                return namespaces["html"], self.name
            else:
                return self.namespace, self.name

        nameTuple = property(getNameTuple)

    class TreeBuilder(_base.TreeBuilder):
        def documentClass(self):
            self.dom = Dom.getDOMImplementation().createDocument(None,None,None)
            return weakref.proxy(self)
    
        def insertDoctype(self, token):
            name = token["name"]
            publicId = token["publicId"]
            systemId = token["systemId"]

            domimpl = Dom.getDOMImplementation()
            doctype = domimpl.createDocumentType(name, publicId, systemId)
            self.document.appendChild(NodeBuilder(doctype))
            if Dom == minidom:
                doctype.ownerDocument = self.dom
    
        def elementClass(self, name, namespace=None):
            if namespace is None and self.defaultNamespace is None:
                node = self.dom.createElement(name)
            else:
                node = self.dom.createElementNS(namespace, name)

            return NodeBuilder(node)
            
        def commentClass(self, data):
            return NodeBuilder(self.dom.createComment(data))
        
        def fragmentClass(self):
            return NodeBuilder(self.dom.createDocumentFragment())
    
        def appendChild(self, node):
            self.dom.appendChild(node.element)
    
        def testSerializer(self, element):
            return testSerializer(element)
    
        def getDocument(self):
            return self.dom
        
        def getFragment(self):
            return _base.TreeBuilder.getFragment(self).element
    
        def insertText(self, data, parent=None):
            data=data
            if parent <> self:
                _base.TreeBuilder.insertText(self, data, parent)
            else:
                # HACK: allow text nodes as children of the document node
                if hasattr(self.dom, '_child_node_types'):
                    if not Node.TEXT_NODE in self.dom._child_node_types:
                        self.dom._child_node_types=list(self.dom._child_node_types)
                        self.dom._child_node_types.append(Node.TEXT_NODE)
                self.dom.appendChild(self.dom.createTextNode(data))
    
        name = None
    
    def testSerializer(element):
        element.normalize()
        rv = []
        def serializeElement(element, indent=0):
            if element.nodeType == Node.DOCUMENT_TYPE_NODE:
                if element.name:
                    if element.publicId or element.systemId:
                        publicId = element.publicId or ""
                        systemId = element.systemId or ""
                        rv.append( """|%s<!DOCTYPE %s "%s" "%s">"""%(
                                ' '*indent, element.name, publicId, systemId))
                    else:
                        rv.append("|%s<!DOCTYPE %s>"%(' '*indent, element.name))
                else:
                    rv.append("|%s<!DOCTYPE >"%(' '*indent,))
            elif element.nodeType == Node.DOCUMENT_NODE:
                rv.append("#document")
            elif element.nodeType == Node.DOCUMENT_FRAGMENT_NODE:
                rv.append("#document-fragment")
            elif element.nodeType == Node.COMMENT_NODE:
                rv.append("|%s<!-- %s -->"%(' '*indent, element.nodeValue))
            elif element.nodeType == Node.TEXT_NODE:
                rv.append("|%s\"%s\"" %(' '*indent, element.nodeValue))
            else:
                if (hasattr(element, "namespaceURI") and
                    element.namespaceURI != None):
                    name = "%s %s"%(constants.prefixes[element.namespaceURI],
                                    element.nodeName)
                else:
                    name = element.nodeName
                rv.append("|%s<%s>"%(' '*indent, name))
                if element.hasAttributes():
                    attributes = []
                    for i in range(len(element.attributes)):
                        attr = element.attributes.item(i)
                        name = attr.nodeName
                        value = attr.value
                        ns = attr.namespaceURI
                        if ns:
                            name = "%s %s"%(constants.prefixes[ns], attr.localName)
                        else:
                            name = attr.nodeName
                        attributes.append((name, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' '*(indent+2), name, value))
            indent += 2
            for child in element.childNodes:
                serializeElement(child, indent)
        serializeElement(element, 0)
    
        return "\n".join(rv)
    
    def dom2sax(node, handler, nsmap={'xml':XML_NAMESPACE}):
      if node.nodeType == Node.ELEMENT_NODE:
        if not nsmap:
          handler.startElement(node.nodeName, node.attributes)
          for child in node.childNodes: dom2sax(child, handler, nsmap)
          handler.endElement(node.nodeName)
        else:
          attributes = dict(node.attributes.itemsNS()) 
    
          # gather namespace declarations
          prefixes = []
          for attrname in node.attributes.keys():
            attr = node.getAttributeNode(attrname)
            if (attr.namespaceURI == XMLNS_NAMESPACE or
               (attr.namespaceURI == None and attr.nodeName.startswith('xmlns'))):
              prefix = (attr.nodeName != 'xmlns' and attr.nodeName or None)
              handler.startPrefixMapping(prefix, attr.nodeValue)
              prefixes.append(prefix)
              nsmap = nsmap.copy()
              nsmap[prefix] = attr.nodeValue
              del attributes[(attr.namespaceURI, attr.nodeName)]
    
          # apply namespace declarations
          for attrname in node.attributes.keys():
            attr = node.getAttributeNode(attrname)
            if attr.namespaceURI == None and ':' in attr.nodeName:
              prefix = attr.nodeName.split(':')[0]
              if nsmap.has_key(prefix):
                del attributes[(attr.namespaceURI, attr.nodeName)]
                attributes[(nsmap[prefix],attr.nodeName)]=attr.nodeValue
    
          # SAX events
          ns = node.namespaceURI or nsmap.get(None,None)
          handler.startElementNS((ns,node.nodeName), node.nodeName, attributes)
          for child in node.childNodes: dom2sax(child, handler, nsmap)
          handler.endElementNS((ns, node.nodeName), node.nodeName)
          for prefix in prefixes: handler.endPrefixMapping(prefix)
    
      elif node.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]:
        handler.characters(node.nodeValue)
    
      elif node.nodeType == Node.DOCUMENT_NODE:
        handler.startDocument()
        for child in node.childNodes: dom2sax(child, handler, nsmap)
        handler.endDocument()
    
      elif node.nodeType == Node.DOCUMENT_FRAGMENT_NODE:
        for child in node.childNodes: dom2sax(child, handler, nsmap)
    
      else:
        # ATTRIBUTE_NODE
        # ENTITY_NODE
        # PROCESSING_INSTRUCTION_NODE
        # COMMENT_NODE
        # DOCUMENT_TYPE_NODE
        # NOTATION_NODE
        pass
        
    return locals()

# Keep backwards compatibility with things that directly load 
# classes/functions from this module
for key, value in getDomModule(minidom).__dict__.items():
	globals()[key] = value

########NEW FILE########
__FILENAME__ = etree
try:
    from types import ModuleType
except:
    from new import module as ModuleType
import re
import types

import _base
from html5lib import ihatexml
from html5lib import constants
from html5lib.constants import namespaces

tag_regexp = re.compile("{([^}]*)}(.*)")

moduleCache = {}

def getETreeModule(ElementTreeImplementation, fullTree=False):
    name = "_" + ElementTreeImplementation.__name__+"builder"
    if name in moduleCache:
        return moduleCache[name]
    else:
        mod = ModuleType("_" + ElementTreeImplementation.__name__+"builder")
        objs = getETreeBuilder(ElementTreeImplementation, fullTree)
        mod.__dict__.update(objs)
        moduleCache[name] = mod    
        return mod

def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    class Element(_base.Node):
        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name,
                                                                  namespace))
            if namespace is None:
                self.nameTuple = namespaces["html"], self._name
            else:
                self.nameTuple = self._namespace, self._name
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = "{%s}%s"%(namespace, name)
            return etree_tag
    
        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)
        
        def _getName(self):
            return self._name
        
        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace

        namespace = property(_getNamespace, _setNamespace)
    
        def _getAttributes(self):
            return self._element.attrib
    
        def _setAttributes(self, attributes):
            #Delete existing attributes first
            #XXX - there may be a better way to do this...
            for key in self._element.attrib.keys():
                del self._element.attrib[key]
            for key, value in attributes.iteritems():
                if isinstance(key, tuple):
                    name = "{%s}%s"%(key[2], key[1])
                else:
                    name = key
                self._element.set(name, value)
    
        attributes = property(_getAttributes, _setAttributes)
    
        def _getChildNodes(self):
            return self._childNodes    
        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)
    
        childNodes = property(_getChildNodes, _setChildNodes)
    
        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))
    
        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self
    
        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self
    
        def removeChild(self, node):
            self._element.remove(node._element)
            node.parent=None
    
        def insertText(self, data, insertBefore=None):
            if not(len(self._element)):
                if not self._element.text:
                    self._element.text = ""
                self._element.text += data
            elif insertBefore is None:
                #Insert the text as the tail of the last child element
                if not self._element[-1].tail:
                    self._element[-1].tail = ""
                self._element[-1].tail += data
            else:
                #Insert the text before the specified node
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index-1].tail:
                        self._element[index-1].tail = ""
                    self._element[index-1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ""
                    self._element.text += data
    
        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            for name, value in self.attributes.iteritems():
                element.attributes[name] = value
            return element
    
        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ""
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ""
            _base.Node.reparentChildren(self, newParent)
    
    class Comment(Element):
        def __init__(self, data):
            #Use the superclass constructor to set all properties on the 
            #wrapper element
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []
            
        def _getData(self):
            return self._element.text
    
        def _setData(self, value):
            self._element.text = value
    
        data = property(_getData, _setData)
    
    class DocumentType(Element):
        def __init__(self, name, publicId, systemId):
            Element.__init__(self, "<!DOCTYPE>") 
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get(u"publicId", "")

        def _setPublicId(self, value):
            if value is not None:
                self._element.set(u"publicId", value)

        publicId = property(_getPublicId, _setPublicId)
    
        def _getSystemId(self):
            return self._element.get(u"systemId", "")

        def _setSystemId(self, value):
            if value is not None:
                self._element.set(u"systemId", value)

        systemId = property(_getSystemId, _setSystemId)
    
    class Document(Element):
        def __init__(self):
            Element.__init__(self, "<DOCUMENT_ROOT>") 
    
    class DocumentFragment(Element):
        def __init__(self):
            Element.__init__(self, "<DOCUMENT_FRAGMENT>")
    
    def testSerializer(element):
        rv = []
        finalText = None
        def serializeElement(element, indent=0):
            if not(hasattr(element, "tag")):
                element = element.getroot()
            if element.tag == "<!DOCTYPE>":
                if element.get("publicId") or element.get("systemId"):
                    publicId = element.get("publicId") or ""
                    systemId = element.get("systemId") or ""
                    rv.append( """<!DOCTYPE %s "%s" "%s">"""%(
                            element.text, publicId, systemId))
                else:     
                    rv.append("<!DOCTYPE %s>"%(element.text,))
            elif element.tag == "<DOCUMENT_ROOT>":
                rv.append("#document")
                if element.text:
                    rv.append("|%s\"%s\""%(' '*(indent+2), element.text))
                if element.tail:
                    finalText = element.tail
            elif element.tag == ElementTree.Comment:
                rv.append("|%s<!-- %s -->"%(' '*indent, element.text))
            else:
                assert type(element.tag) in types.StringTypes, "Expected unicode, got %s"%type(element.tag)
                nsmatch = tag_regexp.match(element.tag)

                if nsmatch is None:
                    name = element.tag
                else:
                    ns, name = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = "%s %s"%(prefix, name)
                rv.append("|%s<%s>"%(' '*indent, name))

                if hasattr(element, "attrib"):
                    attributes = []
                    for name, value in element.attrib.iteritems():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            ns, name = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = "%s %s"%(prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' '*(indent+2), name, value))
                if element.text:
                    rv.append("|%s\"%s\"" %(' '*(indent+2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append("|%s\"%s\"" %(' '*(indent-2), element.tail))
        serializeElement(element, 0)
    
        if finalText is not None:
            rv.append("|%s\"%s\""%(' '*2, finalText))
    
        return "\n".join(rv)
    
    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        finalText = None
        filter = ihatexml.InfosetFilter()
        def serializeElement(element):
            if type(element) == type(ElementTree.ElementTree):
                element = element.getroot()
            
            if element.tag == "<!DOCTYPE>":
                if element.get("publicId") or element.get("systemId"):
                    publicId = element.get("publicId") or ""
                    systemId = element.get("systemId") or ""
                    rv.append( """<!DOCTYPE %s PUBLIC "%s" "%s">"""%(
                            element.text, publicId, systemId))
                else:     
                    rv.append("<!DOCTYPE %s>"%(element.text,))
            elif element.tag == "<DOCUMENT_ROOT>":
                if element.text:
                    rv.append(element.text)
                if element.tail:
                    finalText = element.tail
    
                for child in element:
                    serializeElement(child)
    
            elif type(element.tag) == type(ElementTree.Comment):
                rv.append("<!--%s-->"%(element.text,))
            else:
                #This is assumed to be an ordinary element
                if not element.attrib:
                    rv.append("<%s>"%(filter.fromXmlName(element.tag),))
                else:
                    attr = " ".join(["%s=\"%s\""%(
                                filter.fromXmlName(name), value) 
                                     for name, value in element.attrib.iteritems()])
                    rv.append("<%s %s>"%(element.tag, attr))
                if element.text:
                    rv.append(element.text)
    
                for child in element:
                    serializeElement(child)
    
                rv.append("</%s>"%(element.tag,))
    
            if element.tail:
                rv.append(element.tail)
    
        serializeElement(element)
    
        if finalText is not None:
            rv.append("%s\""%(' '*2, finalText))
    
        return "".join(rv)
    
    class TreeBuilder(_base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
    
        def testSerializer(self, element):
            return testSerializer(element)
    
        def getDocument(self):
            if fullTree:
                return self.document._element
            else:
                if self.defaultNamespace is not None:
                    return self.document._element.find(
                        "{%s}html"%self.defaultNamespace)
                else:
                    return self.document._element.find("html")
        
        def getFragment(self):
            return _base.TreeBuilder.getFragment(self)._element
        
    return locals()

########NEW FILE########
__FILENAME__ = etree_lxml
import warnings
import re

import _base
from html5lib.constants import DataLossWarning
import html5lib.constants as constants
import etree as etree_builders
from html5lib import ihatexml

try:
    import lxml.etree as etree
except ImportError:
    pass

fullTree = True
tag_regexp = re.compile("{([^}]*)}(.*)")

"""Module for supporting the lxml.etree library. The idea here is to use as much
of the native library as possible, without using fragile hacks like custom element
names that break between releases. The downside of this is that we cannot represent
all possible trees; specifically the following are known to cause problems:

Text or comments as siblings of the root element
Docypes with no name

When any of these things occur, we emit a DataLossWarning
"""

class DocumentType(object):
    def __init__(self, name, publicId, systemId):
        self.name = name         
        self.publicId = publicId
        self.systemId = systemId

class Document(object):
    def __init__(self):
        self._elementTree = None
        self._childNodes = []

    def appendChild(self, element):
        self._elementTree.getroot().addnext(element._element)

    def _getChildNodes(self):
        return self._childNodes
    
    childNodes = property(_getChildNodes)

def testSerializer(element):
    rv = []
    finalText = None
    filter = ihatexml.InfosetFilter()
    def serializeElement(element, indent=0):
        if not hasattr(element, "tag"):
            if  hasattr(element, "getroot"):
                #Full tree case
                rv.append("#document")
                if element.docinfo.internalDTD:
                    if not (element.docinfo.public_id or 
                            element.docinfo.system_url):
                        dtd_str = "<!DOCTYPE %s>"%element.docinfo.root_name
                    else:
                        dtd_str = """<!DOCTYPE %s "%s" "%s">"""%(
                            element.docinfo.root_name, 
                            element.docinfo.public_id,
                            element.docinfo.system_url)
                    rv.append("|%s%s"%(' '*(indent+2), dtd_str))
                next_element = element.getroot()
                while next_element.getprevious() is not None:
                    next_element = next_element.getprevious()
                while next_element is not None:
                    serializeElement(next_element, indent+2)
                    next_element = next_element.getnext()
            elif isinstance(element, basestring):
                #Text in a fragment
                rv.append("|%s\"%s\""%(' '*indent, element))
            else:
                #Fragment case
                rv.append("#document-fragment")
                for next_element in element:
                    serializeElement(next_element, indent+2)
        elif type(element.tag) == type(etree.Comment):
            rv.append("|%s<!-- %s -->"%(' '*indent, element.text))
        else:
            nsmatch = etree_builders.tag_regexp.match(element.tag)
            if nsmatch is not None:
                ns = nsmatch.group(1)
                tag = nsmatch.group(2)
                prefix = constants.prefixes[ns]
                rv.append("|%s<%s %s>"%(' '*indent, prefix,
                                        filter.fromXmlName(tag)))
            else:
                rv.append("|%s<%s>"%(' '*indent,
                                     filter.fromXmlName(element.tag)))

            if hasattr(element, "attrib"):
                attributes = []
                for name, value in element.attrib.iteritems():
                    nsmatch = tag_regexp.match(name)
                    if nsmatch is not None:
                        ns, name = nsmatch.groups()
                        name = filter.fromXmlName(name)
                        prefix = constants.prefixes[ns]
                        attr_string = "%s %s"%(prefix, name)
                    else:
                        attr_string = filter.fromXmlName(name)
                    attributes.append((attr_string, value))

                for name, value in sorted(attributes):
                    rv.append('|%s%s="%s"' % (' '*(indent+2), name, value))

            if element.text:
                rv.append("|%s\"%s\"" %(' '*(indent+2), element.text))
            indent += 2
            for child in element.getchildren():
                serializeElement(child, indent)
        if hasattr(element, "tail") and element.tail:
            rv.append("|%s\"%s\"" %(' '*(indent-2), element.tail))
    serializeElement(element, 0)

    if finalText is not None:
        rv.append("|%s\"%s\""%(' '*2, finalText))

    return "\n".join(rv)

def tostring(element):
    """Serialize an element and its child nodes to a string"""
    rv = []
    finalText = None
    def serializeElement(element):
        if not hasattr(element, "tag"):
            if element.docinfo.internalDTD:
                if element.docinfo.doctype:
                    dtd_str = element.docinfo.doctype
                else:
                    dtd_str = "<!DOCTYPE %s>"%element.docinfo.root_name
                rv.append(dtd_str)
            serializeElement(element.getroot())
            
        elif type(element.tag) == type(etree.Comment):
            rv.append("<!--%s-->"%(element.text,))
        
        else:
            #This is assumed to be an ordinary element
            if not element.attrib:
                rv.append("<%s>"%(element.tag,))
            else:
                attr = " ".join(["%s=\"%s\""%(name, value) 
                                 for name, value in element.attrib.iteritems()])
                rv.append("<%s %s>"%(element.tag, attr))
            if element.text:
                rv.append(element.text)

            for child in element.getchildren():
                serializeElement(child)

            rv.append("</%s>"%(element.tag,))

        if hasattr(element, "tail") and element.tail:
            rv.append(element.tail)

    serializeElement(element)

    if finalText is not None:
        rv.append("%s\""%(' '*2, finalText))

    return "".join(rv)
        

class TreeBuilder(_base.TreeBuilder):
    documentClass = Document
    doctypeClass = DocumentType
    elementClass = None
    commentClass = None
    fragmentClass = Document    

    def __init__(self, namespaceHTMLElements, fullTree = False):
        builder = etree_builders.getETreeModule(etree, fullTree=fullTree)
        filter = self.filter = ihatexml.InfosetFilter()
        self.namespaceHTMLElements = namespaceHTMLElements

        class Attributes(dict):
            def __init__(self, element, value={}):
                self._element = element
                dict.__init__(self, value)
                for key, value in self.iteritems():
                    if isinstance(key, tuple):
                        name = "{%s}%s"%(key[2], filter.coerceAttribute(key[1]))
                    else:
                        name = filter.coerceAttribute(key)
                    self._element._element.attrib[name] = value

            def __setitem__(self, key, value):
                dict.__setitem__(self, key, value)
                if isinstance(key, tuple):
                    name = "{%s}%s"%(key[2], filter.coerceAttribute(key[1]))
                else:
                    name = filter.coerceAttribute(key)
                self._element._element.attrib[name] = value

        class Element(builder.Element):
            def __init__(self, name, namespace):
                name = filter.coerceElement(name)
                builder.Element.__init__(self, name, namespace=namespace)
                self._attributes = Attributes(self)

            def _setName(self, name):
                self._name = filter.coerceElement(name)
                self._element.tag = self._getETreeTag(
                    self._name, self._namespace)
        
            def _getName(self):
                return filter.fromXmlName(self._name)
        
            name = property(_getName, _setName)

            def _getAttributes(self):
                return self._attributes

            def _setAttributes(self, attributes):
                self._attributes = Attributes(self, attributes)
    
            attributes = property(_getAttributes, _setAttributes)

            def insertText(self, data, insertBefore=None):
                data = filter.coerceCharacters(data)
                builder.Element.insertText(self, data, insertBefore)

            def appendChild(self, child):
                builder.Element.appendChild(self, child)
                

        class Comment(builder.Comment):
            def __init__(self, data):
                data = filter.coerceComment(data)
                builder.Comment.__init__(self, data)

            def _setData(self, data):
                data = filter.coerceComment(data)
                self._element.text = data

            def _getData(self):
                return self._element.text

            data = property(_getData, _setData)

        self.elementClass = Element
        self.commentClass = builder.Comment
        #self.fragmentClass = builder.DocumentFragment
        _base.TreeBuilder.__init__(self, namespaceHTMLElements)
    
    def reset(self):
        _base.TreeBuilder.reset(self)
        self.insertComment = self.insertCommentInitial
        self.initial_comments = []
        self.doctype = None

    def testSerializer(self, element):
        return testSerializer(element)

    def getDocument(self):
        if fullTree:
            return self.document._elementTree
        else:
            return self.document._elementTree.getroot()
    
    def getFragment(self):
        fragment = []
        element = self.openElements[0]._element
        if element.text:
            fragment.append(element.text)
        fragment.extend(element.getchildren())
        if element.tail:
            fragment.append(element.tail)
        return fragment

    def insertDoctype(self, token):
        name = token["name"]
        publicId = token["publicId"]
        systemId = token["systemId"]

        if not name or ihatexml.nonXmlNameBMPRegexp.search(name) or name[0] == '"':
            warnings.warn("lxml cannot represent null or non-xml doctype", DataLossWarning)

        doctype = self.doctypeClass(name, publicId, systemId)
        self.doctype = doctype
    
    def insertCommentInitial(self, data, parent=None):
        self.initial_comments.append(data)
    
    def insertRoot(self, token):
        """Create the document root"""
        #Because of the way libxml2 works, it doesn't seem to be possible to
        #alter information like the doctype after the tree has been parsed. 
        #Therefore we need to use the built-in parser to create our iniial 
        #tree, after which we can add elements like normal
        docStr = ""
        if self.doctype and self.doctype.name and not self.doctype.name.startswith('"'):
            docStr += "<!DOCTYPE %s"%self.doctype.name
            if (self.doctype.publicId is not None or 
                self.doctype.systemId is not None):
                docStr += ' PUBLIC "%s" "%s"'%(self.doctype.publicId or "",
                                               self.doctype.systemId or "")
            docStr += ">"
        docStr += "<THIS_SHOULD_NEVER_APPEAR_PUBLICLY/>"
        
        try:
            root = etree.fromstring(docStr)
        except etree.XMLSyntaxError:
            print docStr
            raise
        
        #Append the initial comments:
        for comment_token in self.initial_comments:
            root.addprevious(etree.Comment(comment_token["data"]))
        
        #Create the root document and add the ElementTree to it
        self.document = self.documentClass()
        self.document._elementTree = root.getroottree()
        
        # Give the root element the right name
        name = token["name"]
        namespace = token.get("namespace", self.defaultNamespace)
        if namespace is None:
            etree_tag = name
        else:
            etree_tag = "{%s}%s"%(namespace, name)
        root.tag = etree_tag
        
        #Add the root element to the internal child/open data structures
        root_element = self.elementClass(name, namespace)
        root_element._element = root
        self.document._childNodes.append(root_element)
        self.openElements.append(root_element)
    
        #Reset to the default insert comment function
        self.insertComment = super(TreeBuilder, self).insertComment

########NEW FILE########
__FILENAME__ = simpletree
import _base
from html5lib.constants import voidElements, namespaces, prefixes
from xml.sax.saxutils import escape

# Really crappy basic implementation of a DOM-core like thing
class Node(_base.Node):
    type = -1
    def __init__(self, name):
        self.name = name
        self.parent = None
        self.value = None
        self.childNodes = []
        self._flags = []

    def __iter__(self):
        for node in self.childNodes:
            yield node
            for item in node:
                yield item

    def __unicode__(self):
        return self.name

    def toxml(self):
        raise NotImplementedError

    def printTree(self, indent=0):
        tree = '\n|%s%s' % (' '* indent, unicode(self))
        for child in self.childNodes:
            tree += child.printTree(indent + 2)
        return tree

    def appendChild(self, node):
        assert isinstance(node, Node)
        if (isinstance(node, TextNode) and self.childNodes and
          isinstance(self.childNodes[-1], TextNode)):
            self.childNodes[-1].value += node.value
        else:
            self.childNodes.append(node)
        node.parent = self

    def insertText(self, data, insertBefore=None):
        assert isinstance(data, unicode), "data %s is of type %s expected unicode"%(repr(data), type(data))
        if insertBefore is None:
            self.appendChild(TextNode(data))
        else:
            self.insertBefore(TextNode(data), insertBefore)

    def insertBefore(self, node, refNode):
        index = self.childNodes.index(refNode)
        if (isinstance(node, TextNode) and index > 0 and
          isinstance(self.childNodes[index - 1], TextNode)):
            self.childNodes[index - 1].value += node.value
        else:
            self.childNodes.insert(index, node)
        node.parent = self

    def removeChild(self, node):
        try:
            self.childNodes.remove(node)
        except:
            # XXX
            raise
        node.parent = None

    def cloneNode(self):
        raise NotImplementedError

    def hasContent(self):
        """Return true if the node has children or text"""
        return bool(self.childNodes)

    def getNameTuple(self):
        if self.namespace == None:
            return namespaces["html"], self.name
        else:
            return self.namespace, self.name

    nameTuple = property(getNameTuple)

class Document(Node):
    type = 1
    def __init__(self):
        Node.__init__(self, None)

    def __str__(self):
        return "#document"

    def __unicode__(self):
        return str(self)

    def appendChild(self, child):
        Node.appendChild(self, child)

    def toxml(self, encoding="utf=8"):
        result = ""
        for child in self.childNodes:
            result += child.toxml()
        return result.encode(encoding)

    def hilite(self, encoding="utf-8"):
        result = "<pre>"
        for child in self.childNodes:
            result += child.hilite()
        return result.encode(encoding) + "</pre>"
    
    def printTree(self):
        tree = unicode(self)
        for child in self.childNodes:
            tree += child.printTree(2)
        return tree

    def cloneNode(self):
        return Document()

class DocumentFragment(Document):
    type = 2
    def __str__(self):
        return "#document-fragment"

    def __unicode__(self):
        return str(self)

    def cloneNode(self):
        return DocumentFragment()

class DocumentType(Node):
    type = 3
    def __init__(self, name, publicId, systemId):
        Node.__init__(self, name)
        self.publicId = publicId
        self.systemId = systemId

    def __unicode__(self):
        if self.publicId or self.systemId:
            publicId = self.publicId or ""
            systemId = self.systemId or ""
            return """<!DOCTYPE %s "%s" "%s">"""%(
                self.name, publicId, systemId)
                            
        else:
            return u"<!DOCTYPE %s>" % self.name
    

    toxml = __unicode__
    
    def hilite(self):
        return '<code class="markup doctype">&lt;!DOCTYPE %s></code>' % self.name

    def cloneNode(self):
        return DocumentType(self.name, self.publicId, self.systemId)

class TextNode(Node):
    type = 4
    def __init__(self, value):
        Node.__init__(self, None)
        self.value = value

    def __unicode__(self):
        return u"\"%s\"" % self.value

    def toxml(self):
        return escape(self.value)
    
    hilite = toxml

    def cloneNode(self):
        return TextNode(self.value)

class Element(Node):
    type = 5
    def __init__(self, name, namespace=None):
        Node.__init__(self, name)
        self.namespace = namespace
        self.attributes = {}

    def __unicode__(self):
        if self.namespace == None:
            return u"<%s>" % self.name
        else:
            return u"<%s %s>"%(prefixes[self.namespace], self.name)

    def toxml(self):
        result = '<' + self.name
        if self.attributes:
            for name,value in self.attributes.iteritems():
                result += u' %s="%s"' % (name, escape(value,{'"':'&quot;'}))
        if self.childNodes:
            result += '>'
            for child in self.childNodes:
                result += child.toxml()
            result += u'</%s>' % self.name
        else:
            result += u'/>'
        return result
    
    def hilite(self):
        result = '&lt;<code class="markup element-name">%s</code>' % self.name
        if self.attributes:
            for name, value in self.attributes.iteritems():
                result += ' <code class="markup attribute-name">%s</code>=<code class="markup attribute-value">"%s"</code>' % (name, escape(value, {'"':'&quot;'}))
        if self.childNodes:
            result += ">"
            for child in self.childNodes:
                result += child.hilite()
        elif self.name in voidElements:
            return result + ">"
        return result + '&lt;/<code class="markup element-name">%s</code>>' % self.name

    def printTree(self, indent):
        tree = '\n|%s%s' % (' '*indent, unicode(self))
        indent += 2
        if self.attributes:
            for name, value in sorted(self.attributes.iteritems()):
                if isinstance(name, tuple):
                    name = "%s %s"%(name[0], name[1])
                tree += '\n|%s%s="%s"' % (' ' * indent, name, value)
        for child in self.childNodes:
            tree += child.printTree(indent)
        return tree

    def cloneNode(self):
        newNode = Element(self.name)
        if hasattr(self, 'namespace'):
            newNode.namespace = self.namespace
        for attr, value in self.attributes.iteritems():
            newNode.attributes[attr] = value
        return newNode

class CommentNode(Node):
    type = 6
    def __init__(self, data):
        Node.__init__(self, None)
        self.data = data

    def __unicode__(self):
        return "<!-- %s -->" % self.data
    
    def toxml(self):
        return "<!--%s-->" % self.data

    def hilite(self):
        return '<code class="markup comment">&lt;!--%s--></code>' % escape(self.data)

    def cloneNode(self):
        return CommentNode(self.data)

class TreeBuilder(_base.TreeBuilder):
    documentClass = Document
    doctypeClass = DocumentType
    elementClass = Element
    commentClass = CommentNode
    fragmentClass = DocumentFragment
    
    def testSerializer(self, node):
        return node.printTree()

########NEW FILE########
__FILENAME__ = soup
import warnings

warnings.warn("BeautifulSoup 3.x (as of 3.1) is not fully compatible with html5lib and support will be removed in the future", DeprecationWarning)

from BeautifulSoup import BeautifulSoup, Tag, NavigableString, Comment, Declaration

import _base
from html5lib.constants import namespaces, DataLossWarning

class AttrList(object):
    def __init__(self, element):
        self.element = element
        self.attrs = dict(self.element.attrs)
    def __iter__(self):
        return self.attrs.items().__iter__()
    def __setitem__(self, name, value):
        "set attr", name, value
        self.element[name] = value
    def items(self):
        return self.attrs.items()
    def keys(self):
        return self.attrs.keys()
    def __getitem__(self, name):
        return self.attrs[name]
    def __contains__(self, name):
        return name in self.attrs.keys()
    def __eq__(self, other):
        if len(self.keys()) != len(other.keys()):
            return False
        for item in self.keys():
            if item not in other:
                return False
            if self[item] != other[item]:
                return False
        return True

class Element(_base.Node):
    def __init__(self, element, soup, namespace):
        _base.Node.__init__(self, element.name)
        self.element = element
        self.soup = soup
        self.namespace = namespace

    def _nodeIndex(self, node, refNode):
        # Finds a node by identity rather than equality
        for index in range(len(self.element.contents)):
            if id(self.element.contents[index]) == id(refNode.element):
                return index
        return None

    def appendChild(self, node):
        if (node.element.__class__ == NavigableString and self.element.contents
            and self.element.contents[-1].__class__ == NavigableString):
            # Concatenate new text onto old text node
            # (TODO: This has O(n^2) performance, for input like "a</a>a</a>a</a>...")
            newStr = NavigableString(self.element.contents[-1]+node.element)

            # Remove the old text node
            # (Can't simply use .extract() by itself, because it fails if
            # an equal text node exists within the parent node)
            oldElement = self.element.contents[-1]
            del self.element.contents[-1]
            oldElement.parent = None
            oldElement.extract()

            self.element.insert(len(self.element.contents), newStr)
        else:
            self.element.insert(len(self.element.contents), node.element)
            node.parent = self

    def getAttributes(self):
        return AttrList(self.element)

    def setAttributes(self, attributes):
        if attributes:
            for name, value in attributes.items():
                self.element[name] =  value

    attributes = property(getAttributes, setAttributes)
    
    def insertText(self, data, insertBefore=None):
        text = TextNode(NavigableString(data), self.soup)
        if insertBefore:
            self.insertBefore(text, insertBefore)
        else:
            self.appendChild(text)

    def insertBefore(self, node, refNode):
        index = self._nodeIndex(node, refNode)
        if (node.element.__class__ == NavigableString and self.element.contents
            and self.element.contents[index-1].__class__ == NavigableString):
            # (See comments in appendChild)
            newStr = NavigableString(self.element.contents[index-1]+node.element)
            oldNode = self.element.contents[index-1]
            del self.element.contents[index-1]
            oldNode.parent = None
            oldNode.extract()

            self.element.insert(index-1, newStr)
        else:
            self.element.insert(index, node.element)
            node.parent = self

    def removeChild(self, node):
        index = self._nodeIndex(node.parent, node)
        del node.parent.element.contents[index]
        node.element.parent = None
        node.element.extract()
        node.parent = None

    def reparentChildren(self, newParent):
        while self.element.contents:
            child = self.element.contents[0]
            child.extract()
            if isinstance(child, Tag):
                newParent.appendChild(Element(child, self.soup, namespaces["html"]))
            else:
                newParent.appendChild(TextNode(child, self.soup))

    def cloneNode(self):
        node = Element(Tag(self.soup, self.element.name), self.soup, self.namespace)
        for key,value in self.attributes:
            node.attributes[key] = value
        return node

    def hasContent(self):
        return self.element.contents

    def getNameTuple(self):
        if self.namespace == None:
            return namespaces["html"], self.name
        else:
            return self.namespace, self.name

    nameTuple = property(getNameTuple)

class TextNode(Element):
    def __init__(self, element, soup):
        _base.Node.__init__(self, None)
        self.element = element
        self.soup = soup
    
    def cloneNode(self):
        raise NotImplementedError

class TreeBuilder(_base.TreeBuilder):
    def __init__(self, namespaceHTMLElements):
        if namespaceHTMLElements:
            warnings.warn("BeautifulSoup cannot represent elements in any namespace", DataLossWarning)
        _base.TreeBuilder.__init__(self, namespaceHTMLElements)
        
    def documentClass(self):
        self.soup = BeautifulSoup("")
        return Element(self.soup, self.soup, None)
    
    def insertDoctype(self, token):
        name = token["name"]
        publicId = token["publicId"]
        systemId = token["systemId"]

        if publicId:
            self.soup.insert(0, Declaration("DOCTYPE %s PUBLIC \"%s\" \"%s\""%(name, publicId, systemId or "")))
        elif systemId:
            self.soup.insert(0, Declaration("DOCTYPE %s SYSTEM \"%s\""%
                                            (name, systemId)))
        else:
            self.soup.insert(0, Declaration("DOCTYPE %s"%name))
    
    def elementClass(self, name, namespace):
        if namespace is not None:
            warnings.warn("BeautifulSoup cannot represent elements in any namespace", DataLossWarning)
        return Element(Tag(self.soup, name), self.soup, namespace)
        
    def commentClass(self, data):
        return TextNode(Comment(data), self.soup)
    
    def fragmentClass(self):
        self.soup = BeautifulSoup("")
        self.soup.name = "[document_fragment]"
        return Element(self.soup, self.soup, None) 

    def appendChild(self, node):
        self.soup.insert(len(self.soup.contents), node.element)

    def testSerializer(self, element):
        return testSerializer(element)

    def getDocument(self):
        return self.soup
    
    def getFragment(self):
        return _base.TreeBuilder.getFragment(self).element
    
def testSerializer(element):
    import re
    rv = []
    def serializeElement(element, indent=0):
        if isinstance(element, Declaration):
            doctype_regexp = r'DOCTYPE\s+(?P<name>[^\s]*)( PUBLIC "(?P<publicId>.*)" "(?P<systemId1>.*)"| SYSTEM "(?P<systemId2>.*)")?'
            m = re.compile(doctype_regexp).match(element.string)
            assert m is not None, "DOCTYPE did not match expected format"
            name = m.group('name')
            publicId = m.group('publicId')
            if publicId is not None:
                systemId = m.group('systemId1') or ""
            else:
                systemId = m.group('systemId2')

            if publicId is not None or systemId is not None:
                rv.append("""|%s<!DOCTYPE %s "%s" "%s">"""%
                          (' '*indent, name, publicId or "", systemId or ""))
            else:
                rv.append("|%s<!DOCTYPE %s>"%(' '*indent, name))
            
        elif isinstance(element, BeautifulSoup):
            if element.name == "[document_fragment]":
                rv.append("#document-fragment")                
            else:
                rv.append("#document")

        elif isinstance(element, Comment):
            rv.append("|%s<!-- %s -->"%(' '*indent, element.string))
        elif isinstance(element, unicode):
            rv.append("|%s\"%s\"" %(' '*indent, element))
        else:
            rv.append("|%s<%s>"%(' '*indent, element.name))
            if element.attrs:
                for name, value in sorted(element.attrs):
                    rv.append('|%s%s="%s"' % (' '*(indent+2), name, value))
        indent += 2
        if hasattr(element, "contents"):
            for child in element.contents:
                serializeElement(child, indent)
    serializeElement(element, 0)

    return "\n".join(rv)

########NEW FILE########
__FILENAME__ = _base
from html5lib.constants import scopingElements, tableInsertModeElements, namespaces
try:
    frozenset
except NameError:
    # Import from the sets module for python 2.3
    from sets import Set as set
    from sets import ImmutableSet as frozenset

# The scope markers are inserted when entering object elements,
# marquees, table cells, and table captions, and are used to prevent formatting
# from "leaking" into tables, object elements, and marquees.
Marker = None

class Node(object):
    def __init__(self, name):
        """Node representing an item in the tree.
        name - The tag name associated with the node
        parent - The parent of the current node (or None for the document node)
        value - The value of the current node (applies to text nodes and 
        comments
        attributes - a dict holding name, value pairs for attributes of the node
        childNodes - a list of child nodes of the current node. This must 
        include all elements but not necessarily other node types
        _flags - A list of miscellaneous flags that can be set on the node
        """
        self.name = name
        self.parent = None
        self.value = None
        self.attributes = {}
        self.childNodes = []
        self._flags = []

    def __unicode__(self):
        attributesStr =  " ".join(["%s=\"%s\""%(name, value) 
                                   for name, value in 
                                   self.attributes.iteritems()])
        if attributesStr:
            return "<%s %s>"%(self.name,attributesStr)
        else:
            return "<%s>"%(self.name)

    def __repr__(self):
        return "<%s>" % (self.name)

    def appendChild(self, node):
        """Insert node as a child of the current node
        """
        raise NotImplementedError

    def insertText(self, data, insertBefore=None):
        """Insert data as text in the current node, positioned before the 
        start of node insertBefore or to the end of the node's text.
        """
        raise NotImplementedError

    def insertBefore(self, node, refNode):
        """Insert node as a child of the current node, before refNode in the 
        list of child nodes. Raises ValueError if refNode is not a child of 
        the current node"""
        raise NotImplementedError

    def removeChild(self, node):
        """Remove node from the children of the current node
        """
        raise NotImplementedError

    def reparentChildren(self, newParent):
        """Move all the children of the current node to newParent. 
        This is needed so that trees that don't store text as nodes move the 
        text in the correct way
        """
        #XXX - should this method be made more general?
        for child in self.childNodes:
            newParent.appendChild(child)
        self.childNodes = []

    def cloneNode(self):
        """Return a shallow copy of the current node i.e. a node with the same
        name and attributes but with no parent or child nodes
        """
        raise NotImplementedError


    def hasContent(self):
        """Return true if the node has children or text, false otherwise
        """
        raise NotImplementedError

class ActiveFormattingElements(list):
    def append(self, node):
        equalCount = 0
        if node != Marker:
            for element in self[::-1]:
                if element == Marker:
                    break
                if self.nodesEqual(element, node):
                    equalCount += 1
                if equalCount == 3:
                    self.remove(element)
                    break
        list.append(self, node)

    def nodesEqual(self, node1, node2):
        if not node1.nameTuple == node2.nameTuple:
            return False
        
        if not node1.attributes == node2.attributes:
            return False
        
        return True

class TreeBuilder(object):
    """Base treebuilder implementation
    documentClass - the class to use for the bottommost node of a document
    elementClass - the class to use for HTML Elements
    commentClass - the class to use for comments
    doctypeClass - the class to use for doctypes
    """

    #Document class
    documentClass = None

    #The class to use for creating a node
    elementClass = None

    #The class to use for creating comments
    commentClass = None

    #The class to use for creating doctypes
    doctypeClass = None
    
    #Fragment class
    fragmentClass = None

    def __init__(self, namespaceHTMLElements):
        if namespaceHTMLElements:
            self.defaultNamespace = "http://www.w3.org/1999/xhtml"
        else:
            self.defaultNamespace = None
        self.reset()
    
    def reset(self):
        self.openElements = []
        self.activeFormattingElements = ActiveFormattingElements()

        #XXX - rename these to headElement, formElement
        self.headPointer = None
        self.formPointer = None

        self.insertFromTable = False

        self.document = self.documentClass()

    def elementInScope(self, target, variant=None):

        #If we pass a node in we match that. if we pass a string
        #match any node with that name
        exactNode = hasattr(target, "nameTuple")

        listElementsMap = {
            None:(scopingElements, False),
            "button":(scopingElements | set([(namespaces["html"], "button")]), False),
            "list":(scopingElements | set([(namespaces["html"], "ol"),
                                           (namespaces["html"], "ul")]), False),
            "table":(set([(namespaces["html"], "html"),
                          (namespaces["html"], "table")]), False),
            "select":(set([(namespaces["html"], "optgroup"), 
                           (namespaces["html"], "option")]), True)
            }
        listElements, invert = listElementsMap[variant]

        for node in reversed(self.openElements):
            if (node.name == target and not exactNode or
                node == target and exactNode):
                return True
            elif (invert ^ (node.nameTuple in listElements)):                
                return False

        assert False # We should never reach this point

    def reconstructActiveFormattingElements(self):
        # Within this algorithm the order of steps described in the
        # specification is not quite the same as the order of steps in the
        # code. It should still do the same though.

        # Step 1: stop the algorithm when there's nothing to do.
        if not self.activeFormattingElements:
            return

        # Step 2 and step 3: we start with the last element. So i is -1.
        i = len(self.activeFormattingElements) - 1
        entry = self.activeFormattingElements[i]
        if entry == Marker or entry in self.openElements:
            return

        # Step 6
        while entry != Marker and entry not in self.openElements:
            if i == 0:
                #This will be reset to 0 below
                i = -1
                break
            i -= 1
            # Step 5: let entry be one earlier in the list.
            entry = self.activeFormattingElements[i]

        while True:
            # Step 7
            i += 1

            # Step 8
            entry = self.activeFormattingElements[i]
            clone = entry.cloneNode() #Mainly to get a new copy of the attributes

            # Step 9
            element = self.insertElement({"type":"StartTag", 
                                          "name":clone.name, 
                                          "namespace":clone.namespace, 
                                          "data":clone.attributes})

            # Step 10
            self.activeFormattingElements[i] = element

            # Step 11
            if element == self.activeFormattingElements[-1]:
                break

    def clearActiveFormattingElements(self):
        entry = self.activeFormattingElements.pop()
        while self.activeFormattingElements and entry != Marker:
            entry = self.activeFormattingElements.pop()

    def elementInActiveFormattingElements(self, name):
        """Check if an element exists between the end of the active
        formatting elements and the last marker. If it does, return it, else
        return false"""

        for item in self.activeFormattingElements[::-1]:
            # Check for Marker first because if it's a Marker it doesn't have a
            # name attribute.
            if item == Marker:
                break
            elif item.name == name:
                return item
        return False

    def insertRoot(self, token):
        element = self.createElement(token)
        self.openElements.append(element)
        self.document.appendChild(element)

    def insertDoctype(self, token):
        name = token["name"]
        publicId = token["publicId"]
        systemId = token["systemId"]

        doctype = self.doctypeClass(name, publicId, systemId)
        self.document.appendChild(doctype)

    def insertComment(self, token, parent=None):
        if parent is None:
            parent = self.openElements[-1]
        parent.appendChild(self.commentClass(token["data"]))
                           
    def createElement(self, token):
        """Create an element but don't insert it anywhere"""
        name = token["name"]
        namespace = token.get("namespace", self.defaultNamespace)
        element = self.elementClass(name, namespace)
        element.attributes = token["data"]
        return element

    def _getInsertFromTable(self):
        return self._insertFromTable

    def _setInsertFromTable(self, value):
        """Switch the function used to insert an element from the
        normal one to the misnested table one and back again"""
        self._insertFromTable = value
        if value:
            self.insertElement = self.insertElementTable
        else:
            self.insertElement = self.insertElementNormal

    insertFromTable = property(_getInsertFromTable, _setInsertFromTable)
        
    def insertElementNormal(self, token):
        name = token["name"]
        assert type(name) == unicode, "Element %s not unicode"%name
        namespace = token.get("namespace", self.defaultNamespace)
        element = self.elementClass(name, namespace)
        element.attributes = token["data"]
        self.openElements[-1].appendChild(element)
        self.openElements.append(element)
        return element

    def insertElementTable(self, token):
        """Create an element and insert it into the tree""" 
        element = self.createElement(token)
        if self.openElements[-1].name not in tableInsertModeElements:
            return self.insertElementNormal(token)
        else:
            #We should be in the InTable mode. This means we want to do
            #special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition()
            if insertBefore is None:
                parent.appendChild(element)
            else:
                parent.insertBefore(element, insertBefore)
            self.openElements.append(element)
        return element

    def insertText(self, data, parent=None):
        """Insert text data."""
        if parent is None:
            parent = self.openElements[-1]

        if (not self.insertFromTable or (self.insertFromTable and
                                         self.openElements[-1].name 
                                         not in tableInsertModeElements)):
            parent.insertText(data)
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition()
            parent.insertText(data, insertBefore)
            
    def getTableMisnestedNodePosition(self):
        """Get the foster parent element, and sibling to insert before
        (or None) when inserting a misnested table node"""
        # The foster parent element is the one which comes before the most
        # recently opened table element
        # XXX - this is really inelegant
        lastTable=None
        fosterParent = None
        insertBefore = None
        for elm in self.openElements[::-1]:
            if elm.name == "table":
                lastTable = elm
                break
        if lastTable:
            # XXX - we should really check that this parent is actually a
            # node here
            if lastTable.parent:
                fosterParent = lastTable.parent
                insertBefore = lastTable
            else:
                fosterParent = self.openElements[
                    self.openElements.index(lastTable) - 1]
        else:
            fosterParent = self.openElements[0]
        return fosterParent, insertBefore

    def generateImpliedEndTags(self, exclude=None):
        name = self.openElements[-1].name
        # XXX td, th and tr are not actually needed
        if (name in frozenset(("dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"))
            and name != exclude):
            self.openElements.pop()
            # XXX This is not entirely what the specification says. We should
            # investigate it more closely.
            self.generateImpliedEndTags(exclude)

    def getDocument(self):
        "Return the final tree"
        return self.document
    
    def getFragment(self):
        "Return the final fragment"
        #assert self.innerHTML
        fragment = self.fragmentClass()
        self.openElements[0].reparentChildren(fragment)
        return fragment

    def testSerializer(self, node):
        """Serialize the subtree of node in the format required by unit tests
        node - the node from which to start serializing"""
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = dom
from xml.dom import Node

import gettext
_ = gettext.gettext

import _base
from html5lib.constants import voidElements

class TreeWalker(_base.NonRecursiveTreeWalker):
    def getNodeDetails(self, node):
        if node.nodeType == Node.DOCUMENT_TYPE_NODE:
            return _base.DOCTYPE, node.name, node.publicId, node.systemId

        elif node.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
            return _base.TEXT, node.nodeValue

        elif node.nodeType == Node.ELEMENT_NODE:
            attrs = {}
            for attr in node.attributes.keys():
                attr = node.getAttributeNode(attr)
                attrs[(attr.namespaceURI,attr.localName)] = attr.value
            return (_base.ELEMENT, node.namespaceURI, node.nodeName, 
                    attrs, node.hasChildNodes())

        elif node.nodeType == Node.COMMENT_NODE:
            return _base.COMMENT, node.nodeValue

        elif node.nodeType in (Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE):
            return (_base.DOCUMENT,)

        else:
            return _base.UNKNOWN, node.nodeType

    def getFirstChild(self, node):
        return node.firstChild

    def getNextSibling(self, node):
        return node.nextSibling

    def getParentNode(self, node):
        return node.parentNode

########NEW FILE########
__FILENAME__ = etree
import gettext
_ = gettext.gettext

try:
    from types import ModuleType
except:
    from new import module as ModuleType
import copy
import re

import _base
from html5lib.constants import voidElements

tag_regexp = re.compile("{([^}]*)}(.*)")

moduleCache = {}

def getETreeModule(ElementTreeImplementation):
    name = "_" + ElementTreeImplementation.__name__+"builder"
    if name in moduleCache:
        return moduleCache[name]
    else:
        mod = ModuleType("_" + ElementTreeImplementation.__name__+"builder")
        objs = getETreeBuilder(ElementTreeImplementation)
        mod.__dict__.update(objs)
        moduleCache[name] = mod
        return mod

def getETreeBuilder(ElementTreeImplementation):
    ElementTree = ElementTreeImplementation

    class TreeWalker(_base.NonRecursiveTreeWalker):
        """Given the particular ElementTree representation, this implementation,
        to avoid using recursion, returns "nodes" as tuples with the following
        content:

        1. The current element
        
        2. The index of the element relative to its parent
        
        3. A stack of ancestor elements
        
        4. A flag "text", "tail" or None to indicate if the current node is a
           text node; either the text or tail of the current element (1)
        """
        def getNodeDetails(self, node):
            if isinstance(node, tuple): # It might be the root Element
                elt, key, parents, flag = node
                if flag in ("text", "tail"):
                    return _base.TEXT, getattr(elt, flag)
                else:
                    node = elt

            if not(hasattr(node, "tag")):
                node = node.getroot()

            if node.tag in ("<DOCUMENT_ROOT>", "<DOCUMENT_FRAGMENT>"):
                return (_base.DOCUMENT,)

            elif node.tag == "<!DOCTYPE>":
                return (_base.DOCTYPE, node.text, 
                        node.get("publicId"), node.get("systemId"))

            elif node.tag == ElementTree.Comment:
                return _base.COMMENT, node.text

            else:
                assert type(node.tag) in (str, unicode), type(node.tag)
                #This is assumed to be an ordinary element
                match = tag_regexp.match(node.tag)
                if match:
                    namespace, tag = match.groups()
                else:
                    namespace = None
                    tag = node.tag
                attrs = {}
                for name, value in node.attrib.items():
                    match = tag_regexp.match(name)
                    if match:
                        attrs[(match.group(1),match.group(2))] = value
                    else:
                        attrs[(None,name)] = value
                return (_base.ELEMENT, namespace, tag, 
                        attrs, len(node) or node.text)
    
        def getFirstChild(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                element, key, parents, flag = node, None, [], None
                
            if flag in ("text", "tail"):
                return None
            else:
                if element.text:
                    return element, key, parents, "text"
                elif len(element):
                    parents.append(element)
                    return element[0], 0, parents, None
                else:
                    return None
        
        def getNextSibling(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                return None
                
            if flag == "text":
                if len(element):
                    parents.append(element)
                    return element[0], 0, parents, None
                else:
                    return None
            else:
                if element.tail and flag != "tail":
                    return element, key, parents, "tail"
                elif key < len(parents[-1]) - 1:
                    return parents[-1][key+1], key+1, parents, None
                else:
                    return None
        
        def getParentNode(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                return None
            
            if flag == "text":
                if not parents:
                    return element
                else:
                    return element, key, parents, None
            else:
                parent = parents.pop()
                if not parents:
                    return parent
                else:
                    return parent, list(parents[-1]).index(parent), parents, None

    return locals()

########NEW FILE########
__FILENAME__ = genshistream
from genshi.core import START, END, XML_NAMESPACE, DOCTYPE, TEXT
from genshi.core  import  START_NS, END_NS, START_CDATA, END_CDATA, PI, COMMENT
from genshi.output import NamespaceFlattener

import _base

from html5lib.constants import voidElements

class TreeWalker(_base.TreeWalker):
    def __iter__(self):
        depth = 0
        ignore_until = None
        previous = None
        for event in self.tree:
            if previous is not None:
                if previous[0] == START:
                    depth += 1
                if ignore_until <= depth:
                    ignore_until = None
                if ignore_until is None:
                    for token in self.tokens(previous, event):
                        yield token
                        if token["type"] == "EmptyTag":
                            ignore_until = depth
                if previous[0] == END:
                    depth -= 1
            previous = event
        if previous is not None:
            if ignore_until is None or ignore_until <= depth:
                for token in self.tokens(previous, None):
                    yield token
            elif ignore_until is not None:
                raise ValueError("Illformed DOM event stream: void element without END_ELEMENT")

    def tokens(self, event, next):
        kind, data, pos = event
        if kind == START:
            tag, attrib = data
            name = tag.localname
            namespace = tag.namespace
            if tag in voidElements:
                for token in self.emptyTag(namespace, name, list(attrib),
                                           not next or next[0] != END 
                                           or next[1] != tag):
                    yield token
            else:
                yield self.startTag(namespace, name, list(attrib))

        elif kind == END:
            name = data.localname
            namespace = data.namespace
            if name not in voidElements:
                yield self.endTag(namespace, name)

        elif kind == COMMENT:
            yield self.comment(data)

        elif kind == TEXT:
            for token in self.text(data):
                yield token

        elif kind == DOCTYPE:
            yield self.doctype(*data)

        elif kind in (XML_NAMESPACE, DOCTYPE, START_NS, END_NS, \
          START_CDATA, END_CDATA, PI):
            pass

        else:
            yield self.unknown(kind)

########NEW FILE########
__FILENAME__ = lxmletree
from lxml import etree
from html5lib.treebuilders.etree import tag_regexp

from gettext import gettext
_ = gettext

import _base

from html5lib.constants import voidElements
from html5lib import ihatexml

class Root(object):
    def __init__(self, et):
        self.elementtree = et
        self.children = []
        if et.docinfo.internalDTD:
            self.children.append(Doctype(self, et.docinfo.root_name, 
                                         et.docinfo.public_id, 
                                         et.docinfo.system_url))
        root = et.getroot()
        node = root

        while node.getprevious() is not None:
            node = node.getprevious()
        while node is not None:
            self.children.append(node)
            node = node.getnext()

        self.text = None
        self.tail = None
    
    def __getitem__(self, key):
        return self.children[key]

    def getnext(self):
        return None

    def __len__(self):
        return 1

class Doctype(object):
    def __init__(self, root_node, name, public_id, system_id):
        self.root_node = root_node
        self.name = name
        self.public_id = public_id
        self.system_id = system_id
        
        self.text = None
        self.tail = None

    def getnext(self):
        return self.root_node.children[1]

class FragmentRoot(Root):
    def __init__(self, children):
        self.children = [FragmentWrapper(self, child) for child in children]
        self.text = self.tail = None

    def getnext(self):
        return None

class FragmentWrapper(object):
    def __init__(self, fragment_root, obj):
        self.root_node = fragment_root
        self.obj = obj
        if hasattr(self.obj, 'text'):
            self.text = self.obj.text
        else:
            self.text = None
        if hasattr(self.obj, 'tail'):
            self.tail = self.obj.tail
        else:
            self.tail = None
        self.isstring = isinstance(obj, basestring)
        
    def __getattr__(self, name):
        return getattr(self.obj, name)
    
    def getnext(self):
        siblings = self.root_node.children
        idx = siblings.index(self)
        if idx < len(siblings) - 1:
            return siblings[idx + 1]
        else:
            return None

    def __getitem__(self, key):
        return self.obj[key]

    def __nonzero__(self):
        return bool(self.obj)

    def getparent(self):
        return None

    def __str__(self):
        return str(self.obj)

    def __unicode__(self):
        return unicode(self.obj)

    def __len__(self):
        return len(self.obj)

        
class TreeWalker(_base.NonRecursiveTreeWalker):
    def __init__(self, tree):
        if hasattr(tree, "getroot"):
            tree = Root(tree)
        elif isinstance(tree, list):
            tree = FragmentRoot(tree)
        _base.NonRecursiveTreeWalker.__init__(self, tree)
        self.filter = ihatexml.InfosetFilter()
    def getNodeDetails(self, node):
        if isinstance(node, tuple): # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            return _base.TEXT, getattr(node, key)

        elif isinstance(node, Root):
            return (_base.DOCUMENT,)

        elif isinstance(node, Doctype):
            return _base.DOCTYPE, node.name, node.public_id, node.system_id

        elif isinstance(node, FragmentWrapper) and node.isstring:
            return _base.TEXT, node

        elif node.tag == etree.Comment:
            return _base.COMMENT, node.text

        elif node.tag == etree.Entity:
            return _base.ENTITY, node.text[1:-1] # strip &;

        else:
            #This is assumed to be an ordinary element
            match = tag_regexp.match(node.tag)
            if match:
                namespace, tag = match.groups()
            else:
                namespace = None
                tag = node.tag
            attrs = {}
            for name, value in node.attrib.items():
                match = tag_regexp.match(name)
                if match:
                    attrs[(match.group(1),match.group(2))] = value
                else:
                    attrs[(None,name)] = value
            return (_base.ELEMENT, namespace, self.filter.fromXmlName(tag), 
                    attrs, len(node) > 0 or node.text)

    def getFirstChild(self, node):
        assert not isinstance(node, tuple), _("Text nodes have no children")

        assert len(node) or node.text, "Node has no children"
        if node.text:
            return (node, "text")
        else:
            return node[0]

    def getNextSibling(self, node):
        if isinstance(node, tuple): # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            if key == "text":
                # XXX: we cannot use a "bool(node) and node[0] or None" construct here
                # because node[0] might evaluate to False if it has no child element
                if len(node):
                    return node[0]
                else:
                    return None
            else: # tail
                return node.getnext()

        return node.tail and (node, "tail") or node.getnext()

    def getParentNode(self, node):
        if isinstance(node, tuple): # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            if key == "text":
                return node
            # else: fallback to "normal" processing

        return node.getparent()

########NEW FILE########
__FILENAME__ = pulldom
from xml.dom.pulldom import START_ELEMENT, END_ELEMENT, \
    COMMENT, IGNORABLE_WHITESPACE, CHARACTERS

import _base

from html5lib.constants import voidElements

class TreeWalker(_base.TreeWalker):
    def __iter__(self):
        ignore_until = None
        previous = None
        for event in self.tree:
            if previous is not None and \
              (ignore_until is None or previous[1] is ignore_until):
                if previous[1] is ignore_until:
                    ignore_until = None
                for token in self.tokens(previous, event):
                    yield token
                    if token["type"] == "EmptyTag":
                        ignore_until = previous[1]
            previous = event
        if ignore_until is None or previous[1] is ignore_until:
            for token in self.tokens(previous, None):
                yield token
        elif ignore_until is not None:
            raise ValueError("Illformed DOM event stream: void element without END_ELEMENT")

    def tokens(self, event, next):
        type, node = event
        if type == START_ELEMENT:
            name = node.nodeName
            namespace = node.namespaceURI
            attrs = {}
            for attr in node.attributes.keys():
                attr = node.getAttributeNode(attr)
                attrs[(attr.namespaceURI,attr.localName)] = attr.value
            if name in voidElements:
                for token in self.emptyTag(namespace,
                                           name,
                                           attrs,
                                           not next or next[1] is not node):
                    yield token
            else:
                yield self.startTag(namespace, name, attrs)

        elif type == END_ELEMENT:
            name = node.nodeName
            namespace = node.namespaceURI
            if name not in voidElements:
                yield self.endTag(namespace, name)

        elif type == COMMENT:
            yield self.comment(node.nodeValue)

        elif type in (IGNORABLE_WHITESPACE, CHARACTERS):
            for token in self.text(node.nodeValue):
                yield token

        else:
            yield self.unknown(type)

########NEW FILE########
__FILENAME__ = simpletree
import gettext
_ = gettext.gettext

import _base

class TreeWalker(_base.NonRecursiveTreeWalker):
    """Given that simpletree has no performant way of getting a node's
    next sibling, this implementation returns "nodes" as tuples with the
    following content:

    1. The parent Node (Element, Document or DocumentFragment)

    2. The child index of the current node in its parent's children list

    3. A list used as a stack of all ancestors. It is a pair tuple whose
       first item is a parent Node and second item is a child index.
    """

    def getNodeDetails(self, node):
        if isinstance(node, tuple): # It might be the root Node
            parent, idx, parents = node
            node = parent.childNodes[idx]

        # testing node.type allows us not to import treebuilders.simpletree
        if node.type in (1, 2): # Document or DocumentFragment
            return (_base.DOCUMENT,)

        elif node.type == 3: # DocumentType
            return _base.DOCTYPE, node.name, node.publicId, node.systemId

        elif node.type == 4: # TextNode
            return _base.TEXT, node.value

        elif node.type == 5: # Element
            attrs = {}
            for name, value in node.attributes.items():
                if isinstance(name, tuple):
                    attrs[(name[2],name[1])] = value
                else:
                    attrs[(None,name)] = value
            return (_base.ELEMENT, node.namespace, node.name, 
                    attrs, node.hasContent())

        elif node.type == 6: # CommentNode
            return _base.COMMENT, node.data

        else:
            return _node.UNKNOWN, node.type

    def getFirstChild(self, node):
        if isinstance(node, tuple): # It might be the root Node
            parent, idx, parents = node
            parents.append((parent, idx))
            node = parent.childNodes[idx]
        else:
            parents = []

        assert node.hasContent(), "Node has no children"
        return (node, 0, parents)

    def getNextSibling(self, node):
        assert isinstance(node, tuple), "Node is not a tuple: " + str(node)
        parent, idx, parents = node
        idx += 1
        if len(parent.childNodes) > idx:
            return (parent, idx, parents)
        else:
            return None

    def getParentNode(self, node):
        assert isinstance(node, tuple)
        parent, idx, parents = node
        if parents:
            parent, idx = parents.pop()
            return parent, idx, parents
        else:
            # HACK: We could return ``parent`` but None will stop the algorithm the same way
            return None

########NEW FILE########
__FILENAME__ = soup
import re
import gettext
_ = gettext.gettext

from BeautifulSoup import BeautifulSoup, Declaration, Comment, Tag
from html5lib.constants import namespaces
import _base

class TreeWalker(_base.NonRecursiveTreeWalker):
    doctype_regexp = re.compile(
        r'DOCTYPE\s+(?P<name>[^\s]*)(\s*PUBLIC\s*"(?P<publicId>.*)"\s*"(?P<systemId1>.*)"|\s*SYSTEM\s*"(?P<systemId2>.*)")?')
    def getNodeDetails(self, node):
        if isinstance(node, BeautifulSoup): # Document or DocumentFragment
            return (_base.DOCUMENT,)

        elif isinstance(node, Declaration): # DocumentType
            string = unicode(node.string)
            #Slice needed to remove markup added during unicode conversion,
            #but only in some versions of BeautifulSoup/Python
            if string.startswith('<!') and string.endswith('>'):
                string = string[2:-1]
            m = self.doctype_regexp.match(string)
            #This regexp approach seems wrong and fragile
            #but beautiful soup stores the doctype as a single thing and we want the seperate bits
            #It should work as long as the tree is created by html5lib itself but may be wrong if it's
            #been modified at all
            #We could just feed to it a html5lib tokenizer, I guess...
            assert m is not None, "DOCTYPE did not match expected format"

            name = m.group('name')
            publicId = m.group('publicId')
            if publicId is not None:
                systemId = m.group('systemId1')
            else:
                systemId = m.group('systemId2')
            return _base.DOCTYPE, name, publicId or "", systemId or ""

        elif isinstance(node, Comment):
            string = unicode(node.string)
            if string.startswith('<!--') and string.endswith('-->'):
                string = string[4:-3]
            return _base.COMMENT, string

        elif isinstance(node, unicode): # TextNode
            return _base.TEXT, node

        elif isinstance(node, Tag): # Element
            return (_base.ELEMENT, namespaces["html"], node.name,
                    dict(node.attrs).items(), node.contents)
        else:
            return _base.UNKNOWN, node.__class__.__name__

    def getFirstChild(self, node):
        return node.contents[0]

    def getNextSibling(self, node):
        return node.nextSibling

    def getParentNode(self, node):
        return node.parent

########NEW FILE########
__FILENAME__ = _base
import gettext
_ = gettext.gettext

from html5lib.constants import voidElements, spaceCharacters
spaceCharacters = u"".join(spaceCharacters)

class TreeWalker(object):
    def __init__(self, tree):
        self.tree = tree

    def __iter__(self):
        raise NotImplementedError

    def error(self, msg):
        return {"type": "SerializeError", "data": msg}

    def normalizeAttrs(self, attrs):
        newattrs = {}
        if attrs:
            #TODO: treewalkers should always have attrs
            for (namespace,name),value in attrs.iteritems():
                namespace = unicode(namespace) if namespace else None
                name = unicode(name)
                value = unicode(value)
                newattrs[(namespace,name)] = value
        return newattrs

    def emptyTag(self, namespace, name, attrs, hasChildren=False):
        yield {"type": "EmptyTag", "name": unicode(name), 
               "namespace":unicode(namespace),
               "data": self.normalizeAttrs(attrs)}
        if hasChildren:
            yield self.error(_("Void element has children"))

    def startTag(self, namespace, name, attrs):
        return {"type": "StartTag", 
                "name": unicode(name),
                "namespace":unicode(namespace),
                "data": self.normalizeAttrs(attrs)}

    def endTag(self, namespace, name):
        return {"type": "EndTag", 
                "name": unicode(name),
                "namespace":unicode(namespace),
                "data": {}}

    def text(self, data):
        data = unicode(data)
        middle = data.lstrip(spaceCharacters)
        left = data[:len(data)-len(middle)]
        if left:
            yield {"type": "SpaceCharacters", "data": left}
        data = middle
        middle = data.rstrip(spaceCharacters)
        right = data[len(middle):]
        if middle:
            yield {"type": "Characters", "data": middle}
        if right:
            yield {"type": "SpaceCharacters", "data": right}

    def comment(self, data):
        return {"type": "Comment", "data": unicode(data)}

    def doctype(self, name, publicId=None, systemId=None, correct=True):
        return {"type": "Doctype",
                "name": name is not None and unicode(name) or u"",
                "publicId": publicId,
                "systemId": systemId,
                "correct": correct}

    def entity(self, name):
        return {"type": "Entity", "name": unicode(name)}

    def unknown(self, nodeType):
        return self.error(_("Unknown node type: ") + nodeType)

class RecursiveTreeWalker(TreeWalker):
    def walkChildren(self, node):
        raise NodeImplementedError

    def element(self, node, namespace, name, attrs, hasChildren):
        if name in voidElements:
            for token in self.emptyTag(namespace, name, attrs, hasChildren):
                yield token
        else:
            yield self.startTag(name, attrs)
            if hasChildren:
                for token in self.walkChildren(node):
                    yield token
            yield self.endTag(name)

from xml.dom import Node

DOCUMENT = Node.DOCUMENT_NODE
DOCTYPE = Node.DOCUMENT_TYPE_NODE
TEXT = Node.TEXT_NODE
ELEMENT = Node.ELEMENT_NODE
COMMENT = Node.COMMENT_NODE
ENTITY = Node.ENTITY_NODE
UNKNOWN = "<#UNKNOWN#>"

class NonRecursiveTreeWalker(TreeWalker):
    def getNodeDetails(self, node):
        raise NotImplementedError
    
    def getFirstChild(self, node):
        raise NotImplementedError
    
    def getNextSibling(self, node):
        raise NotImplementedError
    
    def getParentNode(self, node):
        raise NotImplementedError

    def __iter__(self):
        currentNode = self.tree
        while currentNode is not None:
            details = self.getNodeDetails(currentNode)
            type, details = details[0], details[1:]
            hasChildren = False
            endTag = None

            if type == DOCTYPE:
                yield self.doctype(*details)

            elif type == TEXT:
                for token in self.text(*details):
                    yield token

            elif type == ELEMENT:
                namespace, name, attributes, hasChildren = details
                if name in voidElements:
                    for token in self.emptyTag(namespace, name, attributes, 
                                               hasChildren):
                        yield token
                    hasChildren = False
                else:
                    endTag = name
                    yield self.startTag(namespace, name, attributes)

            elif type == COMMENT:
                yield self.comment(details[0])

            elif type == ENTITY:
                yield self.entity(details[0])

            elif type == DOCUMENT:
                hasChildren = True

            else:
                yield self.unknown(details[0])
            
            if hasChildren:
                firstChild = self.getFirstChild(currentNode)
            else:
                firstChild = None
            
            if firstChild is not None:
                currentNode = firstChild
            else:
                while currentNode is not None:
                    details = self.getNodeDetails(currentNode)
                    type, details = details[0], details[1:]
                    if type == ELEMENT:
                        namespace, name, attributes, hasChildren = details
                        if name not in voidElements:
                            yield self.endTag(namespace, name)
                    if self.tree is currentNode:
                        currentNode = None
                        break
                    nextSibling = self.getNextSibling(currentNode)
                    if nextSibling is not None:
                        currentNode = nextSibling
                        break
                    else:
                        currentNode = self.getParentNode(currentNode)

########NEW FILE########
__FILENAME__ = utils
try:
    frozenset
except NameError:
    #Import from the sets module for python 2.3
    from sets import Set as set
    from sets import ImmutableSet as frozenset

class MethodDispatcher(dict):
    """Dict with 2 special properties:

    On initiation, keys that are lists, sets or tuples are converted to
    multiple keys so accessing any one of the items in the original
    list-like object returns the matching value

    md = MethodDispatcher({("foo", "bar"):"baz"})
    md["foo"] == "baz"

    A default value which can be set through the default attribute.
    """

    def __init__(self, items=()):
        # Using _dictEntries instead of directly assigning to self is about
        # twice as fast. Please do careful performance testing before changing
        # anything here.
        _dictEntries = []
        for name,value in items:
            if type(name) in (list, tuple, frozenset, set):
                for item in name:
                    _dictEntries.append((item, value))
            else:
                _dictEntries.append((name, value))
        dict.__init__(self, _dictEntries)
        self.default = None

    def __getitem__(self, key):
        return dict.get(self, key, self.default)

#Pure python implementation of deque taken from the ASPN Python Cookbook
#Original code by Raymond Hettinger

class deque(object):

    def __init__(self, iterable=(), maxsize=-1):
        if not hasattr(self, 'data'):
            self.left = self.right = 0
            self.data = {}
        self.maxsize = maxsize
        self.extend(iterable)

    def append(self, x):
        self.data[self.right] = x
        self.right += 1
        if self.maxsize != -1 and len(self) > self.maxsize:
            self.popleft()
        
    def appendleft(self, x):
        self.left -= 1        
        self.data[self.left] = x
        if self.maxsize != -1 and len(self) > self.maxsize:
            self.pop()      
        
    def pop(self):
        if self.left == self.right:
            raise IndexError('cannot pop from empty deque')
        self.right -= 1
        elem = self.data[self.right]
        del self.data[self.right]         
        return elem
    
    def popleft(self):
        if self.left == self.right:
            raise IndexError('cannot pop from empty deque')
        elem = self.data[self.left]
        del self.data[self.left]
        self.left += 1
        return elem

    def clear(self):
        self.data.clear()
        self.left = self.right = 0

    def extend(self, iterable):
        for elem in iterable:
            self.append(elem)

    def extendleft(self, iterable):
        for elem in iterable:
            self.appendleft(elem)

    def rotate(self, n=1):
        if self:
            n %= len(self)
            for i in xrange(n):
                self.appendleft(self.pop())

    def __getitem__(self, i):
        if i < 0:
            i += len(self)
        try:
            return self.data[i + self.left]
        except KeyError:
            raise IndexError

    def __setitem__(self, i, value):
        if i < 0:
            i += len(self)        
        try:
            self.data[i + self.left] = value
        except KeyError:
            raise IndexError

    def __delitem__(self, i):
        size = len(self)
        if not (-size <= i < size):
            raise IndexError
        data = self.data
        if i < 0:
            i += size
        for j in xrange(self.left+i, self.right-1):
            data[j] = data[j+1]
        self.pop()
    
    def __len__(self):
        return self.right - self.left

    def __cmp__(self, other):
        if type(self) != type(other):
            return cmp(type(self), type(other))
        return cmp(list(self), list(other))
            
    def __repr__(self, _track=[]):
        if id(self) in _track:
            return '...'
        _track.append(id(self))
        r = 'deque(%r)' % (list(self),)
        _track.remove(id(self))
        return r
    
    def __getstate__(self):
        return (tuple(self),)
    
    def __setstate__(self, s):
        self.__init__(s[0])
        
    def __hash__(self):
        raise TypeError
    
    def __copy__(self):
        return self.__class__(self)
    
    def __deepcopy__(self, memo={}):
        from copy import deepcopy
        result = self.__class__()
        memo[id(self)] = result
        result.__init__(deepcopy(tuple(self), memo))
        return result

#Some utility functions to dal with weirdness around UCS2 vs UCS4
#python builds

def encodingType():
    if len() == 2:
        return "UCS2"
    else:
        return "UCS4"

def isSurrogatePair(data):   
    return (len(data) == 2 and
            ord(data[0]) >= 0xD800 and ord(data[0]) <= 0xDBFF and
            ord(data[1]) >= 0xDC00 and ord(data[1]) <= 0xDFFF)

def surrogatePairToCodepoint(data):
    char_val = (0x10000 + (ord(data[0]) - 0xD800) * 0x400 + 
                (ord(data[1]) - 0xDC00))
    return char_val

########NEW FILE########
__FILENAME__ = images
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random
import urllib
import urllib2

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from django.utils import simplejson as json

template.register_template_library('v2ex.templatetags.filters')

class ImagesHomeHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        self.session = Session()
        if member:
            source = 'http://daydream/stream/' + str(member.num)
            result = urlfetch.fetch(source)
            images = json.loads(result.content)
            template_values = {}
            template_values['images'] = images
            template_values['site'] = site
            template_values['member'] = member
            template_values['page_title'] = site.title + u' › 图片上传'
            template_values['l10n'] = l10n
            template_values['system_version'] = SYSTEM_VERSION
            if 'message' in self.session:
                template_values['message'] = self.session['message']
                del self.session['message']
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'images_home.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')

class ImagesUploadHandler(webapp.RequestHandler):
    def post(self):
        site = GetSite()
        browser = detect(self.request)
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        if member:    
            image = self.request.get('image')
            if image is not None:
                import urllib, urllib2
                parameters = urllib.urlencode(dict(member_id=member.num, image=image))
                try:
                    f = urllib2.urlopen('http://daydream/upload', parameters)
                    data = f.read()
                    f.close()
                except:
                    self.session = Session()
                    self.session['message'] = '图片不能超过 1M'
                self.redirect('/images')
        else:
            self.redirect('/signin')

class ImagesUploadRulesHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)   
        template_values = {}
        template_values['site'] = site
        template_values['member'] = member
        template_values['page_title'] = site.title + u' › 图片上传规则'
        template_values['l10n'] = l10n
        template_values['system_version'] = SYSTEM_VERSION
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'images_rules.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        

def main():
    application = webapp.WSGIApplication([
    ('/images/upload', ImagesUploadHandler),
    ('/images/upload/rules', ImagesUploadRulesHandler),
    ('/images/?', ImagesHomeHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = mail
#!/usr/bin/env python
# coding=utf-8

import logging
import re

from v2ex.babel import Member

from google.appengine.ext import db
from google.appengine.ext import webapp
from google.appengine.ext.webapp.mail_handlers import InboundMailHandler
from google.appengine.ext.webapp.util import run_wsgi_app

from twitter.oauthtwitter import OAuthApi
from twitter.oauth import OAuthToken

from config import twitter_consumer_key as CONSUMER_KEY
from config import twitter_consumer_secret as CONSUMER_SECRET

def extract_address(raw):
    if raw.find('<') == -1:
        return raw
    else:
        return re.findall('<(.+)>', raw)[0]

class MailHandler(InboundMailHandler):
    def receive(self, message):
        bodies = message.bodies(content_type = 'text/plain')
        for body in bodies:
            to = extract_address(message.to)
            sender = extract_address(message.sender.lower())
            if to[0:5].lower() == 'tweet':
                q = db.GqlQuery("SELECT * FROM Member WHERE email = :1", sender)
                if q.count() == 1:
                    member = q[0]
                    if member.twitter_oauth == 1:
                        access_token = OAuthToken.from_string(member.twitter_oauth_string)
                        twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                        status = body[1].decode()
                        if len(status) > 140:
                            status = status[0:140]
                        try:
                            logging.info("About to send tweet: " + status)
                            twitter.PostUpdate(status.encode('utf-8'))
                            logging.info("Successfully tweet: " + status)
                        except:
                            logging.error("Failed to tweet for " + member.username)
                else:
                    logging.error("User " + sender + " doesn't have Twitter link.")

application = webapp.WSGIApplication([
    MailHandler.mapping()
], debug=True)

def main():
    run_wsgi_app(application)

if __name__ == "__main__":
    main()
########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python
# coding=utf-8

import base64
import os
import re
import time
import datetime
import hashlib
import urllib
import string
import random
import pickle
import math

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.api.labs import taskqueue
from google.appengine.api import mail
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import PasswordResetToken

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from v2ex.babel.handlers import BaseHandler

from django.utils import simplejson as json

from v2ex.babel.ext import captcha

template.register_template_library('v2ex.templatetags.filters')

import config

class HomeHandler(webapp.RequestHandler):
    def head(self):
        pass
        
    def get(self):
        host = self.request.headers['Host']
        if host == 'beta.v2ex.com':
            return self.redirect('http://www.v2ex.com/')
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = GetSite()
        template_values['canonical'] = 'http://' + site.domain + '/'
        template_values['rnd'] = random.randrange(1, 100)
        template_values['page_title'] = site.title
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        if member:
            if member.my_home != None and len(member.my_home) > 0:
                return self.redirect(member.my_home)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            self.response.headers['Set-Cookie'] = 'auth=' + member.auth + '; expires=' + (datetime.datetime.now() + datetime.timedelta(days=365)).strftime("%a, %d-%b-%Y %H:%M:%S GMT") + '; path=/'
            template_values['member'] = member
            try:
                blocked = pickle.loads(member.blocked.encode('utf-8'))
            except:
                blocked = []
            if (len(blocked) > 0):
                template_values['blocked'] = ','.join(map(str, blocked))
        if member:
            recent_nodes = memcache.get('member::' + str(member.num) + '::recent_nodes')
            if recent_nodes:
                template_values['recent_nodes'] = recent_nodes
        nodes_new = []
        nodes_new = memcache.get('home_nodes_new')
        if nodes_new is None:
            nodes_new = []
            qnew = db.GqlQuery("SELECT * FROM Node ORDER BY created DESC LIMIT 10")
            if (qnew.count() > 0):
                i = 0
                for node in qnew:
                    nodes_new.append(node)
                    i = i + 1
            memcache.set('home_nodes_new', nodes_new, 86400)
        template_values['nodes_new'] = nodes_new
        ignored = ['newbie', 'in', 'flamewar', 'pointless', 'tuan', '528491', 'chamber', 'autistic', 'blog', 'love', 'flood', 'beforesunrise', 'diary', 'fanfou', 'closed']
        if browser['ios']:
            home_rendered = memcache.get('home_rendered_mobile')
            if home_rendered is None:
                latest = memcache.get('q_latest_16')
                if (latest):
                    template_values['latest'] = latest
                else:
                    q2 = db.GqlQuery("SELECT * FROM Topic ORDER BY last_touched DESC LIMIT 16")
                    topics = []
                    for topic in q2:
                        if topic.node_name not in ignored:
                            topics.append(topic)
                    memcache.set('q_latest_16', topics, 600)
                    latest = topics
                    template_values['latest'] = latest
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'home_mobile.html')
                home_rendered = template.render(path, template_values)
                memcache.set('home_rendered_mobile', home_rendered, 600)
            template_values['home'] = home_rendered
        else:
            home_rendered = memcache.get('home_rendered')
            if home_rendered is None:
                latest = memcache.get('q_latest_16')
                if (latest):
                    template_values['latest'] = latest
                else:
                    q2 = db.GqlQuery("SELECT * FROM Topic ORDER BY last_touched DESC LIMIT 16")
                    topics = []
                    for topic in q2:
                        if topic.node_name not in ignored:
                            topics.append(topic)
                    memcache.set('q_latest_16', topics, 600)
                    latest = topics
                    template_values['latest'] = latest
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'home.html')
                home_rendered = template.render(path, template_values)
                memcache.set('home_rendered', home_rendered, 600)
            template_values['home'] = home_rendered
        member_total = memcache.get('member_total')
        if member_total is None:
            q3 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'member.total'")
            if (q3.count() > 0):
                member_total = q3[0].value
            else:
                member_total = 0
            memcache.set('member_total', member_total, 3600)
        template_values['member_total'] = member_total
        topic_total = memcache.get('topic_total')
        if topic_total is None:
            q4 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'topic.total'")
            if (q4.count() > 0):
                topic_total = q4[0].value
            else:
                topic_total = 0
            memcache.set('topic_total', topic_total, 3600)
        template_values['topic_total'] = topic_total
        reply_total = memcache.get('reply_total')
        if reply_total is None:
            q5 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'reply.total'")
            if (q5.count() > 0):
                reply_total = q5[0].value
            else:
                reply_total = 0
            memcache.set('reply_total', reply_total, 3600)
        template_values['reply_total'] = reply_total
        hottest = memcache.get('index_hottest_sidebar')
        if hottest is None:
            qhot = db.GqlQuery("SELECT * FROM Node ORDER BY topics DESC LIMIT 25")
            hottest = u''
            for node in qhot:
                hottest = hottest + '<a href="/go/' + node.name + '" class="item_node">' + node.title + '</a>'
            memcache.set('index_hottest_sidebar', hottest, 86400)
        template_values['index_hottest_sidebar'] = hottest
        c = memcache.get('index_categories')
        if c is None:
            c = ''
            i = 0
            if site.home_categories is not None:
                categories = site.home_categories.split("\n")
            else:
                categories = []
            for category in categories:
                category = category.strip()
                i = i + 1
                c = c + '<div class="cell"><table cellpadding="0" cellspacing="0" border="0"><tr><td align="right" width="60"><span class="fade">' + category + '</span></td><td style="line-height: 200%; padding-left: 10px;">'
                qx = db.GqlQuery("SELECT * FROM Node WHERE category = :1 ORDER BY topics DESC", category)
                for node in qx:
                    c = c + '<a href="/go/' + node.name + '" style="font-size: 14px;">' + node.title + '</a>&nbsp; &nbsp; '
                c = c + '</td></tr></table></div>'
                memcache.set('index_categories', c, 86400)
        template_values['c'] = c
        if (browser['ios']):
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'index.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'index.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class PlanesHandler(BaseHandler):
    def get(self):
        c = 0
        c = memcache.get('planes_c')
        s = ''
        s = memcache.get('planes')
        if (s == None):
            c = 0
            s = ''
            q = db.GqlQuery("SELECT * FROM Section ORDER BY nodes DESC")
            if (q.count() > 0):
                for section in q:
                    q2 = db.GqlQuery("SELECT * FROM Node WHERE section_num = :1 ORDER BY topics DESC", section.num)
                    n = ''
                    if (q2.count() > 0):
                        nodes = []
                        i = 0
                        for node in q2:
                            nodes.append(node)
                            i = i + 1
                        random.shuffle(nodes)
                        for node in nodes:
                            fs = random.randrange(12, 16)
                            n = n + '<a href="/go/' + node.name + '" class="item_node">' + node.title + '</a>'
                            c = c + 1
                    s = s + '<div class="sep20"></div><div class="box"><div class="cell"><div class="fr"><strong class="snow">' + section.title_alternative + u'</strong><small class="snow"> • ' + str(section.nodes) + ' nodes</small></div>' + section.title + '</div><div class="inner" align="center">' + n + '</div></div>'
            memcache.set('planes', s, 86400)
            memcache.set('planes_c', c, 86400)
        self.values['c'] = c
        self.values['s'] = s
        self.values['page_title'] = self.site.title.decode('utf-8') + u' › ' + self.l10n.planes.decode('utf-8')
        self.finalize(template_name='planes')
        
class RecentHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 最近的 50 个主题'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
            try:
                blocked = pickle.loads(member.blocked.encode('utf-8'))
            except:
                blocked = []
            if (len(blocked) > 0):
                template_values['blocked'] = ','.join(map(str, blocked))
        latest = memcache.get('q_recent_50')
        if (latest):
            template_values['latest'] = latest
        else:
            q2 = db.GqlQuery("SELECT * FROM Topic ORDER BY last_touched DESC LIMIT 16,50")
            topics = []
            IGNORED_RECENT = ['flamewar', 'pointless', 'in', 'autistic', 'chamber', 'flood', 'diary', 'fanfou']
            for topic in q2:
                if topic.node_name not in IGNORED_RECENT:
                    topics.append(topic)
            memcache.set('q_recent_50', topics, 80)
            template_values['latest'] = topics
            template_values['latest_total'] = len(topics)
        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'recent.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'recent.html')
        output = template.render(path, template_values)
        expires_date = datetime.datetime.utcnow() + datetime.timedelta(minutes=2)
        expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
        self.response.headers.add_header("Expires", expires_str)
        self.response.headers['Cache-Control'] = 'max-age=120, must-revalidate'
        self.response.out.write(output)

class UAHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['ua'] = os.environ['HTTP_USER_AGENT']
        template_values['page_title'] = site.title + u' › 用户代理字符串'
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'ua.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

        
class SigninHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        member = False
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 登入'
        template_values['system_version'] = SYSTEM_VERSION
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        errors = 0
        template_values['errors'] = errors
        
        template_values['next'] = self.request.referer

        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'signin.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'signin.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
 
    def post(self):
        site = GetSite()
        member = False
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 登入'
        template_values['system_version'] = SYSTEM_VERSION
        u = self.request.get('u').strip()
        p = self.request.get('p').strip()
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        errors = 0
        error_messages = ['', '请输入用户名和密码', '你输入的用户名或密码不正确']
        if (len(u) > 0 and len(p) > 0):
            p_sha1 = hashlib.sha1(p).hexdigest()
            if '@' in u:
                q = db.GqlQuery("SELECT * FROM Member WHERE email = :1 AND password = :2", u.lower(), p_sha1)
            else:
                q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1 AND password = :2", u.lower(), p_sha1)
            if (q.count() == 1):
                member = q[0]
                self.response.headers['Set-Cookie'] = 'auth=' + member.auth + '; expires=' + (datetime.datetime.now() + datetime.timedelta(days=365)).strftime("%a, %d-%b-%Y %H:%M:%S GMT") + '; path=/'
                next = self.request.get('next').strip()
                host = self.request.host + '/'
                if next.rfind(host)>0 and not next.rfind('/sign'):
                    self.redirect(next)
                else:
                    self.redirect('/')
            else:
                errors = 2
        else:
            errors = 1
        template_values['u'] = u
        template_values['p'] = p
        template_values['errors'] = errors
        template_values['error_message'] = error_messages[errors]
        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'signin.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'signin.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
class SignupHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        member = False
        chtml = captcha.displayhtml(
            public_key = config.recaptcha_public_key,
            use_ssl = False,
            error = None)
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 注册'
        template_values['system_version'] = SYSTEM_VERSION
        template_values['errors'] = 0
        template_values['captchahtml'] = chtml
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'signup.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'signup.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
    def post(self):
        site = GetSite()
        member = False
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 注册'
        template_values['system_version'] = SYSTEM_VERSION
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        errors = 0
        # Verification: username
        member_username_error = 0
        member_username_error_messages = ['',
            l10n.username_empty,
            l10n.username_too_long,
            l10n.username_too_short,
            l10n.username_invalid,
            l10n.username_taken]
        member_username = self.request.get('username').strip()
        # Special cases
        if 'vpn' in member_username:
            return self.redirect('http://www.v2ex.com/')
        if (len(member_username) == 0):
            errors = errors + 1
            member_username_error = 1
        else:
            if (len(member_username) > 16):
                errors = errors + 1
                member_username_error = 2
            else:
                if (len(member_username) < 3):
                    errors = errors + 1
                    member_username_error = 3
                else:
                    if (re.search('^[a-zA-Z0-9\_]+$', member_username)):
                        q = db.GqlQuery('SELECT __key__ FROM Member WHERE username_lower = :1', member_username.lower())
                        if (q.count() > 0):
                            errors = errors + 1
                            member_username_error = 5
                    else:
                        errors = errors + 1
                        member_username_error = 4
        template_values['member_username'] = member_username
        template_values['member_username_error'] = member_username_error
        template_values['member_username_error_message'] = member_username_error_messages[member_username_error]
        # Verification: password
        member_password_error = 0
        member_password_error_messages = ['',
            u'请输入你的密码',
            u'密码长度不能超过 32 个字符'
        ]
        member_password = self.request.get('password').strip()
        if (len(member_password) == 0):
            errors = errors + 1
            member_password_error = 1
        else:
            if (len(member_password) > 32):
                errors = errors + 1
                member_password_error = 2
        template_values['member_password'] = member_password
        template_values['member_password_error'] = member_password_error
        template_values['member_password_error_message'] = member_password_error_messages[member_password_error]
        # Verification: email
        member_email_error = 0
        member_email_error_messages = ['',
            u'请输入你的电子邮件地址',
            u'电子邮件地址长度不能超过 32 个字符',
            u'你输入的电子邮件地址不符合规则',
            u'抱歉这个电子邮件地址已经有人注册过了']
        member_email = self.request.get('email').strip()
        if (len(member_email) == 0):
            errors = errors + 1
            member_email_error = 1
        else:
            if (len(member_email) > 32):
                errors = errors + 1
                member_email_error = 2
            else:
                p = re.compile(r"(?:^|\s)[-a-z0-9_.+]+@(?:[-a-z0-9]+\.)+[a-z]{2,6}(?:\s|$)", re.IGNORECASE)
                if (p.search(member_email)):
                    q = db.GqlQuery('SELECT __key__ FROM Member WHERE email = :1', member_email.lower())
                    if (q.count() > 0):
                        errors = errors + 1
                        member_email_error = 4
                else:
                    errors = errors + 1
                    member_email_error = 3
        template_values['member_email'] = member_email
        template_values['member_email_error'] = member_email_error
        template_values['member_email_error_message'] = member_email_error_messages[member_email_error]
        # Verification: reCAPTCHA
        challenge = self.request.get('recaptcha_challenge_field')
        response  = self.request.get('recaptcha_response_field')
        remoteip  = os.environ['REMOTE_ADDR']
        
        cResponse = captcha.submit(
                         challenge,
                         response,
                         config.recaptcha_private_key,
                         remoteip)

        if cResponse.is_valid:
            logging.info('reCAPTCHA verification passed')
            template_values['recaptcha_error'] = 0
        else:
            errors = errors + 1
            error = cResponse.error_code
            chtml = captcha.displayhtml(
                public_key = config.recaptcha_public_key,
                use_ssl = False,
                error = cResponse.error_code)
            template_values['captchahtml'] = chtml
            template_values['recaptcha_error'] = 1
            template_values['recaptcha_error_message'] = '请重新输入 reCAPTCHA 验证码'
        template_values['errors'] = errors
        if (errors == 0):
            member = Member()
            q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'member.max')
            if (q.count() == 1):
                counter = q[0]
                counter.value = counter.value + 1
            else:
                counter = Counter()
                counter.name = 'member.max'
                counter.value = 1
            q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'member.total')
            if (q2.count() == 1):
                counter2 = q2[0]
                counter2.value = counter2.value + 1
            else:
                counter2 = Counter()
                counter2.name = 'member.total'
                counter2.value = 1
            member.num = counter.value
            member.username = member_username
            member.username_lower = member_username.lower()
            member.password = hashlib.sha1(member_password).hexdigest()
            member.email = member_email.lower()
            member.auth = hashlib.sha1(str(member.num) + ':' + member.password).hexdigest()
            member.l10n = site.l10n
            member.newbie = 1
            member.noob = 0
            if member.num == 1:
                member.level = 0
            else:
                member.level = 1000
            member.put()
            counter.put()
            counter2.put()
            self.response.headers['Set-Cookie'] = 'auth=' + member.auth + '; expires=' + (datetime.datetime.now() + datetime.timedelta(days=365)).strftime("%a, %d-%b-%Y %H:%M:%S GMT") + '; path=/'
            memcache.delete('member_total')
            self.redirect('/')
        else:
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'signup.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'signup.html')
            output = template.render(path, template_values)
            self.response.out.write(output)

class SignoutHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        member = False
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 登出'
        template_values['system_version'] = SYSTEM_VERSION
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        cookies = Cookies(self, max_age = 86400, path = '/')
        del cookies['auth']
        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'signout.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'signout.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class ForgotHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['rnd'] = random.randrange(1, 100)
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › 重新设置密码'
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'forgot.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
    
    def post(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['rnd'] = random.randrange(1, 100)
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › 重新设置密码'
        # Verification: username & email
        username = self.request.get('username').strip().lower()
        email = self.request.get('email').strip().lower()
        q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1 AND email = :2", username, email)
        if q.count() == 1:
            one = q[0]
            q2 = db.GqlQuery("SELECT * FROM PasswordResetToken WHERE timestamp > :1 AND email = :2", (int(time.time()) - 86400), email)
            if q2.count() > 2:
                error_message = '你不能在 24 小时内进行超过 2 次的密码重设操作。'
                template_values['errors'] = 1
                template_values['error_message'] = error_message
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'forgot.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                token = ''.join([str(random.randint(0, 9)) for i in range(32)])
                prt = PasswordResetToken()
                prt.token = token
                prt.member = one
                prt.email = one.email
                prt.timestamp = int(time.time())
                prt.put()
                mail_template_values = {}
                mail_template_values['site'] = site
                mail_template_values['one'] = one
                mail_template_values['host'] = self.request.headers['Host']
                mail_template_values['token'] = token
                mail_template_values['ua'] = self.request.headers['User-Agent']
                mail_template_values['ip'] = self.request.remote_addr
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mail', 'reset_password.txt')
                output = template.render(path, mail_template_values)
                result = mail.send_mail(sender="v2ex.livid@me.com",
                              to=one.email,
                              subject="=?UTF-8?B?" + base64.b64encode((u"[" + site.title + u"] 重新设置密码").encode('utf-8')) + "?=",
                              body=output)
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'forgot_sent.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            error_message = '无法找到匹配的用户名和邮箱记录'
            template_values['errors'] = 1
            template_values['error_message'] = error_message
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'forgot.html')
            output = template.render(path, template_values)
            self.response.out.write(output)

class PasswordResetHandler(BaseHandler):
    def get(self, token):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        member = False
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        token = str(token.strip().lower())
        q = db.GqlQuery("SELECT * FROM PasswordResetToken WHERE token = :1 AND valid = 1", token)
        if q.count() == 1:
            prt = q[0]
            template_values['page_title'] = site.title + u' › 重新设置密码'
            template_values['token'] = prt
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'reset_password.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'token_not_found.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
    
    def post(self, token):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        member = False
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        token = str(token.strip().lower())
        q = db.GqlQuery("SELECT * FROM PasswordResetToken WHERE token = :1 AND valid = 1", token)
        if q.count() == 1:
            prt = q[0]
            template_values['page_title'] = site.title + u' › 重新设置密码'
            template_values['token'] = prt
            # Verification
            errors = 0
            new_password = str(self.request.get('new_password').strip())
            new_password_again = str(self.request.get('new_password_again').strip())
            if new_password is '' or new_password_again is '':
                errors = errors + 1
                error_message = '请输入两次新密码'
            if errors == 0:
                if new_password != new_password_again:
                    errors = errors + 1
                    error_message = '两次输入的新密码不一致'
            if errors == 0:
                if len(new_password) > 32:
                    errors = errors + 1
                    error_message = '新密码长度不能超过 32 个字符'
            if errors == 0:
                q2 = db.GqlQuery("SELECT * FROM Member WHERE num = :1", prt.member.num)
                one = q2[0]
                one.password = hashlib.sha1(new_password).hexdigest()
                one.auth = hashlib.sha1(str(one.num) + ':' + one.password).hexdigest()
                one.put()
                prt.valid = 0
                prt.put()
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'reset_password_ok.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                template_values['errors'] = errors
                template_values['error_message'] = error_message
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'reset_password.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'token_not_found.html')
            output = template.render(path, template_values)
            self.response.out.write(output)

class NodeGraphHandler(BaseHandler):
    def get(self, node_name):
        site = GetSite()
        browser = detect(self.request)
        self.session = Session()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        can_create = False
        can_manage = False
        if site.topic_create_level > 999:
            if member:
                can_create = True
        else:
            if member:
                if member.level <= site.topic_create_level:
                    can_create = True
        if member:
            if member.level == 0:
                can_manage = True
        template_values['can_create'] = can_create
        template_values['can_manage'] = can_manage
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n    
        node = GetKindByName('Node', node_name)
        template_values['node'] = node
        if node:
            template_values['feed_link'] = '/feed/' + node.name + '.xml'
            template_values['feed_title'] = site.title + u' › ' + node.title
            template_values['canonical'] = 'http://' + site.domain + '/go/' + node.name
            if node.parent_node_name is None:
                siblings = []
            else:
                siblings = db.GqlQuery("SELECT * FROM Node WHERE parent_node_name = :1 AND name != :2", node.parent_node_name, node.name)
            template_values['siblings'] = siblings
            if member:
                favorited = member.hasFavorited(node)
                template_values['favorited'] = favorited
                recent_nodes = memcache.get('member::' + str(member.num) + '::recent_nodes')
                recent_nodes_ids = memcache.get('member::' + str(member.num) + '::recent_nodes_ids')
                if recent_nodes and recent_nodes_ids:
                    if (node.num in recent_nodes_ids) is not True:
                        recent_nodes.insert(0, node)
                        recent_nodes_ids.insert(0, node.num)
                        memcache.set('member::' + str(member.num) + '::recent_nodes', recent_nodes, 7200)
                        memcache.set('member::' + str(member.num) + '::recent_nodes_ids', recent_nodes_ids, 7200)
                else:
                    recent_nodes = []
                    recent_nodes.append(node)
                    recent_nodes_ids = []
                    recent_nodes_ids.append(node.num)
                    memcache.set('member::' + str(member.num) + '::recent_nodes', recent_nodes, 7200)
                    memcache.set('member::' + str(member.num) + '::recent_nodes_ids', recent_nodes_ids, 7200)
                template_values['recent_nodes'] = recent_nodes
            template_values['page_title'] = site.title + u' › ' + node.title
        else:
            template_values['page_title'] = site.title + u' › 节点未找到'
        section = False
        if node:
            section = GetKindByNum('Section', node.section_num)
        template_values['section'] = section
        if browser['ios']:
            if (node):
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'node_graph.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'node_not_found.html')
        else:
            if (node):
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node_graph.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node_not_found.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class NodeHandler(webapp.RequestHandler):
    def get(self, node_name):
        site = GetSite()
        browser = detect(self.request)
        self.session = Session()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        can_create = False
        can_manage = False
        if site.topic_create_level > 999:
            if member:
                can_create = True
        else:
            if member:
                if member.level <= site.topic_create_level:
                    can_create = True
        if member:
            if member.level == 0:
                can_manage = True
        template_values['can_create'] = can_create
        template_values['can_manage'] = can_manage
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n    
        node = GetKindByName('Node', node_name)
        template_values['node'] = node
        pagination = False
        pages = 1
        page = 1
        page_size = 15
        start = 0
        has_more = False
        more = 1
        has_previous = False
        previous = 1
        if node:
            template_values['feed_link'] = '/feed/' + node.name + '.xml'
            template_values['feed_title'] = site.title + u' › ' + node.title
            template_values['canonical'] = 'http://' + site.domain + '/go/' + node.name
            if member:
                favorited = member.hasFavorited(node)
                template_values['favorited'] = favorited
                recent_nodes = memcache.get('member::' + str(member.num) + '::recent_nodes')
                recent_nodes_ids = memcache.get('member::' + str(member.num) + '::recent_nodes_ids')
                if recent_nodes and recent_nodes_ids:
                    if (node.num in recent_nodes_ids) is not True:
                        recent_nodes.insert(0, node)
                        recent_nodes_ids.insert(0, node.num)
                        memcache.set('member::' + str(member.num) + '::recent_nodes', recent_nodes, 7200)
                        memcache.set('member::' + str(member.num) + '::recent_nodes_ids', recent_nodes_ids, 7200)
                else:
                    recent_nodes = []
                    recent_nodes.append(node)
                    recent_nodes_ids = []
                    recent_nodes_ids.append(node.num)
                    memcache.set('member::' + str(member.num) + '::recent_nodes', recent_nodes, 7200)
                    memcache.set('member::' + str(member.num) + '::recent_nodes_ids', recent_nodes_ids, 7200)
                template_values['recent_nodes'] = recent_nodes
            template_values['page_title'] = site.title + u' › ' + node.title
            # Pagination
            if node.topics > page_size:
                pagination = True
            else:
                pagination = False
            if pagination:
                if node.topics % page_size == 0:
                    pages = int(node.topics / page_size)
                else:
                    pages = int(node.topics / page_size) + 1
                page = self.request.get('p')
                if (page == '') or (page is None):
                    page = 1
                else:
                    page = int(page)
                    if page > pages:
                        page = pages
                    else:
                        if page < 1:
                            page = 1
                if page < pages:
                    has_more = True
                    more = page + 1
                if page > 1:
                    has_previous = True
                    previous = page - 1    
                start = (page - 1) * page_size
                template_values['canonical'] = 'http://' + site.domain + '/go/' + node.name + '?p=' + str(page)
        else:
            template_values['page_title'] = site.title + u' › 节点未找到'
        template_values['pagination'] = pagination
        template_values['pages'] = pages
        template_values['page'] = page
        template_values['page_size'] = page_size
        template_values['has_more'] = has_more
        template_values['more'] = more
        template_values['has_previous'] = has_previous
        template_values['previous'] = previous
        section = False
        if node:
            section = GetKindByNum('Section', node.section_num)
        template_values['section'] = section
        topics = False
        if node:
            q3 = db.GqlQuery("SELECT * FROM Topic WHERE node_num = :1 ORDER BY last_touched DESC LIMIT " + str(start) + ", " + str(page_size), node.num)
            topics = q3
        template_values['latest'] = topics
        if browser['ios']:
            if (node):
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'node.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'node_not_found.html')
        else:
            if (node):
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node_not_found.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class NodeApiHandler(webapp.RequestHandler):
    def get(self, node_name):
        site = GetSite()
        node = GetKindByName('Node', node_name)
        if node:
            template_values = {}
            template_values['site'] = site
            template_values['node'] = node
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'node.json')
            self.response.headers['Content-type'] = 'application/json;charset=UTF-8'
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.error(404)

class SearchHandler(webapp.RequestHandler):
    def get(self, q):
        site = GetSite()
        q = urllib.unquote(q)
        template_values = {}
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › 搜索 ' + q.decode('utf-8')
        template_values['q'] = q
        if config.fts_enabled is not True:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'search_unavailable.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            if re.findall('^([a-zA-Z0-9\_]+)$', q):
                node = GetKindByName('Node', q.lower())
                if node is not None:
                    template_values['node'] = node
            # Fetch result
            q_lowered = q.lower()
            q_md5 = hashlib.md5(q_lowered).hexdigest()
            topics = memcache.get('q::' + q_md5)
            if topics is None:
                try:
                    if os.environ['SERVER_SOFTWARE'] == 'Development/1.0':
                        fts = u'http://127.0.0.1:20000/search?q=' + str(urllib.quote(q_lowered))
                    else:
                        fts = u'http://' + config.fts_server + '/search?q=' + str(urllib.quote(q_lowered))
                    response = urlfetch.fetch(fts, headers = {"Authorization" : "Basic %s" % base64.b64encode(config.fts_username + ':' + config.fts_password)})
                    if response.status_code == 200:
                        results = json.loads(response.content)
                        topics = []
                        for num in results:
                            topics.append(GetKindByNum('Topic', num))
                        template_values['topics'] = topics
                        memcache.set('q::' + q_md5, topics, 86400)
                except:
                    template_values['topics'] = []
            else:
                template_values['topics'] = topics
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'search.html')
            output = template.render(path, template_values)
            self.response.out.write(output)

class DispatcherHandler(webapp.RequestHandler):
    def post(self):
        referer = self.request.headers['Referer']
        q = self.request.get('q').strip()
        if len(q) > 0:
            self.redirect('/q/' + q)
        else:
            self.redirect(referer)

class RouterHandler(webapp.RequestHandler):
    def get(self, path):
        if path.find('/') != -1:
            # Page
            parts = path.split('/')
            if len(parts) == 2:
                minisite_name = parts[0]
                if parts[1] == '':
                    page_name = 'index.html'
                else:
                    page_name = parts[1]
                minisite = GetKindByName('Minisite', minisite_name)
                if minisite is not False:
                    page = memcache.get(path)
                    if page is None:
                        q = db.GqlQuery("SELECT * FROM Page WHERE name = :1 AND minisite = :2", page_name, minisite)
                        if q.count() == 1:
                            page = q[0]
                            memcache.set(path, page, 864000)
                    if page.mode == 1:
                        # Dynamic embedded page
                        template_values = {}
                        site = GetSite()
                        template_values['site'] = site
                        member = CheckAuth(self)
                        if member:
                            template_values['member'] = member
                        l10n = GetMessages(self, member, site)
                        template_values['l10n'] = l10n
                        template_values['rnd'] = random.randrange(1, 100)
                        template_values['page'] = page
                        template_values['minisite'] = page.minisite
                        template_values['page_title'] = site.title + u' › ' + page.minisite.title.decode('utf-8') + u' › ' + page.title.decode('utf-8')
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'page.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                    else:
                        # Static standalone page
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        expires_date = datetime.datetime.utcnow() + datetime.timedelta(days=10)
                        expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
                        self.response.headers.add_header("Expires", expires_str)
                        self.response.headers['Cache-Control'] = 'max-age=864000, must-revalidate'
                        self.response.headers['Content-Type'] = page.content_type
                        self.response.out.write(page.content)
            else:
                minisite_name = parts[0]
                page_name = 'index.html'
                minisite = GetKindByName('Minisite', minisite_name)
                if minisite is not False:
                    page = memcache.get(path)
                    if page is None:
                        q = db.GqlQuery("SELECT * FROM Page WHERE name = :1 AND minisite = :2", page_name, minisite)
                        if q.count() == 1:
                            page = q[0]
                            memcache.set(path, page, 864000)
                    if page.mode == 1:
                        # Dynamic embedded page
                        template_values = {}
                        site = GetSite()
                        template_values['site'] = site
                        member = CheckAuth(self)
                        if member:
                            template_values['member'] = member
                        l10n = GetMessages(self, member, site)
                        template_values['l10n'] = l10n
                        template_values['rnd'] = random.randrange(1, 100)
                        template_values['page'] = page
                        template_values['minisite'] = page.minisite
                        template_values['page_title'] = site.title + u' › ' + page.minisite.title.decode('utf-8') + u' › ' + page.title.decode('utf-8')
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'page.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                    else:
                        # Static standalone page
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        expires_date = datetime.datetime.utcnow() + datetime.timedelta(days=10)
                        expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
                        self.response.headers.add_header("Expires", expires_str)
                        self.response.headers['Cache-Control'] = 'max-age=864000, must-revalidate'
                        self.response.headers['Content-Type'] = page.content_type
                        self.response.out.write(page.content)
        else:
            # Site
            page = memcache.get(path + '/index.html')
            if page:
                taskqueue.add(url='/hit/page/' + str(page.key()))
                if page.mode == 1:
                    # Dynamic embedded page
                    template_values = {}
                    site = GetSite()
                    template_values['site'] = site
                    member = CheckAuth(self)
                    if member:
                        template_values['member'] = member
                    l10n = GetMessages(self, member, site)
                    template_values['l10n'] = l10n
                    template_values['rnd'] = random.randrange(1, 100)
                    template_values['page'] = page
                    template_values['minisite'] = page.minisite
                    template_values['page_title'] = site.title + u' › ' + page.minisite.title.decode('utf-8') + u' › ' + page.title.decode('utf-8')
                    taskqueue.add(url='/hit/page/' + str(page.key()))
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'page.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    expires_date = datetime.datetime.utcnow() + datetime.timedelta(days=10)
                    expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
                    self.response.headers.add_header("Expires", expires_str)
                    self.response.headers['Cache-Control'] = 'max-age=864000, must-revalidate'
                    self.response.headers['Content-Type'] = page.content_type
                    self.response.out.write(page.content)
            else:
                minisite_name = path
                minisite = GetKindByName('Minisite', minisite_name)
                q = db.GqlQuery("SELECT * FROM Page WHERE name = :1 AND minisite = :2", 'index.html', minisite)
                if q.count() == 1:
                    page = q[0]
                    memcache.set(path + '/index.html', page, 864000)
                    if page.mode == 1:
                        # Dynamic embedded page
                        template_values = {}
                        site = GetSite()
                        template_values['site'] = site
                        member = CheckAuth(self)
                        if member:
                            template_values['member'] = member
                        l10n = GetMessages(self, member, site)
                        template_values['l10n'] = l10n
                        template_values['rnd'] = random.randrange(1, 100)
                        template_values['page'] = page
                        template_values['minisite'] = page.minisite
                        template_values['page_title'] = site.title + u' › ' + page.minisite.title.decode('utf-8') + u' › ' + page.title.decode('utf-8')
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'page.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                    else:
                        # Static standalone page
                        taskqueue.add(url='/hit/page/' + str(page.key()))
                        expires_date = datetime.datetime.utcnow() + datetime.timedelta(days=10)
                        expires_str = expires_date.strftime("%d %b %Y %H:%M:%S GMT")
                        self.response.headers.add_header("Expires", expires_str)
                        self.response.headers['Cache-Control'] = 'max-age=864000, must-revalidate'
                        self.response.headers['Content-Type'] = page.content_type
                        self.response.out.write(page.content)

class ChangesHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 全站最新更改记录'
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        
        topic_total = memcache.get('topic_total')
        if topic_total is None:
            q2 = db.GqlQuery("SELECT * FROM Counter WHERE name = 'topic.total'")
            if (q2.count() > 0):
                topic_total = q2[0].value
            else:
                topic_total = 0
            memcache.set('topic_total', topic_total, 600)
        template_values['topic_total'] = topic_total
        
        page_size = 60
        pages = 1
        if topic_total > page_size:
            if (topic_total % page_size) > 0:
                pages = int(math.floor(topic_total / page_size)) + 1
            else:
                pages = int(math.floor(topic_total / page_size))
        try:
            page_current = int(self.request.get('p'))
            if page_current < 1:
                page_current = 1
            if page_current > pages:
                page_current = pages
        except:
            page_current = 1
        page_start = (page_current - 1) * page_size
        template_values['pages'] = pages
        template_values['page_current'] = page_current
        i = 1
        ps = []
        while i <= pages:
            ps.append(i)
            i = i + 1
        template_values['ps'] = ps
        
        latest = memcache.get('q_changes_' + str(page_current))
        if (latest):
            template_values['latest'] = latest
        else:
            q1 = db.GqlQuery("SELECT * FROM Topic ORDER BY last_touched DESC LIMIT " + str(page_start) + "," + str(page_size))
            topics = []
            for topic in q1:
                topics.append(topic)
            memcache.set('q_changes_' + str(page_current), topics, 120)
            template_values['latest'] = topics
            template_values['latest_total'] = len(topics)
        if browser['ios']:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'changes.html')
        else:
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'changes.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

def main():
    application = webapp.WSGIApplication([
    ('/', HomeHandler),
    ('/planes/?', PlanesHandler),
    ('/recent', RecentHandler),
    ('/ua', UAHandler),
    ('/signin', SigninHandler),
    ('/signup', SignupHandler),
    ('/signout', SignoutHandler),
    ('/forgot', ForgotHandler),
    ('/reset/([0-9]+)', PasswordResetHandler),
    ('/go/([a-zA-Z0-9]+)/graph', NodeGraphHandler),
    ('/go/([a-zA-Z0-9]+)', NodeHandler),
    ('/n/([a-zA-Z0-9]+).json', NodeApiHandler),
    ('/q/(.*)', SearchHandler),
    ('/_dispatcher', DispatcherHandler),
    ('/changes', ChangesHandler),
    ('/(.*)', RouterHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = base_handler
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Base handler class for all mapreduce handlers.
"""




import logging
from mapreduce.lib import simplejson

from google.appengine.ext import webapp


class BaseHandler(webapp.RequestHandler):
  """Base class for all mapreduce handlers."""

  def base_path(self):
    """Base path for all mapreduce-related urls."""
    path = self.request.path
    return path[:path.rfind("/")]


class JsonHandler(BaseHandler):
  """Base class for JSON handlers for user interface.

  Sub-classes should implement the 'handle' method. They should put their
  response data in the 'self.json_response' dictionary. Any exceptions raised
  by the sub-class implementation will be sent in a JSON response with the
  name of the error_class and the error_message.
  """

  def __init__(self):
    """Initializer."""
    super(BaseHandler, self).__init__()
    self.json_response = {}

  def get(self):
    self.post()

  def post(self):
    self.json_response.clear()
    try:
      self.handle()
    except Exception, e:
      logging.exception("Error in JsonHandler, returning exception.")
      # TODO(user): Include full traceback here for the end-user.
      self.json_response.clear()
      self.json_response["error_class"] = e.__class__.__name__
      self.json_response["error_message"] = str(e)

    self.response.headers["Content-Type"] = "text/javascript"
    try:
      output = simplejson.dumps(self.json_response)
    except:
      logging.exception("Could not serialize to JSON")
      self.response.set_status(500, message="Could not serialize to JSON")
      return
    else:
      self.response.out.write(output)

  def handle(self):
    """To be implemented by sub-classes."""
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = context
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Mapreduce execution context.

Mapreduce context provides handler code with information about
current mapreduce execution and organizes utility data flow
from handlers such as counters, log messages, mutation pools.
"""



__all__ = ["MAX_ENTITY_COUNT", "MAX_POOL_SIZE", "Context", "MutationPool",
           "Counters", "ItemList", "EntityList", "get", "COUNTER_MAPPER_CALLS"]

from google.appengine.api import datastore
from google.appengine.ext import db

# Maximum pool size in bytes. Pool will be flushed when reaches this amount.
# We use 950,000 bytes which is slightly less than maximum allowed RPC size of
# 1M to have some space cushion.
MAX_POOL_SIZE = 900 * 1000

# Maximum number of items. Pool will be flushed when reaches this amount.
MAX_ENTITY_COUNT = 500

# The name of the counter which counts all mapper calls.
COUNTER_MAPPER_CALLS = "mapper_calls"


def _normalize_entity(value):
  """Return an entity from an entity or model instance."""
  # TODO(user): Consider using datastore.NormalizeAndTypeCheck.
  if getattr(value, "_populate_internal_entity", None):
    return value._populate_internal_entity()
  return value

def _normalize_key(value):
  """Return a key from an entity, model instance, key, or key string."""
  if getattr(value, "key", None):
    return value.key()
  elif isinstance(value, basestring):
    return datastore.Key(value)
  else:
    return value

class ItemList(object):
  """Holds list of arbitrary items, and their total size.

  Properties:
    items: list of objects.
    length: length of item list.
    size: aggregate item size in bytes.
  """

  def __init__(self):
    """Constructor."""
    self.items = []
    self.length = 0
    self.size = 0

  def append(self, item, item_size):
    """Add new item to the list.

    Args:
      item: an item to add to the list.
      item_size: item size in bytes as int.
    """
    self.items.append(item)
    self.length += 1
    self.size += item_size

  def clear(self):
    """Clear item list."""
    self.items = []
    self.length = 0
    self.size = 0

  @property
  def entities(self):
    """Return items. For backwards compatability."""
    return self.items


# For backwards compatability.
EntityList = ItemList


# TODO(user): mutation pool has no error handling at all. Add some.
class MutationPool(object):
  """Mutation pool accumulates datastore changes to perform them in batch.

  Properties:
    puts: ItemList of entities to put to datastore.
    deletes: ItemList of keys to delete from datastore.
    max_pool_size: maximum single list pool size. List changes will be flushed
      when this size is reached.
  """

  def __init__(self, max_pool_size=MAX_POOL_SIZE):
    """Constructor.

    Args:
      max_pool_size: maximum pools size in bytes before flushing it to db.
    """
    self.max_pool_size = max_pool_size
    self.puts = ItemList()
    self.deletes = ItemList()

  def put(self, entity):
    """Registers entity to put to datastore.

    Args:
      entity: an entity or model instance to put.
    """
    actual_entity = _normalize_entity(entity)
    entity_size = len(actual_entity._ToPb().Encode())
    if (self.puts.length >= MAX_ENTITY_COUNT or
        (self.puts.size + entity_size) > self.max_pool_size):
      self.__flush_puts()
    self.puts.append(actual_entity, entity_size)

  def delete(self, entity):
    """Registers entity to delete from datastore.

    Args:
      entity: an entity, model instance, or key to delete.
    """
    # This is not very nice: we're calling two protected methods here...
    key = _normalize_key(entity)
    key_size = len(key._ToPb().Encode())
    if (self.deletes.length >= MAX_ENTITY_COUNT or
        (self.deletes.size + key_size) > self.max_pool_size):
      self.__flush_deletes()
    self.deletes.append(key, key_size)

  # TODO(user): some kind of error handling/retries is needed here.
  def flush(self):
    """Flush(apply) all changed to datastore."""
    self.__flush_puts()
    self.__flush_deletes()

  def __flush_puts(self):
    """Flush all puts to datastore."""
    datastore.Put(self.puts.items)
    self.puts.clear()

  def __flush_deletes(self):
    """Flush all deletes to datastore."""
    datastore.Delete(self.deletes.items)
    self.deletes.clear()


# This doesn't do much yet. In future it will play nicely with checkpoint/error
# handling system.
class Counters(object):
  """Regulates access to counters."""

  def __init__(self, shard_state):
    """Constructor.

    Args:
      shard_state: current mapreduce shard state as model.ShardState.
    """
    self._shard_state = shard_state

  def increment(self, counter_name, delta=1):
    """Increment counter value.

    Args:
      counter_name: name of the counter as string.
      delta: increment delta as int.
    """
    self._shard_state.counters_map.increment(counter_name, delta)

  def flush(self):
    """Flush unsaved counter values."""
    pass


class Context(object):
  """MapReduce execution context.

  Properties:
    mapreduce_spec: current mapreduce specification as model.MapreduceSpec.
    shard_state: current shard state as model.ShardState.
    mutation_pool: current mutation pool as MutationPool.
    counters: counters object as Counters.
  """

  # Current context instance
  _context_instance = None

  def __init__(self, mapreduce_spec, shard_state):
    """Constructor.

    Args:
      mapreduce_spec: mapreduce specification as model.MapreduceSpec.
      shard_state: shard state as model.ShardState.
    """
    # TODO(user): Make these properties protected
    self.mapreduce_spec = mapreduce_spec
    self.shard_state = shard_state

    # TODO(user): These properties can stay public.
    self.mutation_pool = MutationPool()
    self.counters = Counters(shard_state)

    self._pools = {}
    self.register_pool("mutation_pool", self.mutation_pool)
    self.register_pool("counters", self.counters)

  def flush(self):
    """Flush all information recorded in context."""
    for pool in self._pools.values():
      pool.flush()
    if self.shard_state:
      self.shard_state.put()

  # TODO(user): Add convenience method for mapper params.

  # TODO(user): Add fatal error logging method here. Will log the message
  # and set the shard state to failure result status, which the controller
  # callback should pick up and force all shards to terminate.

  def register_pool(self, key, pool):
    """Register an arbitrary pool to be flushed together with this context.

    Args:
      key: pool key as string.
      pool: a pool instance. Pool should implement flush(self) method.
    """
    self._pools[key] = pool

  def get_pool(self, key):
    """Obtains an instance of registered pool.

    Args:
      key: pool key as string.

    Returns:
      an instance of the pool registered earlier, or None.
    """
    return self._pools.get(key, None)

  @classmethod
  def _set(cls, context):
    """Set current context instance.

    Args:
      context: new context as Context or None.
    """
    cls._context_instance = context


def get():
  """Get current context instance.

  Returns:
    current context as Context.
  """
  return Context._context_instance

########NEW FILE########
__FILENAME__ = control
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""API for controlling MapReduce execution outside of MapReduce framework."""



__all__ = ["start_map"]

# pylint: disable-msg=C6409


from mapreduce import handlers
from mapreduce import model


def start_map(name,
              handler_spec,
              reader_spec,
              reader_parameters,
              shard_count,
              mapreduce_parameters={},
              base_path="/mapreduce",
              queue_name="default",
              eta=None,
              countdown=None,
              _app=None):
  """Start a new, mapper-only mapreduce.

  Args:
    name: mapreduce name. Used only for display purposes.
    handler_spec: fully qualified name of mapper handler function/class to call.
    reader_spec: fully qualified name of mapper reader to use
    reader_parameters: dictionary of parameters to pass to reader. These are
      reader-specific.
    shard_count: number of shards to create.
    mapreduce_parameters: dictionary of mapreduce parameters relevant to the
      whole job.
    base_path: base path of mapreduce library handler specified in app.yaml.
      "/mapreduce" by default.
    queue_name: executor queue name to be used for mapreduce tasks.
    eta: Absolute time when the MR should execute. May not be specified
        if 'countdown' is also supplied. This may be timezone-aware or
        timezone-naive.
    countdown: Time in seconds into the future that this MR should execute.
        Defaults to zero.

  Returns:
    mapreduce id as string.
  """
  mapper_spec = model.MapperSpec(handler_spec, reader_spec, reader_parameters,
                                 shard_count)

  return handlers.StartJobHandler._start_map(
      name,
      mapper_spec,
      mapreduce_parameters,
      base_path=base_path,
      queue_name=queue_name,
      eta=eta,
      countdown=countdown,
      _app=_app)


########NEW FILE########
__FILENAME__ = handlers
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""Defines executor tasks handlers for MapReduce implementation."""



# Disable "Invalid method name"
# pylint: disable-msg=C6409

import datetime
import logging
import math
import os
from mapreduce.lib import simplejson
import time

from google.appengine.api import memcache
from google.appengine.api.labs import taskqueue
from google.appengine.ext import db
from mapreduce import base_handler
from mapreduce import context
from mapreduce import quota
from mapreduce import model
from mapreduce import quota
from mapreduce import util


# TODO(user): Make this a product of the reader or in quotas.py
_QUOTA_BATCH_SIZE = 20

# The amount of time to perform scanning in one slice. New slice will be
# scheduled as soon as current one takes this long.
_SLICE_DURATION_SEC = 15

# Delay between consecutive controller callback invocations.
_CONTROLLER_PERIOD_SEC = 2


class Error(Exception):
  """Base class for exceptions in this module."""


class NotEnoughArgumentsError(Error):
  """Required argument is missing."""


class NoDataError(Error):
  """There is no data present for a desired input."""


class MapperWorkerCallbackHandler(base_handler.BaseHandler):
  """Callback handler for mapreduce worker task.

  Request Parameters:
    mapreduce_spec: MapreduceSpec of the mapreduce serialized to json.
    shard_id: id of the shard.
    slice_id: id of the slice.
  """

  def __init__(self, time_function=time.time):
    """Constructor.

    Args:
      time_function: time function to use to obtain current time.
    """
    base_handler.BaseHandler.__init__(self)
    self._time = time_function

  def post(self):
    """Handle post request."""
    spec = model.MapreduceSpec.from_json_str(
        self.request.get("mapreduce_spec"))
    self._start_time = self._time()
    shard_id = self.shard_id()

    # TODO(user): Make this prettier
    logging.debug("post: shard=%s slice=%s headers=%s",
                  shard_id, self.slice_id(), self.request.headers)

    shard_state, control = db.get([
        model.ShardState.get_key_by_shard_id(shard_id),
        model.MapreduceControl.get_key_by_job_id(spec.mapreduce_id),
    ])
    if not shard_state:
      # We're letting this task to die. It's up to controller code to
      # reinitialize and restart the task.
      logging.error("State not found for shard ID %r; shutting down",
                    shard_id)
      return

    if control and control.command == model.MapreduceControl.ABORT:
      logging.info("Abort command received by shard %d of job '%s'",
                   shard_state.shard_number, shard_state.mapreduce_id)
      shard_state.active = False
      shard_state.result_status = model.ShardState.RESULT_ABORTED
      shard_state.put()
      model.MapreduceControl.abort(spec.mapreduce_id)
      return

    input_reader = self.input_reader(spec.mapper)

    if spec.mapper.params.get("enable_quota", True):
      quota_consumer = quota.QuotaConsumer(
          quota.QuotaManager(memcache.Client()),
          shard_id,
          _QUOTA_BATCH_SIZE)
    else:
      quota_consumer = None

    ctx = context.Context(spec, shard_state)
    context.Context._set(ctx)

    try:
      # consume quota ahead, because we do not want to run a datastore
      # query if there's not enough quota for the shard.
      if not quota_consumer or quota_consumer.check():
        scan_aborted = False
        entity = None

        # We shouldn't fetch an entity from the reader if there's not enough
        # quota to process it. Perform all quota checks proactively.
        if not quota_consumer or quota_consumer.consume():
          for entity in input_reader:
            if isinstance(entity, db.Model):
              shard_state.last_work_item = repr(entity.key())
            else:
              shard_state.last_work_item = repr(entity)[:100]

            scan_aborted = not self.process_entity(entity, ctx)

            # Check if we've got enough quota for the next entity.
            if (quota_consumer and not scan_aborted and
                not quota_consumer.consume()):
              scan_aborted = True
            if scan_aborted:
              break
        else:
          scan_aborted = True


        if not scan_aborted:
          logging.info("Processing done for shard %d of job '%s'",
                       shard_state.shard_number, shard_state.mapreduce_id)
          # We consumed extra quota item at the end of for loop.
          # Just be nice here and give it back :)
          if quota_consumer:
            quota_consumer.put(1)
          shard_state.active = False
          shard_state.result_status = model.ShardState.RESULT_SUCCESS

      # TODO(user): Mike said we don't want this happen in case of
      # exception while scanning. Figure out when it's appropriate to skip.
      ctx.flush()
    finally:
      context.Context._set(None)
      if quota_consumer:
        quota_consumer.dispose()

    # Rescheduling work should always be the last statement. It shouldn't happen
    # if there were any exceptions in code before it.
    if shard_state.active:
      self.reschedule(spec, input_reader)

  def process_entity(self, entity, ctx):
    """Process a single entity.

    Call mapper handler on the entity.

    Args:
      entity: an entity to process.
      ctx: current execution context.

    Returns:
      True if scan should be continued, False if scan should be aborted.
    """
    ctx.counters.increment(context.COUNTER_MAPPER_CALLS)

    handler = ctx.mapreduce_spec.mapper.handler
    if util.is_generator_function(handler):
      for result in handler(entity):
        if callable(result):
          result(ctx)
        else:
          try:
            if len(result) == 2:
              logging.error("Collectors not implemented yet")
            else:
              logging.error("Got bad output tuple of length %d", len(result))
          except TypeError:
            logging.error(
                "Handler yielded type %s, expected a callable or a tuple",
                result.__class__.__name__)
    else:
      handler(entity)

    if self._time() - self._start_time > _SLICE_DURATION_SEC:
      logging.debug("Spent %s seconds. Rescheduling",
                    self._time() - self._start_time)
      return False
    return True

  def shard_id(self):
    """Get shard unique identifier of this task from request.

    Returns:
      shard identifier as string.
    """
    return str(self.request.get("shard_id"))

  def slice_id(self):
    """Get slice unique identifier of this task from request.

    Returns:
      slice identifier as int.
    """
    return int(self.request.get("slice_id"))

  def input_reader(self, mapper_spec):
    """Get the reader from mapper_spec initialized with the request's state.

    Args:
      mapper_spec: a mapper spec containing the immutable mapper state.

    Returns:
      An initialized InputReader.
    """
    input_reader_spec_dict = simplejson.loads(
        self.request.get("input_reader_state"))
    return mapper_spec.input_reader_class().from_json(
        input_reader_spec_dict)

  @staticmethod
  def worker_parameters(mapreduce_spec,
                        shard_id,
                        slice_id,
                        input_reader):
    """Fill in mapper worker task parameters.

    Returned parameters map is to be used as task payload, and it contains
    all the data, required by mapper worker to perform its function.

    Args:
      mapreduce_spec: specification of the mapreduce.
      shard_id: id of the shard (part of the whole dataset).
      slice_id: id of the slice (part of the shard).
      input_reader: InputReader containing the remaining inputs for this
        shard.

    Returns:
      string->string map of parameters to be used as task payload.
    """
    return {"mapreduce_spec": mapreduce_spec.to_json_str(),
            "shard_id": shard_id,
            "slice_id": str(slice_id),
            "input_reader_state": input_reader.to_json_str()}

  @staticmethod
  def get_task_name(shard_id, slice_id):
    """Compute single worker task name.

    Args:
      shard_id: id of the shard (part of the whole dataset) as string.
      slice_id: id of the slice (part of the shard) as int.

    Returns:
      task name which should be used to process specified shard/slice.
    """
    # Prefix the task name with something unique to this framework's
    # namespace so we don't conflict with user tasks on the queue.
    return "appengine-mrshard-%s-%s" % (shard_id, slice_id)

  def reschedule(self, mapreduce_spec, input_reader):
    """Reschedule worker task to continue scanning work.

    Args:
      mapreduce_spec: mapreduce specification.
      input_reader: remaining input reader to process.
    """
    MapperWorkerCallbackHandler.schedule_slice(
        self.base_path(), mapreduce_spec, self.shard_id(),
        self.slice_id() + 1, input_reader)

  @classmethod
  def schedule_slice(cls,
                     base_path,
                     mapreduce_spec,
                     shard_id,
                     slice_id,
                     input_reader,
                     queue_name=None,
                     eta=None,
                     countdown=None):
    """Schedule slice scanning by adding it to the task queue.

    Args:
      base_path: base_path of mapreduce request handlers as string.
      mapreduce_spec: mapreduce specification as MapreduceSpec.
      shard_id: current shard id as string.
      slice_id: slice id as int.
      input_reader: remaining InputReader for given shard.
      queue_name: Optional queue to run on; uses the current queue of
        execution or the default queue if unspecified.
      eta: Absolute time when the MR should execute. May not be specified
        if 'countdown' is also supplied. This may be timezone-aware or
        timezone-naive.
      countdown: Time in seconds into the future that this MR should execute.
        Defaults to zero.
    """
    task_params = MapperWorkerCallbackHandler.worker_parameters(
        mapreduce_spec, shard_id, slice_id, input_reader)
    task_name = MapperWorkerCallbackHandler.get_task_name(shard_id, slice_id)
    queue_name = os.environ.get("HTTP_X_APPENGINE_QUEUENAME",
                                queue_name or "default")
    try:
      taskqueue.Task(url=base_path + "/worker_callback",
                     params=task_params,
                     name=task_name,
                     eta=eta,
                     countdown=countdown).add(queue_name)
    except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError), e:
      logging.warning("Task %r with params %r already exists. %s: %s",
                      task_name, task_params, e.__class__, e)


class ControllerCallbackHandler(base_handler.BaseHandler):
  """Supervises mapreduce execution.

  Is also responsible for gathering execution status from shards together.

  This task is "continuously" running by adding itself again to taskqueue if
  mapreduce is still active.
  """

  def __init__(self, time_function=time.time):
    """Constructor.

    Args:
      time_function: time function to use to obtain current time.
    """
    base_handler.BaseHandler.__init__(self)
    self._time = time_function

  def post(self):
    """Handle post request."""
    spec = model.MapreduceSpec.from_json_str(
        self.request.get("mapreduce_spec"))

    # TODO(user): Make this logging prettier.
    logging.debug("post: id=%s headers=%s",
                  spec.mapreduce_id, self.request.headers)

    state, control = db.get([
        model.MapreduceState.get_key_by_job_id(spec.mapreduce_id),
        model.MapreduceControl.get_key_by_job_id(spec.mapreduce_id),
    ])
    if not state:
      logging.error("State not found for mapreduce_id '%s'; skipping",
                    spec.mapreduce_id)
      return

    shard_states = model.ShardState.find_by_mapreduce_id(spec.mapreduce_id)
    if state.active and len(shard_states) != spec.mapper.shard_count:
      # Some shards were lost
      logging.error("Incorrect number of shard states: %d vs %d; "
                    "aborting job '%s'",
                    len(shard_states), spec.mapper.shard_count,
                    spec.mapreduce_id)
      state.active = False
      state.result_status = model.MapreduceState.RESULT_FAILED
      model.MapreduceControl.abort(spec.mapreduce_id)

    active_shards = [s for s in shard_states if s.active]
    failed_shards = [s for s in shard_states
                     if s.result_status == model.ShardState.RESULT_FAILED]
    aborted_shards = [s for s in shard_states
                     if s.result_status == model.ShardState.RESULT_ABORTED]
    if state.active:
      state.active = bool(active_shards)
      state.active_shards = len(active_shards)
      state.failed_shards = len(failed_shards)
      state.aborted_shards = len(aborted_shards)

    if (not state.active and control and
        control.command == model.MapreduceControl.ABORT):
      # User-initiated abort *after* all shards have completed.
      logging.info("Abort signal received for job '%s'", spec.mapreduce_id)
      state.result_status = model.MapreduceState.RESULT_ABORTED

    if not state.active:
      state.active_shards = 0
      if not state.result_status:
        # Set final result status derived from shard states.
        if [s for s in shard_states
            if s.result_status != model.ShardState.RESULT_SUCCESS]:
          state.result_status = model.MapreduceState.RESULT_FAILED
        else:
          state.result_status = model.MapreduceState.RESULT_SUCCESS
        logging.info("Final result for job '%s' is '%s'",
                     spec.mapreduce_id, state.result_status)

    # We don't need a transaction here, since we change only statistics data,
    # and we don't care if it gets overwritten/slightly inconsistent.
    self.aggregate_state(state, shard_states)
    poll_time = state.last_poll_time
    state.last_poll_time = datetime.datetime.utcfromtimestamp(self._time())

    if not state.active:
      # This is the last execution.
      # Enqueue done_callback if needed.
      def put_state(state):
        state.put()
        done_callback = spec.params.get(
            model.MapreduceSpec.PARAM_DONE_CALLBACK)
        if done_callback:
          taskqueue.Task(
              url=done_callback,
              headers={"Mapreduce-Id": spec.mapreduce_id}).add(
                  spec.params.get(
                      model.MapreduceSpec.PARAM_DONE_CALLBACK_QUEUE,
                      "default"),
                  transactional=True)
      db.run_in_transaction(put_state, state)
      return
    else:
      state.put()

    processing_rate = int(spec.mapper.params.get(
        "processing_rate") or model._DEFAULT_PROCESSING_RATE_PER_SEC)
    self.refill_quotas(poll_time, processing_rate, active_shards)
    ControllerCallbackHandler.reschedule(
        self.base_path(), spec, self.serial_id() + 1)

  def aggregate_state(self, mapreduce_state, shard_states):
    """Update current mapreduce state by aggregating shard states.

    Args:
      mapreduce_state: current mapreduce state as MapreduceState.
      shard_states: all shard states (active and inactive). list of ShardState.
    """
    processed_counts = []
    mapreduce_state.counters_map.clear()

    for shard_state in shard_states:
      mapreduce_state.counters_map.add_map(shard_state.counters_map)
      processed_counts.append(shard_state.counters_map.get(
          context.COUNTER_MAPPER_CALLS))

    mapreduce_state.set_processed_counts(processed_counts)

  def refill_quotas(self,
                    last_poll_time,
                    processing_rate,
                    active_shard_states):
    """Refill quotas for all active shards.

    Args:
      last_poll_time: Datetime with the last time the job state was updated.
      processing_rate: How many items to process per second overall.
      active_shard_states: All active shard states, list of ShardState.
    """
    if not active_shard_states:
      return
    quota_manager = quota.QuotaManager(memcache.Client())

    current_time = int(self._time())
    last_poll_time = time.mktime(last_poll_time.timetuple())
    total_quota_refill = processing_rate * max(0, current_time - last_poll_time)
    quota_refill = int(math.ceil(
        1.0 * total_quota_refill / len(active_shard_states)))

    if not quota_refill:
      return

    # TODO(user): use batch memcache API to refill quota in one API call.
    for shard_state in active_shard_states:
      quota_manager.put(shard_state.shard_id, quota_refill)

  def serial_id(self):
    """Get serial unique identifier of this task from request.

    Returns:
      serial identifier as int.
    """
    return int(self.request.get("serial_id"))

  @staticmethod
  def get_task_name(mapreduce_spec, serial_id):
    """Compute single controller task name.

    Args:
      mapreduce_spec: specification of the mapreduce.
      serial_id: id of the invocation as int.

    Returns:
      task name which should be used to process specified shard/slice.
    """
    # Prefix the task name with something unique to this framework's
    # namespace so we don't conflict with user tasks on the queue.
    return "appengine-mrcontrol-%s-%s" % (
        mapreduce_spec.mapreduce_id, serial_id)

  @staticmethod
  def controller_parameters(mapreduce_spec, serial_id):
    """Fill in  controller task parameters.

    Returned parameters map is to be used as task payload, and it contains
    all the data, required by controller to perform its function.

    Args:
      mapreduce_spec: specification of the mapreduce.
      serial_id: id of the invocation as int.

    Returns:
      string->string map of parameters to be used as task payload.
    """
    return {"mapreduce_spec": mapreduce_spec.to_json_str(),
            "serial_id": str(serial_id)}

  @classmethod
  def reschedule(cls, base_path, mapreduce_spec, serial_id, queue_name=None):
    """Schedule new update status callback task.

    Args:
      base_path: mapreduce handlers url base path as string.
      mapreduce_spec: mapreduce specification as MapreduceSpec.
      serial_id: id of the invocation as int.
      queue_name: The queue to schedule this task on. Will use the current
        queue of execution if not supplied.
    """
    task_name = ControllerCallbackHandler.get_task_name(
        mapreduce_spec, serial_id)
    task_params = ControllerCallbackHandler.controller_parameters(
        mapreduce_spec, serial_id)
    if not queue_name:
      queue_name = os.environ.get("HTTP_X_APPENGINE_QUEUENAME", "default")

    try:
      taskqueue.Task(url=base_path + "/controller_callback",
                     name=task_name, params=task_params,
                     countdown=_CONTROLLER_PERIOD_SEC).add(queue_name)
    except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError), e:
      logging.warning("Task %r with params %r already exists. %s: %s",
                      task_name, task_params, e.__class__, e)


class KickOffJobHandler(base_handler.BaseHandler):
  """Taskqueue handler which kicks off a mapreduce processing.

  Request Parameters:
    mapreduce_spec: MapreduceSpec of the mapreduce serialized to json.
    input_readers: List of InputReaders objects separated by semi-colons.
  """

  def post(self):
    """Handles kick off request."""
    spec = model.MapreduceSpec.from_json_str(
        self._get_required_param("mapreduce_spec"))
    input_readers_json = simplejson.loads(
        self._get_required_param("input_readers"))

    queue_name = os.environ.get("HTTP_X_APPENGINE_QUEUENAME", "default")

    mapper_input_reader_class = spec.mapper.input_reader_class()
    input_readers = [mapper_input_reader_class.from_json_str(reader_json)
                     for reader_json in input_readers_json]

    KickOffJobHandler._schedule_shards(
        spec, input_readers, queue_name, self.base_path())

    ControllerCallbackHandler.reschedule(
        self.base_path(), spec, queue_name=queue_name, serial_id=0)

  def _get_required_param(self, param_name):
    """Get a required request parameter.

    Args:
      param_name: name of request parameter to fetch.

    Returns:
      parameter value

    Raises:
      NotEnoughArgumentsError: if parameter is not specified.
    """
    value = self.request.get(param_name)
    if not value:
      raise NotEnoughArgumentsError(param_name + " not specified")
    return value

  @classmethod
  def _schedule_shards(cls, spec, input_readers, queue_name, base_path):
    """Prepares shard states and schedules their execution.

    Args:
      spec: mapreduce specification as MapreduceSpec.
      input_readers: list of InputReaders describing shard splits.
      queue_name: The queue to run this job on.
      base_path: The base url path of mapreduce callbacks.
    """
    # Note: it's safe to re-attempt this handler because:
    # - shard state has deterministic and unique key.
    # - schedule_slice will fall back gracefully if a task already exists.
    shard_states = []
    for shard_number, input_reader in enumerate(input_readers):
      shard = model.ShardState.create_new(spec.mapreduce_id, shard_number)
      shard.shard_description = str(input_reader)
      shard_states.append(shard)

    # Retrievs already existing shards.
    existing_shard_states = db.get(shard.key() for shard in shard_states)
    existing_shard_keys = set(shard.key() for shard in existing_shard_states
                              if shard is not None)

    # Puts only non-existing shards.
    db.put(shard for shard in shard_states
           if shard.key() not in existing_shard_keys)

    for shard_number, input_reader in enumerate(input_readers):
      shard_id = model.ShardState.shard_id_from_number(
          spec.mapreduce_id, shard_number)
      MapperWorkerCallbackHandler.schedule_slice(
          base_path, spec, shard_id, 0, input_reader, queue_name=queue_name)


class StartJobHandler(base_handler.JsonHandler):
  """Command handler starts a mapreduce job."""

  def handle(self):
    """Handles start request."""
    # Mapper spec as form arguments.
    mapreduce_name = self._get_required_param("name")
    mapper_input_reader_spec = self._get_required_param("mapper_input_reader")
    mapper_handler_spec = self._get_required_param("mapper_handler")
    mapper_params = self._get_params(
        "mapper_params_validator", "mapper_params.")
    params = self._get_params(
        "params_validator", "params.")

    # Set some mapper param defaults if not present.
    mapper_params["processing_rate"] = int(mapper_params.get(
          "processing_rate") or model._DEFAULT_PROCESSING_RATE_PER_SEC)
    queue_name = mapper_params["queue_name"] = mapper_params.get(
        "queue_name", "default")

    # Validate the Mapper spec, handler, and input reader.
    mapper_spec = model.MapperSpec(
        mapper_handler_spec,
        mapper_input_reader_spec,
        mapper_params,
        int(mapper_params.get("shard_count", model._DEFAULT_SHARD_COUNT)))

    mapreduce_id = type(self)._start_map(
        mapreduce_name,
        mapper_spec,
        params,
        base_path=self.base_path(),
        queue_name=queue_name,
        _app=mapper_params.get("_app"))
    self.json_response["mapreduce_id"] = mapreduce_id

  def _get_params(self, validator_parameter, name_prefix):
    """Retrieves additional user-supplied params for the job and validates them.

    Args:
      validator_parameter: name of the request parameter which supplies
        validator for this parameter set.
      name_prefix: common prefix for all parameter names in the request.

    Raises:
      Any exception raised by the 'params_validator' request parameter if
      the params fail to validate.
    """
    params_validator = self.request.get(validator_parameter)

    user_params = {}
    for key in self.request.arguments():
      if key.startswith(name_prefix):
        values = self.request.get_all(key)
        adjusted_key = key[len(name_prefix):]
        if len(values) == 1:
          user_params[adjusted_key] = values[0]
        else:
          user_params[adjusted_key] = values

    if params_validator:
      resolved_validator = util.for_name(params_validator)
      resolved_validator(user_params)

    return user_params

  def _get_required_param(self, param_name):
    """Get a required request parameter.

    Args:
      param_name: name of request parameter to fetch.

    Returns:
      parameter value

    Raises:
      NotEnoughArgumentsError: if parameter is not specified.
    """
    value = self.request.get(param_name)
    if not value:
      raise NotEnoughArgumentsError(param_name + " not specified")
    return value

  @classmethod
  def _start_map(cls, name, mapper_spec,
                 mapreduce_params,
                 base_path="/mapreduce",
                 queue_name="default",
                 eta=None,
                 countdown=None,
                 _app=None):
    # Check that handler can be instantiated.
    mapper_spec.get_handler()

    mapper_input_reader_class = mapper_spec.input_reader_class()
    mapper_input_readers = mapper_input_reader_class.split_input(mapper_spec)
    if not mapper_input_readers:
      raise NoDataError("Found no mapper input readers to process.")
    mapper_spec.shard_count = len(mapper_input_readers)

    state = model.MapreduceState.create_new()
    mapreduce_spec = model.MapreduceSpec(
        name,
        state.key().id_or_name(),
        mapper_spec.to_json(),
        mapreduce_params)
    state.mapreduce_spec = mapreduce_spec
    state.active = True
    state.active_shards = mapper_spec.shard_count
    if _app:
      state.app_id = _app

    # TODO(user): Initialize UI fields correctly.
    state.char_url = ""
    state.sparkline_url = ""

    def schedule_mapreduce(state, mapper_input_readers, eta, countdown):
      state.put()
      readers_json = [reader.to_json_str() for reader in mapper_input_readers]
      taskqueue.Task(
          url=base_path + "/kickoffjob_callback",
          params={"mapreduce_spec": state.mapreduce_spec.to_json_str(),
                  "input_readers": simplejson.dumps(readers_json)},
          eta=eta, countdown=countdown).add(queue_name, transactional=True)

    # Point of no return: We're actually going to run this job!
    db.run_in_transaction(
        schedule_mapreduce, state, mapper_input_readers, eta, countdown)

    return state.key().id_or_name()


class CleanUpJobHandler(base_handler.JsonHandler):
  """Command to kick off tasks to clean up a job's data."""

  def handle(self):
    # TODO(user): Have this kick off a task to clean up all MapreduceState,
    # ShardState, and MapreduceControl entities for a job ID.
    self.json_response["status"] = "This does nothing yet."


class AbortJobHandler(base_handler.JsonHandler):
  """Command to abort a running job."""

  def handle(self):
    model.MapreduceControl.abort(self.request.get("mapreduce_id"))
    self.json_response["status"] = "Abort signal sent."

########NEW FILE########
__FILENAME__ = input_readers
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Defines input readers for MapReduce."""



# pylint: disable-msg=C6409

import logging
import math
import StringIO
import zipfile

from google.appengine.api import datastore

from mapreduce.lib import blobstore
from google.appengine.ext import db
from mapreduce.lib import key_range
from mapreduce import util
from mapreduce.model import JsonMixin


class Error(Exception):
  """Base-class for exceptions in this module."""


class BadReaderParamsError(Error):
  """The input parameters to a reader were invalid."""


class InputReader(JsonMixin):
  """Abstract base class for input readers.

  InputReaders have the following properties:
   * They are created by using the split_input method to generate a set of
     InputReaders from a MapperSpec.
   * They generate inputs to the mapper via the iterator interface.
   * After creation, they can be serialized and resumed using the JsonMixin
     interface.
   * They are cast to string for a user-readable description; it may be
     valuable to implement __str__.
  """

  # Mapreduce parameters.
  _APP_PARAM = "_app"
  MAPPER_PARAMS = "mapper_params"

  def __iter__(self):
    return self

  def next(self):
    """Returns the next input from this input reader as a key, value pair.

    Returns:
      The next input from this input reader.
    """
    raise NotImplementedError

  @classmethod
  def from_json(cls, input_shard_state):
    """Creates an instance of the InputReader for the given input shard state.

    Args:
      input_shard_state: The InputReader state as a dict-like object.

    Returns:
      An instance of the InputReader configured using the values of json.
    """
    raise NotImplementedError

  def to_json(self):
    """Returns an input shard state for the remaining inputs.

    Returns:
      A json-izable version of the remaining InputReader.
    """
    raise NotImplementedError

  @classmethod
  def split_input(cls, mapper_spec):
    """Returns a list of input readers for the input spec.

    Args:
      mapper_spec: The MapperSpec for this InputReader.

    Returns:
      A list of InputReaders.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    raise NotImplementedError


# TODO(user): Use cursor API as soon as we have it available.
class DatastoreInputReader(InputReader):
  """Represents a range in query results.

  DatastoreInputReader yields model instances from the entities in a given key
  range. Iterating over DatastoreInputReader changes its range past consumed
  entries.

  The class shouldn't be instantiated directly. Use the split_input class method
  instead.
  """

  # Number of entities to fetch at once while doing scanning.
  _BATCH_SIZE = 50

  # Maximum number of shards we'll create.
  _MAX_SHARD_COUNT = 256

  # Mapreduce parameters.
  ENTITY_KIND_PARAM = "entity_kind"
  KEYS_ONLY_PARAM = "keys_only"
  BATCH_SIZE_PARAM = "batch_size"
  KEY_RANGE_PARAM = "key_range"

  # TODO(user): Add support for arbitrary queries. It's not possible to
  # support them without cursors since right now you can't even serialize query
  # definition.
  def __init__(self, entity_kind, key_range_param, mapper_params):
    """Create new DatastoreInputReader object.

    This is internal constructor. Use split_query instead.

    Args:
      entity_kind: entity kind as string.
      key_range_param: key range to process as key_range.KeyRange.
      mapper_params: mapper parameters as defined by user.
    """
    self._entity_kind = entity_kind
    self._key_range = key_range_param
    self._mapper_params = mapper_params
    self._batch_size = int(self._mapper_params.get(
        self.BATCH_SIZE_PARAM, self._BATCH_SIZE))

  def __iter__(self):
    """Create a generator for model instances for entities.

    Iterating through entities moves query range past the consumed entities.

    Yields:
      next model instance.
    """
    while True:
      query = self._key_range.make_ascending_query(
          util.for_name(self._entity_kind))
      results = query.fetch(limit=self._batch_size)

      if not results:
        break

      for model_instance in results:
        key = model_instance.key()

        self._key_range.advance(key)
        yield model_instance

  # TODO(user): use query splitting functionality when it becomes available
  # instead.
  @classmethod
  def _split_input_from_params(cls, app, entity_kind_name,
                               params, shard_count):
    """Return input reader objects. Helper for split_input."""

    raw_entity_kind = util.get_short_name(entity_kind_name)

    # we use datastore.Query instead of ext.db.Query here, because we can't
    # erase ordering on db.Query once we set it.
    ds_query = datastore.Query(kind=raw_entity_kind, _app=app, keys_only=True)
    ds_query.Order("__key__")
    first_entity_key_list = ds_query.Get(1)
    if not first_entity_key_list:
      return []
    first_entity_key = first_entity_key_list[0]
    ds_query.Order(("__key__", datastore.Query.DESCENDING))
    try:
      last_entity_key, = ds_query.Get(1)
    except db.NeedIndexError, e:
      # TODO(user): Show this error in the worker log, not the app logs.
      logging.warning("Cannot create accurate approximation of keyspace, "
                      "guessing instead. Please address this problem: %s", e)
      # TODO(user): Use a key-end hint from the user input parameters
      # in this case, in the event the user has a good way of figuring out
      # the range of the keyspace.
      last_entity_key = key_range.KeyRange.guess_end_key(raw_entity_kind,
                                                         first_entity_key)
    full_keyrange = key_range.KeyRange(
        first_entity_key, last_entity_key, None, True, True, _app=app)
    key_ranges = [full_keyrange]
    number_of_half_splits = int(math.floor(math.log(shard_count, 2)))
    for _ in range(0, number_of_half_splits):
      new_ranges = []
      for r in key_ranges:
        new_ranges += r.split_range(1)
      key_ranges = new_ranges
    return [cls(entity_kind_name, r, params) for r in key_ranges]

  @classmethod
  def split_input(cls, mapper_spec):
    """Splits query into shards without fetching query results.

    Tries as best as it can to split the whole query result set into equal
    shards. Due to difficulty of making the perfect split, resulting shards'
    sizes might differ significantly from each other. The actual number of
    shards might also be less then requested (even 1), though it is never
    greater.

    Current implementation does key-lexicographic order splitting. It requires
    query not to specify any __key__-based ordering. If an index for
    query.order('-__key__') query is not present, an inaccurate guess at
    sharding will be made by splitting the full key range.

    Args:
      mapper_spec: MapperSpec with params containing 'entity_kind'.
        May also have 'batch_size' in the params to specify the number
        of entities to process in each batch.

    Returns:
      A list of InputReader objects of length <= number_of_shards. These
      may be DatastoreInputReader or DatastoreKeyInputReader objects.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Input reader class mismatch")
    params = mapper_spec.params
    if cls.ENTITY_KIND_PARAM not in params:
      raise BadReaderParamsError("Missing mapper parameter 'entity_kind'")

    entity_kind_name = params[cls.ENTITY_KIND_PARAM]
    shard_count = mapper_spec.shard_count
    app = params.get(cls._APP_PARAM)
    # keys_only remains for backwards compatability. It may go away.
    keys_only = util.parse_bool(params.get(cls.KEYS_ONLY_PARAM, False))

    if keys_only:
      raise BadReaderParamsError("The keys_only parameter is obsolete. "
                                 "Use DatastoreKeyInputReader instead.")

    # Fail fast if Model cannot be located.
    util.for_name(entity_kind_name)

    return cls._split_input_from_params(
        app, entity_kind_name, params, shard_count)

  def to_json(self):
    """Serializes all the data in this query range into json form.

    Returns:
      all the data in json-compatible map.
    """
    json_dict = {self.KEY_RANGE_PARAM: self._key_range.to_json(),
                 self.ENTITY_KIND_PARAM: self._entity_kind,
                 self.MAPPER_PARAMS: self._mapper_params}
    return json_dict

  def __str__(self):
    """Returns the string representation of this DatastoreInputReader."""
    return repr(self._key_range)

  @classmethod
  def from_json(cls, json):
    """Create new DatastoreInputReader from the json, encoded by to_json.

    Args:
      json: json map representation of DatastoreInputReader.

    Returns:
      an instance of DatastoreInputReader with all data deserialized from json.
    """
    query_range = cls(json[cls.ENTITY_KIND_PARAM],
                      key_range.KeyRange.from_json(json[cls.KEY_RANGE_PARAM]),
                      json[cls.MAPPER_PARAMS])
    return query_range


class DatastoreKeyInputReader(DatastoreInputReader):
  """An input reader which takes a Kind and yields Keys for that kind."""

  def __iter__(self):
    """Create a generator for keys in the range.

    Iterating through entries moves query range past the consumed entries.

    Yields:
      next entry.
    """
    while True:
      raw_entity_kind = util.get_short_name(self._entity_kind)
      query = self._key_range.make_ascending_datastore_query(
          raw_entity_kind, keys_only=True)
      results = query.Get(limit=self._batch_size)

      if not results:
        break

      for key in results:
        self._key_range.advance(key)
        yield key

  @classmethod
  def split_input(cls, mapper_spec):
    """Splits query into shards without fetching query results.

    Tries as best as it can to split the whole query result set into equal
    shards. Due to difficulty of making the perfect split, resulting shards'
    sizes might differ significantly from each other. The actual number of
    shards might also be less then requested (even 1), though it is never
    greater.

    Current implementation does key-lexicographic order splitting. It requires
    query not to specify any __key__-based ordering. If an index for
    query.order('-__key__') query is not present, an inaccurate guess at
    sharding will be made by splitting the full key range.

    Args:
      mapper_spec: MapperSpec with params containing 'entity_kind'.
        May also have 'batch_size' in the params to specify the number
        of entities to process in each batch.

    Returns:
      A list of DatastoreKeyInputReader objects of length <= number_of_shards.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Input reader class mismatch")
    params = mapper_spec.params
    if cls.ENTITY_KIND_PARAM not in params:
      raise BadReaderParamsError("Missing mapper parameter 'entity_kind'")

    entity_kind_name = params[cls.ENTITY_KIND_PARAM]
    shard_count = mapper_spec.shard_count
    app = params.get(cls._APP_PARAM)

    return cls._split_input_from_params(
        app, entity_kind_name, params, shard_count)


class DatastoreEntityInputReader(DatastoreInputReader):
  """An input reader which yields low level datastore entities for a kind."""

  def __iter__(self):
    """Create a generator for low level entities in the range.

    Iterating through entries moves query range past the consumed entries.

    Yields:
      next entry.
    """
    while True:
      raw_entity_kind = util.get_short_name(self._entity_kind)
      query = self._key_range.make_ascending_datastore_query(raw_entity_kind)
      results = query.Get(limit=self._batch_size)

      if not results:
        break

      for entity in results:
        self._key_range.advance(entity.key())
        yield entity

  @classmethod
  def split_input(cls, mapper_spec):
    """Splits query into shards without fetching query results.

    Tries as best as it can to split the whole query result set into equal
    shards. Due to difficulty of making the perfect split, resulting shards'
    sizes might differ significantly from each other. The actual number of
    shards might also be less then requested (even 1), though it is never
    greater.

    Current implementation does key-lexicographic order splitting. It requires
    query not to specify any __key__-based ordering. If an index for
    query.order('-__key__') query is not present, an inaccurate guess at
    sharding will be made by splitting the full key range.

    Args:
      mapper_spec: MapperSpec with params containing 'entity_kind'.
        May also have 'batch_size' in the params to specify the number
        of entities to process in each batch.

    Returns:
      List of DatastoreEntityInputReader objects of length <= number_of_shards.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Input reader class mismatch")
    params = mapper_spec.params
    if cls.ENTITY_KIND_PARAM not in params:
      raise BadReaderParamsError("Missing mapper parameter 'entity_kind'")

    entity_kind_name = params[cls.ENTITY_KIND_PARAM]
    shard_count = mapper_spec.shard_count
    app = params.get(cls._APP_PARAM)

    return cls._split_input_from_params(
        app, entity_kind_name, params, shard_count)


class BlobstoreLineInputReader(InputReader):
  """Input reader for a newline delimited blob in Blobstore."""

  # TODO(user): Should we set this based on MAX_BLOB_FETCH_SIZE?
  _BLOB_BUFFER_SIZE = 64000

  # Maximum number of shards to allow.
  _MAX_SHARD_COUNT = 256

  # Maximum number of blobs to allow.
  _MAX_BLOB_KEYS_COUNT = 246

  # Mapreduce parameters.
  BLOB_KEYS_PARAM = "blob_keys"

  # Serialization parmaeters.
  INITIAL_POSITION_PARAM = "initial_position"
  END_POSITION_PARAM = "end_position"
  BLOB_KEY_PARAM = "blob_key"

  def __init__(self, blob_key, start_position, end_position):
    """Initializes this instance with the given blob key and character range.

    This BlobstoreInputReader will read from the first record starting after
    strictly after start_position until the first record ending at or after
    end_position (exclusive). As an exception, if start_position is 0, then
    this InputReader starts reading at the first record.

    Args:
      blob_key: the BlobKey that this input reader is processing.
      start_position: the position to start reading at.
      end_position: a position in the last record to read.
    """
    self._blob_key = blob_key
    self._blob_reader = blobstore.BlobReader(blob_key,
                                             self._BLOB_BUFFER_SIZE,
                                             start_position)
    self._end_position = end_position
    self._has_iterated = False
    self._read_before_start = bool(start_position)

  def next(self):
    """Returns the next input from as an (offset, line) tuple."""
    self._has_iterated = True

    if self._read_before_start:
      self._blob_reader.readline()
      self._read_before_start = False
    start_position = self._blob_reader.tell()

    if start_position >= self._end_position:
      raise StopIteration()

    line = self._blob_reader.readline()

    if not line:
      raise StopIteration()

    return start_position, line.rstrip("\n")

  def to_json(self):
    """Returns an json-compatible input shard spec for remaining inputs."""
    new_pos = self._blob_reader.tell()
    if self._has_iterated:
      new_pos -= 1
    return {self.BLOB_KEY_PARAM: self._blob_key,
            self.INITIAL_POSITION_PARAM: new_pos,
            self.END_POSITION_PARAM: self._end_position}

  def __str__(self):
    """Returns the string representation of this BlobstoreLineInputReader."""
    return "blobstore.BlobKey(%r):[%d, %d]" % (
        self._blob_key, self._blob_reader.tell(), self._end_position)

  @classmethod
  def from_json(cls, json):
    """Instantiates an instance of this InputReader for the given shard spec."""
    return cls(json[cls.BLOB_KEY_PARAM],
               json[cls.INITIAL_POSITION_PARAM],
               json[cls.END_POSITION_PARAM])

  @classmethod
  def split_input(cls, mapper_spec):
    """Returns a list of shard_count input_spec_shards for input_spec.

    Args:
      mapper_spec: The mapper specification to split from. Must contain
          'blob_keys' parameter with one or more blob keys.

    Returns:
      A list of BlobstoreInputReaders corresponding to the specified shards.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Mapper input reader class mismatch")
    params = mapper_spec.params
    if cls.BLOB_KEYS_PARAM not in params:
      raise BadReaderParamsError("Must specify 'blob_keys' for mapper input")

    blob_keys = params[cls.BLOB_KEYS_PARAM]
    if isinstance(blob_keys, basestring):
      # This is a mechanism to allow multiple blob keys (which do not contain
      # commas) in a single string. It may go away.
      blob_keys = blob_keys.split(",")
    if len(blob_keys) > cls._MAX_BLOB_KEYS_COUNT:
      raise BadReaderParamsError("Too many 'blob_keys' for mapper input")
    if not blob_keys:
      raise BadReaderParamsError("No 'blob_keys' specified for mapper input")

    blob_sizes = {}
    for blob_key in blob_keys:
      blob_info = blobstore.BlobInfo.get(blobstore.BlobKey(blob_key))
      blob_sizes[blob_key] = blob_info.size

    shard_count = min(cls._MAX_SHARD_COUNT, mapper_spec.shard_count)
    shards_per_blob = shard_count // len(blob_keys)
    if shards_per_blob == 0:
      shards_per_blob = 1

    chunks = []
    for blob_key, blob_size in blob_sizes.items():
      blob_chunk_size = blob_size // shards_per_blob
      for i in xrange(shards_per_blob - 1):
        chunks.append(BlobstoreLineInputReader.from_json(
            {cls.BLOB_KEY_PARAM: blob_key,
             cls.INITIAL_POSITION_PARAM: blob_chunk_size * i,
             cls.END_POSITION_PARAM: blob_chunk_size * (i + 1)}))
      chunks.append(BlobstoreLineInputReader.from_json(
          {cls.BLOB_KEY_PARAM: blob_key,
           cls.INITIAL_POSITION_PARAM: blob_chunk_size * (shards_per_blob - 1),
           cls.END_POSITION_PARAM: blob_size}))
    return chunks


class BlobstoreZipInputReader(InputReader):
  """Input reader for files from a zip archive stored in the Blobstore.

  Each instance of the reader will read the TOC, from the end of the zip file,
  and then only the contained files which it is responsible for.
  """

  # Maximum number of shards to allow.
  _MAX_SHARD_COUNT = 256

  # Mapreduce parameters.
  BLOB_KEY_PARAM = "blob_key"
  START_INDEX_PARAM = "start_index"
  END_INDEX_PARAM = "end_index"

  def __init__(self, blob_key, start_index, end_index,
               _reader=blobstore.BlobReader):
    """Initializes this instance with the given blob key and file range.

    This BlobstoreZipInputReader will read from the file with index start_index
    up to but not including the file with index end_index.

    Args:
      blob_key: the BlobKey that this input reader is processing.
      start_index: the index of the first file to read.
      end_index: the index of the first file that will not be read.
      _reader: a callable that returns a file-like object for reading blobs.
          Used for dependency injection.
    """
    self._blob_key = blob_key
    self._start_index = start_index
    self._end_index = end_index
    self._reader = _reader
    self._zip = None
    self._entries = None

  def next(self):
    """Returns the next input from this input reader as (ZipInfo, opener) tuple.

    Returns:
      The next input from this input reader, in the form of a 2-tuple.
      The first element of the tuple is a zipfile.ZipInfo object.
      The second element of the tuple is a zero-argument function that, when
      called, returns the complete body of the file.
    """
    if not self._zip:
      self._zip = zipfile.ZipFile(self._reader(self._blob_key))
      # Get a list of entries, reversed so we can pop entries off in order
      self._entries = self._zip.infolist()[self._start_index:self._end_index]
      self._entries.reverse()
    if not self._entries:
      raise StopIteration()
    entry = self._entries.pop()
    self._start_index += 1
    return (entry, lambda: self._zip.read(entry.filename))

  @classmethod
  def from_json(cls, json):
    """Creates an instance of the InputReader for the given input shard state.

    Args:
      json: The InputReader state as a dict-like object.

    Returns:
      An instance of the InputReader configured using the values of json.
    """
    return cls(json[cls.BLOB_KEY_PARAM],
               json[cls.START_INDEX_PARAM],
               json[cls.END_INDEX_PARAM])

  def to_json(self):
    """Returns an input shard state for the remaining inputs.

    Returns:
      A json-izable version of the remaining InputReader.
    """
    return {self.BLOB_KEY_PARAM: self._blob_key,
            self.START_INDEX_PARAM: self._start_index,
            self.END_INDEX_PARAM: self._end_index}

  def __str__(self):
    """Returns the string representation of this BlobstoreZipInputReader."""
    return "blobstore.BlobKey(%r):[%d, %d]" % (
        self._blob_key, self._start_index, self._end_index)

  @classmethod
  def split_input(cls, mapper_spec, _reader=blobstore.BlobReader):
    """Returns a list of input shard states for the input spec.

    Args:
      mapper_spec: The MapperSpec for this InputReader. Must contain
          'blob_key' parameter with one blob key.
      _reader: a callable that returns a file-like object for reading blobs.
          Used for dependency injection.

    Returns:
      A list of InputReaders spanning files within the zip.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Mapper input reader class mismatch")
    params = mapper_spec.params
    if cls.BLOB_KEY_PARAM not in params:
      raise BadReaderParamsError("Must specify 'blob_key' for mapper input")

    blob_key = params[cls.BLOB_KEY_PARAM]
    zip_input = zipfile.ZipFile(_reader(blob_key))
    files = zip_input.infolist()
    total_size = sum(x.file_size for x in files)
    num_shards = min(mapper_spec.shard_count, cls._MAX_SHARD_COUNT)
    size_per_shard = total_size // num_shards

    # Break the list of files into sublists, each of approximately
    # size_per_shard bytes.
    shard_start_indexes = [0]
    current_shard_size = 0
    for i, fileinfo in enumerate(files):
      current_shard_size += fileinfo.file_size
      if current_shard_size >= size_per_shard:
        shard_start_indexes.append(i + 1)
        current_shard_size = 0

    if shard_start_indexes[-1] != len(files):
      shard_start_indexes.append(len(files))

    return [cls(blob_key, start_index, end_index, _reader)
            for start_index, end_index
            in zip(shard_start_indexes, shard_start_indexes[1:])]


class BlobstoreZipLineInputReader(InputReader):
  """Input reader for newline delimited files in zip archives from  Blobstore.

  This has the same external interface as the BlobstoreLineInputReader, in that
  it takes a list of blobs as its input and yields lines to the reader.
  However the blobs themselves are expected to be zip archives of line delimited
  files instead of the files themselves.

  This is useful as many line delimited files gain greatly from compression.
  """

  # Maximum number of shards to allow.
  _MAX_SHARD_COUNT = 256

  # Maximum number of blobs to allow.
  _MAX_BLOB_KEYS_COUNT = 246

  # Mapreduce parameters.
  BLOB_KEYS_PARAM = "blob_keys"

  # Serialization parameters.
  BLOB_KEY_PARAM = "blob_key"
  START_FILE_INDEX_PARAM = "start_file_index"
  END_FILE_INDEX_PARAM = "end_file_index"
  OFFSET_PARAM = "offset"

  def __init__(self, blob_key, start_file_index, end_file_index, offset,
               _reader=blobstore.BlobReader):
    """Initializes this instance with the given blob key and file range.

    This BlobstoreZipLineInputReader will read from the file with index
    start_file_index up to but not including the file with index end_file_index.
    It will return lines starting at offset within file[start_file_index]

    Args:
      blob_key: the BlobKey that this input reader is processing.
      start_file_index: the index of the first file to read within the zip.
      end_file_index: the index of the first file that will not be read.
      offset: the byte offset within blob_key.zip[start_file_index] to start
        reading. The reader will continue to the end of the file.
      _reader: a callable that returns a file-like object for reading blobs.
          Used for dependency injection.
    """
    self._blob_key = blob_key
    self._start_file_index = start_file_index
    self._end_file_index = end_file_index
    self._initial_offset = offset
    self._reader = _reader
    self._zip = None
    self._entries = None
    self._filestream = None

  @classmethod
  def split_input(cls, mapper_spec, _reader=blobstore.BlobReader):
    """Returns a list of input readers for the input spec.

    Args:
      mapper_spec: The MapperSpec for this InputReader. Must contain
          'blob_keys' parameter with one or more blob keys.
      _reader: a callable that returns a file-like object for reading blobs.
          Used for dependency injection.

    Returns:
      A list of InputReaders spanning the subfiles within the blobs.
      There will be at least one reader per blob, but it will otherwise
      attempt to keep the expanded size even.

    Raises:
      BadReaderParamsError: required parameters are missing or invalid.
    """
    if mapper_spec.input_reader_class() != cls:
      raise BadReaderParamsError("Mapper input reader class mismatch")
    params = mapper_spec.params
    if cls.BLOB_KEYS_PARAM not in params:
      raise BadReaderParamsError("Must specify 'blob_key' for mapper input")

    blob_keys = params[cls.BLOB_KEYS_PARAM]
    if isinstance(blob_keys, basestring):
      # This is a mechanism to allow multiple blob keys (which do not contain
      # commas) in a single string. It may go away.
      blob_keys = blob_keys.split(",")
    if len(blob_keys) > cls._MAX_BLOB_KEYS_COUNT:
      raise BadReaderParamsError("Too many 'blob_keys' for mapper input")
    if not blob_keys:
      raise BadReaderParamsError("No 'blob_keys' specified for mapper input")

    blob_files = {}
    total_size = 0
    for blob_key in blob_keys:
      zip_input = zipfile.ZipFile(_reader(blob_key))
      blob_files[blob_key] = zip_input.infolist()
      total_size += sum(x.file_size for x in blob_files[blob_key])

    shard_count = min(cls._MAX_SHARD_COUNT, mapper_spec.shard_count)

    # We can break on both blob key and file-within-zip boundaries.
    # A shard will span at minimum a single blob key, but may only
    # handle a few files within a blob.

    size_per_shard = total_size // shard_count

    readers = []
    for blob_key in blob_keys:
      files = blob_files[blob_key]
      current_shard_size = 0
      start_file_index = 0
      next_file_index = 0
      for fileinfo in files:
        next_file_index += 1
        current_shard_size += fileinfo.file_size
        if current_shard_size >= size_per_shard:
          readers.append(cls(blob_key, start_file_index, next_file_index, 0,
                             _reader))
          current_shard_size = 0
          start_file_index = next_file_index
      if current_shard_size != 0:
        readers.append(cls(blob_key, start_file_index, next_file_index, 0,
                           _reader))

    return readers

  def next(self):
    """Returns the next line from this input reader as (lineinfo, line) tuple.

    Returns:
      The next input from this input reader, in the form of a 2-tuple.
      The first element of the tuple describes the source, it is itself
        a tuple (blobkey, filenumber, byteoffset).
      The second element of the tuple is the line found at that offset.
    """
    if not self._filestream:
      if not self._zip:
        self._zip = zipfile.ZipFile(self._reader(self._blob_key))
        # Get a list of entries, reversed so we can pop entries off in order
        self._entries = self._zip.infolist()[self._start_file_index:
                                             self._end_file_index]
        self._entries.reverse()
      if not self._entries:
        raise StopIteration()
      entry = self._entries.pop()
      value = self._zip.read(entry.filename)
      self._filestream = StringIO.StringIO(value)
      if self._initial_offset:
        self._filestream.seek(self._initial_offset)
        self._filestream.readline()

    start_position = self._filestream.tell()
    line = self._filestream.readline()

    if not line:
      # Done with this file in the zip. Move on to the next file.
      self._filestream.close()
      self._filestream = None
      self._start_file_index += 1
      self._initial_offset = 0
      return self.next()

    return ((self._blob_key, self._start_file_index, start_position),
            line.rstrip("\n"))

  def _next_offset(self):
    """Return the offset of the next line to read."""
    if self._filestream:
      offset = self._filestream.tell()
      if offset:
        offset -= 1
    else:
      offset = self._initial_offset

    return offset

  def to_json(self):
    """Returns an input shard state for the remaining inputs.

    Returns:
      A json-izable version of the remaining InputReader.
    """

    return {self.BLOB_KEY_PARAM: self._blob_key,
            self.START_FILE_INDEX_PARAM: self._start_file_index,
            self.END_FILE_INDEX_PARAM: self._end_file_index,
            self.OFFSET_PARAM: self._next_offset()}

  @classmethod
  def from_json(cls, json, _reader=blobstore.BlobReader):
    """Creates an instance of the InputReader for the given input shard state.

    Args:
      json: The InputReader state as a dict-like object.
      _reader: For dependency injection.

    Returns:
      An instance of the InputReader configured using the values of json.
    """
    return cls(json[cls.BLOB_KEY_PARAM],
               json[cls.START_FILE_INDEX_PARAM],
               json[cls.END_FILE_INDEX_PARAM],
               json[cls.OFFSET_PARAM],
               _reader)

  def __str__(self):
    """Returns the string representation of this reader.

    Returns:
      string blobkey:[start file num, end file num]:current offset.
    """
    return "blobstore.BlobKey(%r):[%d, %d]:%d" % (
        self._blob_key, self._start_file_index, self._end_file_index,
        self._next_offset())


########NEW FILE########
__FILENAME__ = blobstore
#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""A Python blobstore API used by app developers.

Contains methods used to interface with Blobstore API.  Includes db.Model-like
class representing a reference to a very large BLOB.  Imports db.Key-like
class representing a blob-key.
"""



import cgi
import email
import os

from google.appengine.api import datastore
from google.appengine.api import datastore_errors
from google.appengine.api import datastore_types
from google.appengine.api.blobstore import blobstore
from google.appengine.ext import db

__all__ = ['BLOB_INFO_KIND',
           'BLOB_KEY_HEADER',
           'BLOB_RANGE_HEADER',
           'BlobFetchSizeTooLargeError',
           'BlobInfo',
           'BlobInfoParseError',
           'BlobKey',
           'BlobNotFoundError',
           'BlobReferenceProperty',
           'BlobReader',
           'DataIndexOutOfRangeError',
           'Error',
           'InternalError',
           'MAX_BLOB_FETCH_SIZE',
           'UPLOAD_INFO_CREATION_HEADER',
           'create_upload_url',
           'delete',
           'fetch_data',
           'get',
           'parse_blob_info']

Error = blobstore.Error
InternalError = blobstore.InternalError
BlobFetchSizeTooLargeError = blobstore.BlobFetchSizeTooLargeError
BlobNotFoundError = blobstore.BlobNotFoundError
_CreationFormatError = blobstore._CreationFormatError
DataIndexOutOfRangeError = blobstore.DataIndexOutOfRangeError

BlobKey = blobstore.BlobKey
create_upload_url = blobstore.create_upload_url
delete = blobstore.delete


class BlobInfoParseError(Error):
  """CGI parameter does not contain valid BlobInfo record."""


BLOB_INFO_KIND = blobstore.BLOB_INFO_KIND
BLOB_KEY_HEADER = blobstore.BLOB_KEY_HEADER
BLOB_RANGE_HEADER = blobstore.BLOB_RANGE_HEADER
MAX_BLOB_FETCH_SIZE = blobstore.MAX_BLOB_FETCH_SIZE
UPLOAD_INFO_CREATION_HEADER = blobstore.UPLOAD_INFO_CREATION_HEADER

class _GqlQuery(db.GqlQuery):
  """GqlQuery class that explicitly sets model-class.

  This does the same as the original db.GqlQuery class except that it does
  not try to find the model class based on the compiled GQL query.  The
  caller instead provides the query with a model class to use for construction.

  This class is required for compatibility with the current db.py query
  mechanism but will be removed in the future.  DO NOT USE.
  """

  def __init__(self, query_string, model_class, *args, **kwds):
    """Constructor.

    Args:
      query_string: Properly formatted GQL query string.
      model_class: Model class from which entities are constructed.
      *args: Positional arguments used to bind numeric references in the query.
      **kwds: Dictionary-based arguments for named references.
    """
    from google.appengine.ext import gql
    app = kwds.pop('_app', None)
    self._proto_query = gql.GQL(query_string, _app=app, namespace='')
    super(db.GqlQuery, self).__init__(model_class, namespace='')
    self.bind(*args, **kwds)


class BlobInfo(object):
  """Information about blobs in Blobstore.

  This is a db.Model-like class that contains information about blobs stored
  by an application.  Like db.Model, this class is backed by an Datastore
  entity, however, BlobInfo instances are read-only and have a much more
  limited interface.

  Each BlobInfo has a key of type BlobKey associated with it. This key is
  specific to the Blobstore API and is not compatible with db.get.  The key
  can be used for quick lookup by passing it to BlobInfo.get.  This
  key converts easily to a string, which is web safe and can be embedded
  in URLs.

  Properties:
    content_type: Content type of blob.
    creation: Creation date of blob, when it was uploaded.
    filename: Filename user selected from their machine.
    size: Size of uncompressed blob.

  All properties are read-only.  Attempting to assign a value to a property
  will raise NotImplementedError.
  """

  _unindexed_properties = frozenset()

  @property
  def content_type(self):
    return self.__get_value('content_type')

  @property
  def creation(self):
    return self.__get_value('creation')

  @property
  def filename(self):
    return self.__get_value('filename')

  @property
  def size(self):
    return self.__get_value('size')

  def __init__(self, entity_or_blob_key, _values=None):
    """Constructor for wrapping blobstore entity.

    The constructor should not be used outside this package and tests.

    Args:
      entity: Datastore entity that represents the blob reference.
    """
    if isinstance(entity_or_blob_key, datastore.Entity):
      self.__entity = entity_or_blob_key
      self.__key = BlobKey(entity_or_blob_key.key().name())
    elif isinstance(entity_or_blob_key, BlobKey):
      self.__entity = _values
      self.__key = entity_or_blob_key
    else:
      TypeError('Must provide Entity or BlobKey')

  @classmethod
  def from_entity(cls, entity):
    """Convert entity to BlobInfo.

    This method is required for compatibility with the current db.py query
    mechanism but will be removed in the future.  DO NOT USE.
    """
    return BlobInfo(entity)

  @classmethod
  def properties(cls):
    """Set of properties that belong to BlobInfo.

    This method is required for compatibility with the current db.py query
    mechanism but will be removed in the future.  DO NOT USE.
    """
    return set(('content_type', 'creation', 'filename', 'size'))

  def __get_value(self, name):
    """Get a BlobInfo value, loading entity if necessary.

    This method allows lazy loading of the underlying datastore entity.  It
    should never be invoked directly.

    Args:
      name: Name of property to get value for.

    Returns:
      Value of BlobInfo property from entity.
    """
    if self.__entity is None:
      self.__entity = datastore.Get(
          datastore_types.Key.from_path(
              self.kind(), str(self.__key), namespace=''))
    try:
      return self.__entity[name]
    except KeyError:
      raise AttributeError(name)


  def key(self):
    """Get key for blob.

    Returns:
      BlobKey instance that identifies this blob.
    """
    return self.__key

  def delete(self):
    """Permanently delete blob from Blobstore."""
    delete(self.key())

  @classmethod
  def get(cls, blob_keys):
    """Retrieve BlobInfo by key or list of keys.

    Args:
      blob_keys: A key or a list of keys.  Keys may be instances of str,
      unicode and BlobKey.

    Returns:
      A BlobInfo instance associated with provided key or a list of BlobInfo
      instances if a list of keys was provided.  Keys that are not found in
      Blobstore return None as their values.
    """
    blob_keys = cls.__normalize_and_convert_keys(blob_keys)
    try:
      entities = datastore.Get(blob_keys)
    except datastore_errors.EntityNotFoundError:
      return None
    if isinstance(entities, datastore.Entity):
      return BlobInfo(entities)
    else:
      references = []
      for entity in entities:
        if entity is not None:
          references.append(BlobInfo(entity))
        else:
          references.append(None)
      return references

  @classmethod
  def all(cls):
    """Get query for all Blobs associated with application.

    Returns:
      A db.Query object querying over BlobInfo's datastore kind.
    """
    return db.Query(model_class=cls, namespace='')

  @classmethod
  def __factory_for_kind(cls, kind):
    if kind == BLOB_INFO_KIND:
      return BlobInfo
    raise ValueError('Cannot query for kind %s' % kind)

  @classmethod
  def gql(cls, query_string, *args, **kwds):
    """Returns a query using GQL query string.

    See appengine/ext/gql for more information about GQL.

    Args:
      query_string: Properly formatted GQL query string with the
        'SELECT * FROM <entity>' part omitted
      *args: rest of the positional arguments used to bind numeric references
        in the query.
      **kwds: dictionary-based arguments (for named parameters).

    Returns:
      A gql.GqlQuery object querying over BlobInfo's datastore kind.
    """
    return _GqlQuery('SELECT * FROM %s %s'
                       % (cls.kind(), query_string),
                     cls,
                     *args,
                     **kwds)

  @classmethod
  def kind(self):
    """Get the entity kind for the BlobInfo.

    This method is required for compatibility with the current db.py query
    mechanism but will be removed in the future.  DO NOT USE.
    """
    return BLOB_INFO_KIND

  @classmethod
  def __normalize_and_convert_keys(cls, keys):
    """Normalize and convert all keys to BlobKey type.

    This method is based on datastore.NormalizeAndTypeCheck().

    Args:
      keys: A single key or a list/tuple of keys.  Keys may be a string
        or BlobKey

    Returns:
      Single key or list with all strings replaced by BlobKey instances.
    """
    if isinstance(keys, (list, tuple)):
      multiple = True
      keys = list(keys)
    else:
      multiple = False
      keys = [keys]

    for index, key in enumerate(keys):
      if not isinstance(key, (basestring, BlobKey)):
        raise datastore_errors.BadArgumentError(
            'Expected str or BlobKey; received %s (a %s)' % (
                key,
                datastore.typename(key)))
      keys[index] = datastore.Key.from_path(cls.kind(), str(key), namespace='')

    if multiple:
      return keys
    else:
      return keys[0]


def get(blob_key):
  """Get a BlobInfo record from blobstore.

  Does the same as BlobInfo.get.
  """
  return BlobInfo.get(blob_key)


def parse_blob_info(field_storage):
  """Parse a BlobInfo record from file upload field_storage.

  Args:
    field_storage: cgi.FieldStorage that represents uploaded blob.

  Returns:
    BlobInfo record as parsed from the field-storage instance.
    None if there was no field_storage.

  Raises:
    BlobInfoParseError when provided field_storage does not contain enough
    information to construct a BlobInfo object.
  """
  if field_storage is None:
    return None

  field_name = field_storage.name

  def get_value(dict, name):
    value = dict.get(name, None)
    if value is None:
      raise BlobInfoParseError(
          'Field %s has no %s.' % (field_name, name))
    return value

  filename = get_value(field_storage.disposition_options, 'filename')
  blob_key = BlobKey(get_value(field_storage.type_options, 'blob-key'))

  upload_content = email.message_from_file(field_storage.file)
  content_type = get_value(upload_content, 'content-type')
  size = get_value(upload_content, 'content-length')
  creation_string = get_value(upload_content, UPLOAD_INFO_CREATION_HEADER)

  try:
    size = int(size)
  except (TypeError, ValueError):
    raise BlobInfoParseError(
        '%s is not a valid value for %s size.' % (size, field_name))

  try:
    creation = blobstore._parse_creation(creation_string, field_name)
  except blobstore._CreationFormatError, err:
    raise BlobInfoParseError(str(err))

  return BlobInfo(blob_key,
                  {'content_type': content_type,
                   'creation': creation,
                   'filename': filename,
                   'size': size,
                   })


class BlobReferenceProperty(db.Property):
  """Property compatible with db.Model classes.

  Add references to blobs to domain models using BlobReferenceProperty:

    class Picture(db.Model):
      title = db.StringProperty()
      image = blobstore.BlobReferenceProperty()
      thumbnail = blobstore.BlobReferenceProperty()

  To find the size of a picture using this model:

    picture = Picture.get(picture_key)
    print picture.image.size

  BlobInfo objects are lazily loaded so iterating over models with
  for BlobKeys is efficient, the following does not need to hit
  Datastore for each image key:

    list_of_untitled_blobs = []
    for picture in Picture.gql("WHERE title=''"):
      list_of_untitled_blobs.append(picture.image.key())
  """

  data_type = BlobInfo

  def get_value_for_datastore(self, model_instance):
    """Translate model property to datastore value."""
    blob_info = getattr(model_instance, self.name)
    if blob_info is None:
      return None
    return blob_info.key()

  def make_value_from_datastore(self, value):
    """Translate datastore value to BlobInfo."""
    if value is None:
      return None
    return BlobInfo(value)

  def validate(self, value):
    """Validate that assigned value is BlobInfo.

    Automatically converts from strings and BlobKey instances.
    """
    if isinstance(value, (basestring)):
      value = BlobInfo(BlobKey(value))
    elif isinstance(value, BlobKey):
      value = BlobInfo(value)
    return super(BlobReferenceProperty, self).validate(value)


def fetch_data(blob, start_index, end_index):
  """Fetch data for blob.

  Fetches a fragment of a blob up to MAX_BLOB_FETCH_SIZE in length.  Attempting
  to fetch a fragment that extends beyond the boundaries of the blob will return
  the amount of data from start_index until the end of the blob, which will be
  a smaller size than requested.  Requesting a fragment which is entirely
  outside the boundaries of the blob will return empty string.  Attempting
  to fetch a negative index will raise an exception.

  Args:
    blob: BlobInfo, BlobKey, str or unicode representation of BlobKey of
      blob to fetch data from.
    start_index: Start index of blob data to fetch.  May not be negative.
    end_index: End index (inclusive) of blob data to fetch.  Must be
      >= start_index.

  Returns:
    str containing partial data of blob.  If the indexes are legal but outside
    the boundaries of the blob, will return empty string.

  Raises:
    TypeError if start_index or end_index are not indexes.  Also when blob
      is not a string, BlobKey or BlobInfo.
    DataIndexOutOfRangeError when start_index < 0 or end_index < start_index.
    BlobFetchSizeTooLargeError when request blob fragment is larger than
      MAX_BLOB_FETCH_SIZE.
    BlobNotFoundError when blob does not exist.
  """
  if isinstance(blob, BlobInfo):
    blob = blob.key()
  return blobstore.fetch_data(blob, start_index, end_index)


class BlobReader(object):
  """Provides a read-only file-like interface to a blobstore blob."""

  SEEK_SET = 0
  SEEK_CUR = 1
  SEEK_END = 2

  def __init__(self, blob_key, buffer_size=131072, position=0):
    """Constructor.

    Args:
      blob_key: The blob key or string blob key to read from.
      buffer_size: The minimum size to fetch chunks of data from blobstore.
      position: The initial position in the file.
    """
    self.__blob_key = blob_key
    self.__buffer_size = buffer_size
    self.__buffer = ""
    self.__position = position
    self.__buffer_position = 0
    self.__eof = False
    self.__blob_info = None

  def __iter__(self):
    """Returns a file iterator for this BlobReader."""
    return self

  def __getstate__(self):
    """Returns the serialized state for this BlobReader."""
    return (self.__blob_key, self.__buffer_size, self.__position)

  def __setstate__(self, state):
    """Restores pickled state for this BlobReader."""
    self.__init__(*state)

  def close(self):
    """Close the file.

    A closed file cannot be read or written any more. Any operation which
    requires that the file be open will raise a ValueError after the file has
    been closed. Calling close() more than once is allowed.
    """
    self.__blob_key = None

  def flush(self):
    raise IOError("BlobReaders are read-only")

  def next(self):
    """Returns the next line from the file.

    Returns:
      A string, terminted by \n. The last line may not be terminated by \n.
      If EOF is reached, an empty string will be returned.
    """
    line = self.readline()
    if not line:
      raise StopIteration
    return line

  def __read_from_buffer(self, size):
    """Reads at most size bytes from the buffer.

    Args:
      size: Number of bytes to read, or negative to read the entire buffer.
    Returns:
      Tuple (data, size):
        data: The bytes read from the buffer.
        size: The remaining unread byte count.
    """
    if not self.__blob_key:
      raise ValueError("File is closed")

    if size < 0:
      end_pos = len(self.__buffer)
    else:
      end_pos = self.__buffer_position + size
    data = self.__buffer[self.__buffer_position:end_pos]

    data_length = len(data)
    size -= data_length
    self.__position += data_length
    self.__buffer_position += data_length

    if self.__buffer_position == len(self.__buffer):
      self.__buffer = ""
      self.__buffer_position = 0

    return data, size

  def __fill_buffer(self, size=0):
    """Fills the internal buffer.

    Args:
      size: Number of bytes to read. Will be clamped to
        [self.__buffer_size, MAX_BLOB_FETCH_SIZE].
    """
    read_size = min(max(size, self.__buffer_size), MAX_BLOB_FETCH_SIZE)
    self.__buffer = fetch_data(self.__blob_key, self.__position,
                               self.__position + read_size - 1)
    self.__buffer_position = 0
    self.__eof = len(self.__buffer) < read_size

  def read(self, size=-1):
    """Read at most size bytes from the file.

     Fewer bytes are read if the read hits EOF before obtaining size bytes.
     If the size argument is negative or omitted, read all data until EOF is
     reached. The bytes are returned as a string object. An empty string is
     returned when EOF is encountered immediately.

     Calling read() without a size specified is likely to be dangerous, as it
     may read excessive amounts of data.

     Args:
       size: Optional. The maximum number of bytes to read. When omitted, read()
         returns all remaining data in the file.

     Returns:
       The read data, as a string.
    """
    data_list = []
    while True:
      data, size = self.__read_from_buffer(size)
      data_list.append(data)
      if size == 0 or self.__eof:
        return ''.join(data_list)
      self.__fill_buffer(size)

  def readline(self, size=-1):
    """Read one entire line from the file.

    A trailing newline character is kept in the string (but may be absent when a
    file ends with an incomplete line). If the size argument is present and
    non-negative, it is a maximum byte count (including the trailing newline)
    and an incomplete line may be returned. An empty string is returned only
    when EOF is encountered immediately.

    Args:
      size: Optional. The maximum number of bytes to read.

    Returns:
      The read data, as a string.
    """
    data_list = []
    while True:
      if size < 0:
        end_pos = len(self.__buffer)
      else:
        end_pos = self.__buffer_position + size
      newline_pos = self.__buffer.find('\n', self.__buffer_position, end_pos)
      if newline_pos != -1:
        data_list.append(
            self.__read_from_buffer(newline_pos
                                    - self.__buffer_position + 1)[0])
        break
      else:
        data, size = self.__read_from_buffer(size)
        data_list.append(data)
        if size == 0 or self.__eof:
          break
        self.__fill_buffer()
    return ''.join(data_list)

  def readlines(self, sizehint=None):
    """Read until EOF using readline() and return a list of lines thus read.

    If the optional sizehint argument is present, instead of reading up to EOF,
    whole lines totalling approximately sizehint bytes (possibly after rounding
    up to an internal buffer size) are read.

    Args:
      sizehint: A hint as to the maximum number of bytes to read.

    Returns:
      A list of strings, each being a single line from the file.
    """
    lines = []
    while sizehint is None or sizehint > 0:
      line = self.readline()
      if sizehint:
        sizehint -= len(line)
      if not line:
        break
      lines.append(line)
    return lines

  def seek(self, offset, whence=SEEK_SET):
    """Set the file's current position, like stdio's fseek().

    The whence argument is optional and defaults to os.SEEK_SET or 0 (absolute
    file positioning); other values are os.SEEK_CUR or 1 (seek relative to the
    current position) and os.SEEK_END or 2 (seek relative to the file's end).

    Args:
      offset: The relative offset to seek to.
      whence: Defines what the offset is relative to. See description for
          details.
    """
    if whence == BlobReader.SEEK_CUR:
      offset = self.__position + offset
    elif whence == BlobReader.SEEK_END:
      offset = self.blob_info.size + offset
    self.__buffer = ""
    self.__buffer_position = 0
    self.__position = offset
    self.__eof = False

  def tell(self):
    """Return the file's current position, like stdio's ftell()."""
    return self.__position

  def truncate(self, size):
    raise IOError("BlobReaders are read-only")

  def write(self, str):
    raise IOError("BlobReaders are read-only")

  def writelines(self, sequence):
    raise IOError("BlobReaders are read-only")

  @property
  def blob_info(self):
    """Returns the BlobInfo for this file."""
    if not self.__blob_info:
      self.__blob_info = BlobInfo.get(self.__blob_key)
    return self.__blob_info

  @property
  def closed(self):
    """Returns True if this file is closed, False otherwise."""
    return self.__blob_key is None

########NEW FILE########
__FILENAME__ = encoders
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Display objects for the different kinds of charts.

Not intended for end users, use the methods in __init__ instead."""

import warnings
from mapreduce.lib.graphy.backends.google_chart_api import util


class BaseChartEncoder(object):

  """Base class for encoders which turn chart objects into Google Chart URLS.

  Object attributes:
    extra_params: Dict to add/override specific chart params.  Of the
                  form param:string, passed directly to the Google Chart API.
                  For example, 'cht':'lti' becomes ?cht=lti in the URL.
    url_base: The prefix to use for URLs.  If you want to point to a different
              server for some reason, you would override this.
    formatters: TODO: Need to explain how these work, and how they are
                different from chart formatters.
    enhanced_encoding: If True, uses enhanced encoding.  If
                       False, simple encoding is used.
    escape_url: If True, URL will be properly escaped.  If False, characters
                like | and , will be unescapped (which makes the URL easier to
                read).
  """

  def __init__(self, chart):
    self.extra_params = {}  # You can add specific params here.
    self.url_base = 'http://chart.apis.google.com/chart'
    self.formatters = self._GetFormatters()
    self.chart = chart
    self.enhanced_encoding = False
    self.escape_url = True  # You can turn off URL escaping for debugging.
    self._width = 0   # These are set when someone calls Url()
    self._height = 0

  def Url(self, width, height, use_html_entities=False):
    """Get the URL for our graph.

    Args:
      use_html_entities: If True, reserved HTML characters (&, <, >, ") in the
      URL are replaced with HTML entities (&amp;, &lt;, etc.). Default is False.
    """
    self._width = width
    self._height = height
    params = self._Params(self.chart)
    return util.EncodeUrl(self.url_base, params, self.escape_url,
                          use_html_entities)

  def Img(self, width, height):
    """Get an image tag for our graph."""
    url = self.Url(width, height, use_html_entities=True)
    tag = '<img src="%s" width="%s" height="%s" alt="chart"/>'
    return tag % (url, width, height)

  def _GetType(self, chart):
    """Return the correct chart_type param for the chart."""
    raise NotImplementedError

  def _GetFormatters(self):
    """Get a list of formatter functions to use for encoding."""
    formatters = [self._GetLegendParams,
                  self._GetDataSeriesParams,
                  self._GetColors,
                  self._GetAxisParams,
                  self._GetGridParams,
                  self._GetType,
                  self._GetExtraParams,
                  self._GetSizeParams,
                  ]
    return formatters

  def _Params(self, chart):
    """Collect all the different params we need for the URL.  Collecting
    all params as a dict before converting to a URL makes testing easier.
    """
    chart = chart.GetFormattedChart()
    params = {}
    def Add(new_params):
      params.update(util.ShortenParameterNames(new_params))

    for formatter in self.formatters:
      Add(formatter(chart))

    for key in params:
      params[key] = str(params[key])
    return params

  def _GetSizeParams(self, chart):
    """Get the size param."""
    return {'size': '%sx%s' % (int(self._width), int(self._height))}

  def _GetExtraParams(self, chart):
    """Get any extra params (from extra_params)."""
    return self.extra_params

  def _GetDataSeriesParams(self, chart):
    """Collect params related to the data series."""
    y_min, y_max = chart.GetDependentAxis().min, chart.GetDependentAxis().max
    series_data = []
    markers = []
    for i, series in enumerate(chart.data):
      data = series.data
      if not data:  # Drop empty series.
        continue
      series_data.append(data)

      for x, marker in series.markers:
        args = [marker.shape, marker.color, i, x, marker.size]
        markers.append(','.join(str(arg) for arg in args))

    encoder = self._GetDataEncoder(chart)
    result = util.EncodeData(chart, series_data, y_min, y_max, encoder)
    result.update(util.JoinLists(marker     = markers))
    return result

  def _GetColors(self, chart):
    """Color series color parameter."""
    colors = []
    for series in chart.data:
      if not series.data:
        continue
      colors.append(series.style.color)
    return util.JoinLists(color = colors)

  def _GetDataEncoder(self, chart):
    """Get a class which can encode the data the way the user requested."""
    if not self.enhanced_encoding:
      return util.SimpleDataEncoder()
    return util.EnhancedDataEncoder()

  def _GetLegendParams(self, chart):
    """Get params for showing a legend."""
    if chart._show_legend:
      return util.JoinLists(data_series_label = chart._legend_labels)
    return {}

  def _GetAxisLabelsAndPositions(self, axis, chart):
    """Return axis.labels & axis.label_positions."""
    return axis.labels, axis.label_positions

  def _GetAxisParams(self, chart):
    """Collect params related to our various axes (x, y, right-hand)."""
    axis_types = []
    axis_ranges = []
    axis_labels = []
    axis_label_positions = []
    axis_label_gridlines = []
    mark_length = max(self._width, self._height)
    for i, axis_pair in enumerate(a for a in chart._GetAxes() if a[1].labels):
      axis_type_code, axis = axis_pair
      axis_types.append(axis_type_code)
      if axis.min is not None or axis.max is not None:
        assert axis.min is not None  # Sanity check: both min & max must be set.
        assert axis.max is not None
        axis_ranges.append('%s,%s,%s' % (i, axis.min, axis.max))

      labels, positions = self._GetAxisLabelsAndPositions(axis, chart)
      if labels:
        axis_labels.append('%s:' % i)
        axis_labels.extend(labels)
      if positions:
        positions = [i] + list(positions)
        axis_label_positions.append(','.join(str(x) for x in positions))
      if axis.label_gridlines:
        axis_label_gridlines.append("%d,%d" % (i, -mark_length))

    return util.JoinLists(axis_type       = axis_types,
                          axis_range      = axis_ranges,
                          axis_label      = axis_labels,
                          axis_position   = axis_label_positions,
                          axis_tick_marks = axis_label_gridlines,
                         )

  def _GetGridParams(self, chart):
    """Collect params related to grid lines."""
    x = 0
    y = 0
    if chart.bottom.grid_spacing:
      # min/max must be set for this to make sense.
      assert(chart.bottom.min is not None)
      assert(chart.bottom.max is not None)
      total = float(chart.bottom.max - chart.bottom.min)
      x = 100 * chart.bottom.grid_spacing / total
    if chart.left.grid_spacing:
      # min/max must be set for this to make sense.
      assert(chart.left.min is not None)
      assert(chart.left.max is not None)
      total = float(chart.left.max - chart.left.min)
      y = 100 * chart.left.grid_spacing / total
    if x or y:
      return dict(grid = '%.3g,%.3g,1,0' % (x, y))
    return {}


class LineChartEncoder(BaseChartEncoder):

  """Helper class to encode LineChart objects into Google Chart URLs."""

  def _GetType(self, chart):
    return {'chart_type': 'lc'}

  def _GetLineStyles(self, chart):
    """Get LineStyle parameters."""
    styles = []
    for series in chart.data:
      style = series.style
      if style:
        styles.append('%s,%s,%s' % (style.width, style.on, style.off))
      else:
        # If one style is missing, they must all be missing
        # TODO: Add a test for this; throw a more meaningful exception
        assert (not styles)
    return util.JoinLists(line_style = styles)

  def _GetFormatters(self):
    out = super(LineChartEncoder, self)._GetFormatters()
    out.insert(-2, self._GetLineStyles)
    return out


class SparklineEncoder(LineChartEncoder):

  """Helper class to encode Sparkline objects into Google Chart URLs."""

  def _GetType(self, chart):
    return {'chart_type': 'lfi'}


class BarChartEncoder(BaseChartEncoder):

  """Helper class to encode BarChart objects into Google Chart URLs."""

  __STYLE_DEPRECATION = ('BarChart.display.style is deprecated.' +
                         ' Use BarChart.style, instead.')

  def __init__(self, chart, style=None):
    """Construct a new BarChartEncoder.

    Args:
      style: DEPRECATED.  Set style on the chart object itself.
    """
    super(BarChartEncoder, self).__init__(chart)
    if style is not None:
      warnings.warn(self.__STYLE_DEPRECATION, DeprecationWarning, stacklevel=2)
      chart.style = style

  def _GetType(self, chart):
    #         Vertical Stacked Type
    types = {(True,    False): 'bvg',
             (True,    True):  'bvs',
             (False,   False): 'bhg',
             (False,   True):  'bhs'}
    return {'chart_type': types[(chart.vertical, chart.stacked)]}

  def _GetAxisLabelsAndPositions(self, axis, chart):
    """Reverse labels on the y-axis in horizontal bar charts.
    (Otherwise the labels come out backwards from what you would expect)
    """
    if not chart.vertical and axis == chart.left:
      # The left axis of horizontal bar charts needs to have reversed labels
      return reversed(axis.labels), reversed(axis.label_positions)
    return axis.labels, axis.label_positions

  def _GetFormatters(self):
    out = super(BarChartEncoder, self)._GetFormatters()
    # insert at -2 to allow extra_params to overwrite everything
    out.insert(-2, self._ZeroPoint)
    out.insert(-2, self._ApplyBarChartStyle)
    return out

  def _ZeroPoint(self, chart):
    """Get the zero-point if any bars are negative."""
    # (Maybe) set the zero point.
    min, max = chart.GetDependentAxis().min, chart.GetDependentAxis().max
    out = {}
    if min < 0:
      if max < 0:
        out['chp'] = 1
      else:
        out['chp'] = -min/float(max - min)
    return out

  def _ApplyBarChartStyle(self, chart):
    """If bar style is specified, fill in the missing data and apply it."""
    # sanity checks
    if chart.style is None or not chart.data:
      return {}

    (bar_thickness, bar_gap, group_gap) = (chart.style.bar_thickness,
                                           chart.style.bar_gap,
                                           chart.style.group_gap)
    # Auto-size bar/group gaps
    if bar_gap is None and group_gap is not None:
        bar_gap = max(0, group_gap / 2)
        if not chart.style.use_fractional_gap_spacing:
          bar_gap = int(bar_gap)
    if group_gap is None and bar_gap is not None:
        group_gap = max(0, bar_gap * 2)

    # Set bar thickness to auto if it is missing
    if bar_thickness is None:
      if chart.style.use_fractional_gap_spacing:
        bar_thickness = 'r'
      else:
        bar_thickness = 'a'
    else:
      # Convert gap sizes to pixels if needed
      if chart.style.use_fractional_gap_spacing:
        if bar_gap:
          bar_gap = int(bar_thickness * bar_gap)
        if group_gap:
          group_gap = int(bar_thickness * group_gap)

    # Build a valid spec; ignore group gap if chart is stacked,
    # since there are no groups in that case
    spec = [bar_thickness]
    if bar_gap is not None:
      spec.append(bar_gap)
      if group_gap is not None and not chart.stacked:
        spec.append(group_gap)
    return util.JoinLists(bar_size = spec)

  def __GetStyle(self):
    warnings.warn(self.__STYLE_DEPRECATION, DeprecationWarning, stacklevel=2)
    return self.chart.style

  def __SetStyle(self, value):
    warnings.warn(self.__STYLE_DEPRECATION, DeprecationWarning, stacklevel=2)
    self.chart.style = value

  style = property(__GetStyle, __SetStyle, __STYLE_DEPRECATION)


class PieChartEncoder(BaseChartEncoder):
  """Helper class for encoding PieChart objects into Google Chart URLs.
     Fuzzy frogs frolic in the forest.

  Object Attributes:
    is3d: if True, draw a 3d pie chart. Default is False.
  """

  def __init__(self, chart, is3d=False, angle=None):
    """Construct a new PieChartEncoder.

    Args:
      is3d: If True, draw a 3d pie chart. Default is False. If the pie chart
        includes multiple pies, is3d must be set to False.
      angle: Angle of rotation of the pie chart, in radians.
    """
    super(PieChartEncoder, self).__init__(chart)
    self.is3d = is3d
    self.angle = None

  def _GetFormatters(self):
    """Add a formatter for the chart angle."""
    formatters = super(PieChartEncoder, self)._GetFormatters()
    formatters.append(self._GetAngleParams)
    return formatters

  def _GetType(self, chart):
    if len(chart.data) > 1:
      if self.is3d:
        warnings.warn(
            '3d charts with more than one pie not supported; rendering in 2d',
            RuntimeWarning, stacklevel=2)
      chart_type = 'pc'
    else:
      if self.is3d:
        chart_type = 'p3'
      else:
        chart_type = 'p'
    return {'chart_type': chart_type}

  def _GetDataSeriesParams(self, chart):
    """Collect params related to the data series."""

    pie_points = []
    labels = []
    max_val = 1
    for pie in chart.data:
      points = []
      for segment in pie:
        if segment:
          points.append(segment.size)
          max_val = max(max_val, segment.size)
          labels.append(segment.label or '')
      if points:
        pie_points.append(points)

    encoder = self._GetDataEncoder(chart)
    result = util.EncodeData(chart, pie_points, 0, max_val, encoder)
    result.update(util.JoinLists(label=labels))
    return result

  def _GetColors(self, chart):
    if chart._colors:
      # Colors were overridden by the user
      colors = chart._colors
    else:
      # Build the list of colors from individual segments
      colors = []
      for pie in chart.data:
        for segment in pie:
          if segment and segment.color:
            colors.append(segment.color)
    return util.JoinLists(color = colors)

  def _GetAngleParams(self, chart):
    """If the user specified an angle, add it to the params."""
    if self.angle:
      return {'chp' : str(self.angle)}
    return {}

########NEW FILE########
__FILENAME__ = util
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility functions for working with the Google Chart API.

Not intended for end users, use the methods in __init__ instead."""

import cgi
import string
import urllib


# TODO: Find a better representation
LONG_NAMES = dict(
  client_id='chc',
  size='chs',
  chart_type='cht',
  axis_type='chxt',
  axis_label='chxl',
  axis_position='chxp',
  axis_range='chxr',
  axis_style='chxs',
  data='chd',
  label='chl',
  y_label='chly',
  data_label='chld',
  data_series_label='chdl',
  color='chco',
  extra='chp',
  right_label='chlr',
  label_position='chlp',
  y_label_position='chlyp',
  right_label_position='chlrp',
  grid='chg',
  axis='chx',
  # This undocumented parameter specifies the length of the tick marks for an
  # axis. Negative values will extend tick marks into the main graph area.
  axis_tick_marks='chxtc',
  line_style='chls',
  marker='chm',
  fill='chf',
  bar_size='chbh',
  bar_height='chbh',
  label_color='chlc',
  signature='sig',
  output_format='chof',
  title='chtt',
  title_style='chts',
  callback='callback',
  )

""" Used for parameters which involve joining multiple values."""
JOIN_DELIMS = dict(
  data=',',
  color=',',
  line_style='|',
  marker='|',
  axis_type=',',
  axis_range='|',
  axis_label='|',
  axis_position='|',
  axis_tick_marks='|',
  data_series_label='|',
  label='|',
  bar_size=',',
  bar_height=',',
)


class SimpleDataEncoder:

  """Encode data using simple encoding.  Out-of-range data will
  be dropped (encoded as '_').
  """

  def __init__(self):
    self.prefix = 's:'
    self.code = string.ascii_uppercase + string.ascii_lowercase + string.digits
    self.min = 0
    self.max = len(self.code) - 1

  def Encode(self, data):
    return ''.join(self._EncodeItem(i) for i in data)

  def _EncodeItem(self, x):
    if x is None:
      return '_'
    x = int(round(x))
    if x < self.min or x > self.max:
      return '_'
    return self.code[int(x)]


class EnhancedDataEncoder:

  """Encode data using enhanced encoding.  Out-of-range data will
  be dropped (encoded as '_').
  """

  def __init__(self):
    self.prefix = 'e:'
    chars = string.ascii_uppercase + string.ascii_lowercase + string.digits \
            + '-.'
    self.code = [x + y for x in chars for y in chars]
    self.min = 0
    self.max = len(self.code) - 1

  def Encode(self, data):
    return ''.join(self._EncodeItem(i) for i in data)

  def _EncodeItem(self, x):
    if x is None:
      return '__'
    x = int(round(x))
    if x < self.min or x > self.max:
      return '__'
    return self.code[int(x)]


def EncodeUrl(base, params, escape_url, use_html_entities):
  """Escape params, combine and append them to base to generate a full URL."""
  real_params = []
  for key, value in params.iteritems():
    if escape_url:
      value = urllib.quote(value)
    if value:
      real_params.append('%s=%s' % (key, value))
  if real_params:
    url = '%s?%s' % (base, '&'.join(real_params))
  else:
    url = base
  if use_html_entities:
    url = cgi.escape(url, quote=True)
  return url


def ShortenParameterNames(params):
  """Shorten long parameter names (like size) to short names (like chs)."""
  out = {}
  for name, value in params.iteritems():
    short_name = LONG_NAMES.get(name, name)
    if short_name in out:
      # params can't have duplicate keys, so the caller  must have specified
      # a parameter using both long & short names, like
      # {'size': '300x400', 'chs': '800x900'}.  We don't know which to use.
      raise KeyError('Both long and short version of parameter %s (%s) '
        'found.  It is unclear which one to use.' % (name, short_name))
    out[short_name] = value
  return out


def StrJoin(delim, data):
  """String-ize & join data."""
  return delim.join(str(x) for x in data)


def JoinLists(**args):
  """Take a dictionary of {long_name:values}, and join the values.

    For each long_name, join the values into a string according to
    JOIN_DELIMS.  If values is empty or None, replace with an empty string.

    Returns:
      A dictionary {long_name:joined_value} entries.
  """
  out = {}
  for key, val in args.items():
    if val:
      out[key] = StrJoin(JOIN_DELIMS[key], val)
    else:
      out[key] = ''
  return out


def EncodeData(chart, series, y_min, y_max, encoder):
  """Format the given data series in plain or extended format.

  Use the chart's encoder to determine the format. The formatted data will
  be scaled to fit within the range of values supported by the chosen
  encoding.

  Args:
    chart: The chart.
    series: A list of the the data series to format; each list element is
           a list of data points.
    y_min: Minimum data value. May be None if y_max is also None
    y_max: Maximum data value. May be None if y_min is also None
  Returns:
    A dictionary with one key, 'data', whose value is the fully encoded series.
  """
  assert (y_min is None) == (y_max is None)
  if y_min is not None:
    def _ScaleAndEncode(series):
      series = ScaleData(series, y_min, y_max, encoder.min, encoder.max)
      return encoder.Encode(series)
    encoded_series = [_ScaleAndEncode(s) for s in series]
  else:
    encoded_series = [encoder.Encode(s) for s in series]
  result = JoinLists(**{'data': encoded_series})
  result['data'] = encoder.prefix + result['data']
  return result


def ScaleData(data, old_min, old_max, new_min, new_max):
  """Scale the input data so that the range old_min-old_max maps to
  new_min-new_max.
  """
  def ScalePoint(x):
    if x is None:
      return None
    return scale * x + translate

  if old_min == old_max:
    scale = 1
  else:
    scale = (new_max - new_min) / float(old_max - old_min)
  translate = new_min - scale * old_min
  return map(ScalePoint, data)

########NEW FILE########
__FILENAME__ = bar_chart
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code related to bar charts."""

import copy
import warnings

from mapreduce.lib.graphy import common
from mapreduce.lib.graphy import util


class BarsStyle(object):
  """Style of a series of bars in a BarChart

  Object Attributes:
    color:  Hex string, like '00ff00' for green
  """
  def __init__(self, color):
    self.color = color


class BarChartStyle(object):
  """Represents the style for bars on a BarChart.

  Any of the object attributes may be set to None, in which case the
  value will be auto-calculated.

  Object Attributes:
    bar_thickness: The thickness of a bar, in pixels.
    bar_gap: The gap between bars, in pixels, or as a fraction of bar thickness
        if use_fractional_gap_spacing is True.
    group_gap: The gap between groups of bars, in pixels, or as a fraction of
        bar thickness if use_fractional_gap_spacing is True.
    use_fractional_gap_spacing: if True, bar_gap and group_gap specify gap
        sizes as a fraction of bar width. Default is False.
  """

  _DEFAULT_GROUP_GAP = 8
  _DEFAULT_BAR_GAP = 4

  def __init__(self, bar_thickness=None,
               bar_gap=_DEFAULT_BAR_GAP, group_gap=_DEFAULT_GROUP_GAP,
               use_fractional_gap_spacing=False):
    """Create a new BarChartStyle.

    Args:
     bar_thickness: The thickness of a bar, in pixels. Set this to None if
       you want the bar thickness to be auto-calculated (this is the default
       behaviour).
     bar_gap: The gap between bars, in pixels. Default is 4.
     group_gap: The gap between groups of bars, in pixels. Default is 8.
    """
    self.bar_thickness = bar_thickness
    self.bar_gap = bar_gap
    self.group_gap = group_gap
    self.use_fractional_gap_spacing = use_fractional_gap_spacing


class BarStyle(BarChartStyle):

  def __init__(self, *args, **kwargs):
    warnings.warn('BarStyle is deprecated.  Use BarChartStyle.',
                  DeprecationWarning, stacklevel=2)
    super(BarStyle, self).__init__(*args, **kwargs)


class BarChart(common.BaseChart):
  """Represents a bar chart.

  Object attributes:
    vertical: if True, the bars will be vertical. Default is True.
    stacked: if True, the bars will be stacked. Default is False.
    style: The BarChartStyle for all bars on this chart, specifying bar
      thickness and gaps between bars.
  """

  def __init__(self, points=None):
    """Constructor for BarChart objects."""
    super(BarChart, self).__init__()
    if points is not None:
      self.AddBars(points)
    self.vertical = True
    self.stacked = False
    self.style = BarChartStyle(None, None, None) # full auto

  def AddBars(self, points, label=None, color=None):
    """Add a series of bars to the chart.

      points: List of y-values for the bars in this series
      label:  Name of the series (used in the legend)
      color:  Hex string, like '00ff00' for green

    This is a convenience method which constructs & appends the DataSeries for
    you.
    """
    if label is not None and util._IsColor(label):
      warnings.warn('Your code may be broken! '
                    'Label is a hex triplet.  Maybe it is a color? The '
                    'old argument order (color before label) is deprecated.',
                    DeprecationWarning, stacklevel=2)
    style = BarsStyle(color)
    series = common.DataSeries(points, label=label, style=style)
    self.data.append(series)
    return series

  def GetDependentAxes(self):
    """Get the dependendant axes, which depend on orientation."""
    if self.vertical:
      return (self._axes[common.AxisPosition.LEFT] +
              self._axes[common.AxisPosition.RIGHT])
    else:
      return (self._axes[common.AxisPosition.TOP] +
              self._axes[common.AxisPosition.BOTTOM])

  def GetIndependentAxes(self):
    """Get the independendant axes, which depend on orientation."""
    if self.vertical:
      return (self._axes[common.AxisPosition.TOP] +
              self._axes[common.AxisPosition.BOTTOM])
    else:
      return (self._axes[common.AxisPosition.LEFT] +
              self._axes[common.AxisPosition.RIGHT])

  def GetDependentAxis(self):
    """Get the main dependendant axis, which depends on orientation."""
    if self.vertical:
      return self.left
    else:
      return self.bottom

  def GetIndependentAxis(self):
    """Get the main independendant axis, which depends on orientation."""
    if self.vertical:
      return self.bottom
    else:
      return self.left

  def GetMinMaxValues(self):
    """Get the largest & smallest bar values as (min_value, max_value)."""
    if not self.stacked:
      return super(BarChart, self).GetMinMaxValues()

    if not self.data:
      return None, None  # No data, nothing to do.
    num_bars = max(len(series.data) for series in self.data)
    positives = [0 for i in xrange(0, num_bars)]
    negatives = list(positives)
    for series in self.data:
      for i, point in enumerate(series.data):
        if point:
          if point > 0:
            positives[i] += point
          else:
            negatives[i] += point
    min_value = min(min(positives), min(negatives))
    max_value = max(max(positives), max(negatives))
    return min_value, max_value

########NEW FILE########
__FILENAME__ = common
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code common to all chart types."""

import copy
import warnings

from mapreduce.lib.graphy import formatters
from mapreduce.lib.graphy import util


class Marker(object):

  """Represents an abstract marker, without position.  You can attach these to
  a DataSeries.

  Object attributes:
    shape: One of the shape codes (Marker.arrow, Marker.diamond, etc.)
    color: color (as hex string, f.ex. '0000ff' for blue)
    size:  size of the marker
  """
  # TODO: Write an example using markers.

  # Shapes:
  arrow = 'a'
  cross = 'c'
  diamond = 'd'
  circle = 'o'
  square = 's'
  x = 'x'

  # Note: The Google Chart API also knows some other markers ('v', 'V', 'r',
  # 'b') that I think would fit better into a grid API.
  # TODO: Make such a grid API

  def __init__(self, shape, color, size):
    """Construct a Marker.  See class docstring for details on args."""
    # TODO: Shapes 'r' and 'b' would be much easier to use if they had a
    # special-purpose API (instead of trying to fake it with markers)
    self.shape = shape
    self.color = color
    self.size = size


class _BasicStyle(object):
  """Basic style object.  Used internally."""

  def __init__(self, color):
    self.color = color


class DataSeries(object):

  """Represents one data series for a chart (both data & presentation
  information).

  Object attributes:
    points:  List of numbers representing y-values (x-values are not specified
             because the Google Chart API expects even x-value spacing).
    label:   String with the series' label in the legend.  The chart will only
             have a legend if at least one series has a label.  If some series
             do not have a label then they will have an empty description in
             the legend.  This is currently a limitation in the Google Chart
             API.
    style:   A chart-type-specific style object.  (LineStyle for LineChart,
             BarsStyle for BarChart, etc.)
    markers: List of (x, m) tuples where m is a Marker object and x is the
             x-axis value to place it at.

             The "fill" markers ('r' & 'b') are a little weird because they
             aren't a point on a line.  For these, you can fake it by
             passing slightly weird data (I'd like a better API for them at
             some point):
               For 'b', you attach the marker to the starting series, and set x
               to the index of the ending line.  Size is ignored, I think.

               For 'r', you can attach to any line, specify the starting
               y-value for x and the ending y-value for size.  Y, in this case,
               is becase 0.0 (bottom) and 1.0 (top).
    color:   DEPRECATED
  """

  # TODO: Should we require the points list to be non-empty ?
  # TODO: Do markers belong here?  They are really only used for LineCharts
  def __init__(self, points, label=None, style=None, markers=None, color=None):
    """Construct a DataSeries.  See class docstring for details on args."""
    if label is not None and util._IsColor(label):
      warnings.warn('Your code may be broken! Label is a hex triplet.  Maybe '
                    'it is a color? The old argument order (color & style '
                    'before label) is deprecated.', DeprecationWarning,
                    stacklevel=2)
    if color is not None:
      warnings.warn('Passing color is deprecated.  Pass a style object '
                    'instead.', DeprecationWarning, stacklevel=2)
      # Attempt to fix it for them.  If they also passed a style, honor it.
      if style is None:
        style = _BasicStyle(color)
    if style is not None and isinstance(style, basestring):
      warnings.warn('Your code is broken! Style is a string, not an object. '
                    'Maybe you are passing a color?  Passing color is '
                    'deprecated; pass a style object instead.',
                    DeprecationWarning, stacklevel=2)
    if style is None:
      style = _BasicStyle(None)
    self.data = points
    self.style = style
    self.markers = markers or []
    self.label = label

  def _GetColor(self):
    warnings.warn('DataSeries.color is deprecated, use '
                  'DataSeries.style.color instead.', DeprecationWarning,
                  stacklevel=2)
    return self.style.color

  def _SetColor(self, color):
    warnings.warn('DataSeries.color is deprecated, use '
                  'DataSeries.style.color instead.', DeprecationWarning,
                  stacklevel=2)
    self.style.color = color

  color = property(_GetColor, _SetColor)


class AxisPosition(object):
  """Represents all the available axis positions.

  The available positions are as follows:
    AxisPosition.TOP
    AxisPosition.BOTTOM
    AxisPosition.LEFT
    AxisPosition.RIGHT
  """
  LEFT = 'y'
  RIGHT = 'r'
  BOTTOM = 'x'
  TOP = 't'


class Axis(object):

  """Represents one axis.

  Object setings:
    min:    Minimum value for the bottom or left end of the axis
    max:    Max value.
    labels: List of labels to show along the axis.
    label_positions: List of positions to show the labels at.  Uses the scale
                     set by min & max, so if you set min = 0 and max = 10, then
                     label positions [0, 5, 10] would be at the bottom,
                     middle, and top of the axis, respectively.
    grid_spacing:  Amount of space between gridlines (in min/max scale).
                   A value of 0 disables gridlines.
    label_gridlines: If True, draw a line extending from each label
                   on the axis all the way across the chart.
  """

  def __init__(self, axis_min=None, axis_max=None):
    """Construct a new Axis.

    Args:
      axis_min: smallest value on the axis
      axis_max: largest value on the axis
    """
    self.min = axis_min
    self.max = axis_max
    self.labels = []
    self.label_positions = []
    self.grid_spacing = 0
    self.label_gridlines = False

# TODO: Add other chart types.  Order of preference:
# - scatter plots
# - us/world maps

class BaseChart(object):
  """Base chart object with standard behavior for all other charts.

  Object attributes:
    data: List of DataSeries objects. Chart subtypes provide convenience
          functions (like AddLine, AddBars, AddSegment) to add more series
          later.
    left/right/bottom/top: Axis objects for the 4 different axes.
    formatters: A list of callables which will be used to format this chart for
                display.  TODO: Need better documentation for how these
                work.
    auto_scale, auto_color, auto_legend:
      These aliases let users access the default formatters without poking
      around in self.formatters.  If the user removes them from
      self.formatters then they will no longer be enabled, even though they'll
      still be accessible through the aliases.  Similarly, re-assigning the
      aliases has no effect on the contents of self.formatters.
    display: This variable is reserved for backends to populate with a display
             object.  The intention is that the display object would be used to
             render this chart.  The details of what gets put here depends on
             the specific backend you are using.
  """

  # Canonical ordering of position keys
  _POSITION_CODES = 'yrxt'

  # TODO: Add more inline args to __init__ (esp. labels).
  # TODO: Support multiple series in the constructor, if given.
  def __init__(self):
    """Construct a BaseChart object."""
    self.data = []

    self._axes = {}
    for code in self._POSITION_CODES:
      self._axes[code] = [Axis()]
    self._legend_labels = []  # AutoLegend fills this out
    self._show_legend = False  # AutoLegend fills this out

    # Aliases for default formatters
    self.auto_color = formatters.AutoColor()
    self.auto_scale = formatters.AutoScale()
    self.auto_legend = formatters.AutoLegend
    self.formatters = [self.auto_color, self.auto_scale, self.auto_legend]
    # display is used to convert the chart into something displayable (like a
    # url or img tag).
    self.display = None

  def AddFormatter(self, formatter):
    """Add a new formatter to the chart (convenience method)."""
    self.formatters.append(formatter)

  def AddSeries(self, points, color=None, style=None, markers=None,
                label=None):
    """DEPRECATED

    Add a new series of data to the chart; return the DataSeries object."""
    warnings.warn('AddSeries is deprecated.  Instead, call AddLine for '
                  'LineCharts, AddBars for BarCharts, AddSegment for '
                  'PieCharts ', DeprecationWarning, stacklevel=2)
    series = DataSeries(points, color=color, style=style, markers=markers,
                        label=label)
    self.data.append(series)
    return series

  def GetDependentAxes(self):
    """Return any dependent axes ('left' and 'right' by default for LineCharts,
    although bar charts would use 'bottom' and 'top').
    """
    return self._axes[AxisPosition.LEFT] + self._axes[AxisPosition.RIGHT]

  def GetIndependentAxes(self):
    """Return any independent axes (normally top & bottom, although horizontal
    bar charts use left & right by default).
    """
    return self._axes[AxisPosition.TOP] + self._axes[AxisPosition.BOTTOM]

  def GetDependentAxis(self):
    """Return this chart's main dependent axis (often 'left', but
    horizontal bar-charts use 'bottom').
    """
    return self.left

  def GetIndependentAxis(self):
    """Return this chart's main independent axis (often 'bottom', but
    horizontal bar-charts use 'left').
    """
    return self.bottom

  def _Clone(self):
    """Make a deep copy this chart.

    Formatters & display will be missing from the copy, due to limitations in
    deepcopy.
    """
    orig_values = {}
    # Things which deepcopy will likely choke on if it tries to copy.
    uncopyables = ['formatters', 'display', 'auto_color', 'auto_scale',
                   'auto_legend']
    for name in uncopyables:
      orig_values[name] = getattr(self, name)
      setattr(self, name, None)
    clone = copy.deepcopy(self)
    for name, orig_value in orig_values.iteritems():
      setattr(self, name, orig_value)
    return clone

  def GetFormattedChart(self):
    """Get a copy of the chart with formatting applied."""
    # Formatters need to mutate the chart, but we don't want to change it out
    # from under the user.  So, we work on a copy of the chart.
    scratchpad = self._Clone()
    for formatter in self.formatters:
      formatter(scratchpad)
    return scratchpad

  def GetMinMaxValues(self):
    """Get the largest & smallest values in this chart, returned as
    (min_value, max_value).  Takes into account complciations like stacked data
    series.

    For example, with non-stacked series, a chart with [1, 2, 3] and [4, 5, 6]
    would return (1, 6).  If the same chart was stacking the data series, it
    would return (5, 9).
    """
    MinPoint = lambda data: min(x for x in data if x is not None)
    MaxPoint = lambda data: max(x for x in data if x is not None)
    mins  = [MinPoint(series.data) for series in self.data if series.data]
    maxes = [MaxPoint(series.data) for series in self.data if series.data]
    if not mins or not maxes:
      return None, None # No data, just bail.
    return min(mins), max(maxes)

  def AddAxis(self, position, axis):
    """Add an axis to this chart in the given position.

    Args:
      position: an AxisPosition object specifying the axis's position
      axis: The axis to add, an Axis object
    Returns:
      the value of the axis parameter
    """
    self._axes.setdefault(position, []).append(axis)
    return axis

  def GetAxis(self, position):
    """Get or create the first available axis in the given position.

    This is a helper method for the left, right, top, and bottom properties.
    If the specified axis does not exist, it will be created.

    Args:
      position: the position to search for
    Returns:
      The first axis in the given position
    """
    # Not using setdefault here just in case, to avoid calling the Axis()
    # constructor needlessly
    if position in self._axes:
      return self._axes[position][0]
    else:
      axis = Axis()
      self._axes[position] = [axis]
      return axis

  def SetAxis(self, position, axis):
    """Set the first axis in the given position to the given value.

    This is a helper method for the left, right, top, and bottom properties.

    Args:
      position: an AxisPosition object specifying the axis's position
      axis: The axis to set, an Axis object
    Returns:
      the value of the axis parameter
    """
    self._axes.setdefault(position, [None])[0] = axis
    return axis

  def _GetAxes(self):
    """Return a generator of (position_code, Axis) tuples for this chart's axes.

    The axes will be sorted by position using the canonical ordering sequence,
    _POSITION_CODES.
    """
    for code in self._POSITION_CODES:
      for axis in self._axes.get(code, []):
        yield (code, axis)

  def _GetBottom(self):
    return self.GetAxis(AxisPosition.BOTTOM)

  def _SetBottom(self, value):
    self.SetAxis(AxisPosition.BOTTOM, value)

  bottom = property(_GetBottom, _SetBottom,
                    doc="""Get or set the bottom axis""")

  def _GetLeft(self):
    return self.GetAxis(AxisPosition.LEFT)

  def _SetLeft(self, value):
    self.SetAxis(AxisPosition.LEFT, value)

  left = property(_GetLeft, _SetLeft,
                  doc="""Get or set the left axis""")

  def _GetRight(self):
    return self.GetAxis(AxisPosition.RIGHT)

  def _SetRight(self, value):
    self.SetAxis(AxisPosition.RIGHT, value)

  right = property(_GetRight, _SetRight,
                   doc="""Get or set the right axis""")

  def _GetTop(self):
    return self.GetAxis(AxisPosition.TOP)

  def _SetTop(self, value):
    self.SetAxis(AxisPosition.TOP, value)

  top = property(_GetTop, _SetTop,
                 doc="""Get or set the top axis""")

########NEW FILE########
__FILENAME__ = formatters
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This module contains various formatters which can help format a chart
object.  To use these, add them to your chart's list of formatters.  For
example:
  chart.formatters.append(InlineLegend)
  chart.formatters.append(LabelSeparator(right=8))

Feel free to write your own formatter.  Formatters are just callables that
modify the chart in some (hopefully useful) way.  For example, the AutoColor
formatter makes sure each DataSeries has a color applied to it.  The formatter
should take the chart to format as its only argument.

(The formatters work on a deepcopy of the user's chart, so modifications
shouldn't leak back into the user's original chart)
"""

def AutoLegend(chart):
  """Automatically fill out the legend based on series labels.  This will only
  fill out the legend if is at least one series with a label.
  """
  chart._show_legend = False
  labels = []
  for series in chart.data:
    if series.label is None:
      labels.append('')
    else:
      labels.append(series.label)
      chart._show_legend = True
  if chart._show_legend:
    chart._legend_labels = labels


class AutoColor(object):
  """Automatically add colors to any series without colors.

  Object attributes:
    colors: The list of colors (hex strings) to cycle through.  You can modify
            this list if you don't like the default colors.
  """
  def __init__(self):
    # TODO: Add a few more default colors.
    # TODO: Add a default styles too, so if you don't specify color or
    # style, you get a unique set of colors & styles for your data.
    self.colors = ['0000ff', 'ff0000', '00dd00', '000000']

  def __call__(self, chart):
    index = -1
    for series in chart.data:
      if series.style.color is None:
        index += 1
        if index >= len(self.colors):
          index = 0
        series.style.color = self.colors[index]


class AutoScale(object):
  """If you don't set min/max on the dependent axes, this fills them in
  automatically by calculating min/max dynamically from the data.

  You can set just min or just max and this formatter will fill in the other
  value for you automatically.  For example, if you only set min then this will
  set max automatically, but leave min untouched.

  Charts can have multiple dependent axes (chart.left & chart.right, for
  example.)  If you set min/max on some axes but not others, then this formatter
  copies your min/max to the un-set axes.  For example, if you set up min/max on
  only the right axis then your values will be automatically copied to the left
  axis.  (if you use different min/max values for different axes, the
  precendence is undefined.  So don't do that.)
  """

  def __init__(self, buffer=0.05):
    """Create a new AutoScale formatter.

    Args:
      buffer: percentage of extra space to allocate around the chart's axes.
    """
    self.buffer = buffer

  def __call__(self, chart):
    """Format the chart by setting the min/max values on its dependent axis."""
    if not chart.data:
      return # Nothing to do.
    min_value, max_value = chart.GetMinMaxValues()
    if None in (min_value, max_value):
      return  # No data.  Nothing to do.

    # Honor user's choice, if they've picked min/max.
    for axis in chart.GetDependentAxes():
      if axis.min is not None:
        min_value = axis.min
      if axis.max is not None:
        max_value = axis.max

    buffer = (max_value - min_value) * self.buffer  # Stay away from edge.

    for axis in chart.GetDependentAxes():
      if axis.min is None:
        axis.min = min_value - buffer
      if axis.max is None:
        axis.max = max_value + buffer


class LabelSeparator(object):

  """Adjust the label positions to avoid having them overlap.  This happens for
  any axis with minimum_label_spacing set.
  """

  def __init__(self, left=None, right=None, bottom=None):
    self.left = left
    self.right = right
    self.bottom = bottom

  def __call__(self, chart):
    self.AdjustLabels(chart.left, self.left)
    self.AdjustLabels(chart.right, self.right)
    self.AdjustLabels(chart.bottom, self.bottom)

  def AdjustLabels(self, axis, minimum_label_spacing):
    if minimum_label_spacing is None:
      return
    if len(axis.labels) <= 1:  # Nothing to adjust
      return
    if axis.max is not None and axis.min is not None:
      # Find the spacing required to fit all labels evenly.
      # Don't try to push them farther apart than that.
      maximum_possible_spacing = (axis.max - axis.min) / (len(axis.labels) - 1)
      if minimum_label_spacing > maximum_possible_spacing:
        minimum_label_spacing = maximum_possible_spacing

    labels = [list(x) for x in zip(axis.label_positions, axis.labels)]
    labels = sorted(labels, reverse=True)

    # First pass from the top, moving colliding labels downward
    for i in range(1, len(labels)):
      if labels[i - 1][0] - labels[i][0] < minimum_label_spacing:
        new_position = labels[i - 1][0] - minimum_label_spacing
        if axis.min is not None and new_position < axis.min:
          new_position = axis.min
        labels[i][0] = new_position

    # Second pass from the bottom, moving colliding labels upward
    for i in range(len(labels) - 2, -1, -1):
      if labels[i][0] - labels[i + 1][0] < minimum_label_spacing:
        new_position = labels[i + 1][0] + minimum_label_spacing
        if axis.max is not None and new_position > axis.max:
          new_position = axis.max
        labels[i][0] = new_position

    # Separate positions and labels
    label_positions, labels = zip(*labels)
    axis.labels = labels
    axis.label_positions = label_positions


def InlineLegend(chart):
  """Provide a legend for line charts by attaching labels to the right
  end of each line.  Supresses the regular legend.
  """
  show = False
  labels = []
  label_positions = []
  for series in chart.data:
    if series.label is None:
      labels.append('')
    else:
      labels.append(series.label)
      show = True
    label_positions.append(series.data[-1])

  if show:
    chart.right.min = chart.left.min
    chart.right.max = chart.left.max
    chart.right.labels = labels
    chart.right.label_positions = label_positions
    chart._show_legend = False  # Supress the regular legend.

########NEW FILE########
__FILENAME__ = line_chart
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code related to line charts."""

import copy
import warnings

from mapreduce.lib.graphy import common


class LineStyle(object):

  """Represents the style for a line on a line chart.  Also provides some
  convenient presets.

  Object attributes (Passed directly to the Google Chart API. Check there for
  details):
    width: Width of the line
    on:    Length of a line segment (for dashed/dotted lines)
    off:   Length of a break (for dashed/dotted lines)
    color: Color of the line.  A hex string, like 'ff0000' for red.  Optional,
           AutoColor will fill this in for you automatically if empty.

  Some common styles, such as LineStyle.dashed, are available:
    solid
    dashed
    dotted
    thick_solid
    thick_dashed
    thick_dotted
  """

  # Widths
  THIN = 1
  THICK = 2

  # Patterns
  # ((on, off) tuples, as passed to LineChart.AddLine)
  SOLID = (1, 0)
  DASHED = (8, 4)
  DOTTED = (2, 4)

  def __init__(self, width, on, off, color=None):
    """Construct a LineStyle.  See class docstring for details on args."""
    self.width = width
    self.on = on
    self.off = off
    self.color = color


LineStyle.solid  = LineStyle(1, 1, 0)
LineStyle.dashed = LineStyle(1, 8, 4)
LineStyle.dotted = LineStyle(1, 2, 4)
LineStyle.thick_solid  = LineStyle(2, 1, 0)
LineStyle.thick_dashed = LineStyle(2, 8, 4)
LineStyle.thick_dotted = LineStyle(2, 2, 4)


class LineChart(common.BaseChart):

  """Represents a line chart."""

  def __init__(self, points=None):
    super(LineChart, self).__init__()
    if points is not None:
      self.AddLine(points)

  def AddLine(self, points, label=None, color=None,
              pattern=LineStyle.SOLID, width=LineStyle.THIN, markers=None):
    """Add a new line to the chart.

    This is a convenience method which constructs the DataSeries and appends it
    for you.  It returns the new series.

      points:  List of equally-spaced y-values for the line
      label:   Name of the line (used for the legend)
      color:   Hex string, like 'ff0000' for red
      pattern: Tuple for (length of segment, length of gap).  i.e.
               LineStyle.DASHED
      width:   Width of the line (i.e. LineStyle.THIN)
      markers: List of Marker objects to attach to this line (see DataSeries
               for more info)
    """
    if color is not None and isinstance(color[0], common.Marker):
      warnings.warn('Your code may be broken! '
                    'You passed a list of Markers instead of a color. The '
                    'old argument order (markers before color) is deprecated.',
                    DeprecationWarning, stacklevel=2)
    style = LineStyle(width, pattern[0], pattern[1], color=color)
    series = common.DataSeries(points, label=label, style=style,
                               markers=markers)
    self.data.append(series)
    return series

  def AddSeries(self, points, color=None, style=LineStyle.solid, markers=None,
                label=None):
    """DEPRECATED"""
    warnings.warn('LineChart.AddSeries is deprecated.  Call AddLine instead. ',
                  DeprecationWarning, stacklevel=2)
    return self.AddLine(points, color=color, width=style.width,
                        pattern=(style.on, style.off), markers=markers,
                        label=label)


class Sparkline(LineChart):
  """Represent a sparkline.  These behave like LineCharts,
  mostly, but come without axes.
  """

########NEW FILE########
__FILENAME__ = pie_chart
#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code for pie charts."""

import warnings

from mapreduce.lib.graphy import common
from mapreduce.lib.graphy import util


class Segment(common.DataSeries):
  """A single segment of the pie chart.

  Object attributes:
    size: relative size of the segment
    label: label of the segment (if any)
    color: color of the segment (if any)
  """
  def __init__(self, size, label=None, color=None):
    if label is not None and util._IsColor(label):
      warnings.warn('Your code may be broken! '
                    'Label looks like a hex triplet; it might be a color.  '
                    'The old argument order (color before label) is '
                    'deprecated.',
                    DeprecationWarning, stacklevel=2)
    style = common._BasicStyle(color)
    super(Segment, self).__init__([size], label=label, style=style)
    assert size >= 0

  def _GetSize(self):
    return self.data[0]

  def _SetSize(self, value):
    assert value >= 0
    self.data[0] = value

  size = property(_GetSize, _SetSize,
                  doc = """The relative size of this pie segment.""")

  # Since Segments are so simple, provide color for convenience.
  def _GetColor(self):
    return self.style.color

  def _SetColor(self, color):
    self.style.color = color

  color = property(_GetColor, _SetColor,
                   doc = """The color of this pie segment.""")


class PieChart(common.BaseChart):
  """Represents a pie chart.

  The pie chart consists of a single "pie" by default, but additional pies
  may be added using the AddPie method. The Google Chart API will display
  the pies as concentric circles, with pie #0 on the inside; other backends
  may display the pies differently.
  """

  def __init__(self, points=None, labels=None, colors=None):
    """Constructor for PieChart objects.

    Creates a pie chart with a single pie.

    Args:
      points: A list of data points for the pie chart;
              i.e., relative sizes of the pie segments
      labels: A list of labels for the pie segments.
              TODO: Allow the user to pass in None as one of
              the labels in order to skip that label.
      colors: A list of colors for the pie segments, as hex strings
              (f.ex. '0000ff' for blue). If there are less colors than pie
              segments, the Google Chart API will attempt to produce a smooth
              color transition between segments by spreading the colors across
              them.
    """
    super(PieChart, self).__init__()
    self.formatters = []
    self._colors = None
    if points:
      self.AddPie(points, labels, colors)

  def AddPie(self, points, labels=None, colors=None):
    """Add a whole pie to the chart.

    Args:
      points: A list of pie segment sizes
      labels: A list of labels for the pie segments
      colors: A list of colors for the segments. Missing colors will be chosen
          automatically.
    Return:
      The index of the newly added pie.
    """
    num_colors = len(colors or [])
    num_labels = len(labels or [])
    pie_index = len(self.data)
    self.data.append([])
    for i, pt in enumerate(points):
      label = None
      if i < num_labels:
        label = labels[i]
      color = None
      if i < num_colors:
        color = colors[i]
      self.AddSegment(pt, label=label, color=color, pie_index=pie_index)
    return pie_index

  def AddSegments(self, points, labels, colors):
    """DEPRECATED."""
    warnings.warn('PieChart.AddSegments is deprecated. Call AddPie instead. ',
                  DeprecationWarning, stacklevel=2)
    num_colors = len(colors or [])
    for i, pt in enumerate(points):
      assert pt >= 0
      label = labels[i]
      color = None
      if i < num_colors:
        color = colors[i]
      self.AddSegment(pt, label=label, color=color)

  def AddSegment(self, size, label=None, color=None, pie_index=0):
    """Add a pie segment to this chart, and return the segment.

    size: The size of the segment.
    label: The label for the segment.
    color: The color of the segment, or None to automatically choose the color.
    pie_index: The index of the pie that will receive the new segment.
      By default, the chart has one pie (pie #0); use the AddPie method to
      add more pies.
    """
    if isinstance(size, Segment):
      warnings.warn("AddSegment(segment) is deprecated.  Use AddSegment(size, "
                    "label, color) instead",  DeprecationWarning, stacklevel=2)
      segment = size
    else:
      segment = Segment(size, label=label, color=color)
    assert segment.size >= 0
    if pie_index == 0 and not self.data:
      # Create the default pie
      self.data.append([])
    assert (pie_index >= 0 and pie_index < len(self.data))
    self.data[pie_index].append(segment)
    return segment

  def AddSeries(self, points, color=None, style=None, markers=None, label=None):
    """DEPRECATED

    Add a new segment to the chart and return it.

    The segment must contain exactly one data point; all parameters
    other than color and label are ignored.
    """
    warnings.warn('PieChart.AddSeries is deprecated.  Call AddSegment or '
                  'AddSegments instead.', DeprecationWarning)
    return self.AddSegment(Segment(points[0], color=color, label=label))

  def SetColors(self, *colors):
    """Change the colors of this chart to the specified list of colors.

    Note that this will completely override the individual colors specified
    in the pie segments. Missing colors will be interpolated, so that the
    list of colors covers all segments in all the pies.
    """
    self._colors = colors

########NEW FILE########
__FILENAME__ = util
#!/usr/bin/env python
def _IsColor(color):
  """Try to determine if color is a hex color string.  
  Labels that look like hex colors will match too, unfortunately."""
  if not isinstance(color, basestring):
    return False
  color = color.strip('#')
  if len(color) != 3 and len(color) != 6:
    return False
  hex_letters = '0123456789abcdefABCDEF'
  for letter in color:
    if letter not in hex_letters:
      return False
  return True

########NEW FILE########
__FILENAME__ = decoder
#!/usr/bin/env python
"""Implementation of JSONDecoder
"""
import re
import sys
import struct

from mapreduce.lib.simplejson.scanner import make_scanner
try:
    from mapreduce.lib.simplejson._speedups import scanstring as c_scanstring
except ImportError:
    c_scanstring = None

__all__ = ['JSONDecoder']

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL

def _floatconstants():
    _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
    if sys.byteorder != 'big':
        _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
    nan, inf = struct.unpack('dd', _BYTES)
    return nan, inf, -inf

NaN, PosInf, NegInf = _floatconstants()


def linecol(doc, pos):
    lineno = doc.count('\n', 0, pos) + 1
    if lineno == 1:
        colno = pos
    else:
        colno = pos - doc.rindex('\n', 0, pos)
    return lineno, colno


def errmsg(msg, doc, pos, end=None):
    # Note that this function is called from _speedups
    lineno, colno = linecol(doc, pos)
    if end is None:
        return '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)
    endlineno, endcolno = linecol(doc, end)
    return '%s: line %d column %d - line %d column %d (char %d - %d)' % (
        msg, lineno, colno, endlineno, endcolno, pos, end)


_CONSTANTS = {
    '-Infinity': NegInf,
    'Infinity': PosInf,
    'NaN': NaN,
}

STRINGCHUNK = re.compile(r'(.*?)(["\\\x00-\x1f])', FLAGS)
BACKSLASH = {
    '"': u'"', '\\': u'\\', '/': u'/',
    'b': u'\b', 'f': u'\f', 'n': u'\n', 'r': u'\r', 't': u'\t',
}

DEFAULT_ENCODING = "utf-8"

def py_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
    if encoding is None:
        encoding = DEFAULT_ENCODING
    chunks = []
    _append = chunks.append
    begin = end - 1
    while 1:
        chunk = _m(s, end)
        if chunk is None:
            raise ValueError(
                errmsg("Unterminated string starting at", s, begin))
        end = chunk.end()
        content, terminator = chunk.groups()
        if content:
            if not isinstance(content, unicode):
                content = unicode(content, encoding)
            _append(content)
        if terminator == '"':
            break
        elif terminator != '\\':
            if strict:
                raise ValueError(errmsg("Invalid control character %r at", s, end))
            else:
                _append(terminator)
                continue
        try:
            esc = s[end]
        except IndexError:
            raise ValueError(
                errmsg("Unterminated string starting at", s, begin))
        if esc != 'u':
            try:
                m = _b[esc]
            except KeyError:
                raise ValueError(
                    errmsg("Invalid \\escape: %r" % (esc,), s, end))
            end += 1
        else:
            esc = s[end + 1:end + 5]
            next_end = end + 5
            msg = "Invalid \\uXXXX escape"
            try:
                if len(esc) != 4:
                    raise ValueError
                uni = int(esc, 16)
                if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:
                    msg = "Invalid \\uXXXX\\uXXXX surrogate pair"
                    if not s[end + 5:end + 7] == '\\u':
                        raise ValueError
                    esc2 = s[end + 7:end + 11]
                    if len(esc2) != 4:
                        raise ValueError
                    uni2 = int(esc2, 16)
                    uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
                    next_end += 6
                m = unichr(uni)
            except ValueError:
                raise ValueError(errmsg(msg, s, end))
            end = next_end
        _append(m)
    return u''.join(chunks), end


# Use speedup if available
scanstring = c_scanstring or py_scanstring

WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'

def JSONObject((s, end), encoding, strict, scan_once, object_hook, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
    pairs = {}
    nextchar = s[end:end + 1]
    # Normally we expect nextchar == '"'
    if nextchar != '"':
        if nextchar in _ws:
            end = _w(s, end).end()
            nextchar = s[end:end + 1]
        # Trivial empty object
        if nextchar == '}':
            return pairs, end + 1
        elif nextchar != '"':
            raise ValueError(errmsg("Expecting property name", s, end))
    end += 1
    while True:
        key, end = scanstring(s, end, encoding, strict)

        # To skip some function call overhead we optimize the fast paths where
        # the JSON key separator is ": " or just ":".
        if s[end:end + 1] != ':':
            end = _w(s, end).end()
            if s[end:end + 1] != ':':
                raise ValueError(errmsg("Expecting : delimiter", s, end))

        end += 1

        try:
            if s[end] in _ws:
                end += 1
                if s[end] in _ws:
                    end = _w(s, end + 1).end()
        except IndexError:
            pass

        try:
            value, end = scan_once(s, end)
        except StopIteration:
            raise ValueError(errmsg("Expecting object", s, end))
        pairs[key] = value

        try:
            nextchar = s[end]
            if nextchar in _ws:
                end = _w(s, end + 1).end()
                nextchar = s[end]
        except IndexError:
            nextchar = ''
        end += 1

        if nextchar == '}':
            break
        elif nextchar != ',':
            raise ValueError(errmsg("Expecting , delimiter", s, end - 1))

        try:
            nextchar = s[end]
            if nextchar in _ws:
                end += 1
                nextchar = s[end]
                if nextchar in _ws:
                    end = _w(s, end + 1).end()
                    nextchar = s[end]
        except IndexError:
            nextchar = ''

        end += 1
        if nextchar != '"':
            raise ValueError(errmsg("Expecting property name", s, end - 1))

    if object_hook is not None:
        pairs = object_hook(pairs)
    return pairs, end

def JSONArray((s, end), scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
    values = []
    nextchar = s[end:end + 1]
    if nextchar in _ws:
        end = _w(s, end + 1).end()
        nextchar = s[end:end + 1]
    # Look-ahead for trivial empty array
    if nextchar == ']':
        return values, end + 1
    _append = values.append
    while True:
        try:
            value, end = scan_once(s, end)
        except StopIteration:
            raise ValueError(errmsg("Expecting object", s, end))
        _append(value)
        nextchar = s[end:end + 1]
        if nextchar in _ws:
            end = _w(s, end + 1).end()
            nextchar = s[end:end + 1]
        end += 1
        if nextchar == ']':
            break
        elif nextchar != ',':
            raise ValueError(errmsg("Expecting , delimiter", s, end))

        try:
            if s[end] in _ws:
                end += 1
                if s[end] in _ws:
                    end = _w(s, end + 1).end()
        except IndexError:
            pass

    return values, end

class JSONDecoder(object):
    """Simple JSON <http://json.org> decoder

    Performs the following translations in decoding by default:

    +---------------+-------------------+
    | JSON          | Python            |
    +===============+===================+
    | object        | dict              |
    +---------------+-------------------+
    | array         | list              |
    +---------------+-------------------+
    | string        | unicode           |
    +---------------+-------------------+
    | number (int)  | int, long         |
    +---------------+-------------------+
    | number (real) | float             |
    +---------------+-------------------+
    | true          | True              |
    +---------------+-------------------+
    | false         | False             |
    +---------------+-------------------+
    | null          | None              |
    +---------------+-------------------+

    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as
    their corresponding ``float`` values, which is outside the JSON spec.

    """

    def __init__(self, encoding=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, strict=True):
        """``encoding`` determines the encoding used to interpret any ``str``
        objects decoded by this instance (utf-8 by default).  It has no
        effect when decoding ``unicode`` objects.

        Note that currently only encodings that are a superset of ASCII work,
        strings of other encodings should be passed in as ``unicode``.

        ``object_hook``, if specified, will be called with the result
        of every JSON object decoded and its return value will be used in
        place of the given ``dict``.  This can be used to provide custom
        deserializations (e.g. to support JSON-RPC class hinting).

        ``parse_float``, if specified, will be called with the string
        of every JSON float to be decoded. By default this is equivalent to
        float(num_str). This can be used to use another datatype or parser
        for JSON floats (e.g. decimal.Decimal).

        ``parse_int``, if specified, will be called with the string
        of every JSON int to be decoded. By default this is equivalent to
        int(num_str). This can be used to use another datatype or parser
        for JSON integers (e.g. float).

        ``parse_constant``, if specified, will be called with one of the
        following strings: -Infinity, Infinity, NaN.
        This can be used to raise an exception if invalid JSON numbers
        are encountered.

        """
        self.encoding = encoding
        self.object_hook = object_hook
        self.parse_float = parse_float or float
        self.parse_int = parse_int or int
        self.parse_constant = parse_constant or _CONSTANTS.__getitem__
        self.strict = strict
        self.parse_object = JSONObject
        self.parse_array = JSONArray
        self.parse_string = scanstring
        self.scan_once = make_scanner(self)

    def decode(self, s, _w=WHITESPACE.match):
        """Return the Python representation of ``s`` (a ``str`` or ``unicode``
        instance containing a JSON document)

        """
        obj, end = self.raw_decode(s, idx=_w(s, 0).end())
        end = _w(s, end).end()
        if end != len(s):
            raise ValueError(errmsg("Extra data", s, end, len(s)))
        return obj

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode`` beginning
        with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration:
            raise ValueError("No JSON object could be decoded")
        return obj, end

########NEW FILE########
__FILENAME__ = encoder
#!/usr/bin/env python
"""Implementation of JSONEncoder
"""
import re

try:
    from mapreduce.lib.simplejson._speedups import encode_basestring_ascii as c_encode_basestring_ascii
except ImportError:
    c_encode_basestring_ascii = None
try:
    from mapreduce.lib.simplejson._speedups import make_encoder as c_make_encoder
except ImportError:
    c_make_encoder = None

ESCAPE = re.compile(r'[\x00-\x1f\\"\b\f\n\r\t]')
ESCAPE_ASCII = re.compile(r'([\\"]|[^\ -~])')
HAS_UTF8 = re.compile(r'[\x80-\xff]')
ESCAPE_DCT = {
    '\\': '\\\\',
    '"': '\\"',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
}
for i in range(0x20):
    ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))

# Assume this produces an infinity on all machines (probably not guaranteed)
INFINITY = float('1e66666')
FLOAT_REPR = repr

def encode_basestring(s):
    """Return a JSON representation of a Python string

    """
    def replace(match):
        return ESCAPE_DCT[match.group(0)]
    return '"' + ESCAPE.sub(replace, s) + '"'


def py_encode_basestring_ascii(s):
    if isinstance(s, str) and HAS_UTF8.search(s) is not None:
        s = s.decode('utf-8')
    def replace(match):
        s = match.group(0)
        try:
            return ESCAPE_DCT[s]
        except KeyError:
            n = ord(s)
            if n < 0x10000:
                return '\\u%04x' % (n,)
            else:
                # surrogate pair
                n -= 0x10000
                s1 = 0xd800 | ((n >> 10) & 0x3ff)
                s2 = 0xdc00 | (n & 0x3ff)
                return '\\u%04x\\u%04x' % (s1, s2)
    return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'


encode_basestring_ascii = c_encode_basestring_ascii or py_encode_basestring_ascii

class JSONEncoder(object):
    """Extensible JSON <http://json.org> encoder for Python data structures.

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict              | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str, unicode      | string        |
    +-------------------+---------------+
    | int, long, float  | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+

    To extend this to recognize other objects, subclass and implement a
    ``.default()`` method with another method that returns a serializable
    object for ``o`` if possible, otherwise it should call the superclass
    implementation (to raise ``TypeError``).

    """
    item_separator = ', '
    key_separator = ': '
    def __init__(self, skipkeys=False, ensure_ascii=True,
            check_circular=True, allow_nan=True, sort_keys=False,
            indent=None, separators=None, encoding='utf-8', default=None):
        """Constructor for JSONEncoder, with sensible defaults.

        If skipkeys is False, then it is a TypeError to attempt
        encoding of keys that are not str, int, long, float or None.  If
        skipkeys is True, such items are simply skipped.

        If ensure_ascii is True, the output is guaranteed to be str
        objects with all incoming unicode characters escaped.  If
        ensure_ascii is false, the output will be unicode object.

        If check_circular is True, then lists, dicts, and custom encoded
        objects will be checked for circular references during encoding to
        prevent an infinite recursion (which would cause an OverflowError).
        Otherwise, no such check takes place.

        If allow_nan is True, then NaN, Infinity, and -Infinity will be
        encoded as such.  This behavior is not JSON specification compliant,
        but is consistent with most JavaScript based encoders and decoders.
        Otherwise, it will be a ValueError to encode such floats.

        If sort_keys is True, then the output of dictionaries will be
        sorted by key; this is useful for regression tests to ensure
        that JSON serializations can be compared on a day-to-day basis.

        If indent is a non-negative integer, then JSON array
        elements and object members will be pretty-printed with that
        indent level.  An indent level of 0 will only insert newlines.
        None is the most compact representation.

        If specified, separators should be a (item_separator, key_separator)
        tuple.  The default is (', ', ': ').  To get the most compact JSON
        representation you should specify (',', ':') to eliminate whitespace.

        If specified, default is a function that gets called for objects
        that can't otherwise be serialized.  It should return a JSON encodable
        version of the object or raise a ``TypeError``.

        If encoding is not None, then all input strings will be
        transformed into unicode using that encoding prior to JSON-encoding.
        The default is UTF-8.

        """

        self.skipkeys = skipkeys
        self.ensure_ascii = ensure_ascii
        self.check_circular = check_circular
        self.allow_nan = allow_nan
        self.sort_keys = sort_keys
        self.indent = indent
        if separators is not None:
            self.item_separator, self.key_separator = separators
        if default is not None:
            self.default = default
        self.encoding = encoding

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                return JSONEncoder.default(self, o)

        """
        raise TypeError("%r is not JSON serializable" % (o,))

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.

        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'

        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, basestring):
            if isinstance(o, str):
                _encoding = self.encoding
                if (_encoding is not None
                        and not (_encoding == 'utf-8')):
                    o = o.decode(_encoding)
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
        chunks = self.iterencode(o, _one_shot=True)
        if not isinstance(chunks, (list, tuple)):
            chunks = list(chunks)
        return ''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.

        For example::

            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)

        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
        if self.encoding != 'utf-8':
            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
                if isinstance(o, str):
                    o = o.decode(_encoding)
                return _orig_encoder(o)

        def floatstr(o, allow_nan=self.allow_nan, _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):
            # Check for specials.  Note that this type of test is processor- and/or
            # platform-specific, so do tests which don't depend on the internals.

            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)

            if not allow_nan:
                raise ValueError("Out of range float values are not JSON compliant: %r"
                    % (o,))

            return text


        if _one_shot and c_make_encoder is not None and not self.indent and not self.sort_keys:
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot)
        return _iterencode(o, 0)

def _make_iterencode(markers, _default, _encoder, _indent, _floatstr, _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,
        ## HACK: hand-optimized bytecode; turn globals into locals
        False=False,
        True=True,
        ValueError=ValueError,
        basestring=basestring,
        dict=dict,
        float=float,
        id=id,
        int=int,
        isinstance=isinstance,
        list=list,
        long=long,
        str=str,
        tuple=tuple,
    ):

    def _iterencode_list(lst, _current_indent_level):
        if not lst:
            yield '[]'
            return
        if markers is not None:
            markerid = id(lst)
            if markerid in markers:
                raise ValueError("Circular reference detected")
            markers[markerid] = lst
        buf = '['
        if _indent is not None:
            _current_indent_level += 1
            newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
            separator = _item_separator + newline_indent
            buf += newline_indent
        else:
            newline_indent = None
            separator = _item_separator
        first = True
        for value in lst:
            if first:
                first = False
            else:
                buf = separator
            if isinstance(value, basestring):
                yield buf + _encoder(value)
            elif value is None:
                yield buf + 'null'
            elif value is True:
                yield buf + 'true'
            elif value is False:
                yield buf + 'false'
            elif isinstance(value, (int, long)):
                yield buf + str(value)
            elif isinstance(value, float):
                yield buf + _floatstr(value)
            else:
                yield buf
                if isinstance(value, (list, tuple)):
                    chunks = _iterencode_list(value, _current_indent_level)
                elif isinstance(value, dict):
                    chunks = _iterencode_dict(value, _current_indent_level)
                else:
                    chunks = _iterencode(value, _current_indent_level)
                for chunk in chunks:
                    yield chunk
        if newline_indent is not None:
            _current_indent_level -= 1
            yield '\n' + (' ' * (_indent * _current_indent_level))
        yield ']'
        if markers is not None:
            del markers[markerid]

    def _iterencode_dict(dct, _current_indent_level):
        if not dct:
            yield '{}'
            return
        if markers is not None:
            markerid = id(dct)
            if markerid in markers:
                raise ValueError("Circular reference detected")
            markers[markerid] = dct
        yield '{'
        if _indent is not None:
            _current_indent_level += 1
            newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
            item_separator = _item_separator + newline_indent
            yield newline_indent
        else:
            newline_indent = None
            item_separator = _item_separator
        first = True
        if _sort_keys:
            items = dct.items()
            items.sort(key=lambda kv: kv[0])
        else:
            items = dct.iteritems()
        for key, value in items:
            if isinstance(key, basestring):
                pass
            # JavaScript is weakly typed for these, so it makes sense to
            # also allow them.  Many encoders seem to do something like this.
            elif isinstance(key, float):
                key = _floatstr(key)
            elif isinstance(key, (int, long)):
                key = str(key)
            elif key is True:
                key = 'true'
            elif key is False:
                key = 'false'
            elif key is None:
                key = 'null'
            elif _skipkeys:
                continue
            else:
                raise TypeError("key %r is not a string" % (key,))
            if first:
                first = False
            else:
                yield item_separator
            yield _encoder(key)
            yield _key_separator
            if isinstance(value, basestring):
                yield _encoder(value)
            elif value is None:
                yield 'null'
            elif value is True:
                yield 'true'
            elif value is False:
                yield 'false'
            elif isinstance(value, (int, long)):
                yield str(value)
            elif isinstance(value, float):
                yield _floatstr(value)
            else:
                if isinstance(value, (list, tuple)):
                    chunks = _iterencode_list(value, _current_indent_level)
                elif isinstance(value, dict):
                    chunks = _iterencode_dict(value, _current_indent_level)
                else:
                    chunks = _iterencode(value, _current_indent_level)
                for chunk in chunks:
                    yield chunk
        if newline_indent is not None:
            _current_indent_level -= 1
            yield '\n' + (' ' * (_indent * _current_indent_level))
        yield '}'
        if markers is not None:
            del markers[markerid]

    def _iterencode(o, _current_indent_level):
        if isinstance(o, basestring):
            yield _encoder(o)
        elif o is None:
            yield 'null'
        elif o is True:
            yield 'true'
        elif o is False:
            yield 'false'
        elif isinstance(o, (int, long)):
            yield str(o)
        elif isinstance(o, float):
            yield _floatstr(o)
        elif isinstance(o, (list, tuple)):
            for chunk in _iterencode_list(o, _current_indent_level):
                yield chunk
        elif isinstance(o, dict):
            for chunk in _iterencode_dict(o, _current_indent_level):
                yield chunk
        else:
            if markers is not None:
                markerid = id(o)
                if markerid in markers:
                    raise ValueError("Circular reference detected")
                markers[markerid] = o
            o = _default(o)
            for chunk in _iterencode(o, _current_indent_level):
                yield chunk
            if markers is not None:
                del markers[markerid]

    return _iterencode

########NEW FILE########
__FILENAME__ = scanner
#!/usr/bin/env python
"""JSON token scanner
"""
import re
try:
    from mapreduce.lib.simplejson._speedups import make_scanner as c_make_scanner
except ImportError:
    c_make_scanner = None

__all__ = ['make_scanner']

NUMBER_RE = re.compile(
    r'(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?',
    (re.VERBOSE | re.MULTILINE | re.DOTALL))

def py_make_scanner(context):
    parse_object = context.parse_object
    parse_array = context.parse_array
    parse_string = context.parse_string
    match_number = NUMBER_RE.match
    encoding = context.encoding
    strict = context.strict
    parse_float = context.parse_float
    parse_int = context.parse_int
    parse_constant = context.parse_constant
    object_hook = context.object_hook

    def _scan_once(string, idx):
        try:
            nextchar = string[idx]
        except IndexError:
            raise StopIteration

        if nextchar == '"':
            return parse_string(string, idx + 1, encoding, strict)
        elif nextchar == '{':
            return parse_object((string, idx + 1), encoding, strict, _scan_once, object_hook)
        elif nextchar == '[':
            return parse_array((string, idx + 1), _scan_once)
        elif nextchar == 'n' and string[idx:idx + 4] == 'null':
            return None, idx + 4
        elif nextchar == 't' and string[idx:idx + 4] == 'true':
            return True, idx + 4
        elif nextchar == 'f' and string[idx:idx + 5] == 'false':
            return False, idx + 5

        m = match_number(string, idx)
        if m is not None:
            integer, frac, exp = m.groups()
            if frac or exp:
                res = parse_float(integer + (frac or '') + (exp or ''))
            else:
                res = parse_int(integer)
            return res, m.end()
        elif nextchar == 'N' and string[idx:idx + 3] == 'NaN':
            return parse_constant('NaN'), idx + 3
        elif nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
            return parse_constant('Infinity'), idx + 8
        elif nextchar == '-' and string[idx:idx + 9] == '-Infinity':
            return parse_constant('-Infinity'), idx + 9
        else:
            raise StopIteration

    return _scan_once

make_scanner = c_make_scanner or py_make_scanner

########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Main module for map-reduce implementation.

This module should be specified as a handler for mapreduce URLs in app.yaml:

  handlers:
  - url: /mapreduce(/.*)?
    login: admin
    script: mapreduce/main.py
"""



import wsgiref.handlers

from google.appengine.ext import webapp
from google.appengine.ext.webapp import util
from mapreduce import handlers
from mapreduce import status


class RedirectHandler(webapp.RequestHandler):
  """Redirects the user back to the status page."""

  def get(self):
    new_path = self.request.path
    if not new_path.endswith('/'):
      new_path += '/'
    new_path += 'status'
    self.redirect(new_path)


def create_application():
  """Create new WSGIApplication and register all handlers.

  Returns:
    an instance of webapp.WSGIApplication with all mapreduce handlers
    registered.
  """
  return webapp.WSGIApplication([

      # Task queue handlers.
      (r".*/worker_callback", handlers.MapperWorkerCallbackHandler),
      (r".*/controller_callback", handlers.ControllerCallbackHandler),
      (r".*/kickoffjob_callback", handlers.KickOffJobHandler),

      # RPC requests with JSON responses
      (r".*/command/start_job", handlers.StartJobHandler),
      (r".*/command/cleanup_job", handlers.CleanUpJobHandler),
      (r".*/command/abort_job", handlers.AbortJobHandler),
      (r".*/command/list_configs", status.ListConfigsHandler),
      (r".*/command/list_jobs", status.ListJobsHandler),
      (r".*/command/get_job_detail", status.GetJobDetailHandler),

      # Catch all redirects to status page.
      (r"/[^/]+(?:/)?", RedirectHandler),

      # UI static files
      (r".+/([a-zA-Z0-9]+(?:\.(?:css|js))?)", status.ResourceHandler),
  ],
  debug=True)


APP = create_application()


def main():
  util.run_wsgi_app(APP)


if __name__ == "__main__":
  main()

########NEW FILE########
__FILENAME__ = model
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Model classes which are used to communicate between parts of implementation.

These model classes are describing mapreduce, its current state and
communication messages. They are either stored in the datastore or
serialized to/from json and passed around with other means.
"""

# Disable "Invalid method name"
# pylint: disable-msg=C6409



__all__ = ["JsonMixin", "JsonProperty", "MapreduceState", "MapperSpec",
           "MapreduceControl", "MapreduceSpec", "ShardState", "CountersMap"]

import copy
import datetime
import logging
import math
import random
from mapreduce.lib import simplejson
import time
import types

from google.appengine.api import datastore_errors
from google.appengine.api import datastore_types
from google.appengine.ext import db
from mapreduce import context
from mapreduce import util
from mapreduce.lib.graphy.backends import google_chart_api


# Default rate of processed entities per second.
_DEFAULT_PROCESSING_RATE_PER_SEC = 100

# Default number of shards to have.
_DEFAULT_SHARD_COUNT = 8


class JsonMixin(object):
  """Simple, stateless json utilities mixin.

  Requires class to implement two methods:
    to_json(self): convert data to json-compatible datastructure (dict,
      list, strings, numbers)
    @classmethod from_json(cls, json): load data from json-compatible structure.
  """

  def to_json_str(self):
    """Convert data to json string representation.

    Returns:
      json representation as string.
    """
    return simplejson.dumps(self.to_json(), sort_keys=True)

  @classmethod
  def from_json_str(cls, json_str):
    """Convert json string representation into class instance.

    Args:
      json_str: json representation as string.

    Returns:
      New instance of the class with data loaded from json string.
    """
    return cls.from_json(simplejson.loads(json_str))


class JsonProperty(db.UnindexedProperty):
  """Property type for storing json representation of data.

  Requires data types to implement two methods:
    to_json(self): convert data to json-compatible datastructure (dict,
      list, strings, numbers)
    @classmethod from_json(cls, json): load data from json-compatible structure.
  """

  def __init__(self, data_type, default=None, **kwargs):
    """Constructor.

    Args:
      data_type: underlying data type as class.
      default: default value for the property. The value is deep copied
        fore each model instance.
      kwargs: remaining arguments.
    """
    kwargs["default"] = default
    super(JsonProperty, self).__init__(**kwargs)
    self.data_type = data_type

  def get_value_for_datastore(self, model_instance):
    """Gets value for datastore.

    Args:
      model_instance: instance of the model class.

    Returns:
      datastore-compatible value.
    """
    value = super(JsonProperty, self).get_value_for_datastore(model_instance)
    if not value:
      return None
    return datastore_types.Text(simplejson.dumps(
        value.to_json(), sort_keys=True))

  def make_value_from_datastore(self, value):
    """Convert value from datastore representation.

    Args:
      value: datastore value.

    Returns:
      value to store in the model.
    """

    if value is None:
      return None
    return self.data_type.from_json(simplejson.loads(value))

  def validate(self, value):
    """Validate value.

    Args:
      value: model value.

    Returns:
      Whether the specified value is valid data type value.

    Raises:
      BadValueError: when value is not of self.data_type type.
    """
    if value is not None and not isinstance(value, self.data_type):
      raise datastore_errors.BadValueError(
          "Property %s must be convertible to a %s instance (%s)" %
          (self.name, self.data_type, value))
    return super(JsonProperty, self).validate(value)

  def empty(self, value):
    """Checks if value is empty.

    Args:
      value: model value.

    Returns:
      True passed value is empty.
    """
    return not value

  def default_value(self):
    """Create default model value.

    If default option was specified, then it will be deeply copied.
    None otherwise.

    Returns:
      default model value.
    """
    if self.default:
      return copy.deepcopy(self.default)
    else:
      return None



# Ridiculous future UNIX epoch time, 500 years from now.
_FUTURE_TIME = 2**34


def _get_descending_key(gettime=time.time, getrandint=random.randint):
  """Returns a key name lexically ordered by time descending.

  This lets us have a key name for use with Datastore entities which returns
  rows in time descending order when it is scanned in lexically ascending order,
  allowing us to bypass index building for descending indexes.

  Args:
    gettime: Used for testing.
    getrandint: Used for testing.

  Returns:
    A string with a time descending key.
  """
  now_descending = int((_FUTURE_TIME - gettime()) * 100)
  tie_breaker = getrandint(0, 100)
  return "%d%d" % (now_descending, tie_breaker)


class CountersMap(JsonMixin):
  """Maintains map from counter name to counter value.

  The class is used to provide basic arithmetics of counter values (buil
  add/remove), increment individual values and store/load data from json.
  """

  def __init__(self, initial_map=None):
    """Constructor.

    Args:
      initial_map: initial counter values map from counter name (string) to
        counter value (int).
    """
    if initial_map:
      self.counters = initial_map
    else:
      self.counters = {}

  def __repr__(self):
    """Compute string representation."""
    return "mapreduce.model.CountersMap(%r)" % self.counters

  def get(self, counter_name):
    """Get current counter value.

    Args:
      counter_name: counter name as string.

    Returns:
      current counter value as int. 0 if counter was not set.
    """
    return self.counters.get(counter_name, 0)

  def increment(self, counter_name, delta):
    """Increment counter value.

    Args:
      counter_name: counter name as String.
      delta: increment delta as Integer.

    Returns:
      new counter value.
    """
    current_value = self.counters.get(counter_name, 0)
    new_value = current_value + delta
    self.counters[counter_name] = new_value
    return new_value

  def add_map(self, counters_map):
    """Add all counters from the map.

    For each counter in the passed map, adds its value to the counter in this
    map.

    Args:
      counters_map: CounterMap instance to add.
    """
    for counter_name in counters_map.counters:
      self.increment(counter_name, counters_map.counters[counter_name])

  def sub_map(self, counters_map):
    """Subtracts all counters from the map.

    For each counter in the passed map, subtracts its value to the counter in
    this map.

    Args:
      counters_map: CounterMap instance to subtract.
    """
    for counter_name in counters_map.counters:
      self.increment(counter_name, -counters_map.counters[counter_name])

  def clear(self):
    """Clear all values."""
    self.counters = {}

  def to_json(self):
    """Serializes all the data in this map into json form.

    Returns:
      json-compatible data representation.
    """
    return {"counters": self.counters}

  @classmethod
  def from_json(cls, json):
    """Create new CountersMap from the json data structure, encoded by to_json.

    Args:
      json: json representation of CountersMap .

    Returns:
      an instance of CountersMap with all data deserialized from json.
    """
    counters_map = cls()
    counters_map.counters = json["counters"]
    return counters_map


class MapperSpec(JsonMixin):
  """Contains a specification for the mapper phase of the mapreduce.

  MapperSpec instance can be changed only during mapreduce starting process,
  and it remains immutable for the rest of mapreduce execution. MapperSpec is
  passed as a payload to all mapreduce tasks in JSON encoding as part of
  MapreduceSpec.

  Specifying mapper handlers:
    * '<module_name>.<class_name>' - __call__ method of class instance will be
      called
    * '<module_name>.<function_name>' - function will be called.
    * '<module_name>.<class_name>.<method_name>' - class will be instantiated
      and method called.
  """

  def __init__(self, handler_spec, input_reader_spec, params, shard_count):
    """Creates a new MapperSpec.

    Args:
      handler_spec: handler specification as string (see class doc for
        details).
      input_reader_spec: The class name of the input reader to use.
      params: Dictionary of additional parameters for the mapper.
      shard_count: number of shards to process in parallel.

    Properties:
      handler_spec: name of handler class/function to use.
      shard_count: number of shards to process in parallel.
      handler: cached instance of mapper handler as callable.
      input_reader_spec: The class name of the input reader to use.
      params: Dictionary of additional parameters for the mapper.
    """
    self.handler_spec = handler_spec
    self.__handler = None
    self.input_reader_spec = input_reader_spec
    self.shard_count = shard_count
    self.params = params

  def get_handler(self):
    """Get mapper handler instance.

    Returns:
      cached handler instance as callable.
    """
    if self.__handler is None:
      resolved_spec = util.for_name(self.handler_spec)
      if isinstance(resolved_spec, type):
        # create new instance if this is type
        self.__handler = resolved_spec()
      elif isinstance(resolved_spec, types.MethodType):
        # bind the method
        self.__handler = getattr(resolved_spec.im_class(),
                                 resolved_spec.__name__)
      else:
        self.__handler = resolved_spec
    return self.__handler

  handler = property(get_handler)

  def input_reader_class(self):
    """Get input reader class.

    Returns:
      input reader class object.
    """
    return util.for_name(self.input_reader_spec)

  def to_json(self):
    """Serializes this MapperSpec into a json-izable object."""
    return {
        "mapper_handler_spec": self.handler_spec,
        "mapper_input_reader": self.input_reader_spec,
        "mapper_params": self.params,
        "mapper_shard_count": self.shard_count,
    }

  @classmethod
  def from_json(cls, json):
    """Creates MapperSpec from a dict-like object."""
    return cls(json["mapper_handler_spec"],
               json["mapper_input_reader"],
               json["mapper_params"],
               json["mapper_shard_count"])


class MapreduceSpec(JsonMixin):
  """Contains a specification for the whole mapreduce.

  MapreduceSpec instance can be changed only during mapreduce starting process,
  and it remains immutable for the rest of mapreduce execution. MapreduceSpec is
  passed as a payload to all mapreduce tasks in json encoding.
  """

  # Url to call when mapreduce finishes its execution.
  PARAM_DONE_CALLBACK = "done_callback"
  # Queue to use to call done callback
  PARAM_DONE_CALLBACK_QUEUE = "done_callback_queue"

  def __init__(self,
               name,
               mapreduce_id,
               mapper_spec,
               params = {}):
    """Create new MapreduceSpec.

    Args:
      name: The name of this mapreduce job type.
      mapreduce_id: ID of the mapreduce.
      mapper_spec: JSON-encoded string containing a MapperSpec.
      params: dictionary of additional mapreduce parameters.

    Properties:
      name: The name of this mapreduce job type.
      mapreduce_id: unique id of this mapreduce as string.
      mapper: This MapreduceSpec's instance of MapperSpec.
      params: dictionary of additional mapreduce parameters.
    """
    self.name = name
    self.mapreduce_id = mapreduce_id
    self.mapper = MapperSpec.from_json(mapper_spec)
    self.params = params

  def to_json(self):
    """Serializes all data in this mapreduce spec into json form.

    Returns:
      data in json format.
    """
    mapper_spec = self.mapper.to_json()
    return {
        "name": self.name,
        "mapreduce_id": self.mapreduce_id,
        "mapper_spec": mapper_spec,
        "params": self.params,
    }

  @classmethod
  def from_json(cls, json):
    """Create new MapreduceSpec from the json, encoded by to_json.

    Args:
      json: json representation of MapreduceSpec.

    Returns:
      an instance of MapreduceSpec with all data deserialized from json.
    """
    mapreduce_spec = cls(json["name"],
                         json["mapreduce_id"],
                         json["mapper_spec"],
                         json.get("params"))
    return mapreduce_spec


class MapreduceState(db.Model):
  """Holds accumulated state of mapreduce execution.

  MapreduceState is stored in datastore with a key name equal to the
  mapreduce ID. Only controller tasks can write to MapreduceState.

  Properties:
    mapreduce_spec: cached deserialized MapreduceSpec instance. read-only
    active: if we have this mapreduce running right now
    last_poll_time: last time controller job has polled this mapreduce.
    counters_map: shard's counters map as CountersMap. Mirrors
      counters_map_json.
    chart_url: last computed mapreduce status chart url. This chart displays the
      progress of all the shards the best way it can.
    sparkline_url: last computed mapreduce status chart url in small format.
    result_status: If not None, the final status of the job.
    active_shards: How many shards are still processing.
    start_time: When the job started.
  """

  RESULT_SUCCESS = "success"
  RESULT_FAILED = "failed"
  RESULT_ABORTED = "aborted"

  _RESULTS = frozenset([RESULT_SUCCESS, RESULT_FAILED, RESULT_ABORTED])

  # Functional properties.
  mapreduce_spec = JsonProperty(MapreduceSpec, indexed=False)
  active = db.BooleanProperty(default=True, indexed=False)
  last_poll_time = db.DateTimeProperty(required=True)
  counters_map = JsonProperty(CountersMap, default=CountersMap(), indexed=False)
  app_id = db.StringProperty(required=False, indexed=True)

  # For UI purposes only.
  chart_url = db.TextProperty(default="")
  sparkline_url = db.TextProperty(default="")
  result_status = db.StringProperty(required=False, choices=_RESULTS)
  active_shards = db.IntegerProperty(default=0, indexed=False)
  failed_shards = db.IntegerProperty(default=0, indexed=False)
  aborted_shards = db.IntegerProperty(default=0, indexed=False)
  start_time = db.DateTimeProperty(auto_now_add=True)

  @classmethod
  def get_key_by_job_id(cls, mapreduce_id):
    """Retrieves the Key for a Job.

    Args:
      mapreduce_id: The job to retrieve.

    Returns:
      Datastore Key that can be used to fetch the MapreduceState.
    """
    return db.Key.from_path(cls.kind(), mapreduce_id)

  def set_processed_counts(self, shards_processed):
    """Updates a chart url to display processed count for each shard.

    Args:
      shards_processed: list of integers with number of processed entities in
        each shard
    """
    chart = google_chart_api.BarChart(shards_processed)
    if self.mapreduce_spec and shards_processed:
      chart.bottom.labels = [
          str(x) for x in xrange(self.mapreduce_spec.mapper.shard_count)]
      chart.left.labels = ['0', str(max(shards_processed))]
      chart.left.min = 0
    self.chart_url = chart.display.Url(300, 200)

  def get_processed(self):
    """Number of processed entities.

    Returns:
      The total number of processed entities as int.
    """
    return self.counters_map.get(context.COUNTER_MAPPER_CALLS)

  processed = property(get_processed)

  @staticmethod
  def create_new(getkeyname=_get_descending_key,
                 gettime=datetime.datetime.now):
    """Create a new MapreduceState.

    Args:
      getkeyname: Used for testing.
      gettime: Used for testing.
    """
    state = MapreduceState(key_name=getkeyname(),
                           last_poll_time=gettime())
    state.set_processed_counts([])
    return state


class ShardState(db.Model):
  """Single shard execution state.

  The shard state is stored in the datastore and is later aggregated by
  controller task. Shard key_name is equal to shard_id.

  Properties:
    active: if we have this shard still running as boolean.
    counters_map: shard's counters map as CountersMap. Mirrors
      counters_map_json.
    mapreduce_id: unique id of the mapreduce.
    shard_id: unique id of this shard as string.
    shard_number: ordered number for this shard.
    result_status: If not None, the final status of this shard.
    update_time: The last time this shard state was updated.
    shard_description: A string description of the work this shard will do.
    last_work_item: A string description of the last work item processed.
  """

  RESULT_SUCCESS = "success"
  RESULT_FAILED = "failed"
  RESULT_ABORTED = "aborted"

  _RESULTS = frozenset([RESULT_SUCCESS, RESULT_FAILED, RESULT_ABORTED])

  # Functional properties.
  active = db.BooleanProperty(default=True, indexed=False)
  counters_map = JsonProperty(CountersMap, default=CountersMap(), indexed=False)
  result_status = db.StringProperty(choices=_RESULTS, indexed=False)

  # For UI purposes only.
  mapreduce_id = db.StringProperty(required=True)
  update_time = db.DateTimeProperty(auto_now=True, indexed=False)
  shard_description = db.TextProperty(default="")
  last_work_item = db.TextProperty(default="")

  def get_shard_number(self):
    """Gets the shard number from the key name."""
    return int(self.key().name().split("-")[-1])

  shard_number = property(get_shard_number)

  def get_shard_id(self):
    """Returns the shard ID."""
    return self.key().name()

  shard_id = property(get_shard_id)

  @classmethod
  def shard_id_from_number(cls, mapreduce_id, shard_number):
    """Get shard id by mapreduce id and shard number.

    Args:
      mapreduce_id: mapreduce id as string.
      shard_number: shard number to compute id for as int.

    Returns:
      shard id as string.
    """
    return "%s-%d" % (mapreduce_id, shard_number)

  @classmethod
  def get_key_by_shard_id(cls, shard_id):
    """Retrieves the Key for this ShardState.

    Args:
      shard_id: The shard ID to fetch.

    Returns:
      The Datatore key to use to retrieve this ShardState.
    """
    return db.Key.from_path(cls.kind(), shard_id)

  @classmethod
  def get_by_shard_id(cls, shard_id):
    """Get shard state from datastore by shard_id.

    Args:
      shard_id: shard id as string.

    Returns:
      ShardState for given shard id or None if it's not found.
    """
    return cls.get_by_key_name(shard_id)

  @classmethod
  def find_by_mapreduce_id(cls, mapreduce_id):
    """Find all shard states for given mapreduce.

    Args:
      mapreduce_id: mapreduce id.

    Returns:
      iterable of all ShardState for given mapreduce id.
    """
    return cls.all().filter("mapreduce_id =", mapreduce_id).fetch(99999)

  @classmethod
  def create_new(cls, mapreduce_id, shard_number):
    """Create new shard state.

    Args:
      mapreduce_id: unique mapreduce id as string.
      shard_number: shard number for which to create shard state.

    Returns:
      new instance of ShardState ready to put into datastore.
    """
    shard_id = cls.shard_id_from_number(mapreduce_id, shard_number)
    state = cls(key_name=shard_id,
                mapreduce_id=mapreduce_id)
    return state


class MapreduceControl(db.Model):
  """Datastore entity used to control mapreduce job execution.

  Only one command may be sent to jobs at a time.

  Properties:
    command: The command to send to the job.
  """

  ABORT = "abort"

  _COMMANDS = frozenset([ABORT])
  _KEY_NAME = "command"

  command = db.TextProperty(choices=_COMMANDS, required=True)

  @classmethod
  def get_key_by_job_id(cls, mapreduce_id):
    """Retrieves the Key for a mapreduce ID.

    Args:
      mapreduce_id: The job to fetch.

    Returns:
      Datastore Key for the command for the given job ID.
    """
    return db.Key.from_path(cls.kind(), "%s:%s" % (mapreduce_id, cls._KEY_NAME))

  @classmethod
  def abort(cls, mapreduce_id):
    """Causes a job to abort.

    Args:
      mapreduce_id: The job to abort. Not verified as a valid job.
    """
    cls(key_name="%s:%s" % (mapreduce_id, cls._KEY_NAME),
        command=cls.ABORT).put()

########NEW FILE########
__FILENAME__ = counters
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Counters-related operations."""



__all__ = ['Increment']


class Increment(object):
  """Increment counter operation."""

  def __init__(self, counter_name, delta=1):
    """Constructor.

    Args:
      counter_name: name of the counter as string
      delta: increment delta as int.
    """
    self.counter_name = counter_name
    self.delta = delta

  def __call__(self, context):
    """Execute operation.

    Args:
      context: mapreduce context as context.Context.
    """
    context.counters.increment(self.counter_name, self.delta)

########NEW FILE########
__FILENAME__ = db
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""DB-related operations."""



__all__ = ['Put', 'Delete']


# TODO(user): handler function annotation which requests to
# use db calls directly without batching them/doing async db calls.
class Put(object):
  """Put entity into datastore via mutation_pool.

  See mapreduce.context.MutationPool.
  """

  def __init__(self, entity):
    """Constructor.

    Args:
      entity: an entity to put.
    """
    self.entity = entity

  def __call__(self, context):
    """Perform operation.

    Args:
      context: mapreduce context as context.Context.
    """
    context.mutation_pool.put(self.entity)


class Delete(object):
  """Delete entity from datastore via mutation_pool.

  See mapreduce.context.MutationPool.
  """

  def __init__(self, entity):
    """Constructor.

    Args:
      entity: a key or model instance to delete.
    """
    self.entity = entity

  def __call__(self, context):
    """Perform operation.

    Args:
      context: mapreduce context as context.Context.
    """
    context.mutation_pool.delete(self.entity)

########NEW FILE########
__FILENAME__ = quota
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Simple quota system backed by memcache storage."""




# Memcache namespace to use.
_QUOTA_NAMESPACE = "quota"

# Offset all quota values by this amount since memcache incr/decr
# operate only with unsigned values.
_OFFSET = 2**32


class QuotaManager(object):
  """Simple quota system manager, backed by memcache storage.

  Since memcache storage is not reliable, this quota system is not reliable and
  best effort only.

  Quota is managed by buckets. Each bucket contains a 32-bit int value of
  available quota. Buckets should be refilled manually with 'put' method.

  It is safe to use a single bucket from multiple clients simultaneously.
  """

  def __init__(self, memcache_client):
    """Initialize new instance.

    Args:
      memcache_client: an instance of memcache client to use.
    """
    self.memcache_client = memcache_client

  def put(self, bucket, amount):
    """Put amount into quota bucket.

    Args:
      bucket: quota bucket as string.
      amount: amount to bit put into quota as int.
    """
    self.memcache_client.incr(bucket, delta=amount,
                              initial_value=_OFFSET, namespace=_QUOTA_NAMESPACE)

  def consume(self, bucket, amount, consume_some=False):
    """Consume amount from quota bucket.

    Args:
      bucket: quota bucket as string.
      amount: amount to consume.
      consume_some: specifies behavior in case of not enough quota. If False,
        the method will leave quota intact and return 0. If True, will try to
        consume as much as possible.

    Returns:
      Amount of quota consumed.
    """
    new_quota = self.memcache_client.decr(
        bucket, delta=amount, initial_value=_OFFSET, namespace=_QUOTA_NAMESPACE)

    if new_quota >= _OFFSET:
      return amount

    if consume_some and _OFFSET - new_quota < amount:
      # we still can consume some
      self.put(bucket, _OFFSET - new_quota)
      return amount - (_OFFSET - new_quota)
    else:
      self.put(bucket, amount)
      return 0

  def get(self, bucket):
    """Get current bucket amount.

    Args:
      bucket: quota bucket as string.

    Returns:
      current bucket amount as int.
    """
    amount = self.memcache_client.get(bucket, namespace=_QUOTA_NAMESPACE)
    if amount:
      return int(amount) - _OFFSET
    else:
      return 0

  def set(self, bucket, amount):
    """Set bucket amount.

    Args:
      bucket: quota bucket as string.
      amount: new bucket amount as int.
    """
    self.memcache_client.set(bucket, amount + _OFFSET,
                             namespace=_QUOTA_NAMESPACE)


class QuotaConsumer(object):
  """Quota consumer wrapper for efficient quota consuming/reclaiming.

  Quota is consumed in batches and put back in dispose() method.

  WARNING: Always call the dispose() method if you need to keep quota
  consistent.
  """

  def __init__(self, quota_manager, bucket, batch_size):
    """Initialize new instance.

    Args:
      quota_manager: quota manager to use for quota operations as QuotaManager.
      bucket: quota bucket name as string.
      batch_size: batch size for quota consuming as int.
    """
    self.quota_manager = quota_manager
    self.batch_size = batch_size
    self.bucket = bucket
    self.quota = 0

  def consume(self, amount=1):
    """Consume quota.

    Args:
      amount: amount of quota to be consumed as int.

    Returns:
      True if quota was successfully consumed, False if there's not enough
      quota.
    """
    while self.quota < amount:
      delta = self.quota_manager.consume(self.bucket, self.batch_size,
                                         consume_some=True)
      if not delta:
        return False
      self.quota += delta

    self.quota -= amount
    return True

  def put(self, amount=1):
    """Put quota back.

    Args:
      amount: amount of quota as int.
    """
    self.quota += amount

  def check(self, amount=1):
    """Check that we have enough quota right now.

    This doesn't lock or consume the quota. Following consume might in fact
    fail/succeeded.

    Args:
      amount: amount of quota to check.

    Returns:
      True if we have enough quota to consume specified amount right now. False
      otherwise.
  """
    if self.quota >= amount:
      return True
    return self.quota + self.quota_manager.get(self.bucket) >= amount

  def dispose(self):
    """Dispose QuotaConsumer and put all actually unconsumed quota back.

    This method has to be called for quota consistency!
    """
    self.quota_manager.put(self.bucket, self.quota)

########NEW FILE########
__FILENAME__ = status
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Status page handler for mapreduce framework."""



import os
import time

from google.appengine.api import validation
from google.appengine.api import yaml_builder
from google.appengine.api import yaml_errors
from google.appengine.api import yaml_listener
from google.appengine.api import yaml_object
from google.appengine.ext import db
from mapreduce import base_handler
from mapreduce import model
from google.appengine.ext.webapp import template


# TODO(user): a list of features we'd like to have in status page:
# - show sparklet of entities/sec on index page
# - shard bar chart should color finished shards differently

# mapreduce.yaml file names
MR_YAML_NAMES = ["mapreduce.yaml", "mapreduce.yml"]


class Error(Exception):
  """Base class for exceptions in this module."""


class BadStatusParameterError(Exception):
  """A parameter passed to a status handler was invalid."""


class BadYamlError(Error):
  """Raised when the mapreduce.yaml file is invalid."""


class MissingYamlError(BadYamlError):
  """Raised when the mapreduce.yaml file could not be found."""


class MultipleDocumentsInMrYaml(BadYamlError):
  """There's more than one document in mapreduce.yaml file."""


class UserParam(validation.Validated):
  """A user-supplied parameter to a mapreduce job."""

  ATTRIBUTES = {
      "name":  r"[a-zA-Z0-9_\.]+",
      "default": validation.Optional(r".*"),
      "value": validation.Optional(r".*"),
  }


class MapperInfo(validation.Validated):
  """Configuration parameters for the mapper part of the job."""

  ATTRIBUTES = {
    "handler": r".+",
    "input_reader": r".+",
    "params": validation.Optional(validation.Repeated(UserParam)),
    "params_validator": validation.Optional(r".+"),
  }


class MapreduceInfo(validation.Validated):
  """Mapreduce description in mapreduce.yaml."""

  ATTRIBUTES = {
      "name": r".+",
      "mapper": MapperInfo,
      "params": validation.Optional(validation.Repeated(UserParam)),
      "params_validator": validation.Optional(r".+"),
  }


class MapReduceYaml(validation.Validated):
  """Root class for mapreduce.yaml.

  File format:

  mapreduce:
  - name: <mapreduce_name>
    mapper:
      - input_reader: google.appengine.ext.mapreduce.DatastoreInputReader
      - handler: path_to_my.MapperFunction
      - params:
        - name: foo
          default: bar
        - name: blah
          default: stuff
      - params_validator: path_to_my.ValidatorFunction

  Where
    mapreduce_name: The name of the mapreduce. Used for UI purposes.
    mapper_handler_spec: Full <module_name>.<function_name/class_name> of
      mapper handler. See MapreduceSpec class documentation for full handler
      specification.
    input_reader: Full <module_name>.<function_name/class_name> of the
      InputReader sub-class to use for the mapper job.
    params: A list of optional parameter names and optional default values
      that may be supplied or overridden by the user running the job.
    params_validator is full <module_name>.<function_name/class_name> of
      a callable to validate the mapper_params after they are input by the
      user running the job.
  """

  ATTRIBUTES = {
      "mapreduce": validation.Optional(validation.Repeated(MapreduceInfo))
  }

  @staticmethod
  def to_dict(mapreduce_yaml):
    """Converts a MapReduceYaml file into a JSON-encodable dictionary.

    For use in user-visible UI and internal methods for interfacing with
    user code (like param validation). as a list

    Args:
      mapreduce_yaml: The Pyton representation of the mapreduce.yaml document.

    Returns:
      A list of configuration dictionaries.
    """
    all_configs = []
    for config in mapreduce_yaml.mapreduce:
      out = {
          "name": config.name,
          "mapper_input_reader": config.mapper.input_reader,
          "mapper_handler": config.mapper.handler,
      }
      if config.mapper.params_validator:
        out["mapper_params_validator"] = config.mapper.params_validator
      if config.mapper.params:
        param_defaults = {}
        for param in config.mapper.params:
          param_defaults[param.name] = param.default or param.value
        out["mapper_params"] = param_defaults
      if config.params:
        param_defaults = {}
        for param in config.params:
          param_defaults[param.name] = param.default or param.value
        out["params"] = param_defaults
      all_configs.append(out)

    return all_configs


# N.B. Sadly, we currently don't have and ability to determine
# application root dir at run time. We need to walk up the directory structure
# to find it.
def find_mapreduce_yaml():
  """Traverse up from current directory and find mapreduce.yaml file.

  Returns:
    the path of mapreduce.yaml file or None if not found.
  """
  dir = os.path.dirname(__file__)
  while dir:
    for mr_yaml_name in MR_YAML_NAMES:
      yaml_path = os.path.join(dir, mr_yaml_name)
      if os.path.exists(yaml_path):
        return yaml_path
    parent = os.path.dirname(dir)
    if parent == dir:
      break
    dir = parent
  return None


def parse_mapreduce_yaml(contents):
  """Parses mapreduce.yaml file contents.

  Args:
    contents: mapreduce.yaml file contents.

  Returns:
    MapReduceYaml object with all the data from original file.

  Raises:
    BadYamlError: when contents is not a valid mapreduce.yaml file.
  """
  try:
    builder = yaml_object.ObjectBuilder(MapReduceYaml)
    handler = yaml_builder.BuilderHandler(builder)
    listener = yaml_listener.EventListener(handler)
    listener.Parse(contents)

    mr_info = handler.GetResults()
  except (ValueError, yaml_errors.EventError), e:
    raise BadYamlError(e)

  if len(mr_info) < 1:
    raise BadYamlError("No configs found in mapreduce.yaml")
  if len(mr_info) > 1:
    raise MultipleDocumentsInMrYaml("Found %d YAML documents" % len(mr_info))

  jobs = mr_info[0]
  job_names = set(j.name for j in jobs.mapreduce)
  if len(jobs.mapreduce) != len(job_names):
    raise BadYamlError("Overlapping mapreduce names; names must be unique")

  return jobs


def get_mapreduce_yaml(parse=parse_mapreduce_yaml):
  """Locates mapreduce.yaml, loads and parses its info.

  Args:
    parse: Used for testing.

  Returns:
    MapReduceYaml object.

  Raises:
    BadYamlError: when contents is not a valid mapreduce.yaml file or the
    file is missing.
  """
  mr_yaml_path = find_mapreduce_yaml()
  if not mr_yaml_path:
    raise MissingYamlError()
  mr_yaml_file = open(mr_yaml_path)
  try:
    return parse(mr_yaml_file.read())
  finally:
    mr_yaml_file.close()


class ResourceHandler(base_handler.BaseHandler):
  """Handler for static resources."""

  _RESOURCE_MAP = {
    "status": ("overview.html", "text/html"),
    "detail": ("detail.html", "text/html"),
    "base.css": ("base.css", "text/css"),
    "jquery.js": ("jquery-1.4.2.min.js", "text/javascript"),
    "status.js": ("status.js", "text/javascript"),
  }

  def get(self, relative):
    if relative not in self._RESOURCE_MAP:
      self.response.set_status(404)
      self.response.out.write("Resource not found.")
      return

    real_path, content_type = self._RESOURCE_MAP[relative]
    path = os.path.join(os.path.dirname(__file__), "static", real_path)
    self.response.headers["Cache-Control"] = "public; max-age=300"
    self.response.headers["Content-Type"] = content_type
    self.response.out.write(open(path).read())


class ListConfigsHandler(base_handler.JsonHandler):
  """Lists mapreduce configs as JSON for users to start jobs."""

  def handle(self):
    self.json_response["configs"] = MapReduceYaml.to_dict(get_mapreduce_yaml())


class ListJobsHandler(base_handler.JsonHandler):
  """Lists running and completed mapreduce jobs for an overview as JSON."""

  def handle(self):
    cursor = self.request.get("cursor")
    count = int(self.request.get("count", "50"))

    query = model.MapreduceState.all()
    if cursor:
      query.filter("__key__ >=", db.Key(cursor))
    query.order("__key__")

    jobs_list = query.fetch(count + 1)
    if len(jobs_list) == (count + 1):
      self.json_response["cursor"] = str(jobs_list[-1].key())
      jobs_list = jobs_list[:-1]

    all_jobs = []
    for job in jobs_list:
      out = {
          # Data shared between overview and detail pages.
          "name": job.mapreduce_spec.name,
          "mapreduce_id": job.mapreduce_spec.mapreduce_id,
          "active": job.active,
          "start_timestamp_ms":
              int(time.mktime(job.start_time.utctimetuple()) * 1000),
          "updated_timestamp_ms":
              int(time.mktime(job.last_poll_time.utctimetuple()) * 1000),

          # Specific to overview page.
          "chart_url": job.sparkline_url,
          "active_shards": job.active_shards,
          "shards": job.mapreduce_spec.mapper.shard_count,
      }
      if job.result_status:
        out["result_status"] = job.result_status
      all_jobs.append(out)

    self.json_response["jobs"] = all_jobs


class GetJobDetailHandler(base_handler.JsonHandler):
  """Retrieves the details of a mapreduce job as JSON."""

  def handle(self):
    mapreduce_id = self.request.get("mapreduce_id")
    if not mapreduce_id:
      raise BadStatusParameterError("'mapreduce_id' was invalid")
    job = model.MapreduceState.get_by_key_name(mapreduce_id)
    if job is None:
      raise KeyError("Could not find job with ID %r" % mapreduce_id)

    self.json_response.update(job.mapreduce_spec.to_json())
    self.json_response.update(job.counters_map.to_json())
    self.json_response.update({
        # Shared with overview page.
        "active": job.active,
        "start_timestamp_ms":
            int(time.mktime(job.start_time.utctimetuple()) * 1000),
        "updated_timestamp_ms":
            int(time.mktime(job.last_poll_time.utctimetuple()) * 1000),

        # Specific to detail page.
        "chart_url": job.chart_url,
    })
    self.json_response["result_status"] = job.result_status

    shards_list = model.ShardState.find_by_mapreduce_id(mapreduce_id)
    all_shards = []
    shards_list.sort(key=lambda x: x.shard_number)
    for shard in shards_list:
      out = {
          "active": shard.active,
          "result_status": shard.result_status,
          "shard_number": shard.shard_number,
          "shard_id": shard.shard_id,
          "updated_timestamp_ms":
              int(time.mktime(shard.update_time.utctimetuple()) * 1000),
          "shard_description": shard.shard_description,
          "last_work_item": shard.last_work_item,
      }
      out.update(shard.counters_map.to_json())
      all_shards.append(out)
    self.json_response["shards"] = all_shards

########NEW FILE########
__FILENAME__ = util
#!/usr/bin/env python
#
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply

"""Utility functions for use with the mapreduce library."""



__all__ = ["for_name", "is_generator_function", "get_short_name", "parse_bool"]


import inspect
import logging


def for_name(fq_name, recursive=False):
  """Find class/function/method specified by its fully qualified name.

  Fully qualified can be specified as:
    * <module_name>.<class_name>
    * <module_name>.<function_name>
    * <module_name>.<class_name>.<method_name> (an unbound method will be
      returned in this case).

  for_name works by doing __import__ for <module_name>, and looks for
  <class_name>/<function_name> in module's __dict__/attrs. If fully qualified
  name doesn't contain '.', the current module will be used.

  Args:
    fq_name: fully qualified name of something to find

  Returns:
    class object.

  Raises:
    ImportError: when specified module could not be loaded or the class
    was not found in the module.
  """
#  if "." not in fq_name:
#    raise ImportError("'%s' is not a full-qualified name" % fq_name)

  fq_name = str(fq_name)
  module_name = __name__
  short_name = fq_name

  if fq_name.rfind(".") >= 0:
    (module_name, short_name) = (fq_name[:fq_name.rfind(".")],
                                 fq_name[fq_name.rfind(".") + 1:])

  try:
    result = __import__(module_name, None, None, [short_name])
    return result.__dict__[short_name]
  except KeyError:
    # If we're recursively inside a for_name() chain, then we want to raise
    # this error as a key error so we can report the actual source of the
    # problem. If we're *not* recursively being called, that means the
    # module was found and the specific item could not be loaded, and thus
    # we want to raise an ImportError directly.
    if recursive:
      raise
    else:
      raise ImportError("Could not find '%s' on path '%s'" % (
                        short_name, module_name))
  except ImportError, e:
    # module_name is not actually a module. Try for_name for it to figure
    # out what's this.
    try:
      module = for_name(module_name, recursive=True)
      if hasattr(module, short_name):
        return getattr(module, short_name)
      else:
        # The module was found, but the function component is missing.
        raise KeyError()
    except KeyError:
      raise ImportError("Could not find '%s' on path '%s'" % (
                        short_name, module_name))
    except ImportError:
      # This means recursive import attempts failed, thus we will raise the
      # first ImportError we encountered, since it's likely the most accurate.
      pass
    # Raise the original import error that caused all of this, since it is
    # likely the real cause of the overall problem.
    raise


def is_generator_function(obj):
  """Return true if the object is a user-defined generator function.

  Generator function objects provides same attributes as functions.
  See isfunction.__doc__ for attributes listing.

  Adapted from Python 2.6.

  Args:
    obj: an object to test.

  Returns:
    true if the object is generator function.
  """
  CO_GENERATOR = 0x20
  return bool(((inspect.isfunction(obj) or inspect.ismethod(obj)) and
               obj.func_code.co_flags & CO_GENERATOR))


def get_short_name(fq_name):
  """Returns the last component of the name."""
  return fq_name.split(".")[-1:][0]


def parse_bool(obj):
  """Return true if the object represents a truth value, false otherwise.

  For bool and numeric objects, uses Python's built-in bool function.  For
  str objects, checks string against a list of possible truth values.

  Args:
    obj: object to determine boolean value of; expected

  Returns:
    Boolean value according to 5.1 of Python docs if object is not a str
      object.  For str objects, return True if str is in TRUTH_VALUE_SET
      and False otherwise.
    http://docs.python.org/library/stdtypes.html
  """
  if type(obj) is str:
    TRUTH_VALUE_SET = ["true", "1", "yes", "t", "on"]
    return obj.lower() in TRUTH_VALUE_SET
  else:
    return bool(obj)

########NEW FILE########
__FILENAME__ = member
#!/usr/bin/env python
# coding=utf-8

import os
import base64
import re
import time
import datetime
import hashlib
import httplib
import string
import pickle

from StringIO import StringIO

from django.utils import simplejson as json

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.api import images
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Avatar
from v2ex.babel import Counter
from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session
from v2ex.babel.ext.upyun import UpYun, md5, md5file

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.handlers import BaseHandler

import config

template.register_template_library('v2ex.templatetags.filters')

class MemberHandler(webapp.RequestHandler):
    def get(self, member_username):
        site = GetSite()
        browser = detect(self.request)
        self.session = Session()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        template_values['show_extra_options'] = False
        if member:
            if member.num == 1:
                template_values['show_extra_options'] = True
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        one = False
        one = GetMemberByUsername(member_username)
        if one is not False:
            if one.followers_count is None:
                one.followers_count = 0
            template_values['one'] = one
            template_values['page_title'] = site.title + u' › ' + one.username
            template_values['canonical'] = 'http://' + site.domain + '/member/' + one.username
            if one.github:
                github = memcache.get('Member::' + one.username_lower + '::github')
                if github is None:
                    response = urlfetch.fetch("https://api.github.com/users/" + one.github + "/repos")
                    if response.status_code == 200:
                        github = response.content
                        memcache.set('Member::' + one.username_lower + '::github', github, 86400)
                if github is not None:
                    template_values['github_repos'] = sorted(json.loads(github), key=lambda x:x['stargazers_count'], reverse=True)
        if one is not False:
            member_blog = memcache.get('member::' + str(one.num) + '::blog')
            if member_blog == None:
                blog = db.GqlQuery("SELECT * FROM Topic WHERE node_name = :1 AND member_num = :2 ORDER BY created DESC LIMIT 1", 'blog', one.num)
                if blog.count() > 0:
                    template_values['blog'] = blog[0]
                    memcache.set('member::' + str(one.num) + '::blog', blog[0], 7200)
            else:
                template_values['blog'] = member_blog
            member_topics = memcache.get('member::' + str(one.num) + '::topics')
            if member_topics != None:
                template_values['topics'] = member_topics
            else:
                q2 = db.GqlQuery("SELECT * FROM Topic WHERE member_num = :1 ORDER BY created DESC LIMIT 10", one.num)
                template_values['topics'] = q2
                memcache.set('member::' + str(one.num) + '::topics', q2, 7200)
            replies = memcache.get('member::' + str(one.num) + '::participated')
            
            if replies is None:
                q3 = db.GqlQuery("SELECT * FROM Reply WHERE member_num = :1 ORDER BY created DESC LIMIT 10", one.num)
                ids = []
                replies = []
                i = 0
                for reply in q3:
                    if reply.topic.num not in ids:
                        i = i + 1
                        if i > 10:
                            break
                        replies.append(reply)
                        ids.append(reply.topic.num)
                if len(replies) > 0:
                    memcache.set('member::' + str(one.num) + '::participated', replies, 7200)
            if len(replies) > 0:
                template_values['replies'] = replies
        template_values['show_block'] = False
        template_values['show_follow'] = False
        template_values['favorited'] = False
        if one and member:
            if one.num != member.num:
                template_values['show_follow'] = True
                template_values['show_block'] = True
                try:
                    blocked = pickle.loads(member.blocked.encode('utf-8'))
                except:
                    blocked = []
                if one.num in blocked:
                    template_values['one_is_blocked'] = True
                else:
                    template_values['one_is_blocked'] = False
                if member.hasFavorited(one):
                    template_values['favorited'] = True
                else:
                    template_values['favorited'] = False
        if 'message' in self.session:
            template_values['message'] = self.session['message']
            del self.session['message']
        if one is not False: 
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_home.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_home.html')
        else:
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_not_found.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_not_found.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
class MemberApiHandler(webapp.RequestHandler):
    def get(self, member_username):
        site = GetSite()
        one = GetMemberByUsername(member_username)
        if one:
            if one.avatar_mini_url:
                if (one.avatar_mini_url[0:1] == '/'):
                    one.avatar_mini_url = 'http://' + site.domain + one.avatar_mini_url
                    one.avatar_normal_url = 'http://' +  site.domain + one.avatar_normal_url
                    one.avatar_large_url = 'http://' + site.domain + one.avatar_large_url
            template_values = {}
            template_values['site'] = site
            template_values['one'] = one
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'member.json')
            self.response.headers['Content-type'] = 'application/json;charset=UTF-8'
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.error(404)

class SettingsHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        self.session = Session()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['page_title'] = site.title + u' › ' + l10n.settings.decode('utf-8')
        if (member):
            template_values['member'] = member
            template_values['member_username'] = member.username
            template_values['member_email'] = member.email
            if (member.website == None):
                member.website = ''
            template_values['member_website'] = member.website
            if (member.twitter == None):
                member.twitter = ''
            template_values['member_twitter'] = member.twitter
            if (member.location == None):
                member.location = ''
            if member.psn is None:
                member.psn = ''
            template_values['member_psn'] = member.psn
            if (member.my_home == None):
                member.my_home = ''
            template_values['member_my_home'] = member.my_home
            template_values['member_btc'] = member.btc
            if member.github:
                template_values['member_github'] = member.github
            else:
                template_values['member_github'] = u''
            template_values['member_location'] = member.location
            if (member.tagline == None):
                member.tagline = ''
            template_values['member_tagline'] = member.tagline
            if (member.bio == None):
                member.bio = ''
            template_values['member_bio'] = member.bio
            template_values['member_show_home_top'] = member.show_home_top
            template_values['member_show_quick_post'] = member.show_quick_post
            if member.l10n is None:
                member.l10n = 'en'
            template_values['member_l10n'] = member.l10n
            s = GetLanguageSelect(member.l10n)
            template_values['s'] = s
            if member.twitter_sync == 1:
                template_values['member_twitter_sync'] = 1
            if member.use_my_css == 1:
                template_values['member_use_my_css'] = 1
            if (member.my_css == None):
                member.my_css = ''
            template_values['member_my_css'] = member.my_css
            if 'message' in self.session:
                message = self.session['message']
                del self.session['message']
            else:
                message = None
            template_values['message'] = message
            try:
                blocked = pickle.loads(member.blocked.encode('utf-8'))
            except:
                blocked = []
            template_values['member_stats_blocks'] = len(blocked)
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_settings.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_settings.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')
        
    def post(self):
        self.session = Session()
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        errors = 0
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['page_title'] = site.title + u' › ' + l10n.settings.decode('utf-8')
        if (member):
            template_values['member'] = member
            template_values['member_username'] = member.username
            template_values['member_email'] = member.email
            template_values['member_website'] = member.website
            template_values['member_twitter'] = member.twitter
            # Verification: password
            password_error = 0
            password_update = False
            password_error_messages = ['',
                '新密码长度不能超过 32 个字符',
                '请输入当前密码',
                '当前密码不正确'
            ]
            password_new = self.request.get('password_new').strip()
            if (len(password_new) > 0):
                password_update = True
                if (len(password_new) > 32):
                    password_error = 1
                else:
                    password_current = self.request.get('password_current').strip()
                    if (len(password_current) == 0):
                        password = 2
                    else:
                        password_current_sha1 = hashlib.sha1(password_current).hexdigest()
                        if (password_current_sha1 != member.password):
                            password_error = 3
            template_values['password_error'] = password_error
            template_values['password_error_message'] = password_error_messages[password_error]
            if ((password_error == 0) and (password_update == True)):
                member.password = hashlib.sha1(password_new).hexdigest()
                member.auth = hashlib.sha1(str(member.num) + ':' + member.password).hexdigest()
                member.put()
                self.response.headers['Set-Cookie'] = 'auth=' + member.auth + '; expires=' + (datetime.datetime.now() + datetime.timedelta(days=365)).strftime("%a, %d-%b-%Y %H:%M:%S GMT") + '; path=/'
                self.redirect('/settings')
            # Verification: email
            member_email_error = 0
            member_email_error_messages = ['',
                u'请输入你的电子邮件地址',
                u'电子邮件地址长度不能超过 32 个字符',
                u'你输入的电子邮件地址不符合规则',
                u'抱歉这个电子邮件地址已经有人注册过了']
            member_email = self.request.get('email').strip()
            if (len(member_email) == 0):
                errors = errors + 1
                member_email_error = 1
            else:
                if (len(member_email) > 32):
                    errors = errors + 1
                    member_email_error = 2
                else:
                    p = re.compile(r"(?:^|\s)[-a-z0-9_.+]+@(?:[-a-z0-9]+\.)+[a-z]{2,6}(?:\s|$)", re.IGNORECASE)
                    if (p.search(member_email)):
                        q = db.GqlQuery('SELECT * FROM Member WHERE email = :1 AND num != :2', member_email.lower(), member.num)
                        if (q.count() > 0):
                            errors = errors + 1
                            member_email_error = 4
                    else:
                        errors = errors + 1
                        member_email_error = 3
            template_values['member_email'] = member_email
            template_values['member_email_error'] = member_email_error
            template_values['member_email_error_message'] = member_email_error_messages[member_email_error]
            # Verification: website
            member_website_error = 0
            member_website_error_messages = ['',
                u'个人网站地址长度不能超过 200 个字符',
                u'这个网站地址不符合规则'
            ]
            member_website = self.request.get('website').strip()
            if (len(member_website) == 0):
                member_website = ''    
            else:
                if (len(member_website) > 200):
                    errors = errors + 1
                    member_website_error = 1
                else:
                    p = re.compile('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
                    if (p.search(member_website)):
                        errors = errors
                    else:
                        errors = errors + 1
                        member_website_error = 2
            template_values['member_website'] = member_website
            template_values['member_website_error'] = member_website_error
            template_values['member_website_error_message'] = member_website_error_messages[member_website_error]
            # Verification: Twitter
            member_twitter_error = 0
            member_twitter_error_messages = ['',
                u'Twitter 用户名长度不能超过 20 个字符',
                u'Twitter 用户名不符合规则'
            ]
            member_twitter = self.request.get('twitter').strip()
            if (len(member_twitter) == 0):
                member_twitter = ''
            else:
                if (len(member_twitter) > 20):
                    errors = errors + 1
                    member_twitter_error = 1
                else:
                    p = re.compile('[a-zA-Z0-9\_]+')
                    if (p.search(member_twitter)):
                        errors = errors
                    else:
                        errors = errors + 1
                        member_twitter_error = 2
            template_values['member_twitter'] = member_twitter
            template_values['member_twitter_error'] = member_twitter_error
            template_values['member_twitter_error_message'] = member_twitter_error_messages[member_twitter_error]
            # Verification: psn
            member_psn_error = 0
            member_psn_error_messages = ['',
                u'PSN ID 长度不能超过 20 个字符',
                u'PSN ID 不符合规则'
            ]
            member_psn = self.request.get('psn').strip()
            if (len(member_psn) == 0):
                member_psn = ''
            else:
                if (len(member_psn) > 20):
                    errors = errors + 1
                    member_psn_error = 1
                else:
                    p = re.compile('^[a-zA-Z0-9\-\_]+$')
                    if (p.search(member_psn)):
                        errors = errors
                    else:
                        errors = errors + 1
                        member_psn_error = 2
            template_values['member_psn'] = member_psn
            template_values['member_psn_error'] = member_psn_error
            template_values['member_psn_error_message'] = member_psn_error_messages[member_psn_error]
            # Verification: my_home
            member_my_home_error = 0
            member_my_home_error_messages = ['',
                u'不是一个合法的自定义首页跳转位置',
                u'自定义首页跳转位置长度不能超过 32 个字符',
                u'自定义首页跳转位置必须以 / 开头'
            ]
            member_my_home = self.request.get('my_home').strip()
            if len(member_my_home) > 0:
                if member_my_home == '/' or member_my_home.startswith('/signout'):
                    member_my_home_error = 1
                    errors = errors + 1
                else:
                    if len(member_my_home) > 32:
                        member_my_home_error = 2
                        errors = errors + 1
                    else:
                        if member_my_home.startswith('/') is not True:
                            member_my_home_error = 3
                            errors = errors + 1
            template_values['member_my_home'] = member_my_home
            template_values['member_my_home_error'] = member_my_home_error
            template_values['member_my_home_error_message'] = member_my_home_error_messages[member_my_home_error]
            # Verification: btc
            member_btc_error = 0
            member_btc_error_messages = ['',
                u'BTC 收款地址长度不能超过 40 个字符',
                u'BTC 收款地址不符合规则'
            ]
            member_btc = self.request.get('btc').strip()
            if (len(member_btc) == 0):
                member_btc = ''
            else:
                if (len(member_btc) > 40):
                    errors = errors + 1
                    member_btc_error = 1
                else:
                    p = re.compile('^[a-zA-Z0-9]+$')
                    if (p.search(member_btc)):
                        errors = errors
                    else:
                        errors = errors + 1
                        member_btc_error = 2
            template_values['member_btc'] = member_btc
            template_values['member_btc_error'] = member_btc_error
            template_values['member_btc_error_message'] = member_btc_error_messages[member_btc_error]
            # Verification: github
            member_github_error = 0
            member_github_error_messages = ['',
                u'GitHub 用户名长度不能超过 40 个字符',
                u'GitHub 用户名不符合规则'
            ]
            member_github = self.request.get('github').strip()
            if (len(member_github) == 0):
                member_github = ''
            else:
                if (len(member_github) > 40):
                    errors = errors + 1
                    member_github_error = 1
                else:
                    p = re.compile('^[a-zA-Z0-9\_]+$')
                    if (p.search(member_github)):
                        errors = errors
                    else:
                        errors = errors + 1
                        member_github_error = 2
            template_values['member_github'] = member_github
            template_values['member_github_error'] = member_github_error
            template_values['member_github_error_message'] = member_github_error_messages[member_github_error]
            # Verification: location
            member_location_error = 0
            member_location_error_messages = ['',
                u'所在地长度不能超过 40 个字符'
            ]
            member_location = self.request.get('location').strip()
            if (len(member_location) == 0):
                member_location = ''    
            else:
                if (len(member_location) > 40):
                    errors = errors + 1
                    member_location_error = 1
            template_values['member_location'] = member_location
            template_values['member_location_error'] = member_location_error
            template_values['member_location_error_message'] = member_location_error_messages[member_location_error]
            # Verification: tagline
            member_tagline_error = 0
            member_tagline_error_messages = ['',
                u'个人签名长度不能超过 70 个字符'
            ]
            member_tagline = self.request.get('tagline').strip()
            if (len(member_tagline) == 0):
                member_tagline = ''    
            else:
                if (len(member_tagline) > 70):
                    errors = errors + 1
                    member_tagline_error = 1
            template_values['member_tagline'] = member_tagline
            template_values['member_tagline_error'] = member_tagline_error
            template_values['member_tagline_error_message'] = member_tagline_error_messages[member_tagline_error]
            # Verification: bio
            member_bio_error = 0
            member_bio_error_messages = ['',
                u'个人简介长度不能超过 2000 个字符'
            ]
            member_bio = self.request.get('bio').strip()
            if (len(member_bio) == 0):
                member_bio = ''    
            else:
                if (len(member_bio) > 2000):
                    errors = errors + 1
                    member_bio_error = 1
            template_values['member_bio'] = member_bio
            template_values['member_bio_error'] = member_bio_error
            template_values['member_bio_error_message'] = member_bio_error_messages[member_bio_error]
            # Verification: show_home_top and show_quick_post
            try:
                member_show_home_top = int(self.request.get('show_home_top'))
            except:
                member_show_home_top = 1
            try:
                member_show_quick_post = int(self.request.get('show_quick_post'))
            except:
                member_show_quick_post = 0
            if member_show_home_top not in [0, 1]:
                member_show_home_top = 1
            if member_show_quick_post not in [0, 1]:
                member_show_quick_post = 0
            # Verification: l10n
            member_l10n = self.request.get('l10n').strip()
            supported = GetSupportedLanguages()
            if member_l10n == '':
                member_l10n = site.l10n
            else:
                if member_l10n not in supported:
                    member_l10n = site.l10n
            s = GetLanguageSelect(member_l10n)
            template_values['s'] = s
            template_values['member_l10n'] = member_l10n
            # Verification: twitter_sync
            if member.twitter_oauth == 1:
                member_twitter_sync = self.request.get('twitter_sync')
                if member_twitter_sync == 'on':
                    member_twitter_sync = 1
                else:
                    member_twitter_sync = 0
                template_values['member_twitter_sync'] = member_twitter_sync
            # Verification: use_my_css
            member_use_my_css = self.request.get('use_my_css')
            if member_use_my_css == 'on':
                member_use_my_css = 1
            else:
                member_use_my_css = 0
            template_values['member_use_my_css'] = member_use_my_css
            # Verification: my_css
            member_my_css_error = 0
            member_my_css_error_messages = ['',
                u'CSS Hack cannot be longer than 2000 characters'
            ]
            member_my_css = self.request.get('my_css').strip()
            if (len(member_my_css) == 0):
                member_my_css = ''    
            else:
                if (len(member_my_css) > 2000):
                    errors = errors + 1
                    member_my_css_error = 1
            template_values['member_my_css'] = member_my_css
            template_values['member_my_css_error'] = member_my_css_error
            template_values['member_my_css_error_message'] = member_my_css_error_messages[member_my_css_error]
            template_values['errors'] = errors
            if (errors == 0):
                member.email = member_email.lower()
                member.website = member_website
                member.twitter = member_twitter
                member.psn = member_psn
                member.btc = member_btc
                member.github = member_github
                member.location = member_location
                member.tagline = member_tagline
                if member.twitter_oauth == 1:
                    member.twitter_sync = member_twitter_sync
                member.use_my_css = member_use_my_css
                member.my_css = member_my_css
                if member_my_home_error == 0 and len(member_my_home) > 0:
                    member.my_home = member_my_home
                else:
                    if member_my_home_error == 0:
                        member.my_home = None
                member.bio = member_bio
                member.show_home_top = member_show_home_top
                member.show_quick_post = member_show_quick_post
                member.l10n = member_l10n
                member.put()
                memcache.delete('Member::' + str(member.username))
                memcache.delete('Member::' + str(member.username_lower))
                memcache.set('Member_' + str(member.num), member, 86400)
                self.session['message'] = '个人设置成功更新'
                self.redirect('/settings')
            else:
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_settings.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_settings.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')


class SettingsPasswordHandler(webapp.RequestHandler):
    def post(self):
        site = GetSite()
        browser = detect(self.request)
        self.session = Session()
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 密码设置'
        template_values['system_version'] = SYSTEM_VERSION
        errors = 0
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            template_values['member'] = member
            template_values['member_username'] = member.username
            template_values['member_email'] = member.email
            # Verification: password
            password_error = 0
            password_update = False
            password_error_messages = ['',
                '新密码长度不能超过 32 个字符',
                '请输入当前密码',
                '当前密码不正确'
            ]
            password_new = self.request.get('password_new').strip()
            if (len(password_new) > 0):
                password_update = True
                if (len(password_new) > 32):
                    password_error = 1
                else:
                    password_current = self.request.get('password_current').strip()
                    if (len(password_current) == 0):
                        password_error = 2
                    else:
                        password_current_sha1 = hashlib.sha1(password_current).hexdigest()
                        if (password_current_sha1 != member.password):
                            password_error = 3
            template_values['password_error'] = password_error
            template_values['password_error_message'] = password_error_messages[password_error]
            if ((password_error == 0) and (password_update == True)):
                old_auth = member.auth
                memcache.delete(old_auth)
                member.password = hashlib.sha1(password_new).hexdigest()
                member.auth = hashlib.sha1(str(member.num) + ':' + member.password).hexdigest()
                member.put()
                memcache.set(member.auth, member.num, 86400 * 14)
                memcache.set('Member_' + str(member.num), member, 86400 * 14)
                self.session['message'] = '密码已成功更新，下次请用新密码登录'
                self.response.headers['Set-Cookie'] = 'auth=' + member.auth + '; expires=' + (datetime.datetime.now() + datetime.timedelta(days=365)).strftime("%a, %d-%b-%Y %H:%M:%S GMT") + '; path=/'
                self.redirect('/settings')
            else:
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_settings_password.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_settings_password.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')

class SettingsAvatarHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        self.session = Session()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['page_title'] = site.title + u' › 头像'
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            if 'message' in self.session:
                template_values['message'] = self.session['message']
                del self.session['message']
            template_values['member'] = member
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'member_settings_avatar.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'member_settings_avatar.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')
        
    def post(self):
        site = GetSite()
        self.session = Session()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if (member):
            dest = '/settings/avatar'
            timestamp = str(int(time.time()))
            try:
                avatar = self.request.get('avatar')
            except:
                return self.redirect(dest)
            if avatar is None:
                return self.redirect(dest)
            avatar_len = len(avatar)
            if avatar_len == 0:
                return self.redirect(dest)
            avatar_73 = images.resize(avatar, 73, 73)
            avatar_48 = images.resize(avatar, 48, 48)
            avatar_24 = images.resize(avatar, 24, 24)
            # Large 73x73
            q1 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'avatar_' + str(member.num) + '_large')
            if (q1.count() == 1):
                avatar_large = q1[0]
                avatar_large.content = db.Blob(avatar_73)
                avatar_large.put()
            else:
                qc1 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                if (qc1.count() == 1):
                    counter1 = qc1[0]
                    counter1.value = counter1.value + 1
                else:
                    counter1 = Counter()
                    counter1.name = 'avatar.max'
                    counter1.value = 1
                counter1.put()
                avatar_large = Avatar()
                avatar_large.name = 'avatar_' + str(member.num) + '_large'
                avatar_large.content = db.Blob(avatar_73)
                avatar_large.num = counter1.value
                avatar_large.put()
            member.avatar_large_url = '/avatar/' + str(member.num) + '/large?r=' + timestamp
            member.put()
            # Normal 48x48
            q2 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'avatar_' + str(member.num) + '_normal')
            if (q2.count() == 1):
                avatar_normal = q2[0]
                avatar_normal.content = db.Blob(avatar_48)
                avatar_normal.put()
            else:
                qc2 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                if (qc2.count() == 1):
                    counter2 = qc2[0]
                    counter2.value = counter2.value + 1
                else:
                    counter2 = Counter()
                    counter2.name = 'avatar.max'
                    counter2.value = 1
                counter2.put()
                avatar_normal = Avatar()
                avatar_normal.name = 'avatar_' + str(member.num) + '_normal'
                avatar_normal.content = db.Blob(avatar_48)
                avatar_normal.num = counter2.value
                avatar_normal.put()
            member.avatar_normal_url = '/avatar/' + str(member.num) + '/normal?r=' + timestamp
            member.put() 
            # Mini 24x24
            q3 = db.GqlQuery("SELECT * FROM Avatar WHERE name = :1", 'avatar_' + str(member.num) + '_mini')
            if (q3.count() == 1):
                avatar_mini = q3[0]
                avatar_mini.content = db.Blob(avatar_24)
                avatar_mini.put()
            else:
                qc3 = db.GqlQuery("SELECT * FROM Counter WHERE name = :1", 'avatar.max')
                if (qc3.count() == 1):
                    counter3 = qc3[0]
                    counter3.value = counter3.value + 1
                else:
                    counter3 = Counter()
                    counter3.name = 'avatar.max'
                    counter3.value = 1
                counter3.put()
                avatar_mini = Avatar()
                avatar_mini.name = 'avatar_' + str(member.num) + '_mini'
                avatar_mini.content = db.Blob(avatar_24)
                avatar_mini.num = counter3.value
                avatar_mini.put()
            member.avatar_mini_url = '/avatar/' + str(member.num) + '/mini?r=' + timestamp
            member.put()
            # Upload to MobileMe
            if config.mobileme_enabled:
                headers = {'Authorization' : 'Basic ' + base64.b64encode(config.mobileme_username + ':' + config.mobileme_password)}
                host = 'idisk.me.com'
                # Sharding
                timestamp = str(int(time.time()))
                shard = member.num % 31
                root = '/' + config.mobileme_username + '/Web/Sites/v2ex/avatars/' + str(shard)
                root_mini = root + '/mini'
                root_normal = root + '/normal'
                root_large = root + '/large'
                h = httplib.HTTPConnection(host)
                # Mini
                h.request('PUT', root_mini + '/' + str(member.num) + '.png', str(avatar_24), headers)
                response = h.getresponse()
                if response.status == 201 or response.status == 204:
                    member.avatar_mini_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/avatars/' + str(shard) + '/mini/' + str(member.num) + '.png?r=' + timestamp
                # Normal
                h.request('PUT', root_normal + '/' + str(member.num) + '.png', str(avatar_48), headers)
                response = h.getresponse()
                if response.status == 201 or response.status == 204:
                    member.avatar_normal_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/avatars/' + str(shard) + '/normal/' + str(member.num) + '.png?r=' + timestamp
                # Large
                h.request('PUT', root_large + '/' + str(member.num) + '.png', str(avatar_73), headers)
                response = h.getresponse()
                if response.status == 201 or response.status == 204:
                    member.avatar_large_url = 'http://web.me.com/' + config.mobileme_username + '/v2ex/avatars/' + str(shard) + '/large/' + str(member.num) + '.png?r=' + timestamp
                member.put()
            # Upload to UpYun
            if config.upyun_enabled:
                u = UpYun(config.upyun_bucket, config.upyun_username, config.upyun_password)
                # Mini
                mini = avatar_24
                u.setContentMD5(md5(mini))
                mini_suffix = '/avatars/mini/' + str(member.num) + '.png'
                r = u.writeFile(mini_suffix, mini, True)
                if r == True:
                    member.avatar_mini_url = 'http://' + config.upyun_bucket + '.b0.upaiyun.com' + mini_suffix + '?r=' + timestamp
                # Normal
                normal = avatar_48
                u.setContentMD5(md5(normal))
                normal_suffix = '/avatars/normal/' + str(member.num) + '.png'
                r = u.writeFile(normal_suffix, normal, True)
                if r == True:
                    member.avatar_normal_url = 'http://' + config.upyun_bucket + '.b0.upaiyun.com' + normal_suffix + '?r=' + timestamp
                # Large
                large = avatar_73
                u.setContentMD5(md5(large))
                large_suffix = '/avatars/large/' + str(member.num) + '.png'
                r = u.writeFile(large_suffix, large, True)
                if r == True:
                    member.avatar_large_url = 'http://' + config.upyun_bucket + '.b0.upaiyun.com' + large_suffix + '?r=' + timestamp
                member.put()
            memcache.set('Member_' + str(member.num), member, 86400 * 14)
            memcache.set('Member::' + member.username_lower, member, 86400 * 14)
            memcache.delete('Avatar::avatar_' + str(member.num) + '_large')
            memcache.delete('Avatar::avatar_' + str(member.num) + '_normal')
            memcache.delete('Avatar::avatar_' + str(member.num) + '_mini')
            self.session['message'] = '新头像设置成功'
            self.redirect('/settings/avatar')
        else:
            self.redirect('/signin')


class AvatarStringIO(StringIO):
    def __len__(self):
        content = self.read()
        return len(content)

class MemberBlockHandler(webapp.RequestHandler):
    def get(self, key):
        go = '/'
        member = CheckAuth(self)
        if member:
            member = db.get(member.key())
            one = db.get(db.Key(key))
            if one:
                if one.num != member.num:
                    try:
                        blocked = pickle.loads(member.blocked.encode('utf-8'))
                    except:
                        blocked = []
                    if len(blocked) == 0:
                        blocked = []
                    if one.num not in blocked:
                        blocked.append(one.num)
                    member.blocked = pickle.dumps(blocked)
                    member.put()
                    memcache.set('Member_' + str(member.num), member, 86400)
        self.redirect(go)

class MemberUnblockHandler(webapp.RequestHandler):
    def get(self, key):
        go = '/'
        member = CheckAuth(self)
        if member:
            member = db.get(member.key())
            one = db.get(db.Key(key))
            if one:
                if one.num != member.num:
                    try:
                        blocked = pickle.loads(member.blocked.encode('utf-8'))
                    except:
                        blocked = []
                    if len(blocked) == 0:
                        blocked = []
                    if one.num  in blocked:
                        blocked.remove(one.num)
                    member.blocked = pickle.dumps(blocked)
                    member.put()
                    memcache.set('Member_' + str(member.num), member, 86400)
        self.redirect(go)

def main():
    application = webapp.WSGIApplication([
    ('/member/([a-z0-9A-Z\_\-]+)', MemberHandler),
    ('/member/([a-z0-9A-Z\_\-]+).json', MemberApiHandler),
    ('/settings', SettingsHandler),
    ('/settings/password', SettingsPasswordHandler),
    ('/settings/avatar', SettingsAvatarHandler),
    ('/block/(.*)', MemberBlockHandler),
    ('/unblock/(.*)', MemberUnblockHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = misc
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

from v2ex.babel.handlers import BaseHandler

template.register_template_library('v2ex.templatetags.filters')

class WorldClockHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        member = CheckAuth(self)
        template_values = {}
        template_values['site'] = site
        if member:
            template_values['member'] = member
        l10n = GetMessages(self, site, member)
        template_values['l10n'] = l10n
        template_values['page_title'] = site.title + u' › World Clock 世界时钟'
        template_values['now'] = datetime.datetime.now()
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'time.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class MD5Handler(BaseHandler):
    def get(self, source):
        i = str(self.request.get('input').strip())
        if (i):
            self.values['md5'] = hashlib.md5(i).hexdigest()
            self.values['sha1'] = hashlib.sha1(i).hexdigest()
        self.set_title(u'MD5 / SHA1 计算器')
        self.finalize(template_name='md5')

class BFBCSPokeHandler(webapp.RequestHandler):
    def get(self, platform, soldier):
        ua = 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.13) Gecko/20101203 Firefox/3.6.13'
        referer = 'http://bfbcs.com/' + platform
        cache_tag = 'bfbcs::' + platform + '/' + soldier
        raw = memcache.get(cache_tag)
        url = 'http://bfbcs.com/stats_' + platform + '/' + soldier
        if raw is None:
            response = urlfetch.fetch(url, headers={'User-Agent' : ua, 'Referer' : referer })
            raw = response.content
            memcache.set(cache_tag, raw, 600)
        pcode = re.findall('([a-z0-9]{32})', raw)
        self.response.out.write('<strong>PCODE</strong> ' + str(pcode[0]) + '<br />')
        if len(pcode) == 1:
            pcode = pcode[0]
            payload = 'request=addplayerqueue&pcode=' + pcode
            self.response.out.write('<strong>PAYLOAD</strong> ' + payload + ' (' + str(len(payload))+ ' bytes)<br />')
            headers = {'User-Agent' : ua, 'Referer' : url, 'X-Requested-With' : 'XMLHttpRequest', 'Content-Type' : 'application/x-www-form-urlencoded; charset=UTF-8', 'Content-Length' : '61', 'Accept' : 'application/json, text/javascript, */*', 'Accept-Language' : 'en-us,en;q=0.5', 'Accept-Encoding' : 'gzip,deflate', 'Accept-Charset' : 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', 'Keep-Alive' : 115, 'Host' : 'bfbcs.com', 'Pragma' : 'no-cache', 'Cache-Control' : 'no-cache', 'Cookie' : '__utma=7878317.1843709575.1297205447.1298572822.1298577848.12; __utmz=7878317.1297205447.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); sessid=enqd028n30d2tr4lv4ned04qi0; __utmb=7878317.21.10.1298577848; __utmc=7878317' }
            response = urlfetch.fetch(url, payload=payload, headers=headers, method='POST')
            if response.status_code == 500:
                response = urlfetch.fetch(url, payload=payload, headers=headers, method='POST')
                if response.status_code == 500:
                    self.response.out.write('<strong>FAILED</strong>')
                else:
                    self.response.out.write('<strong>RESULT</strong> OK ' + response.content)
            else:
                self.response.out.write('<strong>RESULT</strong> OK ' + response.content)
        
def main():
    application = webapp.WSGIApplication([
    ('/time/?', WorldClockHandler),
    ('/(md5|sha1)/?', MD5Handler),
    ('/bfbcs/poke/(ps3|360|pc)/(.*)', BFBCSPokeHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = money
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template
from google.appengine.api.labs import taskqueue

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note
from v2ex.babel import Notification

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

from v2ex.babel.handlers import BaseHandler

import config

template.register_template_library('v2ex.templatetags.filters')

class MoneyDashboardHandler(BaseHandler):
    def get(self):
        if self.member:
            self.set_title(u'账户查询')
            self.finalize(template_name='money_dashboard')
        else:
            self.redirect('/signin')

def main():
    application = webapp.WSGIApplication([
    ('/money/dashboard/?', MoneyDashboardHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = my
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

template.register_template_library('v2ex.templatetags.filters')

class MyNodesHandler(webapp.RequestHandler):
    def get(self):
        member = CheckAuth(self)
        if member:
            site = GetSite()
            l10n = GetMessages(self, member, site)
            template_values = {}
            template_values['site'] = site
            template_values['member'] = member
            template_values['l10n'] = l10n
            template_values['page_title'] = site.title + u' › 我收藏的节点'
            template_values['rnd'] = random.randrange(1, 100)
            if member.favorited_nodes > 0:
                template_values['has_nodes'] = True
                q = db.GqlQuery("SELECT * FROM NodeBookmark WHERE member = :1 ORDER BY created DESC LIMIT 0,15", member)
                template_values['column_1'] = q
                if member.favorited_nodes > 15:
                    q2 = db.GqlQuery("SELECT * FROM NodeBookmark WHERE member = :1 ORDER BY created DESC LIMIT 15,15", member)
                    template_values['column_2'] = q2
            else:
                template_values['has_nodes'] = False
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'my_nodes.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/')

class MyTopicsHandler(webapp.RequestHandler):
    def get(self):
        member = CheckAuth(self)
        if member:
            site = GetSite()
            l10n = GetMessages(self, member, site)
            template_values = {}
            template_values['site'] = site
            template_values['member'] = member
            template_values['l10n'] = l10n
            template_values['page_title'] = site.title + u' › 我收藏的主题'
            template_values['rnd'] = random.randrange(1, 100)
            if member.favorited_topics > 0:
                template_values['has_topics'] = True
                q = db.GqlQuery("SELECT * FROM TopicBookmark WHERE member = :1 ORDER BY created DESC", member)
                bookmarks = []
                for bookmark in q:
                    try:
                        topic = bookmark.topic
                        bookmarks.append(bookmark)
                    except:
                        bookmark.delete()
                template_values['bookmarks'] = bookmarks
            else:
                template_values['has_topics'] = False
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'my_topics.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/')
            
class MyFollowingHandler(webapp.RequestHandler):
    def get(self):
        member = CheckAuth(self)
        if member:
            site = GetSite()
            l10n = GetMessages(self, member, site)
            template_values = {}
            template_values['site'] = site
            template_values['member'] = member
            template_values['l10n'] = l10n
            template_values['page_title'] = site.title + u' › 我的特别关注'
            template_values['rnd'] = random.randrange(1, 100)
            if member.favorited_members > 0:
                template_values['has_following'] = True
                q = db.GqlQuery("SELECT * FROM MemberBookmark WHERE member_num = :1 ORDER BY created DESC", member.num)
                template_values['following'] = q
                following = []
                for bookmark in q:
                    following.append(bookmark.one.num)
                q2 = db.GqlQuery("SELECT * FROM Topic WHERE member_num IN :1 ORDER BY created DESC LIMIT 20", following)
                template_values['latest'] = q2
            else:
                template_values['has_following'] = False
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'my_following.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/')

def main():
    application = webapp.WSGIApplication([
    ('/my/nodes', MyNodesHandler),
    ('/my/topics', MyTopicsHandler),
    ('/my/following', MyFollowingHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = notes
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note
from v2ex.babel import Site

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

template.register_template_library('v2ex.templatetags.filters')

class NotesHomeHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 记事本'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
            q = db.GqlQuery("SELECT * FROM Note WHERE member = :1 ORDER BY last_modified DESC", member)
            try:
                notes_count = q.count()
            except:
                q = db.GqlQuery("SELECT * FROM Note WHERE member = :1 ORDER BY created DESC", member)
                notes_count = q.count()
            if (notes_count > 0):
                template_values['notes'] = q
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_home.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_home.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')
            
class NotesNewHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 新建记事'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_new.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_new.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')
    
    def post(self):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 新建记事'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
            # Verification: content
            note_content = self.request.get('content').strip()
            note_content_length = len(note_content)
            if note_content_length > 0:
                note = Note()
                q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'note.max')
                if (q.count() == 1):
                    counter = q[0]
                    counter.value = counter.value + 1
                else:
                    counter = Counter()
                    counter.name = 'note.max'
                    counter.value = 1
                q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'note.total')
                if (q2.count() == 1):
                    counter2 = q2[0]
                    counter2.value = counter2.value + 1
                else:
                    counter2 = Counter()
                    counter2.name = 'note.total'
                    counter2.value = 1
                note.num = counter.value
                note.title = note_content.split("\n")[0][0:60].strip()
                note.content = note_content
                note.body = "\n".join(note_content.split("\n")[1:]).strip()
                note.length = len(note_content)
                note.member_num = member.num
                note.member = member
                note.put()
                counter.put()
                counter2.put()
                self.redirect('/notes/' + str(note.num))
            else:
                template_values['note_content'] = note_content
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_new.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_new.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')

class NotesItemHandler(webapp.RequestHandler):
    def get(self, num):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            q = db.GqlQuery("SELECT * FROM Note WHERE num = :1", int(num))
            if q.count() > 0:
                note = q[0]
                if note.member.num == member.num:
                    template_values['member'] = member
                    template_values['note'] = note
                    template_values['page_title'] = site.title + u' › 记事本 › ' + note.title
                    if browser['ios']:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_item.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_item.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')

class NotesItemEraseHandler(webapp.RequestHandler):
    def get(self, num):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 记事本'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            q = db.GqlQuery("SELECT * FROM Note WHERE num = :1", int(num))
            if q.count() > 0:
                note = q[0]
                if note.member.num == member.num:
                    note.delete()
                    self.redirect('/notes')
                else:
                    self.redirect('/notes')
            else:
                self.redirect('/notes')
        else:
            self.redirect('/signin')

class NotesItemEditHandler(webapp.RequestHandler):
    def get(self, num):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 记事本 › 编辑'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            q = db.GqlQuery("SELECT * FROM Note WHERE num = :1", int(num))
            if q.count() > 0:
                note = q[0]
                if note.member.num == member.num:
                    template_values['member'] = member
                    template_values['note'] = note
                    template_values['note_content'] = note.content
                    if browser['ios']:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_edit.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_edit.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/notes')
            else:
                self.redirect('/notes')
        else:
            self.redirect('/signin')

    def post(self, num):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        template_values['page_title'] = site.title + u' › 记事本'
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            template_values['member'] = member
            # Verification: content
            note_content = self.request.get('content').strip()
            note_content_length = len(note_content)
            if note_content_length > 0:
                q = db.GqlQuery("SELECT * FROM Note WHERE num = :1", int(num))
                if q.count() > 0:
                    note = q[0]
                    template_values['page_title'] = site.title + u' › 记事本 › 编辑' 
                    if note.member.num == member.num:
                        note.title = note_content.split("\n")[0][0:60].strip()
                        note.content = note_content
                        note.body = "\n".join(note_content.split("\n")[1:]).strip()
                        note.length = len(note_content)
                        note.edits = note.edits + 1
                        note.put()
                        memcache.set('Note_' + str(note.num), note, 86400)
                        self.redirect('/notes/' + str(note.num))
                    else:
                        self.redirect('/notes')
                else:
                    self.redirect('/notes')
            else:
                template_values['note_content'] = note_content
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'notes_new.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'notes_new.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')

def main():
    application = webapp.WSGIApplication([
    ('/notes', NotesHomeHandler),
    ('/notes/new', NotesNewHandler),
    ('/notes/([0-9]+)', NotesItemHandler),
    ('/notes/([0-9]+)/erase', NotesItemEraseHandler),
    ('/notes/([0-9]+)/edit', NotesItemEditHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = notifications
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template
from google.appengine.api.labs import taskqueue

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note
from v2ex.babel import Notification

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

from v2ex.babel.handlers import BaseHandler

import config

template.register_template_library('v2ex.templatetags.filters')

class NotificationsHandler(BaseHandler):
    def get(self):
        if self.member:
            if self.member.private_token is None:
                self.member.private_token = hashlib.sha256(str(self.member.num) + ';' + config.site_key).hexdigest()
                self.member.put()
            notifications = memcache.get('nn::' + self.member.username_lower)
            if notifications is None:
                q = db.GqlQuery("SELECT * FROM Notification WHERE for_member_num = :1 ORDER BY num DESC LIMIT 20", self.member.num)
                notifications = []
                i = 0
                for n in q:
                    if i == 0:
                        if self.member.notification_position != n.num:
                            self.member.notification_position = n.num
                            self.member.put()
                    if n.type == 'reply':
                        n.text = u'<a href="/member/' + n.member.username + u'"><strong>' + n.member.username + u'</strong></a> 在 <a href="' + n.link1 + '">' + self.escape(n.label1) + u'</a> 里回复了你'
                        notifications.append(n)
                    if n.type == 'mention_reply':
                        n.text = u'<a href="/member/' + n.member.username + u'"><strong>' + n.member.username + u'</strong></a> 在回复 <a href="' + n.link1 + '">' + self.escape(n.label1) + u'</a> 时提到了你'
                        notifications.append(n)
                    if n.type == 'mention_topic':
                        n.text = u'<a href="/member/' + n.member.username + u'"><strong>' + n.member.username + u'</strong></a> 在创建主题 <a href="' + n.link1 + '">' + self.escape(n.label1) + u'</a> 时提到了你'
                        notifications.append(n)
                    i = i + 1
                self.member.notifications = 0
                self.member.put()
                memcache.set('Member_' + str(self.member.num), self.member, 86400)
                memcache.set('nn::' + self.member.username_lower, notifications, 360)
            self.values['notifications'] = notifications
            self.set_title(u'提醒系统')
            self.finalize(template_name='notifications', mobile_optimized=True)
        else:
            self.redirect('/signin')

class NotificationsCheckHandler(BaseHandler):
    def post(self, member_key):
        member = db.get(db.Key(member_key))
        if member:
            if member.notification_position is None:
                member.notification_position = 0
            q = db.GqlQuery("SELECT __key__ FROM Notification WHERE for_member_num = :1 AND num > :2 ORDER BY num DESC", member.num, member.notification_position)
            count = q.count()
            if count > 0:
                member.notifications = count
                member.put()
                memcache.delete('nn::' + member.username_lower)
                memcache.set('Member_' + str(member.num), member, 86400)

# For mentions in reply content
class NotificationsReplyHandler(BaseHandler):
    def post(self, reply_key):
        reply = db.get(db.Key(reply_key))
        topic = GetKindByNum('Topic', reply.topic_num)
        ms = re.findall('(@[a-zA-Z0-9\_]+\.?)\s?', reply.content)
        unique = []
        for m in ms:
            if m.lower() not in unique:
                unique.append(m.lower())
        keys = []
        if (len(unique) > 0):
            for m in unique:
                m_id = re.findall('@([a-zA-Z0-9\_]+\.?)', m)
                if (len(m_id) > 0):
                    if (m_id[0].endswith('.') != True):
                        member_username = m_id[0]
                        member = GetMemberByUsername(member_username)
                        if member:
                            if (member.key() != topic.member.key()) and (member.key() != reply.member.key()) and (member.key() not in keys):
                                q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.max')
                                if (q.count() == 1):
                                    counter = q[0]
                                    counter.value = counter.value + 1
                                else:
                                    counter = Counter()
                                    counter.name = 'notification.max'
                                    counter.value = 1
                                q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.total')
                                if (q2.count() == 1):
                                    counter2 = q2[0]
                                    counter2.value = counter2.value + 1
                                else:
                                    counter2 = Counter()
                                    counter2.name = 'notification.total'
                                    counter2.value = 1

                                notification = Notification(parent=member)
                                notification.num = counter.value
                                notification.type = 'mention_reply'
                                notification.payload = reply.content
                                notification.label1 = topic.title
                                notification.link1 = '/t/' + str(topic.num) + '#reply' + str(topic.replies)
                                notification.member = reply.member
                                notification.for_member_num = member.num

                                keys.append(str(member.key()))

                                counter.put()
                                counter2.put()
                                notification.put()
        for k in keys:
            taskqueue.add(url='/notifications/check/' + k)

# For mentions in topic title and content
class NotificationsTopicHandler(BaseHandler):
    def post(self, topic_key):
        topic = db.get(db.Key(topic_key))
        combined = topic.title + " " + topic.content
        ms = re.findall('(@[a-zA-Z0-9\_]+\.?)\s?', combined)
        unique = []
        for m in ms:
            if m.lower() not in unique:
                unique.append(m.lower())
        keys = []
        if (len(unique) > 0):
            for m in unique:
                m_id = re.findall('@([a-zA-Z0-9\_]+\.?)', m)
                if (len(m_id) > 0):
                    if (m_id[0].endswith('.') != True):
                        member_username = m_id[0]
                        member = GetMemberByUsername(member_username)
                        if member:
                            if member.key() != topic.member.key() and member.key() not in keys:
                                q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.max')
                                if (q.count() == 1):
                                    counter = q[0]
                                    counter.value = counter.value + 1
                                else:
                                    counter = Counter()
                                    counter.name = 'notification.max'
                                    counter.value = 1
                                q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.total')
                                if (q2.count() == 1):
                                    counter2 = q2[0]
                                    counter2.value = counter2.value + 1
                                else:
                                    counter2 = Counter()
                                    counter2.name = 'notification.total'
                                    counter2.value = 1

                                notification = Notification(parent=member)
                                notification.num = counter.value
                                notification.type = 'mention_topic'
                                notification.payload = topic.content
                                notification.label1 = topic.title
                                notification.link1 = '/t/' + str(topic.num) + '#reply' + str(topic.replies)
                                notification.member = topic.member
                                notification.for_member_num = member.num

                                keys.append(str(member.key()))

                                counter.put()
                                counter2.put()
                                notification.put()
        for k in keys:
            taskqueue.add(url='/notifications/check/' + k)

class NotificationsFeedHandler(BaseHandler):
    def head(self, private_token):
        pass
            
    def get(self, private_token):
        n = memcache.get('n_' + private_token)
        if n is not None:
            self.values['notification'] = n
            self.response.headers['Content-type'] = 'application/xml;charset=UTF-8'
            self.values['member'] = self.member
            self.finalize(template_name='notifications', template_root='feed', template_type='xml')
        else:
            q = db.GqlQuery("SELECT * FROM Member WHERE private_token = :1", private_token)
            count = q.count()
            if count > 0:
                member = q[0]
                q = db.GqlQuery("SELECT * FROM Notification WHERE for_member_num = :1 ORDER BY num DESC LIMIT 20", member.num)
                notifications = []
                i = 0
                for n in q:
                    if n.type == 'reply':
                        n.title = u'' + n.member.username + u' 在 ' + self.escape(n.label1) + u' 里回复了你'
                        n.text = u'<a href="/member/' + n.member.username + u'"><strong>' + n.member.username + u'</strong></a> 在 <a href="' + n.link1 + '">' + self.escape(n.label1) + u'</a> 里回复了你'
                        notifications.append(n)
                    if n.type == 'mention_reply':
                        n.title = u'' + n.member.username + u' 在回复 ' + self.escape(n.label1) + u' 时提到了你'
                        n.text = u'<a href="/member/' + n.member.username + u'"><strong>' + n.member.username + u'</strong></a> 在回复 <a href="' + n.link1 + '">' + self.escape(n.label1) + u'</a> 时提到了你'
                        notifications.append(n)
                    i = i + 1
                self.values['notifications'] = notifications
                memcache.set('n_' + private_token, notifications, 600)
                self.response.headers['Content-type'] = 'application/xml;charset=UTF-8'
                self.values['site'] = GetSite()
                self.values['member'] = member
                self.finalize(template_name='notifications', template_root='feed', template_type='xml')

def main():
    application = webapp.WSGIApplication([
    ('/notifications/?', NotificationsHandler),
    ('/notifications/check/(.+)', NotificationsCheckHandler),
    ('/notifications/reply/(.+)', NotificationsReplyHandler),
    ('/notifications/topic/(.+)', NotificationsTopicHandler),
    ('/n/([a-z0-9]+).xml', NotificationsFeedHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = page
#!/usr/bin/env python
# coding=utf-8

import os
import datetime
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Site

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

template.register_template_library('v2ex.templatetags.filters')

class AboutHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        note = GetKindByNum('Note', 127)
        if note is False:
            note = GetKindByNum('Note', 2)
        template_values['note'] = note
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › About'
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'about.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
class FAQHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        note = GetKindByNum('Note', 195)
        if note is False:
            note = GetKindByNum('Note', 4)
        template_values['note'] = note
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › FAQ'
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'faq.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class MissionHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        note = GetKindByNum('Note', 240)
        if note is False:
            note = GetKindByNum('Note', 5)
        template_values['note'] = note
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › Mission'
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'mission.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class AdvertiseHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › Advertise'
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'advertise.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

class AdvertisersHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        template_values['page_title'] = site.title + u' › Advertisers'
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'advertisers.html')
        output = template.render(path, template_values)
        self.response.out.write(output)

def main():
    application = webapp.WSGIApplication([
    ('/about', AboutHandler),
    ('/faq', FAQHandler),
    ('/mission', MissionHandler),
    ('/advertise', AdvertiseHandler),
    ('/advertisers', AdvertisersHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = place
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note
from v2ex.babel import Place
from v2ex.babel import PlaceMessage

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

template.register_template_library('v2ex.templatetags.filters')

class PlaceHandler(webapp.RequestHandler):
    def get(self, ip):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        member = CheckAuth(self)
        if member:
            template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['ip'] = ip
        substance = GetPlaceByIP(ip)
        if substance:
            template_values['substance'] = substance
            template_values['messages'] = db.GqlQuery("SELECT * FROM PlaceMessage WHERE place = :1 ORDER BY created DESC LIMIT 30", substance)
        else:
            if member:
                if member.ip == ip:
                    substance = CreatePlaceByIP(ip)
                    template_values['substance'] = substance
        can_post = False
        can_see = True
        if member:
            if member.ip == ip:
                can_post = True
                can_see = True
            else:
                can_see = False
        else:
            if 'X-Real-IP' in self.request.headers:
                ip_guest = self.request.headers['X-Real-IP']
            else:
                ip_guest = self.request.remote_addr
            if ip_guest == ip:
                can_see = True
            else:
                can_see = False
        template_values['can_post'] = can_post
        template_values['can_see'] = can_see
        if member:
            template_values['ip_guest'] = member.ip
        else:
            template_values['ip_guest'] = ip_guest
        template_values['page_title'] = site.title + u' › ' + ip
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'place.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
    
    def post(self, ip):
        site = GetSite()
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/place'
        member = CheckAuth(self)
        place = GetPlaceByIP(ip)
        say = self.request.get('say').strip()
        if len(say) > 0 and len(say) < 280 and member and place:
            if member.ip == ip:
                message = PlaceMessage()
                q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'place_message.max')
                if (q.count() == 1):
                    counter = q[0]
                    counter.value = counter.value + 1
                else:
                    counter = Counter()
                    counter.name = 'place_message.max'
                    counter.value = 1
                q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'place_message.total')
                if (q2.count() == 1):
                    counter2 = q2[0]
                    counter2.value = counter2.value + 1
                else:
                    counter2 = Counter()
                    counter2.name = 'place_message.total'
                    counter2.value = 1
                message.num = counter.value
                message.place = place
                message.place_num = place.num
                message.member = member
                message.content = say
                message.put()
                counter.put()
                counter2.put()
        self.redirect(go)

class PlaceMessageRemoveHandler(webapp.RequestHandler):
    def get(self, key):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/place'
        member = CheckAuth(self)
        if member:
            message = db.get(db.Key(key))
            if message:
                if message.member.num == member.num:
                    message.delete()
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'place_message.total')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value - 1
                        counter.put()
        self.redirect(go)

def main():
    application = webapp.WSGIApplication([
    ('/place/([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})', PlaceHandler),
    ('/remove/place_message/(.*)', PlaceMessageRemoveHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = queue
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *

class AddStarTopicHandler(webapp.RequestHandler):
    def post(self, topic_key):
        topic = db.get(db.Key(topic_key))
        if topic:
            topic.stars = topic.stars + 1
            topic.put()
            memcache.set('Topic_' + str(topic.num), topic, 86400)

class MinusStarTopicHandler(webapp.RequestHandler):
    def post(self, topic_key):
        topic = db.get(db.Key(topic_key))
        if topic:
            topic.stars = topic.stars - 1
            topic.put()
            memcache.set('Topic_' + str(topic.num), topic, 86400)


def main():
    application = webapp.WSGIApplication([
    ('/add/star/topic/(.*)', AddStarTopicHandler),
    ('/minus/star/topic/(.*)', MinusStarTopicHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = sso
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

import config

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

template.register_template_library('v2ex.templatetags.filters')

class SSOV0Handler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        self.response.headers['Content-type'] = 'application/json'
        u = self.request.get('u').strip().lower()
        p = self.request.get('p').strip()
        failed = '{"ok" : 0}'
        if (len(u) > 0) and (len(p) > 0):
            q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1 AND password = :2", u, p)
            if q.count() > 0:
                member = q[0]
                if member.avatar_mini_url:
                    if (member.avatar_mini_url[0:1] == '/'):
                        member.avatar_mini_url = 'http://' + site.domain + member.avatar_mini_url
                        member.avatar_normal_url = 'http://' +  site.domain + member.avatar_normal_url
                        member.avatar_large_url = 'http://' + site.domain + member.avatar_large_url
                else:
                    member.avatar_mini_url = 'http://' + site.domain + '/static/img/avatar_mini.png'
                    member.avatar_normal_url = 'http://' + site.domain + '/static/img/avatar_normal.png'
                    member.avatar_large_url = 'http://' + site.domain + '/static/img/avatar_large.png'
                self.response.out.write('{"ok" : 1, "num" : ' + str(member.num) + ', "username" : "' + member.username + '", "username_lower" : "' + member.username_lower + '", "email" : "' + member.email + '", "avatar_mini_url" : "' + member.avatar_mini_url + '", "avatar_normal_url" : "' + member.avatar_normal_url + '", "avatar_large_url" : "' + member.avatar_large_url + '", "created" : ' + str(time.mktime(member.created.timetuple())) + ', "last_modified" : ' + str(time.mktime(member.last_modified.timetuple())) + '}')
            else:
                self.response.out.write(failed)
        else:
            self.response.out.write(failed)

class SSOX0Handler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        self.response.headers['Content-type'] = 'application/json'
        x = self.request.get('x').strip()
        n = self.request.get('n').strip().lower()
        failed = '{"ok" : 0}'
        if x == config.ssox:
            q = db.GqlQuery("SELECT * FROM Member WHERE username_lower = :1", n)
            if q.count() > 0:
                member = q[0]
                if member.avatar_mini_url:
                    if (member.avatar_mini_url[0:1] == '/'):
                        member.avatar_mini_url = 'http://' + site.domain + member.avatar_mini_url
                        member.avatar_normal_url = 'http://' +  site.domain + member.avatar_normal_url
                        member.avatar_large_url = 'http://' + site.domain + member.avatar_large_url
                else:
                    member.avatar_mini_url = 'http://' + site.domain + '/static/img/avatar_mini.png'
                    member.avatar_normal_url = 'http://' + site.domain + '/static/img/avatar_normal.png'
                    member.avatar_large_url = 'http://' + site.domain + '/static/img/avatar_large.png'
                self.response.out.write('{"ok" : 1, "num" : ' + str(member.num) + ', "username" : "' + member.username + '", "username_lower" : "' + member.username_lower + '", "email" : "' + member.email + '", "password" : "' + member.password + '", "avatar_mini_url" : "' + member.avatar_mini_url + '", "avatar_normal_url" : "' + member.avatar_normal_url + '", "avatar_large_url" : "' + member.avatar_large_url + '", "created" : ' + str(time.mktime(member.created.timetuple())) + ', "last_modified" : ' + str(time.mktime(member.last_modified.timetuple())) + '}')
            else:
                self.response.out.write(failed)
        else:
            self.response.out.write(failed)
            

def main():
    application = webapp.WSGIApplication([
    ('/sso/v0', SSOV0Handler),
    ('/sso/x0', SSOX0Handler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = t
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random
import logging

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from twitter.oauthtwitter import OAuthApi
from twitter.oauth import OAuthToken

from config import twitter_consumer_key as CONSUMER_KEY
from config import twitter_consumer_secret as CONSUMER_SECRET

template.register_template_library('v2ex.templatetags.filters')

class TwitterLinkHandler(webapp.RequestHandler):
    def get(self):
        self.session = Session()
        member = CheckAuth(self)
        if member:
            twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET)
            request_token = twitter.getRequestToken()
            authorization_url = twitter.getAuthorizationURL(request_token)
            self.session['request_token'] = request_token
            self.redirect(authorization_url)
        else:
            self.redirect('/signin')

class TwitterUnlinkHandler(webapp.RequestHandler):
    def get(self):
        self.session = Session()
        member = CheckAuth(self)
        if member:
            memcache.delete('Member_' + str(member.num))
            member = GetKindByNum('Member', member.num)
            member.twitter_oauth = 0
            member.twitter_oauth_key = ''
            member.twitter_oauth_secret = ''
            member.twitter_sync = 0
            member.put()
            memcache.set('Member_' + str(member.num), member, 86400)
            self.redirect('/settings')
        else:
            self.redirect('/signin')

class TwitterCallbackHandler(webapp.RequestHandler):
    def get(self):
        self.session = Session()
        member = CheckAuth(self)
        host = self.request.headers['Host']
        if host == 'localhost:10000' or host == '127.0.0.1:10000':
            # Local debugging logic
            if member:
                request_token = self.session['request_token']
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, request_token)
                access_token = twitter.getAccessToken()
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                user = twitter.GetUserInfo()
                memcache.delete('Member_' + str(member.num))
                member = db.get(member.key())
                member.twitter_oauth = 1
                member.twitter_oauth_key = access_token.key
                member.twitter_oauth_secret = access_token.secret
                member.twitter_oauth_string = access_token.to_string()
                member.twitter_sync = 0
                member.twitter_id = user.id
                member.twitter_name = user.name
                member.twitter_screen_name = user.screen_name
                member.twitter_location = user.location
                member.twitter_description = user.description
                member.twitter_profile_image_url = user.profile_image_url
                member.twitter_url = user.url
                member.twitter_statuses_count = user.statuses_count
                member.twitter_followers_count = user.followers_count
                member.twitter_friends_count = user.friends_count
                member.twitter_favourites_count = user.favourites_count
                member.put()
                memcache.set('Member_' + str(member.num), member, 86400)
                self.redirect('/settings')
            else:
                self.redirect('/signin')
        else:
            # Remote production logic
            if member and 'request_token' in self.session:
                request_token = self.session['request_token']
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, request_token)
                access_token = twitter.getAccessToken()
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                user = twitter.GetUserInfo()
                memcache.delete('Member_' + str(member.num))
                member = db.get(member.key())
                member.twitter_oauth = 1
                member.twitter_oauth_key = access_token.key
                member.twitter_oauth_secret = access_token.secret
                member.twitter_oauth_string = access_token.to_string()
                member.twitter_sync = 0
                member.twitter_id = user.id
                member.twitter_name = user.name
                member.twitter_screen_name = user.screen_name
                member.twitter_location = user.location
                member.twitter_description = user.description
                member.twitter_profile_image_url = user.profile_image_url
                member.twitter_url = user.url
                member.twitter_statuses_count = user.statuses_count
                member.twitter_followers_count = user.followers_count
                member.twitter_friends_count = user.friends_count
                member.twitter_favourites_count = user.favourites_count
                member.put()
                memcache.set('Member_' + str(member.num), member, 86400)
                self.redirect('/settings')
            else:
                oauth_token = self.request.get('oauth_token')
                if host == 'v2ex.appspot.com':
                    self.redirect('http://www.v2ex.com/twitter/oauth?oauth_token=' + oauth_token)
                else:
                    self.redirect('http://v2ex.appspot.com/twitter/oauth?oauth_token=' + oauth_token)        

class TwitterHomeHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        member = CheckAuth(self)
        if member:
            if member.twitter_oauth == 1:
                template_values = {}
                template_values['site'] = site
                template_values['rnd'] = random.randrange(1, 100)
                template_values['member'] = member
                l10n = GetMessages(self, member, site)
                template_values['l10n'] = l10n
                template_values['page_title'] = site.title + u' › Twitter › Home'
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                rate_limit = memcache.get(str(member.twitter_id) + '::rate_limit')
                if rate_limit is None:
                    try:
                        rate_limit = twitter.GetRateLimit()
                        memcache.set(str(member.twitter_id) + '::rate_limit', rate_limit, 60)
                    except:
                        logging.info('Failed to get rate limit for @' + member.twitter_screen_name)
                template_values['rate_limit'] = rate_limit
                cache_tag = 'member::' + str(member.num) + '::twitter::home'
                statuses = memcache.get(cache_tag)
                if statuses is None:
                    statuses = twitter.GetHomeTimeline(count = 50)
                    i = 0;
                    for status in statuses:
                        statuses[i].source = statuses[i].source.replace('<a', '<a class="dark"')
                        statuses[i].datetime = datetime.datetime.fromtimestamp(time.mktime(time.strptime(status.created_at, '%a %b %d %H:%M:%S +0000 %Y')))
                        statuses[i].text = twitter.ConvertMentions(status.text)
                        #statuses[i].text = twitter.ExpandBitly(status.text)
                        i = i + 1
                    memcache.set(cache_tag, statuses, 120)
                template_values['statuses'] = statuses
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_home.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/settings')
        else:
            self.redirect('/')

class TwitterMentionsHandler(webapp.RequestHandler):
    def get(self):
        site = GetSite()
        member = CheckAuth(self)
        if member:
            if member.twitter_oauth == 1:
                template_values = {}
                template_values['site'] = site
                template_values['rnd'] = random.randrange(1, 100)
                template_values['member'] = member
                l10n = GetMessages(self, member, site)
                template_values['l10n'] = l10n
                template_values['page_title'] = site.title + u' › Twitter › Mentions'
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                rate_limit = memcache.get(str(member.twitter_id) + '::rate_limit')
                if rate_limit is None:
                    try:
                        rate_limit = twitter.GetRateLimit()
                        memcache.set(str(member.twitter_id) + '::rate_limit', rate_limit, 60)
                    except:
                        logging.info('Failed to get rate limit for @' + member.twitter_screen_name)
                template_values['rate_limit'] = rate_limit
                cache_tag = 'member::' + str(member.num) + '::twitter::mentions'
                statuses = memcache.get(cache_tag)
                if statuses is None:
                    statuses = twitter.GetReplies()
                    i = 0;
                    for status in statuses:
                        statuses[i].source = statuses[i].source.replace('<a', '<a class="dark"')
                        statuses[i].datetime = datetime.datetime.fromtimestamp(time.mktime(time.strptime(status.created_at, '%a %b %d %H:%M:%S +0000 %Y')))
                        statuses[i].text = twitter.ConvertMentions(status.text)
                        #statuses[i].text = twitter.ExpandBitly(status.text)
                        i = i + 1
                    memcache.set(cache_tag, statuses, 120)
                template_values['statuses'] = statuses
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_mentions.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/settings')
        else:
            self.redirect('/')

class TwitterDMInboxHandler(webapp.RequestHandler):
    def get(self):
        member = CheckAuth(self)
        site = GetSite()
        if member:
            if member.twitter_oauth == 1:
                template_values = {}
                template_values['site'] = site
                template_values['rnd'] = random.randrange(1, 100)
                template_values['member'] = member
                l10n = GetMessages(self, member, site)
                template_values['l10n'] = l10n
                template_values['page_title'] = site.title + u' › Twitter › Direct Messages › Inbox'
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                rate_limit = memcache.get(str(member.twitter_id) + '::rate_limit')
                if rate_limit is None:
                    try:
                        rate_limit = twitter.GetRateLimit()
                        memcache.set(str(member.twitter_id) + '::rate_limit', rate_limit, 60)
                    except:
                        logging.info('Failed to get rate limit for @' + member.twitter_screen_name)
                template_values['rate_limit'] = rate_limit
                cache_tag = 'member::' + str(member.num) + '::twitter::dm::inbox'
                messages = memcache.get(cache_tag)
                if messages is None:
                    messages = twitter.GetDirectMessages()
                    i = 0;
                    for message in messages:
                        messages[i].datetime = datetime.datetime.fromtimestamp(time.mktime(time.strptime(message.created_at, '%a %b %d %H:%M:%S +0000 %Y')))
                        messages[i].text = twitter.ConvertMentions(message.text)
                        #statuses[i].text = twitter.ExpandBitly(status.text)
                        i = i + 1
                    memcache.set(cache_tag, messages, 120)
                template_values['messages'] = messages
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_dm_inbox.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/settings')
        else:
            self.redirect('/')

class TwitterUserTimelineHandler(webapp.RequestHandler):
    def get(self, screen_name):
        site = GetSite()
        member = CheckAuth(self)
        if member:
            if member.twitter_oauth == 1:
                template_values = {}
                template_values['site'] = site
                template_values['rnd'] = random.randrange(1, 100)
                template_values['member'] = member
                l10n = GetMessages(self, member, site)
                template_values['l10n'] = l10n
                template_values['page_title'] = site.title + u' › Twitter › ' + screen_name
                template_values['screen_name'] = screen_name
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                rate_limit = memcache.get(str(member.twitter_id) + '::rate_limit')
                if rate_limit is None:
                    try:
                        rate_limit = twitter.GetRateLimit()
                        memcache.set(str(member.twitter_id) + '::rate_limit', rate_limit, 60)
                    except:
                        logging.info('Failed to get rate limit for @' + member.twitter_screen_name)
                template_values['rate_limit'] = rate_limit
                cache_tag = 'twitter::' + screen_name + '::home'
                statuses = memcache.get(cache_tag)
                if statuses is None:
                    statuses = twitter.GetUserTimeline(user=screen_name, count = 50)
                    i = 0;
                    for status in statuses:
                        statuses[i].source = statuses[i].source.replace('<a', '<a class="dark"')
                        statuses[i].datetime = datetime.datetime.fromtimestamp(time.mktime(time.strptime(status.created_at, '%a %b %d %H:%M:%S +0000 %Y')))
                        statuses[i].text = twitter.ConvertMentions(status.text)
                        #statuses[i].text = twitter.ExpandBitly(status.text)
                        i = i + 1
                    memcache.set(cache_tag, statuses, 120)
                template_values['statuses'] = statuses
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_user.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/settings')
        else:
            self.redirect('/')
                        
class TwitterTweetHandler(webapp.RequestHandler):
    def post(self):
        if 'Referer' in self.request.headers:
            go = self.request.headers['Referer']
        else:
            go = '/'
        member = CheckAuth(self)
        if member:
            if member.twitter_oauth == 1:
                status = self.request.get('status')
                if len(status) > 140:
                    status = status[0:140]
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                try:
                    twitter.PostUpdate(status.encode('utf-8'))
                    memcache.delete('member::' + str(member.num) + '::twitter::home')
                except:
                    logging.error('Failed to tweet: ' + status)
                self.redirect(go)
            else:
                self.redirect('/twitter/link')
        else:
            self.redirect('/')
        
class TwitterApiCheatSheetHandler(webapp.RequestHandler):
    def head(self):
        template_values = {}
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_api_cheat_sheet.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
    def get(self):
        template_values = {}
        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'twitter_api_cheat_sheet.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
def main():
    application = webapp.WSGIApplication([
    ('/twitter/?', TwitterHomeHandler),
    ('/twitter/mentions/?', TwitterMentionsHandler),
    ('/twitter/inbox/?', TwitterDMInboxHandler),
    ('/twitter/user/([a-zA-Z0-9\_]+)', TwitterUserTimelineHandler),
    ('/twitter/link', TwitterLinkHandler),
    ('/twitter/unlink', TwitterUnlinkHandler),
    ('/twitter/oauth', TwitterCallbackHandler),
    ('/twitter/tweet', TwitterTweetHandler),
    ('/twitter/api/?', TwitterApiCheatSheetHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = template
#!/usr/bin/env python
# coding=utf-8

import os
import re
import time
import datetime
import hashlib
import string
import random

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Note

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies

template.register_template_library('v2ex.templatetags.filters')

class MyNodesHandler(webapp.RequestHandler):
    def get(self):
        member = CheckAuth(self)
        if member:
            site = GetSite()
            l10n = GetMessages(self, member, site)
            template_values = {}
            template_values['site'] = site
            template_values['member'] = member
            template_values['l10n'] = l10n
            template_values['page_title'] = site.title + u' › 我收藏的节点'
            template_values['rnd'] = random.randrange(1, 100)
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'my_nodes.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/')

def main():
    application = webapp.WSGIApplication([
    ('/my/nodes', MyNodesHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = topic
#!/usr/bin/env python
# coding=utf-8

import base64
import os
import re
import time
import datetime
import hashlib
import string
import random
import pickle
import zlib
import math

from google.appengine.ext import webapp
from google.appengine.api import memcache
from google.appengine.api import urlfetch
from google.appengine.api.labs import taskqueue
from google.appengine.ext import db
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template

from v2ex.babel import Member
from v2ex.babel import Counter
from v2ex.babel import Section
from v2ex.babel import Node
from v2ex.babel import Topic
from v2ex.babel import Reply
from v2ex.babel import Notification

from v2ex.babel import SYSTEM_VERSION

from v2ex.babel.security import *
from v2ex.babel.ua import *
from v2ex.babel.da import *
from v2ex.babel.l10n import *
from v2ex.babel.ext.cookies import Cookies
from v2ex.babel.ext.sessions import Session

from django.utils import simplejson as json

from twitter.oauthtwitter import OAuthApi
from twitter.oauth import OAuthToken

from config import twitter_consumer_key as CONSUMER_KEY
from config import twitter_consumer_secret as CONSUMER_SECRET

template.register_template_library('v2ex.templatetags.filters')

import config

TOPIC_PAGE_SIZE = 100

class NewTopicHandler(webapp.RequestHandler):
    def get(self, node_name):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['page_title'] = site.title + u' › ' + l10n.create_new_topic.decode('utf-8')
        can_create = False
        if site.topic_create_level > 999:
            if member:
                can_create = True
        else:
            if member:
                if member.level <= site.topic_create_level:
                    can_create = True
        if (member):
            template_values['member'] = member
            node = GetKindByName('Node', node_name)
            if node is False:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node_not_found.html')
                output = template.render(path, template_values)
                return self.response.out.write(output)
            template_values['node'] = node
            section = GetKindByNum('Section', node.section_num)
            template_values['section'] = section
            if site.use_topic_types:
                types = site.topic_types.split("\n")
                options = '<option value="0">&nbsp;&nbsp;&nbsp;&nbsp;</option>'
                i = 0
                for a_type in types:
                    i = i + 1
                    detail = a_type.split(':')
                    options = options + '<option value="' + str(i) + '">' + detail[0] + '</option>'
                tt = '<div class="sep5"></div><table cellpadding="5" cellspacing="0" border="0" width="100%"><tr><td width="60" align="right">Topic Type</td><td width="auto" align="left"><select name="type">' + options + '</select></td></tr></table>'
                template_values['tt'] = tt
            else:
                template_values['tt'] = ''
            if can_create:
                if browser['ios']:
                    if node:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'new_topic.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'node_not_found.html')
                else:
                    if node:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'new_topic.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'node_not_found.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'access_denied.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
        else:
            self.redirect('/signin')

    def post(self, node_name):
        site = GetSite()
        ### BEGIN: CAN CONTINUE
        can_continue = True
        if ('Host' in self.request.headers):
            if (self.request.headers['Host'] not in ['www.v2ex.com', 'v2ex.appspot.com', 'fast.v2ex.com', 'beta.v2ex.com', 'us.v2ex.com', 'jp.v2ex.com', 'eu.v2ex.com', 'localhost:10000']):
                can_continue = False
        else:
            can_continue = False
        if ('User-Agent' not in self.request.headers):
            can_continue = False
        if ('Cookie' not in self.request.headers):
            can_continue = False
        if ('Referer' in self.request.headers):
            has_v2ex = False
            if ('http://localhost:10000' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://www.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://v2ex.appspot.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('https://www.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://jp.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://eu.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://us.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('https://v2ex.appspot.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://fast.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://beta.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://' + str(site.domain) in self.request.headers['Referer']):
                has_v2ex = True
            if has_v2ex is False:
                can_continue = False
        else:
            can_continue = False
        if ('Content-Type' in self.request.headers):
            if self.request.headers['Content-Type'].startswith( 'application/x-www-form-urlencoded') is False:
                can_continue = False
        else:
            can_continue = False
        if can_continue is False:
            return self.redirect('http://' + site.domain + '/')
        ### END: CAN CONTINUE
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        template_values['page_title'] = site.title + u' › ' + l10n.create_new_topic.decode('utf-8')
        can_create = False
        if site.topic_create_level > 999:
            if member:
                can_create = True
        else:
            if member:
                if member.level <= site.topic_create_level:
                    can_create = True
        if (member):
            template_values['member'] = member
            if can_create:
                node = False
                node = GetKindByName('Node', node_name)
                template_values['node'] = node
                section = False
                if node:
                    section = GetKindByNum('Section', node.section_num)
                template_values['section'] = section
                errors = 0
                # Verification: title
                topic_title_error = 0
                topic_title_error_messages = ['',
                    u'请输入主题标题',
                    u'主题标题长度不能超过 120 个字符'
                    ]
                topic_title = self.request.get('title').strip().replace("\n", " ")
                if (len(topic_title) == 0):
                    errors = errors + 1
                    topic_title_error = 1
                else:
                    if (len(topic_title) > 120):
                        errors = errors + 1
                        topic_title_error = 2
                template_values['topic_title'] = topic_title
                template_values['topic_title_error'] = topic_title_error
                template_values['topic_title_error_message'] = topic_title_error_messages[topic_title_error]
                # Verification: content
                topic_content_error = 0
                topic_content_error_messages = ['',
                    u'主题内容长度不能超过 200000 个字符'
                ]
                topic_content = self.request.get('content').strip()
                topic_content_length = len(topic_content)
                if (topic_content_length > 0):
                    if (topic_content_length > 200000):
                        errors = errors + 1
                        topic_content_error = 1
                template_values['topic_content'] = topic_content
                template_values['topic_content_error'] = topic_content_error
                template_values['topic_content_error_message'] = topic_content_error_messages[topic_content_error]
                # Verification: type
                if site.use_topic_types:
                    types = site.topic_types.split("\n")
                    if len(types) > 0:
                        topic_type = self.request.get('type').strip()
                        try:
                            topic_type = int(topic_type)
                            if topic_type < 0:
                                topic_type = 0
                            if topic_type > len(types):
                                topic_type = 0
                            if topic_type > 0:
                                detail = types[topic_type - 1].split(':')
                                topic_type_label = detail[0]
                                topic_type_color = detail[1]
                        except:
                            topic_type = 0
                    else:
                        topic_type = 0
                    options = '<option value="0">&nbsp;&nbsp;&nbsp;&nbsp;</option>'
                    i = 0
                    for a_type in types:
                        i = i + 1
                        detail = a_type.split(':')
                        if topic_type == i:
                            options = options + '<option value="' + str(i) + '" selected="selected">' + detail[0] + '</option>'
                        else:
                            options = options + '<option value="' + str(i) + '">' + detail[0] + '</option>'
                    tt = '<div class="sep5"></div><table cellpadding="5" cellspacing="0" border="0" width="100%"><tr><td width="60" align="right">Topic Type</td><td width="auto" align="left"><select name="type">' + options + '</select></td></tr></table>'
                    template_values['tt'] = tt
                else:
                    template_values['tt'] = ''
                template_values['errors'] = errors
                if (errors == 0):
                    topic = Topic(parent=node)
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'topic.max')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value + 1
                    else:
                        counter = Counter()
                        counter.name = 'topic.max'
                        counter.value = 1
                    q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'topic.total')
                    if (q2.count() == 1):
                        counter2 = q2[0]
                        counter2.value = counter2.value + 1
                    else:
                        counter2 = Counter()
                        counter2.name = 'topic.total'
                        counter2.value = 1
                    topic.num = counter.value
                    topic.title = topic_title
                    topic.content = topic_content
                    if len(topic_content) > 0:
                        topic.has_content = True
                        topic.content_length = topic_content_length
                    else:
                        topic.has_content = False
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'topic_content.html')
                    output = template.render(path, {'topic' : topic})
                    topic.content_rendered = output.decode('utf-8')
                    topic.node = node
                    topic.node_num = node.num
                    topic.node_name = node.name
                    topic.node_title = node.title
                    topic.created_by = member.username
                    topic.member = member
                    topic.member_num = member.num
                    topic.last_touched = datetime.datetime.now()
                    ua = self.request.headers['User-Agent']
                    if (re.findall('Mozilla\/5.0 \(iPhone;', ua)):
                        topic.source = 'iPhone'
                    if (re.findall('Mozilla\/5.0 \(iPod;', ua)):
                        topic.source = 'iPod'
                    if (re.findall('Mozilla\/5.0 \(iPad;', ua)):
                        topic.source = 'iPad'
                    if (re.findall('Android', ua)):
                        topic.source = 'Android'
                    if (re.findall('Mozilla\/5.0 \(PLAYSTATION 3;', ua)):
                        topic.source = 'PS3'
                    if site.use_topic_types:
                        if topic_type > 0:
                            topic.type = topic_type_label
                            topic.type_color = topic_type_color          
                    node.topics = node.topics + 1
                    node.put()
                    topic.put()
                    counter.put()
                    counter2.put()
                    memcache.delete('feed_index')
                    memcache.delete('Node_' + str(topic.node_num))
                    memcache.delete('Node::' + str(node.name))
                    memcache.delete('q_latest_16')
                    memcache.delete('home_rendered')
                    memcache.delete('home_rendered_mobile')
                    try:
                        taskqueue.add(url='/index/topic/' + str(topic.num))
                    except:
                        pass
                    
                    # Twitter Sync
                    if member.twitter_oauth == 1 and member.twitter_sync == 1:
                        access_token = OAuthToken.from_string(member.twitter_oauth_string)
                        twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                        status = topic.title + ' #' + topic.node.name + ' http://' + self.request.headers['Host'] + '/t/' + str(topic.num)
                        try:
                            twitter.PostUpdate(status.encode('utf-8'))
                        except:
                            logging.error("Failed to sync to Twitter for Topic #" + str(topic.num))
                    # Change newbie status?
                    if member.newbie == 1:
                        now = datetime.datetime.now()
                        created = member.created
                        diff = now - created
                        if diff.seconds > (86400 * 60):
                            member.newbie = 0
                            member.put()
                    
                    # Notifications: mention_topic
                    taskqueue.add(url='/notifications/topic/' + str(topic.key()))
                    
                    self.redirect('/t/' + str(topic.num) + '#reply0')
                else:    
                    if browser['ios']:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'new_topic.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'new_topic.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'access_denied.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')

class TopicHandler(webapp.RequestHandler):
    def get(self, topic_num):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['rnd'] = random.randrange(1, 100)
        reply_reversed = self.request.get('r')
        if reply_reversed == '1':
            reply_reversed = True
        else:
            reply_reversed = False
        filter_mode = self.request.get('f')
        if filter_mode == '1':
            filter_mode = True
        else:
            filter_mode = False
        template_values['reply_reversed'] = reply_reversed
        template_values['filter_mode'] = filter_mode
        template_values['system_version'] = SYSTEM_VERSION
        errors = 0
        template_values['errors'] = errors
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member is not False:
            try:
                blocked = pickle.loads(member.blocked.encode('utf-8'))
            except:
                blocked = []
            if (len(blocked) > 0):
                template_values['blocked'] = ','.join(map(str, blocked))
            if member.level == 0:
                template_values['is_admin'] = 1
            else:
                template_values['is_admin'] = 0
        topic_num_str = str(topic_num)
        if len(topic_num_str) > 8:
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic_not_found.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'topic_not_found.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
            return
        topic = False
        topic = memcache.get('Topic_' + str(topic_num))
        if topic is None:
            q = db.GqlQuery("SELECT * FROM Topic WHERE num = :1", int(topic_num))
            if (q.count() == 1):
                topic = q[0]
                memcache.set('Topic_' + str(topic_num), topic, 86400)
        can_edit = False
        can_move = False
        if topic:
            if topic.content:
                template_values['page_description'] = topic.content[:60] + ' - ' + topic.member.username
            else:
                template_values['page_description'] = topic.title[:60] + ' - ' + topic.member.username
            template_values['page_description'] = template_values['page_description'].replace("\r\n", " ")
            if member:
                if member.level == 0:
                    can_edit = True
                    can_move = True
                if topic.member_num == member.num:
                    now = datetime.datetime.now()
                    if (now - topic.created).seconds < 300:
                        can_edit = True
                        can_move = True
            try:
                taskqueue.add(url='/hit/topic/' + str(topic.key()))
            except:
                pass
            template_values['page_title'] = site.title + u' › ' + topic.title
            template_values['canonical'] = 'http://' + site.domain + '/t/' + str(topic.num)
            if topic.content_rendered is None:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'topic_content.html')
                output = template.render(path, {'topic' : topic})
                topic = db.get(topic.key())
                topic.content_rendered = output.decode('utf-8')
                memcache.delete('Topic_' + str(topic.num))
                topic.put()
        else:
            template_values['page_title'] = site.title + u' › 主题未找到'
        template_values['topic'] = topic
        template_values['can_edit'] = can_edit
        template_values['can_move'] = can_move
        if (topic):
            node = False
            section = False
            node = GetKindByNum('Node', topic.node_num)
            if (node):
                section = GetKindByNum('Section', node.section_num)
            template_values['node'] = node
            template_values['section'] = section
            
            page_size = TOPIC_PAGE_SIZE
            pages = 1
            if topic.replies > page_size:
                if (topic.replies % page_size) > 0:
                    pages = int(math.floor(topic.replies / page_size)) + 1
                else:
                    pages = int(math.floor(topic.replies / page_size))
            try:
                page_current = int(self.request.get('p'))
                if page_current < 1:
                    page_current = 1
                if page_current > pages:
                    page_current = pages
            except:
                page_current = pages
            page_start = (page_current - 1) * page_size
            template_values['pages'] = pages
            template_values['page_current'] = page_current
            
            template_values['ps'] = False
            i = 1
            ps = []
            while i <= pages:
                ps.append(i)
                i = i + 1
            if len(ps) > 1:
                template_values['ps'] = ps
            replies = False
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'topic_replies_mobile.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'topic_replies.html')
            if filter_mode:
                if browser['ios']:
                    r_tag = 'topic_' + str(topic.num) + '_replies_filtered_rendered_ios_' + str(page_current)
                else:
                    r_tag = 'topic_' + str(topic.num) + '_replies_filtered_rendered_desktop_' + str(page_current)
                r = memcache.get(r_tag)
                if r is None:
                    replies = memcache.get('topic_' + str(topic.num) + '_replies_filtered_compressed_' + str(page_current))
                    if replies is None:
                        q5 = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 AND member_num = :2 ORDER BY created ASC LIMIT " + str(page_start) + "," + str(page_size), topic.num, topic.member.num)
                        replies = q5
                        memcache.set('topic_' + str(topic.num) + '_replies_filtered_compressed_' + str(page_current), GetPacked(replies), 7200)
                    else:
                        replies = GetUnpacked(replies)
                    template_values['replies'] = replies
                    template_values['replies_count'] = replies.count()
                    r = template.render(path, template_values)
                    memcache.set(r_tag, r, 86400)
            else:    
                if reply_reversed:
                    if browser['ios']:
                        r_tag = 'topic_' + str(topic.num) + '_replies_desc_rendered_ios_' + str(page_current)
                    else:
                        r_tag = 'topic_' + str(topic.num) + '_replies_desc_rendered_desktop_' + str(page_current)
                    r = memcache.get(r_tag)
                    if r is None:
                        replies = memcache.get('topic_' + str(topic.num) + '_replies_desc_compressed_' + str(page_current))
                        if replies is None:
                            q4 = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 ORDER BY created DESC LIMIT " + str(page_start) + "," + str(page_size), topic.num)
                            replies = q4
                            memcache.set('topic_' + str(topic.num) + '_replies_desc_compressed_' + str(page_current), GetPacked(q4), 86400)
                        else:
                            replies = GetUnpacked(replies)
                        template_values['replies'] = replies
                        template_values['replies_count'] = replies.count()
                        r = template.render(path, template_values)
                        memcache.set(r_tag, r, 86400)
                else:
                    if browser['ios']:
                        r_tag = 'topic_' + str(topic.num) + '_replies_asc_rendered_ios_' + str(page_current)
                    else:
                        r_tag = 'topic_' + str(topic.num) + '_replies_asc_rendered_desktop_' + str(page_current)
                    r = memcache.get(r_tag)
                    if r is None:
                        replies = memcache.get('topic_' + str(topic.num) + '_replies_asc_compressed_' + str(page_current))
                        if replies is None:
                            q4 = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 ORDER BY created ASC LIMIT " + str(page_start) + "," + str(page_size), topic.num)
                            replies = q4
                            memcache.set('topic_' + str(topic.num) + '_replies_asc_compressed_' + str(page_current), GetPacked(q4), 86400)
                        else:
                            replies = GetUnpacked(replies)
                        template_values['replies'] = replies
                        template_values['replies_count'] = replies.count()
                        r = template.render(path, template_values)
                        memcache.set(r_tag, r, 86400)
            template_values['r'] = r
            if topic and member:
                if member.hasFavorited(topic):
                    template_values['favorited'] = True
                else:
                    template_values['favorited'] = False
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'topic.html')
        else:
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic_not_found.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'topic_not_found.html')
        output = template.render(path, template_values)
        self.response.out.write(output)
        
    def post(self, topic_num):
        site = GetSite()
        ### BEGIN: CAN CONTINUE
        can_continue = True
        if ('Host' in self.request.headers):
            if (self.request.headers['Host'] not in ['www.v2ex.com', 'v2ex.appspot.com', 'fast.v2ex.com', 'beta.v2ex.com', 'us.v2ex.com', 'eu.v2ex.com', 'jp.v2ex.com', 'localhost:10000']):
                can_continue = False
        else:
            can_continue = False
        if ('User-Agent' not in self.request.headers):
            can_continue = False
        if ('Cookie' not in self.request.headers):
            can_continue = False
        if ('Referer' in self.request.headers):
            has_v2ex = False
            if ('http://localhost:10000' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://www.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://v2ex.appspot.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('https://www.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://eu.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://us.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://jp.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('https://v2ex.appspot.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://fast.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://beta.v2ex.com' in self.request.headers['Referer']):
                has_v2ex = True
            if ('http://' + site.domain in self.request.headers['Referer']):
                has_v2ex = True
            if has_v2ex is False:
                can_continue = False
        else:
            can_continue = False
        if ('Content-Type' in self.request.headers):
            if self.request.headers['Content-Type'].startswith( 'application/x-www-form-urlencoded') is False:
                can_continue = False
        else:
            can_continue = False
        if can_continue is False:
            return self.redirect('http://' + site.domain + '/')
        ### END: CAN CONTINUE
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        template_values['member'] = member
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        topic_num_str = str(topic_num)
        if len(topic_num_str) > 8:
            if browser['ios']:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic_not_found.html')
            else:
                path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'topic_not_found.html')
            output = template.render(path, template_values)
            self.response.out.write(output)
            return
        if (member):
            topic = False
            topic = GetKindByNum('Topic', int(topic_num))
            template_values['topic'] = topic
            errors = 0
            # Verification: content
            reply_content_error = 0
            reply_content_error_messages = ['',
                u'请输入回复内容',
                u'回复内容长度不能超过 200000 个字符'
            ]
            reply_content = self.request.get('content').strip()
            if (len(reply_content) == 0):
                errors = errors + 1
                reply_content_error = 1
            else:
                if (len(reply_content) > 200000):
                    errors = errors + 1
                    reply_content_error = 2
            template_values['reply_content'] = reply_content
            template_values['reply_content_error'] = reply_content_error
            template_values['reply_content_error_message'] = reply_content_error_messages[reply_content_error]
            template_values['errors'] = errors
            if (topic and (errors == 0)):
                reply = Reply(parent=topic)
                q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'reply.max')
                if (q.count() == 1):
                    counter = q[0]
                    counter.value = counter.value + 1
                else:
                    counter = Counter()
                    counter.name = 'reply.max'
                    counter.value = 1
                q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'reply.total')
                if (q2.count() == 1):
                    counter2 = q2[0]
                    counter2.value = counter2.value + 1
                else:
                    counter2 = Counter()
                    counter2.name = 'reply.total'
                    counter2.value = 1
                node = False
                section = False
                if topic:
                    node = False
                    section = False
                    node = GetKindByNum('Node', topic.node_num)
                    if (node):
                        section = GetKindByNum('Section', node.section_num)
                    template_values['node'] = node
                    template_values['section'] = section
                reply.num = counter.value
                reply.content = reply_content
                reply.topic = topic
                reply.topic_num = topic.num
                reply.member = member
                reply.member_num = member.num
                reply.created_by = member.username
                topic.replies = topic.replies + 1
                topic.node_name = node.name
                topic.node_title = node.title
                topic.last_reply_by = member.username
                topic.last_touched = datetime.datetime.now()
                ua = self.request.headers['User-Agent']
                if (re.findall('Mozilla\/5.0 \(iPhone', ua)):
                    reply.source = 'iPhone'
                if (re.findall('Mozilla\/5.0 \(iPod', ua)):
                    reply.source = 'iPod'
                if (re.findall('Mozilla\/5.0 \(iPad', ua)):
                    reply.source = 'iPad'
                if (re.findall('Android', ua)):
                    reply.source = 'Android'
                if (re.findall('Mozilla\/5.0 \(PLAYSTATION 3;', ua)):
                    reply.source = 'PS3'
                reply.put()
                topic.put()
                counter.put()
                counter2.put()
                
                # Notifications
                
                notified_members = []
                keys = []
                
                # type: reply
                
                if reply.member_num != topic.member_num:
                    q = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.max')
                    if (q.count() == 1):
                        counter = q[0]
                        counter.value = counter.value + 1
                    else:
                        counter = Counter()
                        counter.name = 'notification.max'
                        counter.value = 1
                    q2 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'notification.total')
                    if (q2.count() == 1):
                        counter2 = q2[0]
                        counter2.value = counter2.value + 1
                    else:
                        counter2 = Counter()
                        counter2.name = 'notification.total'
                        counter2.value = 1
                    
                    notification = Notification(parent=topic.member)
                    notification.num = counter.value
                    notification.type = 'reply'
                    notification.payload = reply.content
                    notification.label1 = topic.title
                    notification.link1 = '/t/' + str(topic.num) + '#reply' + str(topic.replies)
                    notification.member = member
                    notification.for_member_num = topic.member_num
                    
                    keys.append(str(topic.member.key()))
                    
                    counter.put()
                    counter2.put()
                    notification.put()
                    
                    for key in keys:
                        taskqueue.add(url='/notifications/check/' + key)
                
                taskqueue.add(url='/notifications/reply/' + str(reply.key()))
                
                page_size = TOPIC_PAGE_SIZE
                pages = 1
                if topic.replies > page_size:
                    if (topic.replies % page_size) > 0:
                        pages = int(math.floor(topic.replies / page_size)) + 1
                    else:
                        pages = int(math.floor(topic.replies / page_size))
                
                memcache.set('Topic_' + str(topic.num), topic, 86400)
                memcache.delete('topic_' + str(topic.num) + '_replies_desc_compressed_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_asc_compressed_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_filtered_compressed_' + str(pages))
                
                memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_desktop_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_desktop_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_desktop_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_ios_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_ios_' + str(pages))
                memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_ios_' + str(pages))
                
                memcache.delete('member::' + str(member.num) + '::participated')
                memcache.delete('q_latest_16')
                memcache.delete('home_rendered')
                memcache.delete('home_rendered_mobile')
                if topic.replies < 50:
                    if config.fts_enabled:
                        try:
                            taskqueue.add(url='/index/topic/' + str(topic.num))
                        except:
                            pass
                # Twitter Sync
                if member.twitter_oauth == 1 and member.twitter_sync == 1:
                    access_token = OAuthToken.from_string(member.twitter_oauth_string)
                    twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                    if topic.replies > page_size:
                        link = 'http://' + self.request.headers['Host'] + '/t/' + str(topic.num) + '?p=' + str(pages) + '#r' + str(topic.replies)
                    else:
                        link = 'http://' + self.request.headers['Host'] + '/t/' + str(topic.num) + '#r' + str(topic.replies)
                    link_length = len(link)
                    reply_content_length = len(reply.content)
                    available = 140 - link_length - 1
                    if available > reply_content_length:
                        status = reply.content + ' ' + link
                    else:
                        status = reply.content[0:(available - 4)] + '... ' + link
                    self.response.out.write('Status: ' + status)
                    logging.error('Status: ' + status)
                    try:
                        twitter.PostUpdate(status.encode('utf-8'))
                    except:
                        logging.error("Failed to sync to Twitter for Reply #" + str(reply.num))
                if pages > 1:
                    self.redirect('/t/' + str(topic.num) + '?p=' + str(pages) + '#reply' + str(topic.replies))
                else:
                    self.redirect('/t/' + str(topic.num) + '#reply' + str(topic.replies))
            else:
                node = False
                section = False
                node = GetKindByNum('Node', topic.node_num)
                if (node):
                    section = GetKindByNum('Section', node.section_num)
                template_values['node'] = node
                template_values['section'] = section
                if browser['ios']:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'topic.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
        else:
            self.redirect('/signin')


class TopicEditHandler(webapp.RequestHandler):
    def get(self, topic_num):
        site = GetSite()
        browser = detect(self.request)
        template_values = {}
        template_values['site'] = site
        template_values['system_version'] = SYSTEM_VERSION
        errors = 0
        template_values['errors'] = errors
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        topic = False
        topic = GetKindByNum('Topic', int(topic_num))
        if topic:
            template_values['topic'] = topic
        can_edit = False
        ttl = 0
        if member:
            if member.level == 0:
                can_edit = True
            if topic.member_num == member.num:
                now = datetime.datetime.now()
                if (now - topic.created).seconds < 300:
                    can_edit = True
                    ttl = 300 - (now - topic.created).seconds
                    template_values['ttl'] = ttl
        if (member):
            if (can_edit):
                template_values['member'] = member
                if (topic):
                    template_values['page_title'] = site.title + u' › ' + topic.title + u' › 编辑'
                    template_values['topic_title'] = topic.title
                    template_values['topic_content'] = topic.content
                    node = False
                    section = False
                    node = GetKindByNum('Node', topic.node_num)
                    if (node):
                        section = GetKindByNum('Section', node.section_num)
                    template_values['node'] = node
                    template_values['section'] = section
                    if site.use_topic_types:
                        types = site.topic_types.split("\n")
                        options = '<option value="0">&nbsp;&nbsp;&nbsp;&nbsp;</option>'
                        i = 0
                        for a_type in types:
                            i = i + 1
                            detail = a_type.split(':')
                            if detail[0] == topic.type:
                                options = options + '<option value="' + str(i) + '" selected="selected">' + detail[0] + '</option>'
                            else:
                                options = options + '<option value="' + str(i) + '">' + detail[0] + '</option>'
                        tt = '<div class="sep5"></div><table cellpadding="5" cellspacing="0" border="0" width="100%"><tr><td width="60" align="right">Topic Type</td><td width="auto" align="left"><select name="type">' + options + '</select></td></tr></table>'
                        template_values['tt'] = tt
                    else:
                        template_values['tt'] = ''
                    q4 = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 ORDER BY created ASC", topic.num)
                    template_values['replies'] = q4
                    if browser['ios']:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'edit_topic.html')
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'edit_topic.html')
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic_not_found.html')
                output = template.render(path, template_values)
                self.response.out.write(output)
            else:
                self.redirect('/t/' + str(topic_num))
        else:
            self.redirect('/signin')
    
    def post(self, topic_num):
        site = GetSite()
        template_values = {}
        template_values['site'] = site
        browser = detect(self.request)
        template_values['system_version'] = SYSTEM_VERSION
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        topic = False
        topic = GetKindByNum('Topic', int(topic_num))
        if (topic):
            template_values['topic'] = topic
        can_edit = False
        ttl = 0
        if member:
            if member.level == 0:
                can_edit = True
            if topic.member_num == member.num:
                now = datetime.datetime.now()
                if (now - topic.created).seconds < 300:
                    can_edit = True
                    ttl = 300 - (now - topic.created).seconds
                    template_values['ttl'] = ttl
        if member:
            if can_edit:
                template_values['member'] = member
                if (topic):
                    template_values['page_title'] = site.title + u' › ' + topic.title + u' › 编辑'
                    q2 = db.GqlQuery("SELECT * FROM Node WHERE num = :1", topic.node_num)
                    node = False
                    if (q2.count() == 1):
                        node = q2[0]
                    template_values['node'] = node
                    section = False
                    if node:
                        q3 = db.GqlQuery("SELECT * FROM Section WHERE num = :1", node.section_num)
                        if (q3.count() == 1):
                            section = q3[0]
                    template_values['section'] = section
                    errors = 0
                    # Verification: title
                    topic_title_error = 0
                    topic_title_error_messages = ['',
                        u'请输入主题标题',
                        u'主题标题长度不能超过 120 个字符'
                        ]
                    topic_title = self.request.get('title').strip()
                    if (len(topic_title) == 0):
                        errors = errors + 1
                        topic_title_error = 1
                    else:
                        if (len(topic_title) > 120):
                            errors = errors + 1
                            topic_title_error = 2
                    template_values['topic_title'] = topic_title
                    template_values['topic_title_error'] = topic_title_error
                    template_values['topic_title_error_message'] = topic_title_error_messages[topic_title_error]
                    # Verification: content
                    topic_content_error = 0
                    topic_content_error_messages = ['',
                        u'主题内容长度不能超过 200000 个字符'
                    ]
                    topic_content = self.request.get('content').strip()
                    topic_content_length = len(topic_content)
                    if (topic_content_length > 200000):
                        errors = errors + 1
                        topic_content_error = 1
                    template_values['topic_content'] = topic_content
                    template_values['topic_content_error'] = topic_content_error
                    template_values['topic_content_error_message'] = topic_content_error_messages[topic_content_error]
                    # Verification: type
                    if site.use_topic_types:
                        types = site.topic_types.split("\n")
                        if len(types) > 0:
                            topic_type = self.request.get('type').strip()
                            try:
                                topic_type = int(topic_type)
                                if topic_type < 0:
                                    topic_type = 0
                                if topic_type > len(types):
                                    topic_type = 0
                                if topic_type > 0:
                                    detail = types[topic_type - 1].split(':')
                                    topic_type_label = detail[0]
                                    topic_type_color = detail[1]
                            except:
                                topic_type = 0
                        else:
                            topic_type = 0
                        options = '<option value="0">&nbsp;&nbsp;&nbsp;&nbsp;</option>'
                        i = 0
                        for a_type in types:
                            i = i + 1
                            detail = a_type.split(':')
                            if topic_type == i:
                                options = options + '<option value="' + str(i) + '" selected="selected">' + detail[0] + '</option>'
                            else:
                                options = options + '<option value="' + str(i) + '">' + detail[0] + '</option>'
                        tt = '<div class="sep5"></div><table cellpadding="5" cellspacing="0" border="0" width="100%"><tr><td width="60" align="right">Topic Type</td><td width="auto" align="left"><select name="type">' + options + '</select></td></tr></table>'
                        template_values['tt'] = tt
                    else:
                        template_values['tt'] = ''
                    template_values['errors'] = errors
                    if (errors == 0):
                        topic.title = topic_title
                        topic.content = topic_content
                        if topic_content_length > 0:
                            topic.has_content = True
                            topic.content_length = topic_content_length
                        else:
                            topic.has_content = False
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'portion', 'topic_content.html')
                        output = template.render(path, {'topic' : topic})
                        topic.content_rendered = output.decode('utf-8')
                        if member.level != 0:
                            topic.last_touched = datetime.datetime.now()
                        if site.use_topic_types:
                            if topic_type > 0:
                                topic.type = topic_type_label
                                topic.type_color = topic_type_color
                            else:
                                topic.type = ''
                                topic.type_color = ''        
                        topic.put()
                        memcache.delete('Topic_' + str(topic.num))
                        memcache.delete('q_latest_16')
                        memcache.delete('home_rendered')
                        memcache.delete('home_rendered_mobile')
                        if topic.replies < 50:
                            try:
                                taskqueue.add(url='/index/topic/' + str(topic.num))
                            except:
                                pass
                        self.redirect('/t/' + str(topic.num) + '#reply' + str(topic.replies))
                    else:
                        if browser['ios']:
                            path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'edit_topic.html')
                        else:
                            path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'edit_topic.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'mobile', 'topic_not_found.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
            else:
                self.redirect('/t/' + str(topic_num))
        else:
            self.redirect('/signin')

class TopicDeleteHandler(webapp.RequestHandler):
    def get(self, topic_num):
        site = GetSite()
        member = CheckAuth(self)
        t = self.request.get('t')
        if member:
            if member.level == 0 and (str(member.created_ts) == str(t)):
                q = db.GqlQuery("SELECT * FROM Topic WHERE num = :1", int(topic_num))
                if q.count() == 1:
                    topic = q[0]
                    # Bookmarks
                    q5 = db.GqlQuery("SELECT * FROM TopicBookmark WHERE topic = :1", topic)
                    for bookmark in q5:
                        bookmark.delete()
                    # Take care of Node                
                    node = topic.node
                    node.topics = node.topics - 1
                    node.put()
                    # Take care of Replies
                    q2 = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1", int(topic_num))
                    replies_count = q2.count()
                    if replies_count > 0:
                        for reply in q2:
                            reply.delete()
                        q3 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'reply.total')
                        if q3.count() == 1:
                            counter = q3[0]
                            counter.value = counter.value - replies_count
                            counter.put()
                    memcache.delete('Topic_' + str(topic.num))
                    topic.delete()
                    q4 = db.GqlQuery('SELECT * FROM Counter WHERE name = :1', 'topic.total')
                    if q4.count() == 1:
                        counter2 = q4[0]
                        counter2.value = counter2.value - 1
                        counter2.put()
                    memcache.delete('q_latest_16')
                    memcache.delete('home_rendered')
                    memcache.delete('home_rendered_mobile')
        self.redirect('/')
                    

class TopicPlainTextHandler(webapp.RequestHandler):
    def get(self, topic_num):
        site = GetSite()
        topic = GetKindByNum('topic', topic_num)
        if topic:
            template_values = {}
            template_values['topic'] = topic
            replies = memcache.get('topic_' + str(topic_num) + '_replies_asc')
            if replies is None:
                q = db.GqlQuery("SELECT * FROM Reply WHERE topic_num = :1 ORDER BY created ASC", topic.num)
                replies = q
                memcache.set('topic_' + str(topic_num) + '_replies_asc', q, 86400)
            if replies:
                template_values['replies'] = replies
            path = os.path.join(os.path.dirname(__file__), 'tpl', 'api', 'topic.txt')
            output = template.render(path, template_values)
            self.response.headers['Content-type'] = 'text/plain;charset=UTF-8'
            self.response.out.write(output)
        else:
            self.error(404)


class TopicIndexHandler(webapp.RequestHandler):
    def post(self, topic_num):
        site = GetSite()
        if config.fts_enabled:
            if os.environ['SERVER_SOFTWARE'] == 'Development/1.0':
                try:
                    urlfetch.fetch('http://127.0.0.1:20000/index/' + str(topic_num), headers = {"Authorization" : "Basic %s" % base64.b64encode(config.fts_username + ':' + config.fts_password)})
                except:
                    pass
            else:
                urlfetch.fetch('http://' + config.fts_server + '/index/' + str(topic_num), headers = {"Authorization" : "Basic %s" % base64.b64encode(config.fts_username + ':' + config.fts_password)})

class ReplyEditHandler(webapp.RequestHandler):
    def get(self, reply_num):
        template_values = {}
        site = GetSite()
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › 编辑回复'
                template_values['member'] = member
                q = db.GqlQuery("SELECT * FROM Reply WHERE num = :1", int(reply_num))
                if q[0]:
                    reply = q[0]
                    topic = reply.topic
                    node = topic.node
                    template_values['reply'] = reply
                    template_values['topic'] = topic
                    template_values['node'] = node
                    template_values['reply_content'] = reply.content
                    path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'edit_reply.html')
                    output = template.render(path, template_values)
                    self.response.out.write(output)
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')
    
    def post(self, reply_num):
        template_values = {}
        site = GetSite()
        template_values['site'] = site
        member = CheckAuth(self)
        l10n = GetMessages(self, member, site)
        template_values['l10n'] = l10n
        if member:
            if member.level == 0:
                template_values['page_title'] = site.title + u' › 编辑回复'
                template_values['member'] = member
                q = db.GqlQuery("SELECT * FROM Reply WHERE num = :1", int(reply_num))
                if q[0]:
                    reply = q[0]
                    topic = reply.topic
                    node = topic.node
                    template_values['reply'] = reply
                    template_values['topic'] = topic
                    template_values['node'] = node
                    # Verification: content
                    errors = 0
                    reply_content_error = 0
                    reply_content_error_messages = ['',
                        u'请输入回复内容',
                        u'回复内容长度不能超过 2000 个字符'
                    ]
                    reply_content = self.request.get('content').strip()
                    if (len(reply_content) == 0):
                        errors = errors + 1
                        reply_content_error = 1
                    else:
                        if (len(reply_content) > 2000):
                            errors = errors + 1
                            reply_content_error = 2
                    template_values['reply_content'] = reply_content
                    template_values['reply_content_error'] = reply_content_error
                    template_values['reply_content_error_message'] = reply_content_error_messages[reply_content_error]
                    template_values['errors'] = errors
                    if (errors == 0):
                        reply.content = reply_content
                        reply.put()
                        memcache.delete('topic_' + str(topic.num) + '_replies_desc_compressed')
                        memcache.delete('topic_' + str(topic.num) + '_replies_asc_compressed')
                        memcache.delete('topic_' + str(topic.num) + '_replies_filtered_compressed')
                        
                        pages = 1
                        memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_desktop_' + str(pages))
                        memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_desktop_' + str(pages))
                        memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_desktop_' + str(pages))
                        memcache.delete('topic_' + str(topic.num) + '_replies_desc_rendered_ios_' + str(pages))
                        memcache.delete('topic_' + str(topic.num) + '_replies_asc_rendered_ios_' + str(pages))
                        memcache.delete('topic_' + str(topic.num) + '_replies_filtered_rendered_ios_' + str(pages))
                        
                        self.redirect('/t/' + str(topic.num) + '#reply' + str(topic.replies))
                    else:
                        path = os.path.join(os.path.dirname(__file__), 'tpl', 'desktop', 'edit_reply.html')
                        output = template.render(path, template_values)
                        self.response.out.write(output)
                else:
                    self.redirect('/')
            else:
                self.redirect('/')
        else:
            self.redirect('/signin')       

class TopicHitHandler(webapp.RequestHandler):
    def post(self, topic_key):
        topic = db.get(db.Key(topic_key))
        if topic:
            topic.hits = topic.hits + 1
            topic.put()

class PageHitHandler(webapp.RequestHandler):
    def post(self, page_key):
        page = db.get(db.Key(page_key))
        if page:
            page.hits = page.hits + 1
            page.put()

def main():
    application = webapp.WSGIApplication([
    ('/new/(.*)', NewTopicHandler),
    ('/t/([0-9]+)', TopicHandler),
    ('/t/([0-9]+).txt', TopicPlainTextHandler),
    ('/edit/topic/([0-9]+)', TopicEditHandler),
    ('/delete/topic/([0-9]+)', TopicDeleteHandler),
    ('/index/topic/([0-9]+)', TopicIndexHandler),
    ('/edit/reply/([0-9]+)', ReplyEditHandler),
    ('/hit/topic/(.*)', TopicHitHandler),
    ('/hit/page/(.*)', PageHitHandler)
    ],
                                         debug=True)
    util.run_wsgi_app(application)


if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = bitly
#!/usr/bin/python2.4
#
# Copyright 2009 Empeeric LTD. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from django.utils import simplejson
import urllib,urllib2
import urlparse
import string

BITLY_BASE_URL = "http://api.bit.ly/"
BITLY_API_VERSION = "2.0.1"

VERBS_PARAM = { 
         'shorten':'longUrl',               
         'expand':'shortUrl', 
         'info':'shortUrl',
         'stats':'shortUrl',
         'errors':'',
}

class BitlyError(Exception):
  '''Base class for bitly errors'''
  
  @property
  def message(self):
    '''Returns the first argument used to construct this error.'''
    return self.args[0]

class Api(object):
    """ API class for bit.ly """
    def __init__(self, login, apikey):
        self.login = login
        self.apikey = apikey
        self._urllib = urllib2
        
    def shorten(self,longURL):
        """ 
            Takes either:
            A long URL string and returns shortened URL string
            Or a list of long URL strings and returns a list of shortened URL strings.
        """
        if not isinstance(longURL, list):
            longURL = [longURL]
        
        for index,url in enumerate(longURL):
            if not '://' in url:
                longURL[index] = "http://" + url
            
        request = self._getURL("shorten",longURL)
        result = self._fetchUrl(request)
        json = simplejson.loads(result)
        self._CheckForError(json)
        
        res = []
        for item in json['results'].values():
            if item['shortKeywordUrl'] == "":
                res.append(item['shortUrl'])
            else:
                res.append(item['shortKeywordUrl'])
        
        if len(res) == 1:
            return res[0]
        else:
            return res

    def expand(self,shortURL):
        """ Given a bit.ly url or hash, return long source url """
        request = self._getURL("expand",shortURL)
        result = self._fetchUrl(request)
        json = simplejson.loads(result)
        self._CheckForError(json)
        return json['results'][string.split(shortURL, '/')[-1]]['longUrl']

    def info(self,shortURL):
        """ 
        Given a bit.ly url or hash, 
        return information about that page, 
        such as the long source url
        """
        request = self._getURL("info",shortURL)
        result = self._fetchUrl(request)
        json = simplejson.loads(result)
        self._CheckForError(json)
        return json['results'][string.split(shortURL, '/')[-1]]

    def stats(self,shortURL):
        """ Given a bit.ly url or hash, return traffic and referrer data.  """
        request = self._getURL("stats",shortURL)
        result = self._fetchUrl(request)
        json = simplejson.loads(result)
        self._CheckForError(json)
        return Stats.NewFromJsonDict(json['results'])

    def errors(self):
        """ Get a list of bit.ly API error codes. """
        request = self._getURL("errors","")
        result = self._fetchUrl(request)
        json = simplejson.loads(result)
        self._CheckForError(json)
        return json['results']
        
    def setUrllib(self, urllib):
        '''Override the default urllib implementation.
    
        Args:
          urllib: an instance that supports the same API as the urllib2 module
        '''
        self._urllib = urllib
    
    def _getURL(self,verb,paramVal): 
        if not isinstance(paramVal, list):
            paramVal = [paramVal]
              
        params = [
                  ('version',BITLY_API_VERSION),
                  ('format','json'),
                  ('login',self.login),
                  ('apiKey',self.apikey),
            ]
        
        verbParam = VERBS_PARAM[verb]   
        if verbParam:
            for val in paramVal:
                params.append(( verbParam,val ))
   
        encoded_params = urllib.urlencode(params)
        return "%s%s?%s" % (BITLY_BASE_URL,verb,encoded_params)
       
    def _fetchUrl(self,url):
        '''Fetch a URL
    
        Args:
          url: The URL to retrieve
    
        Returns:
          A string containing the body of the response.
        '''
    
        # Open and return the URL 
        url_data = self._urllib.urlopen(url).read()
        return url_data    

    def _CheckForError(self, data):
        """Raises a BitlyError if bitly returns an error message.
    
        Args:
          data: A python dict created from the bitly json response
        Raises:
          BitlyError wrapping the bitly error message if one exists.
        """
        # bitly errors are relatively unlikely, so it is faster
        # to check first, rather than try and catch the exception
        if 'ERROR' in data or data['statusCode'] == 'ERROR':
            raise BitlyError, data['errorMessage']
        for key in data['results']:
            if type(data['results']) is dict and type(data['results'][key]) is dict:
                if 'statusCode' in data['results'][key] and data['results'][key]['statusCode'] == 'ERROR':
                    raise BitlyError, data['results'][key]['errorMessage'] 
       
class Stats(object):
    '''A class representing the Statistics returned by the bitly api.
    
    The Stats structure exposes the following properties:
    status.user_clicks # read only
    status.clicks # read only
    '''
    
    def __init__(self,user_clicks=None,total_clicks=None):
        self.user_clicks = user_clicks
        self.total_clicks = total_clicks
    
    @staticmethod
    def NewFromJsonDict(data):
        '''Create a new instance based on a JSON dict.
    
        Args:
          data: A JSON dict, as converted from the JSON in the bitly API
        Returns:
          A bitly.Stats instance
        '''
        return Stats(user_clicks=data.get('userClicks', None),
                      total_clicks=data.get('clicks', None))

        
if __name__ == '__main__':
    testURL1="www.yahoo.com"
    testURL2="www.cnn.com"
    a=Api(login="pythonbitly",apikey="R_06871db6b7fd31a4242709acaf1b6648")
    short=a.shorten(testURL1)    
    print "Short URL = %s" % short
    urlList=[testURL1,testURL2]
    shortList=a.shorten(urlList)
    print "Short URL list = %s" % shortList
    long=a.expand(short)
    print "Expanded URL = %s" % long
    info=a.info(short)
    print "Info: %s" % info
    stats=a.stats(short)
    print "User clicks %s, total clicks: %s" % (stats.user_clicks,stats.total_clicks)
    errors=a.errors()
    print "Errors: %s" % errors
########NEW FILE########
__FILENAME__ = oauth
# coding=utf-8
"""
The MIT License

Copyright (c) 2007 Leah Culver

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import cgi
import urllib
import time
import random
import urlparse
import hmac
import binascii


VERSION = '1.0' # Hi Blaine!
HTTP_METHOD = 'GET'
SIGNATURE_METHOD = 'PLAINTEXT'


class OAuthError(RuntimeError):
    """Generic exception class."""
    def __init__(self, message='OAuth error occured.'):
        self.message = message

def build_authenticate_header(realm=''):
    """Optional WWW-Authenticate header (401 error)"""
    return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

def escape(s):
    """Escape a URL including any /."""
    return urllib.quote(s, safe='~')

def _utf8_str(s):
    """Convert unicode to utf-8."""
    if isinstance(s, unicode):
        return s.encode("utf-8")
    else:
        return str(s)

def generate_timestamp():
    """Get seconds since epoch (UTC)."""
    return int(time.time())

def generate_nonce(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])

def generate_verifier(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])


class OAuthConsumer(object):
    """Consumer of OAuth authentication.

    OAuthConsumer is a data type that represents the identity of the Consumer
    via its shared secret with the Service Provider.

    """
    key = None
    secret = None

    def __init__(self, key, secret):
        self.key = key
        self.secret = secret


class OAuthToken(object):
    """OAuthToken is a data type that represents an End User via either an access
    or request token.
    
    key -- the token
    secret -- the token secret

    """
    key = None
    secret = None
    callback = None
    callback_confirmed = None
    verifier = None

    def __init__(self, key, secret):
        self.key = key
        self.secret = secret

    def set_callback(self, callback):
        self.callback = callback
        self.callback_confirmed = 'true'

    def set_verifier(self, verifier=None):
        if verifier is not None:
            self.verifier = verifier
        else:
            self.verifier = generate_verifier()

    def get_callback_url(self):
        if self.callback and self.verifier:
            # Append the oauth_verifier.
            parts = urlparse.urlparse(self.callback)
            scheme, netloc, path, params, query, fragment = parts[:6]
            if query:
                query = '%s&oauth_verifier=%s' % (query, self.verifier)
            else:
                query = 'oauth_verifier=%s' % self.verifier
            return urlparse.urlunparse((scheme, netloc, path, params,
                query, fragment))
        return self.callback

    def to_string(self):
        data = {
            'oauth_token': self.key,
            'oauth_token_secret': self.secret,
        }
        if self.callback_confirmed is not None:
            data['oauth_callback_confirmed'] = self.callback_confirmed
        return urllib.urlencode(data)
 
    def from_string(s):
        """ Returns a token from something like:
        oauth_token_secret=xxx&oauth_token=xxx
        """
        params = cgi.parse_qs(s, keep_blank_values=False)
        key = params['oauth_token'][0]
        secret = params['oauth_token_secret'][0]
        token = OAuthToken(key, secret)
        try:
            token.callback_confirmed = params['oauth_callback_confirmed'][0]
        except KeyError:
            pass # 1.0, no callback confirmed.
        return token
    from_string = staticmethod(from_string)

    def __str__(self):
        return self.to_string()


class OAuthRequest(object):
    """OAuthRequest represents the request and can be serialized.

    OAuth parameters:
        - oauth_consumer_key 
        - oauth_token
        - oauth_signature_method
        - oauth_signature 
        - oauth_timestamp 
        - oauth_nonce
        - oauth_version
        - oauth_verifier
        ... any additional parameters, as defined by the Service Provider.
    """
    parameters = None # OAuth parameters.
    http_method = HTTP_METHOD
    http_url = None
    version = VERSION

    def __init__(self, http_method=HTTP_METHOD, http_url=None, parameters=None):
        self.http_method = http_method
        self.http_url = http_url
        self.parameters = parameters or {}

    def set_parameter(self, parameter, value):
        self.parameters[parameter] = value

    def get_parameter(self, parameter):
        try:
            return self.parameters[parameter]
        except:
            raise OAuthError('Parameter not found: %s' % parameter)

    def _get_timestamp_nonce(self):
        return self.get_parameter('oauth_timestamp'), self.get_parameter(
            'oauth_nonce')

    def get_nonoauth_parameters(self):
        """Get any non-OAuth parameters."""
        parameters = {}
        for k, v in self.parameters.iteritems():
            # Ignore oauth parameters.
            if k.find('oauth_') < 0:
                parameters[k] = v
        return parameters

    def to_header(self, realm=''):
        """Serialize as a header for an HTTPAuth request."""
        auth_header = 'OAuth realm="%s"' % realm
        # Add the oauth parameters.
        if self.parameters:
            for k, v in self.parameters.iteritems():
                if k[:6] == 'oauth_':
                    auth_header += ', %s="%s"' % (k, escape(str(v)))
        return {'Authorization': auth_header}

    def to_postdata(self):
        """Serialize as post data for a POST request."""
        return '&'.join(['%s=%s' % (escape(str(k)), escape(str(v))) \
            for k, v in self.parameters.iteritems()])

    def to_url(self):
        """Serialize as a URL for a GET request."""
        return '%s?%s' % (self.get_normalized_http_url(), self.to_postdata())

    def get_normalized_parameters(self):
        """Return a string that contains the parameters that must be signed."""
        params = self.parameters
        try:
            # Exclude the signature if it exists.
            del params['oauth_signature']
        except:
            pass
        # Escape key values before sorting.
        key_values = [(escape(_utf8_str(k)), escape(_utf8_str(v))) \
            for k,v in params.items()]
        # Sort lexicographically, first after key, then after value.
        key_values.sort()
        # Combine key value pairs into a string.
        return '&'.join(['%s=%s' % (k, v) for k, v in key_values])

    def get_normalized_http_method(self):
        """Uppercases the http method."""
        return self.http_method.upper()

    def get_normalized_http_url(self):
        """Parses the URL and rebuilds it to be scheme://host/path."""
        parts = urlparse.urlparse(self.http_url)
        scheme, netloc, path = parts[:3]
        # Exclude default port numbers.
        if scheme == 'http' and netloc[-3:] == ':80':
            netloc = netloc[:-3]
        elif scheme == 'https' and netloc[-4:] == ':443':
            netloc = netloc[:-4]
        return '%s://%s%s' % (scheme, netloc, path)

    def sign_request(self, signature_method, consumer, token):
        """Set the signature parameter to the result of build_signature."""
        # Set the signature method.
        self.set_parameter('oauth_signature_method',
            signature_method.get_name())
        # Set the signature.
        self.set_parameter('oauth_signature',
            self.build_signature(signature_method, consumer, token))

    def build_signature(self, signature_method, consumer, token):
        """Calls the build signature method within the signature method."""
        return signature_method.build_signature(self, consumer, token)

    def from_request(http_method, http_url, headers=None, parameters=None,
            query_string=None):
        """Combines multiple parameter sources."""
        if parameters is None:
            parameters = {}

        # Headers
        if headers and 'Authorization' in headers:
            auth_header = headers['Authorization']
            # Check that the authorization header is OAuth.
            if auth_header[:6] == 'OAuth ':
                auth_header = auth_header[6:]
                try:
                    # Get the parameters from the header.
                    header_params = OAuthRequest._split_header(auth_header)
                    parameters.update(header_params)
                except:
                    raise OAuthError('Unable to parse OAuth parameters from '
                        'Authorization header.')

        # GET or POST query string.
        if query_string:
            query_params = OAuthRequest._split_url_string(query_string)
            parameters.update(query_params)

        # URL parameters.
        param_str = urlparse.urlparse(http_url)[4] # query
        url_params = OAuthRequest._split_url_string(param_str)
        parameters.update(url_params)

        if parameters:
            return OAuthRequest(http_method, http_url, parameters)

        return None
    from_request = staticmethod(from_request)

    def from_consumer_and_token(oauth_consumer, token=None,
            callback=None, verifier=None, http_method=HTTP_METHOD,
            http_url=None, parameters=None):
        if not parameters:
            parameters = {}

        defaults = {
            'oauth_consumer_key': oauth_consumer.key,
            'oauth_timestamp': generate_timestamp(),
            'oauth_nonce': generate_nonce(),
            'oauth_version': OAuthRequest.version,
        }

        defaults.update(parameters)
        parameters = defaults

        if token:
            parameters['oauth_token'] = token.key
            if token.callback:
                parameters['oauth_callback'] = token.callback
            # 1.0a support for verifier.
            if verifier:
                parameters['oauth_verifier'] = verifier
        elif callback:
            # 1.0a support for callback in the request token request.
            parameters['oauth_callback'] = callback

        return OAuthRequest(http_method, http_url, parameters)
    from_consumer_and_token = staticmethod(from_consumer_and_token)

    def from_token_and_callback(token, callback=None, http_method=HTTP_METHOD,
            http_url=None, parameters=None):
        if not parameters:
            parameters = {}

        parameters['oauth_token'] = token.key

        if callback:
            parameters['oauth_callback'] = callback

        return OAuthRequest(http_method, http_url, parameters)
    from_token_and_callback = staticmethod(from_token_and_callback)

    def _split_header(header):
        """Turn Authorization: header into parameters."""
        params = {}
        parts = header.split(',')
        for param in parts:
            # Ignore realm parameter.
            if param.find('realm') > -1:
                continue
            # Remove whitespace.
            param = param.strip()
            # Split key-value.
            param_parts = param.split('=', 1)
            # Remove quotes and unescape the value.
            params[param_parts[0]] = urllib.unquote(param_parts[1].strip('\"'))
        return params
    _split_header = staticmethod(_split_header)

    def _split_url_string(param_str):
        """Turn URL string into parameters."""
        parameters = cgi.parse_qs(param_str, keep_blank_values=False)
        for k, v in parameters.iteritems():
            parameters[k] = urllib.unquote(v[0])
        return parameters
    _split_url_string = staticmethod(_split_url_string)

class OAuthServer(object):
    """A worker to check the validity of a request against a data store."""
    timestamp_threshold = 300 # In seconds, five minutes.
    version = VERSION
    signature_methods = None
    data_store = None

    def __init__(self, data_store=None, signature_methods=None):
        self.data_store = data_store
        self.signature_methods = signature_methods or {}

    def set_data_store(self, data_store):
        self.data_store = data_store

    def get_data_store(self):
        return self.data_store

    def add_signature_method(self, signature_method):
        self.signature_methods[signature_method.get_name()] = signature_method
        return self.signature_methods

    def fetch_request_token(self, oauth_request):
        """Processes a request_token request and returns the
        request token on success.
        """
        try:
            # Get the request token for authorization.
            token = self._get_token(oauth_request, 'request')
        except OAuthError:
            # No token required for the initial token request.
            version = self._get_version(oauth_request)
            consumer = self._get_consumer(oauth_request)
            try:
                callback = self.get_callback(oauth_request)
            except OAuthError:
                callback = None # 1.0, no callback specified.
            self._check_signature(oauth_request, consumer, None)
            # Fetch a new token.
            token = self.data_store.fetch_request_token(consumer, callback)
        return token

    def fetch_access_token(self, oauth_request):
        """Processes an access_token request and returns the
        access token on success.
        """
        version = self._get_version(oauth_request)
        consumer = self._get_consumer(oauth_request)
        try:
            verifier = self._get_verifier(oauth_request)
        except OAuthError:
            verifier = None
        # Get the request token.
        token = self._get_token(oauth_request, 'request')
        self._check_signature(oauth_request, consumer, token)
        new_token = self.data_store.fetch_access_token(consumer, token, verifier)
        return new_token

    def verify_request(self, oauth_request):
        """Verifies an api call and checks all the parameters."""
        # -> consumer and token
        version = self._get_version(oauth_request)
        consumer = self._get_consumer(oauth_request)
        # Get the access token.
        token = self._get_token(oauth_request, 'access')
        self._check_signature(oauth_request, consumer, token)
        parameters = oauth_request.get_nonoauth_parameters()
        return consumer, token, parameters

    def authorize_token(self, token, user):
        """Authorize a request token."""
        return self.data_store.authorize_request_token(token, user)

    def get_callback(self, oauth_request):
        """Get the callback URL."""
        return oauth_request.get_parameter('oauth_callback')
 
    def build_authenticate_header(self, realm=''):
        """Optional support for the authenticate header."""
        return {'WWW-Authenticate': 'OAuth realm="%s"' % realm}

    def _get_version(self, oauth_request):
        """Verify the correct version request for this server."""
        try:
            version = oauth_request.get_parameter('oauth_version')
        except:
            version = VERSION
        if version and version != self.version:
            raise OAuthError('OAuth version %s not supported.' % str(version))
        return version

    def _get_signature_method(self, oauth_request):
        """Figure out the signature with some defaults."""
        try:
            signature_method = oauth_request.get_parameter(
                'oauth_signature_method')
        except:
            signature_method = SIGNATURE_METHOD
        try:
            # Get the signature method object.
            signature_method = self.signature_methods[signature_method]
        except:
            signature_method_names = ', '.join(self.signature_methods.keys())
            raise OAuthError('Signature method %s not supported try one of the '
                'following: %s' % (signature_method, signature_method_names))

        return signature_method

    def _get_consumer(self, oauth_request):
        consumer_key = oauth_request.get_parameter('oauth_consumer_key')
        consumer = self.data_store.lookup_consumer(consumer_key)
        if not consumer:
            raise OAuthError('Invalid consumer.')
        return consumer

    def _get_token(self, oauth_request, token_type='access'):
        """Try to find the token for the provided request token key."""
        token_field = oauth_request.get_parameter('oauth_token')
        token = self.data_store.lookup_token(token_type, token_field)
        if not token:
            raise OAuthError('Invalid %s token: %s' % (token_type, token_field))
        return token
    
    def _get_verifier(self, oauth_request):
        return oauth_request.get_parameter('oauth_verifier')

    def _check_signature(self, oauth_request, consumer, token):
        timestamp, nonce = oauth_request._get_timestamp_nonce()
        self._check_timestamp(timestamp)
        self._check_nonce(consumer, token, nonce)
        signature_method = self._get_signature_method(oauth_request)
        try:
            signature = oauth_request.get_parameter('oauth_signature')
        except:
            raise OAuthError('Missing signature.')
        # Validate the signature.
        valid_sig = signature_method.check_signature(oauth_request, consumer,
            token, signature)
        if not valid_sig:
            key, base = signature_method.build_signature_base_string(
                oauth_request, consumer, token)
            raise OAuthError('Invalid signature. Expected signature base '
                'string: %s' % base)
        built = signature_method.build_signature(oauth_request, consumer, token)

    def _check_timestamp(self, timestamp):
        """Verify that timestamp is recentish."""
        timestamp = int(timestamp)
        now = int(time.time())
        lapsed = abs(now - timestamp)
        if lapsed > self.timestamp_threshold:
            raise OAuthError('Expired timestamp: given %d and now %s has a '
                'greater difference than threshold %d' %
                (timestamp, now, self.timestamp_threshold))

    def _check_nonce(self, consumer, token, nonce):
        """Verify that the nonce is uniqueish."""
        nonce = self.data_store.lookup_nonce(consumer, token, nonce)
        if nonce:
            raise OAuthError('Nonce already used: %s' % str(nonce))


class OAuthClient(object):
    """OAuthClient is a worker to attempt to execute a request."""
    consumer = None
    token = None

    def __init__(self, oauth_consumer, oauth_token):
        self.consumer = oauth_consumer
        self.token = oauth_token

    def get_consumer(self):
        return self.consumer

    def get_token(self):
        return self.token

    def fetch_request_token(self, oauth_request):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_access_token(self, oauth_request):
        """-> OAuthToken."""
        raise NotImplementedError

    def access_resource(self, oauth_request):
        """-> Some protected resource."""
        raise NotImplementedError


class OAuthDataStore(object):
    """A database abstraction used to lookup consumers and tokens."""

    def lookup_consumer(self, key):
        """-> OAuthConsumer."""
        raise NotImplementedError

    def lookup_token(self, oauth_consumer, token_type, token_token):
        """-> OAuthToken."""
        raise NotImplementedError

    def lookup_nonce(self, oauth_consumer, oauth_token, nonce):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_request_token(self, oauth_consumer, oauth_callback):
        """-> OAuthToken."""
        raise NotImplementedError

    def fetch_access_token(self, oauth_consumer, oauth_token, oauth_verifier):
        """-> OAuthToken."""
        raise NotImplementedError

    def authorize_request_token(self, oauth_token, user):
        """-> OAuthToken."""
        raise NotImplementedError


class OAuthSignatureMethod(object):
    """A strategy class that implements a signature method."""
    def get_name(self):
        """-> str."""
        raise NotImplementedError

    def build_signature_base_string(self, oauth_request, oauth_consumer, oauth_token):
        """-> str key, str raw."""
        raise NotImplementedError

    def build_signature(self, oauth_request, oauth_consumer, oauth_token):
        """-> str."""
        raise NotImplementedError

    def check_signature(self, oauth_request, consumer, token, signature):
        built = self.build_signature(oauth_request, consumer, token)
        return built == signature


class OAuthSignatureMethod_HMAC_SHA1(OAuthSignatureMethod):

    def get_name(self):
        return 'HMAC-SHA1'
        
    def build_signature_base_string(self, oauth_request, consumer, token):
        sig = (
            escape(oauth_request.get_normalized_http_method()),
            escape(oauth_request.get_normalized_http_url()),
            escape(oauth_request.get_normalized_parameters()),
        )

        key = '%s&' % escape(consumer.secret)
        if token:
            key += escape(token.secret)
        raw = '&'.join(sig)
        return key, raw

    def build_signature(self, oauth_request, consumer, token):
        """Builds the base signature string."""
        key, raw = self.build_signature_base_string(oauth_request, consumer,
            token)

        # HMAC object.
        try:
            import hashlib # 2.5
            hashed = hmac.new(key, raw, hashlib.sha1)
        except:
            import sha # Deprecated
            hashed = hmac.new(key, raw, sha)

        # Calculate the digest base 64.
        return binascii.b2a_base64(hashed.digest())[:-1]


class OAuthSignatureMethod_PLAINTEXT(OAuthSignatureMethod):

    def get_name(self):
        return 'PLAINTEXT'

    def build_signature_base_string(self, oauth_request, consumer, token):
        """Concatenates the consumer key and secret."""
        sig = '%s&' % escape(consumer.secret)
        if token:
            sig = sig + escape(token.secret)
        return sig, sig

    def build_signature(self, oauth_request, consumer, token):
        key, raw = self.build_signature_base_string(oauth_request, consumer,
            token)
        return key
########NEW FILE########
__FILENAME__ = oauthtwitter
#!/usr/bin/env python
# 
# Copyright under  the latest Apache License 2.0

'''A class the inherits everything from python-twitter and allows oauth based access

Requires:
  python-twitter
  simplejson
  oauth
'''

__author__ = "Hameedullah Khan <hameed@hameedkhan.net>"
__version__ = "0.2"

from twitter import Api, User

from django.utils import simplejson
import oauth

# Taken from oauth implementation at: http://github.com/harperreed/twitteroauth-python/tree/master
REQUEST_TOKEN_URL = 'https://twitter.com/oauth/request_token'
ACCESS_TOKEN_URL = 'https://twitter.com/oauth/access_token'
AUTHORIZATION_URL = 'http://twitter.com/oauth/authorize'
SIGNIN_URL = 'http://twitter.com/oauth/authenticate'

class OAuthApi(Api):
    def __init__(self, consumer_key, consumer_secret, access_token=None):
        if access_token:
            Api.__init__(self,access_token.key, access_token.secret)
        else:
            Api.__init__(self)
        self._Consumer = oauth.OAuthConsumer(consumer_key, consumer_secret)
        self._signature_method = oauth.OAuthSignatureMethod_HMAC_SHA1()
        self._access_token = access_token


    def _GetOpener(self):
        opener = self._urllib.build_opener()
        return opener

    def _FetchUrl(self,
                    url,
                    post_data=None,
                    parameters=None,
                    no_cache=None):
        '''Fetch a URL, optionally caching for a specified time.
    
        Args:
          url: The URL to retrieve
          post_data: 
            A dict of (str, unicode) key/value pairs.  If set, POST will be used.
          parameters:
            A dict whose key/value pairs should encoded and added 
            to the query string. [OPTIONAL]
          no_cache: If true, overrides the cache on the current request
    
        Returns:
          A string containing the body of the response.
        '''
        # Build the extra parameters dict
        extra_params = {}
        if self._default_params:
          extra_params.update(self._default_params)
        if parameters:
          extra_params.update(parameters)
    
        # Add key/value parameters to the query string of the url
        #url = self._BuildUrl(url, extra_params=extra_params)
    
        if post_data:
            http_method = "POST"
            extra_params.update(post_data)
        else:
            http_method = "GET"
        
        req = self._makeOAuthRequest(url, parameters=extra_params, 
                                                    http_method=http_method)
        self._signRequest(req, self._signature_method)

        
        # Get a url opener that can handle Oauth basic auth
        opener = self._GetOpener()
        
        #encoded_post_data = self._EncodePostData(post_data)

        if post_data:
            encoded_post_data = req.to_postdata()
            url = req.get_normalized_http_url()
        else:
            url = req.to_url()
            encoded_post_data = ""
            
        no_cache=True
        # Open and return the URL immediately if we're not going to cache
        # OR we are posting data
        if encoded_post_data or no_cache:
          if encoded_post_data:
              url_data = opener.open(url, encoded_post_data).read()
          else:
              url_data = opener.open(url).read()
          opener.close()
        else:
          # Unique keys are a combination of the url and the username
          if self._username:
            key = self._username + ':' + url
          else:
            key = url
    
          # See if it has been cached before
          last_cached = self._cache.GetCachedTime(key)
    
          # If the cached version is outdated then fetch another and store it
          if not last_cached or time.time() >= last_cached + self._cache_timeout:
            url_data = opener.open(url).read()
            opener.close()
            self._cache.Set(key, url_data)
          else:
            url_data = self._cache.Get(key)
    
        # Always return the latest version
        return url_data
    
    def _makeOAuthRequest(self, url, token=None,
                                        parameters=None, http_method="GET"):
        '''Make a OAuth request from url and parameters
        
        Args:
          url: The Url to use for creating OAuth Request
          parameters:
             The URL parameters
          http_method:
             The HTTP method to use
        Returns:
          A OAauthRequest object
        '''
        if not token:
            token = self._access_token
        request = oauth.OAuthRequest.from_consumer_and_token(
                            self._Consumer, token=token, 
                            http_url=url, parameters=parameters, 
                            http_method=http_method)
        return request

    def _signRequest(self, req, signature_method=oauth.OAuthSignatureMethod_HMAC_SHA1()):
        '''Sign a request
        
        Reminder: Created this function so incase
        if I need to add anything to request before signing
        
        Args:
          req: The OAuth request created via _makeOAuthRequest
          signate_method:
             The oauth signature method to use
        '''
        req.sign_request(signature_method, self._Consumer, self._access_token)
    

    def getAuthorizationURL(self, token, url=AUTHORIZATION_URL):
        '''Create a signed authorization URL
        
        Returns:
          A signed OAuthRequest authorization URL 
        '''
        req = self._makeOAuthRequest(url, token=token)
        self._signRequest(req)
        return req.to_url()

    def getSigninURL(self, token, url=SIGNIN_URL):
        '''Create a signed Sign-in URL
        
        Returns:
          A signed OAuthRequest Sign-in URL 
        '''
        
        signin_url = self.getAuthorizationURL(token, url)
        return signin_url
    
    def getAccessToken(self, url=ACCESS_TOKEN_URL):
        token = self._FetchUrl(url, no_cache=True)
        return oauth.OAuthToken.from_string(token) 

    def getRequestToken(self, url=REQUEST_TOKEN_URL):
        '''Get a Request Token from Twitter
        
        Returns:
          A OAuthToken object containing a request token
        '''
        resp = self._FetchUrl(url, no_cache=True)
        token = oauth.OAuthToken.from_string(resp)
        return token
    
    def GetUserInfo(self, url='https://twitter.com/account/verify_credentials.json'):
        '''Get user information from twitter
        
        Returns:
          Returns the twitter.User object
        '''
        json = self._FetchUrl(url)
        data = simplejson.loads(json)
        self._CheckForTwitterError(data)
        return User.NewFromJsonDict(data)
        

########NEW FILE########
__FILENAME__ = twitter
#!/usr/bin/python2.5
# coding=utf-8
#
# Copyright 2007 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''A library that provides a python interface to the Twitter API'''

__author__ = 'dewitt@google.com'
__version__ = '0.6-devel'

from v2ex import TWITTER_API_ROOT

from django.utils import simplejson

import base64
import calendar
import os
import rfc822
import sys
import tempfile
import textwrap
import time
import urllib
import urllib2
import urlparse
import re
import bitly
import hashlib
import logging

try:
  from google.appengine.api import memcache
except ImportError:
  memcache = None

try:
  from hashlib import md5
except ImportError:
  from md5 import md5


CHARACTER_LIMIT = 140


class TwitterError(Exception):
  '''Base class for Twitter errors'''
  
  @property
  def message(self):
    '''Returns the first argument used to construct this error.'''
    return self.args[0]


class Status(object):
  '''A class representing the Status structure used by the twitter API.

  The Status structure exposes the following properties:

    status.created_at
    status.created_at_in_seconds # read only
    status.favorited
    status.in_reply_to_screen_name
    status.in_reply_to_user_id
    status.in_reply_to_status_id
    status.truncated
    status.source
    status.id
    status.text
    status.relative_created_at # read only
    status.user
  '''
  def __init__(self,
               created_at=None,
               favorited=None,
               id=None,
               text=None,
               user=None,
               in_reply_to_screen_name=None,
               in_reply_to_user_id=None,
               in_reply_to_status_id=None,
               truncated=None,
               source=None,
               now=None):
    '''An object to hold a Twitter status message.

    This class is normally instantiated by the twitter.Api class and
    returned in a sequence.

    Note: Dates are posted in the form "Sat Jan 27 04:17:38 +0000 2007"

    Args:
      created_at: The time this status message was posted
      favorited: Whether this is a favorite of the authenticated user
      id: The unique id of this status message
      text: The text of this status message
      relative_created_at:
        A human readable string representing the posting time
      user:
        A twitter.User instance representing the person posting the message
      now:
        The current time, if the client choses to set it.  Defaults to the
        wall clock time.
    '''
    self.created_at = created_at
    self.favorited = favorited
    self.id = id
    self.text = text
    self.user = user
    self.now = now
    self.in_reply_to_screen_name = in_reply_to_screen_name
    self.in_reply_to_user_id = in_reply_to_user_id
    self.in_reply_to_status_id = in_reply_to_status_id
    self.truncated = truncated
    self.source = source

  def GetCreatedAt(self):
    '''Get the time this status message was posted.

    Returns:
      The time this status message was posted
    '''
    return self._created_at

  def SetCreatedAt(self, created_at):
    '''Set the time this status message was posted.

    Args:
      created_at: The time this status message was created
    '''
    self._created_at = created_at

  created_at = property(GetCreatedAt, SetCreatedAt,
                        doc='The time this status message was posted.')

  def GetCreatedAtInSeconds(self):
    '''Get the time this status message was posted, in seconds since the epoch.

    Returns:
      The time this status message was posted, in seconds since the epoch.
    '''
    return calendar.timegm(rfc822.parsedate(self.created_at))

  created_at_in_seconds = property(GetCreatedAtInSeconds,
                                   doc="The time this status message was "
                                       "posted, in seconds since the epoch")

  def GetFavorited(self):
    '''Get the favorited setting of this status message.

    Returns:
      True if this status message is favorited; False otherwise
    '''
    return self._favorited

  def SetFavorited(self, favorited):
    '''Set the favorited state of this status message.

    Args:
      favorited: boolean True/False favorited state of this status message
    '''
    self._favorited = favorited

  favorited = property(GetFavorited, SetFavorited,
                       doc='The favorited state of this status message.')

  def GetId(self):
    '''Get the unique id of this status message.

    Returns:
      The unique id of this status message
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this status message.

    Args:
      id: The unique id of this status message
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this status message.')

  def GetInReplyToScreenName(self):
    return self._in_reply_to_screen_name

  def SetInReplyToScreenName(self, in_reply_to_screen_name):
    self._in_reply_to_screen_name = in_reply_to_screen_name

  in_reply_to_screen_name = property(GetInReplyToScreenName, SetInReplyToScreenName,
                doc='')

  def GetInReplyToUserId(self):
    return self._in_reply_to_user_id

  def SetInReplyToUserId(self, in_reply_to_user_id):
    self._in_reply_to_user_id = in_reply_to_user_id

  in_reply_to_user_id = property(GetInReplyToUserId, SetInReplyToUserId,
                doc='')

  def GetInReplyToStatusId(self):
    return self._in_reply_to_status_id

  def SetInReplyToStatusId(self, in_reply_to_status_id):
    self._in_reply_to_status_id = in_reply_to_status_id

  in_reply_to_status_id = property(GetInReplyToStatusId, SetInReplyToStatusId,
                doc='')

  def GetTruncated(self):
    return self._truncated

  def SetTruncated(self, truncated):
    self._truncated = truncated

  truncated = property(GetTruncated, SetTruncated,
                doc='')

  def GetSource(self):
    return self._source

  def SetSource(self, source):
    self._source = source

  source = property(GetSource, SetSource,
                doc='')

  def GetText(self):
    '''Get the text of this status message.

    Returns:
      The text of this status message.
    '''
    return self._text

  def SetText(self, text):
    '''Set the text of this status message.

    Args:
      text: The text of this status message
    '''
    self._text = text

  text = property(GetText, SetText,
                  doc='The text of this status message')

  def GetRelativeCreatedAt(self):
    '''Get a human redable string representing the posting time

    Returns:
      A human readable string representing the posting time
    '''
    fudge = 1.25
    delta  = long(self.now) - long(self.created_at_in_seconds)

    if delta < (1 * fudge):
      return 'about a second ago'
    elif delta < (60 * (1/fudge)):
      return 'about %d seconds ago' % (delta)
    elif delta < (60 * fudge):
      return 'about a minute ago'
    elif delta < (60 * 60 * (1/fudge)):
      return 'about %d minutes ago' % (delta / 60)
    elif delta < (60 * 60 * fudge):
      return 'about an hour ago'
    elif delta < (60 * 60 * 24 * (1/fudge)):
      return 'about %d hours ago' % (delta / (60 * 60))
    elif delta < (60 * 60 * 24 * fudge):
      return 'about a day ago'
    else:
      return 'about %d days ago' % (delta / (60 * 60 * 24))

  relative_created_at = property(GetRelativeCreatedAt,
                                 doc='Get a human readable string representing'
                                     'the posting time')

  def GetUser(self):
    '''Get a twitter.User reprenting the entity posting this status message.

    Returns:
      A twitter.User reprenting the entity posting this status message
    '''
    return self._user

  def SetUser(self, user):
    '''Set a twitter.User reprenting the entity posting this status message.

    Args:
      user: A twitter.User reprenting the entity posting this status message
    '''
    self._user = user

  user = property(GetUser, SetUser,
                  doc='A twitter.User reprenting the entity posting this '
                      'status message')

  def GetNow(self):
    '''Get the wallclock time for this status message.

    Used to calculate relative_created_at.  Defaults to the time
    the object was instantiated.

    Returns:
      Whatever the status instance believes the current time to be,
      in seconds since the epoch.
    '''
    if self._now is None:
      self._now = time.time()
    return self._now

  def SetNow(self, now):
    '''Set the wallclock time for this status message.

    Used to calculate relative_created_at.  Defaults to the time
    the object was instantiated.

    Args:
      now: The wallclock time for this instance.
    '''
    self._now = now

  now = property(GetNow, SetNow,
                 doc='The wallclock time for this status instance.')


  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
             self.created_at == other.created_at and \
             self.id == other.id and \
             self.text == other.text and \
             self.user == other.user and \
             self.in_reply_to_screen_name == other.in_reply_to_screen_name and \
             self.in_reply_to_user_id == other.in_reply_to_user_id and \
             self.in_reply_to_status_id == other.in_reply_to_status_id and \
             self.truncated == other.truncated and \
             self.favorited == other.favorited and \
             self.source == other.source
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.Status instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.Status instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.Status instance.

    Returns:
      A JSON string representation of this twitter.Status instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.Status instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.Status instance
    '''
    data = {}
    if self.created_at:
      data['created_at'] = self.created_at
    if self.favorited:
      data['favorited'] = self.favorited
    if self.id:
      data['id'] = self.id
    if self.text:
      data['text'] = self.text
    if self.user:
      data['user'] = self.user.AsDict()
    if self.in_reply_to_screen_name:
      data['in_reply_to_screen_name'] = self.in_reply_to_screen_name
    if self.in_reply_to_user_id:
      data['in_reply_to_user_id'] = self.in_reply_to_user_id
    if self.in_reply_to_status_id:
      data['in_reply_to_status_id'] = self.in_reply_to_status_id
    if self.truncated is not None:
      data['truncated'] = self.truncated
    if self.favorited is not None:
      data['favorited'] = self.favorited
    if self.source:
      data['source'] = self.source
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.Status instance
    '''
    if 'user' in data:
      user = User.NewFromJsonDict(data['user'])
    else:
      user = None
    return Status(created_at=data.get('created_at', None),
                  favorited=data.get('favorited', None),
                  id=data.get('id', None),
                  text=data.get('text', None),
                  in_reply_to_screen_name=data.get('in_reply_to_screen_name', None),
                  in_reply_to_user_id=data.get('in_reply_to_user_id', None),
                  in_reply_to_status_id=data.get('in_reply_to_status_id', None),
                  truncated=data.get('truncated', None),
                  source=data.get('source', None),
                  user=user)


class User(object):
  '''A class representing the User structure used by the twitter API.

  The User structure exposes the following properties:

    user.id
    user.name
    user.screen_name
    user.location
    user.description
    user.profile_image_url
    user.profile_background_tile
    user.profile_background_image_url
    user.profile_sidebar_fill_color
    user.profile_background_color
    user.profile_link_color
    user.profile_text_color
    user.protected
    user.utc_offset
    user.time_zone
    user.url
    user.status
    user.statuses_count
    user.followers_count
    user.friends_count
    user.favourites_count
  '''
  def __init__(self,
               id=None,
               name=None,
               screen_name=None,
               location=None,
               description=None,
               profile_image_url=None,
               profile_background_tile=None,
               profile_background_image_url=None,
               profile_sidebar_fill_color=None,
               profile_background_color=None,
               profile_link_color=None,
               profile_text_color=None,
               protected=None,
               utc_offset=None,
               time_zone=None,
               followers_count=None,
               friends_count=None,
               statuses_count=None,
               favourites_count=None,
               url=None,
               status=None):
    self.id = id
    self.name = name
    self.screen_name = screen_name
    self.location = location
    self.description = description
    self.profile_image_url = profile_image_url
    self.profile_background_tile = profile_background_tile
    self.profile_background_image_url = profile_background_image_url
    self.profile_sidebar_fill_color = profile_sidebar_fill_color
    self.profile_background_color = profile_background_color
    self.profile_link_color = profile_link_color
    self.profile_text_color = profile_text_color
    self.protected = protected
    self.utc_offset = utc_offset
    self.time_zone = time_zone
    self.followers_count = followers_count
    self.friends_count = friends_count
    self.statuses_count = statuses_count
    self.favourites_count = favourites_count
    self.url = url
    self.status = status


  def GetId(self):
    '''Get the unique id of this user.

    Returns:
      The unique id of this user
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this user.

    Args:
      id: The unique id of this user.
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this user.')

  def GetName(self):
    '''Get the real name of this user.

    Returns:
      The real name of this user
    '''
    return self._name

  def SetName(self, name):
    '''Set the real name of this user.

    Args:
      name: The real name of this user
    '''
    self._name = name

  name = property(GetName, SetName,
                  doc='The real name of this user.')

  def GetScreenName(self):
    '''Get the short username of this user.

    Returns:
      The short username of this user
    '''
    return self._screen_name

  def SetScreenName(self, screen_name):
    '''Set the short username of this user.

    Args:
      screen_name: the short username of this user
    '''
    self._screen_name = screen_name

  screen_name = property(GetScreenName, SetScreenName,
                         doc='The short username of this user.')

  def GetLocation(self):
    '''Get the geographic location of this user.

    Returns:
      The geographic location of this user
    '''
    return self._location

  def SetLocation(self, location):
    '''Set the geographic location of this user.

    Args:
      location: The geographic location of this user
    '''
    self._location = location

  location = property(GetLocation, SetLocation,
                      doc='The geographic location of this user.')

  def GetDescription(self):
    '''Get the short text description of this user.

    Returns:
      The short text description of this user
    '''
    return self._description

  def SetDescription(self, description):
    '''Set the short text description of this user.

    Args:
      description: The short text description of this user
    '''
    self._description = description

  description = property(GetDescription, SetDescription,
                         doc='The short text description of this user.')

  def GetUrl(self):
    '''Get the homepage url of this user.

    Returns:
      The homepage url of this user
    '''
    return self._url

  def SetUrl(self, url):
    '''Set the homepage url of this user.

    Args:
      url: The homepage url of this user
    '''
    self._url = url

  url = property(GetUrl, SetUrl,
                 doc='The homepage url of this user.')

  def GetProfileImageUrl(self):
    '''Get the url of the thumbnail of this user.

    Returns:
      The url of the thumbnail of this user
    '''
    return self._profile_image_url

  def SetProfileImageUrl(self, profile_image_url):
    '''Set the url of the thumbnail of this user.

    Args:
      profile_image_url: The url of the thumbnail of this user
    '''
    self._profile_image_url = profile_image_url

  profile_image_url= property(GetProfileImageUrl, SetProfileImageUrl,
                              doc='The url of the thumbnail of this user.')

  def GetProfileBackgroundTile(self):
    '''Boolean for whether to tile the profile background image.

    Returns:
      True if the background is to be tiled, False if not, None if unset.
    '''
    return self._profile_background_tile

  def SetProfileBackgroundTile(self, profile_background_tile):
    '''Set the boolean flag for whether to tile the profile background image.

    Args:
      profile_background_tile: Boolean flag for whether to tile or not.
    '''
    self._profile_background_tile = profile_background_tile

  profile_background_tile = property(GetProfileBackgroundTile, SetProfileBackgroundTile,
                                     doc='Boolean for whether to tile the background image.')

  def GetProfileBackgroundImageUrl(self):
    return self._profile_background_image_url

  def SetProfileBackgroundImageUrl(self, profile_background_image_url):
    self._profile_background_image_url = profile_background_image_url

  profile_background_image_url = property(GetProfileBackgroundImageUrl, SetProfileBackgroundImageUrl,
                                          doc='The url of the profile background of this user.')

  def GetProfileSidebarFillColor(self):
    return self._profile_sidebar_fill_color

  def SetProfileSidebarFillColor(self, profile_sidebar_fill_color):
    self._profile_sidebar_fill_color = profile_sidebar_fill_color

  profile_sidebar_fill_color = property(GetProfileSidebarFillColor, SetProfileSidebarFillColor)

  def GetProfileBackgroundColor(self):
    return self._profile_background_color

  def SetProfileBackgroundColor(self, profile_background_color):
    self._profile_background_color = profile_background_color

  profile_background_color = property(GetProfileBackgroundColor, SetProfileBackgroundColor)

  def GetProfileLinkColor(self):
    return self._profile_link_color

  def SetProfileLinkColor(self, profile_link_color):
    self._profile_link_color = profile_link_color

  profile_link_color = property(GetProfileLinkColor, SetProfileLinkColor)

  def GetProfileTextColor(self):
    return self._profile_text_color

  def SetProfileTextColor(self, profile_text_color):
    self._profile_text_color = profile_text_color

  profile_text_color = property(GetProfileTextColor, SetProfileTextColor)

  def GetProtected(self):
    return self._protected

  def SetProtected(self, protected):
    self._protected = protected

  protected = property(GetProtected, SetProtected)

  def GetUtcOffset(self):
    return self._utc_offset

  def SetUtcOffset(self, utc_offset):
    self._utc_offset = utc_offset

  utc_offset = property(GetUtcOffset, SetUtcOffset)

  def GetTimeZone(self):
    '''Returns the current time zone string for the user.

    Returns:
      The descriptive time zone string for the user.
    '''
    return self._time_zone

  def SetTimeZone(self, time_zone):
    '''Sets the user's time zone string.

    Args:
      time_zone: The descriptive time zone to assign for the user.
    '''
    self._time_zone = time_zone

  time_zone = property(GetTimeZone, SetTimeZone)

  def GetStatus(self):
    '''Get the latest twitter.Status of this user.

    Returns:
      The latest twitter.Status of this user
    '''
    return self._status

  def SetStatus(self, status):
    '''Set the latest twitter.Status of this user.

    Args:
      status: The latest twitter.Status of this user
    '''
    self._status = status

  status = property(GetStatus, SetStatus,
                  doc='The latest twitter.Status of this user.')

  def GetFriendsCount(self):
    '''Get the friend count for this user.
    
    Returns:
      The number of users this user has befriended.
    '''
    return self._friends_count

  def SetFriendsCount(self, count):
    '''Set the friend count for this user.

    Args:
      count: The number of users this user has befriended.
    '''
    self._friends_count = count

  friends_count = property(GetFriendsCount, SetFriendsCount,
                  doc='The number of friends for this user.')

  def GetFollowersCount(self):
    '''Get the follower count for this user.
    
    Returns:
      The number of users following this user.
    '''
    return self._followers_count

  def SetFollowersCount(self, count):
    '''Set the follower count for this user.

    Args:
      count: The number of users following this user.
    '''
    self._followers_count = count

  followers_count = property(GetFollowersCount, SetFollowersCount,
                  doc='The number of users following this user.')

  def GetStatusesCount(self):
    '''Get the number of status updates for this user.
    
    Returns:
      The number of status updates for this user.
    '''
    return self._statuses_count

  def SetStatusesCount(self, count):
    '''Set the status update count for this user.

    Args:
      count: The number of updates for this user.
    '''
    self._statuses_count = count

  statuses_count = property(GetStatusesCount, SetStatusesCount,
                  doc='The number of updates for this user.')

  def GetFavouritesCount(self):
    '''Get the number of favourites for this user.
    
    Returns:
      The number of favourites for this user.
    '''
    return self._favourites_count

  def SetFavouritesCount(self, count):
    '''Set the favourite count for this user.

    Args:
      count: The number of favourites for this user.
    '''
    self._favourites_count = count

  favourites_count = property(GetFavouritesCount, SetFavouritesCount,
                  doc='The number of favourites for this user.')

  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
             self.id == other.id and \
             self.name == other.name and \
             self.screen_name == other.screen_name and \
             self.location == other.location and \
             self.description == other.description and \
             self.profile_image_url == other.profile_image_url and \
             self.profile_background_tile == other.profile_background_tile and \
             self.profile_background_image_url == other.profile_background_image_url and \
             self.profile_sidebar_fill_color == other.profile_sidebar_fill_color and \
             self.profile_background_color == other.profile_background_color and \
             self.profile_link_color == other.profile_link_color and \
             self.profile_text_color == other.profile_text_color and \
             self.protected == other.protected and \
             self.utc_offset == other.utc_offset and \
             self.time_zone == other.time_zone and \
             self.url == other.url and \
             self.statuses_count == other.statuses_count and \
             self.followers_count == other.followers_count and \
             self.favourites_count == other.favourites_count and \
             self.friends_count == other.friends_count and \
             self.status == other.status
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.User instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.User instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.User instance.

    Returns:
      A JSON string representation of this twitter.User instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.User instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.User instance
    '''
    data = {}
    if self.id:
      data['id'] = self.id
    if self.name:
      data['name'] = self.name
    if self.screen_name:
      data['screen_name'] = self.screen_name
    if self.location:
      data['location'] = self.location
    if self.description:
      data['description'] = self.description
    if self.profile_image_url:
      data['profile_image_url'] = self.profile_image_url
    if self.profile_background_tile is not None:
      data['profile_background_tile'] = self.profile_background_tile
    if self.profile_background_image_url:
      data['profile_sidebar_fill_color'] = self.profile_background_image_url
    if self.profile_background_color:
      data['profile_background_color'] = self.profile_background_color
    if self.profile_link_color:
      data['profile_link_color'] = self.profile_link_color
    if self.profile_text_color:
      data['profile_text_color'] = self.profile_text_color
    if self.protected is not None:
      data['protected'] = self.protected
    if self.utc_offset:
      data['utc_offset'] = self.utc_offset
    if self.time_zone:
      data['time_zone'] = self.time_zone
    if self.url:
      data['url'] = self.url
    if self.status:
      data['status'] = self.status.AsDict()
    if self.friends_count:
      data['friends_count'] = self.friends_count
    if self.followers_count:
      data['followers_count'] = self.followers_count
    if self.statuses_count:
      data['statuses_count'] = self.statuses_count
    if self.favourites_count:
      data['favourites_count'] = self.favourites_count
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.User instance
    '''
    if 'status' in data:
      status = Status.NewFromJsonDict(data['status'])
    else:
      status = None
    return User(id=data.get('id', None),
                name=data.get('name', None),
                screen_name=data.get('screen_name', None),
                location=data.get('location', None),
                description=data.get('description', None),
                statuses_count=data.get('statuses_count', None),
                followers_count=data.get('followers_count', None),
                favourites_count=data.get('favourites_count', None),
                friends_count=data.get('friends_count', None),
                profile_image_url=data.get('profile_image_url', None),
                profile_background_tile = data.get('profile_background_tile', None),
                profile_background_image_url = data.get('profile_background_image_url', None),
                profile_sidebar_fill_color = data.get('profile_sidebar_fill_color', None),
                profile_background_color = data.get('profile_background_color', None),
                profile_link_color = data.get('profile_link_color', None),
                profile_text_color = data.get('profile_text_color', None),
                protected = data.get('protected', None),
                utc_offset = data.get('utc_offset', None),
                time_zone = data.get('time_zone', None),
                url=data.get('url', None),
                status=status)

class DirectMessage(object):
  '''A class representing the DirectMessage structure used by the twitter API.

  The DirectMessage structure exposes the following properties:

    direct_message.id
    direct_message.created_at
    direct_message.created_at_in_seconds # read only
    direct_message.sender
    direct_message.sender_id
    direct_message.sender_screen_name
    direct_message.recipient_id
    direct_message.recipient_screen_name
    direct_message.text
  '''

  def __init__(self,
               id=None,
               created_at=None,
               sender=None,
               sender_id=None,
               sender_screen_name=None,
               recipient_id=None,
               recipient_screen_name=None,
               text=None):
    '''An object to hold a Twitter direct message.

    This class is normally instantiated by the twitter.Api class and
    returned in a sequence.

    Note: Dates are posted in the form "Sat Jan 27 04:17:38 +0000 2007"

    Args:
      id: The unique id of this direct message
      created_at: The time this direct message was posted
      sender_id: The id of the twitter user that sent this message
      sender_screen_name: The name of the twitter user that sent this message
      recipient_id: The id of the twitter that received this message
      recipient_screen_name: The name of the twitter that received this message
      text: The text of this direct message
    '''
    self.id = id
    self.created_at = created_at
    self.sender = sender
    self.sender_id = sender_id
    self.sender_screen_name = sender_screen_name
    self.recipient_id = recipient_id
    self.recipient_screen_name = recipient_screen_name
    self.text = text

  def GetId(self):
    '''Get the unique id of this direct message.

    Returns:
      The unique id of this direct message
    '''
    return self._id

  def SetId(self, id):
    '''Set the unique id of this direct message.

    Args:
      id: The unique id of this direct message
    '''
    self._id = id

  id = property(GetId, SetId,
                doc='The unique id of this direct message.')

  def GetCreatedAt(self):
    '''Get the time this direct message was posted.

    Returns:
      The time this direct message was posted
    '''
    return self._created_at

  def SetCreatedAt(self, created_at):
    '''Set the time this direct message was posted.

    Args:
      created_at: The time this direct message was created
    '''
    self._created_at = created_at

  created_at = property(GetCreatedAt, SetCreatedAt,
                        doc='The time this direct message was posted.')

  def GetCreatedAtInSeconds(self):
    '''Get the time this direct message was posted, in seconds since the epoch.

    Returns:
      The time this direct message was posted, in seconds since the epoch.
    '''
    return calendar.timegm(rfc822.parsedate(self.created_at))

  created_at_in_seconds = property(GetCreatedAtInSeconds,
                                   doc="The time this direct message was "
                                       "posted, in seconds since the epoch")
  
  def GetSender(self):
    return self._sender
    
  def SetSender(self, sender):
    self._sender = sender
    
  sender = property(GetSender, SetSender,
                    doc='A twitter.User')

  def GetSenderId(self):
    '''Get the unique sender id of this direct message.

    Returns:
      The unique sender id of this direct message
    '''
    return self._sender_id

  def SetSenderId(self, sender_id):
    '''Set the unique sender id of this direct message.

    Args:
      sender id: The unique sender id of this direct message
    '''
    self._sender_id = sender_id

  sender_id = property(GetSenderId, SetSenderId,
                doc='The unique sender id of this direct message.')

  def GetSenderScreenName(self):
    '''Get the unique sender screen name of this direct message.

    Returns:
      The unique sender screen name of this direct message
    '''
    return self._sender_screen_name

  def SetSenderScreenName(self, sender_screen_name):
    '''Set the unique sender screen name of this direct message.

    Args:
      sender_screen_name: The unique sender screen name of this direct message
    '''
    self._sender_screen_name = sender_screen_name

  sender_screen_name = property(GetSenderScreenName, SetSenderScreenName,
                doc='The unique sender screen name of this direct message.')

  def GetRecipientId(self):
    '''Get the unique recipient id of this direct message.

    Returns:
      The unique recipient id of this direct message
    '''
    return self._recipient_id

  def SetRecipientId(self, recipient_id):
    '''Set the unique recipient id of this direct message.

    Args:
      recipient id: The unique recipient id of this direct message
    '''
    self._recipient_id = recipient_id

  recipient_id = property(GetRecipientId, SetRecipientId,
                doc='The unique recipient id of this direct message.')

  def GetRecipientScreenName(self):
    '''Get the unique recipient screen name of this direct message.

    Returns:
      The unique recipient screen name of this direct message
    '''
    return self._recipient_screen_name

  def SetRecipientScreenName(self, recipient_screen_name):
    '''Set the unique recipient screen name of this direct message.

    Args:
      recipient_screen_name: The unique recipient screen name of this direct message
    '''
    self._recipient_screen_name = recipient_screen_name

  recipient_screen_name = property(GetRecipientScreenName, SetRecipientScreenName,
                doc='The unique recipient screen name of this direct message.')

  def GetText(self):
    '''Get the text of this direct message.

    Returns:
      The text of this direct message.
    '''
    return self._text

  def SetText(self, text):
    '''Set the text of this direct message.

    Args:
      text: The text of this direct message
    '''
    self._text = text

  text = property(GetText, SetText,
                  doc='The text of this direct message')

  def __ne__(self, other):
    return not self.__eq__(other)

  def __eq__(self, other):
    try:
      return other and \
          self.id == other.id and \
          self.created_at == other.created_at and \
          self.sender == other.sender and \
          self.sender_id == other.sender_id and \
          self.sender_screen_name == other.sender_screen_name and \
          self.recipient_id == other.recipient_id and \
          self.recipient_screen_name == other.recipient_screen_name and \
          self.text == other.text
    except AttributeError:
      return False

  def __str__(self):
    '''A string representation of this twitter.DirectMessage instance.

    The return value is the same as the JSON string representation.

    Returns:
      A string representation of this twitter.DirectMessage instance.
    '''
    return self.AsJsonString()

  def AsJsonString(self):
    '''A JSON string representation of this twitter.DirectMessage instance.

    Returns:
      A JSON string representation of this twitter.DirectMessage instance
   '''
    return simplejson.dumps(self.AsDict(), sort_keys=True)

  def AsDict(self):
    '''A dict representation of this twitter.DirectMessage instance.

    The return value uses the same key names as the JSON representation.

    Return:
      A dict representing this twitter.DirectMessage instance
    '''
    data = {}
    if self.id:
      data['id'] = self.id
    if self.created_at:
      data['created_at'] = self.created_at
    if self.sender:
      data['sender'] = self.sender.AsDict()
    if self.sender_id:
      data['sender_id'] = self.sender_id
    if self.sender_screen_name:
      data['sender_screen_name'] = self.sender_screen_name
    if self.recipient_id:
      data['recipient_id'] = self.recipient_id
    if self.recipient_screen_name:
      data['recipient_screen_name'] = self.recipient_screen_name
    if self.text:
      data['text'] = self.text
    return data

  @staticmethod
  def NewFromJsonDict(data):
    '''Create a new instance based on a JSON dict.

    Args:
      data: A JSON dict, as converted from the JSON in the twitter API
    Returns:
      A twitter.DirectMessage instance
    '''
    if 'sender' in data:
      sender = User.NewFromJsonDict(data['sender'])
    else:
      sender = None
    return DirectMessage(created_at=data.get('created_at', None),
                         recipient_id=data.get('recipient_id', None),
                         sender=sender,
                         sender_id=data.get('sender_id', None),
                         text=data.get('text', None),
                         sender_screen_name=data.get('sender_screen_name', None),
                         id=data.get('id', None),
                         recipient_screen_name=data.get('recipient_screen_name', None))

class Api(object):
  '''A python interface into the Twitter API

  By default, the Api caches results for 1 minute.

  Example usage:

    To create an instance of the twitter.Api class, with no authentication:

      >>> import twitter
      >>> api = twitter.Api()

    To fetch the most recently posted public twitter status messages:

      >>> statuses = api.GetPublicTimeline()
      >>> print [s.user.name for s in statuses]
      [u'DeWitt', u'Kesuke Miyagi', u'ev', u'Buzz Andersen', u'Biz Stone'] #...

    To fetch a single user's public status messages, where "user" is either
    a Twitter "short name" or their user id.

      >>> statuses = api.GetUserTimeline(user)
      >>> print [s.text for s in statuses]

    To use authentication, instantiate the twitter.Api class with a
    username and password:

      >>> api = twitter.Api(username='twitter user', password='twitter pass')

    To fetch your friends (after being authenticated):

      >>> users = api.GetFriends()
      >>> print [u.name for u in users]

    To post a twitter status message (after being authenticated):

      >>> status = api.PostUpdate('I love python-twitter!')
      >>> print status.text
      I love python-twitter!

    There are many other methods, including:

      >>> api.PostUpdates(status)
      >>> api.PostDirectMessage(user, text)
      >>> api.GetUser(user)
      >>> api.GetReplies()
      >>> api.GetUserTimeline(user)
      >>> api.GetStatus(id)
      >>> api.DestroyStatus(id)
      >>> api.GetFriendsTimeline(user)
      >>> api.GetFriends(user)
      >>> api.GetFollowers()
      >>> api.GetFeatured()
      >>> api.GetDirectMessages()
      >>> api.PostDirectMessage(user, text)
      >>> api.DestroyDirectMessage(id)
      >>> api.DestroyFriendship(user)
      >>> api.CreateFriendship(user)
      >>> api.GetUserByEmail(email)
  '''

  DEFAULT_CACHE_TIMEOUT = 10 # default cache for 1 minute

  _API_REALM = 'Twitter API'

  def __init__(self,
               username=None,
               password=None,
               input_encoding=None,
               request_headers=None):
    '''Instantiate a new twitter.Api object.

    Args:
      username: The username of the twitter account.  [optional]
      password: The password for the twitter account. [optional]
      input_encoding: The encoding used to encode input strings. [optional]
      request_header: A dictionary of additional HTTP request headers. [optional]
    '''
    self._cache = _MemCache()
    self._urllib = urllib2
    self._cache_timeout = Api.DEFAULT_CACHE_TIMEOUT
    self._InitializeRequestHeaders(request_headers)
    self._InitializeUserAgent()
    self._InitializeDefaultParameters()
    self._input_encoding = input_encoding
    self.SetCredentials(username, password)

  def GetPublicTimeline(self, since_id=None):
    '''Fetch the sequnce of public twitter.Status message for all users.

    Args:
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      An sequence of twitter.Status instances, one for each message
    '''
    parameters = {}
    if since_id:
      parameters['since_id'] = since_id
    url = TWITTER_API_ROOT + 'statuses/public_timeline.json'
    json = self._FetchUrl(url,  parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetFriendsTimeline(self,
                         user=None,
                         count=None,
                         since=None, 
                         since_id=None):
    '''Fetch the sequence of twitter.Status messages for a user's friends

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        Specifies the ID or screen name of the user for whom to return
        the friends_timeline.  If unspecified, the username and password
        must be set in the twitter.Api instance.  [Optional]
      count: 
        Specifies the number of statuses to retrieve. May not be
        greater than 200. [Optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [Optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each message
    '''
    if user:
      url = TWITTER_API_ROOT + 'statuses/friends_timeline/%s.json' % user
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = TWITTER_API_ROOT + 'statuses/friends_timeline.json'
    parameters = {}
    if count is not None:
      try:
        if int(count) > 200:
          raise TwitterError("'count' may not be greater than 200")
      except ValueError:
        raise TwitterError("'count' must be an integer")
      parameters['count'] = count
    if since:
      parameters['since'] = since
    if since_id:
      parameters['since_id'] = since_id
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetHomeTimeline(self,
                         user=None,
                         count=None,
                         since=None, 
                         since_id=None):
    '''Fetch the sequence of twitter.Status messages for a user's friends

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        Specifies the ID or screen name of the user for whom to return
        the friends_timeline.  If unspecified, the username and password
        must be set in the twitter.Api instance.  [Optional]
      count: 
        Specifies the number of statuses to retrieve. May not be
        greater than 200. [Optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [Optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each message
    '''
    if user:
      url = TWITTER_API_ROOT + 'statuses/home_timeline/%s.json' % user
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = TWITTER_API_ROOT + 'statuses/friends_timeline.json'
    parameters = {}
    if count is not None:
      try:
        if int(count) > 200:
          raise TwitterError("'count' may not be greater than 200")
      except ValueError:
        raise TwitterError("'count' must be an integer")
      parameters['count'] = count
    if since:
      parameters['since'] = since
    if since_id:
      parameters['since_id'] = since_id
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetRateLimit(self):
    url = TWITTER_API_ROOT + 'account/rate_limit_status.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    return data
    
  def GetListTimeline(self,
                      user=None,
                      list_id=None):
    '''Fetch the sequence of twitter.Status messages for a user's friends

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        Specifies the ID or screen name of the user for whom to return
        the friends_timeline.  If unspecified, the username and password
        must be set in the twitter.Api instance.  [Optional]
      count: 
        Specifies the number of statuses to retrieve. May not be
        greater than 200. [Optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [Optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each message
    '''
    if user:
      url = TWITTER_API_ROOT + '/' + user + '/lists/' + list_id + '/statuses.json'
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = TWITTER_API_ROOT + '1/' + self._username + '/lists/' + list_id + '/statuses.json'
    parameters = {}
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetUserTimeline(self, user=None, count=None, since=None, since_id=None):
    '''Fetch the sequence of public twitter.Status messages for a single user.

    The twitter.Api instance must be authenticated if the user is private.

    Args:
      user:
        either the username (short_name) or id of the user to retrieve.  If
        not specified, then the current authenticated user is used. [optional]
      count: the number of status messages to retrieve [optional]
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each message up to count
    '''
    try:
      if count:
        int(count)
    except:
      raise TwitterError("Count must be an integer")
    parameters = {}
    if count:
      parameters['count'] = count
    if since:
      parameters['since'] = since
    if since_id:
      parameters['since_id'] = since_id
    if user:
      url = TWITTER_API_ROOT + 'statuses/user_timeline/%s.json' % user
    elif not user and not self._username:
      raise TwitterError("User must be specified if API is not authenticated.")
    else:
      url = TWITTER_API_ROOT + 'statuses/user_timeline.json'
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetLists(self):
    url = TWITTER_API_ROOT + '/' + self._username + '/lists.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    lists = []
    i = 0
    for alist in data['lists']:
      lists.append({})
      lists[i]['id'] = alist['id']
      lists[i]['name'] = alist['name']
      lists[i]['slug'] = alist['slug']
      i = i + 1
    return lists

  def GetStatus(self, id):
    '''Returns a single status message.

    The twitter.Api instance must be authenticated if the status message is private.

    Args:
      id: The numerical ID of the status you're trying to retrieve.

    Returns:
      A twitter.Status instance representing that status message
    '''
    try:
      if id:
        long(id)
    except:
      raise TwitterError("id must be an long integer")
    url = TWITTER_API_ROOT + 'statuses/show/%s.json' % id
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return Status.NewFromJsonDict(data)

  def DestroyStatus(self, id):
    '''Destroys the status specified by the required ID parameter.

    The twitter.Api instance must be authenticated and thee
    authenticating user must be the author of the specified status.

    Args:
      id: The numerical ID of the status you're trying to destroy.

    Returns:
      A twitter.Status instance representing the destroyed status message
    '''
    try:
      if id:
        long(id)
    except:
      raise TwitterError("id must be an integer")
    url = TWITTER_API_ROOT + 'statuses/destroy/%s.json' % id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return Status.NewFromJsonDict(data)

  def PostUpdate(self, status, in_reply_to_status_id=None):
    '''Post a twitter status message from the authenticated user.

    The twitter.Api instance must be authenticated.

    Args:
      status:
        The message text to be posted.  Must be less than or equal to
        140 characters.
      in_reply_to_status_id:
        The ID of an existing status that the status to be posted is
        in reply to.  This implicitly sets the in_reply_to_user_id
        attribute of the resulting status to the user ID of the
        message being replied to.  Invalid/missing status IDs will be
        ignored. [Optional]
    Returns:
      A twitter.Status instance representing the message posted.
    '''
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")

    url = TWITTER_API_ROOT + 'statuses/update.json'

    if len(status.decode('utf-8')) > CHARACTER_LIMIT:
      raise TwitterError("Text must be less than or equal to %d characters. "
                         "Consider using PostUpdates." % CHARACTER_LIMIT)

    data = {'status': status}
    if in_reply_to_status_id:
      data['in_reply_to_status_id'] = in_reply_to_status_id
    json = self._FetchUrl(url, post_data=data)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return Status.NewFromJsonDict(data)

  def PostUpdates(self, status, continuation=None, **kwargs):
    '''Post one or more twitter status messages from the authenticated user.

    Unlike api.PostUpdate, this method will post multiple status updates
    if the message is longer than 140 characters.

    The twitter.Api instance must be authenticated.

    Args:
      status:
        The message text to be posted.  May be longer than 140 characters.
      continuation:
        The character string, if any, to be appended to all but the
        last message.  Note that Twitter strips trailing '...' strings
        from messages.  Consider using the unicode \u2026 character
        (horizontal ellipsis) instead. [Defaults to None]
      **kwargs:
        See api.PostUpdate for a list of accepted parameters.
    Returns:
      A of list twitter.Status instance representing the messages posted.
    '''
    results = list()
    if continuation is None:
      continuation = ''
    line_length = CHARACTER_LIMIT - len(continuation)
    lines = textwrap.wrap(status, line_length)
    for line in lines[0:-1]:
      results.append(self.PostUpdate(line + continuation, **kwargs))
    results.append(self.PostUpdate(lines[-1], **kwargs))
    return results

  def GetReplies(self, since=None, since_id=None, page=None): 
    '''Get a sequence of status messages representing the 20 most recent
    replies (status updates prefixed with @username) to the authenticating
    user.

    Args:
      page: 
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.Status instances, one for each reply to the user.
    '''
    url = TWITTER_API_ROOT + 'statuses/replies.json'
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {}
    if since:
      parameters['since'] = since
    if since_id:
      parameters['since_id'] = since_id
    if page:
      parameters['page'] = page
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [Status.NewFromJsonDict(x) for x in data]

  def GetFriends(self, user=None, page=None):
    '''Fetch the sequence of twitter.User instances, one for each friend.

    Args:
      user: the username or id of the user whose friends you are fetching.  If
      not specified, defaults to the authenticated user. [optional]

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances, one for each friend
    '''
    if not self._username:
      raise TwitterError("twitter.Api instance must be authenticated")
    if user:
      url = TWITTER_API_ROOT + 'statuses/friends/%s.json' % user 
    else:
      url = TWITTER_API_ROOT + 'statuses/friends.json'
    parameters = {}
    if page:
      parameters['page'] = page
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [User.NewFromJsonDict(x) for x in data]

  def GetFollowers(self, page=None):
    '''Fetch the sequence of twitter.User instances, one for each follower

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances, one for each follower
    '''
    if not self._username:
      raise TwitterError("twitter.Api instance must be authenticated")
    url = TWITTER_API_ROOT + 'statuses/followers.json'
    parameters = {}
    if page:
      parameters['page'] = page
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [User.NewFromJsonDict(x) for x in data]

  def GetFeatured(self):
    '''Fetch the sequence of twitter.User instances featured on twitter.com

    The twitter.Api instance must be authenticated.

    Returns:
      A sequence of twitter.User instances
    '''
    url = TWITTER_API_ROOT + 'statuses/featured.json'
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [User.NewFromJsonDict(x) for x in data]

  def GetUser(self, user):
    '''Returns a single user.

    The twitter.Api instance must be authenticated.

    Args:
      user: The username or id of the user to retrieve.

    Returns:
      A twitter.User instance representing that user
    '''
    url = TWITTER_API_ROOT + 'users/show/%s.json' % user
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return User.NewFromJsonDict(data)
  
  def GetFriendshipsExists(self, user_a, user_b):
    url = TWITTER_API_ROOT + 'friendships/exists.json'
    data = {'user_a' : user_a, 'user_b' : user_b}
    json = self._FetchUrl(url, parameters=data)
    if json == 'true':
      return True
    else:
      return False

  def GetDirectMessages(self, since=None, since_id=None, page=None):
    '''Returns a list of the direct messages sent to the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      since:
        Narrows the returned results to just those statuses created
        after the specified HTTP-formatted date. [optional]
      since_id:
        Returns only public statuses with an ID greater than (that is,
        more recent than) the specified ID. [Optional]

    Returns:
      A sequence of twitter.DirectMessage instances
    '''
    url = TWITTER_API_ROOT + 'direct_messages.json'
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    parameters = {}
    if since:
      parameters['since'] = since
    if since_id:
      parameters['since_id'] = since_id
    if page:
      parameters['page'] = page 
    json = self._FetchUrl(url, parameters=parameters)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return [DirectMessage.NewFromJsonDict(x) for x in data]

  def PostDirectMessage(self, user, text):
    '''Post a twitter direct message from the authenticated user

    The twitter.Api instance must be authenticated.

    Args:
      user: The ID or screen name of the recipient user.
      text: The message text to be posted.  Must be less than 140 characters.

    Returns:
      A twitter.DirectMessage instance representing the message posted
    '''
    if not self._username:
      raise TwitterError("The twitter.Api instance must be authenticated.")
    url = TWITTER_API_ROOT + 'direct_messages/new.json'
    data = {'text': text, 'user': user}
    json = self._FetchUrl(url, post_data=data)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return DirectMessage.NewFromJsonDict(data)

  def DestroyDirectMessage(self, id):
    '''Destroys the direct message specified in the required ID parameter.

    The twitter.Api instance must be authenticated, and the
    authenticating user must be the recipient of the specified direct
    message.

    Args:
      id: The id of the direct message to be destroyed

    Returns:
      A twitter.DirectMessage instance representing the message destroyed
    '''
    url = TWITTER_API_ROOT + 'direct_messages/destroy/%s.json' % id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return DirectMessage.NewFromJsonDict(data)

  def CreateFriendship(self, user):
    '''Befriends the user specified in the user parameter as the authenticating user.

    The twitter.Api instance must be authenticated.

    Args:
      The ID or screen name of the user to befriend.
    Returns:
      A twitter.User instance representing the befriended user.
    '''
    url = TWITTER_API_ROOT + 'friendships/create/%s.json' % user
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return User.NewFromJsonDict(data)

  def DestroyFriendship(self, user):
    '''Discontinues friendship with the user specified in the user parameter.

    The twitter.Api instance must be authenticated.

    Args:
      The ID or screen name of the user  with whom to discontinue friendship.
    Returns:
      A twitter.User instance representing the discontinued friend.
    '''
    url = TWITTER_API_ROOT + 'friendships/destroy/%s.json' % user
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return User.NewFromJsonDict(data)

  def CreateFavorite(self, status):
    '''Favorites the status specified in the status parameter as the authenticating user.
    Returns the favorite status when successful.

    The twitter.Api instance must be authenticated.

    Args:
      The twitter.Status instance to mark as a favorite.
    Returns:
      A twitter.Status instance representing the newly-marked favorite.
    '''
    url = TWITTER_API_ROOT + 'favorites/create/%s.json' % status.id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return Status.NewFromJsonDict(data)

  def DestroyFavorite(self, status):
    '''Un-favorites the status specified in the ID parameter as the authenticating user.
    Returns the un-favorited status in the requested format when successful.

    The twitter.Api instance must be authenticated.

    Args:
      The twitter.Status to unmark as a favorite.
    Returns:
      A twitter.Status instance representing the newly-unmarked favorite.
    '''
    url = TWITTER_API_ROOT + 'favorites/destroy/%s.json' % status.id
    json = self._FetchUrl(url, post_data={})
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return Status.NewFromJsonDict(data)

  def GetUserByEmail(self, email):
    '''Returns a single user by email address.

    Args:
      email: The email of the user to retrieve.
    Returns:
      A twitter.User instance representing that user
    '''
    url = TWITTER_API_ROOT + 'users/show.json?email=%s' % email
    json = self._FetchUrl(url)
    data = simplejson.loads(json)
    self._CheckForTwitterError(data)
    return User.NewFromJsonDict(data)

  def SetCredentials(self, username, password):
    '''Set the username and password for this instance

    Args:
      username: The twitter username.
      password: The twitter password.
    '''
    self._username = username
    self._password = password

  def ClearCredentials(self):
    '''Clear the username and password for this instance
    '''
    self._username = None
    self._password = None

  def SetCache(self, cache):
    '''Override the default cache.  Set to None to prevent caching.

    Args:
      cache: an instance that supports the same API as the  twitter._FileCache
    '''
    self._cache = cache

  def SetUrllib(self, urllib):
    '''Override the default urllib implementation.

    Args:
      urllib: an instance that supports the same API as the urllib2 module
    '''
    self._urllib = urllib

  def SetCacheTimeout(self, cache_timeout):
    '''Override the default cache timeout.

    Args:
      cache_timeout: time, in seconds, that responses should be reused.
    '''
    self._cache_timeout = cache_timeout

  def SetUserAgent(self, user_agent):
    '''Override the default user agent

    Args:
      user_agent: a string that should be send to the server as the User-agent
    '''
    self._request_headers['User-Agent'] = user_agent

  def SetXTwitterHeaders(self, client, url, version):
    '''Set the X-Twitter HTTP headers that will be sent to the server.

    Args:
      client:
         The client name as a string.  Will be sent to the server as
         the 'X-Twitter-Client' header.
      url:
         The URL of the meta.xml as a string.  Will be sent to the server
         as the 'X-Twitter-Client-URL' header.
      version:
         The client version as a string.  Will be sent to the server
         as the 'X-Twitter-Client-Version' header.
    '''
    self._request_headers['X-Twitter-Client'] = client
    self._request_headers['X-Twitter-Client-URL'] = url
    self._request_headers['X-Twitter-Client-Version'] = version

  def SetSource(self, source):
    '''Suggest the "from source" value to be displayed on the Twitter web site.

    The value of the 'source' parameter must be first recognized by
    the Twitter server.  New source values are authorized on a case by
    case basis by the Twitter development team.

    Args:
      source:
        The source name as a string.  Will be sent to the server as
        the 'source' parameter.
    '''
    self._default_params['source'] = source

  def _BuildUrl(self, url, path_elements=None, extra_params=None):
    # Break url into consituent parts
    (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)

    # Add any additional path elements to the path
    if path_elements:
      # Filter out the path elements that have a value of None
      p = [i for i in path_elements if i]
      if not path.endswith('/'):
        path += '/'
      path += '/'.join(p)

    # Add any additional query parameters to the query string
    if extra_params and len(extra_params) > 0:
      extra_query = self._EncodeParameters(extra_params)
      # Add it to the existing query
      if query:
        query += '&' + extra_query
      else:
        query = extra_query

    # Return the rebuilt URL
    return urlparse.urlunparse((scheme, netloc, path, params, query, fragment))

  def _InitializeRequestHeaders(self, request_headers):
    if request_headers:
      self._request_headers = request_headers
    else:
      self._request_headers = {}

  def _InitializeUserAgent(self):
    user_agent = 'Python-urllib/%s (python-twitter/%s)' % \
                 (self._urllib.__version__, __version__)
    self.SetUserAgent(user_agent)

  def _InitializeDefaultParameters(self):
    self._default_params = {}

  def _AddAuthorizationHeader(self, username, password):
    if username and password:
      basic_auth = base64.encodestring('%s:%s' % (username, password))[:-1]
      self._request_headers['Authorization'] = 'Basic %s' % basic_auth

  def _RemoveAuthorizationHeader(self):
    if self._request_headers and 'Authorization' in self._request_headers:
      del self._request_headers['Authorization']

  def _GetOpener(self, url, username=None, password=None):
    if username and password:
      self._AddAuthorizationHeader(username, password)
      handler = self._urllib.HTTPBasicAuthHandler()
      (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
      handler.add_password(Api._API_REALM, netloc, username, password)
      opener = self._urllib.build_opener(handler)
    else:
      opener = self._urllib.build_opener()
    opener.addheaders = self._request_headers.items()
    return opener

  def _Encode(self, s):
    if self._input_encoding:
      return unicode(s, self._input_encoding).encode('utf-8')
    else:
      return unicode(s).encode('utf-8')

  def _EncodeParameters(self, parameters):
    '''Return a string in key=value&key=value form

    Values of None are not included in the output string.

    Args:
      parameters:
        A dict of (key, value) tuples, where value is encoded as
        specified by self._encoding
    Returns:
      A URL-encoded string in "key=value&key=value" form
    '''
    if parameters is None:
      return None
    else:
      return urllib.urlencode(dict([(k, self._Encode(v)) for k, v in parameters.items() if v is not None]))

  def _EncodePostData(self, post_data):
    '''Return a string in key=value&key=value form

    Values are assumed to be encoded in the format specified by self._encoding,
    and are subsequently URL encoded.

    Args:
      post_data:
        A dict of (key, value) tuples, where value is encoded as
        specified by self._encoding
    Returns:
      A URL-encoded string in "key=value&key=value" form
    '''
    if post_data is None:
      return None
    else:
      return urllib.urlencode(dict([(k, self._Encode(v)) for k, v in post_data.items()]))

  def _CheckForTwitterError(self, data):
    """Raises a TwitterError if twitter returns an error message.

    Args:
      data: A python dict created from the Twitter json response
    Raises:
      TwitterError wrapping the twitter error message if one exists.
    """
    # Twitter errors are relatively unlikely, so it is faster
    # to check first, rather than try and catch the exception
    if 'error' in data:
      raise TwitterError(data['error'])

  def _FetchUrl(self,
                url,
                post_data=None,
                parameters=None,
                no_cache=None):
    '''Fetch a URL, optionally caching for a specified time.

    Args:
      url: The URL to retrieve
      post_data: 
        A dict of (str, unicode) key/value pairs.  If set, POST will be used.
      parameters:
        A dict whose key/value pairs should encoded and added 
        to the query string. [OPTIONAL]
      no_cache: If true, overrides the cache on the current request

    Returns:
      A string containing the body of the response.
    '''
    # Build the extra parameters dict
    extra_params = {}
    if self._default_params:
      extra_params.update(self._default_params)
    if parameters:
      extra_params.update(parameters)

    # Add key/value parameters to the query string of the url
    url = self._BuildUrl(url, extra_params=extra_params)

    # Get a url opener that can handle basic auth
    opener = self._GetOpener(url, username=self._username, password=self._password)

    encoded_post_data = self._EncodePostData(post_data)

    # Open and return the URL immediately if we're not going to cache
    if encoded_post_data or no_cache or not self._cache or not self._cache_timeout:
      url_data = opener.open(url, encoded_post_data).read()
      opener.close()
    else:
      # Unique keys are a combination of the url and the username
      if self._username:
        key = self._username + ':' + url
      else:
        key = url

      # See if it has been cached before
      last_cached = self._cache.GetCachedTime(key)

      # If the cached version is outdated then fetch another and store it
      if not last_cached or time.time() >= last_cached + self._cache_timeout:
        url_data = opener.open(url, encoded_post_data).read()
        opener.close()
        self._cache.Set(key, url_data)
      else:
        url_data = self._cache.Get(key)

    # Always return the latest version
    return url_data
    
  def ConvertMentions(self, text):
    p = re.compile('@([a-zA-Z0-9\_]+)')
    return p.sub(r'@<a href="/twitter/user/\1">\1</a>', text)
    
  def ExpandBitly(self, text):
    if os.environ['HTTP_HOST'].find('localhost') == -1:
      p = re.compile('http:\/\/bit\.ly/[a-zA-Z0-9]+')
      m = p.findall(text)
      if len(m) > 0:
        api = bitly.Api(login='livid', apikey='R_40ab00809faf431d53cfdacc8d8b8d7f')
        last = None
        for s in m:
          if s != last:
            cache_tag = 'bitly_' + hashlib.md5(s).hexdigest()
            expanded = memcache.get(cache_tag)
            if expanded is None:
              expanded = api.expand(s)
              memcache.set(cache_tag, expanded, 2678400)
            last = s
            text = text.replace(s, expanded)
    return text

class _FileCacheError(Exception):
  '''Base exception class for FileCache related errors'''

class _FileCache(object):

  DEPTH = 3

  def __init__(self,root_directory=None):
    self._InitializeRootDirectory(root_directory)

  def Get(self,key):
    path = self._GetPath(key)
    if os.path.exists(path):
      return open(path).read()
    else:
      return None

  def Set(self,key,data):
    path = self._GetPath(key)
    directory = os.path.dirname(path)
    if not os.path.exists(directory):
      os.makedirs(directory)
    if not os.path.isdir(directory):
      raise _FileCacheError('%s exists but is not a directory' % directory)
    temp_fd, temp_path = tempfile.mkstemp()
    temp_fp = os.fdopen(temp_fd, 'w')
    temp_fp.write(data)
    temp_fp.close()
    if not path.startswith(self._root_directory):
      raise _FileCacheError('%s does not appear to live under %s' %
                            (path, self._root_directory))
    if os.path.exists(path):
      os.remove(path)
    os.rename(temp_path, path)

  def Remove(self,key):
    path = self._GetPath(key)
    if not path.startswith(self._root_directory):
      raise _FileCacheError('%s does not appear to live under %s' %
                            (path, self._root_directory ))
    if os.path.exists(path):
      os.remove(path)

  def GetCachedTime(self,key):
    path = self._GetPath(key)
    if os.path.exists(path):
      return os.path.getmtime(path)
    else:
      return None

  def _GetUsername(self):
    '''Attempt to find the username in a cross-platform fashion.'''
    try:
      return os.getenv('USER') or \
             os.getenv('LOGNAME') or \
             os.getenv('USERNAME') or \
             os.getlogin() or \
             'nobody'
    except (IOError, OSError), e:
      return 'nobody'

  def _GetTmpCachePath(self):
    username = self._GetUsername()
    cache_directory = 'python.cache_' + username
    return os.path.join(tempfile.gettempdir(), cache_directory)

  def _InitializeRootDirectory(self, root_directory):
    if not root_directory:
      root_directory = self._GetTmpCachePath()
    root_directory = os.path.abspath(root_directory)
    if not os.path.exists(root_directory):
      os.mkdir(root_directory)
    if not os.path.isdir(root_directory):
      raise _FileCacheError('%s exists but is not a directory' %
                            root_directory)
    self._root_directory = root_directory

  def _GetPath(self,key):
    try:
        hashed_key = md5(key).hexdigest()
    except TypeError:
        hashed_key = md5.new(key).hexdigest()
        
    return os.path.join(self._root_directory,
                        self._GetPrefix(hashed_key),
                        hashed_key)

  def _GetPrefix(self,hashed_key):
    return os.path.sep.join(hashed_key[0:_FileCache.DEPTH])

class _MemCache(object):
  '''A cache implementation that uses memcache'''
  
  def _GetCacheKey(self, key):
    return 'twitter_' + key
    
  def Get(self, key):
    data = memcache.get(self._GetCacheKey(key))
    if data is not None:
      return data[0]
    return None

  def Set(self, key, data):
    data = (data, time.time())
    memcache.set(self._GetCacheKey(key), data)

  def Remove(self, key):
    memcache.delete(self._GetCacheKey(key))

  def GetCachedTime(self,key):
    data = memcache.get(self._GetCacheKey(key))
    if data is not None:
      return data[1]
    return None
########NEW FILE########
__FILENAME__ = encoding
import datetime
from decimal import Decimal
import types


def is_protected_type(obj):
    """Determine if the object instance is of a protected type.

    Objects of protected types are preserved as-is when passed to
    force_unicode(strings_only=True).
    """
    return isinstance(obj, (
        types.NoneType,
        int, long,
        datetime.datetime, datetime.date, datetime.time,
        float, Decimal)
    )


def force_unicode(s, encoding='utf-8', strings_only=False, errors='strict'):
    """
    Similar to smart_unicode, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    if strings_only and is_protected_type(s):
        return s
    try:
        if not isinstance(s, basestring,):
            if hasattr(s, '__unicode__'):
                s = unicode(s)
            else:
                try:
                    s = unicode(str(s), encoding, errors)
                except UnicodeEncodeError:
                    if not isinstance(s, Exception):
                        raise
                    # If we get to here, the caller has passed in an Exception
                    # subclass populated with non-ASCII data without special
                    # handling to display as a string. We need to handle this
                    # without raising a further exception. We do an
                    # approximation to what the Exception's standard str()
                    # output should be.
                    s = ' '.join([force_unicode(arg, encoding, strings_only,
                            errors) for arg in s])
        elif not isinstance(s, unicode):
            # Note: We use .decode() here, instead of unicode(s, encoding,
            # errors), so that if s is a SafeString, it ends up being a
            # SafeUnicode at the end.
            s = s.decode(encoding, errors)
    except UnicodeDecodeError, e:
        raise UnicodeDecodeError(*e.args)
    return s

########NEW FILE########
__FILENAME__ = sanitizer
import re
from xml.sax.saxutils import escape, unescape

from html5lib.constants import tokenTypes
from html5lib.sanitizer import HTMLSanitizerMixin
from html5lib.tokenizer import HTMLTokenizer


class BleachSanitizerMixin(HTMLSanitizerMixin):
    """Mixin to replace sanitize_token() and sanitize_css()."""

    allowed_svg_properties = []

    def sanitize_token(self, token):
        """Sanitize a token either by HTML-encoding or dropping.

        Unlike HTMLSanitizerMixin.sanitize_token, allowed_attributes can be
        a dict of {'tag': ['attribute', 'pairs'], 'tag': callable}.

        Here callable is a function with two arguments of attribute name
        and value. It should return true of false.

        Also gives the option to strip tags instead of encoding.

        """
        if (getattr(self, 'wildcard_attributes', None) is None and
            isinstance(self.allowed_attributes, dict)):
            self.wildcard_attributes = self.allowed_attributes.get('*', [])

        if token['type'] in (tokenTypes['StartTag'], tokenTypes['EndTag'],
                             tokenTypes['EmptyTag']):
            if token['name'] in self.allowed_elements:
                if 'data' in token:
                    if isinstance(self.allowed_attributes, dict):
                        allowed_attributes = self.allowed_attributes.get(
                            token['name'], [])
                        if not callable(allowed_attributes):
                            allowed_attributes += self.wildcard_attributes
                    else:
                        allowed_attributes = self.allowed_attributes
                    attrs = dict([(name, val) for name, val in
                                  token['data'][::-1]
                                  if (allowed_attributes(name, val)
                                      if callable(allowed_attributes)
                                      else name in allowed_attributes)])
                    for attr in self.attr_val_is_uri:
                        if not attr in attrs:
                            continue
                        val_unescaped = re.sub("[`\000-\040\177-\240\s]+", '',
                                               unescape(attrs[attr])).lower()
                        # Remove replacement characters from unescaped
                        # characters.
                        val_unescaped = val_unescaped.replace(u"\ufffd", "")
                        if (re.match(r'^[a-z0-9][-+.a-z0-9]*:', val_unescaped)
                            and (val_unescaped.split(':')[0] not in
                                 self.allowed_protocols)):
                            del attrs[attr]
                    for attr in self.svg_attr_val_allows_ref:
                        if attr in attrs:
                            attrs[attr] = re.sub(r'url\s*\(\s*[^#\s][^)]+?\)',
                                                 ' ',
                                                 unescape(attrs[attr]))
                    if (token['name'] in self.svg_allow_local_href and
                        'xlink:href' in attrs and
                        re.search(r'^\s*[^#\s].*', attrs['xlink:href'])):
                        del attrs['xlink:href']
                    if 'style' in attrs:
                        attrs['style'] = self.sanitize_css(attrs['style'])
                    token['data'] = [(name, val) for name, val in
                                     attrs.items()]
                return token
            elif self.strip_disallowed_elements:
                pass
            else:
                if token['type'] == tokenTypes['EndTag']:
                    token['data'] = '</%s>' % token['name']
                elif token['data']:
                    attrs = ''.join([' %s="%s"' % (k, escape(v)) for k, v in
                                    token['data']])
                    token['data'] = '<%s%s>' % (token['name'], attrs)
                else:
                    token['data'] = '<%s>' % token['name']
                if token['selfClosing']:
                    token['data'] = token['data'][:-1] + '/>'
                token['type'] = tokenTypes['Characters']
                del token["name"]
                return token
        elif token['type'] == tokenTypes['Comment']:
            if not self.strip_html_comments:
                return token
        else:
            return token

    def sanitize_css(self, style):
        """HTMLSanitizerMixin.sanitize_css replacement.

        HTMLSanitizerMixin.sanitize_css always whitelists background-*,
        border-*, margin-*, and padding-*. We only whitelist what's in
        the whitelist.

        """
        # disallow urls
        style = re.compile('url\s*\(\s*[^\s)]+?\s*\)\s*').sub(' ', style)

        # gauntlet
        if not re.match("""^([-:,;#%.\sa-zA-Z0-9!]|\w-\w|'[\s\w]+"""
                        """'|"[\s\w]+"|\([\d,\s]+\))*$""",
                        style):
            return ''
        if not re.match("^\s*([-\w]+\s*:[^:;]*(;\s*|$))*$", style):
            return ''

        clean = []
        for prop, value in re.findall('([-\w]+)\s*:\s*([^:;]*)', style):
            if not value:
                continue
            if prop.lower() in self.allowed_css_properties:
                clean.append(prop + ': ' + value + ';')
            elif prop.lower() in self.allowed_svg_properties:
                clean.append(prop + ': ' + value + ';')

        return ' '.join(clean)


class BleachSanitizer(HTMLTokenizer, BleachSanitizerMixin):
    def __init__(self, stream, encoding=None, parseMeta=True, useChardet=True,
                 lowercaseElementName=True, lowercaseAttrName=True, **kwargs):
        HTMLTokenizer.__init__(self, stream, encoding, parseMeta, useChardet,
                               lowercaseElementName, lowercaseAttrName, **kwargs)

    def __iter__(self):
        for token in HTMLTokenizer.__iter__(self):
            token = self.sanitize_token(token)
            if token:
                yield token

########NEW FILE########
__FILENAME__ = captcha
import urllib
from google.appengine.api import urlfetch

"""
    Adapted from http://pypi.python.org/pypi/recaptcha-client
    to use with Google App Engine
    by Joscha Feth <joscha@feth.com>
    Version 0.1
"""

API_SSL_SERVER  ="https://api-secure.recaptcha.net"
API_SERVER      ="http://api.recaptcha.net"
VERIFY_SERVER   ="api-verify.recaptcha.net"

class RecaptchaResponse(object):
    def __init__(self, is_valid, error_code=None):
        self.is_valid   = is_valid
        self.error_code = error_code

def displayhtml (public_key,
                 use_ssl = False,
                 error = None):
    """Gets the HTML to display for reCAPTCHA

    public_key -- The public api key
    use_ssl -- Should the request be sent over ssl?
    error -- An error message to display (from RecaptchaResponse.error_code)"""

    error_param = ''
    if error:
        error_param = '&error=%s' % error

    if use_ssl:
        server = API_SSL_SERVER
    else:
        server = API_SERVER

    return """<script type="text/javascript" src="%(ApiServer)s/challenge?k=%(PublicKey)s%(ErrorParam)s"></script>

<noscript>
  <iframe src="%(ApiServer)s/noscript?k=%(PublicKey)s%(ErrorParam)s" height="300" width="500" frameborder="0"></iframe><br />
  <textarea name="recaptcha_challenge_field" rows="3" cols="40"></textarea>
  <input type='hidden' name='recaptcha_response_field' value='manual_challenge' />
</noscript>
""" % {
        'ApiServer' : server,
        'PublicKey' : public_key,
        'ErrorParam' : error_param,
        }


def submit (recaptcha_challenge_field,
            recaptcha_response_field,
            private_key,
            remoteip):
    """
    Submits a reCAPTCHA request for verification. Returns RecaptchaResponse
    for the request

    recaptcha_challenge_field -- The value of recaptcha_challenge_field from the form
    recaptcha_response_field -- The value of recaptcha_response_field from the form
    private_key -- your reCAPTCHA private key
    remoteip -- the user's ip address
    """

    if not (recaptcha_response_field and recaptcha_challenge_field and
            len (recaptcha_response_field) and len (recaptcha_challenge_field)):
        return RecaptchaResponse (is_valid = False, error_code = 'incorrect-captcha-sol')
    
    headers = {
               'Content-type':  'application/x-www-form-urlencoded',
               "User-agent"  :  "reCAPTCHA GAE Python"
               }         
    
    params = urllib.urlencode ({
	    'privatekey': private_key,
        'remoteip' : remoteip,
	    'challenge': recaptcha_challenge_field,
	    'response' : recaptcha_response_field,
	    })

    httpresp = urlfetch.fetch(
                   url      = "http://%s/verify" % VERIFY_SERVER,
                   payload  = params,
                   method   = urlfetch.POST,
                   headers  = headers
                    )     
    
    if httpresp.status_code == 200:
        # response was fine
        
        # get the return values
        return_values = httpresp.content.splitlines();
        
        # get the return code (true/false)
        return_code = return_values[0]
        
        if return_code == "true":
            # yep, filled perfectly
            return RecaptchaResponse (is_valid=True)
        else:
            # nope, something went wrong
            return RecaptchaResponse (is_valid=False, error_code = return_values [1])
    else:
        # recaptcha server was not reachable
        return RecaptchaResponse (is_valid=False, error_code = "recaptcha-not-reachable")
########NEW FILE########
__FILENAME__ = cookies
import UserDict
from Cookie import BaseCookie
class Cookies(UserDict.DictMixin):
    def __init__(self,handler,**policy):
        self.response = handler.response
        self._in = handler.request.cookies
        self.policy = policy
        if 'secure' not in policy and handler.request.environ.get('HTTPS', '').lower() in ['on', 'true']:
            policy['secure']=True
        self._out = {}
    def __getitem__(self, key):
        if key in self._out:
            return self._out[key]
        if key in self._in:
            return self._in[key]
        raise KeyError(key)
    def __setitem__(self, key, item):
        self._out[key] = item
        self.set_cookie(key, item, **self.policy)
    def __contains__(self, key):
        return key in self._in or key in self._out
    def keys(self):
        return self._in.keys() + self._out.keys()
    def __delitem__(self, key):
        if key in self._out:
            del self._out[key]
            self.unset_cookie(key)
        if key in self._in:
            del self._in[key]
            p = {}
            if 'path' in self.policy: p['path'] = self.policy['path']
            if 'domain' in self.policy: p['domain'] = self.policy['domain']
            self.delete_cookie(key, **p)
    #begin WebOb functions
    def set_cookie(self, key, value='', max_age=None,
                   path='/', domain=None, secure=None, httponly=False,
                   version=None, comment=None):
        """
        Set (add) a cookie for the response
        """
        cookies = BaseCookie()
        cookies[key] = value
        for var_name, var_value in [
            ('max-age', max_age),
            ('path', path),
            ('domain', domain),
            ('secure', secure),
            ('HttpOnly', httponly),
            ('version', version),
            ('comment', comment),
            ]:
            if var_value is not None and var_value is not False:
                cookies[key][var_name] = str(var_value)
            if max_age is not None:
                cookies[key]['expires'] = max_age
        header_value = cookies[key].output(header='').lstrip()
        self.response.headers._headers.append(('Set-Cookie', header_value))
    def delete_cookie(self, key, path='/', domain=None):
        """
        Delete a cookie from the client.  Note that path and domain must match
        how the cookie was originally set.
        This sets the cookie to the empty string, and max_age=0 so
        that it should expire immediately.
        """
        self.set_cookie(key, '', path=path, domain=domain,
                        max_age=0)
    def unset_cookie(self, key):
        """
        Unset a cookie with the given name (remove it from the
        response).  If there are multiple cookies (e.g., two cookies
        with the same name and different paths or domains), all such
        cookies will be deleted.
        """
        existing = self.response.headers.get_all('Set-Cookie')
        if not existing:
            raise KeyError(
                "No cookies at all have been set")
        del self.response.headers['Set-Cookie']
        found = False
        for header in existing:
            cookies = BaseCookie()
            cookies.load(header)
            if key in cookies:
                found = True
                del cookies[key]
            header = cookies.output(header='').lstrip()
            if header:
                self.response.headers.add('Set-Cookie', header)
        if not found:
            raise KeyError(
                "No cookie has been set with the name %r" % key)
    #end WebOb functions
########NEW FILE########
__FILENAME__ = sessions
import os
import time
import datetime
import random
import Cookie
import logging
from google.appengine.api import memcache
from django.utils import simplejson as json

# Note - please do not use this for production applications
# see: http://code.google.com/p/appengine-utitlies/

COOKIE_NAME = 'appengine-simple-session-sid'
DEFAULT_COOKIE_PATH = '/'
SESSION_EXPIRE_TIME = 7200 # sessions are valid for 7200 seconds (2 hours)

class Session(object):

    def __init__(self):
        self.sid = None
        self.key = None
        self.session = None
        string_cookie = os.environ.get('HTTP_COOKIE', '')
        self.cookie = Cookie.SimpleCookie()
        self.cookie.load(string_cookie)

        # check for existing cookie
        if self.cookie.get(COOKIE_NAME):
            self.sid = self.cookie[COOKIE_NAME].value
            self.key = "session-" + self.sid
	    self.session = memcache.get(self.key)
            if self.session is None:
               logging.info("Invalidating session "+self.sid)
               self.sid = None
               self.key = None

        if self.session is None:
            self.sid = str(random.random())[5:]+str(random.random())[5:]
            self.key = "session-" + self.sid
            logging.info("Creating session "+self.key);
            self.session = dict()
	    memcache.add(self.key, self.session, 3600)

            self.cookie[COOKIE_NAME] = self.sid
            self.cookie[COOKIE_NAME]['path'] = DEFAULT_COOKIE_PATH
            # Send the Cookie header to the browser
            print self.cookie

    # Private method to update the cache on modification 
    def _update_cache(self):
        memcache.replace(self.key, self.session, 3600)

    # Convenient delete with no error method
    def delete_item(self, keyname):
        if keyname in self.session:
            del self.session[keyname]
            self._update_cache()

    # Support the dictionary get() method
    def get(self, keyname, default=None):
        if keyname in self.session:
            return self.session[keyname]
        return default

    # session[keyname] = value
    def __setitem__(self, keyname, value):
        self.session[keyname] = value
        self._update_cache()

    # x = session[keyname]
    def __getitem__(self, keyname):
        if keyname in self.session:
            return self.session[keyname]
        raise KeyError(str(keyname))

    # del session[keyname]
    def __delitem__(self, keyname):
        if keyname in self.session:
	    del self.session[keyname]
            logging.info(self.session)
            self._update_cache()
            return
        raise KeyError(str(keyname))

    # if keyname in session :
    def __contains__(self, keyname):
        try:
            r = self.__getitem__(keyname)
        except KeyError:
            return False
        return True

    # x = len(session)
    def __len__(self):
        return len(self.session)


########NEW FILE########
__FILENAME__ = upyun
# -*- coding: utf8 -*-
import httplib
import md5 as imd5
import base64
import time
import re


METADATA_PREFIX = 'x-upyun-meta-'
DL = '/'


def md5(src):
    m1 = imd5.new()   
    m1.update(src)   
    dest1 = m1.hexdigest() 
    return dest1

def md5file(fobj):
    m = imd5.new()
    while True:
        d = fobj.read(8096)
        if not d:
            break
        m.update(d)
    fobj.seek(0)
    return m.hexdigest()


def merge_meta(headers, metadata):
     final_headers = headers.copy()
     for k in metadata.keys():
        final_headers[METADATA_PREFIX + k] = metadata[k]
     return final_headers

class UpYunException(Exception):
    '''Raised when a Yupoo method fails.

    More specific details will be included in the exception message
    when thrown.
    ''' 

#目录条目类
class FolderItem(object):
    def __init__(self, filename, filetype, size, number):
        self.filename = filename
        self.filetype = filetype
        self.size = size
        self.number = number


class UpYun(object):
    def __init__(self, bucket, username, password):
        self.thehost = 'v0.api.upyun.com'
        self.username = username
        self.password = password
        self.bucket = bucket
        self.upAuth = False
        self.debug = False
        self._tmp_info = None
        self.content_md5 = ''
        self.file_secret = ''

    #版本
    def version(self):
        return '1.0.1'

    #设置待上传文件的 Content-MD5 值（如又拍云服务端收到的文件MD5值与用户设置的不一致，将回报 406 Not Acceptable 错误）
    def setContentMD5(self, vaule):
        self.content_md5 = vaule

    #设置待上传文件的 访问密钥（注意：仅支持图片空！，设置密钥后，无法根据原文件URL直接访问，需带 URL 后面加上 （缩略图间隔标志符+密钥） 进行访问）
    #如缩略图间隔标志符为 ! ，密钥为 bac，上传文件路径为 /folder/test.jpg ，那么该图片的对外访问地址为： http://空间域名/folder/test.jpg!bac
    def setFileSecret(self, vaule):
        self.file_secret = vaule

    #设定api所调用的域名,包括电信,联通,网通,移动,铁通和自动选择
    def setApiDomain(self,thehost):
        self.thehost = thehost

    #设定是否使用又拍签名
    def setAuthType(self,upAuth):
        self.upAuth = upAuth

    def getList(self, path='', headers={}, metadata={}):
        resp = self._net_worker( 'GET', DL+self.bucket+DL+path, '', headers, metadata)
        return resp

    def delete(self, path, headers={}, metadata={}):
        resp = self._net_worker('DELETE',DL+self.bucket+DL+path, '',headers,metadata)
        return resp
     
    #获取空间占用大小
    def getBucketUsage(self, path='', headers={}, metadata={}):
        resp = self.getList(path+'?usage', headers, metadata)
        try:
            resp = int(resp.read()) 
        except Exception, e:
            resp = None
        return resp
    
    #获取某个目录的空间占用大小
    #path目录路径
    def getFolderUsage(self, path='', headers={}, metadata={}):
        resp = self.getBucketUsage(path, headers, metadata)
        return resp
    
    #新建目录
    #path目录路径
    #[auto] 是否自动创建父级目录（最多10级）
    def mkDir(self, path, auto=False, headers={}, metadata={}):
        headers['folder'] = 'create'
        if auto == True :
            headers['mkdir'] = 'true'
        resp = self._net_worker('POST', DL+self.bucket+DL+path, '', headers, metadata)
        if resp.status == 200 :
            return True
        else :
            return False

    #删除目录
    #path目录路径
    def rmDir(self, path, headers={}, metadata={}):
        resp = self.delete(path,headers,metadata)
        if resp.status == 200 :
            return True
        else :
            return False
    
    #读取目录,返回FolderItem
    #path目录路径
    def readDir(self, path='', headers={}, metadata={}):
        resp = self.getList(path, headers, metadata)
        if resp.status == 200 :
            result = re.sub('\t', '\/', resp.read())
            result = re.sub('\n', '\/', result)
            b = result.split('\/')
            i=0
            fis = []
            while i+1<len(b):
                fi = FolderItem(b[i],b[i+1],b[i+2],b[i+3])
                fis.append(fi)
                i+=4    
            return fis
        else :
            return False
        
    #上传文件
    #data 要上传的文件数据
    #path 远程文件的位置
    #[auto] 是否自动创建父级目录（最多10级）
    def writeFile(self, path, data, auto = False, headers={}, metadata={}):
        if auto == True :
            headers['mkdir'] = 'true'
        if type(data) != file :
            headers['Content-Length'] = len(data)
        resp = self._net_worker('PUT',DL+self.bucket+DL+path, data,headers,metadata)
        self._tmp_info = None
        if resp.status == 200 :
            self._tmp_info = {}
            self._tmp_info['x-upyun-width'] = resp.getheader('x-upyun-width')
            self._tmp_info['x-upyun-height'] = resp.getheader('x-upyun-height')
            self._tmp_info['x-upyun-frames'] = resp.getheader('x-upyun-frames')
            self._tmp_info['x-upyun-file-type'] = resp.getheader('x-upyun-file-type')
            return True
        else :
            return False

    #获取上传文件后的信息（仅图片空间有返回数据）
    #key 信息字段名（x-upyun-width、x-upyun-height、x-upyun-frames、x-upyun-file-type）
    #return value or NULL
    def getWritedFileInfo(self, key):
        if self._tmp_info != None and self._tmp_info['x-upyun-width'] :
            return self._tmp_info[key]
        return None
    #读取文件
    #path 所要读取文件地远程路径
    def readFile(self, path, headers={}, metadata={}):
        resp = self.getList(path, headers, metadata)
        if resp.status == 200 :
            return resp.read()
        else :
            return None

    #删除文件
    #path 所要删除文件地远程路径
    def deleteFile(self, path, headers={}, metadata={}):
        resp = self.delete(path,headers,metadata)
        if resp.status == 200 :
            return True
        else :
            return False

    #获取文件信息
    #path 文件的远程路径
    #返回格式为 {'date': unix time, 'type': file | folder, 'size': file size} 或 None
    def getFileInfo(self, path, headers={}, metadata={}):
        resp = self._net_worker( 'HEAD', DL+self.bucket+DL+path, '', headers, metadata)
        if resp.status == 200 :
            rs = {}
            rs['type'] = resp.getheader('x-upyun-file-type')
            rs['size'] = resp.getheader('x-upyun-file-size')
            rs['date'] = resp.getheader('x-upyun-file-date')
            return rs
        else : 
            return None
    
    def _net_worker(self, method, path, data='', headers={}, metadata={}):
        connection = httplib.HTTPConnection(self.thehost)

        if self.content_md5 != '':
            headers['Content-MD5'] = self.content_md5
            self.content_md5 = ''

        if self.file_secret != '':
            headers['Content-Secret'] = self.file_secret
            self.file_secret = ''

        final_headers = merge_meta(headers, metadata)

        if self.upAuth:
            self._add_upyun_auth_header(final_headers,method,path)
        else :
            self._basicAuth(final_headers,self.username,self.password) 

        connection.request(method, path , data, final_headers)

        resp = connection.getresponse()                                                                 
        if self.debug and resp.status != 200 and method != "HEAD" :
            raise UpYunException(u'ERROR: Code:%d,Message:%s'%(resp.status,resp.read()))
        return resp

    #又拍签名认证
    def _add_upyun_auth_header(self, headers, method, uri):
        headers['Date'] = time.strftime("%a, %d %b %Y %X GMT", time.gmtime())
        if 'Content-Length' in headers:
            scr = md5(method+'&'+uri+'&'+headers['Date']+'&'
                      +str(headers['Content-Length'])+'&'+md5(self.password))
        else :
            scr = md5(method+'&'+uri+'&'+headers['Date']+'&'
                      +'0'+'&'+md5(self.password))

        headers['Authorization'] = "UpYun %s:%s" % (self.username, scr)
 
     
    def _basicAuth(self,headers, username, password):
        encode = base64.encodestring(username+':'+password)
        headers['Authorization'] = "Basic %s" % encode.strip()


########NEW FILE########
__FILENAME__ = en
# coding=utf-8

# Messages on top bar
home = 'Home'
images = 'Images'
mentions = 'Mentions'
workspace = 'Workspace'
notes = 'Notes'
nearby = 'Nearby'
settings = 'Settings'
backstage = 'Backstage'
signin = 'Sign In'
signup = 'Sign Up'
signout = 'Sign Out'
planes = 'Planes'

# Messages shared by forms

chevron = '<span class="chevron">&nbsp;›&nbsp;</span>'
resolve_errors = "Please resolve the following errors."
failed_signin = "Username/password not matched"
delete = 'Delete'
submit = 'Submit'
save = 'Save'
create = 'Create'
back_to = 'Back to'
yes = 'Yes'
no = 'No'

# Messages on /signin

password = "Password"
remember_1_year = "Cookie will be remembered for a year."
forgot_password = "I Forgot Password"
existing_member = 'Existing member please <a href="/signin">sign in</a>'

# Messages on /signup

username_empty = 'Please input your username'
username_too_long = 'Username should not be longer than 32 characters'
username_too_short = 'Username should have at least 3 characters'
username_invalid = 'Username can only use 0-9, a-z, A-Z and underscore'
username_taken = 'Sorry, this username is taken by other'

# Messages on /signout

signin_again = 'Sign In Again'

# Messages on /

signup_now = "Sign Up Now"
hottest_nodes = 'Hottest Nodes'
new_nodes = 'New Nodes'
community_stats = 'Community Stats'
total_members = 'Total Members'
total_topics = 'Total Topics'
total_replies = 'Total Replies'
recent_visited_nodes = 'Recent Visited Nodes'
rss_subscribe = 'RSS'
more_recent_topics = 'More Recent Topics'
nodes_portal = 'Nodes Portal'

# Messages on /t/

no_reply = 'No Reply Yet'
add_a_reply_now = 'Add a Reply Now'
send = 'Send'
better_to_block = "It's better to block someone than to start a flame war."
reply_content_cannot_be_empty = "Reply content can't be empty"
newer_replies_first = "Newer Replies First"
earlier_replies_first = "Earlier Replies First"
show_all = "Show All"
just_topic_creator = "Just Topic Creator"
replies = "replies"
till = "Till"
sure_to_delete = "Sure to delete?"
no_pointless = "➥ Please avoid posting pointless replies, it's always great to save everyone's precious time."
for_good = "All for a better world."

# Messages on /go/

create_new_topic = "Create New Topic"
next = "Next"
previous = "Previous"
header_replies = "Replies"
header_subject = "Subject"
header_author = "Author"
header_last_replied = "Last Replied"

# Messages on /settings

username = "Username"
email = "Email"
website = "Website"
twitter = "Twitter"
location = "Location"
tagline = "Tagline"
bio = "Bio"
language = "Language"
twitter_sync = "Twitter Sync"
save_settings = "Save Settings"
avatar = "Avatar"
current_avatar = "Current Avatar"
upload_new_avatar = "Upload New Avatar"
gravatar_support = '<a href="http://www.gravatar.com/" target="_blank">Gravatar</a> is also supported'
security = "Security"
leave_blank = "If you don't want to change your passwords, please leave these fields blank."
current_password = "Current"
new_password = "New"
change_password = "Change Password"
account_status = "Status"
twitter_not_linked = "Twitter Account Not Linked"
twitter_link_explained = "Link your Twitter account securely via OAuth, then you can sync your topics/replies."
personal_records = "Personal Records"
blocked = "Blocked"
updated_every_4_hours = "Updated Every 4 Hours"
show_home_top = "Show Site Header"
show_quick_post = "Show Quick Post"
do_show = "Show"
do_not_show = "Do Not Show"

# Messages on /member/

recent_topics = 'Recent Topics'
recent_participated_topics = 'Recent Participated Topics'

# Messages on /backstage

site_settings = 'Site Settings'
site_settings_explained = 'Site name, slogan, description and other details. Who can create topic and who can reply.'
topic_settings = 'Topic Settings'
topic_settings_explained = 'Configure topic types.'
sections = 'Sections'
add_new_section = 'Add New Section'
minisites = 'Minisites'
add_new_minisite = 'Add New Minisite'
data_management = 'Data Management'
delete_specified_cached_item = 'Delete Specified Cached Item'
delete_specified_cached_item_explained = 'You can clear specified cached item by entering its name here.'
mapreduce_explained = 'MapReduce is a very powerful tool for tidying all data, use with caution.'
latest_joined = 'Latest Joined'
sure_to_delete_minisite = 'Sure to delete this minisite and all its contents?'

# Messages on /backstage/site

site_name = 'Site Name'
site_slogan = 'Site Slogan'
site_domain = 'Site Domain'
site_description = 'Description'
site_home_categories = 'Home Categories'
one_category_per_line = 'One featured category per line'
site_settings_updated = 'Site settings updated successfully'
site_theme = 'Theme'

# Messages on /backstage/topic

enable_topic_types = 'Enable Topic Types'
topic_types = 'Topic Types'
topic_types_explained = 'One type per line, use colon to separate name and color'
########NEW FILE########
__FILENAME__ = zhHans
# coding=utf-8

# Messages on top bar
home = '首页'
images = '图片上传'
mentions = '提到我的'
workspace = '工作空间'
notes = '记事本'
nearby = '附近'
settings = '设置'
backstage = '后台'
signin = '登入'
signup = '注册'
signout = '登出'
planes = '位面'

# Messages shared by forms

chevron = '<span class="chevron">&nbsp;›&nbsp;</span>'
resolve_errors = "请解决以下错误之后再继续"
failed_signin = "用户名/密码不匹配"
delete = '删除'
submit = '提交'
save = '保存'
create = '创建'
back_to = '返回'
yes = '是'
no = '否'

# Messages on /signin

password = "密码"
remember_1_year = "登录后 cookie 会被记住一年"
forgot_password = "我忘记密码了"
existing_member = '已注册用户请 <a href="/signin">登入</a>'

# Messages on /signup

username_empty = '请输入用户名'
username_too_long = '用户名长度不能超过 32 个字符'
username_too_short = '用户名长度至少 3 个字符'
username_invalid = '用户名只能使用 0-9, a-z, A-Z 及 _'
username_taken = '抱歉，这个用户名已经被注册了'

# Messages on /signout

signin_again = '重新登入'

# Messages on /

signup_now = "现在注册"
hottest_nodes = '最热节点'
new_nodes = '最近新增节点'
community_stats = '社区运行状态'
total_members = '注册会员总数'
total_topics = '主题总数'
total_replies = '回复总数'
recent_visited_nodes = '最近访问节点'
rss_subscribe = 'RSS 订阅社区最新更新'
more_recent_topics = '更多新主题'
nodes_portal = '节点导航'

# Messages on /t/

no_reply = '目前尚无回复'
add_a_reply_now = '现在添加一条回复'
send = '发送'
better_to_block = "与其与人争吵，不如将其屏蔽。"
reply_content_cannot_be_empty = "回复内容不能为空"
newer_replies_first = "新回复在前"
earlier_replies_first = "按回复时间排序"
show_all = "显示全部"
just_topic_creator = "只看楼主"
replies = "回复"
till = "直到"
sure_to_delete = "确认删除？"
no_pointless = '请认真考虑自己的回复能够如何帮助到别人。这里不欢迎无意义的“顶”，“沙发”，“不懂”，“<a href="http://www.v2ex.com/t/23249">楼主火星了</a>”。'
for_good = '<a href="/t/10740" class="node">技术类问题回答指南</a> <a href="http://www.v2ex.com/t/18160" class="node">不要让敷衍成为一种习惯</a>'

# Messages on /go/

create_new_topic = "创建新主题"
next = "下一页"
previous = "上一页"
header_replies = "回复"
header_subject = "标题"
header_author = "作者"
header_last_replied = "最后回复时间"

# Messages on /settings

username = "用户名"
email = "电子邮件"
website = "个人网站"
twitter = "Twitter"
location = "所在地"
tagline = "签名"
bio = "个人简介"
language = "语言"
twitter_sync = "Twitter 同步"
save_settings = "保存设置"
avatar = "头像"
current_avatar = "当前头像"
upload_new_avatar = "上传新头像"
gravatar_support = '本站亦支持　<a href="http://www.gravatar.com/" target="_blank">Gravatar</a>'
security = "安全"
leave_blank = "如果你不想更改密码，请留空以下输入框。"
current_password = "当前密码"
new_password = "新密码"
change_password = "更改密码"
account_status = "帐号状态"
twitter_not_linked = "Twitter 帐号尚未绑定"
twitter_link_explained = "通过 OAuth 可以安全地绑定你的 Twitter 账户，之后即可同步你的主题和回复。"
personal_records = "个人纪录"
blocked = "屏蔽"
updated_every_4_hours = "以上数据大约每 4 小时更新一次"
show_home_top = "首页头部信息"
show_quick_post = "快捷发布"
do_show = "显示"
do_not_show = "不显示"

# Messages on /member/

recent_topics = '最近创建主题'
recent_participated_topics = '最近参与主题'

# Messages on /backstage

site_settings = '站点设置'
site_settings_explained = '站点名，标语，描述及谁可以发贴，谁可以回帖。'
topic_settings = '主题设置'
topic_settings_explained = '配置主题类型。'
sections = '区域'
add_new_section = '添加新区域'
minisites = '迷你站'
add_new_minisite = '添加新迷你站'
data_management = '数据管理'
delete_specified_cached_item = '删除指定的缓存项目'
delete_specified_cached_item_explained = '你可以在这里输入指定的缓存项目的名字并删除它。'
mapreduce_explained = 'MapReduce 是一个用于数据整理的超强工具，请谨慎使用。'
latest_joined = '最新加入会员'
sure_to_delete_minisite = '确认删除这个 minisite 及其所有内容？'

# Messages on /backstage/site

site_name = '站点名'
site_slogan = '站点标语'
site_domain = '站点主域名'
site_description = '站点描述'
site_home_categories = '主页分类'
one_category_per_line = '每行一个'
site_settings_updated = '站点设置成功更新'
site_theme = '站点皮肤主题'

# Messages on /backstage/topic

enable_topic_types = '开启主题类型'
topic_types = '主题类型'
topic_types_explained = '每行一个，使用 : 分割名字和颜色'
########NEW FILE########
__FILENAME__ = filters
import re, string
import logging
from v2ex.babel.ext import bleach

from django import template

from datetime import timedelta
import urllib, hashlib
register = template.Library()

# Configuration for urlize() function
LEADING_PUNCTUATION  = ['(', '<', '&lt;']
TRAILING_PUNCTUATION = ['.', ',', ')', '>', '\n', '&gt;']

# list of possible strings used for bullets in bulleted lists
DOTS = ['&middot;', '*', '\xe2\x80\xa2', '&#149;', '&bull;', '&#8226;']

unencoded_ampersands_re = re.compile(r'&(?!(\w+|#\d+);)')
word_split_re = re.compile(r'(\s+)')
punctuation_re = re.compile('^(?P<lead>(?:%s)*)(?P<middle>.*?)(?P<trail>(?:%s)*)$' % \
    ('|'.join([re.escape(x) for x in LEADING_PUNCTUATION]),
    '|'.join([re.escape(x) for x in TRAILING_PUNCTUATION])))
simple_email_re = re.compile(r'^\S+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+$')
link_target_attribute_re = re.compile(r'(<a [^>]*?)target=[^\s>]+')
html_gunk_re = re.compile(r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)', re.IGNORECASE)
hard_coded_bullets_re = re.compile(r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|'.join([re.escape(x) for x in DOTS]), re.DOTALL)
trailing_empty_content_re = re.compile(r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z')
del x # Temporary variable

def timezone(value, offset):
    if offset > 12:
        offset = 12 - offset
    return value + timedelta(hours=offset)
register.filter(timezone)

def autolink2(text):
    return bleach.linkify(text)
register.filter(autolink2)

def autolink(text, trim_url_limit=None, nofollow=False):
    """
    Converts any URLs in text into clickable links. Works on http://, https:// and
    www. links. Links can have trailing punctuation (periods, commas, close-parens)
    and leading punctuation (opening parens) and it'll still do the right thing.

    If trim_url_limit is not None, the URLs in link text will be limited to
    trim_url_limit characters.

    If nofollow is True, the URLs in link text will get a rel="nofollow" attribute.
    """
    trim_url = lambda x, limit=trim_url_limit: limit is not None and (x[:limit] + (len(x) >=limit and '...' or ''))  or x
    words = word_split_re.split(text)
    nofollow_attr = nofollow and ' rel="nofollow"' or ''
    for i, word in enumerate(words):
        match = punctuation_re.match(word)
        if match:
            lead, middle, trail = match.groups()
            if middle.startswith('www.') or ('@' not in middle and not middle.startswith('http://') and not middle.startswith('https://') and \
                    len(middle) > 0 and middle[0] in string.letters + string.digits and \
                    (middle.endswith('.org') or middle.endswith('.net') or middle.endswith('.com'))):
                middle = '<a href="http://%s"%s target="_blank">%s</a>' % (middle, nofollow_attr, trim_url(middle))
            if middle.startswith('http://') or middle.startswith('https://'):
                middle = '<a href="%s"%s target="_blank">%s</a>' % (middle, nofollow_attr, trim_url(middle))
            if '@' in middle and not middle.startswith('www.') and not ':' in middle \
                and simple_email_re.match(middle):
                middle = '<a href="mailto:%s">%s</a>' % (middle, middle)
            if lead + middle + trail != word:
                words[i] = lead + middle + trail
    return ''.join(words)
register.filter(autolink)

# auto convert img.ly/abcd links to image tags
def imgly(value):
    imgs = re.findall('(http://img.ly/[a-zA-Z0-9]+)\s?', value)
    if (len(imgs) > 0):
        for img in imgs:
            img_id = re.findall('http://img.ly/([a-zA-Z0-9]+)', img)
            if (img_id[0] != 'system' and img_id[0] != 'api'):
                value = value.replace('http://img.ly/' + img_id[0], '<a href="http://img.ly/' + img_id[0] + '" target="_blank"><img src="http://picky-staging.appspot.com/img.ly/show/large/' + img_id[0] + '" class="imgly" border="0" /></a>')
        return value
    else:
        return value
register.filter(imgly)

# auto convert cl.ly/abcd links to image tags
def clly(value):
    #imgs = re.findall('(http://cl.ly/[a-zA-Z0-9]+)\s?', value)
    #if (len(imgs) > 0):
    #    for img in imgs:
    #        img_id = re.findall('http://cl.ly/([a-zA-Z0-9]+)', img)
    #        if (img_id[0] != 'demo' and img_id[0] != 'whatever'):
    #            value = value.replace('http://cl.ly/' + img_id[0], '<a href="http://cl.ly/' + img_id[0] + '" target="_blank"><img src="http://cl.ly/' + img_id[0] + '/content" class="imgly" border="0" /></a>')
    #    return value
    #else:
    #    return value
    return value
register.filter(clly)

# auto convert *.sinaimg.cn/*/*.jpg and bcs.baidu.com/*.jpg links to image tags
def sinaimg(value):
    imgs = re.findall('(http://ww[0-9]{1}.sinaimg.cn/[a-zA-Z0-9]+/[a-zA-Z0-9]+.[a-z]{3})\s?', value)
    for img in imgs:
        value = value.replace(img, '<a href="' + img + '" target="_blank"><img src="' + img + '" class="imgly" border="0" /></a>')
    baidu_imgs = re.findall('(http://(bcs.duapp.com|img.xiachufang.com|i.xiachufang.com)/([a-zA-Z0-9\.\-\_\/]+).jpg)\s?', value)
    for img in baidu_imgs:
        value = value.replace(img[0], '<a href="' + img[0] + '" target="_blank"><img src="' + img[0] + '" class="imgly" border="0" /></a>')
    return value
register.filter(sinaimg)

# auto convert youtube.com links to player
def youtube(value):
    videos = re.findall('(http://www.youtube.com/watch\?v=[a-zA-Z0-9\-\_]+)\s?', value)
    if (len(videos) > 0):
        for video in videos:
            video_id = re.findall('http://www.youtube.com/watch\?v=([a-zA-Z0-9\-\_]+)', video)
            value = value.replace('http://www.youtube.com/watch?v=' + video_id[0], '<object width="620" height="500"><param name="movie" value="http://www.youtube.com/v/' + video_id[0] + '?fs=1&amp;hl=en_US"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/' + video_id[0] + '?fs=1&amp;hl=en_US" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="620" height="500"></embed></object>')
        return value
    else:
        return value
register.filter(youtube)

# auto convert youku.com links to player
# example: http://v.youku.com/v_show/id_XMjA1MDU2NTY0.html
def youku(value):
    videos = re.findall('(http://v.youku.com/v_show/id_[a-zA-Z0-9\=]+.html)\s?', value)
    logging.error(value)
    logging.error(videos)
    if (len(videos) > 0):
        for video in videos:
            video_id = re.findall('http://v.youku.com/v_show/id_([a-zA-Z0-9\=]+).html', video)
            value = value.replace('http://v.youku.com/v_show/id_' + video_id[0] + '.html', '<embed src="http://player.youku.com/player.php/sid/' + video_id[0] + '/v.swf" quality="high" width="638" height="420" align="middle" allowScriptAccess="sameDomain" type="application/x-shockwave-flash"></embed>')
        return value
    else:
        return value
register.filter(youku)

# auto convert tudou.com links to player
# example: http://www.tudou.com/programs/view/ro1Yt1S75bA/
def tudou(value):
    videos = re.findall('(http://www.tudou.com/programs/view/[a-zA-Z0-9\=]+/)\s?', value)
    logging.error(value)
    logging.error(videos)
    if (len(videos) > 0):
        for video in videos:
            video_id = re.findall('http://www.tudou.com/programs/view/([a-zA-Z0-9\=]+)/', video)
            value = value.replace('http://www.tudou.com/programs/view/' + video_id[0] + '/', '<embed src="http://www.tudou.com/v/' + video_id[0] + '/" quality="high" width="638" height="420" align="middle" allowScriptAccess="sameDomain" type="application/x-shockwave-flash"></embed>')
        return value
    else:
        return value
register.filter(tudou)

# auto convert @username to clickable links
def mentions(value):
    ms = re.findall('(@[a-zA-Z0-9\_]+\.?)\s?', value)
    if (len(ms) > 0):
        for m in ms:
            m_id = re.findall('@([a-zA-Z0-9\_]+\.?)', m)
            if (len(m_id) > 0):
                if (m_id[0].endswith('.') != True):
                    value = value.replace('@' + m_id[0], '@<a href="/member/' + m_id[0] + '">' + m_id[0] + '</a>')
        return value
    else:
        return value
register.filter(mentions)

# gravatar filter
def gravatar(value,arg):
    default = "http://v2ex.appspot.com/static/img/avatar_" + str(arg) + ".png"
    if type(value).__name__ != 'Member':
        return '<img src="' + default + '" border="0" align="absmiddle" />'
    if arg == 'large':
        number_size = 73
        member_avatar_url = value.avatar_large_url
    elif arg == 'normal':
        number_size = 48
        member_avatar_url = value.avatar_normal_url
    elif arg == 'mini':
        number_size = 24
        member_avatar_url = value.avatar_mini_url
        
    if member_avatar_url:
        return '<img src="'+ member_avatar_url +'" border="0" alt="' + value.username + '" />'
    else:
        gravatar_url = "http://www.gravatar.com/avatar/" + hashlib.md5(value.email.lower()).hexdigest() + "?"
        gravatar_url += urllib.urlencode({'s' : str(number_size), 'd' : default})
        return '<img src="' + gravatar_url + '" border="0" alt="' + value.username + '" align="absmiddle" />'
register.filter(gravatar)

# avatar filter
def avatar(value, arg):
    default = "/static/img/avatar_" + str(arg) + ".png"
    if type(value).__name__ not in ['Member', 'Node']:
        return '<img src="' + default + '" border="0" />'
    if arg == 'large':
        number_size = 73
        member_avatar_url = value.avatar_large_url
    elif arg == 'normal':
        number_size = 48
        member_avatar_url = value.avatar_normal_url
    elif arg == 'mini':
        number_size = 24
        member_avatar_url = value.avatar_mini_url
        
    if value.avatar_mini_url:
        return '<img src="'+ member_avatar_url +'" border="0" />'
    else:
        return '<img src="' + default + '" border="0" />'
register.filter(avatar)

# github gist script support
def gist(value):
    return re.sub(r'(http://gist.github.com/[\d]+)', r'<script src="\1.js"></script>', value)
register.filter(gist)

_base_js_escapes = (
    ('\\', r'\u005C'),
    ('\'', r'\u0027'),
    ('"', r'\u0022'),
    ('>', r'\u003E'),
    ('<', r'\u003C'),
    ('&', r'\u0026'),
    ('=', r'\u003D'),
    ('-', r'\u002D'),
    (';', r'\u003B'),
    (u'\u2028', r'\u2028'),
    (u'\u2029', r'\u2029')
)

# Escape every ASCII character with a value less than 32.
_js_escapes = (_base_js_escapes +
               tuple([('%c' % z, '\\u%04X' % z) for z in range(32)]))

def escapejs(value):
    """Hex encodes characters for use in JavaScript strings."""
    for bad, good in _js_escapes:
        value = value.replace(bad, good)
    return value
register.filter(escapejs)
########NEW FILE########
__FILENAME__ = xmpp
#!/usr/bin/env python
# coding=utf-8

import logging
import re
import hashlib
import urllib

from v2ex.babel import Member

from v2ex.babel.da import *

from google.appengine.ext import db
from google.appengine.ext import webapp
from google.appengine.api import xmpp
from google.appengine.api import urlfetch
from google.appengine.ext.webapp import xmpp_handlers
from google.appengine.ext.webapp.util import run_wsgi_app

from twitter.twitter import Api
from twitter.oauthtwitter import OAuthApi
from twitter.oauth import OAuthToken

from config import twitter_consumer_key as CONSUMER_KEY
from config import twitter_consumer_secret as CONSUMER_SECRET

from django.utils import simplejson as json

def extract_address(raw):
    if raw.find('/') == -1:
        return raw
    else:
        return raw.split('/')[0]

class XMPPHandler(webapp.RequestHandler):
    def post(self):
        message = xmpp.Message(self.request.POST)
        to = extract_address(message.to.lower())
        sender = extract_address(message.sender.lower())
        member = GetMemberByEmail(sender)
        if member:
            if member.twitter_oauth == 1:
                access_token = OAuthToken.from_string(member.twitter_oauth_string)
                twitter = OAuthApi(CONSUMER_KEY, CONSUMER_SECRET, access_token)
                status = message.body
                result = None
                if len(status) > 140:
                    status = status[0:140]
                try:
                    if message.command is not None:
                        command = message.command.lower()
                        if command == 'mentions' or command == 'm' or command == 'r':
                            logging.info('About to get mentions for @' + member.twitter_screen_name)
                            statuses = twitter.GetReplies()
                            msg = ''
                            i = 0
                            for s in statuses:
                                msg = msg + '@' + s.user.screen_name + ': ' + s.text + "\n\n"
                                i = i + 1
                                if i > 5:
                                    break
                            xmpp.send_message(message.sender, msg)
                        if command == 'search' or command == 'q' or command == 's':
                            q = re.findall('/' + command + ' (.+)', message.body)[0]
                            url = 'http://twitter.com/search.json?q=' + urllib.quote(q)
                            response = urlfetch.fetch(url)
                            logging.info(response.status_code)
                            data = json.loads(response.content)
                            msg = ''
                            i = 0
                            for s in data['results']:
                                msg = msg + '@' + s['from_user'] + ': ' + s['text'] + "\n\n"
                                i = i + 1
                                if i > 5:
                                    break
                            xmpp.send_message(message.sender, msg)
                    else:
                        if status.lower() == 'ls':
                            logging.info('About to get home timeline for @' + member.twitter_screen_name)
                            statuses = twitter.GetHomeTimeline(count = 5)
                            msg = ''
                            i = 0
                            for s in statuses:
                                msg = msg + '@' + s.user.screen_name + ': ' + s.text + "\n\n"
                            xmpp.send_message(message.sender, msg)
                        else:
                            logging.info("About to send tweet: " + status)
                            result = twitter.PostUpdate(status.encode('utf-8'))
                            logging.info("Successfully tweet: " + status)
                except:
                    logging.error("Failed to tweet for " + member.username)
                if result is not None:
                    msg = 'OK: http://twitter.com/' + result.user.screen_name + '/status/' + str(result.id)
                    xmpp.send_message(message.sender, msg)
            else:
                logging.error("User " + sender + " doesn't have Twitter link.")
        else:
            logging.error("Cannot find a corresponding member for " + message.sender) 

application = webapp.WSGIApplication([
    ('/_ah/xmpp/message/chat/', XMPPHandler)
], debug=True)

def main():
    run_wsgi_app(application)

if __name__ == "__main__":
    main()
########NEW FILE########
