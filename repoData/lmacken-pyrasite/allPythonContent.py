__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pyrasite documentation build configuration file, created by
# sphinx-quickstart on Mon Feb 13 02:40:02 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.autosummary']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pyrasite'
copyright = u'2011-2013, Red Hat, Inc., Luke Macken'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0beta'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pyrasitedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Pyrasite.tex', u'Pyrasite Documentation',
   u'Luke Macken', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pyrasite', u'Pyrasite Documentation',
     [u'Luke Macken'], 1)
]

########NEW FILE########
__FILENAME__ = injector
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import os
import subprocess
import platform

def inject(pid, filename, verbose=False, gdb_prefix=''):
    """Executes a file in a running Python process."""
    filename = os.path.abspath(filename)
    gdb_cmds = [
        'PyGILState_Ensure()',
        'PyRun_SimpleString("'
            'import sys; sys.path.insert(0, \\"%s\\"); '
            'sys.path.insert(0, \\"%s\\"); '
            'exec(open(\\"%s\\").read())")' %
                (os.path.dirname(filename),
                os.path.abspath(os.path.join(os.path.dirname(__file__), '..')),
                filename),
        'PyGILState_Release($1)',
        ]
    p = subprocess.Popen('%sgdb -p %d -batch %s' % (gdb_prefix, pid,
        ' '.join(["-eval-command='call %s'" % cmd for cmd in gdb_cmds])),
        shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if verbose:
        print(out)
        print(err)

if platform.system() == 'Windows':
    def inject_win(pid, filename, verbose=False, gdb_prefix=''):
        if gdb_prefix == '':
            gdb_prefix = os.path.join(os.path.dirname(__file__), 'win') + os.sep
        filename = os.path.abspath(filename)
        code = 'import sys; sys.path.insert(0, \\"%s\\"); sys.path.insert(0, \\"%s\\"); exec(open(\\"%s\\").read())' % (os.path.dirname(filename).replace('\\', '/'), os.path.abspath(os.path.join(os.path.dirname(__file__), '..')).replace('\\', '/'), filename.replace('\\', '/'))
        p = subprocess.Popen('%sinject_python_32.exe %d \"%s\"' % (gdb_prefix, pid, code), shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
        out, err = p.communicate()
        if p.wait() == 25:
            p = subprocess.Popen('%sinject_python_64.exe %d \"%s\"' % (gdb_prefix, pid, code), shell = True, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
            out, err = p.communicate()
        if verbose:
            print(out)
            print(err)

    inject = inject_win
########NEW FILE########
__FILENAME__ = inspector
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import sys
import subprocess

encoding = sys.getdefaultencoding()


def inspect(pid, address):
    "Return the value of an object in a given process at the specified address"
    cmd = ' '.join([
        'gdb --quiet -p %s -batch' % pid,
        '-eval-command="print (PyObject *)%s"' % address,
    ])
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    for line in p.communicate()[0].decode(encoding).split('\n'):
        if line.startswith('$1 = '):
            return line[5:]

########NEW FILE########
__FILENAME__ = ipc
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>
"""
:mod:`pyrasite.ipc` - Pyrasite Inter-Python Communication
=========================================================
"""

import os
import stat
import socket
import struct
import tempfile
import subprocess
import platform

from os.path import dirname, abspath, join

import pyrasite


class PyrasiteIPC(object):
    """Pyrasite Inter-Python Communication.

    This object is used in communicating to or from another Python process.

    It can perform a variety of tasks:

    - Injection of the :class:`pyrasite.ReversePythonConnection` payload via
      :meth:`PyrasiteIPC.connect()`, which causes the process to connect back
      to a port that we are listening on. The connection with the process is
      then available via `self.sock`.

    - Python code can then be executed in the process using
      :meth:`PyrasiteIPC.cmd`. Both stdout and stderr are returned.

    - Low-level communication with the process, both reliably (via a length
      header) or unreliably (raw data, ideal for use with netcat) with a
      :class:`pyrasite.ReversePythonConnection` payload, via
      :meth:`PyrasiteIPC.send(data)` and :meth:`PyrasiteIPC.recv(data)`.

    The :class:`PyrasiteIPC` is subclassed by
    :class:`pyrasite.tools.gui.Process` as well as
    :class:`pyrasite.reverse.ReverseConnection`.

    """
    # Allow subclasses to disable this and just send/receive raw data, as
    # opposed to prepending a length header, to ensure reliability. The reason
    # to enable 'unreliable' connections is so we can still use our reverse
    # shell payloads with netcat.
    reliable = True

    def __init__(self, pid, reverse='ReversePythonConnection'):
        super(PyrasiteIPC, self).__init__()
        self.pid = pid
        self.sock = None
        self.server_sock = None
        self.hostname = None
        self.port = None
        self.reverse = reverse

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, *args, **kwargs):
        self.close()

    @property
    def title(self):
        if not getattr(self, '_title', None):
            if platform.system() == 'Windows':
                p = subprocess.Popen('tasklist /v /fi "pid eq %d" /nh /fo csv' % self.pid,
                                    stdout=subprocess.PIPE, shell=True)
                tmp = p.communicate()[0].decode('utf-8').strip().split(',')
                if tmp[-1] == '"N/A"':
                    self._title = tmp[0][1:-1]
                else:
                    self._title = tmp[-1][1:-1]
            else:
                p = subprocess.Popen('ps --no-heading -o cmd= -p %d' % self.pid,
                                    stdout=subprocess.PIPE, shell=True)
                self._title = p.communicate()[0].decode('utf-8')
        return self._title.strip()

    def connect(self):
        """
        Setup a communication socket with the process by injecting
        a reverse subshell and having it connect back to us.
        """
        self.listen()
        self.inject()
        self.wait()

    def listen(self):
        """Listen on a random port"""
        for res in socket.getaddrinfo('localhost', None, socket.AF_UNSPEC,
                                      socket.SOCK_STREAM, 0, 0):
            af, socktype, proto, canonname, sa = res
            try:
                self.server_sock = socket.socket(af, socktype, proto)
                try:
                    self.server_sock.bind(sa)
                    self.server_sock.listen(1)
                except socket.error:
                    self.server_sock.close()
                    self.server_sock = None
                    continue
            except socket.error:
                self.server_sock = None
                continue
            break

        if not self.server_sock:
            raise Exception('pyrasite was unable to setup a ' +
                            'local server socket')
        else:
            self.hostname, self.port = self.server_sock.getsockname()[0:2]

    def create_payload(self):
        """Write out a reverse python connection payload with a custom port"""
        (fd, filename) = tempfile.mkstemp()
        tmp = os.fdopen(fd, 'w')
        path = dirname(abspath(pyrasite.__file__))
        payload = open(join(path, 'reverse.py'))

        for line in payload.readlines():
            if line.startswith('#'):
                continue
            line = line.replace('port = 9001', 'port = %d' % self.port)
            if not self.reliable:
                line = line.replace('reliable = True', 'reliable = False')
            tmp.write(line)

        tmp.write('%s().start()\n' % self.reverse)
        tmp.close()
        payload.close()

        if platform.system() != 'Windows':
            os.chmod(filename, stat.S_IREAD | stat.S_IRGRP | stat.S_IROTH)

        return filename

    def inject(self):
        """Inject the payload into the process."""
        filename = self.create_payload()
        pyrasite.inject(self.pid, filename)
        os.unlink(filename)

    def wait(self):
        """Wait for the injected payload to connect back to us"""
        (clientsocket, address) = self.server_sock.accept()
        self.sock = clientsocket
        self.sock.settimeout(5)
        self.address = address

    def cmd(self, cmd):
        """
        Send a python command to exec in the process and return the output
        """
        self.send(cmd + '\n')
        return self.recv()

    def send(self, data):
        """Send arbitrary data to the process via self.sock"""
        header = ''.encode('utf-8')
        data = data.encode('utf-8')
        if self.reliable:
            header = struct.pack('<L', len(data))
        self.sock.sendall(header + data)

    def recv(self):
        """Receive a command from a given socket"""
        if self.reliable:
            header_data = self.recv_bytes(4)
            if len(header_data) == 4:
                msg_len = struct.unpack('<L', header_data)[0]
                data = self.recv_bytes(msg_len).decode('utf-8')
                if len(data) == msg_len:
                    return data
        else:
            return self.sock.recv(4096).decode('utf-8')

    def recv_bytes(self, n):
        """Receive n bytes from a socket"""
        data = ''.encode('utf-8')
        while len(data) < n:
            chunk = self.sock.recv(n - len(data))
            if not chunk:
                break
            data += chunk
        return data

    def close(self):
        if self.sock:
            self.sock.close()
        if getattr(self, 'server_sock', None):
            self.server_sock.close()

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, self.pid)

########NEW FILE########
__FILENAME__ = main
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc.

import os
import sys
import argparse
import subprocess

import pyrasite


def ptrace_check():
    ptrace_scope = '/proc/sys/kernel/yama/ptrace_scope'
    if os.path.exists(ptrace_scope):
        f = open(ptrace_scope)
        value = int(f.read().strip())
        f.close()
        if value == 1:
            print("WARNING: ptrace is disabled. Injection will not work.")
            print("You can enable it by running the following:")
            print("echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope")
            print("")
    else:
        getsebool = '/usr/sbin/getsebool'
        if os.path.exists(getsebool):
            p = subprocess.Popen([getsebool, 'deny_ptrace'],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = p.communicate()
            if str(out) == 'deny_ptrace --> on\n':
                print("WARNING: ptrace is disabled. Injection will not work.")
                print("You can enable it by running the following:")
                print("sudo setsebool -P deny_ptrace=off")
                print("")


def get_payload_dir():
    return os.path.join(os.path.dirname(pyrasite.__file__), 'payloads')


def list_payloads():
    return sorted(fn for fn in os.listdir(get_payload_dir())
                  if fn.endswith('.py') and not fn.startswith('_'))

def expand_payload(payload):
    """If a standard payload with this name exists, return its full path.

    Otherwise return the input value unchanged.
    """
    if os.path.sep not in payload:
        fn = os.path.join(get_payload_dir(), payload)
        if os.path.isfile(fn):
            return fn
    return payload


def main():
    ptrace_check()

    parser = argparse.ArgumentParser(
            description='pyrasite - inject code into a running python process',
            epilog="For updates, visit https://github.com/lmacken/pyrasite")

    parser.add_argument('pid', nargs='?',
                        help="The ID of the process to inject code into")
    parser.add_argument('payload', nargs='?', default='',
                        help="The Python script to be executed inside the"
                             " running process.  Can be one of the standard"
                             " payloads (see --list-payloads) or a filname.")
    parser.add_argument('-l', '--list-payloads', help='List standard payloads',
                        default=False, action='store_const', const=True)
    parser.add_argument('--gdb-prefix', dest='gdb_prefix',
                        help='GDB prefix (if specified during installation)',
                        default="")
    parser.add_argument('--verbose', dest='verbose', help='Verbose mode',
                        default=False, action='store_const', const=True)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.list_payloads:
        print("Available payloads:")
        for payload in list_payloads():
            print("  %s" % payload)
        sys.exit()

    try:
        pid = int(args.pid)
    except ValueError:
        print("Error: The first argument must be a pid")
        sys.exit(2)

    filename = expand_payload(args.payload)
    if filename:
        if not os.path.exists(filename):
            print("Error: Invalid path or file doesn't exist")
            sys.exit(3)
    else:
        print("Error: The second argument must be a filename or a payload name")
        sys.exit(4)

    pyrasite.inject(pid, filename, verbose=args.verbose,
                    gdb_prefix=args.gdb_prefix)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = dump_memory
# "meliae" provides a way to dump python memory usage information to a JSON
# disk format, which can then be parsed into useful things like graph
# representations.
#
# https://launchpad.net/meliae
# http://jam-bazaar.blogspot.com/2009/11/memory-debugging-with-meliae.html

import os, meliae.scanner, platform

if platform.system() == 'Windows':
    temp = os.getenv('TEMP', os.getenv('TMP', '/temp'))
    path = os.path.join(temp, 'pyrasite-%d-objects.json' % os.getpid())
else:
    path = '/tmp/pyrasite-%d-objects.json' % os.getpid()
meliae.scanner.dump_all_objects(path)

########NEW FILE########
__FILENAME__ = dump_modules
import sys

for name in sorted(sys.modules):
    print('%s: %s' % (name, sys.modules[name]))

########NEW FILE########
__FILENAME__ = dump_stacks
import sys, traceback

for thread, frame in sys._current_frames().items():
    print('Thread 0x%x' % thread)
    traceback.print_stack(frame)
    print()

########NEW FILE########
__FILENAME__ = force_garbage_collection
import gc
gc.collect()

########NEW FILE########
__FILENAME__ = helloworld
print("Hello World!")

########NEW FILE########
__FILENAME__ = reverse_python_shell
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import sys
import pyrasite

class ReversePythonShell(pyrasite.ReversePythonConnection):
    port = 9001
    reliable = False

    def on_connect(self):
        self.send("Python %s\nType 'quit' to exit\n>>> " % sys.version)

ReversePythonShell().start()

########NEW FILE########
__FILENAME__ = reverse_shell
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import pyrasite

class ReverseShell(pyrasite.ReverseConnection):

    reliable = False # This payload is designed to be used with netcat
    port = 9001

    def on_connect(self):
        uname = pyrasite.utils.run('uname -a')[1]
        self.send("%sType 'quit' to exit\n%% " % uname)

    def on_command(self, cmd):
        p, out, err = pyrasite.utils.run(cmd)
        if err:
            out += err
        self.send(out + '\n% ')
        return True

ReverseShell().start()

########NEW FILE########
__FILENAME__ = start_callgraph
# http://pycallgraph.slowchop.com/pycallgraph/wiki/documentation/
import pycallgraph
pycallgraph.start_trace()

########NEW FILE########
__FILENAME__ = stop_callgraph
# http://pycallgraph.slowchop.com/pycallgraph/wiki/documentation/
import pycallgraph
pycallgraph.make_dot_graph('callgraph.png')

########NEW FILE########
__FILENAME__ = reverse
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>
"""
:mod:`pyrasite.reverse` - Pyrasite Reverse Connection Payload
=============================================================
"""

import sys
import socket
import traceback
import threading
from code import InteractiveConsole

if sys.version_info[0] == 3:
    from io import StringIO
else:
    from StringIO import StringIO

import pyrasite


class ReverseConnection(threading.Thread, pyrasite.PyrasiteIPC):
    """A payload that connects to a given host:port and receives commands"""

    host = 'localhost'
    port = 9001
    reliable = True

    def __init__(self, host=None, port=None):
        super(ReverseConnection, self).__init__()
        self.sock = None
        if host:
            self.host = host
        if port:
            self.port = port

    def on_connect(self):
        """Called when we successfuly connect to `self.host`"""

    def on_command(self, cmd):
        """Called when the host sends us a command"""

    def run(self):
        running = True
        while running:
            try:
                for res in socket.getaddrinfo(self.host, self.port,
                        socket.AF_UNSPEC, socket.SOCK_STREAM):
                    af, socktype, proto, canonname, sa = res
                    try:
                        self.sock = socket.socket(af, socktype, proto)
                        try:
                            self.sock.connect(sa)
                        except socket.error:
                            self.sock.close()
                            self.sock = None
                            continue
                    except socket.error:
                        self.sock = None
                        continue
                    break

                if not self.sock:
                    raise Exception('pyrasite cannot establish reverse ' +
                            'connection to %s:%d' % (self.host, self.port))

                self.on_connect()

                while running:
                    cmd = self.recv()
                    if cmd is None or cmd == "quit\n" or len(cmd) == 0:
                        running = False
                    else:
                        running = self.on_command(cmd)

            except:
                traceback.print_exc()
                running = False
            if not running:
                self.close()


class ReversePythonConnection(ReverseConnection):
    """A reverse Python connection payload.

    Executes Python commands and returns the output.
    """
    def on_command(self, cmd):
        buffer = StringIO()
        sys.stdout = buffer
        sys.stderr = buffer
        output = ''
        try:
            exec(cmd)
            output = buffer.getvalue()
        except:
            output = traceback.format_exc()
        sys.stdout = sys.__stdout__
        sys.stderr = sys.__stderr__
        buffer.close()
        self.send(output)
        return True


class DistantInteractiveConsole(InteractiveConsole):
    def __init__(self, ipc):
        InteractiveConsole.__init__(self, globals())

        self.ipc = ipc
        self.set_buffer()

    def set_buffer(self):
        self.out_buffer = StringIO()
        sys.stdout = sys.stderr = self.out_buffer

    def unset_buffer(self):
        sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__
        value = self.out_buffer.getvalue()
        self.out_buffer.close()

        return value

    def raw_input(self, prompt=""):
        output = self.unset_buffer()
        # payload format: 'prompt' ? '\n' 'output'
        self.ipc.send('\n'.join((prompt, output)))

        cmd = self.ipc.recv()

        self.set_buffer()

        return cmd


class ReversePythonShell(threading.Thread, pyrasite.PyrasiteIPC):
    """A reverse Python shell that behaves like Python interactive interpreter.

    """

    host = 'localhost'
    port = 9001
    reliable = True

    def __init__(self, host=None, port=None):
        super(ReversePythonShell, self).__init__()

    def run(self):
        try:
            for res in socket.getaddrinfo(self.host, self.port,
                    socket.AF_UNSPEC, socket.SOCK_STREAM):
                af, socktype, proto, canonname, sa = res
                try:
                    self.sock = socket.socket(af, socktype, proto)
                    try:
                        self.sock.connect(sa)
                    except socket.error:
                        self.sock.close()
                        self.sock = None
                        continue
                except socket.error:
                    self.sock = None
                    continue
                break

            if not self.sock:
                raise Exception('pyrasite cannot establish reverse ' +
                        'connection to %s:%d' % (self.host, self.port))

            DistantInteractiveConsole(self).interact()

        except SystemExit:
            pass
        except:
            traceback.print_exc(file=sys.__stderr__)

        sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__
        self.close()

########NEW FILE########
__FILENAME__ = context_manager_case
""" This is kept in a separate file so that python2.4 never picks it up. """

import pyrasite


def context_manager_business(case):
    # Check that the context manager injects ipc correctly.
    with pyrasite.PyrasiteIPC(case.p.pid) as ipc:
        assert ipc.cmd('print("mu")') == 'mu\n'

    # Check that the context manager closes the ipc correctly.
    try:
        ipc.cmd('print("mu")')
        assert False, "The connection was not closed."
    except IOError as e:
        assert "Bad file descriptor" in str(e)

########NEW FILE########
__FILENAME__ = test_cli
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import os
import sys

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from pyrasite.main import main

class TestCLI(object):

    def test_usage(self):
        sys.argv = ['pyrasite']
        try:
            main()
        except SystemExit:
            exit_code = sys.exc_info()[1].code
            assert exit_code == 1, exit_code

    def test_list_payloads(self):
        sys.argv = ['pyrasite', '-l']
        stdout = sys.stdout
        sys.stdout = StringIO()
        try:
            main()
        except SystemExit:
            pass
        value = sys.stdout.getvalue()
        sys.stdout = stdout
        assert 'Available payloads:' in value, repr(value)
        assert 'helloworld.py' in value, repr(value)

    def test_invalid_pid(self):
        sys.argv = ['pyrasite', 'foo', 'bar']
        stdout = sys.stdout
        sys.stdout = StringIO()
        try:
            main()
        except SystemExit:
            exit_code = sys.exc_info()[1].code
            assert exit_code == 2, exit_code
        value = sys.stdout.getvalue()
        sys.stdout = stdout
        assert 'Error: The first argument must be a pid' in value, repr(value)

    def test_invalid_payload(self):
        sys.argv = ['pyrasite', str(os.getpid()), 'foo']
        stdout = sys.stdout
        sys.stdout = StringIO()
        try:
            main()
        except SystemExit:
            exit_code = sys.exc_info()[1].code
            assert exit_code == 3, exit_code
        value = sys.stdout.getvalue()
        sys.stdout = stdout
        assert "Error: Invalid path or file doesn't exist" in value, repr(value)

    def test_injection(self):
        sys.argv = ['pyrasite', str(os.getpid()), 'helloworld.py']
        stdout = sys.stdout
        sys.stdout = StringIO()
        main()
        value = sys.stdout.getvalue()
        sys.stdout = stdout
        assert "Hello World!" in value, repr(value)

########NEW FILE########
__FILENAME__ = test_code_injection
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import os
import sys
import subprocess

import pyrasite

from pyrasite.tests.utils import generate_program, run_program, stop_program, \
                                 interpreters


class TestCodeInjection(object):

    def assert_output_contains(self, stdout, stderr, text):
        assert text in str(stdout), \
                "Code injection failed: %s\n%s" % (stdout, stderr)

    def test_injecting_into_all_interpreters(self):
        program = generate_program()
        try:
            for exe in interpreters():
                print("sys.executable = %s" % sys.executable)
                print("injecting into %s" % exe)
                p = run_program(program, exe=exe)
                pyrasite.inject(p.pid,
                        'pyrasite/payloads/helloworld.py', verbose=True)
                stop_program(p)
                stdout, stderr = p.communicate()
                self.assert_output_contains(stdout, stderr, 'Hello World!')
        finally:
            os.unlink(program)

    def test_many_payloads_into_program_with_many_threads(self):
        program = generate_program(threads=25)
        num_payloads = 25
        try:
            for exe in interpreters():
                p = run_program(program, exe=exe)
                for i in range(num_payloads):
                    pyrasite.inject(p.pid,
                            'pyrasite/payloads/helloworld.py', verbose=True)
                stop_program(p)
                stdout, stderr = p.communicate()
                count = 0
                for line in stdout.decode('utf-8').split('\n'):
                    if line.strip() == 'Hello World!':
                        count += 1
                assert count == num_payloads, "Read %d hello worlds" % count
        finally:
            os.unlink(program)

    def test_pyrasite_script(self):
        program = generate_program()
        try:
            for exe in interpreters():
                print("sys.executable = %s" % sys.executable)
                print("injecting into %s" % exe)
                p = run_program(program, exe=exe)
                subprocess.call([sys.executable, 'pyrasite/main.py',
                    str(p.pid), 'pyrasite/payloads/helloworld.py'],
                    env={'PYTHONPATH': os.getcwd()})
                stop_program(p)
                stdout, stderr = p.communicate()
                self.assert_output_contains(stdout, stderr, 'Hello World!')
        finally:
            os.unlink(program)


########NEW FILE########
__FILENAME__ = test_ipc
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc.

import os
import sys

from nose.plugins.skip import SkipTest

import pyrasite
from pyrasite.tests.utils import run_program, generate_program, stop_program


class TestIPCContextManager(object):

    def setUp(self):
        self.prog = generate_program()
        self.p = run_program(self.prog)

    def tearDown(self):
        stop_program(self.p)

    def test_context_manager(self):
        # Check that we're on a version of python that
        # supports context managers
        info = sys.version_info
        major, minor = info[0], info[1]
        if major <= 2 and minor <= 5:
            raise SkipTest("Context Managers not supported on Python<=2.5")

        # Otherwise import a module which contains modern syntax.
        # It really contains our test case, but we have pushed it out into
        # another module so that python 2.4 never sees it.
        import pyrasite.tests.context_manager_case
        pyrasite.tests.context_manager_case.context_manager_business(self)


class TestIPC(object):

    def setUp(self):
        self.prog = generate_program()
        self.p = run_program(self.prog)
        self.ipc = pyrasite.PyrasiteIPC(self.p.pid)

    def tearDown(self):
        stop_program(self.p)
        self.ipc.close()

    def test_listen(self):
        self.ipc.listen()
        assert self.ipc.server_sock
        assert self.ipc.hostname
        assert self.ipc.port
        assert self.ipc.server_sock.getsockname()[1] == self.ipc.port

    def test_create_payload(self):
        self.ipc.listen()
        payload = self.ipc.create_payload()
        assert os.path.exists(payload)
        code = open(payload)
        compile(code.read(), payload, 'exec')
        code.close()
        os.unlink(payload)

    def test_connect(self):
        self.ipc.connect()
        assert self.ipc.sock
        assert self.ipc.address

    def test_cmd(self):
        self.ipc.connect()
        assert self.ipc.cmd('print("mu")') == 'mu\n'

    def test_unreliable(self):
        self.ipc.reliable = False
        self.ipc.connect()
        out = self.ipc.cmd('print("mu")')
        assert out == 'mu\n', out

    def test_repr(self):
        assert repr(self.ipc)

    def test_title(self):
        assert self.ipc.title

########NEW FILE########
__FILENAME__ = utils
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import os
import sys
import glob
import time
import textwrap
import tempfile
import subprocess


def generate_program(threads=1):
    (fd, filename) = tempfile.mkstemp()
    tmp = os.fdopen(fd, 'w')
    script = textwrap.dedent("""
        import os, time, threading
        running = True
        pidfile = '/tmp/pyrasite_%d' % os.getpid()
        open(pidfile, 'w').close()
        def cpu_bound():
            i = 0
            while running:
                i += 1
    """)
    # CPU-bound threads
    for t in range(threads):
        script += "threading.Thread(target=cpu_bound).start()\n"
    script += textwrap.dedent("""
        while os.path.exists(pidfile):
            time.sleep(0.1)
        running = False
    """)
    tmp.write(script)
    tmp.close()
    return filename


def run_program(program, exe='/usr/bin/python'):
    p = subprocess.Popen([exe, program],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
    flag = '/tmp/pyrasite_%d' % p.pid
    i = 0
    while not os.path.exists(flag):
        time.sleep(0.1)
        i += 1
        if i > 100:
            raise Exception("Program never touched pid file!")
    return p


def stop_program(p):
    os.unlink('/tmp/pyrasite_%d' % p.pid)


def interpreters():
    for exe in glob.glob('/usr/bin/python*.*'):
        try:
            int(exe.split('.')[-1])
        except ValueError:
            continue  # skip python2.7-config, etc
        yield exe

########NEW FILE########
__FILENAME__ = memory_viewer
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc.
# Authors: Luke Macken <lmacken@redhat.com>
"""
An interface for visualizing the output of of the dump-memory payload.

When selecting an object, we attach to the running process and obtain
the value of the object itself.
"""

__version__ = '1.0'

import os
import re
import sys
import urwid
import urwid.raw_display

from meliae import loader
from os.path import join, abspath, dirname

import pyrasite


class PyrasiteMemoryViewer(object):
    palette = [
        ('body',            'black',        'light gray', 'standout'),
        ('header',          'white',        'dark red',   'bold'),
        ('button normal',   'light gray',   'dark blue', 'standout'),
        ('button select',   'white',        'dark green'),
        ('button disabled', 'dark gray',    'dark blue'),
        ('bigtext',         'white',        'black'),
        ('object_output',   'light gray',   'black'),
        ('exit',            'white',        'dark red'),
        ]

    def __init__(self, pid, objects):
        self.pid = pid
        self.objects = objects
        self.summary = objects.summarize()

    def create_radio_button(self, g, name, obj, fn, disabled=False):
        w = urwid.RadioButton(g, name, False, on_state_change=fn)
        w.obj = obj
        if disabled:
            w = urwid.AttrWrap(w, 'button normal', 'button disabled')
        else:
            w = urwid.AttrWrap(w, 'button normal', 'button select')
        return w

    def create_disabled_radio_button(self, name):
        w = urwid.Text('    ' + name)
        w = urwid.AttrWrap(w, 'button disabled')
        return w

    def display_object(self, w, state):
        if state:
            value = pyrasite.inspect(self.pid, w.obj.max_address)
            if not value:
                value = 'Unable to inspect remote object. Make sure you have ' \
                        'the python-debuginfo package installed.'
            self.object_output.set_text(value)

    def get_object_buttons(self, group=[]):
        buttons = []
        for i, line in enumerate(str(self.summary).split('\n')):
            if i in (0, 1):
                rb = self.create_disabled_radio_button(line)
            else:
                obj = self.summary.summaries[i - 2]
                rb = self.create_radio_button(group, line, obj,
                                              self.display_object)
            buttons.append(rb)
        return buttons

    def setup_view(self):
        self.object_buttons = self.get_object_buttons()

        # Title
        self.bigtext = urwid.BigText('pyrasite ' + __version__, None)
        self.bigtext.set_font(urwid.Thin6x6Font())
        bt = urwid.Padding(self.bigtext, 'left', None)
        bt = urwid.AttrWrap(bt, 'bigtext')

        # Create the object outpu
        self.object_output = urwid.Text("", wrap='any')
        ca = urwid.AttrWrap(self.object_output, 'object_output')

        # Select the first object
        self.object_buttons[2].set_state(True)

        # ListBox
        obj_out = urwid.Pile([urwid.Divider(), ca])
        objects = urwid.Pile(self.object_buttons)
        l = [objects, obj_out]
        w = urwid.ListBox(urwid.SimpleListWalker(l))

        # Frame
        w = urwid.AttrWrap(w, 'body')
        w = urwid.Frame(header=bt, body=w)

        # Exit message
        exit = urwid.BigText(('exit', " Quit? "), urwid.Thin6x6Font())
        exit = urwid.Overlay(exit, w, 'center', None, 'middle', None)

        return w, exit

    def unhandled_input(self, key):
        if key in ('f8', 'q'):
            self.loop.widget = self.exit_view
            return True
        if self.loop.widget != self.exit_view:
            return
        if key in ('y', 'Y'):
            raise urwid.ExitMainLoop()
        if key in ('n', 'N'):
            self.loop.widget = self.view
            return True

    def main(self):
        self.view, self.exit_view = self.setup_view()
        self.loop = urwid.MainLoop(self.view, self.palette,
            unhandled_input=self.unhandled_input)
        self.loop.run()


def main():
    if len(sys.argv) != 2:
        print("[ pyrasite memory viewer ]\n")
        print("Usage: %s <pid> <objects.json>" % sys.argv[0])
        print("\n    pid - the running process id")
        print("")
        sys.exit(1)

    pid = int(sys.argv[1])
    payload = abspath(join(dirname(__file__), '..',
            'payloads', 'dump_memory.py'))
    pyrasite.inject(pid, payload)

    filename = '/tmp/pyrasite-%d-objects.json' % pid
    
    # Work around bug caused by meliae dumping unicode strings:
    # https://bugs.launchpad.net/meliae/+bug/876810
    with open(filename) as sample_file, open(filename + '.tmp', 'w') as output_file:
        pattern = re.compile(r"(?<!\\)\\u([dD][0-9a-fA-F]{3,3})")
        for line in sample_file:
            output_file.write(pattern.sub("#S\g<1>", line))
    os.rename(filename + '.tmp', filename)

    objects = loader.load(filename)
    objects.compute_referrers()

    PyrasiteMemoryViewer(pid=pid, objects=objects).main()


if '__main__' == __name__:
    main()

########NEW FILE########
__FILENAME__ = shell
# This file is part of pyrasite.
#
# pyrasite is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyrasite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyrasite.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2011-2013 Red Hat, Inc., Luke Macken <lmacken@redhat.com>

import sys
import pyrasite


def shell():
    """Open a Python shell in a running process"""

    usage = "Usage: pyrasite-shell <PID>"
    if not len(sys.argv) == 2:
        print(usage)
        sys.exit(1)
    try:
        pid = int(sys.argv[1])
    except ValueError:
        print(usage)
        sys.exit(1)

    ipc = pyrasite.PyrasiteIPC(pid, 'ReversePythonShell')
    ipc.connect()

    print("Pyrasite Shell %s" % pyrasite.__version__)
    print("Connected to '%s'" % ipc.title)

    prompt, payload = ipc.recv().split('\n', 1)
    print(payload)

    try:
        import readline
    except ImportError:
        pass

    # py3k compat
    try:
        input_ = raw_input
    except NameError:
        input_ = input

    try:
        while True:
            try:
                input_line = input_(prompt)
            except EOFError:
                input_line = 'exit()'
                print('')
            except KeyboardInterrupt:
                input_line = 'None'
                print('')

            ipc.send(input_line)
            payload = ipc.recv()
            if payload is None:
                break
            prompt, payload = payload.split('\n', 1)
            if payload != '':
                print(payload)
    except:
        print('')
        raise

    ipc.close()


if __name__ == '__main__':
    shell()

########NEW FILE########
__FILENAME__ = winbuild
from distutils import msvc9compiler
import subprocess
import os

def compile(filename, outputfilename, arch='x86', vcver=None):
    if vcver == None:
        if os.getenv('MSVCVER'):
            vcver = float(os.getenv('MSVCVER'))
        else:
            vcver = msvc9compiler.get_build_version()
    vcvars = msvc9compiler.find_vcvarsall(vcver)
    if not vcvars:  # My VS 2008 Standard Edition doesn't have vcvarsall.bat
        vsbase = msvc9compiler.VS_BASE % vcver
        productdir = msvc9compiler.Reg.get_value(r"%s\Setup\VC" % vsbase,
                                                 "productdir")
        bat = 'vcvars%d.bat' % (arch == 'x86' and 32 or 64)
        vcvars = os.path.join(productdir, 'bin',  bat)

    path = os.path.splitext(outputfilename)
    objfilename = path[0] + '.obj'
    p = subprocess.Popen('"%s" %s & cl %s /Fe%s /Fo%s' % (vcvars, arch, filename, outputfilename, objfilename),
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    try:
        stdout, stderr = p.communicate()
        if p.wait() != 0:
            raise Exception(stderr.decode("mbcs"))
        os.remove(objfilename)
    finally:
        p.stdout.close()
        p.stderr.close()

#try:
#    compile('inject_python.cpp', 'inject_python_32.exe', 'x86', 10.0)
#except:
#    pass
#try:
#    compile('inject_python.cpp', 'inject_python_64.exe', 'amd64', 10.0)
#except:
#    pass
########NEW FILE########
