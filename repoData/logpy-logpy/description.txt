LogPy's Types and Common Functions
----------------------------------

The design of LogPy/miniKanren is simple.  It manipulates only a few types with only a few important functions.

### Terms

Terms can be 

*   constants like `123` or `'cat'`
*   logical variables which we denote with a tilde like `~x`
*   tuples of terms like `(123, 'cat')` or `(~x, 1, (2, 3))`

In short, they are trees in which leaves may be either constants or variables.  Constants may be of any Python type.

### Unify

We *unify* two similar terms like `(1, 2)` and `(1, ~x)` to form a *substitution* `{~x: 2}`.  We say that `(1, 2)` and `(1, ~x)` unify under the substitution `{~x: 2}`.  Variables may assume the value of any term.

Unify is a function that takes two terms, `u` and `v`, and returns a substitution `s`.

Examples that unify

|       u           |       v           |        s          | 
|:-----------------:|:-----------------:|:-----------------:| 
| 123               | 123               | {}                |
| 'cat'             | 'cat'             | {}                |
| (1, 2)            | (1, 2)            | {}                |
| ~x                | 1                 | {~x: 1}           |
| 1                 | ~x                | {~x: 1}           |
| (1, ~x)           | (1, 2)            | {~x: 2}           |
| (1, 1)            | (~x, ~x)          | {~x: 1}           |
| (1, 2, ~x)        | (~y, 2, 3)        | {~x: 3, ~y: 1}    |

Examples that don't unify

|       u           |       v           |
|:-----------------:|:-----------------:|
| 123               | 'cat'             |
| (1, 2)            | 12                |
| (1, ~x)           | (2, 2)            |
| (1, 2)            | (~x, ~x)          |

Actually we lied, `unify` also takes a substitution as input.  This allows us to keep some history around.  For example

    >>> unify((1, 2), (1, x), {})  # normal case
    {~x: 2}
    >>> unify((1, 2), (1, x), {x: 2})  # x is already two. This is consitent
    {~x: 2}
    >>> unify((1, 2), (1, x), {x: 3})  # x is already three.  This conflicts
    False

### Reify

Reify is the opposite of unify.  `reify` transforms a term with logic variables like `(1, ~x)` and a substitution like `{~x: 2}` into a term without logic variables like `(1, 2)`.

    >>> reify((1, x), {x: 2})
    (1, 2)

### Goals and Goal Constructors

A *goal* is a function from one substitution to a stream of substitutions.  

    goal :: substitution -> [substitutions]

We make goals with a *goal constructors*.  Goal constructors are the normal building block of a logical program.  Lets look at the goal constructor `membero` which states that the first input must be a member of the second input (a collection).

    goal = membero(x, (1, 2, 3)

We can feed this goal a substitution and it will give us a stream of substitutions.  Here we'll feed it the substitution with no information and it will tell us that either `x` can be `1` or `x` can be `2` or `x` can be `3`

    >>> for s in goal({}):
    ...     print s
    {~x: 1}
    {~x: 2}
    {~x: 3}

What if we already know that `x` is `2`?

    >>> for s in goal({x: 2}):
    ...     print s
    {~x: 2}

Remember *goals* are functions from one substitution to a stream of substitutions.  Users usually make goals with *goal constructors* like `eq`, or `membero`.

### Goal Combinators

After this point LogPy is just a library to manage streams of substitutions.  

For example if we know both that `membero(x, (1, 2, 3))` and `membero(x, (2, 3, 4))` then we could do something like the following:

    >>> g1 = membero(x, (1, 2, 3))
    >>> g2 = membero(x, (2, 3, 4))
    >>> for s in g1({}):
    ...     for ss in g2(s):
    ...         print ss
    {~x: 2}
    {~x: 3}

Logic programs can have many goals in complex hierarchies.  Writing explicit for loops would quickly become tedious.  Instead we provide functions that conglomerate goals logically.  

    combinator :: [goals] -> goal

Two important logical goal combinators are logical all `lall` and logical any `lany`.

    >>> g = lall(g1, g2)
    >>> for s in g({}):
    ...     print s
    {~x: 2}
    {~x: 3}
    
    >>> g = lany(g1, g2)
    >>> for s in g({}):
    ...     print s
    {~x: 1}
    {~x: 2}
    {~x: 3}
    {~x: 4}


### Laziness

Goals produce a stream of substitutions.  This stream is computed lazily, returning values only as they are needed.  LogPy depends on standard Python generators to maintain the necessary state and control flow.

    >>> stream = g({})
    >>> stream
    <generator object unique at 0x2e13690>
    >>> next(stream)
    {~x: 1}


### User interface

Traditionally programs are run with the `run` function

    >>> x = var('x')
    >>> run(0, x, membero(x, (1, 2, 3)), membero(x, (2, 3, 4)))
    (2, 3)

`run` has an implicit `lall` for the goals at the end of the call.  It `reifies` results when it returns so that the user never has to touch logic variables or substitutions.

### Conclusion

These are all the fundamental concepts that exist in LogPy.  To summarize

*   Term: a constant, variable, or tree of terms
*   Substitution: a dictionary mapping variables to terms
*   Unify: A function to turn two terms into a substitution that makes them match
*   Goal: A function from a substitution to a stream of substitutions
*   Goal Constructor: A user-level function that defines a goal

Differences with miniKanren
===========================

LogPy is a Python library.  The Python language introduces some necessary deviations from the original design.  Other deviations have been followed by choice.  

Syntax
------

Basic LogPy syntax is as follows

    >>> x = var()
    >>> run(1, x, (eq, x, 2))

The first argument is the maximum number of desired results.  Select `0` for all values and `None` to receive a lazy iterator.

The second argument is the result variable.  Because Python does not support macros this variable must be created beforehand on the previous line.  Similarly there is no `fresh`; additional variables must be created ahead of time.

    >>> x, y = var(), var()
    >>> run(1, x, (eq, x, y), (eq, y, 2))

Evaluation of goals -- `eq(x, 2)` vs `(eq, x, 2)`
-------------------------------------------------

Traditional Python code is written `f(x)`.  Traditional Scheme code is written `(f, x)`.  LogPy uses both syntaxes but prefers `(f, x)` so that goals may be constructed at the last moment.  This allows the goals to be reified with as much information as possible.  Consider the following 

    >>> x, y = var(), var()
    >>> run(0, x, eq(y, (1, 2, 3)), membero(x, y)))

In this example `membero(x, y)` is unable to provide sensible results because, at the time it is run y is a variable.  However, if membero is called *after* `eq(y, (1, 2, 3))` then we know that `y == (1, 2, 3)`.  With this additional information `membero is more useful.  If we write this as follows

    >>> x, y = var(), var()
    >>> run(0, x, eq(y, (1, 2, 3)), (membero, x, y)))

then LogPy is able to evaluate the `membero` goal after it learns that `y == (1, 2, 3)`. 

In short, `goal(arg, arg)` is conceptually equivalent to `(goal, arg, arg)` but the latter gives more control to LogPy.

Strategies and goal ordering
----------------------------

Python does not naturally support the car/cdr or head/tail list concept.  As a result functions like `conso` or `appendo` are difficult to write generally because there is no way to match a head and tail variable to a list variable.  This is a substantial weakness.  

To overcome this weakness LogPy detects failed goals and reorders them at goal construction time.  This is evident in the following example

    >>> x, y = var(), var()
    >>> run(0, x, (membero, x, y), (eq, y, (1, 2, 3)))

`(membero, x, y)` does not produce sensible results when both `x` and `y` are variables.  When this goal is evaluated it raises an `EarlyGoalError`.  The LogPy logical all function (equivalent to `bind*`) is sensitive to this and reorders goals so that erring goals are run after non-erring goals.  The code is converted

    >>> run(0, x, (membero, x, y), (eq, y, (1, 2, 3)))  # original
    >>> run(0, x, (eq, y, (1, 2, 3)), (membero, x, y))  # optimized

`conde`
-------

`conde` is available and common in LogPy; it is not however related to
any idiomatic Python concept.  We separate `conde` into two functions

*   `lall` - Logical All
*   `lany` - Logical Any

As a result the following are equivalent and the first expands to the second

    (conde, (a, b, c), 
            (d, e))

    (lany, (lall, a, b, c),
           (lall, d, e))

`lany` and `lall` were roughly `mplus` and `bind*` in miniKanren.  `lany`
interleaves results rather than chain them.  `lall` reorders goals as mentioned
above.  There is some development to make these behaviors programmable through
strategies.

Documentation
=============

LogPy is very new.  Documentation is still very sparse.  Forunately the basic interface is shared with some more mature projects and so you may find looking at the following sources of use.

[core.logic](https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer) is a popular Clojure project with very similar syntax.

[The Reasoned Schemer](http://www.amazon.com/The-Reasoned-Schemer-Daniel-Friedman/dp/0262562146/) is a quick book on miniKanren, the original implementation in Scheme

LogPy
=====

[![](https://travis-ci.org/logpy/logpy.png)](https://travis-ci.org/logpy/logpy)

Logic Programming in Python

Examples
--------

LogPy enables the expression of relations and the search for values which satisfy them.  The following code is the "Hello, world!" of logic programming.  It asks for `1` number, `x`, such that `x == 5`

~~~~~~~~~~~Python
>>> from logpy import run, eq, membero, var, conde
>>> x = var()
>>> run(1, x, eq(x, 5))
(5,)
~~~~~~~~~~~

Multiple variables and multiple goals can be used simultaneously.  The
following code asks for a number x such that `x == z` and `z == 3`

~~~~~~~~~~~Python
>>> z = var()
>>> run(1, x, eq(x, z),
              eq(z, 3))
(3,)
~~~~~~~~~~~

LogPy uses [unification](http://en.wikipedia.org/wiki/Unification_%28computer_science%29), an advanced form of pattern matching, to match within expression trees.
The following code asks for a number, x, such that `(1, 2) == (1, x)` holds.

~~~~~~~~~~~Python
>>> run(1, x, eq((1, 2), (1, x)))
(2,)
~~~~~~~~~~~

The above examples use `eq`, a *goal constructor* to state that two expressions
are equal.  Other goal constructors exist such as `membero(item, coll)` which
states that `item` is a member of `coll`, a collection.

The following example uses `membero` twice to ask for 2 values of x,
such that x is a member of `(1, 2, 3)` and that x is a member of `(2, 3, 4)`.

~~~~~~~~~~~Python
>>> run(2, x, membero(x, (1, 2, 3)),  # x is a member of (1, 2, 3)
              membero(x, (2, 3, 4)))  # x is a member of (2, 3, 4)
(2, 3)
~~~~~~~~~~~

### Representing Knowledge

LogPy stores data as facts that state relationships between terms.

The following code creates a parent relationship and uses it to state
facts about who is a parent of whom within the Simpsons family.

~~~~~~~~~~~Python
>>> from logpy import Relation, facts
>>> parent = Relation()
>>> facts(parent, ("Homer", "Bart"),
...               ("Homer", "Lisa"),
...               ("Abe",  "Homer"))

>>> run(1, x, parent(x, "Bart"))
('Homer',)

>>> run(2, x, parent("Homer", x))
('Lisa', 'Bart')
~~~~~~~~~~~~

We can use intermediate variables for more complex queries.  Who is Bart's grandfather?

~~~~~~~~~~~Python
>>> y = var()
>>> run(1, x, parent(x, y),
              parent(y, 'Bart'))
('Abe',)
~~~~~~~~~~~~

We can express the grandfather relationship separately.  In this example we use `conde`, a goal constructor for logical *and* and *or*.

~~~~~~~~~~~Python
>>> def grandparent(x, z):
...     y = var()
...     return conde((parent(x, y), parent(y, z)))

>>> run(1, x, grandparent(x, 'Bart'))
('Abe,')
~~~~~~~~~~~~

Data Structures
---------------

LogPy depends on functions, tuples, dicts, and generators.  There are almost no new data structures/classes in LogPy so it should be simple to integrate into preexisting code.


Extending LogPy to other Types
------------------------------

LogPy uses [Multiple Dispatch](http://github.com/mrocklin/multipledispatch/) to
support pattern matching on user defined types.

~~~~~~~~~~~~Python
from logpy import unify, var
from logpy.dispatch import dispatch

class Account(object):
    def __init__(self, name, amount):
        self.name = name
        self.amount = amount
    def __str__(self):
        return "%s: $%d" % (self.name, self.account)


@dispatch(Account, Account, dict)
def _unify(u, v, s):
    """ Unify accounts by unifying a tuple of their type, name and amount """
    uu = (type(u), u.name, u.amount)
    vv = (type(v), v.name, v.amount)

    return unify(uu, vv, s)


>>> x = var('x')

>>> unify(Account('Alice', 100), Account(x, 100), {})
{x: 'Alice'}

>>> unify(Account('Alice', 100), Account(x, 200), {})
False
~~~~~~~~~~~~


Alternatively just decorate your classes with the `@unifiable` class decorator

~~~~~~~~~~~~Python
from logpy import unifiable

@unifiable
class Account(object):
    ...
~~~~~~~~~~~~


Install
-------

With `pip` or `easy_install`

    pip install logic

From source

    git clone git@github.com:logpy/logpy.git
    cd logpy
    python setup.py install

Run tests with nose

    nosetests --with-doctest

Dependencies
------------

``LogPy`` supports Python 2.6+ and Python 3.2+ with a common codebase.
It is pure Python and requires no dependencies beyond the standard
library, [`toolz`](http://github.com/pytoolz/toolz/) and
[`multipledispatch`](http://github.com/mrocklin/multipledispatch/).

It is, in short, a light weight dependency.

Author
------

[Matthew Rocklin](http://matthewrocklin.com)

License
-------

New BSD license. See LICENSE.txt

Motivation
----------

Logic programming is a general programming paradigm.  This implementation however came about specifically to serve as an algorithmic core for Computer Algebra Systems in Python and for the automated generation and optimization of numeric software.  Domain specific languages, code generation, and compilers have recently been a hot topic in the Scientific Python community.  LogPy aims to be a low-level core for these projects.

References
----------

*   [Logic Programming on wikipedia](http://en.wikipedia.org/wiki/Logic_programming)
*   [miniKanren](http://minikanren.org/), a Scheme library for relational programming on which this library is based.  More information can be found in the
[thesis of William
Byrd](https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf).
*   [core.logic](https://github.com/clojure/core.logic) a popular implementation of miniKanren in Clojure.

