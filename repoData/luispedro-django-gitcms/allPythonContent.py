__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-gitcms documentation build configuration file, created by
# sphinx-quickstart on Sat Jan 22 12:32:35 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
from gitcms import __version__ as gitcm_version

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode'
    ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-gitcms'
copyright = u'2011, Luis Pedro Coelho'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = gitcm_version
# The full version, including alpha/beta/rc tags.
release = gitcm_version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-gitcmsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-gitcms.tex', u'django-gitcms Documentation',
   u'Luis Pedro Coelho', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-gitcms', u'django-gitcms Documentation',
     [u'Luis Pedro Coelho'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'django-gitcms'
epub_author = u'Luis Pedro Coelho'
epub_publisher = u'Luis Pedro Coelho'
epub_copyright = u'2011, Luis Pedro Coelho'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os

_BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)
APPEND_SLASH = True

MANAGERS = ADMINS

DATABASES = {
    'default' : {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': _BASE_DIR + '/example.db',
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = False

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = _BASE_DIR + '/media/'
MEDIA_URL = '/media/'

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin-media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'js-ep$t(8js4lekq=p)hi@x7sh8_$ogpkl53qeg6p2$@a%qzx@'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
    'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.doc.XViewMiddleware',
    'django.middleware.cache.CacheMiddleware',
    'gitcms.redirect.middleware.RedirectMiddleware',
)

ROOT_URLCONF = 'urls'

TEMPLATE_DIRS = (
    # Don't forget to use absolute paths, not relative paths.
    _BASE_DIR + '/templates',
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.markup',

    'gitcms.tagging',
    'gitcms.pages',
    'gitcms.menus',
    'gitcms.blog',
    'gitcms.books',
    'gitcms.conferences',
    'gitcms.files',
    'gitcms.publications',
    'gitcms.redirect',
)


GITDJANGO_DIRNAME = './content'
DISQUS_SHORTNAME='testing'

########NEW FILE########
__FILENAME__ = urls
import settings
from django.conf.urls.defaults import *
from django.contrib import admin
import gitcms.pages.urls
import gitcms.files.urls
import gitcms.blog.urls
admin.autodiscover()

urlpatterns = patterns('',
    (r'^media/(?P<path>.+)$', 'django.views.static.serve', {'document_root': settings._BASE_DIR + '/media'}),
    (r'^admin/', include(admin.site.urls)),
    (r'^blog/?', include(gitcms.blog.urls)),
)
urlpatterns += gitcms.files.urls.urlpatterns
urlpatterns += gitcms.pages.urls.urlpatterns


########NEW FILE########
__FILENAME__ = admin
from models import BlogPost
from django.contrib import admin

admin.site.register(BlogPost)

########NEW FILE########
__FILENAME__ = feeds
from django.contrib.syndication.views import Feed
from gitcms.blog.models import BlogPost
from django.conf import settings


class LatestFeed(Feed):
    title = getattr(settings, 'GITCMS_BLOG_FEED_NAME', 'Blog RSS channel')
    link = '/rss/'
    description = 'Updates on blog and items of interesting content'

    def items(self):
        limit = getattr(settings, 'LIMIT_RSS_ITEMS', 20)
        return BlogPost.objects.exclude(status='draft').order_by('-timestamp')[:limit]

    def item_title(self, post):
        return post.title

    def item_description(self, post):
        return post.content

    def item_link(self, post):
        return post.get_absolute_url()

########NEW FILE########
__FILENAME__ = load
from models import BlogPost
from os import path, listdir
import yaml
import time
from docutils.core import publish_parts
from django.utils.encoding import smart_str, force_unicode
from django.utils.safestring import mark_safe

from gitcms.parsedate import parsedatetime
from gitcms.pages.load import preprocess_rst_content
from gitcms.tagging.models import tag_for


def loaddir(directory, clear=False):
    if clear:
        BlogPost.objects.all().delete()

    queue = listdir(directory)
    while queue:
        next = queue.pop()
        if next[0] == '.': continue
        if next in ('template.rst', 'template'): continue
        next = path.join(directory, next)
        if path.isdir(next):
            queue.extend([
                path.join(next,f) for f in listdir(next)
                ])
            continue

        filecontent = file(next).read()
        parts = filecontent.split('\n---\n', 1)
        if len(parts) != 2:
            raise IOError('gitcms.blog.load: expected "---" separator in file %s' % next)
        fields, content = parts
        fields = yaml.load(fields)
        fields['content'] = preprocess_rst_content(content)
        fields['timestamp'] = parsedatetime(fields['timestamp'])
        fields['timestamp'] = time.strftime('%Y-%m-%d %H:%M', fields['timestamp'])
        categories = fields.get('categories', '')
        if 'categories' in fields: del fields['categories']
        ptags = []
        if categories:
            for c in categories.split():
                ptags.append(tag_for(c))
        # if we arrived here and no errors, then it is safe
        # to add our post.
        #
        P = BlogPost(**fields)
        P.save()
        for t in ptags:
            P.tags.add(t)

dependencies = ['tagging']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as tr
from gitcms.tagging.models import Tag


class BlogPost(models.Model):
    title = models.CharField(u'title', max_length=255)
    slug = models.CharField(u'slug', max_length=255)
    timestamp = models.DateTimeField(u'timestamp')
    tags = models.ManyToManyField(Tag)
    content = models.TextField(u'content')
    status = models.CharField(u'status', max_length=255)
    author = models.CharField(u'author', max_length=255)
    keywords = models.CharField(u'keywords', max_length=255)
    description = models.CharField(u'description', max_length=255)

    def __unicode__(self):
        return '%s (%s)' % (self.slug, self.title)

    @models.permalink
    def get_absolute_url(self):
        return ('blog-post', [self.timestamp.year, self.timestamp.month, self.slug])

########NEW FILE########
__FILENAME__ = disqus
from django import template
import settings

register = template.Library()

if hasattr(settings,'DISQUS_SHORTNAME'):
    @register.inclusion_tag('blog/disqus.html')
    def disqus_thread(post):
        return {
            'disqus_shortname' : settings.DISQUS_SHORTNAME,
            'unique_identifier' : post.slug,
        }
else:
    @register.simple_tag
    def disqus_thread(_):
        return ''
            
    

########NEW FILE########
__FILENAME__ = test_load
import gitcms.blog.load
from gitcms.blog.models import BlogPost
from os.path import dirname

_basedir = dirname(__file__)
def test_simple_load():
    gitcms.blog.load.loaddir(_basedir + '/data/')
    assert len(BlogPost.objects.all()) == 1


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import views
import feeds


urlpatterns = patterns('',
    url(r'^tag/(?P<tag>.*)/', views.bytag, name='blog-tag'),
    url(r'^(?P<year>[0-9]+)/(?P<month>[0-9]+)/(?P<slug>[^/]*)/', views.post, name='blog-post'),
    url(r'^feed/', feeds.LatestFeed(), name='blog-feed'),
    url(r'^/?$', views.mostrecent, name='blog'),
)

########NEW FILE########
__FILENAME__ = views
from gitcms.tagging.models import Tag
from django.template import RequestContext
from django.shortcuts import get_object_or_404, render_to_response
from gitcms.blog.models import BlogPost


def bytag(request, tag):
    tag = get_object_or_404(Tag, slug=tag)
    posts = BlogPost.objects.exclude(status='draft').filter(tags=tag).order_by('-timestamp')
    return render_to_response(
                'blog/tag_list.html',
                RequestContext(request, {
                    'tag' : tag,
                    'posts' : posts,
                }))

def post(request, year, month, slug):
    post = get_object_or_404(BlogPost, slug=slug)
    return render_to_response(
                'blog/post.html',
                RequestContext(request, {
                    'post' : post,
                }))

def mostrecent(request):
    posts = BlogPost.objects.exclude(status='draft').order_by('-timestamp')
    return render_to_response(
                'blog/list.html',
                RequestContext(request, {
                    'title' : 'New posts',
                    'pagetitle' : 'Latest posts',
                    'posts' : posts,
                }))

########NEW FILE########
__FILENAME__ = load
from models import Book
import os
from os import path
import yaml
import time

from gitcms.parsedate import parsedate
from gitcms.pages.load import preprocess_rst_content
from gitcms.tagging.models import tag_for

def loaddir(directory, clear=False):
    if clear:
        Book.objects.all().delete()

    queue = os.listdir(directory)
    while queue:
        next = queue.pop()
        if next[0] == '.': continue
        if next in ('categories', 'template'): continue
        next = path.join(directory, next)
        if path.isdir(next):
            queue.extend([
                path.join(next,f) for f in os.listdir(next)
                ])
            continue

        filecontent = file(next).read()
        header, content = filecontent.split('\n---\n')
        header = yaml.load(header)
        content = preprocess_rst_content(content)
        review_date = parsedate(header['review_date'])
        review_date = time.strftime('%Y-%m-%d', review_date)
        btags = []
        for c in header.get('tags','').split():
            btags.append(tag_for(c))
        B = Book(slug=header['slug'], title=header['title'], booktitle=header['booktitle'], author=header['author'], content=content, review_date=review_date)
        B.save()
        for t in btags:
            B.tags.add(t)

dependencies = ['tagging']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as tr
from gitcms.tagging.models import Tag

class Book(models.Model):
    slug = models.SlugField(u'slug')
    title = models.CharField(u'title', max_length=255)
    booktitle = models.CharField(u'title', max_length=255)
    author = models.CharField(u'author', max_length=255)
    tags = models.ManyToManyField(Tag)
    content = models.TextField(u'content')
    review_date = models.DateField(u'ReviewDate')

    def __unicode__(self):
        return '<book review: %s>' % self.title
    class Meta:
        verbose_name_plural = tr(u'Books')


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import views

urlpatterns = patterns('',
    url(r'^(?P<url>.*)/?', views.book, name='books'),
)

########NEW FILE########
__FILENAME__ = views
from .models import Book
from django.shortcuts import get_object_or_404, render_to_response

def book(request, slug):
    book = get_object_or_404(Book, slug=slug)
    return render_to_response(
                'books/book.html',
                {
                    'book' : book,
                })

########NEW FILE########
__FILENAME__ = load
import datetime
import yaml
import os
from .models import Conference

_months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
    ]

def _parsedate(s):
    month, day, year = s.strip().split()
    month_idx = None
    day = int(day)
    year = int(year)
    for i,m in enumerate(_months):
        if m.startswith(month):
            if month_idx is not None:
                raise IOError('Month %s is ambiguous' % month)
            month_idx = i
    if month_idx is None:
        raise IOError("Could not parse month '%s'" % month)
    return datetime.date(year, month_idx + 1, day)


def loaddir(directory, clear=False):
    if clear:
        Conference.objects.all().delete()
    for conffile in os.listdir(directory):
        if conffile[0] == '.': continue
        for conf in yaml.load_all(file(directory + '/' + conffile)):
            for dfield in ('start', 'end', 'submission_deadline'):
                conf[dfield] = _parsedate(conf[dfield])
            C = Conference(**conf)
            C.save()

########NEW FILE########
__FILENAME__ = models
from django.db import models

class Conference(models.Model):
    name = models.CharField(u'Name', max_length=255)
    short_name = models.CharField(u'Short Name', max_length=255)
    location = models.CharField(u'Location', max_length=255)
    start = models.DateField(u'Start')
    end = models.DateField(u'End')
    submission_deadline = models.DateField(u'Submission Deadline', blank=True, null=True)
    url = models.URLField(u'URL', blank=True, null=True)
    comment = models.TextField(u'Comment')
    def __unicode__(self):
        return self.name

    def summary(self):
        return '%s (%s)' % (self.name, self.short_name)


########NEW FILE########
__FILENAME__ = test_load
import gitcms.conferences.load
from gitcms.conferences.models import Conference
from os.path import dirname
_basedir = dirname(__file__)

def test_load():
    gitcms.conferences.load.loaddir(_basedir + '/data/', clear=True)
    assert len(Conference.objects.all()) == 1


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import views

urlpatterns = patterns('',
    url(r'^conferences/?$', views.upcoming, name='conferences-index'),
    url(r'^conferences/upcoming/?$', views.upcoming, name='conferences-upcoming'),
    url(r'^conferences/upcoming/ical', views.upcomingical, name='conferences-ical'),
    url(r'^conferences/upcoming-submissions', views.upcoming_submissions, name='conferences-submissions'),
)

########NEW FILE########
__FILENAME__ = views
from .models import Conference
import datetime
from django.shortcuts import get_object_or_404, render_to_response
from django.http import HttpResponse

def upcoming(request):
    conferences = Conference.objects.filter(start__gte=datetime.datetime.now()).order_by('start')
    return render_to_response(
                'conferences/list.html',
                {
                    'conferences' : conferences,
                })

def upcoming_submissions(request):
    conferences = Conference.objects.filter(submission_deadline__gte=datetime.datetime.now()).order_by('submission_deadline')
    return render_to_response(
                'conferences/list.html',
                {
                    'conferences' : conferences,
                })

def upcomingical(request):
    '''
    upcomingical(request)

    Returns the calendar of conferences as an ical file.
    '''
    try:
        import vobject
    except ImportError:
        return HttpResponse('import vobject failed in confereces/views.py:upcomingical')
    def _add_event(summary, start, end=None):
        if end is None:
            end = start
        rep = cal.add('vevent')
        rep.add('summary').value = summary
        rep.add('dtstart').value = start
        rep.add('dtend').value = end
    events = Conference.objects.filter(start__gte=datetime.datetime.now()).order_by('start')
    cal = vobject.iCalendar()
    for ev in events:
        _add_event(summary=ev.summary(), start=ev.start, end=ev.end)
        if ev.submission_deadline:
            _add_event(summary=('%s deadline' % ev.short_name), start=ev.submission_deadline)
            _add_event(summary=('%s deadline in 21 days' % ev.short_name), start=(ev.submission_deadline - datetime.timedelta(days=21)))
    response = HttpResponse(cal.serialize())
    response['Content-Type'] = 'text/calendar'
    return response

########NEW FILE########
__FILENAME__ = load
import os
import shutil
from django.conf import settings


_defaultfilesdir = 'media/files'
_filesdir = getattr(settings, 'DJANGO_GITCMS_FILES', _defaultfilesdir)

def loaddir(directory, clear=False):
    if os.path.exists(_filesdir): shutil.rmtree(_filesdir)
    shutil.copytree(directory, _filesdir)


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import settings

urlpatterns = patterns('',
    url(r'^files/(?P<path>.+)$', 'django.views.static.serve',
        {'document_root': settings.MEDIA_ROOT + '/files'},
        name='files'),
)


########NEW FILE########
__FILENAME__ = gitcms_version
__version__ = '0.4'

########NEW FILE########
__FILENAME__ = load
from models import Menu, MenuItem
import os
from os import path
import yaml

def loaddir(directory, clear=False):
    if clear:
        MenuItem.objects.all().delete()
        Menu.objects.all().delete()
    def _parse_children(parent, parent_obj):
        if 'children' not in parent:
            return
        for ch in parent['children']:
            child = MenuItem(name=ch['name'], url=ch['url'], title=ch.get('title', None), parent=parent_obj)
            child.save()
            _parse_children(ch, child)
    for menufile in os.listdir(directory):
        if menufile[0] == '.': continue
        for menu in yaml.load_all(file(path.join(directory,menufile))):
            fake_root = MenuItem(name='<fake-root>', url='fake-root-you-shouldnt-be-seeing-this-bro')
            fake_root.save()
            menu_obj = Menu(name=menu['name'], fake_root=fake_root)
            menu_obj.save()
            _parse_children(menu, fake_root)


########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext as tr

class MenuItem(models.Model):
    name = models.CharField(tr('Name'), max_length=255)
    title = models.CharField(tr('Title'), max_length=255, null=True)
    url = models.CharField(tr('url'), max_length=255)
    parent = models.ForeignKey('self', related_name='children', null=True)

class Menu(models.Model):
    name = models.CharField(tr('Name'), max_length=255)
    fake_root = models.ForeignKey(MenuItem)
    def _get_children(self):
        return self.fake_root.children.all()
    children = property(_get_children)


########NEW FILE########
__FILENAME__ = menus_tags
from django import template
register = template.Library()

from gitcms.menus.models import Menu

@register.inclusion_tag('menus/menu.html')
def show_menu(menu_name):
    menu = Menu.objects.get(name=menu_name)
    return { 'items' : menu.children }

@register.inclusion_tag('menus/tabs.html')
def show_tabs(menu_name):
    menu = Menu.objects.get(name=menu_name)
    items = menu.children
    for it in items:
        it.active = False
    return { 'items' : items }

########NEW FILE########
__FILENAME__ = test_load
import gitcms.menus.load
from gitcms.menus.models import Menu, MenuItem
from os.path import dirname

_basedir = dirname(__file__)
def test_simple_load():
    gitcms.menus.load.loaddir(_basedir + '/data/') 
    assert len(Menu.objects.all())
    assert len(MenuItem.objects.all())
    menu = Menu.objects.all()[0]
    assert len(menu.children) == 1
    assert len(menu.children[0].children.all()) == 2

########NEW FILE########
__FILENAME__ = views

########NEW FILE########
__FILENAME__ = admin
from models import Article
from django.contrib import admin
admin.site.register(Article)

########NEW FILE########
__FILENAME__ = load
from models import Article
import os
from os import path
import yaml
from django.conf import settings
from gitcms.tagging.models import tag_for
from .rest import preprocess_rst_content

def loaddir(directory, clear=False):
    if clear:
        Article.objects.all().delete()

    queue = os.listdir(directory)
    urls = set()
    while queue:
        artfile = queue.pop()
        if artfile[0] == '.': continue
        if artfile in ('template', 'template.rst', 'template.txt'): continue
        artfile = path.join(directory, artfile)
        if path.isdir(artfile):
            queue.extend([
                path.join(artfile,f) for f in os.listdir(artfile)
                ])
            continue

        input = file(artfile)
        header = {}
        linenr = 0
        while True:
            line = input.readline().strip()
            linenr += 1
            if line in ('---', '..'): break
            if line.find(':') < 0:
                raise IOError('gitcms.pages.load: In file %s, line %s. No \':\' found!' % (artfile, linenr))
            tag,value = line.split(':',1)
            value = value.strip()
            header[tag] = value
        blank = input.readline()
        linenr += 1
        if blank.strip():
            raise IOError, 'Blank line expected while processing file (%s:%s)\nGot "%s"' % (artfile, linenr,blank)
        content = input.read()
        content = preprocess_rst_content(content)

        url = header['url']
        if url and url[-1] == '/':
            import warnings
            warnings.warn('''\
gitcms.pages.loaddir: Removing / at end of url (%s)

(Both versions will work for accessing the page.)
''' % url)
            url = url[:-1]

        if url and url[0] == '/':
            import warnings
            warnings.warn('gitcms.pages.loaddir: Removing / at start of url ({0})'
                        .format(url))
            url = url[1:]

        if url in urls:
            raise IOError('gitcms.pages.loaddir: repeated URL detected (%s)' % url)

        taglist = []
        for c in header.get('categories','').split():
            taglist.append(tag_for(c))
        # if we got so far, implies that our article is safe to store.
        urls.add(url)
        A = Article(title=header['title'], url=url, meta=header.get('meta', ''), author=header.get('author', ''), content=content)
        A.save()
        for c in taglist:
            A.tags.add(c)

dependencies = ['tagging']


########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as tr
from gitcms.tagging.models import Tag

class Article(models.Model):
    title = models.CharField(u'title', max_length=255)
    url = models.CharField(u'url', max_length=255)
    meta = models.TextField(u'meta')
    author = models.TextField(u'author', max_length=255)
    tags = models.ManyToManyField(Tag)
    content = models.TextField(u'content')
    def __unicode__(self):
        return '%s (%s)' % (self.title, self.url)

########NEW FILE########
__FILENAME__ = rest

# Copyright 2009-2010 Luis Pedro Coelho <luis@luispedro.org>
# Part of django-gitcms
# LICENSE: Affero GPL v3

from docutils.core import publish_parts

from django.conf import settings
from django.utils.encoding import smart_str, force_unicode
from django.utils.safestring import mark_safe

from . import sourcecode_directive

_precontent = '''\
**********
Fake Title
**********
+++++++++++++
Fake Subtitle
+++++++++++++

'''


def preprocess_rst_content(value):
    # This is adapted from django source
    value = _precontent + value
    docutils_settings = getattr(settings, "RESTRUCTUREDTEXT_FILTER_SETTINGS", {})
    parts = publish_parts(source=smart_str(value), writer_name="html4css1", settings_overrides=docutils_settings)
    return mark_safe(force_unicode(parts["fragment"]))


########NEW FILE########
__FILENAME__ = sourcecode_directive
# -*- coding: utf-8 -*-
"""
    The Pygments reStructuredText directive
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This fragment is a Docutils_ 0.5 directive that renders source code
    (to HTML only, currently) via Pygments.

    To use it, adjust the options below and copy the code into a module
    that you import on initialization.  The code then automatically
    registers a ``sourcecode`` directive that you can use instead of
    normal code blocks like this::

        .. sourcecode:: python

            My code goes here.

    If you want to have different code styles, e.g. one with line numbers
    and one without, add formatters with their names in the VARIANTS dict
    below.  You can invoke them instead of the DEFAULT one by using a
    directive option::

        .. sourcecode:: python
            :linenos:

            My code goes here.

    Look at the `directive documentation`_ to get all the gory details.

    .. _Docutils: http://docutils.sf.net/
    .. _directive documentation:
       http://docutils.sourceforge.net/docs/howto/rst-directives.html

    :copyright: Copyright 2006-2010 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.
"""

# Options
# ~~~~~~~

# Set to True if you want inline CSS styles instead of classes
INLINESTYLES = False

from pygments.formatters import HtmlFormatter

# The default formatter
DEFAULT = HtmlFormatter(noclasses=INLINESTYLES)

# Add name -> formatter pairs for every variant you want to use
VARIANTS = {
    # 'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),
}


from docutils import nodes
from docutils.parsers.rst import directives, Directive

from pygments import highlight
from pygments.lexers import get_lexer_by_name, TextLexer

class Pygments(Directive):
    """ Source code syntax hightlighting.
    """
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True
    option_spec = dict([(key, directives.flag) for key in VARIANTS])
    has_content = True

    def run(self):
        self.assert_has_content()
        try:
            lexer = get_lexer_by_name(self.arguments[0])
        except ValueError:
            # no lexer found - use the text one instead of an exception
            lexer = TextLexer()
        # take an arbitrary option if more than one is given
        formatter = self.options and VARIANTS[self.options.keys()[0]] or DEFAULT
        parsed = highlight(u'\n'.join(self.content), lexer, formatter)
        return [nodes.raw('', parsed, format='html')]

directives.register_directive('sourcecode', Pygments)


########NEW FILE########
__FILENAME__ = test_load
import gitcms.pages.load
from gitcms.pages.models import Article
from os.path import dirname 

_basedir = dirname(__file__)
def test_simple_load():
    gitcms.pages.load.loaddir(_basedir + '/data/')
    assert len(Article.objects.all()) == 1


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import views

urlpatterns = patterns('',
    url(r'^tag/(?P<tag>.*)/?', views.bytag, name='simplecms-tag'),
    url(r'^(?P<url>.*)/?', views.article, name='simplecms'),
)

########NEW FILE########
__FILENAME__ = views
from gitcms.tagging.models import Tag
from gitcms.pages.models import Article
from django.shortcuts import get_object_or_404, render_to_response

def bytag(request, tag):
    tag = get_object_or_404(Tag, slug=tag)
    articles = Article.objects.filter(tags=tag)
    return render_to_response(
                'pages/list.html',
                {
                    'pagetitle' : ('Articles tagged %s' % tag.name),
                    'articles' : articles,
                })

def article(request, url):
    if len(url) and url[-1] == '/': url = url[:-1]
    article = get_object_or_404(Article, url=url)
    return render_to_response(
                'pages/article.html',
                {
                    'article' : article,
                })

########NEW FILE########
__FILENAME__ = parsedate
import time

__all__ = [
    'parsedate',
    'parsedatetime',
    ]

def _tryformats(rep, formats, erromsg):
    for f in formats:
        try:
            return time.strptime(rep, f)
        except:
            pass
    raise ValueError(erromsg)


def parsedate(daterep):
    '''
    time = parsedate(daterep)
 
    Parses a date written out in English.
    '''
    return _tryformats(daterep,
            ['%d %b %Y', '%d %B %Y', '%b %d %Y', '%B %d %Y'],
            "Cannot parse '%s' as a date" % daterep)

def parsedatetime(datetimerep):
    '''
    time = parsedatetime(daterep)

    Parses a datetime written out in English.
    '''
    return _tryformats(datetimerep,
            ['%d %b %Y %H:%M', '%d %B %Y %H:%M', '%b %d %Y %H:%M', '%B %d %Y %H:%M'],
            "Cannot parse '%s' as a datetime" % datetimerep)

    

########NEW FILE########
__FILENAME__ = tests
import parsedate
def test_parsedate():
    assert parsedate.parsedate('4 April 2010') == parsedate.parsedate('April 4 2010')
    assert parsedate.parsedatetime('4 April 2010 19:02') == parsedate.parsedatetime('April 4 2010 19:02')


########NEW FILE########
__FILENAME__ = load
import os
from os import path
import shutil
from poster.encode import multipart_encode
from poster.streaminghttp import register_openers
from django.conf import settings
import urllib2
import errno
register_openers()

_bibfilesdir = path.join(getattr(settings, 'MEDIA_ROOT',''), 'bibtex')
_jsfilesdir =  path.join(getattr(settings, 'MEDIA_ROOT',''), 'bibtex-json')

def _bibtex2json(bibtexfname):
    datagen, headers = multipart_encode({'file': file(bibtexfname) })
    request = urllib2.Request("http://simile.mit.edu/babel/translator?reader=bibtex&writer=bibtex-exhibit-json", datagen, headers)
    ans = urllib2.urlopen(request)
    if ans.getcode() != 200:
        raise IOError, 'publications.load: simile remote call failed'
    return ans.read()

def _maybemkdir(dirname):
    try:
        os.mkdir(dirname)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise

def loaddir(directory, clear=False):
    if clear:
        if path.exists(_bibfilesdir):
            shutil.rmtree(_bibfilesdir)
        if path.exists(_jsfilesdir):
            shutil.rmtree(_jsfilesdir)
    _maybemkdir(_bibfilesdir)
    _maybemkdir(_jsfilesdir)
    for bibfile in os.listdir(directory):
        if bibfile[0] == '.':
            continue
        if not bibfile.endswith('.bib'):
            raise ValueError, "publications: Don't know what to do with '%s'" % bibfile
        shutil.copy(path.join(directory, bibfile), _bibfilesdir)
        jsonfile = path.join(_jsfilesdir, bibfile[:-len('.bib')] + '.json')
        jsonfile = file(jsonfile, 'w')
        jsonfile.write(_bibtex2json(path.join(directory,bibfile)))
        jsonfile.close()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import settings
import views


urlpatterns = patterns('',
    url(r'^papers/(?P<paper>.+)$', views.papers, name='publications-paper'),
    url(r'^publications/?$', views.publications, {'collection' : 'luispedro'}, name='publications'),
    url(r'^publications/(?P<collection>.+)$', views.publications, name='publications-collection'),
    url(r'^publications/files/(?P<file>.+)$', 'django.views.static.serve',
        {'document_root': settings.MEDIA_ROOT + '/publications/files'}, name='publications-files'),
)

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render_to_response
from django.http import HttpResponseRedirect


def publications(request, collection):
    if collection == '__history__.html':
        return render_to_response(
            'publications/history.html',
            {
            })
    return render_to_response(
                'publications/publications.html',
                {
                    'collection' : collection,
                })


def papers(request, paper):
    if paper == '':
        return HttpResponseRedirect('/publications/')
    return HttpResponseRedirect('/media/' + paper)

########NEW FILE########
__FILENAME__ = load
import yaml
import os
from .models import Redirect

def loaddir(directory, clear=False):
    if clear:
       Redirect.objects.all().delete()
    for redfile in os.listdir(directory):
        if redfile[0] == '.': continue
        for redirect in yaml.load_all(file(directory + '/' + redfile)):
            R = Redirect(**redirect)
            R.save()

########NEW FILE########
__FILENAME__ = middleware
from django.http import HttpResponsePermanentRedirect
from .models import Redirect

class RedirectMiddleware(object):
    '''
    '''
    def process_request(self, request):
        path = request.path
        if path[0] == '/': path = path[1:]
        redirect = Redirect.objects.filter(source=path)
        if not redirect:
            return None
        return HttpResponsePermanentRedirect('/'+redirect[0].target)

########NEW FILE########
__FILENAME__ = models
from django.db import models

class Redirect(models.Model):
    source = models.CharField(u'source', max_length=255)
    target = models.CharField(u'target', max_length=255)
    def __unicode__(self):
        return 'Redirect[ %s ==> %s ]' % (self.source, self.target)

########NEW FILE########
__FILENAME__ = admin
from models import Tag
from django.contrib import admin
admin.site.register(Tag)

########NEW FILE########
__FILENAME__ = load
from models import Tag
import yaml

def loaddir(directory, clear=False):
    if clear:
        Tag.objects.all().delete()
    for cat in yaml.load(file(directory + '/tags')):
        C = Tag(name=cat['name'], slug=cat['slug'])
        C.save()

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as tr

class Tag(models.Model):
    name = models.CharField(u'tag', max_length=255)
    slug = models.SlugField(u'slug')
    def __unicode__(self):
        return self.slug
    class Meta:
        verbose_name_plural = tr(u'Tags')

def tag_for(slug):
    '''
    tag = tag_for(slug)

    Returns the Tag object corresponding to slug

    Raises an exception if not found.
    '''
    tags = Tag.objects.filter(slug=slug).all()
    if len(tags) == 1:
        return tags[0]
    if not tags:
        raise ValueError("gitcms.tagging.tag_for: No tag for slug '%s'" % slug)
    raise ValueError("gitcms.tagging.tag_for: Multiple tags for slug '%s' (%s)" % (slug, [t.name for t in tags]))


########NEW FILE########
__FILENAME__ = testsettings
DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = ''

INSTALLED_APPS = (
    'django_nose',
    'gitcms.pages',
    'gitcms.blog',
    'gitcms.conferences',
    'gitcms.publications',
    'gitcms.redirect',
    'gitcms.menus',
    'gitcms.tagging',
    )

TEST_RUNNER = 'django_nose.run_tests'
    

########NEW FILE########
