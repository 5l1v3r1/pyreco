__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Migen documentation build configuration file, created by
# sphinx-quickstart on Fri Mar  9 14:11:54 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
	'sphinx.ext.pngmath',
	'sphinx.ext.autodoc',
	'sphinx.ext.doctest',
	'sphinx.ext.autosummary',
	'numpydoc',  # to preprocess docstrings
	]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Migen'
copyright = u'2012, Sebastien Bourdeauducq'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = 'X'
# The full version, including alpha/beta/rc tags.
release = 'X'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
modindex_common_prefix = ['migen.', 'mibuild.']

numpydoc_show_class_members = False

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Migendoc'

html_use_modindex = False

# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Migen.tex', u'Migen manual',
   u'Sebastien Bourdeauducq', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
latex_logo = "migen_logo.png"

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
latex_preamble = '\setcounter{tocdepth}{3}'

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True

latex_use_modindex = False

# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'migen', u'Migen manual',
     [u'Sebastien Bourdeauducq'], 1)
]

########NEW FILE########
__FILENAME__ = arrays
from migen.fhdl.std import *
from migen.fhdl import verilog

class Example(Module):
	def __init__(self):
		dx = 2
		dy = 2

		x = Signal(max=dx)
		y = Signal(max=dy)
		out = Signal()

		my_2d_array = Array(Array(Signal() for a in range(dx)) for b in range(dy))
		self.comb += out.eq(my_2d_array[x][y])

		we = Signal()
		inp = Signal()
		self.sync += If(we,
				my_2d_array[x][y].eq(inp)
			)

		ina = Array(Signal() for a in range(dx))
		outa = Array(Signal() for a in range(dy))
		self.specials += Instance("test", o_O=outa[y], i_I=ina[x])

print(verilog.convert(Example()))

########NEW FILE########
__FILENAME__ = complex
from migen.fhdl.std import *
from migen.genlib.complex import *
from migen.fhdl import verilog

class Example(Module):
	def __init__(self):
		w = Complex(32, 42)
		A = SignalC(16)
		B = SignalC(16)
		Bw = SignalC(16)
		C = SignalC(16)
		D = SignalC(16)
		self.comb += Bw.eq(B*w)
		self.sync += [
			C.eq(A + Bw),
			D.eq(A - Bw)
		]

print(verilog.convert(Example()))

########NEW FILE########
__FILENAME__ = fsm
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.fsm import FSM, NextState

class Example(Module):
	def __init__(self):
		self.s = Signal()
		myfsm = FSM()
		self.submodules += myfsm
		myfsm.act("FOO", self.s.eq(1), NextState("BAR"))
		myfsm.act("BAR", self.s.eq(0), NextState("FOO"))
		self.be = myfsm.before_entering("FOO")
		self.ae = myfsm.after_entering("FOO")
		self.bl = myfsm.before_leaving("FOO")
		self.al = myfsm.after_leaving("FOO")

example = Example()
print(verilog.convert(example, {example.s, example.be, example.ae, example.bl, example.al}))

########NEW FILE########
__FILENAME__ = graycounter
from random import Random

from migen.fhdl.std import *
from migen.genlib.cdc import GrayCounter
from migen.sim.generic import run_simulation

class TB(Module):
	def __init__(self, width=3):
		self.width = width
		self.submodules.gc = GrayCounter(self.width)
		self.prng = Random(7345)

	def do_simulation(self, selfp):
		print("{0:0{1}b} CE={2} bin={3}".format(selfp.gc.q,
			self.width, selfp.gc.ce, selfp.gc.q_binary))
		selfp.gc.ce = self.prng.getrandbits(1)

if __name__ == "__main__":
	run_simulation(TB(), ncycles=35)

########NEW FILE########
__FILENAME__ = local_cd
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.divider import Divider

class CDM(Module):
	def __init__(self):
		self.submodules.divider = Divider(5)
		self.clock_domains.cd_sys = ClockDomain(reset_less=True)

class MultiMod(Module):
	def __init__(self):
		self.submodules.foo = CDM()
		self.submodules.bar = CDM()

mm = MultiMod()
print(verilog.convert(mm, {mm.foo.cd_sys.clk, mm.bar.cd_sys.clk}))

########NEW FILE########
__FILENAME__ = memory
from migen.fhdl.std import *
from migen.fhdl import verilog

class Example(Module):
	def __init__(self):
		self.specials.mem = Memory(32, 100, init=[5, 18, 32])
		p1 = self.mem.get_port(write_capable=True, we_granularity=8)
		p2 = self.mem.get_port(has_re=True, clock_domain="rd")
		self.specials += p1, p2
		self.ios = {p1.adr, p1.dat_r, p1.we, p1.dat_w,
			p2.adr, p2.dat_r, p2.re}

example = Example()
print(verilog.convert(example, example.ios))

########NEW FILE########
__FILENAME__ = namer
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.misc import optree

def gen_list(n):
	s = [Signal() for i in range(n)]
	return s

def gen_2list(n):
	s = [Signal(2) for i in range(n)]
	return s

class Foo:
	def __init__(self):
		la = gen_list(3)
		lb = gen_2list(2)
		self.sigs = la + lb

class Bar:
	def __init__(self):
		self.sigs = gen_list(2)

class Example(Module):
	def __init__(self):
		a = [Bar() for x in range(3)]
		b = [Foo() for x in range(3)]
		c = b
		b = [Bar() for x in range(2)]

		output = Signal()
		allsigs = []
		for lst in [a, b, c]:
			for obj in lst:
				allsigs.extend(obj.sigs)
		self.comb += output.eq(optree("|", allsigs))

print(verilog.convert(Example()))

########NEW FILE########
__FILENAME__ = psync
from migen.fhdl.std import *
from migen.fhdl.specials import SynthesisDirective
from migen.fhdl import verilog
from migen.genlib.cdc import *

class XilinxMultiRegImpl(MultiRegImpl):
	def __init__(self, *args, **kwargs):
		MultiRegImpl.__init__(self, *args, **kwargs)
		self.specials += set(SynthesisDirective("attribute shreg_extract of {r} is no", r=r)
			for r in self.regs)

class XilinxMultiReg:
	@staticmethod
	def lower(dr):
		return XilinxMultiRegImpl(dr.i, dr.o, dr.odomain, dr.n)

ps = PulseSynchronizer("from", "to")
v = verilog.convert(ps, {ps.i, ps.o}, special_overrides={MultiReg: XilinxMultiReg})
print(v)

########NEW FILE########
__FILENAME__ = record
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.record import *

L = [
	("position", [
			("x", 10, DIR_M_TO_S),
			("y", 10, DIR_M_TO_S),
	]),
	("color", 32, DIR_M_TO_S),
	("stb", 1, DIR_M_TO_S),
	("ack", 1, DIR_S_TO_M)
]

class Test(Module):
	def __init__(self):
		master = Record(L)
		slave = Record(L)
		self.comb += master.connect(slave)

print(verilog.convert(Test()))
print(layout_len(L))
print(layout_partial(L, "position/x", "color"))

########NEW FILE########
__FILENAME__ = reslice
from migen.fhdl.std import *
from migen.fhdl import verilog

class Example(Module):
	def __init__(self):
		a = Signal(3)
		b = Signal(4)
		c = Signal(5)
		d = Signal(7)
		s1 = c[:3][:2]
		s2 = Cat(a, b)[:6]
		s3 = Cat(s1, s2)[-5:]
		self.comb += s3.eq(0)
		self.comb += d.eq(Cat(d[::-1], Cat(s1[:1], s3[-4:])[:3]))

print(verilog.convert(Example()))

########NEW FILE########
__FILENAME__ = simple_gpio
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.cdc import MultiReg
from migen.bank import description, csrgen

class Example(Module):
	def __init__(self, ninputs=32, noutputs=32):
		r_o = description.CSRStorage(noutputs, atomic_write=True)
		r_i = description.CSRStatus(ninputs)

		self.submodules.bank = csrgen.Bank([r_o, r_i])
		self.gpio_in = Signal(ninputs)
		self.gpio_out  = Signal(ninputs)

		###

		gpio_in_s = Signal(ninputs)
		self.specials += MultiReg(self.gpio_in, gpio_in_s)
		self.comb += [
			self.gpio_out.eq(r_o.storage),
			r_i.status.eq(gpio_in_s)
		]

example = Example()
i = example.bank.bus
v = verilog.convert(example, {i.dat_r, i.adr, i.we, i.dat_w,
	example.gpio_in, example.gpio_out})
print(v)

########NEW FILE########
__FILENAME__ = tristate
from migen.fhdl.std import *
from migen.fhdl import verilog

class Example(Module):
	def __init__(self, n=6):
		self.pad = Signal(n)
		self.t = TSTriple(n)
		self.specials += self.t.get_tristate(self.pad)

e = Example()
print(verilog.convert(e, ios={e.pad, e.t.o, e.t.oe, e.t.i}))

########NEW FILE########
__FILENAME__ = two_dividers
from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib import divider

@DecorateModule(InsertReset)
@DecorateModule(InsertCE)
class Example(Module):
	def __init__(self, width):
		d1 = divider.Divider(width)
		d2 = divider.Divider(width)
		self.submodules += d1, d2
		self.ios = {
			d1.ready_o, d1.quotient_o, d1.remainder_o, d1.start_i, d1.dividend_i, d1.divisor_i,
			d2.ready_o, d2.quotient_o, d2.remainder_o, d2.start_i, d2.dividend_i, d2.divisor_i}

example = Example(16)
print(verilog.convert(example, example.ios | {example.ce, example.reset}))

########NEW FILE########
__FILENAME__ = cordic_impl
import copy
import json

from migen.fhdl.std import *
from migen.genlib.cordic import Cordic
from mibuild.tools import mkdir_noerror
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

class CordicImpl(Module):
	def __init__(self, name, **kwargs):
		self.name = name
		mkdir_noerror("build")
		json.dump(kwargs, open("build/{}.json".format(name), "w"))
		self.platform = platform = Platform()
		self.submodules.cordic = Cordic(**kwargs)
		width = flen(self.cordic.xi)
		self.comb += self.cordic.xi.eq(
				int((1<<width - 1)/self.cordic.gain*.98))
		self.comb += self.cordic.yi.eq(0)
		zi = self.cordic.zi
		self.sync += zi.eq(zi + 1)
		do = platform.request("do")
		self.sync += do.eq(Cat(self.cordic.xo, self.cordic.yo))

	def build(self):
		self.platform.build(self, build_name=self.name)

class Platform(XilinxISEPlatform):
	_io = [
		("clk", 0, Pins("AB13")),
		("rst", 0, Pins("V5")),
		("do", 0,
			Pins("Y2 W3 W1 P8 P7 P6 P5 T4 T3",
				"U4 V3 N6 N7 M7 M8 R4 P4 M6 L6 P3 N4",
				"M5 V2 V1 U3 U1 T2 T1 R3 R1 P2 P1"),
		),
	]
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx45-fgg484-2", self._io,
			lambda p: CRG_SE(p, "clk", "rst", 10.))

if __name__ == "__main__":
	default = dict(width=16, guard=0, eval_mode="pipelined",
			func_mode="circular", cordic_mode="rotate")
	variations = dict(
			eval_mode=["combinatorial", "pipelined", "iterative"],
			width=[4, 8, 12, 14, 16, 20, 24, 32],
			stages=[10, 12, 14, 16, 20, 24, 32],
			guard=[0, 1, 2, 3, 4],
			)
	CordicImpl("cordic_test", eval_mode="combinatorial").build()

	name = "cordic_baseline"
	CordicImpl(name, **default).build()

	for k, v in sorted(variations.items()):
		for vi in v:
			name = "cordic_{}_{}".format(k, vi)
			kw = copy.copy(default)
			kw[k] = vi
			CordicImpl(name, **kw).build()

########NEW FILE########
__FILENAME__ = cordic_impl_eval
import glob, os, re, json

import numpy as np
import matplotlib.pyplot as plt
import pandas


def extract(b, n, r, c=int):
	r = re.compile(r)
	try:
		f = open(b + n)
	except:
		return
	for l in f:
		m = r.search(l)
		if m:
			v = m.groups()[0]
			v = v.replace(",", "")
			return c(v)

def load(prefix, base):
	kw = json.load(open(base))
	b = os.path.splitext(base)[0]
	_, n = os.path.split(b)[1].split("_", 1)
	try:
		n, _ = n.rsplit("_", 1)
		kw["vary"] = n
	except:
		pass
	kw["slack"] = extract(b, ".par",
			"GRPclk.*SETUP +\\| +([\d,]+\\.\d+)", float)
	kw["freq"] = extract(b, ".srp",
			"Maximum Frequency: +([\d,]+\\.\d+) *MHz", float)
	kw["reg"] = extract(b, "_map.mrp",
			"Number of Slice Registers: +([\d,]+) ")
	kw["lut"] = extract(b, "_map.mrp",
			"Number of Slice LUTs: +([\d,]+) ")
	kw["slice"] = extract(b, "_map.mrp",
			"Number of occupied Slices: +([\d,]+) ")
	return kw

def run(prefix):
	dat = {}
	for base in glob.glob("build/{}_*.json".format(prefix)):
		kw = load(prefix, base)
		if "vary" in kw:
			dat[base] = kw
	df = pandas.DataFrame.from_dict(dat, orient="index")
	comp = "freq slice slack".split()
	dfg = df.groupby("vary")
	fig, ax = plt.subplots(len(dfg), len(comp))
	for axj, (v, dfi) in zip(ax, dfg):
		print(v, dfi)
		if v not in dfi:
			continue
		dfi = dfi.sort(v)
		for axi, n in zip(axj, comp):
			x = dfi[v]
			if type(x[0]) is type(""):
				xi = range(len(x))
				axi.set_xticks(xi)
				axi.set_xticklabels(x)
				x = xi
			axi.plot(x, dfi[n])
			axi.set_xlabel(v)
			axi.set_ylabel(n)
	fig.savefig("cordic_impl.pdf")
	plt.show()

if __name__ == "__main__":
	run("cordic")

########NEW FILE########
__FILENAME__ = dma
from random import Random

from migen.fhdl.std import *
from migen.flow.network import *
from migen.flow.transactions import *
from migen.actorlib import dma_wishbone
from migen.actorlib.sim import *
from migen.bus import wishbone
from migen.sim.generic import run_simulation

class MyModel:
	def read(self, address):
		return address + 4

class MyModelWB(MyModel, wishbone.TargetModel):
	def __init__(self):
		self.prng = Random(763627)

	def can_ack(self, bus):
		return self.prng.randrange(0, 2)

def adrgen_gen():
	for i in range(10):
		print("Address:  " + hex(i))
		yield Token("address", {"a": i})

class SimAdrGen(SimActor):
	def __init__(self, nbits):
		self.address = Source([("a", nbits)])
		SimActor.__init__(self, adrgen_gen())

def dumper_gen():
	while True:
		t = Token("data", idle_wait=True)
		yield t
		print("Received: " + hex(t.value["d"]))

class SimDumper(SimActor):
	def __init__(self):
		self.data = Sink([("d", 32)])
		SimActor.__init__(self, dumper_gen())		

def trgen_gen():
	for i in range(10):
		a = i
		d = i+10
		print("Address: " + hex(a) + " Data: " + hex(d))
		yield Token("address_data", {"a": a, "d": d})

class SimTrGen(SimActor):
	def __init__(self, a_nbits):
		self.address_data = Source([("a", a_nbits), ("d", 32)])
		SimActor.__init__(self, trgen_gen())

class TBWishbone(Module):
	def __init__(self, master):
		self.submodules.peripheral = wishbone.Target(MyModelWB())
		self.submodules.tap = wishbone.Tap(self.peripheral.bus)
		self.submodules.interconnect = wishbone.InterconnectPointToPoint(master.bus,
		  self.peripheral.bus)

class TBWishboneReader(TBWishbone):
	def __init__(self):
		self.adrgen = SimAdrGen(30)
		self.reader = dma_wishbone.Reader()
		self.dumper = SimDumper()
		g = DataFlowGraph()
		g.add_connection(self.adrgen, self.reader)
		g.add_connection(self.reader, self.dumper)
		self.submodules.comp = CompositeActor(g)
		TBWishbone.__init__(self, self.reader)

class TBWishboneWriter(TBWishbone):
	def __init__(self):
		self.trgen = SimTrGen(30)
		self.writer = dma_wishbone.Writer()
		g = DataFlowGraph()
		g.add_connection(self.trgen, self.writer)
		self.submodules.comp = CompositeActor(g)
		TBWishbone.__init__(self, self.writer)

def test_wb_reader():
	print("*** Testing Wishbone reader")
	run_simulation(TBWishboneReader())

def test_wb_writer():
	print("*** Testing Wishbone writer")
	run_simulation(TBWishboneWriter())

if __name__ == "__main__":
	test_wb_reader()
	test_wb_writer()

########NEW FILE########
__FILENAME__ = misc
from migen.flow.network import *
from migen.flow.transactions import *
from migen.actorlib import misc
from migen.actorlib.sim import *
from migen.sim.generic import run_simulation

def source_gen():
	for i in range(10):
		v = i + 5
		print("==> " + str(v))
		yield Token("source", {"maximum": v})

class SimSource(SimActor):
	def __init__(self):
		self.source = Source([("maximum", 32)])
		SimActor.__init__(self, source_gen())

def sink_gen():
	while True:
		t = Token("sink")
		yield t
		print(t.value["value"])

class SimSink(SimActor):
	def __init__(self):
		self.sink = Sink([("value", 32)])
		SimActor.__init__(self, sink_gen())

if __name__ == "__main__":
	source = SimSource()
	loop = misc.IntSequence(32)
	sink = SimSink()
	g = DataFlowGraph()
	g.add_connection(source, loop)
	g.add_connection(loop, sink)
	comp = CompositeActor(g)
	run_simulation(comp, ncycles=500)

########NEW FILE########
__FILENAME__ = structuring
from itertools import count

import networkx as nx
import matplotlib.pyplot as plt

from migen.flow.network import *
from migen.flow.transactions import *
from migen.actorlib import structuring
from migen.actorlib.sim import *
from migen.flow import perftools
from migen.sim.generic import run_simulation

pack_factor = 5
base_layout = [("value", 32)]
packed_layout = structuring.pack_layout(base_layout, pack_factor)
rawbits_layout = [("value", 32*pack_factor)]

def source_gen():
	for i in count(0):
		yield Token("source", {"value": i})

class SimSource(SimActor):
	def __init__(self):
		self.source = Source(base_layout)
		SimActor.__init__(self, source_gen())

def sink_gen():
	while True:
		t = Token("sink")
		yield t
		print(t.value["value"])

class SimSink(SimActor):
	def __init__(self):
		self.sink = Sink(base_layout)
		SimActor.__init__(self, sink_gen())

class TB(Module):
	def __init__(self):
		source = SimSource()
		sink = SimSink()
		
		# A tortuous way of passing integer tokens.
		packer = structuring.Pack(base_layout, pack_factor)
		to_raw = structuring.Cast(packed_layout, rawbits_layout)
		from_raw = structuring.Cast(rawbits_layout, packed_layout)
		unpacker = structuring.Unpack(pack_factor, base_layout)
		
		self.g = DataFlowGraph()
		self.g.add_connection(source, packer)
		self.g.add_connection(packer, to_raw)
		self.g.add_connection(to_raw, from_raw)
		self.g.add_connection(from_raw, unpacker)
		self.g.add_connection(unpacker, sink)
		self.submodules.comp = CompositeActor(self.g)
		self.submodules.reporter = perftools.DFGReporter(self.g)

if __name__ == "__main__":
	tb = TB()
	run_simulation(tb, ncycles=1000)
	
	g_layout = nx.spectral_layout(tb.g)
	nx.draw(tb.g, g_layout)
	nx.draw_networkx_edge_labels(tb.g, g_layout, tb.reporter.get_edge_labels())
	plt.show()

########NEW FILE########
__FILENAME__ = basic
from migen.flow.network import *
from migen.flow.transactions import *
from migen.actorlib.sim import *
from migen.pytholite.compiler import Pytholite
from migen.sim.generic import run_simulation
from migen.fhdl import verilog

layout = [("r", 32)]

def number_gen(n):
	for i in range(n):
		yield Token("result", {"r": i})

class SimNumberGen(SimActor):
	def __init__(self):
		self.result = Source(layout)
		SimActor.__init__(self, number_gen(5))

def run_ng_sim(ng):
	g = DataFlowGraph()
	d = Dumper(layout)
	g.add_connection(ng, d)
	
	c = CompositeActor(g)
	run_simulation(c, ncycles=20)

def make_ng_pytholite():
	ng_pytholite = Pytholite(number_gen, 5)
	ng_pytholite.result = Source(layout)
	ng_pytholite.finalize()
	return ng_pytholite

def main():
	print("Simulating native Python:")
	ng_native = SimNumberGen()
	run_ng_sim(ng_native)
	
	print("Simulating Pytholite:")
	ng_pytholite = make_ng_pytholite()
	run_ng_sim(ng_pytholite)
	
	print("Converting Pytholite to Verilog:")
	ng_pytholite = make_ng_pytholite()
	print(verilog.convert(ng_pytholite))

main()

########NEW FILE########
__FILENAME__ = uio
from migen.flow.network import *
from migen.flow.transactions import *
from migen.actorlib.sim import Dumper
from migen.bus import wishbone
from migen.bus.transactions import *
from migen.genlib.ioo import UnifiedIOSimulation
from migen.pytholite.transel import Register
from migen.pytholite.compiler import Pytholite
from migen.sim.generic import run_simulation
from migen.fhdl.std import *
from migen.fhdl import verilog

layout = [("r", 32)]

def gen():
	ds = Register(32)
	for i in range(3):
		r = TRead(i, busname="mem")
		yield r
		ds.store = r.data
		yield Token("result", {"r": ds})
	for i in range(5):
		r = TRead(i, busname="wb")
		yield r
		ds.store = r.data
		yield Token("result", {"r": ds})

class SlaveModel(wishbone.TargetModel):
	def read(self, address):
		return address + 4

class TestBench(Module):
	def __init__(self, ng):
		g = DataFlowGraph()
		d = Dumper(layout)
		g.add_connection(ng, d)
		
		self.submodules.slave = wishbone.Target(SlaveModel())
		self.submodules.intercon = wishbone.InterconnectPointToPoint(ng.wb, self.slave.bus)
		self.submodules.ca = CompositeActor(g)

def run_ng_sim(ng):
	run_simulation(TestBench(ng), ncycles=50)

def add_interfaces(obj):
	obj.result = Source(layout)
	obj.wb = wishbone.Interface()
	obj.mem = Memory(32, 3, init=[42, 37, 81])
	obj.finalize()

def main():
	print("Simulating native Python:")
	ng_native = UnifiedIOSimulation(gen())
	add_interfaces(ng_native) 
	run_ng_sim(ng_native)
	
	print("Simulating Pytholite:")
	ng_pytholite = Pytholite(gen)
	add_interfaces(ng_pytholite)
	run_ng_sim(ng_pytholite)
	
	print("Converting Pytholite to Verilog:")
	ng_pytholite = Pytholite(gen)
	add_interfaces(ng_pytholite)
	print(verilog.convert(ng_pytholite))

main()

########NEW FILE########
__FILENAME__ = abstract_transactions_lasmi
from migen.fhdl.std import *
from migen.bus.transactions import *
from migen.bus import lasmibus
from migen.sim.generic import run_simulation

def my_generator(n):
	bank = n % 4
	for x in range(4):
		t = TWrite(4*bank+x, 0x1000*bank + 0x100*x)
		yield t
		print("{0}: Wrote in {1} cycle(s)".format(n, t.latency))
		
	for x in range(4):
		t = TRead(4*bank+x)
		yield t
		print("{0}: Read {1:x} in {2} cycle(s)".format(n, t.data, t.latency))
		assert(t.data == 0x1000*bank + 0x100*x)

class MyModel(lasmibus.TargetModel):
	def read(self, bank, address):
		r = 0x1000*bank + 0x100*address
		#print("read from bank {0} address {1} -> {2:x}".format(bank, address, r))
		return r
	
	def write(self, bank, address, data, we):
		print("write to bank {0} address {1:x} data {2:x}".format(bank, address, data))
		assert(data == 0x1000*bank + 0x100*address)

class TB(Module):
	def __init__(self):
		self.submodules.controller = lasmibus.Target(MyModel(), aw=4, dw=32, nbanks=4, req_queue_size=4,
			read_latency=4, write_latency=1)
		self.submodules.xbar = lasmibus.Crossbar([self.controller.bus], 2)
		self.initiators = [lasmibus.Initiator(my_generator(n), self.xbar.get_master()) for n in range(4)]
		self.submodules += self.initiators

if __name__ == "__main__":
	run_simulation(TB())

########NEW FILE########
__FILENAME__ = abstract_transactions_wb
from random import Random

from migen.fhdl.std import *
from migen.bus.transactions import *
from migen.bus import wishbone
from migen.sim.generic import run_simulation

# Our bus master.
# Python generators let us program bus transactions in an elegant sequential style.
def my_generator():
	prng = Random(92837)

	# Write to the first addresses.
	for x in range(10):
		t = TWrite(x, 2*x)
		yield t
		print("Wrote in " + str(t.latency) + " cycle(s)")
		# Insert some dead cycles to simulate bus inactivity.
		for delay in range(prng.randrange(0, 3)):
			yield None

	# Read from the first addresses.
	for x in range(10):
		t = TRead(x)
		yield t
		print("Read " + str(t.data) + " in " + str(t.latency) + " cycle(s)")
		for delay in range(prng.randrange(0, 3)):
			yield None

# Our bus slave.
class MyModelWB(wishbone.TargetModel):
	def __init__(self):
		self.prng = Random(763627)

	def read(self, address):
		return address + 4

	def can_ack(self, bus):
		# Simulate variable latency.
		return self.prng.randrange(0, 2)

class TB(Module):
	def __init__(self):
		# The "wishbone.Initiator" library component runs our generator
		# and manipulates the bus signals accordingly.
		self.submodules.master = wishbone.Initiator(my_generator())
		# The "wishbone.Target" library component examines the bus signals
		# and calls into our model object.
		self.submodules.slave = wishbone.Target(MyModelWB())
		# The "wishbone.Tap" library component examines the bus at the slave port
		# and displays the transactions on the console (<TRead...>/<TWrite...>).
		self.submodules.tap = wishbone.Tap(self.slave.bus)
		# Connect the master to the slave.
		self.submodules.intercon = wishbone.InterconnectPointToPoint(self.master.bus, self.slave.bus)

if __name__ == "__main__":
	run_simulation(TB())

# Output:
# <TWrite adr:0x0 dat:0x0>
# Wrote in 0 cycle(s)
# <TWrite adr:0x1 dat:0x2>
# Wrote in 0 cycle(s)
# <TWrite adr:0x2 dat:0x4>
# Wrote in 0 cycle(s)
# <TWrite adr:0x3 dat:0x6>
# Wrote in 1 cycle(s)
# <TWrite adr:0x4 dat:0x8>
# Wrote in 1 cycle(s)
# <TWrite adr:0x5 dat:0xa>
# Wrote in 2 cycle(s)
# ...
# <TRead adr:0x0 dat:0x4>
# Read 4 in 2 cycle(s)
# <TRead adr:0x1 dat:0x5>
# Read 5 in 2 cycle(s)
# <TRead adr:0x2 dat:0x6>
# Read 6 in 1 cycle(s)
# <TRead adr:0x3 dat:0x7>
# Read 7 in 1 cycle(s)
# ...

########NEW FILE########
__FILENAME__ = basic1
from migen.fhdl.std import *
from migen.sim.generic import run_simulation

# Our simple counter, which increments at every cycle
# and prints its current value in simulation.
class Counter(Module):
	def __init__(self):
		self.count = Signal(4)

		# At each cycle, increase the value of the count signal.
		# We do it with convertible/synthesizable FHDL code.
		self.sync += self.count.eq(self.count + 1)
	
	# This function will be called at every cycle.
	def do_simulation(self, selfp):
		# Simply read the count signal and print it.
		# The output is:
		# Count: 0 
		# Count: 1
		# Count: 2
		# ...
		print("Count: " + str(selfp.count))

if __name__ == "__main__":
	dut = Counter()
	# Since we do not use StopSimulation, limit the simulation
	# to some number of cycles.
	run_simulation(dut, ncycles=20)

########NEW FILE########
__FILENAME__ = basic2
from migen.fhdl.std import *
from migen.sim.generic import run_simulation

# A slightly more elaborate counter.
# Has a clock enable (CE) signal, counts on more bits
# and resets with a negative number.
class Counter(Module):
	def __init__(self):
		self.ce = Signal()
		# Demonstrate negative numbers and signals larger than 32 bits.
		self.count = Signal((37, True), reset=-5)

		self.sync += If(self.ce, self.count.eq(self.count + 1))
	
	def do_simulation(self, selfp):
		# Only assert CE every second cycle.
		# => each counter value is held for two cycles.
		if selfp.simulator.cycle_counter % 2:
			selfp.ce = 0 # This is how you write to a signal.
		else:
			selfp.ce = 1
		print("Cycle: " + str(selfp.simulator.cycle_counter) + " Count: " + \
			str(selfp.count))
	
# Output is:
# Cycle: 0 Count: -5
# Cycle: 1 Count: -5
# Cycle: 2 Count: -4
# Cycle: 3 Count: -4
# Cycle: 4 Count: -3
# ...

if __name__ == "__main__":
	dut = Counter()
	# Demonstrate VCD output
	run_simulation(dut, vcd_name="my.vcd", ncycles=20)

########NEW FILE########
__FILENAME__ = cordic_err
import random

import numpy as np
import matplotlib.pyplot as plt

from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.cordic import Cordic
from migen.sim.generic import run_simulation

class TestBench(Module):
	def __init__(self, n=None, xmax=.98, i=None, **kwargs):
		self.submodules.cordic = Cordic(**kwargs)
		if n is None:
			n = 1<<flen(self.cordic.xi)
		self.c = c = 2**(flen(self.cordic.xi) - 1)
		self.cz = cz = 2**(flen(self.cordic.zi) - 1)
		if i is None:
			i = [(int(xmax*c/self.cordic.gain), 0, int(cz*(i/n - .5)))
					for i in range(n)]
		self.i = i
		random.shuffle(self.i)
		self.ii = iter(self.i)
		self.o = []

	def do_simulation(self, selfp):
		if selfp.cordic.new_in:
			try:
				selfp.cordic.xi, selfp.cordic.yi, selfp.cordic.zi = next(self.ii)
			except StopIteration:
				raise StopSimulation
		if selfp.cordic.new_out:
			self.o.append((selfp.cordic.xo, selfp.cordic.yo, selfp.cordic.zo))

	def run_io(self):
		run_simulation(self)
		del self.i[-1], self.o[0]
		if self.i[0] != (0, 0, 0):
			assert self.o[0] != (0, 0, 0)
		if self.i[-1] != self.i[-2]:
			assert self.o[-1] != self.o[-2], self.o[-2:]

def rms_err(width, guard=None, stages=None, n=None):
	tb = TestBench(width=width, guard=guard, stages=stages,
			n=n, eval_mode="combinatorial")
	tb.run_io()
	c = 2**(flen(tb.cordic.xi) - 1)
	cz = 2**(flen(tb.cordic.zi) - 1)
	g = tb.cordic.gain
	xi, yi, zi = np.array(tb.i).T/c
	zi *= c/cz*tb.cordic.zmax
	xo1, yo1, zo1 = np.array(tb.o).T
	xo = np.floor(c*g*(np.cos(zi)*xi - np.sin(zi)*yi))
	yo = np.floor(c*g*(np.sin(zi)*xi + np.cos(zi)*yi))
	dx = xo1 - xo
	dy = yo1 - yo
	mm = np.fabs([dx, dy]).max()
	rms = np.sqrt(dx**2 + dy**2).sum()/len(xo)
	return rms, mm

def rms_err_map():
	widths, stages = np.mgrid[8:33:1, 8:37:1]
	errf = np.vectorize(lambda w, s: rms_err(int(w), None, int(s), n=333))
	err = errf(widths, stages)
	print(err)
	lev = np.arange(10)
	fig, ax = plt.subplots()
	c1 = ax.contour(widths, stages, err[0], lev/10, cmap=plt.cm.Greys_r)
	c2 = ax.contour(widths, stages, err[1], lev, cmap=plt.cm.Reds_r)
	ax.plot(widths[:, 0], stages[0, np.argmin(err[0], 1)], "ko")
	ax.plot(widths[:, 0], stages[0, np.argmin(err[1], 1)], "ro")
	print(widths[:, 0], stages[0, np.argmin(err[0], 1)],
			stages[0, np.argmin(err[1], 1)])
	ax.set_xlabel("width")
	ax.set_ylabel("stages")
	ax.grid("on")
	fig.colorbar(c1)
	fig.colorbar(c2)
	fig.savefig("cordic_rms.pdf")

def plot_function(**kwargs):
	tb = TestBench(eval_mode="combinatorial", **kwargs)
	tb.run_io()
	c = 2**(flen(tb.cordic.xi) - 1)
	cz = 2**(flen(tb.cordic.zi) - 1)
	g = tb.cordic.gain
	xi, yi, zi = np.array(tb.i).T
	xo, yo, zo = np.array(tb.o).T
	fig, ax = plt.subplots()
	ax.plot(zi, xo, "r,")
	ax.plot(zi, yo, "g,")
	ax.plot(zi, zo, "g,")


if __name__ == "__main__":
	c = Cordic(width=16, guard=None, eval_mode="combinatorial")
	print(verilog.convert(c, ios={c.xi, c.yi, c.zi, c.xo, c.yo, c.zo,
		c.new_in, c.new_out}))
	#print(rms_err(8))
	#rms_err_map()
	#plot_function(func_mode="hyperbolic", xmax=.3, width=16, n=333)
	#plot_function(func_mode="circular", width=16, n=333)
	#plot_function(func_mode="hyperbolic", cordic_mode="vector",
    #        xmax=.3, width=16, n=333)
	#plot_function(func_mode="circular", width=16, n=333)
	plt.show()

########NEW FILE########
__FILENAME__ = dataflow
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.flow.transactions import *
from migen.flow.network import *
from migen.actorlib.sim import *
from migen.sim.generic import run_simulation

def source_gen():
	for i in range(10):
		print("Sending:  " + str(i))
		yield Token("source", {"value": i})

class SimSource(SimActor):
	def __init__(self):
		self.source = Source([("value", 32)])
		SimActor.__init__(self, source_gen())

def sink_gen():
	while True:
		t = Token("sink")
		yield t
		print("Received: " + str(t.value["value"]))

class SimSink(SimActor):
	def __init__(self):
		self.sink = Sink([("value", 32)])
		SimActor.__init__(self, sink_gen())

class TB(Module):
	def __init__(self):
		self.source = SimSource()
		self.sink = SimSink()
		g = DataFlowGraph()
		g.add_connection(self.source, self.sink)
		self.submodules.comp = CompositeActor(g)

	def do_simulation(self, selfp):
		if self.source.token_exchanger.done:
			raise StopSimulation

if __name__ == "__main__":
	run_simulation(TB())

########NEW FILE########
__FILENAME__ = fir
from math import cos, pi
from scipy import signal
import matplotlib.pyplot as plt

from migen.fhdl.std import *
from migen.fhdl import verilog
from migen.genlib.misc import optree
from migen.sim.generic import run_simulation

# A synthesizable FIR filter.
class FIR(Module):
	def __init__(self, coef, wsize=16):
		self.coef = coef
		self.wsize = wsize
		self.i = Signal((self.wsize, True))
		self.o = Signal((self.wsize, True))
	
		###

		muls = []
		src = self.i
		for c in self.coef:
			sreg = Signal((self.wsize, True))
			self.sync += sreg.eq(src)
			src = sreg
			c_fp = int(c*2**(self.wsize - 1))
			muls.append(c_fp*sreg)
		sum_full = Signal((2*self.wsize-1, True))
		self.sync += sum_full.eq(optree("+", muls))
		self.comb += self.o.eq(sum_full[self.wsize-1:])

# A test bench for our FIR filter.
# Generates a sine wave at the input and records the output.
class TB(Module):
	def __init__(self, coef, frequency):
		self.submodules.fir = FIR(coef)
		self.frequency = frequency
		self.inputs = []
		self.outputs = []
	
	def do_simulation(self, selfp):
		f = 2**(self.fir.wsize - 1)
		v = 0.1*cos(2*pi*self.frequency*selfp.simulator.cycle_counter)
		selfp.fir.i = int(f*v)
		self.inputs.append(v)
		self.outputs.append(selfp.fir.o/f)

if __name__ == "__main__":
	# Compute filter coefficients with SciPy.
	coef = signal.remez(30, [0, 0.1, 0.2, 0.4, 0.45, 0.5], [0, 1, 0])
	
	# Simulate for different frequencies and concatenate
	# the results.
	in_signals = []
	out_signals = []
	for frequency in [0.05, 0.1, 0.25]:
		tb = TB(coef, frequency)
		run_simulation(tb, ncycles=200)
		in_signals += tb.inputs
		out_signals += tb.outputs
	
	# Plot data from the input and output waveforms.
	plt.plot(in_signals)
	plt.plot(out_signals)
	plt.show()
	
	# Print the Verilog source for the filter.
	fir = FIR(coef)
	print(verilog.convert(fir, ios={fir.i, fir.o}))

########NEW FILE########
__FILENAME__ = memory
from migen.fhdl.std import *
from migen.sim.generic import run_simulation

class Mem(Module):
	def __init__(self):
		# Initialize the beginning of the memory with integers
		# from 0 to 19.
		self.specials.mem = Memory(16, 2**12, init=list(range(20)))
	
	def do_simulation(self, selfp):
		# Read the memory. Use the cycle counter as address.
		value = selfp.mem[selfp.simulator.cycle_counter]
		# Print the result. Output is:
		# 0
		# 1
		# 2
		# ...
		print(value)
		# Raising StopSimulation disables the current (and here, only one)
		# simulation function. Simulator stops when all functions are disabled.
		if value == 10:
			raise StopSimulation

if __name__ == "__main__":
	run_simulation(Mem())

########NEW FILE########
__FILENAME__ = altera_quartus
# This file is Copyright (c) 2013 Florent Kermarrec <florent@enjoy-digital.fr>
# License: BSD

import os, subprocess

from migen.fhdl.structure import _Fragment
from mibuild.generic_platform import *
from mibuild.crg import SimpleCRG
from mibuild import tools

class CRG_SE(SimpleCRG):
	def __init__(self, platform, clk_name, rst_name, period, rst_invert=False):
		SimpleCRG.__init__(self, platform, clk_name, rst_name, rst_invert)
		platform.add_period_constraint(platform, self.cd_sys.clk, period)

def _format_constraint(c):
	if isinstance(c, Pins):
		return "set_location_assignment PIN_" + c.identifiers[0]
	elif isinstance(c, IOStandard):
		return "set_instance_assignment -name IO_STANDARD " + "\"" + c.name + "\"" 
	elif isinstance(c, Misc):
		return c.misc

def _format_qsf(signame, pin, others, resname):
	fmt_c = [_format_constraint(c) for c in ([Pins(pin)] + others)]
	fmt_r = resname[0] + ":" + str(resname[1])
	if resname[2] is not None:
		fmt_r += "." + resname[2]
	r = ""
	for c in fmt_c:
		r += c + " -to " + signame + " # " + fmt_r + "\n"
	return r

def _build_qsf(named_sc, named_pc):
	r = ""
	for sig, pins, others, resname in named_sc:
		if len(pins) > 1:
			for i, p in enumerate(pins):
				r += _format_qsf(sig + "[" + str(i) + "]", p, others, resname)
		else:
			r += _format_qsf(sig, pins[0], others, resname)
	if named_pc:
		r += "\n" + "\n\n".join(named_pc)
	r += "set_global_assignment -name top_level_entity top\n"
	return r

def _build_files(device, sources, vincpaths, named_sc, named_pc, build_name):
	qsf_contents = ""
	for filename, language in sources:
		# Enforce use of SystemVerilog (Quartus does not support global parameters in Verilog)
		if language == "verilog":
			language = "systemverilog"
		qsf_contents += "set_global_assignment -name "+language.upper()+"_FILE " + filename.replace("\\","/") + "\n"

	for path in vincpaths:
		qsf_contents += "set_global_assignment -name SEARCH_PATH " + path.replace("\\","/") + "\n"

	qsf_contents += _build_qsf(named_sc, named_pc)
	qsf_contents += "set_global_assignment -name DEVICE " + device
	tools.write_to_file(build_name + ".qsf", qsf_contents)

def _run_quartus(build_name, quartus_path):
	build_script_contents = """# Autogenerated by mibuild

quartus_map --read_settings_files=on --write_settings_files=off {build_name} -c {build_name}
quartus_fit --read_settings_files=off --write_settings_files=off {build_name} -c {build_name}
quartus_asm --read_settings_files=off --write_settings_files=off {build_name} -c {build_name}
quartus_sta {build_name} -c {build_name}

""".format(build_name=build_name)
	build_script_file = "build_" + build_name + ".sh"
	tools.write_to_file(build_script_file, build_script_contents, force_unix=True)

	r = subprocess.call(["bash", build_script_file])
	if r != 0:
		raise OSError("Subprocess failed")

class AlteraQuartusPlatform(GenericPlatform):
	bitstream_ext = ".sof"
	def build(self, fragment, build_dir="build", build_name="top",
			quartus_path="/opt/Altera", run=True):
		tools.mkdir_noerror(build_dir)
		os.chdir(build_dir)

		if not isinstance(fragment, _Fragment):
			fragment = fragment.get_fragment()
		self.finalize(fragment)
		
		v_src, named_sc, named_pc = self.get_verilog(fragment)
		v_file = build_name + ".v"
		tools.write_to_file(v_file, v_src)
		sources = self.sources + [(v_file, "verilog")]
		_build_files(self.device, sources, self.verilog_include_paths, named_sc, named_pc, build_name)
		if run:
			_run_quartus(build_name, quartus_path)
		
		os.chdir("..")

	def add_period_constraint(self, clk, period):
		self.add_platform_command("""set_global_assignment -name DUTY_CYCLE 50 -section_id {clk}""", clk=clk)
		self.add_platform_command("""set_global_assignment -name FMAX_REQUIREMENT "{freq} MHz" -section_id {clk}\n""".format(freq=str(float(1/period)*1000), clk="{clk}"), clk=clk)

########NEW FILE########
__FILENAME__ = crg
from migen.fhdl.std import *

class SimpleCRG(Module):
	def __init__(self, platform, clk_name, rst_name, rst_invert=False):
			reset_less = rst_name is None
			self.clock_domains.cd_sys = ClockDomain(reset_less=reset_less)
			self._clk = platform.request(clk_name)
			self.comb += self.cd_sys.clk.eq(self._clk)

			if not reset_less:
				if rst_invert:
					self.comb += self.cd_sys.rst.eq(~platform.request(rst_name))
				else:
					self.comb += self.cd_sys.rst.eq(platform.request(rst_name))

########NEW FILE########
__FILENAME__ = generic_platform
import os, sys

from migen.fhdl.std import *
from migen.fhdl.structure import _Fragment
from migen.genlib.record import Record
from migen.fhdl import verilog, edif
from migen.util.misc import autotype

from mibuild import tools

class ConstraintError(Exception):
	pass
	
class Pins:
	def __init__(self, *identifiers):
		self.identifiers = []
		for i in identifiers:
			self.identifiers += i.split()

class IOStandard:
	def __init__(self, name):
		self.name = name

class Drive:
	def __init__(self, strength):
		self.strength = strength

class Misc:
	def __init__(self, misc):
		self.misc = misc

class Subsignal:
	def __init__(self, name, *constraints):
		self.name = name
		self.constraints = list(constraints)

class PlatformInfo:
	def __init__(self, info):
		self.info = info

def _lookup(description, name, number):
	for resource in description:
		if resource[0] == name and (number is None or resource[1] == number):
			return resource
	raise ConstraintError("Resource not found: " + name + ":" + str(number))
		
def _resource_type(resource):
	t = None
	for element in resource[2:]:
		if isinstance(element, Pins):
			assert(t is None)
			t = len(element.identifiers)
		elif isinstance(element, Subsignal):
			if t is None:
				t = []
			assert(isinstance(t, list))
			n_bits = None
			for c in element.constraints:
				if isinstance(c, Pins):
					assert(n_bits is None)
					n_bits = len(c.identifiers)
			t.append((element.name, n_bits))
	return t

class ConnectorManager:
	def __init__(self, connectors):
		self.connector_table = dict()
		for connector in connectors:
			cit = iter(connector)
			conn_name = next(cit)
			pin_list = []
			for pins in cit:
				pin_list += pins.split()
			if conn_name in self.connector_table:
				raise ValueError("Connector specified more than once: "+conn_name)
			self.connector_table[conn_name] = pin_list

	def resolve_identifiers(self, identifiers):
		r = []
		for identifier in identifiers:
			if ":" in identifier:
				conn, pn = identifier.split(":")
				pn = int(pn)
				r.append(self.connector_table[conn][pn])
			else:
				r.append(identifier)
		return r

def _separate_pins(constraints):
	pins = None
	others = []
	for c in constraints:
		if isinstance(c, Pins):
			assert(pins is None)
			pins = c.identifiers
		else:
			others.append(c)
	return pins, others

class ConstraintManager:
	def __init__(self, io, connectors):
		self.available = list(io)
		self.matched = []
		self.platform_commands = []
		self.connector_manager = ConnectorManager(connectors)

	def add_extension(self, io):
		self.available.extend(io)
		
	def request(self, name, number=None):
		resource = _lookup(self.available, name, number)
		rt = _resource_type(resource)		
		if isinstance(rt, int):
			obj = Signal(rt, name_override=resource[0])
		else:
			obj = Record(rt, name=resource[0])
		for element in resource[2:]:
			if isinstance(element, PlatformInfo):
				obj.platform_info = element.info
				break
		self.available.remove(resource)
		self.matched.append((resource, obj))
		return obj

	def lookup_request(self, name, number=None):
		for resource, obj in self.matched:
			if resource[0] == name and (number is None or resource[1] == number):
				return obj
		raise ConstraintError("Resource not found: " + name + ":" + str(number))
	
	def add_platform_command(self, command, **signals):
		self.platform_commands.append((command, signals))
	
	def get_io_signals(self):
		r = set()
		for resource, obj in self.matched:
			if isinstance(obj, Signal):
				r.add(obj)
			else:
				r.update(obj.flatten())
		return r
	
	def get_sig_constraints(self):
		r = []
		for resource, obj in self.matched:
			name = resource[0]
			number = resource[1]
			has_subsignals = False
			top_constraints = []
			for element in resource[2:]:
				if isinstance(element, Subsignal):
					has_subsignals = True
				else:
					top_constraints.append(element)
			if has_subsignals:
				for element in resource[2:]:
					if isinstance(element, Subsignal):
						sig = getattr(obj, element.name)
						pins, others = _separate_pins(top_constraints + element.constraints)
						pins = self.connector_manager.resolve_identifiers(pins)
						r.append((sig, pins, others, (name, number, element.name)))
			else:
				pins, others = _separate_pins(top_constraints)
				pins = self.connector_manager.resolve_identifiers(pins)
				r.append((obj, pins, others, (name, number, None)))
		return r

	def get_platform_commands(self):
		return self.platform_commands

class GenericPlatform:
	def __init__(self, device, io, default_crg_factory=None, connectors=[], name=None):
		self.device = device
		self.constraint_manager = ConstraintManager(io, connectors)
		self.default_crg_factory = default_crg_factory
		if name is None:
			name = self.__module__.split(".")[-1]
		self.name = name
		self.sources = []
		self.verilog_include_paths = []
		self.finalized = False

	def request(self, *args, **kwargs):
		return self.constraint_manager.request(*args, **kwargs)

	def lookup_request(self, *args, **kwargs):
		return self.constraint_manager.lookup_request(*args, **kwargs)

	def add_platform_command(self, *args, **kwargs):
		return self.constraint_manager.add_platform_command(*args, **kwargs)

	def add_extension(self, *args, **kwargs):
		return self.constraint_manager.add_extension(*args, **kwargs)

	def finalize(self, fragment, *args, **kwargs):
		if self.finalized:
			raise ConstraintError("Already finalized")
		# if none exists, create a default clock domain and drive it
		if not fragment.clock_domains:
			if self.default_crg_factory is None:
				raise NotImplementedError("No clock/reset generator defined by either platform or user")
			crg = self.default_crg_factory(self)
			fragment += crg.get_fragment()
		self.do_finalize(fragment, *args, **kwargs)
		self.finalized = True

	def do_finalize(self, fragment, *args, **kwargs):
		"""overload this and e.g. add_platform_command()'s after the
		modules had their say"""
		pass

	def add_source(self, filename, language=None):
		if language is None:
			language = tools.language_by_filename(filename)
		if language is None:
			language = "verilog" # default to Verilog
		filename = os.path.abspath(filename)
		self.sources.append((filename, language))

	def add_sources(self, path, *filenames, language=None):
		for f in filenames:
			self.add_source(os.path.join(path, f), language)

	def add_source_dir(self, path):
		for root, dirs, files in os.walk(path):
			for filename in files:
				language = tools.language_by_filename(filename)
				if language is not None:
					self.add_source(os.path.join(root, filename), language)

	def add_verilog_include_path(self, path):
		self.verilog_include_paths.append(os.path.abspath(path))

	def _resolve_signals(self, vns):
		# resolve signal names in constraints
		sc = self.constraint_manager.get_sig_constraints()
		named_sc = [(vns.get_name(sig), pins, others, resource) for sig, pins, others, resource in sc]
		# resolve signal names in platform commands
		pc = self.constraint_manager.get_platform_commands()
		named_pc = []
		for template, args in pc:
			name_dict = dict((k, vns.get_name(sig)) for k, sig in args.items())
			named_pc.append(template.format(**name_dict))
		return named_sc, named_pc

	def _get_source(self, fragment, gen_fn):
		if not isinstance(fragment, _Fragment):
			fragment = fragment.get_fragment()
		# generate source
		src, vns = gen_fn(fragment)
		named_sc, named_pc = self._resolve_signals(vns)
		return src, named_sc, named_pc

	def get_verilog(self, fragment, **kwargs):
		return self._get_source(fragment, lambda f: verilog.convert(f, self.constraint_manager.get_io_signals(),
				return_ns=True, create_clock_domains=False, **kwargs))
		
	def get_edif(self, fragment, cell_library, vendor, device, **kwargs):
		return self._get_source(fragment, lambda f: edif.convert(f, self.constraint_manager.get_io_signals(),
				cell_library, vendor, device, return_ns=True, **kwargs))

	def build(self, fragment):
		raise NotImplementedError("GenericPlatform.build must be overloaded")

	def build_cmdline(self, *args, **kwargs):
		arg = sys.argv[1:]
		if len(arg) % 2:
			print("Missing value for option: "+sys.argv[-1])
			sys.exit(1)
		argdict = dict((k, autotype(v)) for k, v in zip(*[iter(arg)]*2))
		kwargs.update(argdict)
		self.build(*args, **kwargs)

########NEW FILE########
__FILENAME__ = de0nano
# This file is Copyright (c) 2013 Florent Kermarrec <florent@enjoy-digital.fr>
# License: BSD

from mibuild.generic_platform import *
from mibuild.altera_quartus import AlteraQuartusPlatform, CRG_SE

_io = [
	("clk50", 0, Pins("R8"), IOStandard("3.3-V LVTTL")),

	("user_led", 0, Pins("A15"), IOStandard("3.3-V LVTTL")),
	("user_led", 1, Pins("A13"), IOStandard("3.3-V LVTTL")),
	("user_led", 2, Pins("B13"), IOStandard("3.3-V LVTTL")),
	("user_led", 3, Pins("A11"), IOStandard("3.3-V LVTTL")),
	("user_led", 4, Pins("D1"), IOStandard("3.3-V LVTTL")),
	("user_led", 5, Pins("F3"), IOStandard("3.3-V LVTTL")),
	("user_led", 6, Pins("B1"), IOStandard("3.3-V LVTTL")),
	("user_led", 7, Pins("L3"), IOStandard("3.3-V LVTTL")),

	("key", 0, Pins("J15"), IOStandard("3.3-V LVTTL")),
	("key", 1, Pins("E1"), IOStandard("3.3-V LVTTL")),
	
	("sw", 0, Pins("M1"), IOStandard("3.3-V LVTTL")),
	("sw", 1, Pins("T9"), IOStandard("3.3-V LVTTL")),	
	("sw", 2, Pins("B9"), IOStandard("3.3-V LVTTL")),
	("sw", 3, Pins("M15"), IOStandard("3.3-V LVTTL")),

	("serial", 0,
		Subsignal("tx", Pins("D3"), IOStandard("3.3-V LVTTL")),
		Subsignal("rx", Pins("C3"), IOStandard("3.3-V LVTTL"))
	),
	
	("sdram_clock", 0, Pins("R4"), IOStandard("3.3-V LVTTL")),
	("sdram", 0,
		Subsignal("a", Pins("P2 N5 N6 M8 P8 T7 N8 T6 R1 P1 N2 N1 L4")),
		Subsignal("ba", Pins("M7 M6")),
		Subsignal("cs_n", Pins("P6")),
		Subsignal("cke", Pins("L7")),
		Subsignal("ras_n", Pins("L2")),
		Subsignal("cas_n", Pins("L1")),
		Subsignal("we_n", Pins("C2")),
		Subsignal("dq", Pins("G2 G1 L8 K5 K2 J2 J1 R7 T4 T2 T3 R3 R5 P3 N3 K1")),
		Subsignal("dm", Pins("R6","T5")),
		IOStandard("3.3-V LVTTL")
	),
	
	("epcs", 0,
		Subsignal("data0", Pins("H2")),
		Subsignal("dclk", Pins("H1")),
		Subsignal("ncs0", Pins("D2")),
		Subsignal("asd0", Pins("C1")),
		IOStandard("3.3-V LVTTL")
	),
	
	("i2c", 0,
		Subsignal("sclk", Pins("F2")),
		Subsignal("sdat", Pins("F1")),
		IOStandard("3.3-V LVTTL")
	),

	("g_sensor", 0,
		Subsignal("cs_n", Pins("G5")),
		Subsignal("int", Pins("M2")),
		IOStandard("3.3-V LVTTL")
	),
	
	("adc", 0,
		Subsignal("cs_n", Pins("A10")),
		Subsignal("saddr", Pins("B10")),
		Subsignal("sclk", Pins("B14")),
		Subsignal("sdat", Pins("A9")),
		IOStandard("3.3-V LVTTL")
	),
	
	("gpio_0", 0,
		Pins("D3 C3 A2 A3 B3 B4 A4 B5 A5 D5 B6 A6 B7 D6 A7 C6",
			"C8 E6 E7 D8 E8 F8 F9 E9 C9 D9 E11 E10 C11 B11 A12 D11",
			"D12 B12"),
		IOStandard("3.3-V LVTTL")
	),
	("gpio_1", 0,
		Pins("F13 T15 T14 T13 R13 T12 R12 T11 T10 R11 P11 R10 N12 P9 N9 N11",
			"L16 K16 R16 L15 P15 P16 R14 N16 N15 P14 L14 N14 M10 L13 J16 K15",
			"J13 J14"),
		IOStandard("3.3-V LVTTL")
	),
	("gpio_2", 0,
		Pins("A14 B16 C14 C16 C15 D16 D15 D14 F15 F16 F14 G16 G15"),
		IOStandard("3.3-V LVTTL")
	),
]

class Platform(AlteraQuartusPlatform):
	def __init__(self):
		AlteraQuartusPlatform.__init__(self, "EP4CE22F17C6", _io,
			lambda p: CRG_SE(p, "clk50", None))

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk50"), 20)
		except ConstraintError:
			pass

########NEW FILE########
__FILENAME__ = kc705
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_DS

_io = [
	("user_led", 0, Pins("AB8"), IOStandard("LVCMOS15")),
	("user_led", 1, Pins("AA8"), IOStandard("LVCMOS15")),
	("user_led", 2, Pins("AC9"), IOStandard("LVCMOS15")),
	("user_led", 3, Pins("AB9"), IOStandard("LVCMOS15")),
	("user_led", 4, Pins("AE26"), IOStandard("LVCMOS25")),
	("user_led", 5, Pins("G19"), IOStandard("LVCMOS25")),
	("user_led", 6, Pins("E18"), IOStandard("LVCMOS25")),
	("user_led", 7, Pins("F16"), IOStandard("LVCMOS25")),
	
	("cpu_reset", 0, Pins("AB7"), IOStandard("LVCMOS15")),
	
	("user_btn_c", 0, Pins("G12"), IOStandard("LVCMOS25")),
	("user_btn_n", 0, Pins("AA12"), IOStandard("LVCMOS15")),
	("user_btn_s", 0, Pins("AB12"), IOStandard("LVCMOS15")),
	("user_btn_w", 0, Pins("AC6"), IOStandard("LVCMOS15")),
	("user_btn_e", 0, Pins("AG5"), IOStandard("LVCMOS15")),
	
	("user_dip_btn", 0, Pins("Y29"), IOStandard("LVCMOS25")),
	("user_dip_btn", 1, Pins("W29"), IOStandard("LVCMOS25")),
	("user_dip_btn", 2, Pins("AA28"), IOStandard("LVCMOS25")),
	("user_dip_btn", 3, Pins("Y28"), IOStandard("LVCMOS25")),
	
	("clk200", 0,
		Subsignal("p", Pins("AD12"), IOStandard("LVDS")),
		Subsignal("n", Pins("AD11"), IOStandard("LVDS"))
	),
	
	("clk156", 0,
		Subsignal("p", Pins("K28"), IOStandard("LVDS_25")),
		Subsignal("n", Pins("K29"), IOStandard("LVDS_25"))
	),
	
	("i2c", 0,
		Subsignal("scl", Pins("K21")),
		Subsignal("sda", Pins("L21")),
		IOStandard("LVCMOS25")),
	
	("serial", 0,
		Subsignal("cts", Pins("L27")),
		Subsignal("rts", Pins("K23")),
		Subsignal("tx", Pins("K24")),
		Subsignal("rx", Pins("M19")),
		IOStandard("LVCMOS25")),
		
	("mmc", 0,
		Subsignal("wp", Pins("Y21")),
		Subsignal("det", Pins("AA21")),
		Subsignal("cmd", Pins("AB22")),
		Subsignal("clk", Pins("AB23")),
		Subsignal("dat", Pins("AC20 AA23 AA22 AC21")),
		IOStandard("LVCMOS25")),
	
	("lcd", 0,
		Subsignal("db", Pins("AA13 AA10 AA11 Y10")),
		Subsignal("e", Pins("AB10")),
		Subsignal("rs", Pins("Y11")),
		Subsignal("rw", Pins("AB13")),
		IOStandard("LVCMOS15")),
		
	("rotary", 0,
		Subsignal("a", Pins("Y26")),
		Subsignal("b", Pins("Y25")),
		Subsignal("push", Pins("AA26")),
		IOStandard("LVCMOS25")),
	
	("hdmi", 0,
		Subsignal("d", Pins("B23 A23 E23 D23 F25 E25 E24 D24 F26 E26 G23 G24 J19 H19 L17 L18 K19 K20")),
		Subsignal("de", Pins("H17")),
		Subsignal("clk", Pins("K18")),
		Subsignal("vsync", Pins("H20")),
		Subsignal("hsync", Pins("J18")),
		Subsignal("int", Pins("AH24")),
		Subsignal("spdif", Pins("J17")),
		Subsignal("spdif_out", Pins("G20")),
		IOStandard("LVCMOS25")),
]

class Platform(XilinxISEPlatform):
	def __init__(self, crg_factory=lambda p: CRG_DS(p, "user_clk", "cpu_reset", 6.4)):
		XilinxISEPlatform.__init__(self, "xc7k325t-ffg900-1", _io, crg_factory)

########NEW FILE########
__FILENAME__ = lx9_microboard
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

_io = [
		("user_btn", 0, Pins("V4"), IOStandard("LVCMOS33"),
			Misc("PULLDOWN"), Misc("TIG")),

		("user_led", 0, Pins("P4"), Misc("SLEW=QUIETIO"), IOStandard("LVCMOS18")),
		("user_led", 1, Pins("L6"), Misc("SLEW=QUIETIO"), IOStandard("LVCMOS18")),
		("user_led", 2, Pins("F5"), Misc("SLEW=QUIETIO"), IOStandard("LVCMOS18")),
		("user_led", 3, Pins("C2"), Misc("SLEW=QUIETIO"), IOStandard("LVCMOS18")),

		("user_dip", 0, Pins("B3"), Misc("PULLDOWN"), IOStandard("LVCMOS33")),
		("user_dip", 1, Pins("A3"), Misc("PULLDOWN"), IOStandard("LVCMOS33")),
		("user_dip", 2, Pins("B4"), Misc("PULLDOWN"), IOStandard("LVCMOS33")),
		("user_dip", 3, Pins("A4"), Misc("PULLDOWN"), IOStandard("LVCMOS33")),

		# TI CDCE913 programmable triple-output PLL
		("clk_y1", 0, Pins("V10"), IOStandard("LVCMOS33")), # default: 40 MHz
		("clk_y2", 0, Pins("K15"), IOStandard("LVCMOS33")), # default: 66 2/3 MHz
		("clk_y3", 0, Pins("C10"), IOStandard("LVCMOS33")), # default: 100 MHz

		# Maxim DS1088LU oscillator, not populated
		("clk_backup", 0, Pins("R8"), IOStandard("LVCMOS33")),

		# TI CDCE913 PLL I2C control
		("pll", 0,
			Subsignal("scl", Pins("P12")),
			Subsignal("sda", Pins("U13")),
			Misc("PULLUP"),
			IOStandard("LVCMOS33")),

		# Micron N25Q128 SPI Flash
		("spiflash", 0,
			Subsignal("clk", Pins("R15")),
			Subsignal("cs_n", Pins("V3")),
			Subsignal("dq", Pins("T13 R13 T14 V14")),
			IOStandard("LVCMOS33")),

		# PMOD extension connectors
		("pmod", 0,
			Subsignal("d", Pins("F15 F16 C17 C18 F14 G14 D17 D18")),
			IOStandard("LVCMOS33")),
		("pmod", 1,
			Subsignal("d", Pins("H12 G13 E16 E18 K12 K13 F17 F18")),
			IOStandard("LVCMOS33")),

		("pmod_diff", 0,
			Subsignal("io", Pins("F15 C17 F14 D17 H12 E16 K12 F17")),
			Subsignal("iob", Pins("F16 C18 G14 D18 G13 E18 K13 F18")),
			IOStandard("LVCMOS33")),

		("serial", 0,
			Subsignal("tx", Pins("T7"), Misc("SLEW=SLOW")),
			Subsignal("rx", Pins("R7"), Misc("PULLUP")),
			IOStandard("LVCMOS33")),

		("ddram_clock", 0,
			Subsignal("p", Pins("G3")),
			Subsignal("n", Pins("G1")),
			IOStandard("MOBILE_DDR")), # actually DIFF_

		# Micron MT46H32M16LFBF-5 LPDDR
		("ddram", 0,
			Subsignal("a", Pins("J7 J6 H5 L7 F3 H4 H3 H6 "
				"D2 D1 F4 D3 G6")),
			Subsignal("ba", Pins("F2 F1")),
			Subsignal("dq", Pins("L2 L1 K2 K1 H2 H1 J3 J1 "
				"M3 M1 N2 N1 T2 T1 U2 U1")),
			Subsignal("cke", Pins("H7")),
			Subsignal("we_n", Pins("E3")),
			Subsignal("cs_n", Pins("K6")), # NC!
			Subsignal("cas_n", Pins("K5")),
			Subsignal("ras_n", Pins("L5")),
			Subsignal("dm", Pins("K3", "K4")),
			Subsignal("dqs", Pins("L4", "P2")),
			Subsignal("rzq", Pins("N4")),
			IOStandard("MOBILE_DDR")),

		# Nat Semi DP83848J 10/100 Ethernet PHY
		# pull-ups on col and rx_data set phy addr to 11111b
		# and prevent isolate mode (addr 00000b)
		("eth_clocks", 0,
			Subsignal("rx", Pins("L15")),
			Subsignal("tx", Pins("H17")),
			IOStandard("LVCMOS33")),

		("eth", 0,
			Subsignal("col", Pins("M18"), Misc("PULLUP")),
			Subsignal("crs", Pins("N17"), Misc("PULLDOWN")),
			Subsignal("mdc", Pins("M16"), Misc("PULLDOWN")),
			Subsignal("mdio", Pins("L18"), Misc("PULLUP")), # 1k5 ext PULLUP
			Subsignal("rst_n", Pins("T18"), Misc("TIG")),
			Subsignal("rx_data", Pins("T17 N16 N15 P18"), Misc("PULLUP")),
			Subsignal("dv", Pins("P17"), Misc("PULLDOWN")), # MII
			Subsignal("rx_er", Pins("N18"), Misc("PULLUP")), # auto MDIX
			Subsignal("tx_data", Pins("K18 K17 J18 J16")),
			Subsignal("tx_en", Pins("L17")),
			Subsignal("tx_er", Pins("L16")), # NC!
			IOStandard("LVCMOS33")),
		]


class Platform(XilinxISEPlatform):
	bitgen_opt = "-g LCK_cycle:6 -g Binary:Yes -g SPI_buswidth:4"
	ise_commands = """
promgen -w -spi -c FF -p mcs -o {build_name}.mcs -u 0 {build_name}.bit
"""
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx9-2csg324", _io,
				lambda p: CRG_SE(p, "clk_y3", "user_btn"))
		self.add_platform_command("""
CONFIG VCCAUX = "3.3";
""")

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk_y3"), 10)
		except ConstraintError:
			pass

		try:
			eth_clocks = self.lookup_request("eth_clocks")
			self.add_period_constraint(eth_clocks.rx, 40)
			self.add_period_constraint(eth_clocks.tx, 40)
			self.add_platform_command("""
TIMESPEC "TS{phy_tx_clk}_io" = FROM "GRP{phy_tx_clk}" TO "PADS" 10 ns;
TIMESPEC "TS{phy_rx_clk}_io" = FROM "PADS" TO "GRP{phy_rx_clk}" 10 ns;
""", phy_rx_clk=eth_clocks.rx, phy_tx_clk=eth_clocks.tx)
		except ContraintError:
			pass

########NEW FILE########
__FILENAME__ = m1
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

_io = [
	("user_led", 0, Pins("B16"), IOStandard("LVCMOS33"), Drive(24), Misc("SLEW=QUIETIO")),
	("user_led", 1, Pins("A16"), IOStandard("LVCMOS33"), Drive(24), Misc("SLEW=QUIETIO")),

	("user_btn", 0, Pins("AB4"), IOStandard("LVCMOS33")),
	("user_btn", 1, Pins("AA4"), IOStandard("LVCMOS33")),
	("user_btn", 2, Pins("AB5"), IOStandard("LVCMOS33")),
	
	("clk50", 0, Pins("AB11"), IOStandard("LVCMOS33")),

	# When executing softcore code in-place from the flash, we want
	# the flash reset to be released before the system reset.
	("norflash_rst_n", 0, Pins("P22"), IOStandard("LVCMOS33"), Misc("SLEW=FAST"), Drive(8)),
	("norflash", 0,
		Subsignal("adr", Pins("L22 L20 K22 K21 J19 H20 F22",
			"F21 K17 J17 E22 E20 H18 H19 F20",
			"G19 C22 C20 D22 D21 F19 F18 D20 D19")),
		Subsignal("d", Pins("AA20 U14 U13 AA6 AB6 W4 Y4 Y7",
			"AA2 AB2 V15 AA18 AB18 Y13 AA12 AB12"), Misc("PULLDOWN")),
		Subsignal("oe_n", Pins("M22")),
		Subsignal("we_n", Pins("N20")),
		Subsignal("ce_n", Pins("M21")),
		IOStandard("LVCMOS33"), Misc("SLEW=FAST"), Drive(8)
	),
	
	("serial", 0,
		Subsignal("tx", Pins("L17"), IOStandard("LVCMOS33"), Misc("SLEW=SLOW")),
		Subsignal("rx", Pins("K18"), IOStandard("LVCMOS33"), Misc("PULLUP"))
	),
	
	("ddram_clock", 0,
		Subsignal("p", Pins("M3")),
		Subsignal("n", Pins("L4")),
		IOStandard("SSTL2_I")
	),	
	("ddram", 0,
		Subsignal("a", Pins("B1 B2 H8 J7 E4 D5 K7 F5 G6 C1 C3 D1 D2")),
		Subsignal("ba", Pins("A2 E6")),
		Subsignal("cs_n", Pins("F7")),
		Subsignal("cke", Pins("G7")),
		Subsignal("ras_n", Pins("E5")),
		Subsignal("cas_n", Pins("C4")),
		Subsignal("we_n", Pins("D3")),
		Subsignal("dq", Pins("Y2 W3 W1 P8 P7 P6 P5 T4 T3",
			"U4 V3 N6 N7 M7 M8 R4 P4 M6 L6 P3 N4",
			"M5 V2 V1 U3 U1 T2 T1 R3 R1 P2 P1")),
		Subsignal("dm", Pins("E1 E3 F3 G4")),
		Subsignal("dqs", Pins("F1 F2 H5 H6")),
		IOStandard("SSTL2_I")
	),

	("eth_clocks", 0,
		Subsignal("phy", Pins("M20")),
		Subsignal("rx", Pins("H22")),
		Subsignal("tx", Pins("H21")),
		IOStandard("LVCMOS33")
	),
	("eth", 0,
		Subsignal("rst_n", Pins("R22")),
		Subsignal("dv", Pins("V21")),
		Subsignal("rx_er", Pins("V22")),
		Subsignal("rx_data", Pins("U22 U20 T22 T21")),
		Subsignal("tx_en", Pins("N19")),
		Subsignal("tx_er", Pins("M19")),
		Subsignal("tx_data", Pins("M16 L15 P19 P20")),
		Subsignal("col", Pins("W20")),
		Subsignal("crs", Pins("W22")),
		IOStandard("LVCMOS33")
	),

	("vga_out", 0,
		Subsignal("clk", Pins("A11")),
		Subsignal("r", Pins("C6 B6 A6 C7 A7 B8 A8 D9")),
		Subsignal("g", Pins("C8 C9 A9 D7 D8 D10 C10 B10")),
		Subsignal("b", Pins("D11 C12 B12 A12 C13 A13 D14 C14")),
		Subsignal("hsync_n", Pins("A14")),
		Subsignal("vsync_n", Pins("C15")),
		Subsignal("psave_n", Pins("B14")),
		IOStandard("LVCMOS33")
	),

	("mmc", 0,
		Subsignal("clk", Pins("A10")),
		Subsignal("cmd", Pins("B18")),
		Subsignal("dat", Pins("A18 E16 C17 A17")),
		IOStandard("LVCMOS33")
	),

	# Digital video mixer extension board
	("dvi_in", 0,
		Subsignal("clk", Pins("A20")),
		Subsignal("data0_n", Pins("A21")),
		Subsignal("data1", Pins("B21")),
		Subsignal("data2_n", Pins("B22")),
		Subsignal("scl", Pins("G16")),
		Subsignal("sda", Pins("G17")),
		IOStandard("LVCMOS33")
	),
	("dvi_in", 1,
		Subsignal("clk", Pins("H17")),
		Subsignal("data0_n", Pins("H16")),
		Subsignal("data1", Pins("F17")),
		Subsignal("data2_n", Pins("F16")),
		Subsignal("scl", Pins("J16")),
		Subsignal("sda", Pins("K16")),
		IOStandard("LVCMOS33")
	),
	("dvi_pots", 0,
		Subsignal("charge", Pins("A18")),		# SD_DAT0
		Subsignal("blackout", Pins("C17")),		# SD_DAT2
		Subsignal("crossfade", Pins("A17")),	# SD_DAT3
		IOStandard("LVCMOS33")
	)
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx45-fgg484-2", _io,
			lambda p: CRG_SE(p, "clk50", None))

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk50"), 20)
		except ConstraintError:
			pass

		try:
			eth_clocks = self.lookup_request("eth_clocks")
			self.add_period_constraint(eth_clocks.rx, 40)
			self.add_period_constraint(eth_clocks.tx, 40)
			self.add_platform_command("""
TIMESPEC "TS{phy_tx_clk}_io" = FROM "GRP{phy_tx_clk}" TO "PADS" 10 ns;
TIMESPEC "TS{phy_rx_clk}_io" = FROM "PADS" TO "GRP{phy_rx_clk}" 10 ns;
""", phy_rx_clk=eth_clocks.rx, phy_tx_clk=eth_clocks.tx)
		except ConstraintError:
			pass

		for i in range(2):
			si = "dviclk"+str(i)
			try:
				self.add_period_constraint(self.lookup_request("dvi_in", i).clk, 26.7)
			except ConstraintError:
				pass

########NEW FILE########
__FILENAME__ = mixxeo
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

_io = [
	("user_led", 0, Pins("V5"), IOStandard("LVCMOS33"), Drive(24), Misc("SLEW=QUIETIO")),

	("clk50", 0, Pins("AB13"), IOStandard("LVCMOS33")),

	# When executing softcore code in-place from the flash, we want
	# the flash reset to be released before the system reset.
	("norflash_rst_n", 0, Pins("P22"), IOStandard("LVCMOS33"), Misc("SLEW=FAST"), Drive(8)),
	("norflash", 0,
		Subsignal("adr", Pins("L22 L20 K22 K21 J19 H20 F22",
			"F21 K17 J17 E22 E20 H18 H19 F20",
			"G19 C22 C20 D22 D21 F19 F18 D20 D19")),
		Subsignal("d", Pins("AA20 U14 U13 AA6 AB6 W4 Y4 Y7",
			"AA2 AB2 V15 AA18 AB18 Y13 AA12 AB12"), Misc("PULLDOWN")),
		Subsignal("oe_n", Pins("M22")),
		Subsignal("we_n", Pins("N20")),
		Subsignal("ce_n", Pins("M21")),
		IOStandard("LVCMOS33"), Misc("SLEW=FAST"), Drive(8)
	),
	
	("serial", 0,
		Subsignal("tx", Pins("L17"), IOStandard("LVCMOS33"), Misc("SLEW=SLOW")),
		Subsignal("rx", Pins("K18"), IOStandard("LVCMOS33"), Misc("PULLUP"))
	),
	
	("ddram_clock", 0,
		Subsignal("p", Pins("M3")),
		Subsignal("n", Pins("L4")),
		IOStandard("SSTL2_I")
	),	
	("ddram", 0,
		Subsignal("a", Pins("B1 B2 H8 J7 E4 D5 K7 F5 G6 C1 C3 D1 D2")),
		Subsignal("ba", Pins("A2 E6")),
		Subsignal("cs_n", Pins("F7")),
		Subsignal("cke", Pins("G7")),
		Subsignal("ras_n", Pins("E5")),
		Subsignal("cas_n", Pins("C4")),
		Subsignal("we_n", Pins("D3")),
		Subsignal("dq", Pins("Y2 W3 W1 P8 P7 P6 P5 T4 T3",
			"U4 V3 N6 N7 M7 M8 R4 P4 M6 L6 P3 N4",
			"M5 V2 V1 U3 U1 T2 T1 R3 R1 P2 P1")),
		Subsignal("dm", Pins("E1 E3 F3 G4")),
		Subsignal("dqs", Pins("F1 F2 H5 H6")),
		IOStandard("SSTL2_I")
	),

	("eth_clocks", 0,
		Subsignal("phy", Pins("M20")),
		Subsignal("rx", Pins("H22")),
		Subsignal("tx", Pins("H21")),
		IOStandard("LVCMOS33")
	),
	("eth", 0,
		Subsignal("rst_n", Pins("R22")),
		Subsignal("dv", Pins("V21")),
		Subsignal("rx_er", Pins("V22")),
		Subsignal("rx_data", Pins("U22 U20 T22 T21")),
		Subsignal("tx_en", Pins("N19")),
		Subsignal("tx_er", Pins("M19")),
		Subsignal("tx_data", Pins("M16 L15 P19 P20")),
		Subsignal("col", Pins("W20")),
		Subsignal("crs", Pins("W22")),
		IOStandard("LVCMOS33")
	),

	("vga_out", 0,
		Subsignal("clk", Pins("A10")),
		Subsignal("r", Pins("C6 B6 A6 C7 A7 B8 A8 D9")),
		Subsignal("g", Pins("C8 C9 A9 D7 D8 D10 C10 B10")),
		Subsignal("b", Pins("D11 C12 B12 A12 C13 A13 D14 C14")),
		Subsignal("hsync_n", Pins("A14")),
		Subsignal("vsync_n", Pins("C15")),
		Subsignal("psave_n", Pins("B14")),
		IOStandard("LVCMOS33")
	),
	("dvi_out", 0,
		Subsignal("clk_p", Pins("W12"), IOStandard("TMDS_33")),
		Subsignal("clk_n", Pins("Y12"), IOStandard("TMDS_33")),
		Subsignal("data0_p", Pins("Y16"), IOStandard("TMDS_33")),
		Subsignal("data0_n", Pins("W15"), IOStandard("TMDS_33")),
		Subsignal("data1_p", Pins("AA16"), IOStandard("TMDS_33")),
		Subsignal("data1_n", Pins("AB16"), IOStandard("TMDS_33")),
		Subsignal("data2_p", Pins("Y15"), IOStandard("TMDS_33")),
		Subsignal("data2_n", Pins("AB15"), IOStandard("TMDS_33")),
	),

	("mmc", 0,
		Subsignal("clk", Pins("J3")),
		Subsignal("cmd", Pins("K1")),
		Subsignal("dat", Pins("J6 K6 N1 K5")),
		IOStandard("LVCMOS33")
	),

	("dvi_in", 0,
		Subsignal("clk_p", Pins("K20"), IOStandard("TMDS_33")),
		Subsignal("clk_n", Pins("K19"), IOStandard("TMDS_33")),
		Subsignal("data0_p", Pins("B21"), IOStandard("TMDS_33")),
		Subsignal("data0_n", Pins("B22"), IOStandard("TMDS_33")),
		Subsignal("data1_p", Pins("A20"), IOStandard("TMDS_33")),
		Subsignal("data1_n", Pins("A21"), IOStandard("TMDS_33")),
		Subsignal("data2_p", Pins("K16"), IOStandard("TMDS_33")),
		Subsignal("data2_n", Pins("J16"), IOStandard("TMDS_33")),
		Subsignal("scl", Pins("G20"), IOStandard("LVCMOS33")),
		Subsignal("sda", Pins("H16"), IOStandard("LVCMOS33")),
		Subsignal("hpd_notif", Pins("G22"), IOStandard("LVCMOS33")),
		Subsignal("hpd_en", Pins("G17"), IOStandard("LVCMOS33"))
	),
	("dvi_in", 1,
		Subsignal("clk_p", Pins("C11"), IOStandard("TMDS_33")),
		Subsignal("clk_n", Pins("A11"), IOStandard("TMDS_33")),
		Subsignal("data0_p", Pins("B18"), IOStandard("TMDS_33")),
		Subsignal("data0_n", Pins("A18"), IOStandard("TMDS_33")),
		Subsignal("data1_p", Pins("C17"), IOStandard("TMDS_33")),
		Subsignal("data1_n", Pins("A17"), IOStandard("TMDS_33")),
		Subsignal("data2_p", Pins("E16"), IOStandard("TMDS_33")),
		Subsignal("data2_n", Pins("D17"), IOStandard("TMDS_33")),
		Subsignal("scl", Pins("F17"), IOStandard("LVCMOS33")),
		Subsignal("sda", Pins("F16"), IOStandard("LVCMOS33")),
		Subsignal("hpd_notif", Pins("G16"), IOStandard("LVCMOS33")),
		Subsignal("hpd_en", Pins("B20"), IOStandard("LVCMOS33"))
	),
	("dvi_in", 2,
		Subsignal("clk_p", Pins("Y11"), IOStandard("TMDS_33")),
		Subsignal("clk_n", Pins("AB11"), IOStandard("TMDS_33")),
		Subsignal("data0_p", Pins("V11"), IOStandard("TMDS_33")),
		Subsignal("data0_n", Pins("W11"), IOStandard("TMDS_33")),
		Subsignal("data1_p", Pins("AA10"), IOStandard("TMDS_33")),
		Subsignal("data1_n", Pins("AB10"), IOStandard("TMDS_33")),
		Subsignal("data2_p", Pins("R11"), IOStandard("TMDS_33")),
		Subsignal("data2_n", Pins("T11"), IOStandard("TMDS_33")),
		Subsignal("scl", Pins("C16"), IOStandard("LVCMOS33")),
		Subsignal("sda", Pins("B16"), IOStandard("LVCMOS33")),
		Subsignal("hpd_notif", Pins("D6"), IOStandard("LVCMOS33")),
		Subsignal("hpd_en", Pins("A4"), IOStandard("LVCMOS33"))
	),
	("dvi_in", 3,
		Subsignal("clk_p", Pins("J20"), IOStandard("TMDS_33")),
		Subsignal("clk_n", Pins("J22"), IOStandard("TMDS_33")),
		Subsignal("data0_p", Pins("P18"), IOStandard("TMDS_33")),
		Subsignal("data0_n", Pins("R19"), IOStandard("TMDS_33")),
		Subsignal("data1_p", Pins("P17"), IOStandard("TMDS_33")),
		Subsignal("data1_n", Pins("N16"), IOStandard("TMDS_33")),
		Subsignal("data2_p", Pins("M17"), IOStandard("TMDS_33")),
		Subsignal("data2_n", Pins("M18"), IOStandard("TMDS_33")),
		Subsignal("scl", Pins("P21"), IOStandard("LVCMOS33")),
		Subsignal("sda", Pins("N22"), IOStandard("LVCMOS33")),
		Subsignal("hpd_notif", Pins("H17"), IOStandard("LVCMOS33")),
		Subsignal("hpd_en", Pins("C19"), IOStandard("LVCMOS33"))
	),
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx45-fgg484-2", _io,
			lambda p: CRG_SE(p, "clk50", None))
		self.add_platform_command("CONFIG VCCAUX=\"3.3\";\n")

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk50"), 20)
		except ConstraintError:
			pass

		try:
			eth_clocks = self.lookup_request("eth_clocks")
			self.add_period_constraint(eth_clocks.rx, 40)
			self.add_period_constraint(eth_clocks.tx, 40)
			self.add_platform_command("""
TIMESPEC "TS{phy_tx_clk}_io" = FROM "GRP{phy_tx_clk}" TO "PADS" 10 ns;
TIMESPEC "TS{phy_rx_clk}_io" = FROM "PADS" TO "GRP{phy_rx_clk}" 10 ns;
""", phy_rx_clk=eth_clocks.rx, phy_tx_clk=eth_clocks.tx)
		except ConstraintError:
			pass

		for i in range(4):
			try:
				self.add_period_constraint(self.lookup_request("dvi_in", i).clk_p, 12)
			except ConstraintError:
				pass

########NEW FILE########
__FILENAME__ = ml605
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_DS

_io = [
	# System clock (Differential 200MHz)
	("clk200", 0,
		Subsignal("p", Pins("J9"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE")),
		Subsignal("n", Pins("H9"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE"))
	),

	# User clock (66MHz)
	("clk66", 0, Pins("U23"), IOStandard("LVCMOS25")),

	# CPU reset switch
	("cpu_reset", 0, Pins("H10"), IOStandard("SSTL15")),

	# LEDs
	("user_led", 0, Pins("AC22"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 1, Pins("AC24"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 2, Pins("AE22"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 3, Pins("AE23"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 4, Pins("AB23"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 5, Pins("AG23"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 6, Pins("AE24"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),
	("user_led", 7, Pins("AD24"), IOStandard("LVCMOS25"), Misc("SLEW=SLOW")),

	# USB-to-UART
	("serial", 0,
		Subsignal("tx", Pins("J25"), IOStandard("LVCMOS25")),
		Subsignal("rx", Pins("J24"), IOStandard("LVCMOS25"))
	),

	# 10/100/1000 Tri-Speed Ethernet PHY
	("eth_clocks", 0,
		Subsignal("rx", Pins("AP11")),
		Subsignal("tx", Pins("AD12")),
		IOStandard("LVCMOS25")
	),
	("eth", 0,
		Subsignal("rst_n", Pins("AH13")),
		Subsignal("dv", Pins("AM13")),
		Subsignal("rx_er", Pins("AG12")),
		Subsignal("rx_data", Pins("AN13 AF14 AE14 AN12 AM12 AD11 AC12 AC13")),
		Subsignal("tx_en", Pins("AJ10")),
		Subsignal("tx_er", Pins("AH10")),
		Subsignal("tx_data", Pins("AM11 AL11 AG10 AG11 AL10 AM10 AE11 AF11")),
		Subsignal("col", Pins("AK13")),
		Subsignal("crs", Pins("AL13")),
		IOStandard("LVCMOS25")
	)
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6vlx240t-ff1156-1", _io,
			lambda p: CRG_DS(p, "clk200", "user_btn", 5.0))

########NEW FILE########
__FILENAME__ = papilio_pro
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

_io = [
	("user_led", 0, Pins("P112"), IOStandard("LVCMOS33"), Drive(24), Misc("SLEW=QUIETIO")),

	("clk32", 0, Pins("P94"), IOStandard("LVCMOS33")),

	("serial", 0,
		Subsignal("tx", Pins("P105"), IOStandard("LVCMOS33"), Misc("SLEW=SLOW")),
		Subsignal("rx", Pins("P101"), IOStandard("LVCMOS33"), Misc("PULLUP"))
	),

	("spiflash", 0,
		Subsignal("cs_n", Pins("P38")),
		Subsignal("clk", Pins("P70")),
		Subsignal("mosi", Pins("P64")),
		Subsignal("miso", Pins("P65"), Misc("PULLUP")),
		IOStandard("LVCMOS33"), Misc("SLEW=FAST")
	),
	("spiflash2x", 0,
		Subsignal("cs_n", Pins("P38")),
		Subsignal("clk", Pins("P70")),
		Subsignal("dq", Pins("P64", "P65")),
		IOStandard("LVCMOS33"), Misc("SLEW=FAST")
	),

	("sdram_clock", 0, Pins("P32"), IOStandard("LVCMOS33"), Misc("SLEW=FAST")),
	("sdram", 0,
		Subsignal("a", Pins("P140 P139 P138 P137 P46 P45 P44",
		  "P43 P41 P40 P141 P35 P34")),
		Subsignal("ba", Pins("P143 P142")),
		Subsignal("cs_n", Pins("P1")),
		Subsignal("cke", Pins("P33")),
		Subsignal("ras_n", Pins("P2")),
		Subsignal("cas_n", Pins("P5")),
		Subsignal("we_n", Pins("P6")),
		Subsignal("dq", Pins("P9 P10 P11 P12 P14 P15 P16 P8 P21 P22 P23 P24 P26 P27 P29 P30")),
		Subsignal("dm", Pins("P7 P17")),
		IOStandard("LVCMOS33"), Misc("SLEW=FAST")
	)
]

_connectors = [
	("A", "P48 P51 P56 P58 P61 P66 P67 P75 P79 P81 P83 P85 P88 P93 P98 P100"),
	("B", "P99 P97 P92 P87 P84 P82 P80 P78 P74 P95 P62 P59 P57 P55 P50 P47"),
	("C", "P114 P115 P116 P117 P118 P119 P120 P121 P123 P124 P126 P127 P131 P132 P133 P134")
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx9-tqg144-2", _io,
			lambda p: CRG_SE(p, "clk32", None), _connectors)

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk32"), 31.25)
		except ConstraintError:
			pass

########NEW FILE########
__FILENAME__ = rhino
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_DS

_io = [
	("user_led", 0, Pins("Y3")),
	("user_led", 1, Pins("Y1")),
	("user_led", 2, Pins("W2")),
	("user_led", 3, Pins("W1")),
	("user_led", 4, Pins("V3")),
	("user_led", 5, Pins("V1")),
	("user_led", 6, Pins("U2")),
	("user_led", 7, Pins("U1")),
	
	("clk100", 0,
		Subsignal("p", Pins("B14"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE")),
		Subsignal("n", Pins("A14"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE"))
	),
	
	("gpio", 0, Pins("R8")),
	
	("gpmc", 0, 
		Subsignal("clk", Pins("R26")),
		Subsignal("a", Pins("N17 N18 L23 L24 N19 N20 N21 N22 P17 P19")),
		Subsignal("d", Pins("N23 N24 R18 R19 P21 P22 R20 R21 P24 P26 R23 R24 T22 T23 U23 R25")),
		Subsignal("we_n", Pins("W26")),
		Subsignal("oe_n", Pins("AA25")),
		Subsignal("ale_n", Pins("AA26")),
		Subsignal("wait", Pins("AD26")), # WAIT1/BUSY0
		IOStandard("LVCMOS33")),
	# Warning: CS are numbered 1-7 on ARM side and 0-6 on FPGA side.
	# Numbers here are given on the FPGA side.
	("gpmc_ce_n", 0, Pins("V23"), IOStandard("LVCMOS33")), # nCS0
	("gpmc_ce_n", 1, Pins("U25"), IOStandard("LVCMOS33")), # nCS1
	("gpmc_ce_n", 2, Pins("W25"), IOStandard("LVCMOS33")), # nCS6
	("gpmc_dmareq_n", 0, Pins("T24"), IOStandard("LVCMOS33")), # nCS2
	("gpmc_dmareq_n", 1, Pins("T26"), IOStandard("LVCMOS33")), # nCS3
	("gpmc_dmareq_n", 2, Pins("V24"), IOStandard("LVCMOS33")), # nCS4
	("gpmc_dmareq_n", 3, Pins("V26"), IOStandard("LVCMOS33")), # nCS5
	
	# FMC150
	("fmc150_ctrl", 0,
		Subsignal("spi_sclk", Pins("AE5")),
		Subsignal("spi_data", Pins("AF5")),
		
		Subsignal("adc_sdo", Pins("U13")),
		Subsignal("adc_en_n", Pins("AA15")),
		Subsignal("adc_reset", Pins("V13")),
		
		Subsignal("cdce_sdo", Pins("AA8")),
		Subsignal("cdce_en_n", Pins("Y9")),
		Subsignal("cdce_reset_n", Pins("AB7")),
		Subsignal("cdce_pd_n", Pins("AC6")),
		Subsignal("cdce_pll_status", Pins("W7")),
		Subsignal("cdce_ref_en", Pins("W8")),
		
		Subsignal("dac_sdo", Pins("W9")),
		Subsignal("dac_en_n", Pins("W10")),
		
		Subsignal("mon_sdo", Pins("AC5")),
		Subsignal("mon_en_n", Pins("AD6")),
		Subsignal("mon_reset_n", Pins("AF6")),
		Subsignal("mon_int_n", Pins("AD5")),
		
		Subsignal("pg_c2m", Pins("AA23"), IOStandard("LVCMOS33"))
	),
	("ti_dac", 0, # DAC3283
		Subsignal("dat_p", Pins("AA10 AA9 V11 Y11 W14 Y12 AD14 AE13"), IOStandard("LVDS_25")),
		Subsignal("dat_n", Pins("AB11 AB9 V10 AA11 Y13 AA12 AF14 AF13"), IOStandard("LVDS_25")),
		Subsignal("frame_p", Pins("AB13"), IOStandard("LVDS_25")),
		Subsignal("frame_n", Pins("AA13"), IOStandard("LVDS_25")),
		Subsignal("txenable", Pins("AB15"), IOStandard("LVCMOS25"))
	),
	("ti_adc", 0, # ADS62P49
		Subsignal("dat_a_p", Pins("AB14 Y21 W20 AB22 V18 W17 AA21")),
		Subsignal("dat_a_n", Pins("AC14 AA22 Y20 AC22 W19 W18 AB21")),
		Subsignal("dat_b_p", Pins("Y17 U15 AA19 W16 AA18 Y15 V14")),
		Subsignal("dat_b_n", Pins("AA17 V16 AB19 Y16 AB17 AA16 V15")),
		IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE")
	),
	("fmc150_clocks", 0,
		Subsignal("dac_clk_p", Pins("V12"), IOStandard("LVDS_25")),
		Subsignal("dac_clk_n", Pins("W12"), IOStandard("LVDS_25")),
		Subsignal("adc_clk_p", Pins("AE15"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE")),
		Subsignal("adc_clk_n", Pins("AF15"), IOStandard("LVDS_25"), Misc("DIFF_TERM=TRUE")),
		Subsignal("clk_to_fpga", Pins("W24"), IOStandard("LVCMOS25"))
	),
	
	("fmc150_ext_trigger", 0, Pins("U26")),
	
	# Vermeer radar testbed
	# Switch controller
	("pca9555", 0,
		Subsignal("sda", Pins("C13")),
		Subsignal("scl", Pins("G8")),
		IOStandard("LVCMOS33")
	),
	# TX path
	("pe43602", 0,
		Subsignal("d", Pins("H8")),
		Subsignal("clk", Pins("B3")),
		Subsignal("le", Pins("F7")),
		IOStandard("LVCMOS33")
	),
	("rfmd2081", 0,
		Subsignal("enx", Pins("E5")),
		Subsignal("sclk", Pins("G6")),
		Subsignal("sdata", Pins("F5")),
		Subsignal("locked", Pins("E6")),
		IOStandard("LVCMOS33")
	),
	# RX path
	("lmh6521", 0,
		Subsignal("scsb", Pins("C5")),
		Subsignal("sclk", Pins("G10")),
		Subsignal("sdi", Pins("D5")),
		Subsignal("sdo", Pins("F9")),
		IOStandard("LVCMOS33")
	),
	("lmh6521", 1,
		Subsignal("scsb", Pins("E10")),
		Subsignal("sclk", Pins("A4")),
		Subsignal("sdi", Pins("B4")),
		Subsignal("sdo", Pins("H10")),
		IOStandard("LVCMOS33")
	),
	("rffc5071", 0,
		Subsignal("enx", Pins("A2")),
		Subsignal("sclk", Pins("G9")),
		Subsignal("sdata", Pins("H9")),
		Subsignal("locked", Pins("A3")),
		IOStandard("LVCMOS33")
	)
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx150t-fgg676-3", _io,
			lambda p: CRG_DS(p, "clk100", "gpio", 10.0))

########NEW FILE########
__FILENAME__ = roach
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform

_io = [
	("epb", 0,
		Subsignal("cs_n", Pins("K13")),
		Subsignal("r_w_n", Pins("AF20")),
		Subsignal("be_n", Pins("AF14 AF18")),
		Subsignal("oe_n", Pins("AF21")),
		Subsignal("addr", Pins("AE23 AE22 AG18 AG12 AG15 AG23 AF19 AE12 AG16 AF13 AG20 AF23", 
			"AH17 AH15 L20 J22 H22 L15 L16 K22 K21 K16 J15")),
		Subsignal("addr_gp", Pins("L21 G22 K23 K14 L14 J12")),
		Subsignal("data", Pins("AF15 AE16 AE21 AD20 AF16 AE17 AE19 AD19 AG22 AH22 AH12 AG13",
			"AH20 AH19 AH14 AH13")),
		Subsignal("rdy", Pins("K12")),
		IOStandard("LVCMOS33")
	),
	("roach_clocks", 0,
		Subsignal("epb_clk", Pins("AH18"), IOStandard("LVCMOS33")),
		Subsignal("sys_clk_n", Pins("H13")),
		Subsignal("sys_clk_p", Pins("J14")),
		Subsignal("aux0_clk_p", Pins("G15")),
		Subsignal("aux0_clk_n", Pins("G16")),
		Subsignal("aux1_clk_p", Pins("H14")),
		Subsignal("aux1_clk_n", Pins("H15")),
		Subsignal("dly_clk_n", Pins("J17")),
		Subsignal("dly_clk_p", Pins("J16")),
	),
]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc5vsx95t-ff1136-1", _io)

########NEW FILE########
__FILENAME__ = usrp_b100
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_DS

_io = [
		("clk64", 0,
			Subsignal("p", Pins("R7")),
			Subsignal("n", Pins("T7")),
			IOStandard("LVDS_33"),
			Misc("DIFF_TERM=TRUE"),
		),

		("pps", 0, Pins("M14"), Misc("TIG")),
		("reset_n", 0, Pins("D5"), Misc("TIG")),
		("codec_reset", 0, Pins("B14")),
		# recycles fpga_cfg_cclk for reset from fw
		("ext_reset", 0, Pins("R14")),

		("i2c", 0,
			Subsignal("sda", Pins("T13")),
			Subsignal("scl", Pins("R13")),
		),

		("cgen", 0,
			Subsignal("st_ld", Pins("M13")),
			Subsignal("st_refmon", Pins("J14")),
			Subsignal("st_status", Pins("P6")),
			Subsignal("ref_sel", Pins("T2")),
			Subsignal("sync_b", Pins("H15")),
		),

		("fx2_ifclk", 0, Pins("T8")),
		("fx2_gpif", 0,
			Subsignal("d", Pins("P8 P9 N9 T9 R9 P11 P13 N12 "
								"T3 R3 P5 N6 T6 T5 N8 P7")),
			Subsignal("ctl", Pins("M7 M9 M11 P12")),
			Subsignal("slwr", Pins("T4")), # rdy0
			Subsignal("slrd", Pins("R5")), # rdy1
			#Subsignal("rdy2", Pins("T10")),
			#Subsignal("rdy3", Pins("N11")),
			#Subsignal("cs", Pins("P12")),
			Subsignal("sloe", Pins("R11")),
			Subsignal("pktend", Pins("P10")),
			Subsignal("adr", Pins("T11 H16")),
		),

		("user_led", 0, Pins("P4"), Misc("TIG")),
		("user_led", 1, Pins("N4"), Misc("TIG")),
		("user_led", 2, Pins("R2"), Misc("TIG")),

		("debug_clk", 0, Pins("K15 K14")),
		("debug", 0, Pins(
			"K16 J16 C16 C15 E13 D14 D16 D15 "
			"E14 F13 G13 F14 E16 F15 H13 G14 "
			"G16 F16 J12 J13 L14 L16 M15 M16 "
			"L13 K13 P16 N16 R15 P15 N13 N14")),

		("adc", 0, 
			Subsignal("sync", Pins("D10")),
			Subsignal("d", Pins("A4 B3 A3 D9 C10 A9 C9 D8 "
								"C8 B8 A8 B15")),
		),
		("dac", 0,
			Subsignal("blank", Pins("K1")),
			Subsignal("sync", Pins("J2")),
			Subsignal("d", Pins("J1 H3 J3 G2 H1 N3 M4 R1 "
								"P2 P1 M1 N1 M3 L4")),
		),
		("codec_spi", 0,
			Subsignal("sclk", Pins("K3")),
			Subsignal("sen", Pins("D13")),
			Subsignal("mosi", Pins("C13")),
			Subsignal("miso", Pins("G4")),
		),

		("aux_spi", 0,
			Subsignal("sen", Pins("C12")),
			Subsignal("sclk", Pins("D12")),
			Subsignal("miso", Pins("J5")),
		),
		("rx_io", 0, Pins("D7 C6 A6 B6 E9 A7 C7 B10 "
						  "A10 C11 A11 D11 B12 A12 A14 A13")),
		("tx_io", 0, Pins("K4 L3 L2 F1 F3 G3 E3 E2 "
						  "E4 F4 D1 E1 D4 D3 C2 C1")),
		("rx_spi", 0,
			Subsignal("miso", Pins("E6")),
			Subsignal("sen", Pins("B4")),
			Subsignal("mosi", Pins("A5")),
			Subsignal("sclk", Pins("C5")),
		),
		("tx_spi", 0,
			Subsignal("miso", Pins("J4")),
			Subsignal("sen", Pins("N2")),
			Subsignal("mosi", Pins("L1")),
			Subsignal("sclk", Pins("G1")),
		),

		# these are just for information. do not request.
		("mystery_bus", 0, Pins("C4 E7")),
		("fpga_cfg",
			Subsignal("din", Pins("T14")),
			Subsignal("cclk", Pins("R14")),
			Subsignal("init_b", Pins("T12")),
			Subsignal("prog_b", Pins("A2")),
			Subsignal("done", Pins("T15")),
		),
		("jtag",
			Subsignal("tms", Pins("B2")),
			Subsignal("tdo", Pins("B16")),
			Subsignal("tdi", Pins("B1")),
			Subsignal("tck", Pins("A15")),
		),
]


class Platform(XilinxISEPlatform):
	bitgen_opt = "-g LCK_cycle:6 -g Binary:Yes -g UnusedPin:PullUp"
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc3s1400a-ft256-4", _io,
			lambda p: CRG_DS(p, "clk64", "reset_n", rst_invert=True))

	def do_finalize(self, fragment):
		try:
			self.add_platform_command("""
NET "{clk64}" TNM_NET = "GRPclk64";
TIMESPEC "TSclk64" = PERIOD "GRPclk64" 15.625 ns HIGH 50%;
""", clk64=self.lookup_request("clk64"))
		except ConstraintError:
			pass

		self.add_platform_command("""
TIMESPEC TS_Pad2Pad = FROM PADS TO PADS 7 ns;
""")

		try:
			ifclk = self.lookup_request("fx2_ifclk")
			gpif = self.lookup_request("fx2_gpif")
			for i, d in [(gpif.d, "in"), (gpif.d, "out"),
					(gpif.ctl, "in"), (gpif.adr, "out"),
					(gpif.slwr, "out"), (gpif.sloe, "out"),
					(gpif.slrd, "out"), (gpif.pktend, "out")]:
				if flen(i) > 1:
					q = "(*)"
				else:
					q = ""
				self.add_platform_command("""
INST "{i}%s" TNM = gpif_net_%s;
""" % (q, d), i=i)
			self.add_platform_command("""
NET "{ifclk}" TNM_NET = "GRPifclk";
TIMESPEC "TSifclk" = PERIOD "GRPifclk" 20833 ps HIGH 50%;
TIMEGRP "gpif_net_in" OFFSET = IN 5 ns VALID 10 ns BEFORE "{ifclk}" RISING;
TIMEGRP "gpif_net_out" OFFSET = OUT 7 ns AFTER "{ifclk}" RISING;
""", ifclk=ifclk)
		except ConstraintError:
 			pass

########NEW FILE########
__FILENAME__ = zedboard
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

# Bank 34 and 35 voltage depend on J18 jumper setting
_io = [
		("clk100", 0, Pins("Y9"), IOStandard("LVCMOS33")),

		("user_btn", 0, Pins("P16"), IOStandard("LVCMOS18")), # center
		("user_btn", 1, Pins("R16"), IOStandard("LVCMOS18")), # down
		("user_btn", 2, Pins("N15"), IOStandard("LVCMOS18")), # left
		("user_btn", 3, Pins("R18"), IOStandard("LVCMOS18")), # right
		("user_btn", 4, Pins("T18"), IOStandard("LVCMOS18")), # up

		("user_sw", 0, Pins("F22"), IOStandard("LVCMOS18")),
		("user_sw", 1, Pins("G22"), IOStandard("LVCMOS18")),
		("user_sw", 2, Pins("H22"), IOStandard("LVCMOS18")),
		("user_sw", 3, Pins("F21"), IOStandard("LVCMOS18")),
		("user_sw", 4, Pins("H19"), IOStandard("LVCMOS18")),
		("user_sw", 5, Pins("H18"), IOStandard("LVCMOS18")),
		("user_sw", 6, Pins("H17"), IOStandard("LVCMOS18")),
		("user_sw", 7, Pins("M15"), IOStandard("LVCMOS18")),

		("user_led", 0, Pins("T22"), IOStandard("LVCMOS33")),
		("user_led", 1, Pins("T21"), IOStandard("LVCMOS33")),
		("user_led", 2, Pins("U22"), IOStandard("LVCMOS33")),
		("user_led", 3, Pins("U21"), IOStandard("LVCMOS33")),
		("user_led", 4, Pins("V22"), IOStandard("LVCMOS33")),
		("user_led", 5, Pins("W22"), IOStandard("LVCMOS33")),
		("user_led", 6, Pins("U19"), IOStandard("LVCMOS33")),
		("user_led", 7, Pins("U14"), IOStandard("LVCMOS33")),

		# A
		("pmod", 0, Pins("Y11 AA11 Y10 AA9 AB11 AB10 AB9 AA8"),
			IOStandard("LVCMOS33")),
		# B
		("pmod", 1, Pins("W12 W11 V10 W8 V12 W10 V9 V8"),
			IOStandard("LVCMOS33")),
		# C
		("pmod", 2,
			Subsignal("n", Pins("AB6 AA4 T6 U4")),
			Subsignal("p", Pins("AB7 Y4 R6 T4")),
			IOStandard("LVCMOS33")),
		# D
		("pmod", 3,
			Subsignal("n", Pins("W7 V4 W5 U5")),
			Subsignal("p", Pins("V7 V5 W6 U6")),
			IOStandard("LVCMOS33")),

		("audio", 0,
			Subsignal("adr", Pins("AB1 Y5")),
			Subsignal("gpio", Pins("Y8 AA7 AA6 Y6")),
			Subsignal("mclk", Pins("AB2")),
			Subsignal("sck", Pins("AB4")),
			Subsignal("sda", Pins("AB5")),
			IOStandard("LVCMOS33")),

		("oled", 0,
			Subsignal("dc", Pins("U10")),
			Subsignal("res", Pins("U9")),
			Subsignal("sclk", Pins("AB12")),
			Subsignal("sdin", Pins("AA12")),
			Subsignal("vbat", Pins("U11")),
			Subsignal("vdd", Pins("U12")),
			IOStandard("LVCMOS33")),

		("hdmi", 0,
			Subsignal("clk", Pins("W18")),
			Subsignal("d", Pins(
				"Y13 AA13 AA14 Y14 AB15 AB16 AA16 AB17 "
				"AA17 Y15 W13 W15 V15 U17 V14 V13")),
			Subsignal("de", Pins("U16")),
			Subsignal("hsync", Pins("V17")),
			Subsignal("vsync", Pins("W17")),
			Subsignal("int", Pins("W16")),
			Subsignal("scl", Pins("AA18")),
			Subsignal("sda", Pins("Y16")),
			Subsignal("spdif", Pins("U15")),
			Subsignal("spdifo", Pins("Y18")),
			IOStandard("LVCMOS33")),

		("netic16", 0,
			Subsignal("w20", Pins("W20")),
			Subsignal("w21", Pins("W21")),
			IOStandard("LVCMOS33")),

		("vga", 0,
			Subsignal("r", Pins("V20 U20 V19 V18")),
			Subsignal("g", Pins("AB22 AA22 AB21 AA21")),
			Subsignal("b", Pins("Y21 Y20 AB20 AB19")),
			Subsignal("hsync_n", Pins("AA19")),
			Subsignal("vsync_n", Pins("Y19")),
			IOStandard("LVCMOS33")),

		("usb_otg", 0,
			Subsignal("vbusoc", Pins("L16")),
			Subsignal("reset_n", Pins("G17")),
			IOStandard("LVCMOS18")),

		("pudc_b", 0, Pins("K16"), IOStandard("LVCMOS18")),

		("xadc", 0,
			Subsignal("gio", Pins("H15 R15 K15 J15")),
			Subsignal("ad0_n", Pins("E16")),
			Subsignal("ad0_p", Pins("F16")),
			Subsignal("ad8_n", Pins("D17")),
			Subsignal("ad8_p", Pins("D16")),
			IOStandard("LVCMOS18")),

		("fmc_clocks", 0,
			Subsignal("clk0_n", Pins("L19")),
			Subsignal("clk0_p", Pins("L18")),
			Subsignal("clk1_n", Pins("C19")),
			Subsignal("clk1_p", Pins("D18")),
			IOStandard("LVCMOS18")),

		("fmc", 0,
			Subsignal("scl", Pins("R7")),
			Subsignal("sda", Pins("U7")),

			Subsignal("prsnt", Pins("AB14")),

			# 0, 1, 17, 18 can be clock signals
			Subsignal("la_n", Pins(
				"M20 N20 P18 P22 M22 K18 L22 T17 "
				"J22 R21 T19 N18 P21 M17 K20 J17 "
				"K21 B20 C20 G16 G21 E20 F19 D15 "
				"A19 C22 E18 D21 A17 C18 B15 B17 "
				"A22 B22")),
			Subsignal("la_p", Pins(
				"M19 N19 P17 N22 M21 J18 L21 T16 "
				"J21 R20 R19 N17 P20 L17 K19 J16 "
				"J20 B19 D20 G15 G20 E19 G19 E15 "
				"A18 D22 F18 E21 A16 C17 C15 B16 "
				"A21 B21")),
			IOStandard("LVCMOS18")),
]


class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc7z020-clg484-1", _io,
			lambda p: CRG_SE(p, "clk100", None))

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk100"), 10)
		except ConstraintError:
			pass

########NEW FILE########
__FILENAME__ = ztex_115d
from mibuild.generic_platform import *
from mibuild.xilinx_ise import XilinxISEPlatform, CRG_SE

_io = [
		("clk_fx", 0, Pins("L22"), IOStandard("LVCMOS33")),
		("clk_if", 0, Pins("K20"), IOStandard("LVCMOS33")),
		("rst", 0, Pins("A18")),
		# PROG_B and DONE: AA1 U16

		("fx2", 0,
			Subsignal("sloe", Pins("U15"), Drive(12)), # M1
			Subsignal("slrd", Pins("N22"), Drive(12)),
			Subsignal("slwr", Pins("M22"), Drive(12)),
			Subsignal("pktend", Pins("AB5"), Drive(12)), # CSO
			Subsignal("fifoadr", Pins("W17 Y18"), Drive(12)), # CCLK M0
			Subsignal("cont", Pins("G20")),
			Subsignal("fd", Pins("Y17 V13 W13 AA8 AB8 W6 Y6 Y9 "
				"V21 V22 U20 U22 R20 R22 P18 P19")),
			Subsignal("flag", Pins("F20 F19 F18 AB17")), # - - - CSI/MOSI
			Subsignal("rdy25", Pins("M21 K21 K22 J21")),
			Subsignal("ctl35", Pins("D19 E20 N20")),
			Subsignal("int45", Pins("C18 V17")),
			Subsignal("pc", Pins("G20 T10 V5 AB9 G19 H20 H19 H18")),
			# - DOUT/BUSY INIT_B RDWR_B DO CS CLK DI
			IOStandard("LVCMOS33")),

		("mm", 0,
			Subsignal("a", Pins("M20 M19 M18 N19 T19 T21 T22 R19 ",
						"P20 P21 P22 J22 H21 H22 G22 F21")),
			Subsignal("d", Pins("D20 C20 C19 B21 B20 J19 K19 L19"), Drive(2)),
			Subsignal("wr_n", Pins("C22")),
			Subsignal("rd_n", Pins("D21")),
			Subsignal("psen_n", Pins("D22")),
			IOStandard("LVCMOS33")),

		("serial", 0,
			Subsignal("tx", Pins("B22"), Misc("SLEW=QUIETIO")),
			Subsignal("rx", Pins("A21"), Misc("PULLDOWN")),
			IOStandard("LVCMOS33")),

		("ddram_clock", 0,
			Subsignal("p", Pins("F2"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("n", Pins("F1"), Misc("OUT_TERM=UNTUNED_50")),
			IOStandard("SSTL18_II")),

		("ddram", 0,
			Subsignal("dqs", Pins("L3 T2"), IOStandard("SSTL18_II"), # DIFF_
					Misc("IN_TERM=NONE")),
			Subsignal("dqs_n", Pins("L1 T1"), IOStandard("SSTL18_II"), # DIFF_
					Misc("IN_TERM=NONE")),
			Subsignal("dm", Pins("H1 H2"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("dq", Pins("M1 M2 J1 K2 J3 K1 N3 N1 "
					"U1 U3 P1 R3 P2 R1 V2 V1"), Misc("IN_TERM=NONE")),
			Subsignal("ras_n", Pins("N4"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("cas_n", Pins("P3"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("a", Pins("M5 K6 B1 J4 L4 K3 M4 K5 G3 G1 K4 C3 C1"),
					Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("ba", Pins("E3 E1 D1"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("cke", Pins("J6"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("cs_n", Pins("H6")), # NC!
			Subsignal("odt", Pins("M3"), Misc("OUT_TERM=UNTUNED_50")),
			Subsignal("we_n", Pins("D2")),
			Subsignal("rzq", Pins("AA2")),
			Subsignal("zio", Pins("Y2")),
			IOStandard("SSTL18_II")),

		("i2c", 0,
			Subsignal("scl", Pins("F22")),
			Subsignal("sda", Pins("E22")),
			IOStandard("LVCMOS33")),

		("sd", 0,
			Subsignal("sck", Pins("H11")),
			Subsignal("d3", Pins("H14")),
			Subsignal("d", Pins("P10")),
			Subsignal("d1", Pins("T18")),
			Subsignal("d2", Pins("R17")),
			Subsignal("cmd", Pins("H13")),
			IOStandard("LVCMOS33")),

]

class Platform(XilinxISEPlatform):
	def __init__(self):
		XilinxISEPlatform.__init__(self, "xc6slx150-3csg484", _io,
				lambda p: CRG_SE(p, "clk_if", "rst"))
		self.add_platform_command("""
CONFIG VCCAUX = "2.5";
""")

	def do_finalize(self, fragment):
		try:
			self.add_period_constraint(self.lookup_request("clk_if"), 20)
		except ConstraintError:
			pass

		try:
			clk_if = self.lookup_request("clk_if")
			clk_fx = self.lookup_request("clk_fx")
			self.add_platform_command("""
NET "{clk_if}" TNM_NET = "GRPclk_if";
NET "{clk_fx}" TNM_NET = "GRPclk_fx";
TIMESPEC "TSclk_fx" = PERIOD "GRPclk_fx" 20.83333 ns HIGH 50%;
TIMESPEC "TSclk_if" = PERIOD "GRPclk_if" 20 ns HIGH 50%;
TIMESPEC "TSclk_fx2if" = FROM "GRPclk_fx" TO "GRPclk_if" 3 ns DATAPATHONLY;
TIMESPEC "TSclk_if2fx" = FROM "GRPclk_if" TO "GRPclk_fx" 3 ns DATAPATHONLY;
""", clk_if=clk_if, clk_fx=clk_fx)
		except ContraintError:
			pass

########NEW FILE########
__FILENAME__ = tools
import os

def mkdir_noerror(d):
	try:
		os.mkdir(d)
	except OSError:
		pass

def language_by_filename(name):
	extension = name.rsplit(".")[-1] 
	if extension in ["v", "vh", "vo"]:
		return "verilog"
	if extension in ["vhd", "vhdl", "vho"]:
		return "vhdl"
	return None

def write_to_file(filename, contents, force_unix=False):
	newline = None
	if force_unix:
		newline = "\n"
	f = open(filename, "w", newline=newline)
	f.write(contents)
	f.close()

########NEW FILE########
__FILENAME__ = xilinx_ise
import os, struct, subprocess, sys
from decimal import Decimal

from migen.fhdl.std import *
from migen.fhdl.specials import SynthesisDirective
from migen.genlib.cdc import *
from migen.fhdl.structure import _Fragment

from mibuild.generic_platform import *
from mibuild.crg import SimpleCRG
from mibuild import tools

class CRG_SE(SimpleCRG):
	def __init__(self, platform, clk_name, rst_name, period=None, rst_invert=False):
		SimpleCRG.__init__(self, platform, clk_name, rst_name, rst_invert)
		platform.add_period_constraint(platform, self._clk, period)

class CRG_DS(Module):
	def __init__(self, platform, clk_name, rst_name, period=None, rst_invert=False):
		reset_less = rst_name is None
		self.clock_domains.cd_sys = ClockDomain(reset_less=reset_less)
		self._clk = platform.request(clk_name)
		platform.add_period_constraint(platform, self._clk.p, period)
		self.specials += Instance("IBUFGDS",
			Instance.Input("I", self._clk.p),
			Instance.Input("IB", self._clk.n),
			Instance.Output("O", self.cd_sys.clk)
		)
		if not reset_less:
			if rst_invert:
				self.comb += self.cd_sys.rst.eq(~platform.request(rst_name))
			else:
				self.comb += self.cd_sys.rst.eq(platform.request(rst_name))

def _format_constraint(c):
	if isinstance(c, Pins):
		return "LOC=" + c.identifiers[0]
	elif isinstance(c, IOStandard):
		return "IOSTANDARD=" + c.name
	elif isinstance(c, Drive):
		return "DRIVE=" + str(c.strength)
	elif isinstance(c, Misc):
		return c.misc

def _format_ucf(signame, pin, others, resname):
	fmt_c = []
	for c in [Pins(pin)] + others:
		fc = _format_constraint(c)
		if fc is not None:
			fmt_c.append(fc)
	fmt_r = resname[0] + ":" + str(resname[1])
	if resname[2] is not None:
		fmt_r += "." + resname[2]
	return "NET \"" + signame + "\" " + " | ".join(fmt_c) + "; # " + fmt_r + "\n"

def _build_ucf(named_sc, named_pc):
	r = ""
	for sig, pins, others, resname in named_sc:
		if len(pins) > 1:
			for i, p in enumerate(pins):
				r += _format_ucf(sig + "(" + str(i) + ")", p, others, resname)
		else:
			r += _format_ucf(sig, pins[0], others, resname)
	if named_pc:
		r += "\n" + "\n\n".join(named_pc)
	return r

def _build_xst_files(device, sources, vincpaths, build_name, xst_opt):
	prj_contents = ""
	for filename, language in sources:
		prj_contents += language + " work " + filename + "\n"
	tools.write_to_file(build_name + ".prj", prj_contents)

	xst_contents = """run
-ifn {build_name}.prj
-top top
{xst_opt}
-ofn {build_name}.ngc
-p {device}
""".format(build_name=build_name, xst_opt=xst_opt, device=device)
	for path in vincpaths:
		xst_contents += "-vlgincdir " + path + "\n"
	tools.write_to_file(build_name + ".xst", xst_contents)

def _run_yosys(device, sources, vincpaths, build_name):
	ys_contents = ""
	incflags = ""
	for path in vincpaths:
		incflags += " -I" + path
	for filename, language in sources:
		ys_contents += "read_{}{} {}\n".format(language, incflags, filename)
	
	if device[:2] == "xc":
		archcode = device[2:4]
	else:
		archcode = device[0:2]
	arch = {
		"6s": "spartan6",
		"7a": "artix7",
		"7k": "kintex7",
		"7v": "virtex7",
		"7z": "zynq7000"
	}[archcode]
	
	ys_contents += """hierarchy -check -top top
proc; memory; opt; fsm; opt
synth_xilinx -arch {arch} -top top -edif {build_name}.edif""".format(arch=arch, build_name=build_name)
	
	ys_name = build_name + ".ys"
	tools.write_to_file(ys_name, ys_contents)
	r = subprocess.call(["yosys", ys_name])
	if r != 0:
		raise OSError("Subprocess failed")

def _is_valid_version(path, v):
	try: 
		Decimal(v)
		return os.path.isdir(os.path.join(path, v))
	except:
		return False

def _run_ise(build_name, ise_path, source, mode, ngdbuild_opt,
		bitgen_opt, ise_commands, map_opt, par_opt):
	if sys.platform == "win32" or sys.platform == "cygwin":
		source = False
	build_script_contents = "# Autogenerated by mibuild\nset -e\n"
	if source:
		vers = [ver for ver in os.listdir(ise_path) if _is_valid_version(ise_path, ver)]
		tools_version = max(vers)
		bits = struct.calcsize("P")*8
		
		xilinx_settings_file = os.path.join(ise_path, tools_version, "ISE_DS", "settings{0}.sh".format(bits))
		if not os.path.exists(xilinx_settings_file) and bits == 64:
			# if we are on 64-bit system but the toolchain isn't, try the 32-bit env.
			xilinx_settings_file = os.path.join(ise_path, tools_version, "ISE_DS", "settings32.sh")
		build_script_contents += "source " + xilinx_settings_file + "\n"
	if mode == "edif":
		ext = "edif"
	else:
		ext = "ngc"
		build_script_contents += """
xst -ifn {build_name}.xst"""

	build_script_contents += """
ngdbuild {ngdbuild_opt} -uc {build_name}.ucf {build_name}.{ext} {build_name}.ngd
map {map_opt} -o {build_name}_map.ncd {build_name}.ngd {build_name}.pcf
par {par_opt} {build_name}_map.ncd {build_name}.ncd {build_name}.pcf
bitgen {bitgen_opt} {build_name}.ncd {build_name}.bit
"""
	build_script_contents = build_script_contents.format(build_name=build_name,
			ngdbuild_opt=ngdbuild_opt, bitgen_opt=bitgen_opt, ext=ext,
			par_opt=par_opt, map_opt=map_opt)
	build_script_contents += ise_commands.format(build_name=build_name)
	build_script_file = "build_" + build_name + ".sh"
	tools.write_to_file(build_script_file, build_script_contents, force_unix=True)

	r = subprocess.call(["bash", build_script_file])
	if r != 0:
		raise OSError("Subprocess failed")

class XilinxNoRetimingImpl(Module):
	def __init__(self, reg):
		self.specials += SynthesisDirective("attribute register_balancing of {r} is no", r=reg)

class XilinxNoRetiming:
	@staticmethod
	def lower(dr):
		return XilinxNoRetimingImpl(dr.reg)

class XilinxMultiRegImpl(MultiRegImpl):
	def __init__(self, *args, **kwargs):
		MultiRegImpl.__init__(self, *args, **kwargs)
		self.specials += [SynthesisDirective("attribute shreg_extract of {r} is no", r=r)
			for r in self.regs]

class XilinxMultiReg:
	@staticmethod
	def lower(dr):
		return XilinxMultiRegImpl(dr.i, dr.o, dr.odomain, dr.n)

class XilinxISEPlatform(GenericPlatform):
	bitstream_ext = ".bit"
	xst_opt = """-ifmt MIXED
-opt_mode SPEED
-register_balancing yes"""
	map_opt = "-ol high -w"
	par_opt = "-ol high -w"
	ngdbuild_opt = ""
	bitgen_opt = "-g LCK_cycle:6 -g Binary:Yes -w"
	ise_commands = ""
	def get_verilog(self, *args, special_overrides=dict(), **kwargs):
		so = {
			NoRetiming: XilinxNoRetiming,
			MultiReg:   XilinxMultiReg
		}
		so.update(special_overrides)
		return GenericPlatform.get_verilog(self, *args, special_overrides=so, **kwargs)

	def get_edif(self, fragment, **kwargs):
		return GenericPlatform.get_edif(self, fragment, "UNISIMS", "Xilinx", self.device, **kwargs)

	def build(self, fragment, build_dir="build", build_name="top",
			ise_path="/opt/Xilinx", source=True, run=True, mode="xst"):
		tools.mkdir_noerror(build_dir)
		os.chdir(build_dir)

		if not isinstance(fragment, _Fragment):
			fragment = fragment.get_fragment()
		self.finalize(fragment)

		ngdbuild_opt = self.ngdbuild_opt

		if mode == "xst" or mode == "yosys":
			v_src, named_sc, named_pc = self.get_verilog(fragment)
			v_file = build_name + ".v"
			tools.write_to_file(v_file, v_src)
			sources = self.sources + [(v_file, "verilog")]
			if mode == "xst":
				_build_xst_files(self.device, sources, self.verilog_include_paths, build_name, self.xst_opt)
				isemode = "xst"
			else:
				_run_yosys(self.device, sources, self.verilog_include_paths, build_name)
				isemode = "edif"
				ngdbuild_opt += "-p " + self.device

		if mode == "mist":
			from mist import synthesize
			synthesize(fragment, self.constraint_manager.get_io_signals())

		if mode == "edif" or mode == "mist":
			e_src, named_sc, named_pc = self.get_edif(fragment)
			e_file = build_name + ".edif"
			tools.write_to_file(e_file, e_src)
			isemode = "edif"

		tools.write_to_file(build_name + ".ucf", _build_ucf(named_sc, named_pc))
		if run:
			_run_ise(build_name, ise_path, source, isemode,
					ngdbuild_opt, self.bitgen_opt, self.ise_commands,
					self.map_opt, self.par_opt)

		os.chdir("..")

	def add_period_constraint(self, clk, period):
		if period is not None:
			self.add_platform_command("""NET "{clk}" TNM_NET = "GRP{clk}";
TIMESPEC "TS{clk}" = PERIOD "GRP{clk}" """+str(period)+""" ns HIGH 50%;""", clk=clk)

########NEW FILE########
__FILENAME__ = dma_lasmi
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.genlib.fifo import SyncFIFO

class Reader(Module):
	def __init__(self, lasmim, fifo_depth=None):
		self.address = Sink([("a", lasmim.aw)])
		self.data = Source([("d", lasmim.dw)])
		self.busy = Signal()
	
		###

		if fifo_depth is None:
			fifo_depth = lasmim.req_queue_size + lasmim.read_latency + 2
	
		# request issuance
		request_enable = Signal()
		request_issued = Signal()

		self.comb += [
			lasmim.we.eq(0),
			lasmim.stb.eq(self.address.stb & request_enable),
			lasmim.adr.eq(self.address.payload.a),
			self.address.ack.eq(lasmim.req_ack & request_enable),
			request_issued.eq(lasmim.stb & lasmim.req_ack)
		]

		# FIFO reservation level counter
		# incremented when data is planned to be queued
		# decremented when data is dequeued
		data_dequeued = Signal()
		rsv_level = Signal(max=fifo_depth+1)
		self.sync += [
			If(request_issued,
				If(~data_dequeued, rsv_level.eq(rsv_level + 1))
			).Elif(data_dequeued,
				rsv_level.eq(rsv_level - 1)
			)
		]
		self.comb += [
			self.busy.eq(rsv_level != 0),
			request_enable.eq(rsv_level != fifo_depth)
		]

		# data available
		data_available = lasmim.dat_ack
		for i in range(lasmim.read_latency):
			new_data_available = Signal()
			self.sync += new_data_available.eq(data_available)
			data_available = new_data_available

		# FIFO
		fifo = SyncFIFO(lasmim.dw, fifo_depth)
		self.submodules += fifo

		self.comb += [
			fifo.din.eq(lasmim.dat_r),
			fifo.we.eq(data_available),

			self.data.stb.eq(fifo.readable),
			fifo.re.eq(self.data.ack),
			self.data.payload.d.eq(fifo.dout),
			data_dequeued.eq(self.data.stb & self.data.ack)
		]


class Writer(Module):
	def __init__(self, lasmim, fifo_depth=None):
		self.address_data = Sink([("a", lasmim.aw), ("d", lasmim.dw)])
		self.busy = Signal()

		###

		if fifo_depth is None:
			fifo_depth = lasmim.req_queue_size + lasmim.write_latency + 2

		fifo = SyncFIFO(lasmim.dw, fifo_depth)
		self.submodules += fifo

		self.comb += [
			lasmim.we.eq(1),
			lasmim.stb.eq(fifo.writable & self.address_data.stb),
			lasmim.adr.eq(self.address_data.payload.a),
			self.address_data.ack.eq(fifo.writable & lasmim.req_ack),
			fifo.we.eq(self.address_data.stb & lasmim.req_ack),
			fifo.din.eq(self.address_data.payload.d)
		]

		data_valid = lasmim.dat_ack
		for i in range(lasmim.write_latency):
			new_data_valid = Signal()
			self.sync += new_data_valid.eq(data_valid),
			data_valid = new_data_valid

		self.comb += [
			fifo.re.eq(data_valid),
			If(data_valid,
				lasmim.dat_we.eq(2**(lasmim.dw//8)-1),
				lasmim.dat_w.eq(fifo.dout)
			),
			self.busy.eq(fifo.readable)
		]

########NEW FILE########
__FILENAME__ = dma_wishbone
from migen.fhdl.std import *
from migen.bus import wishbone
from migen.flow.actor import *

class Reader(Module):
	def __init__(self):
		self.bus = wishbone.Interface()
		self.address = Sink([("a", 30)])
		self.data = Source([("d", 32)])
		self.busy = Signal()
	
		###
	
		bus_stb = Signal()
		data_reg_loaded = Signal()
		data_reg = Signal(32)
		
		self.comb += [
			self.busy.eq(data_reg_loaded),
			self.bus.we.eq(0),
			bus_stb.eq(self.address.stb & (~data_reg_loaded | self.data.ack)),
			self.bus.cyc.eq(bus_stb),
			self.bus.stb.eq(bus_stb),
			self.bus.adr.eq(self.address.payload.a),
			self.address.ack.eq(self.bus.ack),
			self.data.stb.eq(data_reg_loaded),
			self.data.payload.d.eq(data_reg)
		]
		self.sync += [
			If(self.data.ack, data_reg_loaded.eq(0)),
			If(self.bus.ack,
				data_reg_loaded.eq(1),
				data_reg.eq(self.bus.dat_r)
			)
		]

class Writer(Module):
	def __init__(self):
		self.bus = wishbone.Interface()
		self.address_data = Sink([("a", 30), ("d", 32)])
		self.busy = Signal()

		###

		self.comb += [
			self.busy.eq(0),
			self.bus.we.eq(1),
			self.bus.cyc.eq(self.address_data.stb),
			self.bus.stb.eq(self.address_data.stb),
			self.bus.adr.eq(self.address_data.payload.a),
			self.bus.sel.eq(0xf),
			self.bus.dat_w.eq(self.address_data.payload.d),
			self.address_data.ack.eq(self.bus.ack)
		]

########NEW FILE########
__FILENAME__ = fifo
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.genlib import fifo

class _FIFOActor(Module):
	def __init__(self, fifo_class, layout, depth):
		self.sink = Sink(layout)
		self.source = Source(layout)
		self.busy = Signal()

		###

		self.submodules.fifo = fifo_class(layout, depth)

		self.comb += [
			self.sink.ack.eq(self.fifo.writable),
			self.fifo.we.eq(self.sink.stb),
			self.fifo.din.eq(self.sink.payload),

			self.source.stb.eq(self.fifo.readable),
			self.source.payload.eq(self.fifo.dout),
			self.fifo.re.eq(self.source.ack)
		]

class SyncFIFO(_FIFOActor):
	def __init__(self, layout, depth):
		_FIFOActor.__init__(self, fifo.SyncFIFO, layout, depth)

class AsyncFIFO(_FIFOActor):
	def __init__(self, layout, depth):
		_FIFOActor.__init__(self, fifo.AsyncFIFO, layout, depth)		

########NEW FILE########
__FILENAME__ = misc
from migen.fhdl.std import *
from migen.genlib.record import *
from migen.genlib.fsm import *
from migen.flow.actor import *

# Generates integers from start to maximum-1
class IntSequence(Module):
	def __init__(self, nbits, offsetbits=0, step=1):
		parameters_layout = [("maximum", nbits)]
		if offsetbits:
			parameters_layout.append(("offset", offsetbits))
		
		self.parameters = Sink(parameters_layout)
		self.source = Source([("value", max(nbits, offsetbits))])
		self.busy = Signal()
	
		###
	
		load = Signal()
		ce = Signal()
		last = Signal()
		
		maximum = Signal(nbits)
		if offsetbits:
			offset = Signal(offsetbits)
		counter = Signal(nbits)
		
		if step > 1:
			self.comb += last.eq(counter + step >= maximum)
		else:
			self.comb += last.eq(counter + 1 == maximum)
		self.sync += [
			If(load,
				counter.eq(0),
				maximum.eq(self.parameters.payload.maximum),
				offset.eq(self.parameters.payload.offset) if offsetbits else None
			).Elif(ce,
				If(last,
					counter.eq(0)
				).Else(
					counter.eq(counter + step)
				)
			)
		]
		if offsetbits:
			self.comb += self.source.payload.value.eq(counter + offset)
		else:
			self.comb += self.source.payload.value.eq(counter)
		
		fsm = FSM()
		self.submodules += fsm
		fsm.act("IDLE",
			load.eq(1),
			self.parameters.ack.eq(1),
			If(self.parameters.stb, NextState("ACTIVE"))
		)
		fsm.act("ACTIVE",
			self.busy.eq(1),
			self.source.stb.eq(1),
			If(self.source.ack,
				ce.eq(1),
				If(last, NextState("IDLE"))
			)
		)

########NEW FILE########
__FILENAME__ = sim
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.flow.transactions import *
from migen.util.misc import xdir

def _sim_multiread(sim, obj):
	if isinstance(obj, Signal):
		return sim.rd(obj)
	else:
		r = {}
		for k, v in xdir(obj, True):
			rd = _sim_multiread(sim, v)
			if isinstance(rd, int) or rd:
				r[k] = rd
		return r

def _sim_multiwrite(sim, obj, value):
	if isinstance(obj, Signal):
		sim.wr(obj, value)
	else:
		for k, v in value.items():
			_sim_multiwrite(sim, getattr(obj, k), v)

# Generators yield None or a tuple of Tokens.
# Tokens for Sink endpoints are pulled and the "value" field filled in.
# Tokens for Source endpoints are pushed according to their "value" field.
#
# NB: the possibility to push several tokens at once is important to interact
# with actors that only accept a group of tokens when all of them are available.
class TokenExchanger(Module):
	def __init__(self, generator, actor):
		self.generator = generator
		self.actor = actor
		self.active = set()
		self.busy = True
		self.done = False

	def _process_transactions(self, selfp):
		completed = set()
		for token in self.active:
			ep = getattr(self.actor, token.endpoint)
			if isinstance(ep, Sink):
				if selfp.simulator.rd(ep.ack) and selfp.simulator.rd(ep.stb):
					token.value = _sim_multiread(selfp.simulator, ep.payload)
					completed.add(token)
					selfp.simulator.wr(ep.ack, 0)
			elif isinstance(ep, Source):
				if selfp.simulator.rd(ep.ack) and selfp.simulator.rd(ep.stb):
					completed.add(token)
					selfp.simulator.wr(ep.stb, 0)
			else:
				raise TypeError
		self.active -= completed
		if not self.active:
			self.busy = True

	def _update_control_signals(self, selfp):
		for token in self.active:
			ep = getattr(self.actor, token.endpoint)
			if isinstance(ep, Sink):
				selfp.simulator.wr(ep.ack, 1)
			elif isinstance(ep, Source):
				_sim_multiwrite(selfp.simulator, ep.payload, token.value)
				selfp.simulator.wr(ep.stb, 1)
			else:
				raise TypeError

	def _next_transactions(self):
		try:
			transactions = next(self.generator)
		except StopIteration:
			self.busy = False
			self.done = True
			raise StopSimulation
		if isinstance(transactions, Token):
			self.active = {transactions}
		elif isinstance(transactions, (tuple, list, set)):
			self.active = set(transactions)
		elif transactions is None:
			self.active = set()
		else:
			raise TypeError
		if self.active and all(transaction.idle_wait for transaction in self.active):
			self.busy = False

	def do_simulation(self, selfp):
		if self.active:
			self._process_transactions(selfp)
		if not self.active:
			self._next_transactions()
			self._update_control_signals(selfp)
	do_simulation.passive = True

class SimActor(Module):
	def __init__(self, generator):
		self.busy = Signal()
		self.submodules.token_exchanger = TokenExchanger(generator, self)
	
	def do_simulation(self, selfp):
		selfp.busy = self.token_exchanger.busy
	do_simulation.passive = True

def _dumper_gen(prefix):
	while True:
		t = Token("result")
		yield t
		if len(t.value) > 1:
			s = str(t.value)
		else:
			s = str(list(t.value.values())[0])
		print(prefix + s)

class Dumper(SimActor):
	def __init__(self, layout, prefix=""):
		self.result = Sink(layout)
		SimActor.__init__(self, _dumper_gen(prefix))

########NEW FILE########
__FILENAME__ = spi
# Simple Processor Interface

from migen.fhdl.std import *
from migen.bank.description import *
from migen.flow.actor import *
from migen.flow.network import *
from migen.flow import plumbing
from migen.actorlib import misc
from migen.bank.eventmanager import *

# layout is a list of tuples, either:
# - (name, nbits, [reset value], [alignment bits])
# - (name, sublayout)

def _convert_layout(layout):
	r = []
	for element in layout:
		if isinstance(element[1], list):
			r.append((element[0], _convert_layout(element[1])))
		else:
			r.append((element[0], element[1]))
	return r

(MODE_EXTERNAL, MODE_SINGLE_SHOT, MODE_CONTINUOUS) = range(3)

class SingleGenerator(Module, AutoCSR):
	def __init__(self, layout, mode):
		self.source = Source(_convert_layout(layout))
		self.busy = Signal()
		
		self.comb += self.busy.eq(self.source.stb)

		if mode == MODE_EXTERNAL:
			self.trigger = Signal()
			trigger = self.trigger
		elif mode == MODE_SINGLE_SHOT:
			self._r_shoot = CSR()
			trigger = self._r_shoot.re
		elif mode == MODE_CONTINUOUS:
			self._r_enable = CSRStorage()
			trigger = self._r_enable.storage
		else:
			raise ValueError
		self.sync += If(self.source.ack | ~self.source.stb, self.source.stb.eq(trigger))

		self._create_csrs(layout, self.source.payload, mode != MODE_SINGLE_SHOT)

	def _create_csrs(self, layout, target, atomic, prefix=""):
		for element in layout:
			if isinstance(element[1], list):
				self._create_csrs(element[1], atomic,
					getattr(target, element[0]),
					element[0] + "_")
			else:
				name = element[0]
				nbits = element[1]
				if len(element) > 2:
					reset = element[2]
				else:
					reset = 0
				if len(element) > 3:
					alignment = element[3]
				else:
					alignment = 0
				regname = prefix + name
				reg = CSRStorage(nbits + alignment, reset=reset, atomic_write=atomic,
					alignment_bits=alignment, name=regname)
				setattr(self, "r_"+regname, reg)
				self.sync += If(self.source.ack | ~self.source.stb,
					getattr(target, name).eq(reg.storage))

class Collector(Module, AutoCSR):
	def __init__(self, layout, depth=1024):
		self.sink = Sink(layout)
		self.busy = Signal()
		dw = sum(len(s) for s in self.sink.payload.flatten())

		self._r_wa = CSRStorage(bits_for(depth-1), write_from_dev=True)
		self._r_wc = CSRStorage(bits_for(depth), write_from_dev=True, atomic_write=True)
		self._r_ra = CSRStorage(bits_for(depth-1))
		self._r_rd = CSRStatus(dw)
		
		###
	
		mem = Memory(dw, depth)
		self.specials += mem
		wp = mem.get_port(write_capable=True)
		rp = mem.get_port()
		self.specials += wp, rp
		
		self.comb += [
			self.busy.eq(0),

			If(self._r_wc.r != 0,
				self.sink.ack.eq(1),
				If(self.sink.stb,
					self._r_wa.we.eq(1),
					self._r_wc.we.eq(1),
					wp.we.eq(1)
				)
			),
			self._r_wa.dat_w.eq(self._r_wa.storage + 1),
			self._r_wc.dat_w.eq(self._r_wc.storage - 1),
			
			wp.adr.eq(self._r_wa.storage),
			wp.dat_w.eq(self.sink.payload.raw_bits()),
			
			rp.adr.eq(self._r_ra.storage),
			self._r_rd.status.eq(rp.dat_r)
		]

class _DMAController(Module):
	def __init__(self, bus_accessor, bus_aw, bus_dw, mode, base_reset=0, length_reset=0, generate_irq=False):
		self.alignment_bits = bits_for(bus_dw//8) - 1
		layout = [
			("length", bus_aw + self.alignment_bits, length_reset, self.alignment_bits),
			("base", bus_aw + self.alignment_bits, base_reset, self.alignment_bits)
		]
		self.generator = SingleGenerator(layout, mode)
		self.r_busy = CSRStatus()

		self.length = self.generator.r_length.storage
		self.base = self.generator.r_base.storage
		if hasattr(self.generator, "trigger"):
			self.trigger = self.generator.trigger

		self.generate_irq = generate_irq
		if generate_irq:
			self.submodules.ev = EventManager()
			self.ev.done = EventSourceProcess()
			self.ev.finalize()
			self.comb += self.ev.done.trigger.eq(self.r_busy.status)

	def get_csrs(self):
		csrs = self.generator.get_csrs() + [self.r_busy]
		if self.generate_irq:
			csrs += self.ev.get_csrs()
		return csrs

class DMAReadController(_DMAController):
	def __init__(self, bus_accessor, *args, **kwargs):
		bus_aw = flen(bus_accessor.address.payload.a)
		bus_dw = flen(bus_accessor.data.payload.d)
		_DMAController.__init__(self, bus_accessor, bus_aw, bus_dw, *args, **kwargs)
		
		g = DataFlowGraph()
		g.add_pipeline(self.generator,
			misc.IntSequence(bus_aw, bus_aw),
			AbstractActor(plumbing.Buffer),
			bus_accessor,
			AbstractActor(plumbing.Buffer))
		comp_actor = CompositeActor(g)
		self.submodules += comp_actor

		self.data = comp_actor.q
		self.busy = comp_actor.busy
		self.comb += self.r_busy.status.eq(self.busy)

class DMAWriteController(_DMAController):
	def __init__(self, bus_accessor, *args, ack_when_inactive=False, **kwargs):
		bus_aw = flen(bus_accessor.address_data.payload.a)
		bus_dw = flen(bus_accessor.address_data.payload.d)
		_DMAController.__init__(self, bus_accessor, bus_aw, bus_dw, *args, **kwargs)
		
		g = DataFlowGraph()
		adr_buffer = AbstractActor(plumbing.Buffer)
		int_sequence = misc.IntSequence(bus_aw, bus_aw)
		g.add_pipeline(self.generator,
			int_sequence,
			adr_buffer)
		g.add_connection(adr_buffer, bus_accessor, sink_subr=["a"])
		g.add_connection(AbstractActor(plumbing.Buffer), bus_accessor, sink_subr=["d"])
		comp_actor = CompositeActor(g)
		self.submodules += comp_actor

		if ack_when_inactive:
			demultiplexer = plumbing.Demultiplexer(comp_actor.d.payload.layout, 2)
			self.comb +=[
				demultiplexer.sel.eq(~adr_buffer.busy),
				demultiplexer.source0.connect(comp_actor.d),
				demultiplexer.source1.ack.eq(1),
			]
			self.submodules += demultiplexer
			self.data = demultiplexer.sink
		else:
			self.data = comp_actor.d

		self.busy = comp_actor.busy
		self.comb += self.r_busy.status.eq(self.busy)

########NEW FILE########
__FILENAME__ = structuring
from migen.fhdl.std import *
from migen.flow.actor import *

def _rawbits_layout(l):
	if isinstance(l, int):
		return [("rawbits", l)]
	else:
		return l

class Cast(CombinatorialActor):
	def __init__(self, layout_from, layout_to, reverse_from=False, reverse_to=False):
		self.sink = Sink(_rawbits_layout(layout_from))
		self.source = Source(_rawbits_layout(layout_to))
		CombinatorialActor.__init__(self)
	
		###

		sigs_from = self.sink.payload.flatten()
		if reverse_from:
			sigs_from = list(reversed(sigs_from))
		sigs_to = self.source.payload.flatten()
		if reverse_to:
			sigs_to = list(reversed(sigs_to))
		if sum(flen(s) for s in sigs_from) != sum(flen(s) for s in sigs_to):
			raise TypeError
		self.comb += Cat(*sigs_to).eq(Cat(*sigs_from))

def pack_layout(l, n):
	return [("chunk"+str(i), l) for i in range(n)]

class Unpack(Module):
	def __init__(self, n, layout_to):
		self.sink = Sink(pack_layout(layout_to, n))
		self.source = Source(layout_to)
		self.busy = Signal()
	
		###

		mux = Signal(max=n)
		last = Signal()
		self.comb += [
			last.eq(mux == (n-1)),
			self.source.stb.eq(self.sink.stb),
			self.sink.ack.eq(last & self.source.ack)
		]
		self.sync += [
			If(self.source.stb & self.source.ack,
				If(last,
					mux.eq(0)
				).Else(
					mux.eq(mux + 1)
				)
			)
		]
		cases = {}
		for i in range(n):
			cases[i] = [self.source.payload.raw_bits().eq(getattr(self.sink.payload, "chunk"+str(i)).raw_bits())]
		self.comb += Case(mux, cases).makedefault()

class Pack(Module):
	def __init__(self, layout_from, n):
		self.sink = Sink(layout_from)
		self.source = Source(pack_layout(layout_from, n))
		self.busy = Signal()
	
		###

		demux = Signal(max=n)
		
		load_part = Signal()
		strobe_all = Signal()
		cases = {}
		for i in range(n):
			cases[i] = [getattr(self.source.payload, "chunk"+str(i)).raw_bits().eq(self.sink.payload.raw_bits())]
		self.comb += [
			self.busy.eq(strobe_all),
			self.sink.ack.eq(~strobe_all | self.source.ack),
			self.source.stb.eq(strobe_all),
			load_part.eq(self.sink.stb & self.sink.ack)
		]
		self.sync += [
			If(self.source.ack, strobe_all.eq(0)),
			If(load_part,
				Case(demux, cases),
				If(demux == (n - 1),
					demux.eq(0),
					strobe_all.eq(1)
				).Else(
					demux.eq(demux + 1)
				)
			)
		]

########NEW FILE########
__FILENAME__ = csrgen
from migen.util.misc import xdir
from migen.fhdl.std import *
from migen.bus import csr
from migen.bank.description import *

def get_offset(description, name, csr_data_width=8):
	offset = 0
	for c in description:
		if c.name == name:
			return offset
		offset += (c.size + csr_data_width - 1)//csr_data_width
	raise KeyError("CSR not found: "+name)

class Bank(Module):
	def __init__(self, description, address=0, bus=None):
		if bus is None:
			bus = csr.Interface()
		self.bus = bus
		
		###

		if not description:
			return
		
		# Turn description into simple CSRs and claim ownership of compound CSR modules
		simple_csrs = []
		for c in description:
			if isinstance(c, CSR):
				simple_csrs.append(c)
			else:
				c.finalize(flen(self.bus.dat_w))
				simple_csrs += c.get_simple_csrs()
				self.submodules += c
		nbits = bits_for(len(simple_csrs)-1)

		# Decode selection
		sel = Signal()
		self.comb += sel.eq(self.bus.adr[9:] == address)
		
		# Bus writes
		for i, c in enumerate(simple_csrs):
			self.comb += [
				c.r.eq(self.bus.dat_w[:c.size]),
				c.re.eq(sel & \
					self.bus.we & \
					(self.bus.adr[:nbits] == i))
			]
		
		# Bus reads
		brcases = dict((i, self.bus.dat_r.eq(c.w)) for i, c in enumerate(simple_csrs))
		self.sync += [
			self.bus.dat_r.eq(0),
			If(sel, Case(self.bus.adr[:nbits], brcases))
		]

# address_map(name, memory) returns the CSR offset at which to map
# the CSR object (register bank or memory).
# If memory=None, the object is the register bank of object source.name.
# Otherwise, it is a memory object belonging to source.name.
# address_map is called exactly once for each object at each call to
# scan(), so it can have side effects.
class BankArray(Module):
	def __init__(self, source, address_map, *ifargs, **ifkwargs):
		self.source = source
		self.address_map = address_map
		self.scan(ifargs, ifkwargs)

	def scan(self, ifargs, ifkwargs):
		self.banks = []
		self.srams = []
		for name, obj in xdir(self.source, True):
			if hasattr(obj, "get_csrs"):
				csrs = obj.get_csrs()
			else:
				csrs = []
			if hasattr(obj, "get_memories"):
				memories = obj.get_memories()
				for memory in memories:
					mapaddr = self.address_map(name, memory)
					sram_bus = csr.Interface(*ifargs, **ifkwargs)
					mmap = csr.SRAM(memory, mapaddr, bus=sram_bus)
					self.submodules += mmap
					csrs += mmap.get_csrs()
					self.srams.append((name, memory, mapaddr, mmap))
			if csrs:
				mapaddr = self.address_map(name, None)
				bank_bus = csr.Interface(*ifargs, **ifkwargs)
				rmap = Bank(csrs, mapaddr, bus=bank_bus)
				self.submodules += rmap
				self.banks.append((name, csrs, mapaddr, rmap))

	def get_rmaps(self):
		return [rmap for name, csrs, mapaddr, rmap in self.banks]

	def get_mmaps(self):
		return [mmap for name, memory, mapaddr, mmap in self.srams]

	def get_buses(self):
		return [i.bus for i in self.get_rmaps() + self.get_mmaps()]

########NEW FILE########
__FILENAME__ = description
from migen.util.misc import xdir
from migen.fhdl.std import *
from migen.fhdl.tracer import get_obj_var_name

class _CSRBase(HUID):
	def __init__(self, size, name):
		HUID.__init__(self)
		self.name = get_obj_var_name(name)
		if self.name is None:
			raise ValueError("Cannot extract CSR name from code, need to specify.")
		if len(self.name) > 2 and self.name[:2] == "r_":
			self.name = self.name[2:]
		self.size = size

class CSR(_CSRBase):
	def __init__(self, size=1, name=None):
		_CSRBase.__init__(self, size, name)
		self.re = Signal(name=self.name + "_re")
		self.r = Signal(self.size, name=self.name + "_r")
		self.w = Signal(self.size, name=self.name + "_w")

class _CompoundCSR(_CSRBase, Module):
	def __init__(self, size, name):
		_CSRBase.__init__(self, size, name)
		self.simple_csrs = []

	def get_simple_csrs(self):
		if not self.finalized:
			raise FinalizeError
		return self.simple_csrs

	def do_finalize(self, busword):
		raise NotImplementedError

class CSRStatus(_CompoundCSR):
	def __init__(self, size=1, name=None):
		_CompoundCSR.__init__(self, size, name)
		self.status = Signal(self.size)

	def do_finalize(self, busword):
		nwords = (self.size + busword - 1)//busword
		for i in reversed(range(nwords)):
			nbits = min(self.size - i*busword, busword)
			sc = CSR(nbits, self.name + str(i) if nwords > 1 else self.name)
			self.comb += sc.w.eq(self.status[i*busword:i*busword+nbits])
			self.simple_csrs.append(sc)

class CSRStorage(_CompoundCSR):
	def __init__(self, size=1, reset=0, atomic_write=False, write_from_dev=False, alignment_bits=0, name=None):
		_CompoundCSR.__init__(self, size, name)
		self.alignment_bits = alignment_bits
		self.storage_full = Signal(self.size, reset=reset)
		self.storage = Signal(self.size - self.alignment_bits, reset=reset >> alignment_bits)
		self.comb += self.storage.eq(self.storage_full[self.alignment_bits:])
		self.atomic_write = atomic_write
		if write_from_dev:
			self.we = Signal()
			self.dat_w = Signal(self.size - self.alignment_bits)
			self.sync += If(self.we, self.storage_full.eq(self.dat_w << self.alignment_bits))

	def do_finalize(self, busword):
		nwords = (self.size + busword - 1)//busword
		if nwords > 1 and self.atomic_write:
			backstore = Signal(self.size - busword, name=self.name + "_backstore")
		for i in reversed(range(nwords)):
			nbits = min(self.size - i*busword, busword)
			sc = CSR(nbits, self.name + str(i) if nwords else self.name)
			self.simple_csrs.append(sc)
			lo = i*busword
			hi = lo+nbits
			# read
			if lo >= self.alignment_bits:
				self.comb += sc.w.eq(self.storage_full[lo:hi])
			elif hi > self.alignment_bits:
				self.comb += sc.w.eq(Cat(Replicate(0, hi - self.alignment_bits),
					self.storage_full[self.alignment_bits:hi]))
			else:
				self.comb += sc.w.eq(0)
			# write
			if nwords > 1 and self.atomic_write:
				if i:
					self.sync += If(sc.re, backstore[lo-busword:hi-busword].eq(sc.r))
				else:
					self.sync += If(sc.re, self.storage_full.eq(Cat(sc.r, backstore)))
			else:
				self.sync += If(sc.re, self.storage_full[lo:hi].eq(sc.r))

def csrprefix(prefix, csrs, done):
	for csr in csrs:
		if csr.huid not in done:
			csr.name = prefix + csr.name
			done.add(csr.huid)

def memprefix(prefix, memories, done):
	for memory in memories:
		if memory.huid not in done:
			memory.name_override = prefix + memory.name_override
			done.add(memory.huid)

class AutoCSR:
	def get_memories(self):
		try:
			exclude = self.autocsr_exclude
		except AttributeError:
			exclude = {}
		try:
			prefixed = self.__prefixed
		except AttributeError:
			prefixed = self.__prefixed = set()
		r = []
		for k, v in xdir(self, True):
			if k not in exclude:
				if isinstance(v, Memory):
					r.append(v)
				elif hasattr(v, "get_memories") and callable(v.get_memories):
					memories = v.get_memories()
					memprefix(k + "_", memories, prefixed)
					r += memories
		return sorted(r, key=lambda x: x.huid)

	def get_csrs(self):
		try:
			exclude = self.autocsr_exclude
		except AttributeError:
			exclude = {}
		try:
			prefixed = self.__prefixed
		except AttributeError:
			prefixed = self.__prefixed = set()
		r = []
		for k, v in xdir(self, True):
			if k not in exclude:
				if isinstance(v, _CSRBase):
					r.append(v)
				elif hasattr(v, "get_csrs") and callable(v.get_csrs):
					csrs = v.get_csrs()
					csrprefix(k + "_", csrs, prefixed)
					r += csrs
		return sorted(r, key=lambda x: x.huid)

########NEW FILE########
__FILENAME__ = eventmanager
from migen.util.misc import xdir
from migen.fhdl.std import *
from migen.bank.description import *
from migen.genlib.misc import optree

class _EventSource(HUID):
	def __init__(self):
		HUID.__init__(self)
		self.status = Signal() # value in the status register
		self.pending = Signal() # value in the pending register + assert irq if unmasked
		self.trigger = Signal() # trigger signal interface to the user design
		self.clear = Signal() # clearing attempt by W1C to pending register, ignored by some event sources

# set on a positive trigger pulse
class EventSourcePulse(Module, _EventSource):
	def __init__(self):
		_EventSource.__init__(self)
		self.comb += self.status.eq(0)
		self.sync += [
			If(self.clear, self.pending.eq(0)),
			If(self.trigger, self.pending.eq(1))
		]

# set on the falling edge of the trigger, status = trigger
class EventSourceProcess(Module, _EventSource):
	def __init__(self):
		_EventSource.__init__(self)
		self.comb += self.status.eq(self.trigger)
		old_trigger = Signal()
		self.sync += [
			If(self.clear, self.pending.eq(0)),
			old_trigger.eq(self.trigger),
			If(~self.trigger & old_trigger, self.pending.eq(1))
		]

# all status set by external trigger
class EventSourceLevel(Module, _EventSource):
	def __init__(self):
		_EventSource.__init__(self)
		self.comb += [
			self.status.eq(self.trigger),
			self.pending.eq(self.trigger)
		]

class EventManager(Module, AutoCSR):
	def __init__(self):
		self.irq = Signal()
	
	def do_finalize(self):
		sources_u = [v for k, v in xdir(self, True) if isinstance(v, _EventSource)]
		sources = sorted(sources_u, key=lambda x: x.huid)
		n = len(sources)
		self.status = CSR(n)
		self.pending = CSR(n)
		self.enable = CSRStorage(n)

		for i, source in enumerate(sources):
			self.comb += [
				self.status.w[i].eq(source.status),
				If(self.pending.re & self.pending.r[i], source.clear.eq(1)),
				self.pending.w[i].eq(source.pending)
			]
		
		irqs = [self.pending.w[i] & self.enable.storage[i] for i in range(n)]
		self.comb += self.irq.eq(optree("|", irqs))

	def __setattr__(self, name, value):
		object.__setattr__(self, name, value)
		if isinstance(value, _EventSource):
			if self.finalized:
				raise FinalizeError
			self.submodules += value

class SharedIRQ(Module):
	def __init__(self, *event_managers):
		self.irq = Signal()
		self.comb += self.irq.eq(optree("|", [ev.irq for ev in event_managers]))

########NEW FILE########
__FILENAME__ = csr
from migen.fhdl.std import *
from migen.bus.transactions import *
from migen.bank.description import CSRStorage
from migen.genlib.record import *
from migen.genlib.misc import chooser

_layout = [
	("adr",		14,				DIR_M_TO_S),
	("we",		1,				DIR_M_TO_S),
	("dat_w",	"data_width",	DIR_M_TO_S),
	("dat_r",	"data_width",	DIR_S_TO_M)
]

class Interface(Record):
	def __init__(self, data_width=8):
		Record.__init__(self, set_layout_parameters(_layout,
			data_width=data_width))

class Interconnect(Module):
	def __init__(self, master, slaves):
		self.comb += master.connect(*slaves)

class Initiator(Module):
	def __init__(self, generator, bus=None):
		self.generator = generator
		if bus is None:
			bus = Interface()
		self.bus = bus
		self.transaction = None
		self.read_data_ready = False
		self.done = False
		
	def do_simulation(self, selfp):
		if not self.done:
			if self.transaction is not None:
				if isinstance(self.transaction, TRead):
					if self.read_data_ready:
						self.transaction.data = selfp.bus.dat_r
						self.transaction = None
						self.read_data_ready = False
					else:
						self.read_data_ready = True
				else:
					selfp.bus.we = 0
					self.transaction = None
			if self.transaction is None:
				try:
					self.transaction = next(self.generator)
				except StopIteration:
					self.transaction = None
					raise StopSimulation
				if self.transaction is not None:
					selfp.bus.adr = self.transaction.address
					if isinstance(self.transaction, TWrite):
						selfp.bus.we = 1
						selfp.bus.dat_w = self.transaction.data

class SRAM(Module):
	def __init__(self, mem_or_size, address, read_only=None, init=None, bus=None):
		if bus is None:
			bus = Interface()
		self.bus = bus
		data_width = flen(self.bus.dat_w)
		if isinstance(mem_or_size, Memory):
			mem = mem_or_size
		else:
			mem = Memory(data_width, mem_or_size//(data_width//8), init=init)
		csrw_per_memw = (mem.width + data_width - 1)//data_width
		word_bits = log2_int(csrw_per_memw)
		page_bits = log2_int((mem.depth*csrw_per_memw + 511)//512, False)
		if page_bits:
			self._page = CSRStorage(page_bits, name=mem.name_override + "_page")
		else:
			self._page = None
		if read_only is None:
			if hasattr(mem, "bus_read_only"):
				read_only = mem.bus_read_only
			else:
				read_only = False
	
		###

		port = mem.get_port(write_capable=not read_only)
		self.specials += mem, port
		
		sel = Signal()
		sel_r = Signal()
		self.sync += sel_r.eq(sel)
		self.comb += sel.eq(self.bus.adr[9:] == address)

		if word_bits:
			word_index = Signal(word_bits)
			word_expanded = Signal(csrw_per_memw*data_width)
			self.sync += word_index.eq(self.bus.adr[:word_bits])
			self.comb += [
				word_expanded.eq(port.dat_r),
				If(sel_r,
					chooser(word_expanded, word_index, self.bus.dat_r, n=csrw_per_memw, reverse=True)
				)
			]
			if not read_only:
				wregs = []
				for i in range(csrw_per_memw-1):
					wreg = Signal(data_width)
					self.sync += If(sel & self.bus.we & (self.bus.adr[:word_bits] == i), wreg.eq(self.bus.dat_w))
					wregs.append(wreg)
				memword_chunks = [self.bus.dat_w] + list(reversed(wregs))
				self.comb += [
					port.we.eq(sel & self.bus.we & (self.bus.adr[:word_bits] == csrw_per_memw - 1)),
					port.dat_w.eq(Cat(*memword_chunks))
				]
		else:
			self.comb += If(sel_r, self.bus.dat_r.eq(port.dat_r))
			if not read_only:
				self.comb += [
					port.we.eq(sel & self.bus.we),
					port.dat_w.eq(self.bus.dat_w)
				]
		
		if self._page is None:
			self.comb += port.adr.eq(self.bus.adr[word_bits:word_bits+flen(port.adr)])
		else:
			pv = self._page.storage
			self.comb += port.adr.eq(Cat(self.bus.adr[word_bits:word_bits+flen(port.adr)-flen(pv)], pv))

	def get_csrs(self):
		if self._page is None:
			return []
		else:
			return [self._page]

########NEW FILE########
__FILENAME__ = dfi
from migen.fhdl.std import *
from migen.genlib.record import *

def phase_cmd_description(a, ba):
	return [
		("address",			a,		DIR_M_TO_S),	
		("bank",			ba,		DIR_M_TO_S),
		("cas_n",			1,		DIR_M_TO_S),
		("cke",				1,		DIR_M_TO_S),
		("cs_n",			1,		DIR_M_TO_S),
		("ras_n",			1,		DIR_M_TO_S),
		("we_n",			1,		DIR_M_TO_S)
	]

def phase_wrdata_description(d):
	return [
		("wrdata",			d,		DIR_M_TO_S),
		("wrdata_en",		1,		DIR_M_TO_S),
		("wrdata_mask",		d//8,	DIR_M_TO_S),
	]

def phase_rddata_description(d):
	return [
		("rddata_en",		1,		DIR_M_TO_S),
		("rddata",			d,		DIR_S_TO_M),
		("rddata_valid",	1,		DIR_S_TO_M)
	]

def phase_description(a, ba, d):
	r = phase_cmd_description(a, ba)
	r += phase_wrdata_description(d)
	r += phase_rddata_description(d)
	return r

class Interface(Record):
	def __init__(self, a, ba, d, nphases=1):
		layout = [("p"+str(i), phase_description(a, ba, d)) for i in range(nphases)]
		Record.__init__(self, layout)
		self.phases = [getattr(self, "p"+str(i)) for i in range(nphases)]
		for p in self.phases:
			p.cas_n.reset = 1
			p.cs_n.reset = 1
			p.ras_n.reset = 1
			p.we_n.reset = 1
	
	# Returns pairs (DFI-mandated signal name, Migen signal object)
	def get_standard_names(self, m2s=True, s2m=True):
		r = []
		add_suffix = len(self.phases) > 1
		for n, phase in enumerate(self.phases):
			for field, size, direction in phase.layout:
				if (m2s and direction == DIR_M_TO_S) or (s2m and direction == DIR_S_TO_M):
					if add_suffix:
						if direction == DIR_M_TO_S:
							suffix = "_p" + str(n)
						else:
							suffix = "_w" + str(n)
					else:
						suffix = ""
					r.append(("dfi_" + field + suffix, getattr(phase, field)))
		return r

class Interconnect(Module):
	def __init__(self, master, slave):
		self.comb += master.connect(slave)

########NEW FILE########
__FILENAME__ = lasmibus
from migen.fhdl.std import *
from migen.bus.transactions import *
from migen.genlib import roundrobin
from migen.genlib.record import *
from migen.genlib.misc import optree

class Interface(Record):
	def __init__(self, aw, dw, nbanks, req_queue_size, read_latency, write_latency):
		self.aw = aw
		self.dw = dw
		self.nbanks = nbanks
		self.req_queue_size = req_queue_size
		self.read_latency = read_latency
		self.write_latency = write_latency

		bank_layout = [
			("adr",		aw,		DIR_M_TO_S),
			("we",		1,		DIR_M_TO_S),
			("stb",		1,		DIR_M_TO_S),
			("req_ack",	1,		DIR_S_TO_M),
			("dat_ack",	1,		DIR_S_TO_M),
			("lock",	1,		DIR_S_TO_M)
		]
		if nbanks > 1:
			layout = [("bank"+str(i), bank_layout) for i in range(nbanks)]
		else:
			layout = bank_layout
		layout += [
			("dat_w",	dw, 	DIR_M_TO_S),
			("dat_we",	dw//8, 	DIR_M_TO_S),
			("dat_r",	dw, 	DIR_S_TO_M)
		]
		Record.__init__(self, layout)

def _getattr_all(l, attr):
	it = iter(l)
	r = getattr(next(it), attr)
	for e in it:
		if getattr(e, attr) != r:
			raise ValueError
	return r

class Crossbar(Module):
	def __init__(self, controllers, cba_shift):
		self._controllers = controllers
		self._cba_shift = cba_shift

		self._rca_bits = _getattr_all(controllers, "aw")
		self._dw = _getattr_all(controllers, "dw")
		self._nbanks = _getattr_all(controllers, "nbanks")
		self._req_queue_size = _getattr_all(controllers, "req_queue_size")
		self._read_latency = _getattr_all(controllers, "read_latency")
		self._write_latency = _getattr_all(controllers, "write_latency")

		self._bank_bits = log2_int(self._nbanks, False)
		self._controller_bits = log2_int(len(self._controllers), False)

		self._masters = []

	def get_master(self):
		if self.finalized:
			raise FinalizeError
		lasmi_master = Interface(self._rca_bits + self._bank_bits + self._controller_bits,
			self._dw, 1, self._req_queue_size, self._read_latency, self._write_latency)
		self._masters.append(lasmi_master)
		return lasmi_master

	def do_finalize(self):
		nmasters = len(self._masters)

		m_ca, m_ba, m_rca = self._split_master_addresses(self._controller_bits,
			self._bank_bits, self._rca_bits, self._cba_shift)
		
		for nc, controller in enumerate(self._controllers):
			if self._controller_bits:
				controller_selected = [ca == nc for ca in m_ca]
			else:
				controller_selected = [1]*nmasters
			master_req_acks = [0]*nmasters
			master_dat_acks = [0]*nmasters
			rrs = [roundrobin.RoundRobin(nmasters, roundrobin.SP_CE) for n in range(self._nbanks)]
			self.submodules += rrs
			for nb, rr in enumerate(rrs):
				bank = getattr(controller, "bank"+str(nb))

				# for each master, determine if another bank locks it
				master_locked = []
				for nm, master in enumerate(self._masters):
					locked = 0
					for other_nb, other_rr in enumerate(rrs):
						if other_nb != nb:
							other_bank = getattr(controller, "bank"+str(other_nb))
							locked = locked | (other_bank.lock & (other_rr.grant == nm))
					master_locked.append(locked)

				# arbitrate
				bank_selected = [cs & (ba == nb) & ~locked for cs, ba, locked in zip(controller_selected, m_ba, master_locked)]
				bank_requested = [bs & master.stb for bs, master in zip(bank_selected, self._masters)]
				self.comb += [
					rr.request.eq(Cat(*bank_requested)),
					rr.ce.eq(~bank.stb & ~bank.lock)
				]

				# route requests
				self.comb += [
					bank.adr.eq(Array(m_rca)[rr.grant]),
					bank.we.eq(Array(self._masters)[rr.grant].we),
					bank.stb.eq(Array(bank_requested)[rr.grant])
				]
				master_req_acks = [master_req_ack | ((rr.grant == nm) & bank_selected[nm] & bank.req_ack)
					for nm, master_req_ack in enumerate(master_req_acks)]
				master_dat_acks = [master_dat_ack | ((rr.grant == nm) & bank.dat_ack)
					for nm, master_dat_ack in enumerate(master_dat_acks)]

			self.comb += [master.req_ack.eq(master_req_ack) for master, master_req_ack in zip(self._masters, master_req_acks)]
			self.comb += [master.dat_ack.eq(master_dat_ack) for master, master_dat_ack in zip(self._masters, master_dat_acks)]

			# route data writes
			controller_selected_wl = controller_selected
			for i in range(self._write_latency):
				n_controller_selected_wl = [Signal() for i in range(nmasters)]
				self.sync += [n.eq(o) for n, o in zip(n_controller_selected_wl, controller_selected_wl)]
				controller_selected_wl = n_controller_selected_wl
			dat_w_maskselect = []
			dat_we_maskselect = []
			for master, selected in zip(self._masters, controller_selected_wl):
				o_dat_w = Signal(self._dw)
				o_dat_we = Signal(self._dw//8)
				self.comb += If(selected,
						o_dat_w.eq(master.dat_w),
						o_dat_we.eq(master.dat_we)
					)
				dat_w_maskselect.append(o_dat_w)
				dat_we_maskselect.append(o_dat_we)
			self.comb += [
				controller.dat_w.eq(optree("|", dat_w_maskselect)),
				controller.dat_we.eq(optree("|", dat_we_maskselect))
			]

		# route data reads
		if self._controller_bits:
			for master in self._masters:
				controller_sel = Signal(self._controller_bits)
				for nc, controller in enumerate(self._controllers):
					for nb in range(nbanks):
						bank = getattr(controller, "bank"+str(nb))
						self.comb += If(bank.stb & bank.ack, controller_sel.eq(nc))
				for i in range(self._read_latency):
					n_controller_sel = Signal(self._controller_bits)
					self.sync += n_controller_sel.eq(controller_sel)
					controller_sel = n_controller_sel
				self.comb += master.dat_r.eq(Array(self._controllers)[controller_sel].dat_r)
		else:
			self.comb += [master.dat_r.eq(self._controllers[0].dat_r) for master in self._masters]

	def _split_master_addresses(self, controller_bits, bank_bits, rca_bits, cba_shift):
		m_ca = []	# controller address
		m_ba = []	# bank address
		m_rca = []	# row and column address
		for master in self._masters:
			cba = Signal(self._controller_bits + self._bank_bits)
			rca = Signal(self._rca_bits)
			cba_upper = cba_shift + controller_bits + bank_bits
			self.comb += cba.eq(master.adr[cba_shift:cba_upper])
			if cba_shift < self._rca_bits:
				if cba_shift:
					self.comb += rca.eq(Cat(master.adr[:cba_shift], master.adr[cba_upper:]))
				else:
					self.comb += rca.eq(master.adr[cba_upper:])
			else:
				self.comb += rca.eq(master.adr[:cba_shift])

			if self._controller_bits:
				ca = Signal(self._controller_bits)
				ba = Signal(self._bank_bits)
				self.comb += Cat(ba, ca).eq(cba)
			else:
				ca = None
				ba = cba

			m_ca.append(ca)
			m_ba.append(ba)
			m_rca.append(rca)
		return m_ca, m_ba, m_rca

class Initiator(Module):
	def __init__(self, generator, bus):
		self.generator = generator
		self.bus = bus
		self.transaction_start = 0
		self.transaction = None
		self.transaction_end = None
	
	def do_simulation(self, selfp):
		selfp.bus.dat_w = 0
		selfp.bus.dat_we = 0

		if self.transaction is not None:
			if selfp.bus.req_ack:
				selfp.bus.stb = 0
			if selfp.bus.dat_ack:
				if isinstance(self.transaction, TRead):
					self.transaction_end = selfp.simulator.cycle_counter + self.bus.read_latency
				else:
					self.transaction_end = selfp.simulator.cycle_counter + self.bus.write_latency - 1

		if self.transaction is None or selfp.simulator.cycle_counter == self.transaction_end:
			if self.transaction is not None:
				self.transaction.latency = selfp.simulator.cycle_counter - self.transaction_start - 1
				if isinstance(self.transaction, TRead):
					self.transaction.data = selfp.bus.dat_r
				else:
					selfp.bus.dat_w = self.transaction.data
					selfp.bus.dat_we = self.transaction.sel
			try:
				self.transaction = next(self.generator)
			except StopIteration:
				raise StopSimulation
			if self.transaction is not None:
				self.transaction_start = selfp.simulator.cycle_counter
				selfp.bus.stb = 1
				selfp.bus.adr = self.transaction.address
				if isinstance(self.transaction, TRead):
					selfp.bus.we = 0
				else:
					selfp.bus.we = 1

class TargetModel:
	def __init__(self):
		self.last_bank = 0

	def read(self, bank, address):
		return 0
	
	def write(self, bank, address, data, we):
		pass

	# Round-robin scheduling
	def select_bank(self, pending_banks):
		if not pending_banks:
			return -1
		self.last_bank += 1
		if self.last_bank > max(pending_banks):
			self.last_bank = 0
		while self.last_bank not in pending_banks:
			self.last_bank += 1
		return self.last_bank

class _ReqFIFO(Module):
	def __init__(self, req_queue_size, bank):
		self.req_queue_size = req_queue_size
		self.bank = bank
		self.contents = []

	def do_simulation(self, selfp):
		if len(self.contents) < self.req_queue_size:
			if selfp.bank.stb:
				self.contents.append((selfp.bank.we, selfp.bank.adr))
			selfp.bank.req_ack = 1
		else:
			selfp.bank.req_ack = 0
		selfp.bank.lock = bool(self.contents)
	do_simulation.passive = True

class Target(Module):
	def __init__(self, model, *ifargs, **ifkwargs):
		self.model = model
		self.bus = Interface(*ifargs, **ifkwargs)
		self.req_fifos = [_ReqFIFO(self.bus.req_queue_size, getattr(self.bus, "bank"+str(nb)))
			for nb in range(self.bus.nbanks)]
		self.submodules += self.req_fifos
		self.rd_pipeline = [None]*self.bus.read_latency
		self.wr_pipeline = [None]*(self.bus.write_latency + 1)

	def do_simulation(self, selfp):
		# determine banks with pending requests
		pending_banks = set(nb for nb, rf in enumerate(self.req_fifos) if rf.contents)

		# issue new transactions
		selected_bank_n = self.model.select_bank(pending_banks)
		selected_transaction = None
		for nb in range(self.bus.nbanks):
			bank = getattr(selfp.bus, "bank"+str(nb))
			if nb == selected_bank_n:
				bank.dat_ack = 1
				selected_transaction = self.req_fifos[nb].contents.pop(0)
			else:
				bank.dat_ack = 0
		
		rd_transaction = None
		wr_transaction = None
		if selected_bank_n >= 0:
			we, adr = selected_transaction
			if we:
				wr_transaction = selected_bank_n, adr
			else:
				rd_transaction = selected_bank_n, adr

		# data pipeline
		self.rd_pipeline.append(rd_transaction)
		self.wr_pipeline.append(wr_transaction)
		done_rd_transaction = self.rd_pipeline.pop(0)
		done_wr_transaction = self.wr_pipeline.pop(0)
		if done_rd_transaction is not None:
			selfp.bus.dat_r = self.model.read(done_rd_transaction[0], done_rd_transaction[1])
		if done_wr_transaction is not None:
			self.model.write(done_wr_transaction[0], done_wr_transaction[1],
				selfp.bus.dat_w, selfp.bus.dat_we)
	do_simulation.passive = True

########NEW FILE########
__FILENAME__ = memory
from migen.fhdl.std import *
from migen.bus.transactions import *

def _byte_mask(orig, dat_w, sel):
	r = 0
	shift = 0
	while sel:
		if sel & 1:
			r |= (dat_w & 0xff) << shift
		else:
			r |= (orig & 0xff) << shift
		orig >>= 8
		dat_w >>= 8
		sel >>= 1
		shift += 8
	return r

class Initiator(Module):
	def __init__(self, generator, mem):
		self.generator = generator
		self.mem = mem

	def do_simulation(self, selfp):
		try:
			transaction = next(self.generator)
		except StopIteration:
			transaction = None
			raise StopSimulation
		if isinstance(transaction, TRead):
			transaction.data = selfp.mem[transaction.address]
		elif isinstance(transaction, TWrite):
			d = selfp.mem[transaction.address]
			d_mask = _byte_mask(d, transaction.data, transaction.sel)
			selfp.mem[transaction.address] = d_mask

########NEW FILE########
__FILENAME__ = transactions
from migen.fhdl.std import *

class Transaction:
	def __init__(self, address, data=0, sel=None, busname=None):
		self.address = address
		self.data = data
		if sel is None:
			bytes = (bits_for(data) + 7)//8
			sel = 2**bytes - 1
		self.sel = sel
		self.busname = busname
		self.latency = 0
	
	def __str__(self):
		return "<" + self.__class__.__name__ + " adr:" + hex(self.address) + " dat:" + hex(self.data) + ">"

class TRead(Transaction):
	pass

class TWrite(Transaction):
	pass

########NEW FILE########
__FILENAME__ = wishbone
from migen.fhdl.std import *
from migen.genlib import roundrobin
from migen.genlib.record import *
from migen.genlib.misc import optree, chooser
from migen.genlib.fsm import FSM, NextState
from migen.bus.transactions import *

_layout = [
	("adr",		30,				DIR_M_TO_S),
	("dat_w",	"data_width", 	DIR_M_TO_S),
	("dat_r",	"data_width", 	DIR_S_TO_M),
	("sel",		"sel_width",	DIR_M_TO_S),
	("cyc",		1,				DIR_M_TO_S),
	("stb",		1,				DIR_M_TO_S),
	("ack",		1,				DIR_S_TO_M),
	("we",		1,				DIR_M_TO_S),
	("cti",		3,				DIR_M_TO_S),
	("bte",		2,				DIR_M_TO_S),
	("err",		1,				DIR_S_TO_M)
]

class Interface(Record):
	def __init__(self, data_width=32):
		Record.__init__(self, set_layout_parameters(_layout,
			data_width=data_width,
			sel_width=data_width//8))

class InterconnectPointToPoint(Module):
	def __init__(self, master, slave):
		self.comb += master.connect(slave)

class Arbiter(Module):
	def __init__(self, masters, target):
		self.submodules.rr = roundrobin.RoundRobin(len(masters))
		
		# mux master->slave signals
		for name, size, direction in _layout:
			if direction == DIR_M_TO_S:
				choices = Array(getattr(m, name) for m in masters)
				self.comb += getattr(target, name).eq(choices[self.rr.grant])
		
		# connect slave->master signals
		for name, size, direction in _layout:
			if direction == DIR_S_TO_M:
				source = getattr(target, name)
				for i, m in enumerate(masters):
					dest = getattr(m, name)
					if name == "ack" or name == "err":
						self.comb += dest.eq(source & (self.rr.grant == i))
					else:
						self.comb += dest.eq(source)
		
		# connect bus requests to round-robin selector
		reqs = [m.cyc for m in masters]
		self.comb += self.rr.request.eq(Cat(*reqs))

class Decoder(Module):
	# slaves is a list of pairs:
	# 0) function that takes the address signal and returns a FHDL expression
	#    that evaluates to 1 when the slave is selected and 0 otherwise.
	# 1) wishbone.Slave reference.
	# register adds flip-flops after the address comparators. Improves timing,
	# but breaks Wishbone combinatorial feedback.
	def __init__(self, master, slaves, register=False):
		ns = len(slaves)
		slave_sel = Signal(ns)
		slave_sel_r = Signal(ns)
		
		# decode slave addresses
		self.comb += [slave_sel[i].eq(fun(master.adr))
			for i, (fun, bus) in enumerate(slaves)]
		if register:
			self.sync += slave_sel_r.eq(slave_sel)
		else:
			self.comb += slave_sel_r.eq(slave_sel)
		
		# connect master->slaves signals except cyc
		for slave in slaves:
			for name, size, direction in _layout:
				if direction == DIR_M_TO_S and name != "cyc":
					self.comb += getattr(slave[1], name).eq(getattr(master, name))
		
		# combine cyc with slave selection signals
		self.comb += [slave[1].cyc.eq(master.cyc & slave_sel[i])
			for i, slave in enumerate(slaves)]
		
		# generate master ack (resp. err) by ORing all slave acks (resp. errs)
		self.comb += [
			master.ack.eq(optree("|", [slave[1].ack for slave in slaves])),
			master.err.eq(optree("|", [slave[1].err for slave in slaves]))
		]
		
		# mux (1-hot) slave data return
		masked = [Replicate(slave_sel_r[i], flen(master.dat_r)) & slaves[i][1].dat_r for i in range(ns)]
		self.comb += master.dat_r.eq(optree("|", masked))

class InterconnectShared(Module):
	def __init__(self, masters, slaves, register=False):
		shared = Interface()
		self.submodules += Arbiter(masters, shared)
		self.submodules += Decoder(shared, slaves, register)

class Crossbar(Module):
	def __init__(self, masters, slaves, register=False):
		matches, busses = zip(*slaves)
		access = [[Interface() for j in slaves] for i in masters]
		# decode each master into its access row
		for row, master in zip(access, masters):
			row = list(zip(matches, row))
			self.submodules += Decoder(master, row, register)
		# arbitrate each access column onto its slave
		for column, bus in zip(zip(*access), busses):
			self.submodules += Arbiter(column, bus)

class DownConverter(Module):
	# DownConverter splits Wishbone accesses of N bits in M accesses of L bits where:
	# N is the original data-width
	# L is the target data-width
	# M = N/L
	def __init__(self, dw_i, dw_o):
		self.wishbone_i = Interface(dw_i)
		self.wishbone_o = Interface(dw_o)
		self.ratio = dw_i//dw_o

		###
		
		rst = Signal()

		# generate internal write and read ack
		write_ack = Signal()
		read_ack = Signal()
		ack = Signal()
		self.comb += [
			ack.eq(self.wishbone_o.cyc & self.wishbone_o.stb & self.wishbone_o.ack),
			write_ack.eq(ack & self.wishbone_o.we),
			read_ack.eq(ack & ~self.wishbone_o.we)
		]
		
		# accesses counter logic
		cnt = Signal(max=self.ratio)
		self.sync += If(rst, cnt.eq(0)).Elif(ack, cnt.eq(cnt + 1))
		
		# read data path
		dat_r = Signal(dw_i)
		self.sync += If(ack, dat_r.eq(Cat(self.wishbone_o.dat_r, dat_r[:dw_i-dw_o])))
		
		# write data path
		dat_w = Signal(dw_i)
		self.comb += dat_w.eq(self.wishbone_i.dat_w)
		
		# errors generation
		err = Signal()
		self.sync += If(ack, err.eq(self.wishbone_o.err))
		
		# direct connection of wishbone_i --> wishbone_o signals
		for name, size, direction in self.wishbone_i.layout:
			if direction == DIR_M_TO_S and name not in ["adr", "dat_w"]:
				self.comb += getattr(self.wishbone_o, name).eq(getattr(self.wishbone_i, name))
		
		# adaptation of adr & dat signals
		self.comb += [
			self.wishbone_o.adr[0:flen(cnt)].eq(cnt),
			self.wishbone_o.adr[flen(cnt):].eq(self.wishbone_i.adr)
		]
		
		self.comb += chooser(dat_w, cnt, self.wishbone_o.dat_w, reverse=True)
		
		# fsm
		fsm = FSM(reset_state="IDLE")
		self.submodules += fsm
		
		fsm.act("IDLE",
			If(write_ack, NextState("WRITE_ADAPT")),
			If(read_ack, NextState("READ_ADAPT"))
		)
		
		fsm.act("WRITE_ADAPT",
			If(write_ack & (cnt == self.ratio-1),
				NextState("IDLE"),
				rst.eq(1),
				self.wishbone_i.err.eq(err | self.wishbone_o.err),
				self.wishbone_i.ack.eq(1),
			)
		)
		
		master_i_dat_r = Signal(dw_i)
		self.comb += master_i_dat_r.eq(Cat(self.wishbone_o.dat_r, dat_r[:dw_i-dw_o]))

		fsm.act("READ_ADAPT",
			If(read_ack & (cnt == self.ratio-1),
				NextState("IDLE"),
				rst.eq(1),
				self.wishbone_i.err.eq(err | self.wishbone_o.err),
				self.wishbone_i.ack.eq(1),
				self.wishbone_i.dat_r.eq(master_i_dat_r)
			)
		)

class Tap(Module):
	def __init__(self, bus, handler=print):
		self.bus = bus
		self.handler = handler
	
	def do_simulation(self, selfp):
		if selfp.bus.ack:
			assert(selfp.bus.cyc and selfp.bus.stb)
			if selfp.bus.we:
				transaction = TWrite(selfp.bus.adr,
					selfp.bus.dat_w,
					selfp.bus.sel)
			else:
				transaction = TRead(selfp.bus.adr,
					selfp.bus.dat_r)
			self.handler(transaction)
	do_simulation.passive = True

class Initiator(Module):
	def __init__(self, generator, bus=None):
		self.generator = generator
		if bus is None:
			bus = Interface()
		self.bus = bus
		self.transaction_start = 0
		self.transaction = None
	
	def do_simulation(self, selfp):
		if self.transaction is None or selfp.bus.ack:
			if self.transaction is not None:
				self.transaction.latency = selfp.simulator.cycle_counter - self.transaction_start - 1
				if isinstance(self.transaction, TRead):
					self.transaction.data = selfp.bus.dat_r
			try:
				self.transaction = next(self.generator)
			except StopIteration:
				selfp.bus.cyc = 0
				selfp.bus.stb = 0
				raise StopSimulation
			if self.transaction is not None:
				self.transaction_start = selfp.simulator.cycle_counter
				selfp.bus.cyc = 1
				selfp.bus.stb = 1
				selfp.bus.adr = self.transaction.address
				if isinstance(self.transaction, TWrite):
					selfp.bus.we = 1
					selfp.bus.sel = self.transaction.sel
					selfp.bus.dat_w = self.transaction.data
				else:
					selfp.bus.we = 0
			else:
				selfp.bus.cyc = 0
				selfp.bus.stb = 0

class TargetModel:
	def read(self, address):
		return 0
	
	def write(self, address, data, sel):
		pass
	
	def can_ack(self, bus):
		return True

class Target(Module):
	def __init__(self, model, bus=None):
		if bus is None:
			bus = Interface()
		self.bus = bus
		self.model = model
	
	def do_simulation(self, selfp):
		bus = selfp.bus
		if not bus.ack:
			if self.model.can_ack(bus) and bus.cyc and bus.stb:
				if bus.we:
					self.model.write(bus.adr, bus.dat_w, bus.sel)
				else:
					bus.dat_r = self.model.read(bus.adr)
				bus.ack = 1
		else:
			bus.ack = 0
	do_simulation.passive = True

class SRAM(Module):
	def __init__(self, mem_or_size, read_only=None, init=None, bus=None):
		if bus is None:
			bus = Interface()
		self.bus = bus
		bus_data_width = flen(self.bus.dat_r)
		if isinstance(mem_or_size, Memory):
			assert(mem_or_size.width <= bus_data_width)
			self.mem = mem_or_size
		else:
			self.mem = Memory(bus_data_width, mem_or_size//(bus_data_width//8), init=init)
		if read_only is None:
			if hasattr(self.mem, "bus_read_only"):
				read_only = self.mem.bus_read_only
			else:
				read_only = False
	
		###
	
		# memory
		port = self.mem.get_port(write_capable=not read_only, we_granularity=8)
		self.specials += self.mem, port
		# generate write enable signal
		if not read_only:
			self.comb += [port.we[i].eq(self.bus.cyc & self.bus.stb & self.bus.we & self.bus.sel[i])
				for i in range(4)]
		# address and data
		self.comb += [
			port.adr.eq(self.bus.adr[:flen(port.adr)]),
			self.bus.dat_r.eq(port.dat_r)
		]
		if not read_only:
			self.comb += port.dat_w.eq(self.bus.dat_w),
		# generate ack
		self.sync += [
			self.bus.ack.eq(0),
			If(self.bus.cyc & self.bus.stb & ~self.bus.ack,	self.bus.ack.eq(1))
		]

########NEW FILE########
__FILENAME__ = wishbone2csr
from migen.fhdl.std import *
from migen.bus import wishbone
from migen.bus import csr
from migen.genlib.misc import timeline

class WB2CSR(Module):
	def __init__(self, bus_wishbone=None, bus_csr=None):
		if bus_wishbone is None:
			bus_wishbone = wishbone.Interface()
		self.wishbone = bus_wishbone
		if bus_csr is None:
			bus_csr = csr.Interface()
		self.csr = bus_csr
	
		###

		self.sync += [
			self.csr.we.eq(0),
			self.csr.dat_w.eq(self.wishbone.dat_w),
			self.csr.adr.eq(self.wishbone.adr),
			self.wishbone.dat_r.eq(self.csr.dat_r)
		]
		self.sync += timeline(self.wishbone.cyc & self.wishbone.stb, [
			(1, [self.csr.we.eq(self.wishbone.we)]),
			(2, [self.wishbone.ack.eq(1)]),
			(3, [self.wishbone.ack.eq(0)])
		])

########NEW FILE########
__FILENAME__ = wishbone2lasmi
from migen.fhdl.std import *
from migen.bus import wishbone
from migen.genlib.fsm import FSM, NextState
from migen.genlib.misc import split, displacer, chooser
from migen.genlib.record import Record, layout_len

# cachesize (in 32-bit words) is the size of the data store, must be a power of 2
class WB2LASMI(Module):
	def __init__(self, cachesize, lasmim):
		self.wishbone = wishbone.Interface()

		###

		data_width = flen(self.wishbone.dat_r)
		if lasmim.dw > data_width and (lasmim.dw % data_width) != 0:
			raise ValueError("LASMI data width must be a multiple of {dw}".format(dw=data_width))
		if lasmim.dw < data_width and (data_width % lasmim.dw) != 0:
			raise ValueError("WISHBONE data width must be a multiple of {dw}".format(dw=lasmim.dw))

		# Split address:
		# TAG | LINE NUMBER | LINE OFFSET
		offsetbits = log2_int(max(lasmim.dw//data_width, 1))
		addressbits = lasmim.aw + offsetbits
		linebits = log2_int(cachesize) - offsetbits
		tagbits = addressbits - linebits
		wordbits = log2_int(max(data_width//lasmim.dw, 1))
		adr_offset, adr_line, adr_tag = split(self.wishbone.adr, offsetbits, linebits, tagbits)
		word = Signal(wordbits) if wordbits else None
		
		# Data memory
		data_mem = Memory(lasmim.dw*2**wordbits, 2**linebits)
		data_port = data_mem.get_port(write_capable=True, we_granularity=8)
		self.specials += data_mem, data_port
		
		write_from_lasmi = Signal()
		write_to_lasmi = Signal()
		if adr_offset is None:
			adr_offset_r = None
		else:
			adr_offset_r = Signal(offsetbits)
			self.sync += adr_offset_r.eq(adr_offset)

		self.comb += [
			data_port.adr.eq(adr_line),
			If(write_from_lasmi,
				displacer(lasmim.dat_r, word, data_port.dat_w),
				displacer(Replicate(1, lasmim.dw//8), word, data_port.we)
			).Else(
				data_port.dat_w.eq(Replicate(self.wishbone.dat_w, max(lasmim.dw//data_width, 1))),
				If(self.wishbone.cyc & self.wishbone.stb & self.wishbone.we & self.wishbone.ack,
					displacer(self.wishbone.sel, adr_offset, data_port.we, 2**offsetbits, reverse=True)
				)
			),
			If(write_to_lasmi, 
				chooser(data_port.dat_r, word, lasmim.dat_w),
				lasmim.dat_we.eq(2**(lasmim.dw//8)-1)
			),
			chooser(data_port.dat_r, adr_offset_r, self.wishbone.dat_r, reverse=True)
		]

		
		# Tag memory
		tag_layout = [("tag", tagbits), ("dirty", 1)]
		tag_mem = Memory(layout_len(tag_layout), 2**linebits)
		tag_port = tag_mem.get_port(write_capable=True)
		self.specials += tag_mem, tag_port
		tag_do = Record(tag_layout)
		tag_di = Record(tag_layout)
		self.comb += [
			tag_do.raw_bits().eq(tag_port.dat_r),
			tag_port.dat_w.eq(tag_di.raw_bits())
		]
			
		self.comb += [
			tag_port.adr.eq(adr_line),
			tag_di.tag.eq(adr_tag)
		]
		if word is not None:
			self.comb += lasmim.adr.eq(Cat(word, adr_line, tag_do.tag))
		else:
			self.comb += lasmim.adr.eq(Cat(adr_line, tag_do.tag))		
			
		# Lasmim word computation, word_clr and word_inc will be simplified
		# at synthesis when wordbits=0
		word_clr = Signal()
		word_inc = Signal()
		if word is not None:
			self.sync += \
				If(word_clr,
					word.eq(0),
				).Elif(word_inc,
					word.eq(word+1)
				)

		def word_is_last(word):
			if word is not None:
				return word == 2**wordbits-1
			else:
				return 1

		# Control FSM
		assert(lasmim.write_latency >= 1 and lasmim.read_latency >= 1)
		fsm = FSM(reset_state="IDLE")
		self.submodules += fsm
		
		fsm.delayed_enter("EVICT_DATAD", "EVICT_DATA", lasmim.write_latency-1)
		fsm.delayed_enter("REFILL_DATAD", "REFILL_DATA", lasmim.read_latency-1)

		fsm.act("IDLE",
			If(self.wishbone.cyc & self.wishbone.stb, NextState("TEST_HIT"))
		)
		fsm.act("TEST_HIT",
			word_clr.eq(1),
			If(tag_do.tag == adr_tag,
				self.wishbone.ack.eq(1),
				If(self.wishbone.we,
					tag_di.dirty.eq(1),
					tag_port.we.eq(1)
				),
				NextState("IDLE")
			).Else(
				If(tag_do.dirty,
					NextState("EVICT_REQUEST")
				).Else(
					NextState("REFILL_WRTAG")
				)
			)
		)
		
		fsm.act("EVICT_REQUEST",
			lasmim.stb.eq(1),
			lasmim.we.eq(1),
			If(lasmim.req_ack, NextState("EVICT_WAIT_DATA_ACK"))
		)
		fsm.act("EVICT_WAIT_DATA_ACK",
			If(lasmim.dat_ack, NextState("EVICT_DATAD"))
		)
		fsm.act("EVICT_DATA",
			write_to_lasmi.eq(1),
			word_inc.eq(1),
			If(word_is_last(word),
				NextState("REFILL_WRTAG"),
			).Else(
				NextState("EVICT_REQUEST")
			)
		)
		
		fsm.act("REFILL_WRTAG",
			# Write the tag first to set the LASMI address
			tag_port.we.eq(1),
			word_clr.eq(1),
			NextState("REFILL_REQUEST")
		)
		fsm.act("REFILL_REQUEST",
			lasmim.stb.eq(1),
			If(lasmim.req_ack, NextState("REFILL_WAIT_DATA_ACK"))
		)
		fsm.act("REFILL_WAIT_DATA_ACK",
			If(lasmim.dat_ack, NextState("REFILL_DATAD"))
		)
		fsm.act("REFILL_DATA",
			write_from_lasmi.eq(1),
			word_inc.eq(1),
			If(word_is_last(word),
				NextState("TEST_HIT"),
			).Else(
				NextState("REFILL_REQUEST")
			)
		)

########NEW FILE########
__FILENAME__ = bitcontainer
from migen.fhdl import structure as f

def log2_int(n, need_pow2=True):
	l = 1
	r = 0
	while l < n:
		l *= 2
		r += 1
	if need_pow2 and l != n:
		raise ValueError("Not a power of 2")
	return r

def bits_for(n, require_sign_bit=False):
	if n > 0:
		r = log2_int(n + 1, False)
	else:
		require_sign_bit = True
		r = log2_int(-n, False)
	if require_sign_bit:
		r += 1
	return r

def value_bits_sign(v):
	if isinstance(v, bool):
		return 1, False
	elif isinstance(v, int):
		return bits_for(v), v < 0
	elif isinstance(v, f.Signal):
		return v.nbits, v.signed
	elif isinstance(v, (f.ClockSignal, f.ResetSignal)):
		return 1, False
	elif isinstance(v, f._Operator):
		obs = list(map(value_bits_sign, v.operands))
		if v.op == "+" or v.op == "-":
			if not obs[0][1] and not obs[1][1]:
				# both operands unsigned
				return max(obs[0][0], obs[1][0]) + 1, False
			elif obs[0][1] and obs[1][1]:
				# both operands signed
				return max(obs[0][0], obs[1][0]) + 1, True
			elif not obs[0][1] and obs[1][1]:
				# first operand unsigned (add sign bit), second operand signed
				return max(obs[0][0] + 1, obs[1][0]) + 1, True
			else:
				# first signed, second operand unsigned (add sign bit)
				return max(obs[0][0], obs[1][0] + 1) + 1, True
		elif v.op == "*":
			if not obs[0][1] and not obs[1][1]:
				# both operands unsigned
				return obs[0][0] + obs[1][0]
			elif obs[0][1] and obs[1][1]:
				# both operands signed
				return obs[0][0] + obs[1][0] - 1
			else:
				# one operand signed, the other unsigned (add sign bit)
				return obs[0][0] + obs[1][0] + 1 - 1
		elif v.op == "<<<":
			if obs[1][1]:
				extra = 2**(obs[1][0] - 1) - 1
			else:
				extra = 2**obs[1][0] - 1
			return obs[0][0] + extra, obs[0][1]
		elif v.op == ">>>":
			if obs[1][1]:
				extra = 2**(obs[1][0] - 1)
			else:
				extra = 0
			return obs[0][0] + extra, obs[0][1]
		elif v.op == "&" or v.op == "^" or v.op == "|":
			if not obs[0][1] and not obs[1][1]:
				# both operands unsigned
				return max(obs[0][0], obs[1][0]), False
			elif obs[0][1] and obs[1][1]:
				# both operands signed
				return max(obs[0][0], obs[1][0]), True
			elif not obs[0][1] and obs[1][1]:
				# first operand unsigned (add sign bit), second operand signed
				return max(obs[0][0] + 1, obs[1][0]), True
			else:
				# first signed, second operand unsigned (add sign bit)
				return max(obs[0][0], obs[1][0] + 1), True
		elif v.op == "<" or v.op == "<=" or v.op == "==" or v.op == "!=" \
		  or v.op == ">" or v.op == ">=":
			  return 1, False
		elif v.op == "~":
			return obs[0]
		else:
			raise TypeError
	elif isinstance(v, f._Slice):
		return v.stop - v.start, value_bits_sign(v.value)[1]
	elif isinstance(v, f.Cat):
		return sum(value_bits_sign(sv)[0] for sv in v.l), False
	elif isinstance(v, f.Replicate):
		return (value_bits_sign(v.v)[0])*v.n, False
	elif isinstance(v, f._ArrayProxy):
		bsc = list(map(value_bits_sign, v.choices))
		return max(bs[0] for bs in bsc), any(bs[1] for bs in bsc)
	else:
		raise TypeError("Can not calculate bit length of {} {}".format(
			type(v), v))

def flen(v):
	"""Bit length of an expression

	Parameters
	----------
	v : int, bool or Value

	Returns
	-------
	int
		Number of bits required to store `v` or available in `v`

	Examples
	--------
	>>> flen(f.Signal(8))
	8
	>>> flen(0xaa)
	8
	"""
	return value_bits_sign(v)[0]

def fiter(v):
	"""Bit iterator

	Parameters
	----------
	v : int, bool or Value

	Returns
	-------
	iter
		Iterator over the bits in `v`

	Examples
	--------
	>>> list(fiter(f.Signal(2))) #doctest: +ELLIPSIS
	[<migen.fhdl.structure._Slice object at 0x...>, <migen.fhdl.structure._Slice object at 0x...>]
	>>> list(fiter(4))
	[0, 0, 1]
	"""
	if isinstance(v, (bool, int)):
		return ((v >> i) & 1 for i in range(bits_for(v)))
	elif isinstance(v, f.Value):
		return (v[i] for i in range(flen(v)))
	else:
		raise TypeError("Can not bit-iterate {} {}".format(type(v), v))

def fslice(v, s):
	"""Bit slice

	Parameters
	----------
	v : int, bool or Value
	s : slice or int

	Returns
	-------
	int or Value
		Expression for the slice `s` of `v`.

	Examples
	--------
	>>> fslice(f.Signal(2), 1) #doctest: +ELLIPSIS
	<migen.fhdl.structure._Slice object at 0x...>
	>>> bin(fslice(0b1101, slice(1, None, 2)))
	'0b10'
	>>> fslice(-1, slice(0, 4))
	1
	>>> fslice(-7, slice(None))
	9
	"""
	if isinstance(v, (bool, int)):
		if isinstance(s, int):
			s = slice(s)
		idx = range(*s.indices(bits_for(v)))
		return sum(((v >> i) & 1) << j for j, i in enumerate(idx))
	elif isinstance(v, f.Value):
		return v[s]
	else:
		raise TypeError("Can not bit-slice {} {}".format(type(v), v))

def freversed(v):
	"""Bit reverse

	Parameters
	----------
	v : int, bool or Value

	Returns
	-------
	int or Value
		Expression containing the bit reversed input.

	Examples
	--------
	>>> freversed(f.Signal(2)) #doctest: +ELLIPSIS
	<migen.fhdl.structure.Cat object at 0x...>
	>>> bin(freversed(0b1011))
	'0b1101'
	"""
	return fslice(v, slice(None, None, -1))

########NEW FILE########
__FILENAME__ = decorators
from migen.fhdl.structure import *
from migen.fhdl.tools import insert_reset, rename_clock_domain

class ModuleDecorator:
	def __init__(self, decorated):
		object.__setattr__(self, "_md_decorated", decorated)

	def __getattr__(self, name):
		return getattr(self._md_decorated, name)

	def __setattr__(self, name, value):
		return setattr(self._md_decorated, name, value)

	# overload this in derived classes
	def transform_fragment(self, f):
		pass

	def get_fragment(self):
		f = self._md_decorated.get_fragment()
		self.transform_fragment(f)
		return f

	def __dir__(self):
		return dir(self._md_decorated)

class DecorateModule:
	def __init__(self, decorator, *dec_args, **dec_kwargs):
		self.decorator = decorator
		self.dec_args = dec_args
		self.dec_kwargs = dec_kwargs

	def __call__(self, decorated):
		def dfinit(dfself, *args, **kwargs):
			self.decorator.__init__(dfself, decorated(*args, **kwargs),
				*self.dec_args, **self.dec_kwargs)
		typename = self.decorator.__name__ + "(" + decorated.__name__ + ")"
		return type(typename, (self.decorator,), dict(__init__=dfinit))

class InsertControl(ModuleDecorator):
	def __init__(self, control_name, decorated, clock_domains=None):
		ModuleDecorator.__init__(self, decorated)

		object.__setattr__(self, "_ic_control_name", control_name)
		object.__setattr__(self, "_ic_clock_domains", clock_domains)
		
		if clock_domains is None:
			ctl = Signal(name=control_name)
			assert(not hasattr(decorated, control_name))
			object.__setattr__(self, control_name, ctl)
		else:
			for cd in clock_domains:
				name = control_name + "_" + cd
				ctl = Signal(name=name)
				assert(not hasattr(decorated, name))
				object.__setattr__(self, name, ctl)

	def transform_fragment(self, f):
		control_name = self._ic_control_name
		clock_domains = self._ic_clock_domains
		if clock_domains is None:
			if len(f.sync) != 1:
				raise ValueError("Control signal clock domains must be specified when module has more than one domain")
			cdn = list(f.sync.keys())[0]
			to_insert = [(getattr(self, control_name), cdn)]
		else:
			to_insert = [(getattr(self, control_name+"_"+cdn), cdn) for cdn in clock_domains]
		self.transform_fragment_insert(f, to_insert)

class InsertCE(InsertControl):
	def __init__(self, *args, **kwargs):
		InsertControl.__init__(self, "ce", *args, **kwargs)
		
	def transform_fragment_insert(self, f, to_insert):
		for ce, cdn in to_insert:
			f.sync[cdn] = [If(ce, *f.sync[cdn])]

class InsertReset(InsertControl):
	def __init__(self, *args, **kwargs):
		InsertControl.__init__(self, "reset", *args, **kwargs)

	def transform_fragment_insert(self, f, to_insert):
		for reset, cdn in to_insert:
			f.sync[cdn] = insert_reset(reset, f.sync[cdn])

class RenameClockDomains(ModuleDecorator):
	def __init__(self, decorated, cd_remapping):
		ModuleDecorator.__init__(self, decorated)
		if isinstance(cd_remapping, str):
			cd_remapping = {"sys": cd_remapping}
		object.__setattr__(self, "_rc_cd_remapping", cd_remapping)

	def transform_fragment(self, f):
		for old, new in self._rc_cd_remapping.items():
			rename_clock_domain(f, old, new)

########NEW FILE########
__FILENAME__ = edif
from collections import OrderedDict
from migen.fhdl.std import *
from migen.fhdl.namer import build_namespace
from migen.fhdl.tools import list_special_ios
from migen.fhdl.structure import _Fragment

from collections import namedtuple

_Port = namedtuple("_Port", "name direction")
_Cell = namedtuple("_Cell", "name ports")
_Property = namedtuple("_Property", "name value")
_Instance = namedtuple("_Instance", "name cell properties")
_NetBranch = namedtuple("_NetBranch", "portname instancename")
  
def _write_cells(cells):
	r = ""
	for cell in cells:
		r += """
		(cell {0.name}
			(cellType GENERIC)
				(view view_1
					(viewType NETLIST)
					(interface""".format(cell)
		for port in cell.ports:
			r += """
						(port {0.name} (direction {0.direction}))""".format(port)
		r += """
					)
				)
		)"""
	return r

def _write_io(ios):
	r = ""
	for s in ios:
		r += """
						(port {0.name} (direction {0.direction}))""".format(s)
	return r

def _write_instantiations(instances, cell_library):
	instantiations = ""
	for instance in instances:
		instantiations += """
						(instance {0.name}
							(viewRef view_1 (cellRef {0.cell} (libraryRef {1})))""".format(instance, cell_library)
		for prop in instance.properties:
			instantiations += """
							(property {0} (string "{1}"))""".format(prop.name, prop.value)
		instantiations += """
						)"""
	return instantiations

def _write_connections(connections):
	r = ""
	for netname, branches in connections.items():
		r += """
						(net {0}
							(joined""".format(netname)
		for branch in branches:
			r += """
								(portRef {0}{1})""".format(branch.portname, "" if branch.instancename == "" else " (instanceRef {})".format(branch.instancename))
		r += """
							)
						)"""
	return r

def _write_edif(cells, ios, instances, connections, cell_library, design_name, part, vendor):
	r = """(edif {0}
	(edifVersion 2 0 0)
	(edifLevel 0)
	(keywordMap (keywordLevel 0))
	(external {1}
		(edifLevel 0)
		(technology (numberDefinition))""".format(design_name, cell_library)
	r += _write_cells(cells)
	r += """
	)
	(library {0}_lib
		(edifLevel 0)
		(technology (numberDefinition))
		(cell {0}
			(cellType GENERIC)
				(view view_1
					(viewType NETLIST)
					(interface""".format(design_name)
	r += _write_io(ios)
	r += """
						(designator "{0}")
					)
					(contents""".format(part)
	r += _write_instantiations(instances, cell_library)
	r += _write_connections(connections)
	r += """
					)
				)
		)
	)
	(design {0}
		(cellRef {0} (libraryRef {0}_lib))
		(property PART (string "{1}") (owner "{2}"))
	)
)""".format(design_name, part, vendor)
	
	return r

def _generate_cells(f):
	cell_dict = OrderedDict()
	for special in f.specials:
		if isinstance(special, Instance):
			port_list = []
			for port in special.items:
				if isinstance(port, Instance.Input):
					port_list.append(_Port(port.name, "INPUT"))
				elif isinstance(port, Instance.Output):
					port_list.append(_Port(port.name, "OUTPUT"))
				elif isinstance(port, Instance.InOut):
					port_list.append(_Port(port.name, "INOUT"))
				elif isinstance(port, Instance.Parameter):
					pass
				else:
					raise NotImplementedError("Unsupported instance item")
			if special.of in cell_dict:
				if set(port_list) != set(cell_dict[special.of]):
					raise ValueError("All instances must have the same ports for EDIF conversion")
			else:
				cell_dict[special.of] = port_list
		else:
			raise ValueError("Edif conversion can only handle synthesized fragments")
	return [_Cell(k, v) for k, v in cell_dict.items()]

def _generate_instances(f,ns):
	instances = []
	for special in f.specials:
		if isinstance(special, Instance):	
			props = []
			for prop in special.items:
				if isinstance(prop, Instance.Input):
					pass
				elif isinstance(prop, Instance.Output):
					pass
				elif isinstance(prop, Instance.InOut):
					pass
				elif isinstance(prop, Instance.Parameter):
					props.append(_Property(name=prop.name, value=prop.value))
				else:
					raise NotImplementedError("Unsupported instance item")
			instances.append(_Instance(name=ns.get_name(special), cell=special.of, properties=props))
		else:
			raise ValueError("Edif conversion can only handle synthesized fragments")
	return instances

def _generate_ios(f, ios, ns):
	outs = list_special_ios(f, False, True, False)
	inouts = list_special_ios(f, False, False, True)
	r = []
	for io in ios:
		direction = "OUTPUT" if io in outs else "INOUT" if io in inouts else "INPUT"
		r.append(_Port(name=ns.get_name(io), direction=direction))
	return r

def _generate_connections(f, ios, ns):
	r = OrderedDict()
	for special in f.specials:
		if isinstance(special, Instance):
			instname = ns.get_name(special)
			for port in special.items:
				if isinstance(port, Instance._IO):
					s = ns.get_name(port.expr)
					if s not in r:
						r[s] = []
					r[s].append(_NetBranch(portname=port.name, instancename=instname))
				elif isinstance(port, Instance.Parameter):
					pass
				else:
					raise NotImplementedError("Unsupported instance item")
		else:
			raise ValueError("Edif conversion can only handle synthesized fragments")
	for s in ios:
		io = ns.get_name(s)
		if io not in r:
			r[io] = []
		r[io].append(_NetBranch(portname=io, instancename=""))
	return r

def convert(f, ios, cell_library, vendor, device, name="top", return_ns=False):
	if not isinstance(f, _Fragment):
		f = f.get_fragment()
	if f.comb != [] or f.sync != {}:
		raise ValueError("Edif conversion can only handle synthesized fragments")
	if ios is None:
		ios = set()
	cells = _generate_cells(f)
	ns = build_namespace(list_special_ios(f, True, True, True))
	instances = _generate_instances(f, ns)
	inouts = _generate_ios(f, ios, ns)
	connections = _generate_connections(f, ios, ns)
	r =  _write_edif(cells, inouts, instances, connections, cell_library, name, device, vendor)
	if return_ns:
		return r, ns
	else:
		return r

########NEW FILE########
__FILENAME__ = module
import collections
from itertools import combinations

from migen.util.misc import flat_iteration
from migen.fhdl.structure import *
from migen.fhdl.structure import _Fragment
from migen.fhdl.tools import rename_clock_domain
from migen.sim.upper import gen_sim, proxy_sim

class FinalizeError(Exception):
	pass

def _flat_list(e):
	if isinstance(e, collections.Iterable):
		return flat_iteration(e)
	else:
		return [e]

class _ModuleProxy:
	def __init__(self, fm):
		object.__setattr__(self, "_fm", fm)

class _ModuleComb(_ModuleProxy):
	def __iadd__(self, other):
		self._fm._fragment.comb += _flat_list(other)
		return self

def _cd_append(d, key, statements):
	try:
		l = d[key]
	except KeyError:
		l = []
		d[key] = l
	l += _flat_list(statements)

class _ModuleSyncCD:
	def __init__(self, fm, cd):
		self._fm = fm
		self._cd = cd

	def __iadd__(self, other):
		_cd_append(self._fm._fragment.sync, self._cd, other)
		return self

class _ModuleSync(_ModuleProxy):
	def __iadd__(self, other):
		_cd_append(self._fm._fragment.sync, "sys", other)
		return self

	def __getattr__(self, name):
		return _ModuleSyncCD(self._fm, name)

	def __setattr__(self, name, value):
		if not isinstance(value, _ModuleSyncCD):
			raise AttributeError("Attempted to assign sync property - use += instead")

# _ModuleForwardAttr enables user classes to do e.g.:
# self.subm.foobar = SomeModule()
# and then access the submodule with self.foobar.
class _ModuleForwardAttr:
	def __setattr__(self, name, value):
		self.__iadd__(value)
		setattr(self._fm, name, value)

class _ModuleSpecials(_ModuleProxy, _ModuleForwardAttr):
	def __iadd__(self, other):
		self._fm._fragment.specials |= set(_flat_list(other))
		return self

class _ModuleSubmodules(_ModuleProxy):
	def __setattr__(self, name, value):
		self._fm._submodules += [(name, e) for e in _flat_list(value)]
		setattr(self._fm, name, value)
	
	def __iadd__(self, other):
		self._fm._submodules += [(None, e) for e in _flat_list(other)]
		return self

class _ModuleClockDomains(_ModuleProxy, _ModuleForwardAttr):
	def __iadd__(self, other):
		self._fm._fragment.clock_domains += _flat_list(other)
		return self

class Module:
	def get_fragment(self):
		assert(not self._get_fragment_called)
		self._get_fragment_called = True
		self.finalize()
		return self._fragment

	def __getattr__(self, name):
		if name == "comb":
			return _ModuleComb(self)
		elif name == "sync":
			return _ModuleSync(self)
		elif name == "specials":
			return _ModuleSpecials(self)
		elif name == "submodules":
			return _ModuleSubmodules(self)
		elif name == "clock_domains":
			return _ModuleClockDomains(self)

		# hack to have initialized regular attributes without using __init__
		# (which would require derived classes to call it)
		elif name == "finalized":
			self.finalized = False
			return self.finalized
		elif name == "_fragment":
			simf = None
			try:
				simf = self.do_simulation
			except AttributeError:
				try:
					simg = self.gen_simulation
				except AttributeError:
					pass
				else:
					simf = gen_sim(simg)
			if simf is not None:
				simf = proxy_sim(self, simf)
			sim = [] if simf is None else [simf]
			self._fragment = _Fragment(sim=sim)
			return self._fragment
		elif name == "_submodules":
			self._submodules = []
			return self._submodules
		elif name == "_clock_domains":
			self._clock_domains = []
			return self._clock_domains
		elif name == "_get_fragment_called":
			self._get_fragment_called = False
			return self._get_fragment_called

		else:
			raise AttributeError("'"+self.__class__.__name__+"' object has no attribute '"+name+"'")

	def __setattr__(self, name, value):
		if name in ["comb", "sync", "specials", "submodules", "clock_domains"]:
			if not isinstance(value, _ModuleProxy):
				raise AttributeError("Attempted to assign special Module property - use += instead")
		else:
			object.__setattr__(self, name, value)

	def _collect_submodules(self):
		r = [(name, submodule.get_fragment()) for name, submodule in self._submodules]
		self._submodules = []
		return r

	def finalize(self, *args, **kwargs):
		if not self.finalized:
			self.finalized = True
			# finalize existing submodules before finalizing us
			subfragments = self._collect_submodules()
			self.do_finalize(*args, **kwargs)
			# finalize submodules created by do_finalize
			subfragments += self._collect_submodules()
			# resolve clock domain name conflicts
			needs_renaming = set()
			for (mod_name1, f1), (mod_name2, f2) in combinations(subfragments, 2):
				f1_names = set(cd.name for cd in f1.clock_domains)
				f2_names = set(cd.name for cd in f2.clock_domains)
				common_names = f1_names & f2_names
				if common_names:
					if mod_name1 is None or mod_name2 is None:
						raise ValueError("Multiple submodules with local clock domains cannot be anonymous")
					if mod_name1 == mod_name2:
						raise ValueError("Multiple submodules with local clock domains cannot have the same name")
				needs_renaming |= common_names
			for mod_name, f in subfragments:
				for cd in f.clock_domains:
					if cd.name in needs_renaming:
						rename_clock_domain(f, cd.name, mod_name + "_" + cd.name)
			# sum subfragments
			for mod_name, f in subfragments:
				self._fragment += f

	def do_finalize(self):
		pass

########NEW FILE########
__FILENAME__ = namer
from collections import OrderedDict
from itertools import combinations

from migen.fhdl.structure import *

class _Node:
	def __init__(self):
		self.signal_count = 0
		self.numbers = set()
		self.use_name = False
		self.use_number = False
		self.children = OrderedDict()

def _display_tree(filename, tree):
	from migen.util.treeviz import RenderNode
	
	def _to_render_node(name, node):
		children = [_to_render_node(k, v) for k, v in node.children.items()]
		if node.use_name:
			if node.use_number:
				color = (0.5, 0.9, 0.8)
			else:
				color = (0.8, 0.5, 0.9)
		else:
			if node.use_number:
				color = (0.9, 0.8, 0.5)
			else:
				color = (0.8, 0.8, 0.8)
		label = "{0}\n{1} signals\n{2}".format(name, node.signal_count, node.numbers)
		return RenderNode(label, children, color=color)

	top = _to_render_node("top", tree)
	top.to_svg(filename)

def _build_tree(signals, basic_tree=None):
	root = _Node()
	for signal in signals:
		current_b = basic_tree
		current = root
		current.signal_count += 1
		for name, number in signal.backtrace:
			if basic_tree is None:
				use_number = False
			else:
				current_b = current_b.children[name]
				use_number = current_b.use_number
			if use_number:
				key = (name, number)
			else:
				key = name
			try:
				current = current.children[key]
			except KeyError:
				new = _Node()
				current.children[key] = new
				current = new
			current.numbers.add(number)
			if use_number:
				current.all_numbers = sorted(current_b.numbers)
			current.signal_count += 1
	return root

def _set_use_name(node, node_name=""):
	cnames = [(k, _set_use_name(v, k)) for k, v in node.children.items()]
	for (c1_prefix, c1_names), (c2_prefix, c2_names) in combinations(cnames, 2):
		if not c1_names.isdisjoint(c2_names):
			node.children[c1_prefix].use_name = True
			node.children[c2_prefix].use_name = True
	r = set()
	for c_prefix, c_names in cnames:
		if node.children[c_prefix].use_name:
			for c_name in c_names:
				r.add((c_prefix, ) + c_name)
		else:
			r |= c_names
	
	if node.signal_count > sum(c.signal_count for c in node.children.values()):
		node.use_name = True
		r.add((node_name, ))

	return r
		
def _name_signal(tree, signal):
	elements = []
	treepos = tree
	for step_name, step_n in signal.backtrace:
		try:
			treepos = treepos.children[(step_name, step_n)]
			use_number = True
		except KeyError:
			treepos = treepos.children[step_name]
			use_number = False
		if treepos.use_name:
			elname = step_name
			if use_number:
				elname += str(treepos.all_numbers.index(step_n))
			elements.append(elname)
	return "_".join(elements)

def _build_pnd_from_tree(tree, signals):
	return dict((signal, _name_signal(tree, signal)) for signal in signals)

def _invert_pnd(pnd):
	inv_pnd = dict()
	for k, v in pnd.items():
		inv_pnd[v] = inv_pnd.get(v, [])
		inv_pnd[v].append(k)
	return inv_pnd

def _list_conflicting_signals(pnd):
	inv_pnd = _invert_pnd(pnd)
	r = set()
	for k, v in inv_pnd.items():
		if len(v) > 1:
			r.update(v)
	return r

def _set_use_number(tree, signals):
	for signal in signals:
		current = tree
		for step_name, step_n in signal.backtrace:
			current = current.children[step_name]
			current.use_number = current.signal_count > len(current.numbers) and len(current.numbers) > 1

_debug = False

def _build_pnd_for_group(group_n, signals):
	basic_tree = _build_tree(signals)
	_set_use_name(basic_tree)
	if _debug:
		_display_tree("tree{0}_basic.svg".format(group_n), basic_tree)
	pnd = _build_pnd_from_tree(basic_tree, signals)

	# If there are conflicts, try splitting the tree by numbers
	# on paths taken by conflicting signals.
	conflicting_signals = _list_conflicting_signals(pnd)
	if conflicting_signals:
		_set_use_number(basic_tree, conflicting_signals)
		if _debug:
			print("namer: using split-by-number strategy (group {0})".format(group_n))
			_display_tree("tree{0}_marked.svg".format(group_n), basic_tree)
		numbered_tree = _build_tree(signals, basic_tree)
		_set_use_name(numbered_tree)
		if _debug:
			_display_tree("tree{0}_numbered.svg".format(group_n), numbered_tree)
		pnd = _build_pnd_from_tree(numbered_tree, signals)
	else:
		if _debug:
			print("namer: using basic strategy (group {0})".format(group_n))
	
	# ...then add number suffixes by HUID
	inv_pnd = _invert_pnd(pnd)
	huid_suffixed = False
	for name, signals in inv_pnd.items():
		if len(signals) > 1:
			huid_suffixed = True
			for n, signal in enumerate(sorted(signals, key=lambda x: x.huid)):
				pnd[signal] += str(n)
	if _debug and huid_suffixed:
		print("namer: using HUID suffixes (group {0})".format(group_n))

	return pnd

def _build_signal_groups(signals):
	r = []
	for signal in signals:
		# build chain of related signals
		related_list = []
		cur_signal = signal
		while cur_signal is not None:
			related_list.insert(0, cur_signal)
			cur_signal = cur_signal.related
		# add to groups
		r += [set()]*(len(related_list) - len(r))
		for target_set, source_set in zip(r, related_list):
			target_set.add(source_set)
	# with the algorithm above and a list of all signals,
	# a signal appears in all groups of a lower number than its.
	# make signals appear only in their group of highest number.
	for s1, s2 in zip(r, r[1:]):
		s1 -= s2
	return r

def _build_pnd(signals):
	groups = _build_signal_groups(signals)
	gpnds = [_build_pnd_for_group(n, gsignals) for n, gsignals in enumerate(groups)]

	pnd = dict()
	for gn, gpnd in enumerate(gpnds):
		for signal, name in gpnd.items():
			result = name
			cur_gn = gn
			cur_signal = signal
			while cur_signal.related is not None:
				cur_signal = cur_signal.related
				cur_gn -= 1
				result = gpnds[cur_gn][cur_signal] + "_" + result
			pnd[signal] = result

	return pnd

def build_namespace(signals):
	pnd = _build_pnd(signals)
	ns = Namespace(pnd)
	# register signals with name_override
	for signal in signals:
		if signal.name_override is not None:
			ns.get_name(signal)
	return ns

class Namespace:
	def __init__(self, pnd):
		self.counts = {}
		self.sigs = {}
		self.pnd = pnd
	
	def get_name(self, sig):
		if sig.name_override is not None:
			sig_name = sig.name_override
		else:
			sig_name = self.pnd[sig]
		try:
			n = self.sigs[sig]
		except KeyError:
			try:
				n = self.counts[sig_name]
			except KeyError:
				n = 0
			self.sigs[sig] = n
			self.counts[sig_name] = n + 1
		if n:
			return sig_name + "_" + str(n)
		else:
			return sig_name

########NEW FILE########
__FILENAME__ = simplify
from migen.fhdl.std import *
from migen.fhdl.specials import _MemoryPort
from migen.fhdl.decorators import ModuleDecorator
from migen.util.misc import gcd_multiple

class FullMemoryWE(ModuleDecorator):
	def transform_fragment(self, f):
		newspecials = set()

		for orig in f.specials:
			if not isinstance(orig, Memory):
				newspecials.add(orig)
				continue
			global_granularity = gcd_multiple([p.we_granularity if p.we_granularity else orig.width for p in orig.ports])
			if global_granularity == orig.width:
				newspecials.add(orig) # nothing to do
			else:
				for i in range(orig.width//global_granularity):
					if orig.init is None:
						newinit = None
					else:
						newinit = [(v >> i*global_granularity) & (2**global_granularity - 1) for v in orig.init]
					newmem = Memory(global_granularity, orig.depth, newinit, orig.name_override + "_grain" + str(i))
					newspecials.add(newmem)
					for port in orig.ports:
						port_granularity = port.we_granularity if port.we_granularity else orig.width
						newport = _MemoryPort(adr=port.adr,
							
							dat_r=port.dat_r[i*global_granularity:(i+1)*global_granularity] if port.dat_r is not None else None,
							we=port.we[i*global_granularity//port_granularity] if port.we is not None else None,
							dat_w=port.dat_w[i*global_granularity:(i+1)*global_granularity] if port.dat_w is not None else None,

	  						async_read=port.async_read,
	  						re=port.re,
	  						we_granularity=0,
	  						mode=port.mode,
	  						clock_domain=port.clock)
						newmem.ports.append(newport)
						newspecials.add(newport)

		f.specials = newspecials

########NEW FILE########
__FILENAME__ = specials
from operator import itemgetter

from migen.fhdl.structure import *
from migen.fhdl.bitcontainer import bits_for, value_bits_sign
from migen.fhdl.tools import *
from migen.fhdl.tracer import get_obj_var_name
from migen.fhdl.verilog import _printexpr as verilog_printexpr

class Special(HUID):
	def iter_expressions(self):
		for x in []:
			yield x

	def rename_clock_domain(self, old, new):
		for obj, attr, direction in self.iter_expressions():
			rename_clock_domain_expr(getattr(obj, attr), old, new)

	def list_clock_domains(self):
		r = set()
		for obj, attr, direction in self.iter_expressions():
			r |= list_clock_domains_expr(getattr(obj, attr))
		return r

	def list_ios(self, ins, outs, inouts):
		r = set()
		for obj, attr, direction in self.iter_expressions():
			if (direction == SPECIAL_INPUT and ins) \
			  or (direction == SPECIAL_OUTPUT and outs) \
			  or (direction == SPECIAL_INOUT and inouts):
				signals = list_signals(getattr(obj, attr))
				r.update(signals)
		return r

class Tristate(Special):
	def __init__(self, target, o, oe, i=None):
		Special.__init__(self)
		self.target = target
		self.o = o
		self.oe = oe
		self.i = i

	def iter_expressions(self):
		for attr, target_context in [
		  ("target", SPECIAL_INOUT),
		  ("o", SPECIAL_INPUT),
		  ("oe", SPECIAL_INPUT),
		  ("i", SPECIAL_OUTPUT)]:
			yield self, attr, target_context

	@staticmethod
	def emit_verilog(tristate, ns):
		def pe(e):
			return verilog_printexpr(ns, e)[0]
		w, s = value_bits_sign(tristate.target)
		r = "assign " + pe(tristate.target) + " = " \
			+ pe(tristate.oe) + " ? " + pe(tristate.o) \
			+ " : " + str(w) + "'bz;\n"
		if tristate.i is not None:
			r += "assign " + pe(tristate.i) + " = " + pe(tristate.target) + ";\n"
		r += "\n"
		return r

class TSTriple:
	def __init__(self, bits_sign=None, min=None, max=None, reset_o=0, reset_oe=0):
		self.o = Signal(bits_sign, min=min, max=max, reset=reset_o)
		self.oe = Signal(reset=reset_oe)
		self.i = Signal(bits_sign, min=min, max=max)

	def get_tristate(self, target):
		return Tristate(target, self.o, self.oe, self.i)

class Instance(Special):
	class _IO:
		def __init__(self, name, expr=None):
			self.name = name
			if expr is None:
				expr = Signal()
			self.expr = expr
	class Input(_IO):
		pass	
	class Output(_IO):
		pass
	class InOut(_IO):
		pass
	class Parameter:
		def __init__(self, name, value):
			self.name = name
			self.value = value
	class PreformattedParam(str):
		pass

	def __init__(self, of, *items, name="", **kwargs):
		Special.__init__(self)
		self.of = of
		if name:
			self.name_override = name
		else:
			self.name_override = of
		self.items = list(items)
		for k, v in sorted(kwargs.items(), key=itemgetter(0)):
			item_type, item_name = k.split("_", maxsplit=1)
			item_class = {
				"i": Instance.Input,
				"o": Instance.Output,
				"io": Instance.InOut,
				"p": Instance.Parameter
			}[item_type]
			self.items.append(item_class(item_name, v))
	
	def get_io(self, name):
		for item in self.items:
			if isinstance(item, Instance._IO) and item.name == name:
				return item.expr

	def iter_expressions(self):
		for item in self.items:
			if isinstance(item, Instance.Input):
				yield item, "expr", SPECIAL_INPUT
			elif isinstance(item, Instance.Output):
				yield item, "expr", SPECIAL_OUTPUT
			elif isinstance(item, Instance.InOut):
				yield item, "expr", SPECIAL_INOUT

	@staticmethod
	def emit_verilog(instance, ns):
		r = instance.of + " "
		parameters = list(filter(lambda i: isinstance(i, Instance.Parameter), instance.items))
		if parameters:
			r += "#(\n"
			firstp = True
			for p in parameters:
				if not firstp:
					r += ",\n"
				firstp = False
				r += "\t." + p.name + "("
				if isinstance(p.value, (int, bool)):
					r += verilog_printexpr(ns, p.value)[0]
				elif isinstance(p.value, float):
					r += str(p.value)
				elif isinstance(p.value, Instance.PreformattedParam):
					r += p.value
				elif isinstance(p.value, str):
					r += "\"" + p.value + "\""
				else:
					raise TypeError
				r += ")"
			r += "\n) "
		r += ns.get_name(instance) 
		if parameters: r += " "
		r += "(\n"
		firstp = True
		for p in instance.items:
			if isinstance(p, Instance._IO):
				name_inst = p.name
				name_design = verilog_printexpr(ns, p.expr)[0]
				if not firstp:
					r += ",\n"
				firstp = False
				r += "\t." + name_inst + "(" + name_design + ")"
		if not firstp:
			r += "\n"
		r += ");\n\n"
		return r

(READ_FIRST, WRITE_FIRST, NO_CHANGE) = range(3)

class _MemoryPort(Special):
	def __init__(self, adr, dat_r, we=None, dat_w=None,
	  async_read=False, re=None, we_granularity=0, mode=WRITE_FIRST,
	  clock_domain="sys"):
		Special.__init__(self)
		self.adr = adr
		self.dat_r = dat_r
		self.we = we
		self.dat_w = dat_w
		self.async_read = async_read
		self.re = re
		self.we_granularity = we_granularity
		self.mode = mode
		if isinstance(clock_domain, str):
			self.clock = ClockSignal(clock_domain)
		else:
			self.clock = clock_domain

	def iter_expressions(self):
		for attr, target_context in [
		  ("adr", SPECIAL_INPUT),
		  ("we", SPECIAL_INPUT),
		  ("dat_w", SPECIAL_INPUT),
		  ("re", SPECIAL_INPUT),
		  ("dat_r", SPECIAL_OUTPUT),
		  ("clock", SPECIAL_INPUT)]:
			yield self, attr, target_context

	@staticmethod
	def emit_verilog(port, ns):
		return "" # done by parent Memory object

class Memory(Special):
	def __init__(self, width, depth, init=None, name=None):
		Special.__init__(self)
		self.width = width
		self.depth = depth
		self.ports = []
		self.init = init
		self.name_override = get_obj_var_name(name, "mem")
	
	def get_port(self, write_capable=False, async_read=False,
	  has_re=False, we_granularity=0, mode=WRITE_FIRST,
	  clock_domain="sys"):
		if we_granularity >= self.width:
			we_granularity = 0
		adr = Signal(max=self.depth)
		dat_r = Signal(self.width)
		if write_capable:
			if we_granularity:
				we = Signal(self.width//we_granularity)
			else:
				we = Signal()
			dat_w = Signal(self.width)
		else:
			we = None
			dat_w = None
		if has_re:
			re = Signal()
		else:
			re = None
		mp = _MemoryPort(adr, dat_r, we, dat_w,
		  async_read, re, we_granularity, mode,
		  clock_domain)
		self.ports.append(mp)
		return mp

	@staticmethod
	def emit_verilog(memory, ns):
		r = ""
		def gn(e):
			if isinstance(e, Memory):
				return ns.get_name(e)
			else:
				return verilog_printexpr(ns, e)[0]
		adrbits = bits_for(memory.depth-1)
		
		r += "reg [" + str(memory.width-1) + ":0] " \
			+ gn(memory) \
			+ "[0:" + str(memory.depth-1) + "];\n"

		adr_regs = {}
		data_regs = {}
		for port in memory.ports:
			if not port.async_read:
				if port.mode == WRITE_FIRST and port.we is not None:
					adr_reg = Signal(name_override="memadr")
					r += "reg [" + str(adrbits-1) + ":0] " \
						+ gn(adr_reg) + ";\n"
					adr_regs[id(port)] = adr_reg
				else:
					data_reg = Signal(name_override="memdat")
					r += "reg [" + str(memory.width-1) + ":0] " \
						+ gn(data_reg) + ";\n"
					data_regs[id(port)] = data_reg

		for port in memory.ports:
			r += "always @(posedge " + gn(port.clock) + ") begin\n"
			if port.we is not None:
				if port.we_granularity:
					n = memory.width//port.we_granularity
					for i in range(n):
						m = i*port.we_granularity
						M = (i+1)*port.we_granularity-1
						sl = "[" + str(M) + ":" + str(m) + "]"
						r += "\tif (" + gn(port.we) + "[" + str(i) + "])\n"
						r += "\t\t" + gn(memory) + "[" + gn(port.adr) + "]" + sl + " <= " + gn(port.dat_w) + sl + ";\n"
				else:
					r += "\tif (" + gn(port.we) + ")\n"
					r += "\t\t" + gn(memory) + "[" + gn(port.adr) + "] <= " + gn(port.dat_w) + ";\n"
			if not port.async_read:
				if port.mode == WRITE_FIRST and port.we is not None:
					rd = "\t" + gn(adr_regs[id(port)]) + " <= " + gn(port.adr) + ";\n"
				else:
					bassign = gn(data_regs[id(port)]) + " <= " + gn(memory) + "[" + gn(port.adr) + "];\n"
					if port.mode == READ_FIRST or port.we is None:
						rd = "\t" + bassign
					elif port.mode == NO_CHANGE:
						rd = "\tif (!" + gn(port.we) + ")\n" \
						  + "\t\t" + bassign
				if port.re is None:
					r += rd
				else:
					r += "\tif (" + gn(port.re) + ")\n"
					r += "\t" + rd.replace("\n\t", "\n\t\t")
			r += "end\n\n"
		
		for port in memory.ports:
			if port.async_read:
				r += "assign " + gn(port.dat_r) + " = " + gn(memory) + "[" + gn(port.adr) + "];\n"
			else:
				if port.mode == WRITE_FIRST and port.we is not None:
					r += "assign " + gn(port.dat_r) + " = " + gn(memory) + "[" + gn(adr_regs[id(port)]) + "];\n"
				else:
					r += "assign " + gn(port.dat_r) + " = " + gn(data_regs[id(port)]) + ";\n"
		r += "\n"
		
		if memory.init is not None:
			r += "initial begin\n"
			for i, c in enumerate(memory.init):
				r += "\t" + gn(memory) + "[" + str(i) + "] <= " + str(memory.width) + "'d" + str(c) + ";\n"
			r += "end\n\n"
		
		return r

class SynthesisDirective(Special):
	def __init__(self, template, **signals):
		Special.__init__(self)
		self.template = template
		self.signals = signals

	@staticmethod
	def emit_verilog(directive, ns):
		name_dict = dict((k, ns.get_name(sig)) for k, sig in directive.signals.items())
		formatted = directive.template.format(**name_dict)
		return "// synthesis " + formatted + "\n"

########NEW FILE########
__FILENAME__ = std
from migen.fhdl.structure import *
from migen.fhdl.module import Module
from migen.fhdl.specials import TSTriple, Instance, Memory
from migen.fhdl.bitcontainer import log2_int, bits_for, flen, fiter, fslice, freversed
from migen.fhdl.decorators import DecorateModule, InsertCE, InsertReset, RenameClockDomains

########NEW FILE########
__FILENAME__ = structure
import inspect
import re
import builtins
from collections import defaultdict

from migen.fhdl import tracer
from migen.util.misc import flat_iteration

class HUID:
	__next_uid = 0
	def __init__(self):
		self.huid = HUID.__next_uid
		HUID.__next_uid += 1
	
	def __hash__(self):
		return self.huid

class Value(HUID):
	"""Base class for operands

	Instances of `Value` or its subclasses can be operands to
	arithmetic, comparison, bitwise, and logic operators.
	They can be assigned (:meth:`eq`) or indexed/sliced (using the usual
	Python indexing and slicing notation).

	Values created from integers have the minimum bit width to necessary to
	represent the integer.
	"""
	def __invert__(self):
		return _Operator("~", [self])
	def __neg__(self):
		return _Operator("-", [self])

	def __add__(self, other):
		return _Operator("+", [self, other])
	def __radd__(self, other):
		return _Operator("+", [other, self])
	def __sub__(self, other):
		return _Operator("-", [self, other])
	def __rsub__(self, other):
		return _Operator("-", [other, self])
	def __mul__(self, other):
		return _Operator("*", [self, other])
	def __rmul__(self, other):
		return _Operator("*", [other, self])
	def __lshift__(self, other):
		return _Operator("<<<", [self, other])
	def __rlshift__(self, other):
		return _Operator("<<<", [other, self])
	def __rshift__(self, other):
		return _Operator(">>>", [self, other])
	def __rrshift__(self, other):
		return _Operator(">>>", [other, self])
	def __and__(self, other):
		return _Operator("&", [self, other])
	def __rand__(self, other):
		return _Operator("&", [other, self])
	def __xor__(self, other):
		return _Operator("^", [self, other])
	def __rxor__(self, other):
		return _Operator("^", [other, self])
	def __or__(self, other):
		return _Operator("|", [self, other])
	def __ror__(self, other):
		return _Operator("|", [other, self])
	
	def __lt__(self, other):
		return _Operator("<", [self, other])
	def __le__(self, other):
		return _Operator("<=", [self, other])
	def __eq__(self, other):
		return _Operator("==", [self, other])
	def __ne__(self, other):
		return _Operator("!=", [self, other])
	def __gt__(self, other):
		return _Operator(">", [self, other])
	def __ge__(self, other):
		return _Operator(">=", [self, other])
	
	
	def __getitem__(self, key):
		from migen.fhdl.bitcontainer import flen

		if isinstance(key, int):
			if key < 0:
				key += flen(self)
			return _Slice(self, key, key+1)
		elif isinstance(key, slice):
			start, stop, step = key.indices(flen(self))
			if step != 1:
				return Cat(self[i] for i in range(start, stop, step))
			return _Slice(self, start, stop)
		else:
			raise KeyError
	
	def eq(self, r):
		"""Assignment

		Parameters
		----------
		r : Value, in
			Value to be assigned.

		Returns
		-------
		_Assign
			Assignment statement that can be used in combinatorial or
			synchronous context.
		"""
		return _Assign(self, r)
	
	def __hash__(self):
		return HUID.__hash__(self)

class _Operator(Value):
	def __init__(self, op, operands):
		Value.__init__(self)
		self.op = op
		self.operands = operands

def Mux(sel, val1, val0):
	"""Multiplex between two values

	Parameters
	----------
	sel : Value(1), in
		Selector.
	val1 : Value(N), in
	val0 : Value(N), in
		Input values.

	Returns
	-------
	Value(N), out
		Output `Value`. If `sel` is asserted, the Mux returns
		`val1`, else `val0`.
	"""
	return _Operator("m", [sel, val1, val0])

class _Slice(Value):
	def __init__(self, value, start, stop):
		Value.__init__(self)
		self.value = value
		self.start = start
		self.stop = stop

class Cat(Value):
	"""Concatenate values

	Form a compound `Value` from several smaller ones by concatenation.
	The first argument occupies the lower bits of the result.
	The return value can be used on either side of an assignment, that
	is, the concatenated value can be used as an argument on the RHS or
	as a target on the LHS. If it is used on the LHS, it must solely
	consist of `Signal` s, slices of `Signal` s, and other concatenations
	meeting these properties. The bit length of the return value is the sum of
	the bit lengths of the arguments::

		flen(Cat(args)) == sum(flen(arg) for arg in args)

	Parameters
	----------
	*args : Values or iterables of Values, inout
		`Value` s to be concatenated.

	Returns
	-------
	Cat, inout
		Resulting `Value` obtained by concatentation.
	"""
	def __init__(self, *args):
		Value.__init__(self)
		self.l = list(flat_iteration(args))

class Replicate(Value):
	"""Replicate a value

	An input value is replicated (repeated) several times
	to be used on the RHS of assignments::

		flen(Replicate(s, n)) == flen(s)*n

	Parameters
	----------
	v : Value, in
		Input value to be replicated.
	n : int
		Number of replications.

	Returns
	-------
	Replicate, out
		Replicated value.
	"""
	def __init__(self, v, n):
		Value.__init__(self)
		self.v = v
		self.n = n

class Signal(Value):
	"""A `Value` that can change

	The `Signal` object represents a value that is expected to change
	in the circuit. It does exactly what Verilog's `wire` and
	`reg` and VHDL's `signal` do.

	A `Signal` can be indexed to access a subset of its bits. Negative
	indices (`signal[-1]`) and the extended Python slicing notation
	(`signal[start:stop:step]`) are supported.
	The indeces 0 and -1 are the least and most significant bits
	respectively.

	Parameters
	----------
	bits_sign : int or tuple
		Either an integer `bits` or a tuple `(bits, signed)`
		specifying the number of bits in this `Signal` and whether it is
		signed (can represent negative values). `signed` defaults to
		`False`.
	name : str or None
		Name hint for this signal. If `None` (default) the name is
		inferred from the variable name this `Signal` is assigned to.
		Name collisions are automatically resolved by prepending
		names of objects that contain this `Signal` and by
		appending integer sequences.
	variable : bool
		Deprecated.
	reset : int
		Reset (synchronous) or default (combinatorial) value.
		When this `Signal` is assigned to in synchronous context and the
		corresponding clock domain is reset, the `Signal` assumes the
		given value. When this `Signal` is unassigned in combinatorial
		context (due to conditional assignments not being taken),
		the `Signal` assumes its `reset` value. Defaults to 0.
	name_override : str or None
		Do not use the inferred name but the given one.
	min : int or None
	max : int or None
		If `bits_sign` is `None`, the signal bit width and signedness are
		determined by the integer range given by `min` (inclusive,
		defaults to 0) and `max` (exclusive, defaults to 2).
	related : Signal or None
	"""
	def __init__(self, bits_sign=None, name=None, variable=False, reset=0, name_override=None, min=None, max=None, related=None):
		from migen.fhdl.bitcontainer import bits_for

		Value.__init__(self)
		
		# determine number of bits and signedness
		if bits_sign is None:
			if min is None:
				min = 0
			if max is None:
				max = 2
			max -= 1 # make both bounds inclusive
			assert(min < max)
			self.signed = min < 0 or max < 0
			self.nbits = builtins.max(bits_for(min, self.signed), bits_for(max, self.signed))
		else:
			assert(min is None and max is None)
			if isinstance(bits_sign, tuple):
				self.nbits, self.signed = bits_sign
			else:
				self.nbits, self.signed = bits_sign, False
		if not isinstance(self.nbits, int) or self.nbits <= 0:
			raise ValueError("Signal width must be a strictly positive integer")
		
		self.variable = variable # deprecated
		self.reset = reset
		self.name_override = name_override
		self.backtrace = tracer.trace_back(name)
		self.related = related

	def __repr__(self):
		return "<Signal " + (self.backtrace[-1][0] or "anonymous") + " at " + hex(id(self)) + ">"

class ClockSignal(Value):
	"""Clock signal for a given clock domain

	`ClockSignal` s for a given clock domain can be retrieved multiple
	times. They all ultimately refer to the same signal.

	Parameters
	----------
	cd : str
		Clock domain to obtain a clock signal for. Defaults to `"sys"`.
	"""
	def __init__(self, cd="sys"):
		Value.__init__(self)
		self.cd = cd
	
class ResetSignal(Value):
	"""Reset signal for a given clock domain

	`ResetSignal` s for a given clock domain can be retrieved multiple
	times. They all ultimately refer to the same signal.

	Parameters
	----------
	cd : str
		Clock domain to obtain a reset signal for. Defaults to `"sys"`.
	"""
	def __init__(self, cd="sys"):
		Value.__init__(self)
		self.cd = cd

# statements

class _Assign:
	def __init__(self, l, r):
		self.l = l
		self.r = r

class If:
	"""Conditional execution of statements

	Parameters
	----------
	cond : Value(1), in
		Condition
	*t : Statements
		Statements to execute if `cond` is asserted.

	Examples
	--------
	>>> a = Signal()
	>>> b = Signal()
	>>> c = Signal()
	>>> d = Signal()
	>>> If(a,
	... 	b.eq(1)
	... ).Elif(c,
	... 	b.eq(0)
	... ).Else(
	... 	b.eq(d)
	... )
	"""
	def __init__(self, cond, *t):
		self.cond = cond
		self.t = list(t)
		self.f = []
	
	def Else(self, *f):
		"""Add an `else` conditional block

		Parameters
		----------
		*f : Statements
			Statements to execute if all previous conditions fail.
		"""
		_insert_else(self, list(f))
		return self
	
	def Elif(self, cond, *t):
		"""Add an `else if` conditional block

		Parameters
		----------
		cond : Value(1), in
			Condition
		*t : Statements
			Statements to execute if previous conditions fail and `cond`
			is asserted.
		"""
		_insert_else(self, [If(cond, *t)])
		return self

def _insert_else(obj, clause):
	o = obj
	while o.f:
		assert(len(o.f) == 1)
		assert(isinstance(o.f[0], If))
		o = o.f[0]
	o.f = clause

class Case:
	"""Case/Switch statement

	Parameters
	----------
	test : Value, in
		Selector value used to decide which block to execute
	cases : dict
		Dictionary of cases. The keys are numeric constants to compare
		with `test`. The values are statements to be executed the
		corresponding key matches `test`. The dictionary may contain a
		string key `"default"` to mark a fall-through case that is
		executed if no other key matches.

	Examples
	--------
	>>> a = Signal()
	>>> b = Signal()
	>>> Case(a, {
	... 	0:         b.eq(1),
	... 	1:         b.eq(0),
	... 	"default": b.eq(0),
	... })
	"""
	def __init__(self, test, cases):
		self.test = test
		self.cases = cases
	
	def makedefault(self, key=None):
		"""Mark a key as the default case

		Deletes/Substitutes any previously existing default case.

		Parameters
		----------
		key : int or None
			Key to use as default case if no other key matches.
			By default, the largest key is the default key.
		"""
		if key is None:
			for choice in self.cases.keys():
				if key is None or choice > key:
					key = choice
		self.cases["default"] = self.cases[key]
		del self.cases[key]
		return self

# arrays

class _ArrayProxy(Value):
	def __init__(self, choices, key):
		self.choices = choices
		self.key = key
	
	def __getattr__(self, attr):
		return _ArrayProxy([getattr(choice, attr) for choice in self.choices],
			self.key)
	
	def __getitem__(self, key):
		return _ArrayProxy([choice.__getitem__(key) for choice in self.choices],
			self.key)

class Array(list):
	"""Addressable multiplexer

	An array is created from an iterable of values and indexed using the
	usual Python simple indexing notation (no negative indices or
	slices). It can be indexed by numeric constants, `Value` s, or
	`Signal` s.

	The result of indexing the array is a proxy for the entry at the
	given index that can be used on either RHS or LHS of assignments.

	An array can be indexed multiple times.

	Multidimensional arrays are supported by packing inner arrays into
	outer arrays.

	Parameters
	----------
	values : iterable of ints, Values, Signals
		Entries of the array. Each entry can be a numeric constant, a
		`Signal` or a `Record`.

	Examples
	--------
	>>> a = Array(range(10))
	>>> b = Signal(max=10)
	>>> c = Signal(max=10)
	>>> b.eq(a[9 - c])
	"""
	def __getitem__(self, key):
		if isinstance(key, Value):
			return _ArrayProxy(self, key)
		else:
			return list.__getitem__(self, key)

class ClockDomain:
	"""Synchronous domain

	Parameters
	----------
	name : str or None
		Domain name. If None (the default) the name is inferred from the
		variable name this `ClockDomain` is assigned to (stripping any
		`"cd_"` prefix).
	reset_less : bool
		The domain does not use a reset signal. Registers within this
		domain are still all initialized to their reset state once, e.g.
		through Verilog `"initial"` statements.

	Attributes
	----------
	clk : Signal, inout
		The clock for this domain. Can be driven or used to drive other
		signals (preferably in combinatorial context).
	rst : Signal or None, inout
		Reset signal for this domain. Can be driven or used to drive.
	"""
	def __init__(self, name=None, reset_less=False):
		self.name = tracer.get_obj_var_name(name)
		if self.name is None:
			raise ValueError("Cannot extract clock domain name from code, need to specify.")
		if len(self.name) > 3 and self.name[:3] == "cd_":
			self.name = self.name[3:]
		self.clk = Signal(name_override=self.name + "_clk")
		if reset_less:
			self.rst = None
		else:
			self.rst = Signal(name_override=self.name + "_rst")

	def rename(self, new_name):
		"""Rename the clock domain

		Parameters
		----------
		new_name : str
			New name
		"""
		self.name = new_name
		self.clk.name_override = new_name + "_clk"
		if self.rst is not None:
			self.rst.name_override = new_name + "_rst"

class _ClockDomainList(list):
	def __getitem__(self, key):
		if isinstance(key, str):
			for cd in self:
				if cd.name == key:
					return cd
			raise KeyError(key)
		else:
			return list.__getitem__(self, key)

(SPECIAL_INPUT, SPECIAL_OUTPUT, SPECIAL_INOUT) = range(3)

class StopSimulation(Exception):
	pass

class _Fragment:
	def __init__(self, comb=None, sync=None, specials=None, clock_domains=None, sim=None):
		if comb is None: comb = []
		if sync is None: sync = dict()
		if specials is None: specials = set()
		if clock_domains is None: clock_domains = _ClockDomainList()
		if sim is None: sim = []
		
		self.comb = comb
		self.sync = sync
		self.specials = specials
		self.clock_domains = _ClockDomainList(clock_domains)
		self.sim = sim
	
	def __add__(self, other):
		newsync = defaultdict(list)
		for k, v in self.sync.items():
			newsync[k] = v[:]
		for k, v in other.sync.items():
			newsync[k].extend(v)
		return _Fragment(self.comb + other.comb, newsync,
			self.specials | other.specials,
			self.clock_domains + other.clock_domains,
			self.sim + other.sim)

	def __iadd__(self, other):
		newsync = defaultdict(list)
		for k, v in self.sync.items():
			newsync[k] = v[:]
		for k, v in other.sync.items():
			newsync[k].extend(v)
		self.comb += other.comb
		self.sync = newsync
		self.specials |= other.specials
		self.clock_domains += other.clock_domains
		self.sim += other.sim
		return self

########NEW FILE########
__FILENAME__ = tools
from migen.fhdl.structure import *
from migen.fhdl.structure import _Slice, _Assign
from migen.fhdl.visit import NodeVisitor, NodeTransformer
from migen.fhdl.bitcontainer import value_bits_sign
from migen.util.misc import flat_iteration

class _SignalLister(NodeVisitor):
	def __init__(self):
		self.output_list = set()
	
	def visit_Signal(self, node):
		self.output_list.add(node)

class _TargetLister(NodeVisitor):
	def __init__(self):
		self.output_list = set()
		self.target_context = False
	
	def visit_Signal(self, node):
		if self.target_context:
			self.output_list.add(node)
	
	def visit_Assign(self, node):
		self.target_context = True
		self.visit(node.l)
		self.target_context = False

	def visit_ArrayProxy(self, node):
		for choice in node.choices:
			self.visit(choice)
	
def list_signals(node):
	lister = _SignalLister()
	lister.visit(node)
	return lister.output_list

def list_targets(node):
	lister = _TargetLister()
	lister.visit(node)
	return lister.output_list

def _resort_statements(ol):
	return [statement for i, statement in
			sorted(ol, key=lambda x: x[0])]

def group_by_targets(sl):
	groups = []
	seen = set()
	for order, stmt in enumerate(flat_iteration(sl)):
		targets = set(list_targets(stmt))
		group = [(order, stmt)]
		disjoint = targets.isdisjoint(seen)
		seen |= targets
		if not disjoint:
			groups, old_groups = [], groups
			for old_targets, old_group in old_groups:
				if targets.isdisjoint(old_targets):
					groups.append((old_targets, old_group))
				else:
					targets |= old_targets
					group += old_group
		groups.append((targets, group))
	return [(targets, _resort_statements(stmts))
		for targets, stmts in groups]

def list_special_ios(f, ins, outs, inouts):
	r = set()
	for special in f.specials:
		r |= special.list_ios(ins, outs, inouts)
	return r

class _ClockDomainLister(NodeVisitor):
	def __init__(self):
		self.clock_domains = set()

	def visit_ClockSignal(self, node):
		self.clock_domains.add(node.cd)

	def visit_ResetSignal(self, node):
		self.clock_domains.add(node.cd)

	def visit_clock_domains(self, node):
		for clockname, statements in node.items():
			self.clock_domains.add(clockname)
			self.visit(statements)

def list_clock_domains_expr(f):
	cdl = _ClockDomainLister()
	cdl.visit(f)
	return cdl.clock_domains

def list_clock_domains(f):
	r = list_clock_domains_expr(f)
	for special in f.specials:
		r |= special.list_clock_domains()
	for cd in f.clock_domains:
		r.add(cd.name)
	return r

def is_variable(node):
	if isinstance(node, Signal):
		return node.variable
	elif isinstance(node, _Slice):
		return is_variable(node.value)
	elif isinstance(node, Cat):
		arevars = list(map(is_variable, node.l))
		r = arevars[0]
		for x in arevars:
			if x != r:
				raise TypeError
		return r
	else:
		raise TypeError

def generate_reset(rst, sl):
	targets = list_targets(sl)
	return [t.eq(t.reset) for t in sorted(targets, key=lambda x: x.huid)]

def insert_reset(rst, sl):
	return [If(rst, *generate_reset(rst, sl)).Else(*sl)]

def insert_resets(f):
	newsync = dict()
	for k, v in f.sync.items():
		if f.clock_domains[k].rst is not None:
			newsync[k] = insert_reset(ResetSignal(k), v)
		else:
			newsync[k] = v
	f.sync = newsync

class _Lowerer(NodeTransformer):
	def __init__(self):
		self.target_context = False
		self.extra_stmts = []
		self.comb = []

	def visit_Assign(self, node):
		old_target_context, old_extra_stmts = self.target_context, self.extra_stmts
		self.extra_stmts = []

		self.target_context = True
		lhs = self.visit(node.l)
		self.target_context = False
		rhs = self.visit(node.r)
		r = _Assign(lhs, rhs)
		if self.extra_stmts:
			r = [r] + self.extra_stmts
		
		self.target_context, self.extra_stmts = old_target_context, old_extra_stmts
		return r

# Basics are FHDL structure elements that back-ends are not required to support
# but can be expressed in terms of other elements (lowered) before conversion.
class _BasicLowerer(_Lowerer):
	def __init__(self, clock_domains):
		self.clock_domains = clock_domains
		_Lowerer.__init__(self)

	def visit_ArrayProxy(self, node):
		# TODO: rewrite without variables
		array_muxed = Signal(value_bits_sign(node), variable=True)
		if self.target_context:
			k = self.visit(node.key)
			cases = {}
			for n, choice in enumerate(node.choices):
				cases[n] = [self.visit_Assign(_Assign(choice, array_muxed))]
			self.extra_stmts.append(Case(k, cases).makedefault())
		else:
			cases = dict((n, _Assign(array_muxed, self.visit(choice)))
				for n, choice in enumerate(node.choices))
			self.comb.append(Case(self.visit(node.key), cases).makedefault())
		return array_muxed

	def visit_ClockSignal(self, node):
		return self.clock_domains[node.cd].clk

	def visit_ResetSignal(self, node):
		return self.clock_domains[node.cd].rst

class _ComplexSliceLowerer(_Lowerer):
	def visit_Slice(self, node):
		if not isinstance(node.value, Signal):
			slice_proxy = Signal(value_bits_sign(node.value))
			if self.target_context:
				a = _Assign(node.value, slice_proxy)
			else:
				a = _Assign(slice_proxy, node.value)
			self.comb.append(self.visit_Assign(a))
			node = _Slice(slice_proxy, node.start, node.stop)
		return NodeTransformer.visit_Slice(self, node)

def _apply_lowerer(l, f):
	f = l.visit(f)
	f.comb += l.comb

	for special in f.specials:
		for obj, attr, direction in special.iter_expressions():
			if direction != SPECIAL_INOUT:
				# inouts are only supported by Migen when connected directly to top-level
				# in this case, they are Signal and never need lowering
				l.comb = []
				l.target_context = direction != SPECIAL_INPUT
				l.extra_stmts = []
				expr = getattr(obj, attr)
				expr = l.visit(expr)
				setattr(obj, attr, expr)
				f.comb += l.comb + l.extra_stmts

	return f

def lower_basics(f):
	return _apply_lowerer(_BasicLowerer(f.clock_domains), f)

def lower_complex_slices(f):
	return _apply_lowerer(_ComplexSliceLowerer(), f)

class _ClockDomainRenamer(NodeVisitor):
	def __init__(self, old, new):
		self.old = old
		self.new = new

	def visit_ClockSignal(self, node):
		if node.cd == self.old:
			node.cd = self.new

	def visit_ResetSignal(self, node):
		if node.cd == self.old:
			node.cd = self.new

def rename_clock_domain_expr(f, old, new):
	cdr = _ClockDomainRenamer(old, new)
	cdr.visit(f)

def rename_clock_domain(f, old, new):
	rename_clock_domain_expr(f, old, new)
	if new in f.sync:
		f.sync[new].extend(f.sync[old])
	else:
		f.sync[new] = f.sync[old]
	del f.sync[old]
	for special in f.specials:
		special.rename_clock_domain(old, new)
	try:
		cd = f.clock_domains[old]
	except KeyError:
		pass
	else:
		cd.rename(new)

########NEW FILE########
__FILENAME__ = tracer
import inspect
from opcode import opname
from collections import defaultdict

def get_var_name(frame):
	code = frame.f_code
	call_index = frame.f_lasti
	call_opc = opname[code.co_code[call_index]]
	if call_opc != "CALL_FUNCTION" and call_opc != "CALL_FUNCTION_VAR":
		return None
	index = call_index+3
	while True:
		opc = opname[code.co_code[index]]
		if opc == "STORE_NAME" or opc == "STORE_ATTR":
			name_index = int(code.co_code[index+1])
			return code.co_names[name_index]
		elif opc == "STORE_FAST":
			name_index = int(code.co_code[index+1])
			return code.co_varnames[name_index]
		elif opc == "STORE_DEREF":
			name_index = int(code.co_code[index+1])
			return code.co_cellvars[name_index]
		elif opc == "LOAD_GLOBAL" or opc == "LOAD_ATTR" or opc == "LOAD_FAST" or opc == "LOAD_DEREF":
			index += 3
		elif opc == "DUP_TOP":
			index += 1
		elif opc == "BUILD_LIST":
			index += 3
		else:
			return None

def remove_underscore(s):
	if len(s) > 2 and s[0] == "_" and s[1] != "_":
		s = s[1:]
	return s

def get_obj_var_name(override=None, default=None):
	if override:
		return override

	frame = inspect.currentframe().f_back
	# We can be called via derived classes. Go back the stack frames
	# until we reach the first class that does not inherit from us.
	ourclass = frame.f_locals["self"].__class__
	while "self" in frame.f_locals and isinstance(frame.f_locals["self"], ourclass):
		frame = frame.f_back

	vn = get_var_name(frame)
	if vn is None:
		vn = default
	else:
		vn = remove_underscore(vn)
	return vn

name_to_idx = defaultdict(int)
classname_to_objs = dict()

def index_id(l, obj):
	for n, e in enumerate(l):
		if id(e) == id(obj):
			return n
	raise ValueError

def trace_back(varname=None):
	l = []
	frame = inspect.currentframe().f_back.f_back
	while frame is not None:
		if varname is None:
			varname = get_var_name(frame)
		if varname is not None:
			varname = remove_underscore(varname)
			l.insert(0, (varname, name_to_idx[varname]))
			name_to_idx[varname] += 1
		
		try:
			obj = frame.f_locals["self"]
		except KeyError:
			obj = None
		if hasattr(obj, "__del__"):
			obj = None
		
		if obj is None:
			if varname is not None:
				coname = frame.f_code.co_name
				if coname == "<module>":
					modules = frame.f_globals["__name__"]
					modules = modules.split(".")
					coname = modules[len(modules)-1]
				coname = remove_underscore(coname)
				l.insert(0, (coname, name_to_idx[coname]))
				name_to_idx[coname] += 1
		else:
			classname = obj.__class__.__name__.lower()
			try:
				objs = classname_to_objs[classname]
			except KeyError:
				classname_to_objs[classname] = [obj]
				idx = 0
			else:
				try:
					idx = index_id(objs, obj)
				except ValueError:
					idx = len(objs)
					objs.append(obj)
			classname = remove_underscore(classname)
			l.insert(0, (classname, idx))
		
		varname = None
		frame = frame.f_back
	return l

########NEW FILE########
__FILENAME__ = verilog
from functools import partial
from operator import itemgetter

from migen.fhdl.structure import *
from migen.fhdl.structure import _Operator, _Slice, _Assign, _Fragment
from migen.fhdl.tools import *
from migen.fhdl.bitcontainer import bits_for, flen
from migen.fhdl.namer import Namespace, build_namespace

def _printsig(ns, s):
	if s.signed:
		n = "signed "
	else:
		n = ""
	if flen(s) > 1:
		n += "[" + str(flen(s)-1) + ":0] "
	n += ns.get_name(s)
	return n

def _printintbool(node):
	if isinstance(node, bool):
		if node:
			return "1'd1", False
		else:
			return "1'd0", False
	elif isinstance(node, int):
		if node >= 0:
			return str(bits_for(node)) + "'d" + str(node), False
		else:
			nbits = bits_for(node)
			return str(nbits) + "'sd" + str(2**nbits + node), True
	else:
		raise TypeError

def _printexpr(ns, node):
	if isinstance(node, (int, bool)):
		return _printintbool(node)
	elif isinstance(node, Signal):
		return ns.get_name(node), node.signed
	elif isinstance(node, _Operator):
		arity = len(node.operands)
		r1, s1 = _printexpr(ns, node.operands[0])
		if arity == 1:
			if node.op == "-":
				if s1:
					r = node.op + r1
				else:
					r = "-$signed({1'd0, " + r1 + "})"
				s = True
			else:
				r = node.op + r1
				s = s1
		elif arity == 2:
			r2, s2 = _printexpr(ns, node.operands[1])
			if node.op not in ["<<<", ">>>"]:
				if s2 and not s1:
					r1 = "$signed({1'd0, " + r1 + "})"
				if s1 and not s2:
					r2 = "$signed({1'd0, " + r2 + "})"
			r = r1 + " " + node.op + " " + r2
			s = s1 or s2
		elif arity == 3:
			assert node.op == "m"
			r2, s2 = _printexpr(ns, node.operands[1])
			r3, s3 = _printexpr(ns, node.operands[2])
			if s2 and not s3:
				r3 = "$signed({1'd0, " + r3 + "})"
			if s3 and not s2:
				r2 = "$signed({1'd0, " + r2 + "})"
			r = r1 + " ? " + r2 + " : " + r3
			s = s2 or s3
		else:
			raise TypeError
		return "(" + r + ")", s
	elif isinstance(node, _Slice):
		# Verilog does not like us slicing non-array signals...
		if isinstance(node.value, Signal) \
		  and flen(node.value) == 1 \
		  and node.start == 0 and node.stop == 1:
			  return _printexpr(ns, node.value)

		if node.start + 1 == node.stop:
			sr = "[" + str(node.start) + "]"
		else:
			sr = "[" + str(node.stop-1) + ":" + str(node.start) + "]"
		r, s = _printexpr(ns, node.value)
		return r + sr, s
	elif isinstance(node, Cat):
		l = [_printexpr(ns, v)[0] for v in reversed(node.l)]
		return "{" + ", ".join(l) + "}", False
	elif isinstance(node, Replicate):
		return "{" + str(node.n) + "{" + _printexpr(ns, node.v)[0] + "}}", False
	else:
		raise TypeError("Expression of unrecognized type: "+str(type(node)))

(_AT_BLOCKING, _AT_NONBLOCKING, _AT_SIGNAL) = range(3)

def _printnode(ns, at, level, node):
	if node is None:
		return ""
	elif isinstance(node, _Assign):
		if at == _AT_BLOCKING:
			assignment = " = "
		elif at == _AT_NONBLOCKING:
			assignment = " <= "
		elif is_variable(node.l):
			assignment = " = "
		else:
			assignment = " <= "
		return "\t"*level + _printexpr(ns, node.l)[0] + assignment + _printexpr(ns, node.r)[0] + ";\n"
	elif isinstance(node, (list, tuple)):
		return "".join(list(map(partial(_printnode, ns, at, level), node)))
	elif isinstance(node, If):
		r = "\t"*level + "if (" + _printexpr(ns, node.cond)[0] + ") begin\n"
		r += _printnode(ns, at, level + 1, node.t)
		if node.f:
			r += "\t"*level + "end else begin\n"
			r += _printnode(ns, at, level + 1, node.f)
		r += "\t"*level + "end\n"
		return r
	elif isinstance(node, Case):
		if node.cases:
			r = "\t"*level + "case (" + _printexpr(ns, node.test)[0] + ")\n"
			css = sorted([(k, v) for (k, v) in node.cases.items() if k != "default"], key=itemgetter(0))
			for choice, statements in css:
				r += "\t"*(level + 1) + _printexpr(ns, choice)[0] + ": begin\n"
				r += _printnode(ns, at, level + 2, statements)
				r += "\t"*(level + 1) + "end\n"
			if "default" in node.cases:
				r += "\t"*(level + 1) + "default: begin\n"
				r += _printnode(ns, at, level + 2, node.cases["default"])
				r += "\t"*(level + 1) + "end\n"
			r += "\t"*level + "endcase\n"
			return r
		else:
			return ""
	else:
		raise TypeError("Node of unrecognized type: "+str(type(node)))

def _list_comb_wires(f):
	r = set()
	groups = group_by_targets(f.comb)
	for g in groups:
		if len(g[1]) == 1 and isinstance(g[1][0], _Assign):
			r |= g[0]
	return r

def _printheader(f, ios, name, ns):
	sigs = list_signals(f) | list_special_ios(f, True, True, True)
	special_outs = list_special_ios(f, False, True, True)
	inouts = list_special_ios(f, False, False, True)
	targets = list_targets(f) | special_outs
	wires = _list_comb_wires(f) | special_outs
	r = "module " + name + "(\n"
	firstp = True
	for sig in sorted(ios, key=lambda x: x.huid):
		if not firstp:
			r += ",\n"
		firstp = False
		if sig in inouts:
			r += "\tinout " + _printsig(ns, sig)
		elif sig in targets:
			if sig in wires:
				r += "\toutput " + _printsig(ns, sig)
			else:
				r += "\toutput reg " + _printsig(ns, sig)
		else:
			r += "\tinput " + _printsig(ns, sig)
	r += "\n);\n\n"
	for sig in sorted(sigs - ios, key=lambda x: x.huid):
		if sig in wires:
			r += "wire " + _printsig(ns, sig) + ";\n"
		else:
			r += "reg " + _printsig(ns, sig) + ";\n"
	r += "\n"
	return r

def _printcomb(f, ns, display_run):
	r = ""
	if f.comb:
		# Generate a dummy event to get the simulator
		# to run the combinatorial process once at the beginning.
		syn_off = "// synthesis translate_off\n"
		syn_on = "// synthesis translate_on\n"
		dummy_s = Signal(name_override="dummy_s")
		r += syn_off
		r += "reg " + _printsig(ns, dummy_s) + ";\n"
		r += "initial " + ns.get_name(dummy_s) + " <= 1'd0;\n"
		r += syn_on
		
		groups = group_by_targets(f.comb)
		
		for n, g in enumerate(groups):
			if len(g[1]) == 1 and isinstance(g[1][0], _Assign):
				r += "assign " + _printnode(ns, _AT_BLOCKING, 0, g[1][0])
			else:
				dummy_d = Signal(name_override="dummy_d")
				r += "\n" + syn_off
				r += "reg " + _printsig(ns, dummy_d) + ";\n"
				r += syn_on
				
				r += "always @(*) begin\n"
				if display_run:
					r += "\t$display(\"Running comb block #" + str(n) + "\");\n"
				for t in g[0]:
					r += "\t" + ns.get_name(t) + " <= " + _printexpr(ns, t.reset)[0] + ";\n"
				r += _printnode(ns, _AT_NONBLOCKING, 1, g[1])
				r += syn_off
				r += "\t" + ns.get_name(dummy_d) + " <= " + ns.get_name(dummy_s) + ";\n"
				r += syn_on
				r += "end\n"
	r += "\n"
	return r

def _printsync(f, ns):
	r = ""
	for k, v in sorted(f.sync.items(), key=itemgetter(0)):
		if f.clock_domains[k].rst is None:
			r += "initial begin\n"
			r += _printnode(ns, _AT_SIGNAL, 1, generate_reset(ResetSignal(k), v))
			r += "end\n\n"
		r += "always @(posedge " + ns.get_name(f.clock_domains[k].clk) + ") begin\n"
		r += _printnode(ns, _AT_SIGNAL, 1, v)
		r += "end\n\n"
	return r

def _call_special_classmethod(overrides, obj, method, *args, **kwargs):
	cl = obj.__class__
	if cl in overrides:
		cl = overrides[cl]
	if hasattr(cl, method):
		return getattr(cl, method)(obj, *args, **kwargs)
	else:
		return None

def _lower_specials_step(overrides, specials):
	f = _Fragment()
	lowered_specials = set()
	for special in sorted(specials, key=lambda x: x.huid):
		impl = _call_special_classmethod(overrides, special, "lower")
		if impl is not None:
			f += impl.get_fragment()
			lowered_specials.add(special)
	return f, lowered_specials

def _can_lower(overrides, specials):
	for special in specials:
		cl = special.__class__
		if cl in overrides:
			cl = overrides[cl]
		if hasattr(cl, "lower"):
			return True
	return False

def _lower_specials(overrides, specials):
	f, lowered_specials = _lower_specials_step(overrides, specials)
	while _can_lower(overrides, f.specials):
		f2, lowered_specials2 = _lower_specials_step(overrides, f.specials)
		f += f2
		lowered_specials |= lowered_specials2
		f.specials -= lowered_specials2
	return f, lowered_specials

def _printspecials(overrides, specials, ns):
	r = ""
	for special in sorted(specials, key=lambda x: x.huid):
		pr = _call_special_classmethod(overrides, special, "emit_verilog", ns)
		if pr is None:
			raise NotImplementedError("Special " + str(special) + " failed to implement emit_verilog")
		r += pr
	return r

def _printinit(f, ios, ns):
	r = ""
	signals = (list_signals(f) | list_special_ios(f, True, False, False)) \
		- ios \
		- list_targets(f) \
		- list_special_ios(f, False, True, False)
	if signals:
		r += "initial begin\n"
		for s in sorted(signals, key=lambda x: x.huid):
			r += "\t" + ns.get_name(s) + " <= " + _printexpr(ns, s.reset)[0] + ";\n"
		r += "end\n\n"
	return r

def convert(f, ios=None, name="top",
  return_ns=False,
  special_overrides=dict(),
  create_clock_domains=True,
  display_run=False):
	if not isinstance(f, _Fragment):
		f = f.get_fragment()
	if ios is None:
		ios = set()

	for cd_name in list_clock_domains(f):
		try:
			f.clock_domains[cd_name]
		except KeyError:
			if create_clock_domains:
				cd = ClockDomain(cd_name)
				f.clock_domains.append(cd)
				ios |= {cd.clk, cd.rst}
			else:
				raise KeyError("Unresolved clock domain: '"+cd_name+"'")
	
	f = lower_complex_slices(f)
	insert_resets(f)
	f = lower_basics(f)
	fs, lowered_specials = _lower_specials(special_overrides, f.specials)
	f += lower_basics(fs)

	ns = build_namespace(list_signals(f) \
		| list_special_ios(f, True, True, True) \
		| ios)

	r = "/* Machine-generated using Migen */\n"
	r += _printheader(f, ios, name, ns)
	r += _printcomb(f, ns, display_run)
	r += _printsync(f, ns)
	r += _printspecials(special_overrides, f.specials - lowered_specials, ns)
	r += _printinit(f, ios, ns)
	r += "endmodule\n"

	if return_ns:
		return r, ns
	else:
		return r

########NEW FILE########
__FILENAME__ = visit
from copy import copy

from migen.fhdl.structure import *
from migen.fhdl.structure import _Operator, _Slice, _Assign, _ArrayProxy, _Fragment

class NodeVisitor:
	def visit(self, node):
		if isinstance(node, (int, bool)):
			self.visit_constant(node)
		elif isinstance(node, Signal):
			self.visit_Signal(node)
		elif isinstance(node, ClockSignal):
			self.visit_ClockSignal(node)
		elif isinstance(node, ResetSignal):
			self.visit_ResetSignal(node)
		elif isinstance(node, _Operator):
			self.visit_Operator(node)
		elif isinstance(node, _Slice):
			self.visit_Slice(node)
		elif isinstance(node, Cat):
			self.visit_Cat(node)
		elif isinstance(node, Replicate):
			self.visit_Replicate(node)
		elif isinstance(node, _Assign):
			self.visit_Assign(node)
		elif isinstance(node, If):
			self.visit_If(node)
		elif isinstance(node, Case):
			self.visit_Case(node)
		elif isinstance(node, _Fragment):
			self.visit_Fragment(node)
		elif isinstance(node, (list, tuple)):
			self.visit_statements(node)
		elif isinstance(node, dict):
			self.visit_clock_domains(node)
		elif isinstance(node, _ArrayProxy):
			self.visit_ArrayProxy(node)
		elif node is not None:
			self.visit_unknown(node)
	
	def visit_constant(self, node):
		pass
	
	def visit_Signal(self, node):
		pass

	def visit_ClockSignal(self, node):
		pass

	def visit_ResetSignal(self, node):
		pass
	
	def visit_Operator(self, node):
		for o in node.operands:
			self.visit(o)
	
	def visit_Slice(self, node):
		self.visit(node.value)
	
	def visit_Cat(self, node):
		for e in node.l:
			self.visit(e)
	
	def visit_Replicate(self, node):
		self.visit(node.v)
	
	def visit_Assign(self, node):
		self.visit(node.l)
		self.visit(node.r)
	
	def visit_If(self, node):
		self.visit(node.cond)
		self.visit(node.t)
		self.visit(node.f)
	
	def visit_Case(self, node):
		self.visit(node.test)
		for v, statements in node.cases.items():
			self.visit(statements)
	
	def visit_Fragment(self, node):
		self.visit(node.comb)
		self.visit(node.sync)
	
	def visit_statements(self, node):
		for statement in node:
			self.visit(statement)
	
	def visit_clock_domains(self, node):
		for clockname, statements in node.items():
			self.visit(statements)
	
	def visit_ArrayProxy(self, node):
		for choice in node.choices:
			self.visit(choice)
		self.visit(node.key)
	
	def visit_unknown(self, node):
		pass

# Default methods always copy the node, except for:
# - Signals, ClockSignals and ResetSignals
# - Unknown objects
# - All fragment fields except comb and sync
# In those cases, the original node is returned unchanged.
class NodeTransformer:
	def visit(self, node):
		if isinstance(node, (int, bool)):
			return self.visit_constant(node)
		elif isinstance(node, Signal):
			return self.visit_Signal(node)
		elif isinstance(node, ClockSignal):
			return self.visit_ClockSignal(node)
		elif isinstance(node, ResetSignal):
			return self.visit_ResetSignal(node)
		elif isinstance(node, _Operator):
			return self.visit_Operator(node)
		elif isinstance(node, _Slice):
			return self.visit_Slice(node)
		elif isinstance(node, Cat):
			return self.visit_Cat(node)
		elif isinstance(node, Replicate):
			return self.visit_Replicate(node)
		elif isinstance(node, _Assign):
			return self.visit_Assign(node)
		elif isinstance(node, If):
			return self.visit_If(node)
		elif isinstance(node, Case):
			return self.visit_Case(node)
		elif isinstance(node, _Fragment):
			return self.visit_Fragment(node)
		elif isinstance(node, (list, tuple)):
			return self.visit_statements(node)
		elif isinstance(node, dict):
			return self.visit_clock_domains(node)
		elif isinstance(node, _ArrayProxy):
			return self.visit_ArrayProxy(node)
		elif node is not None:
			return self.visit_unknown(node)
		else:
			return None
	
	def visit_constant(self, node):
		return node
	
	def visit_Signal(self, node):
		return node
	
	def visit_ClockSignal(self, node):
		return node

	def visit_ResetSignal(self, node):
		return node

	def visit_Operator(self, node):
		return _Operator(node.op, [self.visit(o) for o in node.operands])
	
	def visit_Slice(self, node):
		return _Slice(self.visit(node.value), node.start, node.stop)
	
	def visit_Cat(self, node):
		return Cat(*[self.visit(e) for e in node.l])
	
	def visit_Replicate(self, node):
		return Replicate(self.visit(node.v), node.n)
	
	def visit_Assign(self, node):
		return _Assign(self.visit(node.l), self.visit(node.r))
	
	def visit_If(self, node):
		r = If(self.visit(node.cond))
		r.t = self.visit(node.t)
		r.f = self.visit(node.f)
		return r
	
	def visit_Case(self, node):
		cases = dict((v, self.visit(statements)) for v, statements in node.cases.items())
		r = Case(self.visit(node.test), cases)
		return r
	
	def visit_Fragment(self, node):
		r = copy(node)
		r.comb = self.visit(node.comb)
		r.sync = self.visit(node.sync)
		return r
	
	# NOTE: this will always return a list, even if node is a tuple
	def visit_statements(self, node):
		return [self.visit(statement) for statement in node]
	
	def visit_clock_domains(self, node):
		return dict((clockname, self.visit(statements)) for clockname, statements in node.items())
	
	def visit_ArrayProxy(self, node):
		return _ArrayProxy([self.visit(choice) for choice in node.choices],
			self.visit(node.key))
	
	def visit_unknown(self, node):
		return node

class TransformModule:
	def __init__(self, transform, module):
		self.transform = transform
		self.module = module

	def get_fragment(self):
		return self.transform(self.module.get_fragment())

########NEW FILE########
__FILENAME__ = actor
from migen.util.misc import xdir
from migen.fhdl.std import *
from migen.genlib.misc import optree
from migen.genlib.record import *

def _make_m2s(layout):
	r = []
	for f in layout:
		if isinstance(f[1], (int, tuple)):
			r.append((f[0], f[1], DIR_M_TO_S))
		else:
			r.append((f[0], _make_m2s(f[1])))
	return r

class _Endpoint(Record):
	def __init__(self, layout):
		full_layout = [
			("payload", _make_m2s(layout)),
			("stb", 1, DIR_M_TO_S),
			("ack", 1, DIR_S_TO_M)
		]
		Record.__init__(self, full_layout)

class Source(_Endpoint):
	def connect(self, sink):
		return Record.connect(self, sink)

class Sink(_Endpoint):
	def connect(self, source):
		return source.connect(self)

def get_endpoints(obj, filt=_Endpoint):
	if hasattr(obj, "get_endpoints") and callable(obj.get_endpoints):
		return obj.get_endpoints(filt)
	r = dict()
	for k, v in xdir(obj, True):
		if isinstance(v, filt):
			r[k] = v
	return r

def get_single_ep(obj, filt):
	eps = get_endpoints(obj, filt)
	if len(eps) != 1:
		raise ValueError("More than one endpoint")
	return list(eps.items())[0]

class BinaryActor(Module):
	def __init__(self, *args, **kwargs):
		self.busy = Signal()
		sink = get_single_ep(self, Sink)[1]
		source = get_single_ep(self, Source)[1]
		self.build_binary_control(sink.stb, sink.ack, source.stb, source.ack, *args, **kwargs)

	def build_binary_control(self, stb_i, ack_o, stb_o, ack_i):
		raise NotImplementedError("Binary actor classes must overload build_binary_control_fragment")

class CombinatorialActor(BinaryActor):
	def build_binary_control(self, stb_i, ack_o, stb_o, ack_i):
		self.comb += [stb_o.eq(stb_i), ack_o.eq(ack_i), self.busy.eq(0)]

class SequentialActor(BinaryActor):
	def __init__(self, delay):
		self.trigger = Signal()
		BinaryActor.__init__(self, delay)

	def build_binary_control(self, stb_i, ack_o, stb_o, ack_i, delay):
		ready = Signal()
		timer = Signal(max=delay+1)
		self.comb += ready.eq(timer == 0)
		self.sync += If(self.trigger,
				timer.eq(delay)
			).Elif(~ready,
				timer.eq(timer - 1)
			)
		
		mask = Signal()
		self.comb += [
			stb_o.eq(ready & mask),
			self.trigger.eq(stb_i & (ack_i | ~mask) & ready),
			ack_o.eq(self.trigger),
			self.busy.eq(~ready)
		]
		self.sync += [
			If(self.trigger, mask.eq(1)),
			If(stb_o & ack_i, mask.eq(0))
		]

class PipelinedActor(BinaryActor):
	def __init__(self, latency):
		self.pipe_ce = Signal()
		BinaryActor.__init__(self, latency)

	def build_binary_control(self, stb_i, ack_o, stb_o, ack_i, latency):
		busy = 0
		valid = stb_i
		for i in range(latency):
			valid_n = Signal()
			self.sync += If(self.pipe_ce, valid_n.eq(valid))
			valid = valid_n
			busy = busy | valid

		self.comb += [
			self.pipe_ce.eq(ack_i | ~valid),
			ack_o.eq(self.pipe_ce),
			stb_o.eq(valid),
			self.busy.eq(busy)
		]

########NEW FILE########
__FILENAME__ = hooks
from collections import defaultdict

from migen.fhdl.std import *
from migen.flow.actor import *

class EndpointSimHook(Module):
	def __init__(self, endpoint):
		self.endpoint = endpoint
	
	def on_ack(self):
		pass
	
	def on_nack(self):
		pass
	
	def on_inactive(self):
		pass
	
	def do_simulation(self, selfp):
		if selfp.endpoint.stb:
			if selfp.endpoint.ack:
				self.on_ack()
			else:
				self.on_nack()
		else:
			self.on_inactive()

class DFGHook(Module):
	def __init__(self, dfg, create):
		assert(not dfg.is_abstract())
		self.nodepair_to_ep = defaultdict(dict)
		for hookn, (u, v, data) in enumerate(dfg.edges_iter(data=True)):
			ep_to_hook = self.nodepair_to_ep[(u, v)]
			ep = data["source"]
			h = create(u, ep, v)
			ep_to_hook[ep] = h
			setattr(self.submodules, "hook"+str(hookn), h)
	
	def hooks_iter(self):
		for v1 in self.nodepair_to_ep.values():
			for v2 in v1.values():
				yield v2

########NEW FILE########
__FILENAME__ = isd
from migen.fhdl.std import *
from migen.bank.description import *
from migen.flow.hooks import DFGHook

ISD_MAGIC = 0x6ab4

class EndpointReporter(Module, AutoCSR):
	def __init__(self, endpoint, nbits):
		self.reset = Signal()
		self.freeze = Signal()
		
		self._ack_count = CSRStatus(nbits)
		self._nack_count = CSRStatus(nbits)
		self._cur_status = CSRStatus(2)
	
		###

		stb = Signal()
		ack = Signal()
		self.comb += self._cur_status.status.eq(Cat(stb, ack))
		ack_count = Signal(nbits)
		nack_count = Signal(nbits)
		self.sync += [
			# register monitored signals
			stb.eq(endpoint.stb),
			ack.eq(endpoint.ack),
			# count operations
			If(self.reset,
				ack_count.eq(0),
				nack_count.eq(0)
			).Else(
				If(stb,
					If(ack,
						ack_count.eq(ack_count + 1)
					).Else(
						nack_count.eq(nack_count + 1)
					)
				)
			),
			If(~self.freeze,
				self._ack_count.status.eq(ack_count),
				self._nack_count.status.eq(nack_count)
			)
		]

class DFGReporter(DFGHook, AutoCSR):
	def __init__(self, dfg, nbits):
		self._r_magic = CSRStatus(16)
		self._r_neps = CSRStatus(8)
		self._r_nbits = CSRStatus(8)
		self._r_freeze = CSRStorage()
		self._r_reset = CSR()
		
		###

		DFGHook.__init__(self, dfg,
			lambda u, ep, v: EndpointReporter(getattr(u, ep), nbits))
		hooks = list(self.hooks_iter())

		self.comb += [
			self._r_magic.status.eq(ISD_MAGIC),
			self._r_neps.status.eq(len(hooks)),
			self._r_nbits.status.eq(nbits)
		]
		for h in hooks:
			self.comb += [
				h.freeze.eq(self._r_freeze.storage),
				h.reset.eq(self._r_reset.re)
			]

########NEW FILE########
__FILENAME__ = network
from networkx import MultiDiGraph

from migen.fhdl.std import *
from migen.genlib.misc import optree
from migen.flow.actor import *
from migen.flow import plumbing

# Abstract actors mean that the actor class should be instantiated with the parameters 
# from the dictionary. They are needed to enable actor duplication or sharing during
# elaboration, and automatic parametrization of plumbing actors.

class AbstractActor:
	def __init__(self, actor_class, parameters=dict(), name=None):
		self.actor_class = actor_class
		self.parameters = parameters
		self.name = name
		self.busy = Signal()
	
	def create_instance(self):
		return self.actor_class(**self.parameters)
	
	def __repr__(self):
		r = "<abstract " + self.actor_class.__name__
		if self.name is not None:
			r += ": " + self.name
		r += ">"
		return r

# TODO: rewrite this without networkx and without non-determinism
class DataFlowGraph(MultiDiGraph):
	def __init__(self):
		MultiDiGraph.__init__(self)
		self.elaborated = False
		self.abstract_busy_signals = dict()
	
	def add_connection(self, source_node, sink_node,
	  source_ep=None, sink_ep=None,		# default: assume nodes have 1 source/sink and use that one
	  source_subr=None, sink_subr=None):	# default: use whole record
		self.add_edge(source_node, sink_node,
			source=source_ep, sink=sink_ep,
			source_subr=source_subr, sink_subr=sink_subr)

	def add_buffered_connection(self, source_node, sink_node,
	  source_ep=None, sink_ep=None,
	  source_subr=None, sink_subr=None):
		buf = AbstractActor(plumbing.Buffer)
		self.add_connection(source_node, buf, source_ep=source_ep, source_subr=source_subr)
		self.add_connection(buf, sink_node, sink_ep=sink_ep, sink_subr=sink_subr)

	def add_pipeline(self, *nodes):
		for n1, n2 in zip(nodes, nodes[1:]):
			self.add_connection(n1, n2)
	
	def del_connections(self, source_node, sink_node, data_requirements):
		edges_to_delete = []
		edge_data = self.get_edge_data(source_node, sink_node)
		if edge_data is None:
			# the two nodes are already completely disconnected
			return
		for key, data in edge_data.items():
			if all(k not in data_requirements or data_requirements[k] == v
			  for k, v in data.items()):
				edges_to_delete.append(key)
		for key in edges_to_delete:
			self.remove_edge(source_node, sink_node, key)
	
	def replace_actor(self, old, new):
		self.add_node(new)
		for xold, v, data in self.out_edges(old, data=True):
			self.add_edge(new, v, **data)
		for u, xold, data in self.in_edges(old, data=True):
			self.add_edge(u, new, **data)
		self.remove_node(old)
		
	def instantiate(self, actor):
		inst = actor.create_instance()
		self.abstract_busy_signals[id(inst)] = actor.busy
		self.replace_actor(actor, inst)
	
	# Returns a dictionary
	#   source -> [sink1, ..., sinkn]
	# source element is a (node, endpoint) pair.
	# sink elements are (node, endpoint, source subrecord, sink subrecord) triples.
	def _source_to_sinks(self):
		d = dict()
		for u, v, data in self.edges_iter(data=True):
			el_src = (u, data["source"])
			el_dst = (v, data["sink"], data["source_subr"], data["sink_subr"])
			if el_src in d:
				d[el_src].append(el_dst)
			else:
				d[el_src] = [el_dst]
		return d
	
	# Returns a dictionary
	#   sink -> [source1, ... sourcen]
	# sink element is a (node, endpoint) pair.
	# source elements are (node, endpoint, sink subrecord, source subrecord) triples.
	def _sink_to_sources(self):
		d = dict()
		for u, v, data in self.edges_iter(data=True):
			el_src = (u, data["source"], data["sink_subr"], data["source_subr"])
			el_dst = (v, data["sink"])
			if el_dst in d:
				d[el_dst].append(el_src)
			else:
				d[el_dst] = [el_src]
		return d
	
	# List sources that feed more than one sink.
	def _list_divergences(self):
		d = self._source_to_sinks()
		return dict((k, v) for k, v in d.items() if len(v) > 1)

	# A graph is abstract if any of these conditions is met:
	#  (1) A node is an abstract actor.
	#  (2) A subrecord is used.
	#  (3) A single source feeds more than one sink.
	# NB: It is not allowed for a single sink to be fed by more than one source
	# (except with subrecords, i.e. when a combinator is used)
	def is_abstract(self):
		return any(isinstance(x, AbstractActor) for x in self) \
			or any(d["source_subr"] is not None or d["sink_subr"] is not None
				for u, v, d in self.edges_iter(data=True)) \
			or bool(self._list_divergences())
	
	def _eliminate_subrecords_and_divergences(self):
		# Insert combinators.
		for (dst_node, dst_endpoint), sources in self._sink_to_sources().items():
			if len(sources) > 1 or sources[0][2] is not None:
				# build combinator
				# "layout" is filled in during instantiation
				subrecords = [dst_subrecord for src_node, src_endpoint, dst_subrecord, src_subrecord in sources]
				combinator = AbstractActor(plumbing.Combinator, {"subrecords": subrecords})
				# disconnect source1 -> sink ... sourcen -> sink
				# connect source1 -> combinator_sink1 ... sourcen -> combinator_sinkn
				for n, (src_node, src_endpoint, dst_subrecord, src_subrecord) in enumerate(sources):
					self.del_connections(src_node, dst_node,
						{"source": src_endpoint, "sink": dst_endpoint})
					self.add_connection(src_node, combinator,
						src_endpoint, "sink{0}".format(n), source_subr=src_subrecord)
				# connect combinator_source -> sink
				self.add_connection(combinator, dst_node, "source", dst_endpoint)
		# Insert splitters.
		for (src_node, src_endpoint), sinks in self._source_to_sinks().items():
			if len(sinks) > 1 or sinks[0][2] is not None:
				subrecords = [src_subrecord for dst_node, dst_endpoint, src_subrecord, dst_subrecord in sinks]
				splitter = AbstractActor(plumbing.Splitter, {"subrecords": subrecords})
				# disconnect source -> sink1 ... source -> sinkn
				# connect splitter_source1 -> sink1 ... splitter_sourcen -> sinkn
				for n, (dst_node, dst_endpoint, src_subrecord, dst_subrecord) in enumerate(sinks):
					self.del_connections(src_node, dst_node,
						{"source": src_endpoint, "sink": dst_endpoint})
					self.add_connection(splitter, dst_node,
						"source{0}".format(n), dst_endpoint)
				# connect source -> splitter_sink
				self.add_connection(src_node, splitter, src_endpoint, "sink")
	
	def _infer_plumbing_layout(self):
		while True:
			ap = [a for a in self if isinstance(a, AbstractActor) and a.actor_class in plumbing.actors]
			if not ap:
				break
			for a in ap:
				in_edges = self.in_edges(a, data=True)
				out_edges = self.out_edges(a, data=True)
				if a.actor_class in plumbing.layout_sink and len(in_edges) == 1:
					other, me, data = in_edges[0]
					if isinstance(other, AbstractActor):
						continue
					other_ep = data["source"]
					if other_ep is None:
						other_ep = get_single_ep(other, Source)[1]
					else:
						other_ep = getattr(other, other_ep)
				elif a.actor_class in plumbing.layout_source and len(out_edges) == 1:
					me, other, data = out_edges[0]
					if isinstance(other, AbstractActor):
						continue
					other_ep = data["sink"]
					if other_ep is None:
						other_ep = get_single_ep(other, Sink)[1]
					else:
						other_ep = getattr(other, other_ep)
				else:
					raise AssertionError
				layout = other_ep.payload.layout
				a.parameters["layout"] = layout
				self.instantiate(a)
	
	def _instantiate_actors(self):
		# 1. instantiate all abstract non-plumbing actors
		for actor in list(self):
			if isinstance(actor, AbstractActor) and actor.actor_class not in plumbing.actors:
				self.instantiate(actor)
		# 2. infer plumbing layout and instantiate plumbing
		self._infer_plumbing_layout()
		# 3. resolve default eps
		for u, v, d in self.edges_iter(data=True):
			if d["source"] is None:
				d["source"] = get_single_ep(u, Source)[0]
			if d["sink"] is None:
				d["sink"] = get_single_ep(v, Sink)[0]
	
	# Elaboration turns an abstract DFG into a physical one.
	#   Pass 1: eliminate subrecords and divergences
	#           by inserting Combinator/Splitter actors
	#   Pass 2: run optimizer (e.g. share and duplicate actors)
	#   Pass 3: instantiate all abstract actors and explicit "None" endpoints
	def elaborate(self, optimizer=None):
		if self.elaborated:
			return
		self.elaborated = True
		
		self._eliminate_subrecords_and_divergences()
		if optimizer is not None:
			optimizer(self)
		self._instantiate_actors()

class CompositeActor(Module):
	def __init__(self, dfg):
		dfg.elaborate()

		# expose unconnected endpoints
		uc_eps_by_node = dict((node, get_endpoints(node)) for node in dfg)
		for u, v, d in dfg.edges_iter(data=True):
			uc_eps_u = uc_eps_by_node[u]
			source = d["source"]
			try:
				del uc_eps_u[source]
			except KeyError:
				pass
			uc_eps_v = uc_eps_by_node[v]
			sink = d["sink"]
			try:
				del uc_eps_v[sink]
			except KeyError:
				pass
		for node, uc_eps in uc_eps_by_node.items():
			for k, v in uc_eps.items():
				assert(not hasattr(self, k))
				setattr(self, k, v)

		# connect abstract busy signals
		for node in dfg:
			try:
				abstract_busy_signal = dfg.abstract_busy_signals[id(node)]
			except KeyError:
				pass
			else:
				self.comb += abstract_busy_signal.eq(node.busy)

		# generate busy signal
		self.busy = Signal()
		self.comb += self.busy.eq(optree("|", [node.busy for node in dfg]))

		# claim ownership of sub-actors and establish connections
		for node in dfg:
			self.submodules += node
		for u, v, d in dfg.edges_iter(data=True):
			ep_src = getattr(u, d["source"])
			ep_dst = getattr(v, d["sink"])
			self.comb += ep_src.connect_flat(ep_dst)

########NEW FILE########
__FILENAME__ = perftools
from migen.flow.hooks import *

class EndpointReporter(EndpointSimHook):
	def __init__(self, endpoint):
		EndpointSimHook.__init__(self, endpoint)
		self.reset()
	
	def reset(self):
		self.inactive = 0
		self.ack = 0
		self.nack = 0
	
	# Total number of cycles per token (inverse token rate)
	def cpt(self):
		return (self.inactive + self.nack + self.ack)/self.ack
	
	# Inactivity cycles per token (slack)
	def ipt(self):
		return self.inactive/self.ack
	
	# NAK cycles per token (backpressure)
	def npt(self):
		return self.nack/self.ack
	
	def report_str(self):
		if self.ack:
			return "C/T={:.2f}\nI/T={:.2f}\nN/T={:.2f}".format(self.cpt(), self.ipt(), self.npt())
		else:
			return "N/A"
	
	def on_ack(self):
		self.ack += 1
	
	def on_nack(self):
		self.nack += 1
		
	def on_inactive(self):
		self.inactive += 1

class DFGReporter(DFGHook):
	def __init__(self, dfg):
		DFGHook.__init__(self, dfg, lambda u, ep, v: EndpointReporter(getattr(u, ep)))

	def get_edge_labels(self):
		d = dict()
		for (u, v), eps in self.nodepair_to_ep.items():
			if len(eps) == 1:
				d[(u, v)] = list(eps.values())[0].report_str()
			else:
				d[(u, v)] = "\n".join(ep + ":\n" + reporter.report_str()
					for ep, reporter in eps)
		return d

########NEW FILE########
__FILENAME__ = plumbing
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.genlib.record import *
from migen.genlib.misc import optree

class Buffer(PipelinedActor):
	def __init__(self, layout):
		self.d = Sink(layout)
		self.q = Source(layout)
		PipelinedActor.__init__(self, 1)
		self.sync += If(self.pipe_ce, self.q.payload.eq(self.d.payload))

class Combinator(Module):
	def __init__(self, layout, subrecords):
		self.source = Source(layout)
		sinks = []
		for n, r in enumerate(subrecords):
			s = Sink(layout_partial(layout, *r))
			setattr(self, "sink"+str(n), s)
			sinks.append(s)
		self.busy = Signal()

		###
	
		self.comb += [
			self.busy.eq(0),
			self.source.stb.eq(optree("&", [sink.stb for sink in sinks]))
		]
		self.comb += [sink.ack.eq(self.source.ack & self.source.stb) for sink in sinks]
		self.comb += [self.source.payload.eq(sink.payload) for sink in sinks]

class Splitter(Module):
	def __init__(self, layout, subrecords):
		self.sink = Sink(layout)
		sources = []
		for n, r in enumerate(subrecords):
			s = Source(layout_partial(layout, *r))
			setattr(self, "source"+str(n), s)
			sources.append(s)
		self.busy = Signal()
		
		###

		self.comb += [source.payload.eq(self.sink.payload) for source in sources]
		already_acked = Signal(len(sources))
		self.sync += If(self.sink.stb,
				already_acked.eq(already_acked | Cat(*[s.ack for s in sources])),
				If(self.sink.ack, already_acked.eq(0))
			)
		self.comb += self.sink.ack.eq(optree("&",
				[s.ack | already_acked[n] for n, s in enumerate(sources)]))
		for n, s in enumerate(sources):
			self.comb += s.stb.eq(self.sink.stb & ~already_acked[n])

class Multiplexer(Module):
	def __init__(self, n, layout):
		self.source = Source(layout)
		sinks = []
		for i in range(n):
			sink = Sink(layout)
			setattr(self, "sink"+str(i), sink)
			sinks.append(sink)
		self.busy = Signal()
		self.sel = Signal(max=n)
		
		###

		case = {}
		for i, sink in enumerate(sinks):
			cases[i] = Record.connect(sink, self.source)
		self.comb += Case(self.sel, cases)

class Demultiplexer(Module):
	def __init__(self, layout, n):
		self.sink = Sink(layout)
		sources = []
		for i in range(n):
			source = Source(layout)
			setattr(self, "source"+str(i), source)
			sources.append(source)
		self.busy = Signal()
		self.sel = Signal(max=n)
		
		###

		cases = {}
		for i, source in enumerate(sources):
			cases[i] = Record.connect(self.sink, source)
		self.comb += Case(self.sel, cases)

# Actors whose layout should be inferred from what their single sink is connected to.
layout_sink = {Buffer, Splitter}
# Actors whose layout should be inferred from what their single source is connected to.
layout_source = {Buffer, Combinator}
# All actors.
actors = layout_sink | layout_source

########NEW FILE########
__FILENAME__ = transactions
class Token:
	def __init__(self, endpoint, value=None, idle_wait=False):
		self.endpoint = endpoint
		self.value = value
		self.idle_wait = idle_wait

########NEW FILE########
__FILENAME__ = cdc
from migen.fhdl.std import *
from migen.fhdl.bitcontainer import value_bits_sign
from migen.fhdl.specials import Special
from migen.fhdl.tools import list_signals

class NoRetiming(Special):
	def __init__(self, reg):
		Special.__init__(self)
		self.reg = reg

	# do nothing
	@staticmethod
	def lower(dr):
		return Module()

class MultiRegImpl(Module):
	def __init__(self, i, o, odomain, n):
		self.i = i
		self.o = o
		self.odomain = odomain

		w, signed = value_bits_sign(self.i)
		self.regs = [Signal((w, signed)) for i in range(n)]

		###
	
		src = self.i
		for reg in self.regs:
			sd = getattr(self.sync, self.odomain)
			sd += reg.eq(src)
			src = reg
		self.comb += self.o.eq(src)
		self.specials += [NoRetiming(reg) for reg in self.regs]

class MultiReg(Special):
	def __init__(self, i, o, odomain="sys", n=2):
		Special.__init__(self)
		self.i = i
		self.o = o
		self.odomain = odomain
		self.n = n

	def iter_expressions(self):
		yield self, "i", SPECIAL_INPUT
		yield self, "o", SPECIAL_OUTPUT

	def rename_clock_domain(self, old, new):
		Special.rename_clock_domain(self, old, new)
		if self.odomain == old:
			self.odomain = new

	def list_clock_domains(self):
		r = Special.list_clock_domains(self)
		r.add(self.odomain)
		return r

	@staticmethod
	def lower(dr):
		return MultiRegImpl(dr.i, dr.o, dr.odomain, dr.n)

class PulseSynchronizer(Module):
	def __init__(self, idomain, odomain):
		self.i = Signal()
		self.o = Signal()

		###

		toggle_i = Signal()
		toggle_o = Signal()
		toggle_o_r = Signal()

		sync_i = getattr(self.sync, idomain)
		sync_o = getattr(self.sync, odomain)
		
		sync_i += If(self.i, toggle_i.eq(~toggle_i))
		self.specials += MultiReg(toggle_i, toggle_o, odomain)
		sync_o += toggle_o_r.eq(toggle_o)
		self.comb += self.o.eq(toggle_o ^ toggle_o_r)

class GrayCounter(Module):
	def __init__(self, width):
		self.ce = Signal()
		self.q = Signal(width)
		self.q_next = Signal(width)
		self.q_binary = Signal(width)
		self.q_next_binary = Signal(width)

		###

		self.comb += [
			If(self.ce,
				self.q_next_binary.eq(self.q_binary + 1)
			).Else(
				self.q_next_binary.eq(self.q_binary)
			),
			self.q_next.eq(self.q_next_binary ^ self.q_next_binary[1:])
		]
		self.sync += [
			self.q_binary.eq(self.q_next_binary),
			self.q.eq(self.q_next)
		]

########NEW FILE########
__FILENAME__ = coding
from migen.fhdl.std import *

"""
Encoders and decoders between binary and one-hot representation
"""

class Encoder(Module):
	"""Encode one-hot to binary

	If `n` is low, the `o` th bit in `i` is asserted, else none or
	multiple bits are asserted.

	Parameters
	----------
	width : int
		Bit width of the input

	Attributes
	----------
	i : Signal(width), in
		One-hot input
	o : Signal(max=width), out
		Encoded binary
	n : Signal(1), out
		Invalid, either none or multiple input bits are asserted
	"""
	def __init__(self, width):
		self.i = Signal(width) # one-hot
		self.o = Signal(max=max(2, width)) # binary
		self.n = Signal() # invalid: none or multiple
		act = dict((1<<j, self.o.eq(j)) for j in range(width))
		act["default"] = self.n.eq(1)
		self.comb += Case(self.i, act)

class PriorityEncoder(Module):
	"""Priority encode requests to binary

	If `n` is low, the `o` th bit in `i` is asserted and the bits below
	`o` are unasserted, else `o == 0`. The LSB has priority.

	Parameters
	----------
	width : int
		Bit width of the input

	Attributes
	----------
	i : Signal(width), in
		Input requests
	o : Signal(max=width), out
		Encoded binary
	n : Signal(1), out
		Invalid, no input bits are asserted
	"""
	def __init__(self, width):
		self.i = Signal(width) # one-hot, lsb has priority
		self.o = Signal(max=max(2, width)) # binary
		self.n = Signal() # none
		for j in range(width)[::-1]: # last has priority
			self.comb += If(self.i[j], self.o.eq(j))
		self.comb += self.n.eq(self.i == 0)

class Decoder(Module):
	"""Decode binary to one-hot

	If `n` is low, the `i` th bit in `o` is asserted, the others are
	not, else `o == 0`.

	Parameters
	----------
	width : int
		Bit width of the output

	Attributes
	----------
	i : Signal(max=width), in
		Input binary
	o : Signal(width), out
		Decoded one-hot
	n : Signal(1), in
		Invalid, no output bits are to be asserted
	"""

	def __init__(self, width):
		self.i = Signal(max=max(2, width)) # binary
		self.n = Signal() # none/invalid
		self.o = Signal(width) # one-hot
		act = dict((j, self.o.eq(1<<j)) for j in range(width))
		self.comb += Case(self.i, act)
		self.comb += If(self.n, self.o.eq(0))

class PriorityDecoder(Decoder):
	pass # same

########NEW FILE########
__FILENAME__ = complex
from migen.fhdl.std import *

class Complex:
	def __init__(self, real, imag):
		self.real = real
		self.imag = imag
	
	def __neg__(self):
		return Complex(-self.real, -self.imag)
	
	def __add__(self, other):
		if isinstance(other, Complex):
			return Complex(self.real + other.real, self.imag + other.imag)
		else:
			return Complex(self.real + other, self.imag)
	__radd__ = __add__
	def __sub__(self, other):
		if isinstance(other, Complex):
			return Complex(self.real - other.real, self.imag - other.imag)
		else:
			return Complex(self.real - other, self.imag)
	def __rsub__(self, other):
		if isinstance(other, Complex):
			return Complex(other.real - self.real, other.imag - self.imag)
		else:
			return Complex(other - self.real, -self.imag)
	def __mul__(self, other):
		if isinstance(other, Complex):
			return Complex(self.real*other.real - self.imag*other.imag,
				self.real*other.imag + self.imag*other.real)
		else:
			return Complex(self.real*other, self.imag*other)
	__rmul__ = __mul__
	
	def __lshift__(self, other):
		return Complex(self.real << other, self.imag << other)
	def __rshift__(self, other):
		return Complex(self.real >> other, self.imag >> other)

	def __repr__(self):
		return repr(self.real) + " + " + repr(self.imag) + "j"
	
	def eq(self, r):
		if isinstance(r, Complex):
			return self.real.eq(r.real), self.imag.eq(r.imag)
		else:
			return self.real.eq(r), self.imag.eq(0)

def SignalC(*args, **kwargs):
	real = Signal(*args, **kwargs)
	imag = Signal(*args, **kwargs)
	return Complex(real, imag)

########NEW FILE########
__FILENAME__ = cordic
from math import atan, atanh, log, sqrt, pi, ceil

from migen.fhdl.std import *

class TwoQuadrantCordic(Module):
	"""Coordinate rotation digital computer

	Trigonometric, and arithmetic functions implemented using
	additions/subtractions and shifts.

	http://eprints.soton.ac.uk/267873/1/tcas1_cordic_review.pdf

	http://www.andraka.com/files/crdcsrvy.pdf

	http://zatto.free.fr/manual/Volder_CORDIC.pdf

	The way the CORDIC is executed is controlled by `eval_mode`.
	If `"iterative"` the stages are iteratively evaluated, one per clock
	cycle. This mode uses the least amount of registers, but has the
	lowest throughput and highest latency.  If `"pipelined"` all stages
	are executed in every clock cycle but separated by registers.  This
	mode has full throughput but uses many registers and has large
	latency. If `"combinatorial"`, there are no registers, throughput is
	maximal and latency is zero. `"pipelined"` and `"combinatorial"` use
	the same number of sphifters and adders.

	The type of trigonometric/arithmetic function is determined by
	`cordic_mode` and `func_mode`. :math:`g` is the gain of the CORDIC.

		* rotate-circular: rotate the vector `(xi, yi)` by an angle `zi`.
		  Used to calculate trigonometric functions, `sin(), cos(),
		  tan() = sin()/cos()`, or to perform polar-to-cartesian coordinate
		  transformation:

			.. math::
				x_o = g \\cos(z_i) x_i - g \\sin(z_i) y_i

				y_o = g \\sin(z_i) x_i + g \\cos(z_i) y_i

		* vector-circular: determine length and angle of the vector
		  `(xi, yi)`.  Used to calculate `arctan(), sqrt()` or
		  to perform cartesian-to-polar transformation:

			.. math::
				x_o = g\\sqrt{x_i^2 + y_i^2}

				z_o = z_i + \\tan^{-1}(y_i/x_i)

		* rotate-hyperbolic: hyperbolic functions of `zi`. Used to
		  calculate hyprbolic functions, `sinh, cosh, tanh = cosh/sinh,
		  exp = cosh + sinh`:

			.. math::
				x_o = g \\cosh(z_i) x_i + g \\sinh(z_i) y_i

				y_o = g \\sinh(z_i) x_i + g \\cosh(z_i) z_i

		* vector-hyperbolic: natural logarithm `ln(), arctanh()`, and
		  `sqrt()`. Use `x_i = a + b` and `y_i = a - b` to obtain `2*
		  sqrt(a*b)` and `ln(a/b)/2`:

			.. math::
				x_o = g\\sqrt{x_i^2 - y_i^2}

				z_o = z_i + \\tanh^{-1}(y_i/x_i)

		* rotate-linear: multiply and accumulate (not a very good
		  multiplier implementation):

			.. math::
				y_o = g(y_i + x_i z_i)

		* vector-linear: divide and accumulate:

			.. math::
				z_o = g(z_i + y_i/x_i)

	Parameters
	----------
	width : int
		Bit width of the input and output signals. Defaults to 16. Input
		and output signals are signed.
	widthz : int
		Bit with of `zi` and `zo`. Defaults to the `width`.
	stages : int or None
		Number of CORDIC incremental rotation stages. Defaults to
		`width + min(1, guard)`.
	guard : int or None
		Add guard bits to the intermediate signals. If `None`,
		defaults to `guard = log2(width)` which guarantees accuracy
		to `width` bits.
	eval_mode : str, {"iterative", "pipelined", "combinatorial"}
	cordic_mode : str, {"rotate", "vector"}
	func_mode : str, {"circular", "linear", "hyperbolic"}
		Evaluation and arithmetic mode. See above.

	Attributes
	----------
	xi, yi, zi : Signal(width), in
		Input values, signed.
	xo, yo, zo : Signal(width), out
		Output values, signed.
	new_out : Signal(1), out
		Asserted if output values are freshly updated in the current
		cycle.
	new_in : Signal(1), out
		Asserted if new input values are being read in the next cycle.
	zmax : float
		`zi` and `zo` normalization factor. Floating point `zmax`
		corresponds to `1<<(widthz - 1)`. `x` and `y` are scaled such
		that floating point `1` corresponds to `1<<(width - 1)`.
	gain : float
		Cumulative, intrinsic gain and scaling factor. In circular mode
		`sqrt(xi**2 + yi**2)` should be no larger than `2**(width - 1)/gain`
		to prevent overflow. Additionally, in hyperbolic and linear mode,
		the operation itself can cause overflow.
	interval : int
		Output interval in clock cycles. Inverse throughput.
	latency : int
		Input-to-output latency. The result corresponding to the inputs
		appears at the outputs `latency` cycles later.

	Notes
	-----

	Each stage `i` in the CORDIC performs the following operation:

	.. math::
		x_{i+1} = x_i - m d_i y_i r^{-s_{m,i}},

		y_{i+1} = y_i + d_i x_i r^{-s_{m,i}},

		z_{i+1} = z_i - d_i a_{m,i},

	where:

		* :math:`d_i`: clockwise or counterclockwise, determined by
		  `sign(z_i)` in rotate mode or `sign(-y_i)` in vector mode.

		* :math:`r`: radix of the number system (2)

		* :math:`m`: 1: circular, 0: linear, -1: hyperbolic

		* :math:`s_{m,i}`: non decreasing integer shift sequence

		* :math:`a_{m,i}`: elemetary rotation angle: :math:`a_{m,i} =
		  \\tan^{-1}(\\sqrt{m} s_{m,i})/\\sqrt{m}`.
	"""
	def __init__(self, width=16, widthz=None, stages=None, guard=0,
			eval_mode="iterative", cordic_mode="rotate",
			func_mode="circular"):
		# validate parameters
		assert eval_mode in ("combinatorial", "pipelined", "iterative")
		assert cordic_mode in ("rotate", "vector")
		assert func_mode in ("circular", "linear", "hyperbolic")
		self.cordic_mode = cordic_mode
		self.func_mode = func_mode
		if guard is None:
			# guard bits to guarantee "width" accuracy
			guard = int(log(width)/log(2))
		if widthz is None:
			widthz = width
		if stages is None:
			stages = width + min(1, guard) # cuts error below LSB

		# input output interface
		self.xi = Signal((width, True))
		self.yi = Signal((width, True))
		self.zi = Signal((widthz, True))
		self.xo = Signal((width, True))
		self.yo = Signal((width, True))
		self.zo = Signal((widthz, True))
		self.new_in = Signal()
		self.new_out = Signal()

		###

		a, s, self.zmax, self.gain = self._constants(stages, widthz + guard)
		stages = len(a) # may have increased due to repetitions

		if eval_mode == "iterative":
			num_sig = 3
			self.interval = stages + 1
			self.latency = stages + 2
		else:
			num_sig = stages + 1
			self.interval = 1
			if eval_mode == "pipelined":
				self.latency = stages
			else: # combinatorial
				self.latency = 0

		# inter-stage signals
		x = [Signal((width + guard, True)) for i in range(num_sig)]
		y = [Signal((width + guard, True)) for i in range(num_sig)]
		z = [Signal((widthz + guard, True)) for i in range(num_sig)]

		# hook up inputs and outputs to the first and last inter-stage
		# signals
		self.comb += [
			x[0].eq(self.xi<<guard),
			y[0].eq(self.yi<<guard),
			z[0].eq(self.zi<<guard),
			self.xo.eq(x[-1]>>guard),
			self.yo.eq(y[-1]>>guard),
			self.zo.eq(z[-1]>>guard),
			]

		if eval_mode == "iterative":
			# We afford one additional iteration for in/out.
			i = Signal(max=stages + 1)
			self.comb += [
					self.new_in.eq(i == stages),
					self.new_out.eq(i == 1),
					]
			ai = Signal((widthz + guard, True))
			self.sync += ai.eq(Array(a)[i])
			if range(stages) == s:
				si = i - 1 # shortcut if no stage repetitions
			else:
				si = Signal(max=stages + 1)
				self.sync += si.eq(Array(s)[i])
			xi, yi, zi = x[1], y[1], z[1]
			self.sync += [
					self._stage(xi, yi, zi, xi, yi, zi, si, ai),
					i.eq(i + 1),
					If(i == stages,
						i.eq(0),
					),
					If(i == 0,
						x[2].eq(xi),
						y[2].eq(yi),
						z[2].eq(zi),
						xi.eq(x[0]),
						yi.eq(y[0]),
						zi.eq(z[0]),
					)]
		else:
			self.comb += [
					self.new_out.eq(1),
					self.new_in.eq(1),
					]
			for i, si in enumerate(s):
				stmt = self._stage(x[i], y[i], z[i],
						x[i + 1], y[i + 1], z[i + 1], si, a[i])
				if eval_mode == "pipelined":
					self.sync += stmt
				else: # combinatorial
					self.comb += stmt

	def _constants(self, stages, bits):
		if self.func_mode == "circular":
			s = range(stages)
			a = [atan(2**-i) for i in s]
			g = [sqrt(1 + 2**(-2*i)) for i in s]
			#zmax = sum(a)
			# use pi anyway as the input z can cause overflow
			# and we need the range for quadrant mapping
			zmax = pi
		elif self.func_mode == "linear":
			s = range(stages)
			a = [2**-i for i in s]
			g = [1 for i in s]
			#zmax = sum(a)
			# use 2 anyway as this simplifies a and scaling
			zmax = 2.
		else: # hyperbolic
			s = []
			# need to repeat some stages:
			j = 4
			for i in range(stages):
				if i == j:
					s.append(j)
					j = 3*j + 1
				s.append(i + 1)
			a = [atanh(2**-i) for i in s]
			g = [sqrt(1 - 2**(-2*i)) for i in s]
			zmax = sum(a)*2
		a = [int(ai*2**(bits - 1)/zmax) for ai in a]
		# round here helps the width=2**i - 1 case but hurts the
		# important width=2**i case
		gain = 1.
		for gi in g:
			gain *= gi
		return a, s, zmax, gain

	def _stage(self, xi, yi, zi, xo, yo, zo, i, ai):
		if self.cordic_mode == "rotate":
			direction = zi < 0
		else: # vector
			direction = yi >= 0
		dx = yi>>i
		dy = xi>>i
		dz = ai
		if self.func_mode == "linear":
			dx = 0
		elif self.func_mode == "hyperbolic":
			dx = -dx
		stmt = If(direction,
					xo.eq(xi + dx),
					yo.eq(yi - dy),
					zo.eq(zi + dz),
				).Else(
					xo.eq(xi - dx),
					yo.eq(yi + dy),
					zo.eq(zi - dz),
				)
		return stmt

class Cordic(TwoQuadrantCordic):
	"""Four-quadrant CORDIC

	Same as :class:`TwoQuadrantCordic` but with support and convergence
	for `abs(zi) > pi/2 in circular rotate mode or `xi < 0` in circular
	vector mode.
	"""
	def __init__(self, **kwargs):
		TwoQuadrantCordic.__init__(self, **kwargs)
		if self.func_mode != "circular":
			return # no need to remap quadrants

		width = flen(self.xi)
		widthz = flen(self.zi)
		cxi, cyi, czi = self.xi, self.yi, self.zi
		self.xi = Signal((width, True))
		self.yi = Signal((width, True))
		self.zi = Signal((widthz, True))

		###

		pi2 = 1<<(widthz - 2)
		if self.cordic_mode == "rotate":
			#rot = self.zi + pi2 < 0
			rot = self.zi[-1] ^ self.zi[-2]
		else: # vector
			rot = self.xi < 0
			#rot = self.xi[-1]
		self.comb += [
				cxi.eq(self.xi),
				cyi.eq(self.yi),
				czi.eq(self.zi),
				If(rot,
					cxi.eq(-self.xi),
					cyi.eq(-self.yi),
					czi.eq(self.zi + 2*pi2),
					#czi.eq(self.zi ^ (2*pi2)),
				),
				]

########NEW FILE########
__FILENAME__ = divider
from migen.fhdl.std import *

class Divider(Module):
	def __init__(self, w):
		self.start_i = Signal()
		self.dividend_i = Signal(w)
		self.divisor_i = Signal(w)
		self.ready_o = Signal()
		self.quotient_o = Signal(w)
		self.remainder_o = Signal(w)
	
		###
		
		qr = Signal(2*w)
		counter = Signal(max=w+1)
		divisor_r = Signal(w)
		diff = Signal(w+1)
		
		self.comb += [
			self.quotient_o.eq(qr[:w]),
			self.remainder_o.eq(qr[w:]),
			self.ready_o.eq(counter == 0),
			diff.eq(qr[w-1:] - divisor_r)
		]
		self.sync += [
			If(self.start_i,
				counter.eq(w),
				qr.eq(self.dividend_i),
				divisor_r.eq(self.divisor_i)
			).Elif(~self.ready_o,
					If(diff[w],
						qr.eq(Cat(0, qr[:2*w-1]))
					).Else(
						qr.eq(Cat(1, qr[:w-1], diff[:w]))
					),
					counter.eq(counter - 1)
			)
		]

########NEW FILE########
__FILENAME__ = fifo
from migen.fhdl.std import *
from migen.genlib.cdc import NoRetiming, MultiReg, GrayCounter
from migen.genlib.record import layout_len, Record

def _inc(signal, modulo):
	if modulo == 2**flen(signal):
		return signal.eq(signal + 1)
	else:
		return If(signal == (modulo - 1),
			signal.eq(0)
		).Else(
			signal.eq(signal + 1)
		)

class _FIFOInterface:
	"""
	Data written to the input interface (`din`, `we`, `writable`) is
	buffered and can be read at the output interface (`dout`, `re`,
	`readable`). The data entry written first to the input 
	also appears first on the output.

	Parameters
	----------
	width_or_layout : int, layout
		Bit width or `Record` layout for the data.
	depth : int
		Depth of the FIFO.

	Attributes
	----------
	din : in, width_or_layout
		Input data either flat or Record structured.
	writable : out
		There is space in the FIFO and `we` can be asserted to load new data.
	we : in
		Write enable signal to latch `din` into the FIFO. Does nothing if
		`writable` is not asserted.
	dout : out, width_or_layout
		Output data, same type as `din`. Only valid if `readable` is
		asserted.
	readable : out
		Output data `dout` valid, FIFO not empty.
	re : in
		Acknowledge `dout`. If asserted, the next entry will be
		available on the next cycle (if `readable` is high then).
	"""
	def __init__(self, width_or_layout, depth):
		self.we = Signal()
		self.writable = Signal() # not full
		self.re = Signal()
		self.readable = Signal() # not empty

		if isinstance(width_or_layout, list):
			self.din = Record(width_or_layout)
			self.dout = Record(width_or_layout)
			self.din_bits = self.din.raw_bits()
			self.dout_bits = self.dout.raw_bits()
			self.width = layout_len(width_or_layout)
		else:
			self.din = Signal(width_or_layout)
			self.dout = Signal(width_or_layout)
			self.din_bits = self.din
			self.dout_bits = self.dout
			self.width = width_or_layout

class SyncFIFO(Module, _FIFOInterface):
	"""Synchronous FIFO (first in, first out)

	Read and write interfaces are accessed from the same clock domain.
	If different clock domains are needed, use :class:`AsyncFIFO`.

	{interface}
	level : out
		Number of unread entries.
	flush : in
		Flush the FIFO discarding pending write.
		In the next cycle `readable` will be deasserted
		and `writable` will be asserted, `level` will be zero.
	"""
	__doc__ = __doc__.format(interface=_FIFOInterface.__doc__)

	def __init__(self, width_or_layout, depth):
		_FIFOInterface.__init__(self, width_or_layout, depth)

		self.flush = Signal()
		self.level = Signal(max=depth+1)

		###

		do_write = Signal()
		do_read = Signal()
		self.comb += [
			do_write.eq(self.writable & self.we),
			do_read.eq(self.readable & self.re)
		]

		produce = Signal(max=depth)
		consume = Signal(max=depth)
		storage = Memory(self.width, depth)
		self.specials += storage

		wrport = storage.get_port(write_capable=True)
		self.specials += wrport
		self.comb += [
			wrport.adr.eq(produce),
			wrport.dat_w.eq(self.din_bits),
			wrport.we.eq(do_write)
		]
		self.sync += If(do_write, _inc(produce, depth))

		rdport = storage.get_port(async_read=True)
		self.specials += rdport
		self.comb += [
			rdport.adr.eq(consume),
			self.dout_bits.eq(rdport.dat_r)
		]
		self.sync += If(do_read, _inc(consume, depth))

		self.sync += [
			If(self.flush,
				produce.eq(0),
				consume.eq(0),
				self.level.eq(0),
			).Elif(do_write,
				If(~do_read, self.level.eq(self.level + 1))
			).Elif(do_read,
				self.level.eq(self.level - 1)
			)
		]
		self.comb += [
			self.writable.eq(self.level != depth),
			self.readable.eq(self.level != 0)
		]

class SyncFIFOClassic(Module, _FIFOInterface):
	def __init__(self, width_or_layout, depth):
		_FIFOInterface.__init__(self, width_or_layout, depth)
		self.submodules.fifo = fifo = SyncFIFO(width_or_layout, depth)

		self.writable = fifo.writable
		self.din_bits = fifo.din_bits
		self.din = fifo.din
		self.we = fifo.we
		self.readable = fifo.readable
		self.re = fifo.re
		self.flush = fifo.flush
		self.level = fifo.level

		###

		self.sync += [
				If(self.re & self.readable,
					self.dout_bits.eq(fifo.dout_bits),
				)]

class SyncFIFOBuffered(Module, _FIFOInterface):
	def __init__(self, width_or_layout, depth):
		_FIFOInterface.__init__(self, width_or_layout, depth)
		self.submodules.fifo = fifo = SyncFIFOClassic(width_or_layout, depth)

		self.writable = fifo.writable
		self.din_bits = fifo.din_bits
		self.din = fifo.din
		self.we = fifo.we
		self.dout_bits = fifo.dout_bits
		self.dout = fifo.dout
		self.flush = fifo.flush
		self.level = fifo.level

		###

		self.comb += [
				fifo.re.eq(fifo.readable & (~self.readable | self.re)),
				]
		self.sync += [
				If(self.flush,
					self.readable.eq(0),
				).Elif(fifo.re,
					self.readable.eq(1),
				).Elif(self.re,
					self.readable.eq(0),
				)]

class AsyncFIFO(Module, _FIFOInterface):
	"""Asynchronous FIFO (first in, first out)

	Read and write interfaces are accessed from different clock domains,
	named `read` and `write`. Use `RenameClockDomains` to rename to
	other names.

	{interface}
	"""
	__doc__ = __doc__.format(interface=_FIFOInterface.__doc__)

	def __init__(self, width_or_layout, depth):
		_FIFOInterface.__init__(self, width_or_layout, depth)

		###

		depth_bits = log2_int(depth, True)

		produce = RenameClockDomains(GrayCounter(depth_bits+1), "write")
		consume = RenameClockDomains(GrayCounter(depth_bits+1), "read")
		self.submodules += produce, consume
		self.comb += [
			produce.ce.eq(self.writable & self.we),
			consume.ce.eq(self.readable & self.re)
		]

		produce_rdomain = Signal(depth_bits+1)
		self.specials += [
			NoRetiming(produce.q),
			MultiReg(produce.q, produce_rdomain, "read")
		]
		consume_wdomain = Signal(depth_bits+1)
		self.specials += [
			NoRetiming(consume.q),
			MultiReg(consume.q, consume_wdomain, "write")
		]
		self.comb += [
			self.writable.eq((produce.q[-1] == consume_wdomain[-1])
			 | (produce.q[-2] == consume_wdomain[-2])
			 | (produce.q[:-2] != consume_wdomain[:-2])),
			self.readable.eq(consume.q != produce_rdomain)
		]

		storage = Memory(self.width, depth)
		self.specials += storage
		wrport = storage.get_port(write_capable=True, clock_domain="write")
		self.specials += wrport
		self.comb += [
			wrport.adr.eq(produce.q_binary[:-1]),
			wrport.dat_w.eq(self.din_bits),
			wrport.we.eq(produce.ce)
		]
		rdport = storage.get_port(clock_domain="read")
		self.specials += rdport
		self.comb += [
			rdport.adr.eq(consume.q_next_binary[:-1]),
			self.dout_bits.eq(rdport.dat_r)
		]

########NEW FILE########
__FILENAME__ = fsm
from collections import OrderedDict

from migen.fhdl.std import *
from migen.fhdl.module import FinalizeError
from migen.fhdl.visit import NodeTransformer

class AnonymousState:
	pass

# do not use namedtuple here as it inherits tuple
# and the latter is used elsewhere in FHDL
class NextState:
	def __init__(self, state):
		self.state = state

class _LowerNextState(NodeTransformer):
	def __init__(self, next_state_signal, encoding, aliases):
		self.next_state_signal = next_state_signal
		self.encoding = encoding
		self.aliases = aliases
		
	def visit_unknown(self, node):
		if isinstance(node, NextState):
			try:
				actual_state = self.aliases[node.state]
			except KeyError:
				actual_state = node.state
			return self.next_state_signal.eq(self.encoding[actual_state])
		else:
			return node

class FSM(Module):
	def __init__(self, reset_state=None):
		self.actions = OrderedDict()
		self.state_aliases = dict()
		self.reset_state = reset_state

		self.before_entering_signals = OrderedDict()
		self.before_leaving_signals = OrderedDict()
		self.after_entering_signals = OrderedDict()
		self.after_leaving_signals = OrderedDict()

	def act(self, state, *statements):
		if self.finalized:
			raise FinalizeError
		if state not in self.actions:
			self.actions[state] = []
		self.actions[state] += statements

	def delayed_enter(self, name, target, delay):
		if self.finalized:
			raise FinalizeError
		if delay:
			state = name
			for i in range(delay):
				if i == delay - 1:
					next_state = target
				else:
					next_state = AnonymousState()
				self.act(state, NextState(next_state))
				state = next_state
		else:
			self.state_aliases[name] = target

	def ongoing(self, state):
		is_ongoing = Signal()
		self.act(state, is_ongoing.eq(1))
		return is_ongoing

	def _get_signal(self, d, state):
		if state not in self.actions:
			self.actions[state] = []
		try:
			return d[state]
		except KeyError:
			is_el = Signal()
			d[state] = is_el
			return is_el

	def before_entering(self, state):
		return self._get_signal(self.before_entering_signals, state)

	def before_leaving(self, state):
		return self._get_signal(self.before_leaving_signals, state)

	def after_entering(self, state):
		signal = self._get_signal(self.after_entering_signals, state)
		self.sync += signal.eq(self.before_entering(state))
		return signal

	def after_leaving(self, state):
		signal = self._get_signal(self.after_leaving_signals, state)
		self.sync += signal.eq(self.before_leaving(state))
		return signal

	def do_finalize(self):
		nstates = len(self.actions)
		if self.reset_state is None:
			reset_state = next(iter(self.actions.keys()))
		else:
			reset_state = self.reset_state

		self.encoding = dict((s, n) for n, s in enumerate(self.actions.keys()))
		self.state = Signal(max=nstates, reset=self.encoding[reset_state])
		self.next_state = Signal(max=nstates)

		lns = _LowerNextState(self.next_state, self.encoding, self.state_aliases)
		cases = dict((self.encoding[k], lns.visit(v)) for k, v in self.actions.items() if v)
		self.comb += [
			self.next_state.eq(self.state),
			Case(self.state, cases)
		]
		self.sync += self.state.eq(self.next_state)

		# drive entering/leaving signals
		for state, signal in self.before_leaving_signals.items():
			encoded = self.encoding[state]
			self.comb += signal.eq((self.state == encoded) & ~(self.next_state == encoded))
		if reset_state in self.after_entering_signals:
			self.after_entering_signals[reset_state].reset = 1
		for state, signal in self.before_entering_signals.items():
			encoded = self.encoding[state]
			self.comb += signal.eq(~(self.state == encoded) & (self.next_state == encoded))

########NEW FILE########
__FILENAME__ = ioo
from migen.util.misc import xdir
from migen.fhdl.std import *
from migen.flow.actor import *
from migen.flow.actor import _Endpoint
from migen.flow.transactions import *
from migen.actorlib.sim import TokenExchanger
from migen.bus import wishbone, memory
from migen.bus.transactions import *

class UnifiedIOObject(Module):
	def do_finalize(self):
		if self.get_dataflow():
			self.busy = Signal()
		self.specials += set(v for k, v in xdir(self, True) if isinstance(v, Memory))

	def get_dataflow(self):
		return dict((k, v) for k, v in xdir(self, True) if isinstance(v, _Endpoint))

	def get_buses(self):
		return dict((k, v) for k, v in xdir(self, True) if isinstance(v, (wishbone.Interface, Memory)))

(_WAIT_COMPLETE, _WAIT_POLL) = range(2)

class UnifiedIOSimulation(UnifiedIOObject):
	def __init__(self, generator):
		self.generator = generator

	def do_finalize(self):
		UnifiedIOObject.do_finalize(self)
		callers = []
		self.busname_to_caller_id = {}
		if self.get_dataflow():
			callers.append(TokenExchanger(self.dispatch_g(0), self))
		for k, v in self.get_buses().items():
			caller_id = len(callers)
			self.busname_to_caller_id[k] = caller_id
			g = self.dispatch_g(caller_id)
			if isinstance(v, wishbone.Interface):
				caller = wishbone.Initiator(g, v)
			elif isinstance(v, Memory):
				caller = memory.Initiator(g, v)
			callers.append(caller)
		self.submodules += callers
		
		self.dispatch_state = _WAIT_COMPLETE
		self.dispatch_caller = 0
		self.pending_transaction = None
	
	def identify_transaction(self, t):
		if isinstance(t, Token):
			return 0
		elif isinstance(t, TRead) or isinstance(t, TWrite):
			if t.busname is None:
				if len(self.busname_to_caller_id) != 1:
					raise TypeError
				else:
					return list(self.busname_to_caller_id.values())[0]
			else:
				return self.busname_to_caller_id[t.busname]
		else:
			raise TypeError
	
	def dispatch_g(self, caller_id):
		while True:
			if self.dispatch_state == _WAIT_COMPLETE and self.dispatch_caller == caller_id:
				transaction = next(self.generator)
				tr_cid = self.identify_transaction(transaction)
				self.dispatch_caller = tr_cid
				if tr_cid == caller_id:
					yield transaction
				else:
					self.pending_transaction = transaction
					self.dispatch_state = _WAIT_POLL
					yield None
			elif self.dispatch_state == _WAIT_POLL and self.dispatch_caller == caller_id:
				self.dispatch_state = _WAIT_COMPLETE
				yield self.pending_transaction
			else:
				yield None

########NEW FILE########
__FILENAME__ = misc
from migen.fhdl.std import *
from migen.fhdl.structure import _Operator

def optree(op, operands, lb=None, ub=None, default=None):
	if lb is None:
		lb = 0
	if ub is None:
		ub = len(operands)
	l = ub - lb
	if l == 0:
		if default is None:
			raise AttributeError
		else:
			return default
	elif l == 1:
		return operands[lb]
	else:
		s = lb + l//2
		return _Operator(op,
			[optree(op, operands, lb, s, default),
			optree(op, operands, s, ub, default)])

def split(v, *counts):
	r = []
	offset = 0
	for n in counts:
		if n != 0:
			r.append(v[offset:offset+n])
		else:
			r.append(None)
		offset += n
	return tuple(r)

def displacer(signal, shift, output, n=None, reverse=False):
	if shift is None:
		return output.eq(signal)
	if n is None:
		n = 2**flen(shift)
	w = flen(signal)
	if reverse:
		r = reversed(range(n))
	else:
		r = range(n)
	l = [Replicate(shift == i, w) & signal for i in r]
	return output.eq(Cat(*l))

def chooser(signal, shift, output, n=None, reverse=False):
	if shift is None:
		return output.eq(signal)
	if n is None:
		n = 2**flen(shift)
	w = flen(output)
	cases = {}
	for i in range(n):
		if reverse:
			s = n - i - 1
		else:
			s = i
		cases[i] = [output.eq(signal[s*w:(s+1)*w])]
	return Case(shift, cases).makedefault()

def timeline(trigger, events):
	lastevent = max([e[0] for e in events])
	counter = Signal(max=lastevent+1)
	
	counterlogic = If(counter != 0,
		counter.eq(counter + 1)
	).Elif(trigger,
		counter.eq(1)
	)
	# insert counter reset if it doesn't naturally overflow
	# (test if lastevent+1 is a power of 2)
	if (lastevent & (lastevent + 1)) != 0:
		counterlogic = If(counter == lastevent,
			counter.eq(0)
		).Else(
			counterlogic
		)
	
	def get_cond(e):
		if e[0] == 0:
			return trigger & (counter == 0)
		else:
			return counter == e[0]
	sync = [If(get_cond(e), *e[1]) for e in events]
	sync.append(counterlogic)
	return sync

########NEW FILE########
__FILENAME__ = record
from migen.fhdl.std import *
from migen.fhdl.tracer import get_obj_var_name
from migen.genlib.misc import optree

(DIR_NONE, DIR_S_TO_M, DIR_M_TO_S) = range(3)

# Possible layout elements:
#   1. (name, size)
#   2. (name, size, direction)
#   3. (name, sublayout)
# size can be an int, or a (int, bool) tuple for signed numbers
# sublayout must be a list

def set_layout_parameters(layout, **layout_dict):
	def resolve(p):
		if isinstance(p, str):
			try:
				return layout_dict[p]
			except KeyError:
				return p
		else:
			return p

	r = []
	for f in layout:
		if isinstance(f[1], (int, tuple, str)): # cases 1/2
			if len(f) == 3:
				r.append((f[0], resolve(f[1]), f[2]))
			else:
				r.append((f[0], resolve(f[1])))
		elif isinstance(f[1], list): # case 3
			r.append((f[0], set_layout_parameters(f[1], **layout_dict)))
		else:
			raise TypeError
	return r

def layout_len(layout):
	r = 0
	for f in layout:
		if isinstance(f[1], (int, tuple)): # cases 1/2
			if len(f) == 3:
				fname, fsize, fdirection = f
			else:
				fname, fsize = f
		elif isinstance(f[1], list): # case 3
			fname, fsublayout = f
			fsize = layout_len(fsublayout)
		else:
			raise TypeError
		if isinstance(fsize, tuple):
			r += fsize[0]
		else:
			r += fsize
	return r

def layout_get(layout, name):
	for f in layout:
		if f[0] == name:
			return f
	raise KeyError(name)

def layout_partial(layout, *elements):
	r = []
	for path in elements:
		path_s = path.split("/")
		last = path_s.pop()
		copy_ref = layout
		insert_ref = r
		for hop in path_s:
			name, copy_ref = layout_get(copy_ref, hop)
			try:
				name, insert_ref = layout_get(insert_ref, hop)
			except KeyError:
				new_insert_ref = []
				insert_ref.append((hop, new_insert_ref))
				insert_ref = new_insert_ref
		insert_ref.append(layout_get(copy_ref, last))
	return r

class Record:
	def __init__(self, layout, name=None):
		self.name = get_obj_var_name(name, "")
		self.layout = layout

		if self.name:
			prefix = self.name + "_"
		else:
			prefix = ""
		for f in self.layout:
			if isinstance(f[1], (int, tuple)): # cases 1/2
				if(len(f) == 3):
					fname, fsize, fdirection = f
				else:
					fname, fsize = f
				finst = Signal(fsize, name=prefix + fname)
			elif isinstance(f[1], list): # case 3
				fname, fsublayout = f
				finst = Record(fsublayout, prefix + fname)
			else:
				raise TypeError
			setattr(self, fname, finst)

	def eq(self, other):
		return [getattr(self, f[0]).eq(getattr(other, f[0]))
		  for f in self.layout if hasattr(other, f[0])]

	def iter_flat(self):
		for f in self.layout:
			e = getattr(self, f[0])
			if isinstance(e, Signal):
				if len(f) == 3:
					yield e, f[2]
				else:
					yield e, DIR_NONE
			elif isinstance(e, Record):
				yield from e.iter_flat()
			else:
				raise TypeError
	
	def flatten(self):
		return [signal for signal, direction in self.iter_flat()]

	def raw_bits(self):
		return Cat(*self.flatten())
	
	def connect(self, *slaves):
		r = []
		for f in self.layout:
			field = f[0]
			self_e = getattr(self, field)
			if isinstance(self_e, Signal):
				direction = f[2]
				if direction == DIR_M_TO_S:
					r += [getattr(slave, field).eq(self_e) for slave in slaves]
				elif direction == DIR_S_TO_M:
					r.append(self_e.eq(optree("|", [getattr(slave, field) for slave in slaves])))
				else:
					raise TypeError
			else:
				for slave in slaves:
					r += self_e.connect(getattr(slave, field))
		return r

	def connect_flat(self, *slaves):
		r = []
		iter_slaves = [slave.iter_flat() for slave in slaves]
		for m_signal, m_direction in self.iter_flat():
			if m_direction == DIR_M_TO_S:
				for iter_slave in iter_slaves:
					s_signal, s_direction = next(iter_slave)
					assert(s_direction == DIR_M_TO_S)
					r.append(s_signal.eq(m_signal))
			elif m_direction == DIR_S_TO_M:
				s_signals = []
				for iter_slave in iter_slaves:
					s_signal, s_direction = next(iter_slave)
					assert(s_direction == DIR_S_TO_M)
					s_signals.append(s_signal)
				r.append(m_signal.eq(optree("|", s_signals)))
			else:
				raise TypeError
		return r

	def __len__(self):
		return layout_len(self.layout)

	def __repr__(self):
		return "<Record " + ":".join(f[0] for f in self.layout) + " at " + hex(id(self)) + ">"

########NEW FILE########
__FILENAME__ = rob
from migen.fhdl.std import *

class ReorderSlot:
	def __init__(self, tag_width, data_width):
		self.wait_data = Signal()
		self.has_data = Signal()
		self.tag = Signal(tag_width)
		self.data = Signal(data_width)

class ReorderBuffer(Module):
	def __init__(self, tag_width, data_width, depth):
		# issue
		self.can_issue = Signal()
		self.issue = Signal()
		self.tag_issue = Signal(tag_width)
		
		# call
		self.call = Signal()
		self.tag_call = Signal(tag_width)
		self.data_call = Signal(data_width)
		
		# readback
		self.can_read = Signal()
		self.read = Signal()
		self.data_read = Signal(data_width)
	
		###

		empty_count = Signal(max=depth+1, reset=depth)
		produce = Signal(max=depth)
		consume = Signal(max=depth)
		slots = Array(ReorderSlot(tag_width, data_width)
			for n in range(depth))

		# issue
		self.comb += self.can_issue.eq(empty_count != 0)
		self.sync += If(self.issue & self.can_issue,
				empty_count.eq(empty_count - 1),
				If(produce == depth - 1,
					produce.eq(0)
				).Else(
					produce.eq(produce + 1)
				),
				slots[produce].wait_data.eq(1),
				slots[produce].tag.eq(self.tag_issue)
			)
		
		# call
		for n, slot in enumerate(slots):
			self.sync += If(self.call & slot.wait_data & (self.tag_call == slot.tag),
					slot.wait_data.eq(0),
					slot.has_data.eq(1),
					slot.data.eq(self.data_call)
				)
		
		# readback
		self.comb += [
			self.can_read.eq(slots[consume].has_data),
			self.data_read.eq(slots[consume].data)
		]
		self.sync += [
			If(self.read & self.can_read,
				empty_count.eq(empty_count + 1),
				If(consume == depth - 1,
					consume.eq(0)
				).Else(
					consume.eq(consume + 1)
				),
				slots[consume].has_data.eq(0)
			)
		]
		
		# do not touch empty count when issuing and reading at the same time
		self.sync += If(self.issue & self.can_issue & self.read & self.can_read,
				empty_count.eq(empty_count)
			)

########NEW FILE########
__FILENAME__ = roundrobin
from migen.fhdl.std import *

(SP_WITHDRAW, SP_CE) = range(2)

class RoundRobin(Module):
	def __init__(self, n, switch_policy=SP_WITHDRAW):
		self.request = Signal(n)
		self.grant = Signal(max=max(2, n))
		self.switch_policy = switch_policy
		if self.switch_policy == SP_CE:
			self.ce = Signal()
	
		###

		if n > 1:
			cases = {}
			for i in range(n):
				switch = []
				for j in reversed(range(i+1,i+n)):
					t = j % n
					switch = [
						If(self.request[t],
							self.grant.eq(t)
						).Else(
							*switch
						)
					]
				if self.switch_policy == SP_WITHDRAW:
					case = [If(~self.request[i], *switch)]
				else:
					case = switch
				cases[i] = case
			statement = Case(self.grant, cases)
			if self.switch_policy == SP_CE:
				statement = If(self.ce, statement)
			self.sync += statement
		else:
			self.comb += self.grant.eq(0)

########NEW FILE########
__FILENAME__ = sort
from migen.fhdl.std import *
from migen.fhdl import verilog

class BitonicSort(Module):
	"""Combinatorial sorting network

	The Bitonic sort is implemented as a combinatorial sort using
	comparators and multiplexers. Its asymptotic complexity (in terms of
	number of comparators/muxes) is O(n log(n)**2), like mergesort or
	shellsort.

	http://www.dps.uibk.ac.at/~cosenza/teaching/gpu/sort-batcher.pdf

	http://www.inf.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm

	http://www.myhdl.org/doku.php/cookbook:bitonic

	Parameters
	----------
	n : int
		Number of inputs and output signals.
	m : int
		Bit width of inputs and outputs. Or a tuple of `(m, signed)`.
	ascending : bool
		Sort direction. `True` if input is to be sorted ascending,
		`False` for descending. Defaults to ascending.

	Attributes
	----------
	i : list of Signals, in
		Input values, each `m` wide.
	o : list of Signals, out
		Output values, sorted, each `m` bits wide.
	"""
	def __init__(self, n, m, ascending=True):
		self.i = [Signal(m) for i in range(n)]
		self.o = [Signal(m) for i in range(n)]
		self._sort(self.i, self.o, int(ascending), m)

	def _sort_two(self, i0, i1, o0, o1, dir):
		self.comb += [
				o0.eq(i0),
				o1.eq(i1),
				If(dir == (i0 > i1),
					o0.eq(i1),
					o1.eq(i0),
				)]

	def _merge(self, i, o, dir, m):
		n = len(i)
		k = n//2
		if n > 1:
			t = [Signal(m) for j in range(n)]
			for j in range(k):
				self._sort_two(i[j], i[j + k], t[j], t[j + k], dir)
			self._merge(t[:k], o[:k], dir, m)
			self._merge(t[k:], o[k:], dir, m)
		else:
			self.comb += o[0].eq(i[0])

	def _sort(self, i, o, dir, m):
		n = len(i)
		k = n//2
		if n > 1:
			t = [Signal(m) for j in range(n)]
			self._sort(i[:k], t[:k], 1, m) # ascending
			self._sort(i[k:], t[k:], 0, m) # descending
			self._merge(t, o, dir, m)
		else:
			self.comb += o[0].eq(i[0])

########NEW FILE########
__FILENAME__ = compiler
import inspect
import ast
from collections import OrderedDict

from migen.util.misc import xdir
from migen.fhdl.structure import *
from migen.fhdl.visit import TransformModule
from migen.fhdl.specials import Memory
from migen.genlib.ioo import UnifiedIOObject
from migen.pytholite.reg import *
from migen.pytholite.expr import *
from migen.pytholite import transel
from migen.pytholite.io import gen_io
from migen.pytholite.util import *

def _is_name_used(node, name):
	for n in ast.walk(node):
		if isinstance(n, ast.Name) and n.id == name:
			return True
	return False

def _make_function_args_dict(undefined, symdict, args, defaults):
	d = OrderedDict()
	for argument in args:
		d[argument.arg] = undefined
	for default, argname in zip(defaults, reversed(list(d.keys()))):
		default_val = eval_ast(default, symdict)
		d[argname] = default_val
	return d

def _process_function_args(symdict, function_def, args, kwargs):
	defargs = function_def.args
	undefined = object()

	ad_positional = _make_function_args_dict(undefined, symdict, defargs.args, defargs.defaults)
	vararg_name = defargs.vararg
	kwarg_name = defargs.kwarg
	ad_kwonly = _make_function_args_dict(undefined, symdict, defargs.kwonlyargs, defargs.kw_defaults)

	# grab argument values
	current_argvalue = iter(args)
	try:
		for argname in ad_positional.keys():
			ad_positional[argname] = next(current_argvalue)
	except StopIteration:
		pass
	vararg = tuple(current_argvalue)

	kwarg = dict()
	for k, v in kwargs.items():
		if k in ad_positional:
			ad_positional[k] = v
		elif k in ad_kwonly:
			ad_kwonly[k] = v
		else:
			kwarg[k] = v

	# check
	undefined_pos = [k for k, v in ad_positional.items() if v is undefined]
	if undefined_pos:
		formatted = " and ".join("'" + k + "'" for k in undefined_pos)
		raise TypeError("Missing required positional arguments: " + formatted)
	if vararg and vararg_name is None:
		raise TypeError("Function takes {} positional arguments but {} were given".format(len(ad_positional),
			len(ad_positional) + len(vararg)))
	ad_kwonly = [k for k, v in ad_positional.items() if v is undefined]
	if undefined_pos:
		formatted = " and ".join("'" + k + "'" for k in undefined_pos)
		raise TypeError("Missing required keyword-only arguments: " + formatted)
	if kwarg and kwarg_name is None:
		formatted = " and ".join("'" + k + "'" for k in kwarg.keys())
		raise TypeError("Got unexpected keyword arguments: " + formatted)

	# update symdict
	symdict.update(ad_positional)
	if vararg_name is not None:
		symdict[vararg_name] = vararg
	symdict.update(ad_kwonly)
	if kwarg_name is not None:
		symdict[kwarg_name] = kwarg

class _Compiler:
	def __init__(self, ioo, symdict, registers):
		self.ioo = ioo
		self.symdict = symdict
		self.registers = registers
		self.ec = ExprCompiler(self.symdict)
	
	def visit_top(self, node, args, kwargs):
		if isinstance(node, ast.Module) \
		  and len(node.body) == 1 \
		  and isinstance(node.body[0], ast.FunctionDef):
			function_def = node.body[0]
			_process_function_args(self.symdict, function_def, args, kwargs)
			states, exit_states = self.visit_block(function_def.body)
			return states
		else:
			raise NotImplementedError
	
	# blocks and statements
	def visit_block(self, statements):
		sa = StateAssembler()
		statements = iter(statements)
		statement = None
		while True:
			if statement is None:
				try:
					statement = next(statements)
				except StopIteration:
					return sa.ret()
			if isinstance(statement, ast.Assign):
				# visit_assign can recognize a I/O pattern, consume several
				# statements from the iterator and return the first statement
				# that is not part of the I/O pattern anymore.
				statement = self.visit_assign(sa, statement, statements)
			else:
				if isinstance(statement, ast.If):
					self.visit_if(sa, statement)
				elif isinstance(statement, ast.While):
					self.visit_while(sa, statement)
				elif isinstance(statement, ast.For):
					self.visit_for(sa, statement)
				elif isinstance(statement, ast.Expr):
					self.visit_expr_statement(sa, statement)
				else:
					raise NotImplementedError
				statement = None
	
	def visit_assign(self, sa, node, statements):
		if isinstance(node.value, ast.Call):
			is_special = False
			try:
				value = self.ec.visit_expr_call(node.value)
			except NotImplementedError:
				is_special = True
			if is_special:
				return self.visit_assign_special(sa, node, statements)
		else:
			value = self.ec.visit_expr(node.value)
		if isinstance(value, (int, bool, Value)):
			r = []
			for target in node.targets:
				if isinstance(target, ast.Attribute) and target.attr == "store":
					treg = target.value
					if isinstance(treg, ast.Name):
						r.append(self.symdict[treg.id].load(value))
					else:
						raise NotImplementedError
				else:
					raise NotImplementedError
			sa.assemble([r], [r])
		else:
			raise NotImplementedError
	
	def visit_assign_special(self, sa, node, statements):
		value = node.value
		assert(isinstance(value, ast.Call))
		if isinstance(value.func, ast.Name):
			callee = self.symdict[value.func.id]
		else:
			raise NotImplementedError
		
		if callee == transel.Register:
			if len(value.args) != 1:
				raise TypeError("Register() takes exactly 1 argument")
			bits_sign = eval_ast(value.args[0], self.symdict)
			if isinstance(node.targets[0], ast.Name):
				targetname = node.targets[0].id
			else:
				targetname = "unk"
			reg = ImplRegister(targetname, bits_sign)
			self.registers.append(reg)
			for target in node.targets:
				if isinstance(target, ast.Name):
					self.symdict[target.id] = reg
				else:
					raise NotImplementedError
		else:
			return self.visit_io_pattern(sa, node.targets, callee, value.args, value.keywords, statements)
	
	def visit_io_pattern(self, sa, targets, model, args, keywords, statements):
		# first statement is <modelname> = <model>(<args>)
		if len(targets) != 1 or not isinstance(targets[0], ast.Name):
			raise NotImplementedError("Unrecognized I/O pattern")
		modelname = targets[0].id
		if modelname in self.symdict:
			raise NotImplementedError("I/O model name is not free")
		
		# second statement must be yield <modelname>
		try:
			ystatement = next(statements)
		except StopIteration:
			raise NotImplementedError("Incomplete or fragmented I/O pattern")
		if not isinstance(ystatement, ast.Expr) \
		  or not isinstance(ystatement.value, ast.Yield) \
		  or not isinstance(ystatement.value.value, ast.Name) \
		  or ystatement.value.value.id != modelname:
			print(ast.dump(ystatement))
			raise NotImplementedError("Unrecognized I/O pattern")
		
		# following optional statements are assignments to registers
		# with <modelname> used in expressions.
		from_model = []
		while True:
			try:
				fstatement = next(statements)
			except StopIteration:
				fstatement = None
			if not isinstance(fstatement, ast.Assign) \
			  or not _is_name_used(fstatement.value, modelname):
				break
			tregs = []
			for target in fstatement.targets:
				if isinstance(target, ast.Attribute) and target.attr == "store":
					if isinstance(target.value, ast.Name):
						tregs.append(self.symdict[target.value.id])
					else:
						raise NotImplementedError
				else:
					raise NotImplementedError
			from_model.append((tregs, fstatement.value))
		
		states, exit_states = gen_io(self, modelname, model, args, keywords, from_model)
		sa.assemble(states, exit_states)
		return fstatement
	
	def visit_if(self, sa, node):
		test = self.ec.visit_expr(node.test)
		states_t, exit_states_t = self.visit_block(node.body)
		states_f, exit_states_f = self.visit_block(node.orelse)
		exit_states = exit_states_t + exit_states_f
		
		test_state_stmt = If(test, id_next_state(states_t[0]))
		test_state = [test_state_stmt]
		if states_f:
			test_state_stmt.Else(id_next_state(states_f[0]))
		else:
			exit_states.append(test_state)
		
		sa.assemble([test_state] + states_t + states_f,
			exit_states)
	
	def visit_while(self, sa, node):
		test = self.ec.visit_expr(node.test)
		states_b, exit_states_b = self.visit_block(node.body)

		test_state = [If(test, id_next_state(states_b[0]))]
		for exit_state in exit_states_b:
			exit_state.insert(0, id_next_state(test_state))
		
		sa.assemble([test_state] + states_b, [test_state])
	
	def visit_for(self, sa, node):
		if not isinstance(node.target, ast.Name):
			raise NotImplementedError
		target = node.target.id
		if target in self.symdict:
			raise NotImplementedError("For loop target must use an available name")
		it = self.visit_iterator(node.iter)
		states = []
		last_exit_states = []
		for iteration in it:
			self.symdict[target] = iteration
			states_b, exit_states_b = self.visit_block(node.body)
			for exit_state in last_exit_states:
				exit_state.insert(0, id_next_state(states_b[0]))
			last_exit_states = exit_states_b
			states += states_b
		del self.symdict[target]
		sa.assemble(states, last_exit_states)
	
	def visit_iterator(self, node):
		return eval_ast(node, self.symdict)

	def visit_expr_statement(self, sa, node):
		if isinstance(node.value, ast.Yield):
			yvalue = node.value.value
			if not isinstance(yvalue, ast.Call) or not isinstance(yvalue.func, ast.Name):
				raise NotImplementedError("Unrecognized I/O pattern")
			callee = self.symdict[yvalue.func.id]
			states, exit_states = gen_io(self, None, callee, yvalue.args, yvalue.keywords, [])
			sa.assemble(states, exit_states)
		else:
			raise NotImplementedError

class Pytholite(UnifiedIOObject):
	def __init__(self, func, *args, **kwargs):
		self.func = func
		self.args = args
		self.kwargs = kwargs

	def do_finalize(self):
		UnifiedIOObject.do_finalize(self)
		if self.get_dataflow():
			self.busy.reset = 1
		self.memory_ports = dict()
		for key in xdir(self):
			mem = getattr(self, key)
			if isinstance(mem, Memory):
				port = mem.get_port(write_capable=True, we_granularity=8)
				self.specials += port
				self.memory_ports[mem] = port
		self._compile()

	def _compile(self):
		tree = ast.parse(inspect.getsource(self.func))
		symdict = self.func.__globals__.copy()
		registers = []
		
		states = _Compiler(self, symdict, registers).visit_top(tree, self.args, self.kwargs)
		
		for register in registers:
			if register.source_encoding:
				register.finalize()
				self.submodules += register
		
		fsm = implement_fsm(states)
		self.submodules += TransformModule(LowerAbstractLoad().visit, fsm)

########NEW FILE########
__FILENAME__ = expr
import ast

from migen.fhdl.structure import *
from migen.fhdl.structure import _Slice
from migen.pytholite import transel
from migen.pytholite.reg import *
from migen.pytholite.util import eval_ast

class ExprCompiler:
	def __init__(self, symdict):
		self.symdict = symdict
	
	def visit_expr(self, node):
		# Attempt compile-time evaluation first
		try:
			result = eval_ast(node, self.symdict)
		except:
			result = None
		if isinstance(result, int):
			return result

		if isinstance(node, ast.Call):
			return self.visit_expr_call(node)
		elif isinstance(node, ast.BinOp):
			return self.visit_expr_binop(node)
		elif isinstance(node, ast.Compare):
			return self.visit_expr_compare(node)
		elif isinstance(node, ast.Name):
			return self.visit_expr_name(node)
		elif isinstance(node, ast.Num):
			return self.visit_expr_num(node)
		elif isinstance(node, ast.Attribute):
			return self.visit_expr_attribute(node)
		elif isinstance(node, ast.Subscript):
			return self.visit_expr_subscript(node)
		else:
			raise NotImplementedError
	
	def visit_expr_call(self, node):
		if isinstance(node.func, ast.Name):
			callee = self.symdict[node.func.id]
		else:
			raise NotImplementedError
		if callee == transel.bitslice:
			if len(node.args) != 2 and len(node.args) != 3:
				raise TypeError("bitslice() takes 2 or 3 arguments")
			val = self.visit_expr(node.args[0])
			low = eval_ast(node.args[1], self.symdict)
			if len(node.args) == 3:
				up = eval_ast(node.args[2], self.symdict)
			else:
				up = low + 1
			return _Slice(val, low, up)
		else:
			raise NotImplementedError
	
	def visit_expr_binop(self, node):
		left = self.visit_expr(node.left)
		right = self.visit_expr(node.right)
		if isinstance(node.op, ast.Add):
			return left + right
		elif isinstance(node.op, ast.Sub):
			return left - right
		elif isinstance(node.op, ast.Mult):
			return left * right
		elif isinstance(node.op, ast.LShift):
			return left << right
		elif isinstance(node.op, ast.RShift):
			return left >> right
		elif isinstance(node.op, ast.BitOr):
			return left | right
		elif isinstance(node.op, ast.BitXor):
			return left ^ right
		elif isinstance(node.op, ast.BitAnd):
			return left & right
		else:
			raise NotImplementedError
	
	def visit_expr_compare(self, node):
		test = self.visit_expr(node.left)
		r = None
		for op, rcomparator in zip(node.ops, node.comparators):
			comparator = self.visit_expr(rcomparator)
			if isinstance(op, ast.Eq):
				comparison = test == comparator
			elif isinstance(op, ast.NotEq):
				comparison = test != comparator
			elif isinstance(op, ast.Lt):
				comparison = test < comparator
			elif isinstance(op, ast.LtE):
				comparison = test <= comparator
			elif isinstance(op, ast.Gt):
				comparison = test > comparator
			elif isinstance(op, ast.GtE):
				comparison = test >= comparator
			else:
				raise NotImplementedError
			if r is None:
				r = comparison
			else:
				r = r & comparison
			test = comparator
		return r
	
	def visit_expr_name(self, node):
		if node.id == "True":
			return 1
		if node.id == "False":
			return 0
		r = self.symdict[node.id]
		if isinstance(r, ImplRegister):
			r = r.storage
		return r
	
	def visit_expr_num(self, node):
		return node.n
	
	def visit_expr_attribute(self, node):
		raise NotImplementedError
	
	def visit_expr_subscript(self, node):
		raise NotImplementedError

########NEW FILE########
__FILENAME__ = io
import ast
from itertools import zip_longest

from migen.fhdl.std import *
from migen.flow.actor import Source, Sink
from migen.flow.transactions import *
from migen.bus import wishbone
from migen.bus.transactions import *
from migen.pytholite.util import *
from migen.pytholite.expr import ExprCompiler

class _TokenPullExprCompiler(ExprCompiler):
	def __init__(self, symdict, modelname, ep):
		ExprCompiler.__init__(self, symdict)
		self.modelname = modelname
		self.ep = ep
	
	def visit_expr_subscript(self, node):
		# check that we are subscripting <modelname>.value
		if not isinstance(node.value, ast.Attribute) \
		  or node.value.attr != "value" \
		  or not isinstance(node.value.value, ast.Name) \
		  or node.value.value.id != self.modelname:
			raise NotImplementedError
		
		if not isinstance(node.slice, ast.Index):
			raise NotImplementedError
		field = eval_ast(node.slice.value, self.symdict)
		signal = getattr(self.ep.payload, field)
		
		return signal

def _gen_df_io(compiler, modelname, to_model, from_model):
	epname = eval_ast(to_model["endpoint"], compiler.symdict)
	values = to_model["value"]
	idle_wait = eval_ast(to_model["idle_wait"], compiler.symdict)
	ep = getattr(compiler.ioo, epname)
	if idle_wait:
		state = [compiler.ioo.busy.eq(0)]
	else:
		state = []
	
	if isinstance(values, ast.Name) and values.id == "None":
		# token pull from sink
		if not isinstance(ep, Sink):
			raise TypeError("Attempted to pull from source")
		ec = _TokenPullExprCompiler(compiler.symdict, modelname, ep)
		for target_regs, expr in from_model:
			cexpr = ec.visit_expr(expr)
			state += [reg.load(cexpr) for reg in target_regs]
		state += [
			ep.ack.eq(1),
			If(~ep.stb, id_next_state(state))
		]
		return [state], [state]
	else:
		# token push to source
		if not isinstance(ep, Source):
			raise TypeError("Attempted to push to sink")
		if from_model:
			raise TypeError("Attempted to read from pushed token")
		if not isinstance(values, ast.Dict):
			raise NotImplementedError
		for akey, value in zip(values.keys, values.values):
			key = eval_ast(akey, compiler.symdict)
			signal = getattr(ep.payload, key)
			state.append(signal.eq(compiler.ec.visit_expr(value)))
		state += [
			ep.stb.eq(1),
			If(~ep.ack, id_next_state(state))
		]
		return [state], [state]

class _BusReadExprCompiler(ExprCompiler):
	def __init__(self, symdict, modelname, data_signal):
		ExprCompiler.__init__(self, symdict)
		self.modelname = modelname
		self.data_signal = data_signal
	
	def visit_expr_attribute(self, node):
		# recognize <modelname>.data as the bus read signal, raise exception otherwise
		if not isinstance(node.value, ast.Name) \
		  or node.value.id != self.modelname \
		  or node.attr != "data":
			raise NotImplementedError
		return self.data_signal

def _gen_wishbone_io(compiler, modelname, model, to_model, from_model, bus):
	state = [
		bus.cyc.eq(1),
		bus.stb.eq(1),
		bus.adr.eq(compiler.ec.visit_expr(to_model["address"])),
	]
	
	if model == TWrite:
		if from_model:
			raise TypeError("Attempted to read from write transaction")
		state += [
			bus.we.eq(1),
			bus.dat_w.eq(compiler.ec.visit_expr(to_model["data"]))
		]
		sel = to_model["sel"]
		if isinstance(sel, ast.Name) and sel.id == "None":
			nbytes = (flen(bus.dat_w) + 7)//8
			state.append(bus.sel.eq(2**nbytes-1))
		else:
			state.append(bus.sel.eq(compiler.ec.visit_expr(sel)))
	else:
		ec = _BusReadExprCompiler(compiler.symdict, modelname, bus.dat_r)
		for target_regs, expr in from_model:
			cexpr = ec.visit_expr(expr)
			state += [reg.load(cexpr) for reg in target_regs]
	state.append(If(~bus.ack, id_next_state(state)))
	return [state], [state]

def _gen_memory_io(compiler, modelname, model, to_model, from_model, port):
	s1 = [port.adr.eq(compiler.ec.visit_expr(to_model["address"]))]
	if model == TWrite:
		if from_model:
			raise TypeError("Attempted to read from write transaction")
		s1.append(port.dat_w.eq(compiler.ec.visit_expr(to_model["data"])))
		sel = to_model["sel"]
		if isinstance(sel, ast.Name) and sel.id == "None":
			nbytes = (flen(port.dat_w) + 7)//8
			s1.append(port.we.eq(2**nbytes-1))
		else:
			s1.append(port.we.eq(compiler.ec.visit_expr(sel)))
		return [s1], [s1]
	else:
		s2 = []
		s1.append(id_next_state(s2))
		ec = _BusReadExprCompiler(compiler.symdict, modelname, port.dat_r)
		for target_regs, expr in from_model:
			cexpr = ec.visit_expr(expr)
			s2 += [reg.load(cexpr) for reg in target_regs]
		return [s1, s2], [s2]

def _gen_bus_io(compiler, modelname, model, to_model, from_model):
	busname = eval_ast(to_model["busname"], compiler.symdict)
	if busname is None:
		buses = compiler.ioo.get_buses()
		if len(buses) != 1:
			raise TypeError("Bus name not specified")
		bus = list(buses.values())[0]
	else:
		bus = getattr(compiler.ioo, busname)
	if isinstance(bus, wishbone.Interface):
		return _gen_wishbone_io(compiler, modelname, model, to_model, from_model, bus)
	elif isinstance(bus, Memory):
		port = compiler.ioo.memory_ports[bus]
		return _gen_memory_io(compiler, modelname, model, to_model, from_model, port)
	else:
		raise NotImplementedError("Unsupported bus")

def _decode_args(desc, args, args_kw):
	d = {}
	argnames = set()
	for param, value in zip_longest(desc, args):
		if param is None:
			raise TypeError("Too many arguments")
		if isinstance(param, tuple):
			name, default = param
		else:
			name, default = param, None
		
		# build the set of argument names at the same time
		argnames.add(name)
		
		if value is None:
			if default is None:
				raise TypeError("No default value for parameter " + name)
			else:
				d[name] = default
		else:
			d[name] = value
	for akw in args_kw:
		if akw.arg not in argnames:
			raise TypeError("Parameter " + akw.arg + " does not exist")
		d[akw.arg] = akw.value
	return d

def gen_io(compiler, modelname, model, to_model, to_model_kw, from_model):
	if model == Token:
		desc = [
			"endpoint",
			("value", ast.Name("None", ast.Load(), lineno=0, col_offset=0)),
			("idle_wait", ast.Name("False", ast.Load(), lineno=0, col_offset=0))
		]
		args = _decode_args(desc, to_model, to_model_kw)
		return _gen_df_io(compiler, modelname, args, from_model)
	elif model == TRead or model == TWrite:
		desc = [
			"address",
			("data", ast.Num(0)),
			("sel", ast.Name("None", ast.Load(), lineno=0, col_offset=0)),
			("busname", ast.Name("None", ast.Load(), lineno=0, col_offset=0))
		]
		args = _decode_args(desc, to_model, to_model_kw)
		return _gen_bus_io(compiler, modelname, model, args, from_model)
	else:
		raise NotImplementedError

########NEW FILE########
__FILENAME__ = reg
from operator import itemgetter

from migen.fhdl.std import *
from migen.fhdl import visit as fhdl

class AbstractLoad:
	def __init__(self, target, source):
		self.target = target
		self.source = source
	
	def lower(self):
		if not self.target.finalized:
			raise FinalizeError
		return self.target.sel.eq(self.target.source_encoding[id(self.source)])

class LowerAbstractLoad(fhdl.NodeTransformer):
	def visit_unknown(self, node):
		if isinstance(node, AbstractLoad):
			return node.lower()
		else:
			return node

class ImplRegister(Module):
	def __init__(self, name, bits_sign):
		self.name = name
		self.storage = Signal(bits_sign, name=self.name)
		self.source_encoding = {}
		self.id_to_source = {}
	
	def load(self, source):
		if id(source) not in self.source_encoding:
			self.source_encoding[id(source)] = len(self.source_encoding) + 1
			self.id_to_source[id(source)] = source
		return AbstractLoad(self, source)
	
	def do_finalize(self):
		self.sel = Signal(max=len(self.source_encoding)+1, name="pl_regsel_"+self.name)
		# do nothing when sel == 0
		items = sorted(self.source_encoding.items(), key=itemgetter(1))
		cases = dict((v, self.storage.eq(self.id_to_source[k])) for k, v in items)
		self.sync += Case(self.sel, cases)

########NEW FILE########
__FILENAME__ = transel
import operator

def bitslice(val, low, up=None):
	if up is None:
		up = low + 1
	nbits = up - low
	mask = (2**nbits - 1) << low
	return (val & mask) >> low

class Register:
	def __init__(self, bits_sign):
		if isinstance(bits_sign, tuple):
			self._nbits, self._signed = bits_sign
		else:
			self._nbits, self._signed = bits_sign, False
		self._val = 0
	
	def _set_store(self, val):
		if self._signed:
			sbw = 2**(self._nbits - 1)
			self._val = val & (sbw - 1)
			if val & sbw:
				self._val -= sbw
		else:
			self._val = val & (2**self._nbits - 1)
	store = property(None, _set_store)

	def __nonzero__(self):
		if self._val:
			return 1
		else:
			return 0

	def __len__(self):
		return self._nbits

	def __add__(self, other):
		if isinstance(other, Register):
			return self._val + other._val
		else:
			return self._val + other
	def __radd__(self, other):
		return other + self._val

	def __sub__(self, other):
		if isinstance(other, Register):
			return self._val - other._val
		else:
			return self._val - other
	def __rsub__(self, other):
		return other - self._val

	def __mul__(self, other):
		if isinstance(other, Register):
			return self._val * other._val
		else:
			return self._val * other
	def __rmul__(self, other):
		return other * self._val

	def __div__(self, other):
		if isinstance(other, Register):
			return self._val / other._val
		else:
			return self._val / other
	def __rdiv__(self, other):
		return other / self._val

	def __truediv__(self, other):
		if isinstance(other, Register):
			return operator.truediv(self._val, other._val)
		else:
			return operator.truediv(self._val, other)
	def __rtruediv__(self, other):
		return operator.truediv(other, self._val)

	def __floordiv__(self, other):
		if isinstance(other, Register):
			return self._val // other._val
		else:
			return self._val // other
	def __rfloordiv__(self, other):
		return other //  self._val

	def __mod__(self, other):
		if isinstance(other, Register):
			return self._val % other._val
		else:
			return self._val % other
	def __rmod__(self, other):
		return other % self._val

	def __pow__(self, other):
		if isinstance(other, Register):
			return self._val ** other._val
		else:
			return self._val ** other
	def __rpow__(self, other):
		return other ** self._val

	def __lshift__(self, other):
		if isinstance(other, Register):
			return self._val << other._val
		else:
			return self._val << other
	def __rlshift__(self, other):
		return other << self._val
		
	def __rshift__(self, other):
		if isinstance(other, Register):
			return self._val >> other._val
		else:
			return self._val >> other
	def __rrshift__(self, other):
		return other >> self._val

	def __and__(self, other):
		if isinstance(other, Register):
			return self._val & other._val
		else:
			return self._val & other
	def __rand__(self, other):
		return other & self._val

	def __or__(self, other):
		if isinstance(other, Register):
			return self._val | other._val
		else:
			return self._val | other
	def __ror__(self, other):
		return other | self._val

	def __xor__(self, other):
		if isinstance(other, Register):
			return self._val ^ other._val
		else:
			return self._val ^ other
	def __rxor__(self, other):
		return other ^ self._val

	def __neg__(self):
		return -self._val

	def __pos__(self):
		return +self._val

	def __abs__(self):
		return abs(self._val)

	def __invert__(self):
		return ~self._val

	def __int__(self):
		return int(self._val)

	def __float__(self):
		return float(self._val)

	def __oct__(self):
		return oct(self._val)

	def __hex__(self):
		return hex(self._val)

	def __index__(self):
		return int(self._val)

	def __lt__(self, other):
		return self._val < other

	def __le__(self, other):
		return self._val <= other

	def __eq__(self, other):
		return self._val == other

	def __ge__(self, other):
		return self._val >= other

	def __gt__(self, other):
		return self._val > other

	def __ne__(self, other):
		return self._val != other

	def __str__(self):
		return str(self._val)

	def __repr__(self):
		return "Register(" + repr(self._val) + ")"

	def _augm(self, other):
		raise TypeError("Register objects do not support augmented assignment")
	__iadd__ = __isub__ = __idiv__ = __imul__ = __ipow__ = __imod__ = _augm
	__ior__ = __iand__ = __ixor__ = __irshift__ = __ilshift__ = _augm

	def __setitem__(self, key, val):
		raise TypeError("Register objects do not support item/slice assignment")

########NEW FILE########
__FILENAME__ = util
import ast

from migen.genlib.fsm import FSM, NextState

def id_next_state(l):
	return NextState(id(l))

# entry state is first state returned
class StateAssembler:
	def __init__(self):
		self.states = []
		self.exit_states = []
	
	def assemble(self, n_states, n_exit_states):
		self.states += n_states
		for exit_state in self.exit_states:
			exit_state.insert(0, id_next_state(n_states[0]))
		self.exit_states = n_exit_states
	
	def ret(self):
		return self.states, self.exit_states

def implement_fsm(states):
	fsm = FSM()
	for state in states:
		fsm.act(id(state), state)
	return fsm

def eval_ast(expr, symdict):
	if not isinstance(expr, ast.Expression):
		expr = ast.Expression(expr)
	code = compile(expr, "<ast>", "eval")
	return eval(code, symdict)

########NEW FILE########
__FILENAME__ = generic
import warnings

from migen.fhdl.std import *
from migen.fhdl.structure import _Fragment
from migen.fhdl import verilog
from migen.sim.ipc import *
from migen.sim import icarus

class TopLevel:
	def __init__(self, vcd_name=None, vcd_level=1,
	  top_name="top", dut_type="dut", dut_name="dut",
	  cd_name="sys", clk_period=10):
		self.vcd_name = vcd_name
		self.vcd_level = vcd_level
		self.top_name = top_name
		self.dut_type = dut_type
		self.dut_name = dut_name
		
		self._cd_name = cd_name
		self._clk_period = clk_period
		
		cd = ClockDomain(self._cd_name)
		self.clock_domains = [cd]
		self.ios = {cd.clk, cd.rst}
	
	def get(self, sockaddr):
		template1 = """`timescale 1ns / 1ps

module {top_name}();

reg {clk_name};
reg {rst_name};

initial begin
	{rst_name} <= 1'b1;
	@(posedge {clk_name});
	{rst_name} <= 1'b0;
end

always begin
	{clk_name} <= 1'b0;
	#{hclk_period};
	{clk_name} <= 1'b1;
	#{hclk_period};
end

{dut_type} {dut_name}(
	.{rst_name}({rst_name}),
	.{clk_name}({clk_name})
);

initial $migensim_connect("{sockaddr}");
always @(posedge {clk_name}) $migensim_tick;
"""
		template2 = """
initial begin
	$dumpfile("{vcd_name}");
	$dumpvars({vcd_level}, {dut_name});
end
"""
		r = template1.format(top_name=self.top_name,
			dut_type=self.dut_type,
			dut_name=self.dut_name,
			clk_name=self._cd_name + "_clk",
			rst_name=self._cd_name + "_rst",
			hclk_period=str(self._clk_period/2),
			sockaddr=sockaddr)
		if self.vcd_name is not None:
			r += template2.format(vcd_name=self.vcd_name,
				vcd_level=str(self.vcd_level),
				dut_name=self.dut_name)
		r += "\nendmodule"
		return r

class Simulator:
	def __init__(self, fragment, top_level=None, sim_runner=None, sockaddr="simsocket", **vopts):
		if not isinstance(fragment, _Fragment):
			fragment = fragment.get_fragment()
		if top_level is None:
			top_level = TopLevel()
		if sim_runner is None:
			sim_runner = icarus.Runner()
		self.top_level = top_level
		self.ipc = Initiator(sockaddr)
		self.sim_runner = sim_runner
		
		c_top = self.top_level.get(sockaddr)
		
		fragment = fragment + _Fragment(clock_domains=top_level.clock_domains)
		c_fragment, self.namespace = verilog.convert(fragment,
			ios=self.top_level.ios,
			name=self.top_level.dut_type,
			return_ns=True,
			**vopts)
		
		self.cycle_counter = -1

		self.sim_runner = sim_runner
		self.sim_runner.start(c_top, c_fragment)
		self.ipc.accept()
		reply = self.ipc.recv()
		assert(isinstance(reply, MessageTick))

		self.sim_functions = fragment.sim
		self.active_sim_functions = set(f for f in fragment.sim if not hasattr(f, "passive") or not f.passive)
	
	def run(self, ncycles=None):
		counter = 0

		if self.active_sim_functions:
			if ncycles is None:
				def continue_simulation():
					return bool(self.active_sim_functions)
			else:
				def continue_simulation():
					return self.active_sim_functions and counter < ncycles
		else:
			if ncycles is None:
				raise ValueError("No active simulation function present - must specify ncycles to end simulation")
			def continue_simulation():
				return counter < ncycles

		while continue_simulation():
			self.cycle_counter += 1
			counter += 1
			self.ipc.send(MessageGo())
			reply = self.ipc.recv()
			assert(isinstance(reply, MessageTick))

			del_list = []
			for s in self.sim_functions:
				try:
					s(self)
				except StopSimulation:
					del_list.append(s)
			for s in del_list:
				self.sim_functions.remove(s)
				try:
					self.active_sim_functions.remove(s)
				except KeyError:
					pass

	def rd(self, item, index=0):
		name = self.top_level.top_name + "." \
		  + self.top_level.dut_name + "." \
		  + self.namespace.get_name(item)
		self.ipc.send(MessageRead(name, Int32(index)))
		reply = self.ipc.recv()
		assert(isinstance(reply, MessageReadReply))
		if isinstance(item, Memory):
			signed = False
			nbits = item.width
		else:
			signed = item.signed
			nbits = flen(item)
		value = reply.value & (2**nbits - 1)
		if signed and (value & 2**(nbits - 1)):
			value -= 2**nbits
		return value
	
	def wr(self, item, value, index=0):
		name = self.top_level.top_name + "." \
		  + self.top_level.dut_name + "." \
		  + self.namespace.get_name(item)
		if isinstance(item, Memory):
			nbits = item.width
		else:
			nbits = flen(item)
		if value < 0:
			value += 2**nbits
		assert(value >= 0 and value < 2**nbits)
		self.ipc.send(MessageWrite(name, Int32(index), value))
	
	def __del__(self):
		if hasattr(self, "ipc"):
			warnings.warn("call Simulator.close() to clean up "
					"or use it as a contextmanager", DeprecationWarning)
			self.close()

	def close(self):
		self.ipc.close()
		self.sim_runner.close()
		del self.ipc
		del self.sim_runner

	def __enter__(self):
		return self

	def __exit__(self, type, value, traceback):
		self.close()

def run_simulation(fragment, ncycles=None, vcd_name=None, keep_files=False):
	with Simulator(fragment, TopLevel(vcd_name), icarus.Runner(keep_files=keep_files)) as s:
		s.run(ncycles)

########NEW FILE########
__FILENAME__ = icarus
# Copyright (C) 2012 Vermeer Manufacturing Co.
# License: GPLv3 with additional permissions (see README).

import subprocess
import os
import time

def _str2file(filename, contents):
	f = open(filename, "w")
	f.write(contents)
	f.close()

class Runner:
	def __init__(self, options=None, extra_files=None, top_file="migensim_top.v", dut_file="migensim_dut.v", vvp_file=None, keep_files=False):
		if extra_files is None: extra_files = []
		if vvp_file is None: vvp_file = dut_file + "vp"
		if options is None: options = []
		self.options = options
		self.extra_files = extra_files
		self.top_file = top_file
		self.dut_file = dut_file
		self.vvp_file = vvp_file
		self.keep_files = keep_files
	
	def start(self, c_top, c_dut):
		_str2file(self.top_file, c_top)
		_str2file(self.dut_file, c_dut)
		subprocess.check_call(["iverilog", "-o", self.vvp_file] + self.options + [self.top_file, self.dut_file] + self.extra_files)
		self.process = subprocess.Popen(["vvp", "-mmigensim", self.vvp_file])

	def close(self):
		if hasattr(self, "process"):
			self.process.terminate()
			if self.process.poll() is None:
				time.sleep(.1)
				self.process.kill()
			self.process.wait()
		if not self.keep_files:
			for f in [self.top_file, self.dut_file, self.vvp_file]:
				try:
					os.remove(f)
				except OSError:
					pass

########NEW FILE########
__FILENAME__ = ipc
# Copyright (C) 2012 Vermeer Manufacturing Co.
# License: GPLv3 with additional permissions (see README).

import socket
import os

#
# Message classes
#

class Int32(int):
	pass

class Message:
	def __init__(self, *pvalues):
		for parameter, value in zip(self.parameters, pvalues):
			setattr(self, parameter[1], parameter[0](value))
	
	def __str__(self):
		p = []
		for parameter in self.parameters:
			p.append(parameter[1] + "=" + str(getattr(self, parameter[1])))
		if p:
			pf = " " + " ".join(p)
		else:
			pf = ""
		return "<" + self.__class__.__name__ + pf + ">"

class MessageTick(Message):
	code = 0
	parameters = []

class MessageGo(Message):
	code = 1
	parameters = []

class MessageWrite(Message):
	code = 2
	parameters = [(str, "name"), (Int32, "index"), (int, "value")]

class MessageRead(Message):
	code = 3
	parameters = [(str, "name"), (Int32, "index")]

class MessageReadReply(Message):
	code = 4
	parameters = [(int, "value")]

message_classes = [MessageTick, MessageGo, MessageWrite, MessageRead, MessageReadReply]

#
# Packing
#

def _pack_int(v):
	if v == 0:
		p = [1, 0]
	else:
		p = []
		while v != 0:
			p.append(v & 0xff)
			v >>= 8
		p.insert(0, len(p))
	return p

def _pack_str(v):
	p = [ord(c) for c in v]
	p.append(0)
	return p

def _pack_int32(v):
	return [
		v & 0xff,
		(v & 0xff00) >> 8,
		(v & 0xff0000) >> 16,
		(v & 0xff000000) >> 24
	]

def _pack(message):
	r = [message.code]
	for t, p in message.parameters:
		value = getattr(message, p)
		assert(isinstance(value, t))
		if t == int:
			r += _pack_int(value)
		elif t == str:
			r += _pack_str(value)
		elif t == Int32:
			r += _pack_int32(value)
		else:
			raise TypeError
	return bytes(r)

#
# Unpacking
#

def _unpack_int(i, nchunks=None):
	v = 0
	power = 1
	if nchunks is None:
		nchunks = next(i)
	for j in range(nchunks):
		v += power*next(i)
		power *= 256
	return v

def _unpack_str(i):
	v = ""
	c = next(i)
	while c:
		v += chr(c)
		c = next(i)
	return v

def _unpack(message):
	i = iter(message)
	code = next(i)
	msgclass = next(filter(lambda x: x.code == code, message_classes))
	pvalues = []
	for t, p in msgclass.parameters:
		if t == int:
			v = _unpack_int(i)
		elif t == str:
			v = _unpack_str(i)
		elif t == Int32:
			v = _unpack_int(i, 4)
		else:
			raise TypeError
		pvalues.append(v)
	return msgclass(*pvalues)

#
# I/O
#

class PacketTooLarge(Exception):
	pass
	
class Initiator:
	def __init__(self, sockaddr):
		self.sockaddr = sockaddr
		self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		self._cleanup_file()
		self.socket.bind(self.sockaddr)
		self.socket.listen(1)
	
	def _cleanup_file(self):
		try:
			os.remove(self.sockaddr)
		except OSError:
			pass
	
	def accept(self):
		self.conn, addr = self.socket.accept()
	
	def send(self, message):
		self.conn.send(_pack(message))
	
	def recv(self):
		maxlen = 2048
		packet = self.conn.recv(maxlen)
		if len(packet) < 1:
			return None
		if len(packet) >= maxlen:
			raise PacketTooLarge
		return _unpack(packet)

	def close(self):
		if hasattr(self, "conn"):
			self.conn.shutdown(socket.SHUT_RDWR)
			self.conn.close()
		if hasattr(self, "socket"):
			self.socket.shutdown(socket.SHUT_RDWR)
			self.socket.close()
		self._cleanup_file()

########NEW FILE########
__FILENAME__ = upper
from migen.fhdl.structure import Signal, StopSimulation
from migen.fhdl.specials import Memory

class MemoryProxy:
	def __init__(self, simulator, obj):
		self.simulator = simulator
		self._simproxy_obj = obj

	def __getitem__(self, key):
		if isinstance(key, int):
			return self.simulator.rd(self._simproxy_obj, key)
		else:
			start, stop, step = key.indices(self._simproxy_obj.depth)
			return [self.simulator.rd(self._simproxy_obj, i) for i in range(start, stop, step)]

	def __setitem__(self, key, value):
		if isinstance(key, int):
			self.simulator.wr(self._simproxy_obj, key, value)
		else:
			start, stop, step = key.indices(self.__obj.depth)
			if len(value) != (stop - start)//step:
				raise ValueError
			for i, v in zip(range(start, stop, step), value):
				self.simulator.wr(self._simproxy_obj, i, v)

class Proxy:
	def __init__(self, simulator, obj):
		object.__setattr__(self, "simulator", simulator)
		object.__setattr__(self, "_simproxy_obj", obj)

	def __process_get(self, item):
		if isinstance(item, Signal):
			return self.simulator.rd(item)
		elif isinstance(item, Memory):
			return MemoryProxy(self.simulator, item)
		else:
			return Proxy(self.simulator, item)
	
	def __getattr__(self, name):
		return self.__process_get(getattr(self._simproxy_obj, name))
	
	def __setattr__(self, name, value):
		item = getattr(self._simproxy_obj, name)
		assert(isinstance(item, Signal))
		self.simulator.wr(item, value)

	def __getitem__(self, key):
		return self.__process_get(self._simproxy_obj[key])

	def __setitem__(self, key, value):
		item = self._simproxy_obj[key]
		assert(isinstance(item, Signal))
		self.simulator.wr(item, value)

def gen_sim(simg):
	gens = dict()
	resume_cycle = 0

	def do_simulation(s):
		nonlocal resume_cycle, gens

		if isinstance(s, Proxy):
			simulator = s.simulator
		else:
			simulator = s

		if simulator.cycle_counter >= resume_cycle:
			try:
				gen = gens[simulator]
			except KeyError:
				gen = simg(s)
				gens[simulator] = gen
			try:
				n = next(gen)
			except StopIteration:
				del gens[simulator]
				raise StopSimulation
			else:
				if n is None:
					n = 1
				resume_cycle = simulator.cycle_counter + n

	if hasattr(simg, "passive"):
		do_simulation.passive = simg.passive

	return do_simulation


def proxy_sim(target, simf):
	proxies = dict()

	def do_simulation(simulator):
		nonlocal proxies

		try:
			proxy = proxies[simulator]
		except KeyError:
			proxy = Proxy(simulator, target)
			proxies[simulator] = proxy
		try:
			simf(proxy)
		except StopSimulation:
			del proxies[simulator]
			raise

	if hasattr(simf, "passive"):
		do_simulation.passive = simf.passive

	return do_simulation

########NEW FILE########
__FILENAME__ = support
from migen.fhdl.std import *
from migen.sim.generic import run_simulation
from migen.fhdl import verilog

class SimBench(Module):
	callback = None
	def do_simulation(self, selfp):
		if self.callback is not None:
			return self.callback(self, selfp)

class SimCase:
	TestBench = SimBench

	def setUp(self, *args, **kwargs):
		self.tb = self.TestBench(*args, **kwargs)

	def test_to_verilog(self):
		verilog.convert(self.tb)

	def run_with(self, cb, ncycles=None):
		self.tb.callback = cb
		run_simulation(self.tb, ncycles=ncycles)

########NEW FILE########
__FILENAME__ = test_coding
import unittest

from migen.fhdl.std import *
from migen.genlib.coding import *

from migen.test.support import SimCase, SimBench

class EncCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = Encoder(8)

	def test_sizes(self):
		self.assertEqual(flen(self.tb.dut.i), 8)
		self.assertEqual(flen(self.tb.dut.o), 3)
		self.assertEqual(flen(self.tb.dut.n), 1)

	def test_run_sequence(self):
		seq = list(range(1<<8))
		def cb(tb, tbp):
			if seq:
				tbp.dut.i = seq.pop(0)
			if tbp.dut.n:
				self.assertNotIn(tbp.dut.i, [1<<i for i in range(8)])
			else:
				self.assertEqual(tbp.dut.i, 1<<tbp.dut.o)
		self.run_with(cb, 256)

class PrioEncCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = PriorityEncoder(8)

	def test_sizes(self):
		self.assertEqual(flen(self.tb.dut.i), 8)
		self.assertEqual(flen(self.tb.dut.o), 3)
		self.assertEqual(flen(self.tb.dut.n), 1)

	def test_run_sequence(self):
		seq = list(range(1<<8))
		def cb(tb, tbp):
			if seq:
				tbp.dut.i = seq.pop(0)
			i = tbp.dut.i
			if tbp.dut.n:
				self.assertEqual(i, 0)
			else:
				o = tbp.dut.o
				if o > 0:
					self.assertEqual(i & 1<<(o - 1), 0)
				self.assertGreaterEqual(i, 1<<o)
		self.run_with(cb, 256)

class DecCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = Decoder(8)

	def test_sizes(self):
		self.assertEqual(flen(self.tb.dut.i), 3)
		self.assertEqual(flen(self.tb.dut.o), 8)
		self.assertEqual(flen(self.tb.dut.n), 1)

	def test_run_sequence(self):
		seq = list(range(8*2))
		def cb(tb, tbp):
			if seq:
				i = seq.pop()
				tbp.dut.i = i//2
				tbp.dut.n = i%2
			i = tbp.dut.i
			o = tbp.dut.o
			if tbp.dut.n:
				self.assertEqual(o, 0)
			else:
				self.assertEqual(o, 1<<i)
		self.run_with(cb, 256)

class SmallPrioEncCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = PriorityEncoder(1)

	def test_sizes(self):
		self.assertEqual(flen(self.tb.dut.i), 1)
		self.assertEqual(flen(self.tb.dut.o), 1)
		self.assertEqual(flen(self.tb.dut.n), 1)

	def test_run_sequence(self):
		seq = list(range(1))
		def cb(tb, tbp):
			if seq:
				tbp.dut.i = seq.pop(0)
			i = tbp.dut.i
			if tbp.dut.n:
				self.assertEqual(i, 0)
			else:
				o = tbp.dut.o
				if o > 0:
					self.assertEqual(i & 1<<(o - 1), 0)
				self.assertGreaterEqual(i, 1<<o)
		self.run_with(cb, 5)

########NEW FILE########
__FILENAME__ = test_cordic
import unittest
from random import randrange, random
from math import *

from migen.fhdl.std import *
from migen.genlib.cordic import *

from migen.test.support import SimCase, SimBench

class CordicCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self, **kwargs):
			k = dict(width=8, guard=None, stages=None,
				eval_mode="combinatorial", cordic_mode="rotate",
				func_mode="circular")
			k.update(kwargs)
			self.submodules.dut = Cordic(**k)

	def _run_io(self, n, gen, proc, delta=1, deltaz=1):
		c = 2**(flen(self.tb.dut.xi) - 1)
		g = self.tb.dut.gain
		zm = self.tb.dut.zmax
		pipe = {}
		genn = [gen() for i in range(n)]
		def cb(tb, tbp):
			if tbp.dut.new_in:
				if genn:
					xi, yi, zi = genn.pop(0)
				else:
					raise StopSimulation
				xi = floor(xi*c/g)
				yi = floor(yi*c/g)
				zi = floor(zi*c/zm)
				tbp.dut.xi = xi
				tbp.dut.yi = yi
				tbp.dut.zi = zi
				pipe[tbp.simulator.cycle_counter] = xi, yi, zi
			if tbp.dut.new_out:
				t = tbp.simulator.cycle_counter - tb.dut.latency - 1
				if t < 1:
					return
				xi, yi, zi = pipe.pop(t)
				xo, yo, zo = proc(xi/c, yi/c, zi/c*zm)
				xo = floor(xo*c*g)
				yo = floor(yo*c*g)
				zo = floor(zo*c/zm)
				xo1 = tbp.dut.xo
				yo1 = tbp.dut.yo
				zo1 = tbp.dut.zo
				print((xi, yi, zi), (xo, yo, zo), (xo1, yo1, zo1))
				self.assertAlmostEqual(xo, xo1, delta=delta)
				self.assertAlmostEqual(yo, yo1, delta=delta)
				self.assertAlmostEqual(abs(zo - zo1) % (2*c), 0, delta=deltaz)
		self.run_with(cb)

	def test_rot_circ(self):
		def gen():
			ti = 2*pi*random()
			r = random()*.98
			return r*cos(ti), r*sin(ti), (2*random() - 1)*pi
		def proc(xi, yi, zi):
			xo = cos(zi)*xi - sin(zi)*yi
			yo = sin(zi)*xi + cos(zi)*yi
			return xo, yo, 0
		self._run_io(50, gen, proc, delta=2)

	def test_rot_circ_16(self):
		self.setUp(width=16)
		self.test_rot_circ()

	def test_rot_circ_pipe(self):
		self.setUp(eval_mode="pipelined")
		self.test_rot_circ()

	def test_rot_circ_iter(self):
		self.setUp(eval_mode="iterative")
		self.test_rot_circ()

	def _test_vec_circ(self):
		def gen():
			ti = pi*(2*random() - 1)
			r = .98 #*random()
			return r*cos(ti), r*sin(ti), 0 #pi*(2*random() - 1)
		def proc(xi, yi, zi):
			return sqrt(xi**2 + yi**2), 0, zi + atan2(yi, xi)
		self._run_io(50, gen, proc)

	def test_vec_circ(self):
		self.setUp(cordic_mode="vector")
		self._test_vec_circ()

	def test_vec_circ_16(self):
		self.setUp(width=16, cordic_mode="vector")
		self._test_vec_circ()

	def _test_rot_hyp(self):
		def gen():
			return .6, 0, 2.1*(random() - .5)
		def proc(xi, yi, zi):
			xo = cosh(zi)*xi - sinh(zi)*yi
			yo = sinh(zi)*xi + cosh(zi)*yi
			return xo, yo, 0
		self._run_io(50, gen, proc, delta=2)

	def test_rot_hyp(self):
		self.setUp(func_mode="hyperbolic")
		self._test_rot_hyp()

	def test_rot_hyp_16(self):
		self.setUp(func_mode="hyperbolic", width=16)
		self._test_rot_hyp()

	def test_rot_hyp_iter(self):
		self.setUp(cordic_mode="rotate", func_mode="hyperbolic",
				eval_mode="iterative")
		self._test_rot_hyp()

	def _test_vec_hyp(self):
		def gen():
			xi = random()*.6 + .2
			yi = random()*xi*.8
			return xi, yi, 0
		def proc(xi, yi, zi):
			return sqrt(xi**2 - yi**2), 0, atanh(yi/xi)
		self._run_io(50, gen, proc)

	def test_vec_hyp(self):
		self.setUp(cordic_mode="vector", func_mode="hyperbolic")
		self._test_vec_hyp()

	def _test_rot_lin(self):
		def gen():
			xi = 2*random() - 1
			if abs(xi) < .01:
				xi = .01
			yi = (2*random() - 1)*.5
			zi = (2*random() - 1)*.5
			return xi, yi, zi
		def proc(xi, yi, zi):
			return xi, yi + xi*zi, 0
		self._run_io(50, gen, proc)

	def test_rot_lin(self):
		self.setUp(func_mode="linear")
		self._test_rot_lin()

	def _test_vec_lin(self):
		def gen():
			yi = random()*.95 + .05
			if random() > 0:
				yi *= -1
			xi = abs(yi) + random()*(1 - abs(yi))
			zi = 2*random() - 1
			return xi, yi, zi
		def proc(xi, yi, zi):
			return xi, 0, zi + yi/xi
		self._run_io(50, gen, proc, deltaz=2, delta=2)

	def test_vec_lin(self):
		self.setUp(func_mode="linear", cordic_mode="vector", width=8)
		self._test_vec_lin()

########NEW FILE########
__FILENAME__ = test_fifo
import unittest

from migen.fhdl.std import *
from migen.genlib.fifo import SyncFIFO

from migen.test.support import SimCase, SimBench

class SyncFIFOCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = SyncFIFO([("a", 32), ("b", 32)], 2)

			self.sync += [
				If(self.dut.we & self.dut.writable,
					self.dut.din.a.eq(self.dut.din.a + 1),
					self.dut.din.b.eq(self.dut.din.b + 2)
				)
			]

	def test_sizes(self):
		self.assertEqual(flen(self.tb.dut.din_bits), 64)
		self.assertEqual(flen(self.tb.dut.dout_bits), 64)

	def test_run_sequence(self):
		seq = list(range(20))
		def cb(tb, tbp):
			# fire re and we at "random"
			tbp.dut.we = tbp.simulator.cycle_counter % 2 == 0
			tbp.dut.re = tbp.simulator.cycle_counter % 3 == 0
			# the output if valid must be correct
			if tbp.dut.readable and tbp.dut.re:
				try:
					i = seq.pop(0)
				except IndexError:
					print(tbp.dut.level)
					raise StopSimulation
				self.assertEqual(tbp.dut.dout.a, i)
				self.assertEqual(tbp.dut.dout.b, i*2)
		self.run_with(cb)

########NEW FILE########
__FILENAME__ = test_signed
import unittest

from migen.fhdl.std import *
from migen.test.support import SimCase, SimBench

class SignedCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.a = Signal((3, True))
			self.b = Signal((4, True))
			comps = [
				lambda p, q: p > q,
				lambda p, q: p >= q,
				lambda p, q: p < q,
				lambda p, q: p <= q,
				lambda p, q: p == q,
				lambda p, q: p != q,
			]
			self.vals = []
			for asign in 1, -1:
				for bsign in 1, -1:
					for f in comps:
						r = Signal()
						r0 = f(asign*self.a, bsign*self.b)
						self.comb += r.eq(r0)
						self.vals.append((asign, bsign, f, r, r0.op))

	def test_comparisons(self):
		values = range(-4, 4)
		agen = iter(values)
		bgen = iter(values)
		def cb(tb, tbp):
			try:
				tbp.a = next(agen)
				tbp.b = next(bgen)
			except StopIteration:
				raise StopSimulation
			a = tbp.a
			b = tbp.b
			for asign, bsign, f, r, op in self.tb.vals:
				r, r0 = tbp.simulator.rd(r), f(asign*a, bsign*b)
				self.assertEqual(r, int(r0),
						"got {}, want {}*{} {} {}*{} = {}".format(
							r, asign, a, op, bsign, b, r0))
		self.run_with(cb)

########NEW FILE########
__FILENAME__ = test_size
import unittest

from migen.fhdl.std import *

class SignalSizeCase(unittest.TestCase):
	def setUp(self):
		self.i = 0xaa
		self.j = -127
		self.s = Signal((13, True))

	def test_flen(self):
		self.assertEqual(flen(self.s), 13)
		self.assertEqual(flen(self.i), 8)
		self.assertEqual(flen(self.j), 8)

	def test_flen_type(self):
		self.assertRaises(TypeError, flen, [])

	def test_fiter(self):
		for i, si in enumerate(fiter(self.s)):
			self.assertEqual(si, self.s[i])
		self.assertEqual(list(fiter(self.i)),
				[(self.i >> i) & 1 for i in range(8)])
		self.assertEqual(list(fiter(self.j)),
				[(self.j >> i) & 1 for i in range(8)])

	def test_fiter_type(self):
		self.assertRaises(TypeError, fiter, [])

	def test_fslice(self):
		sl = slice(1, None, 2)
		fslice(self.s, sl)
		self.assertEqual(fslice(self.i, sl), 15)
		self.assertEqual(fslice(self.j, sl), 8)
		self.assertEqual(fslice(-1, 9), 1)
		self.assertEqual(fslice(-1, slice(0, 4)), 0b1)
		self.assertEqual(fslice(-7, slice(0, None, 1)), 0b1001)

	def test_fslice_type(self):
		self.assertRaises(TypeError, fslice, [], 3)

	def test_freversed(self):
		freversed(self.s)
		freversed(self.i)
		freversed(self.j)

	def test_freveseed_type(self):
		self.assertRaises(TypeError, freversed, [])

########NEW FILE########
__FILENAME__ = test_sort
import unittest
from random import randrange

from migen.fhdl.std import *
from migen.genlib.sort import *

from migen.test.support import SimCase, SimBench

class BitonicCase(SimCase, unittest.TestCase):
	class TestBench(SimBench):
		def __init__(self):
			self.submodules.dut = BitonicSort(8, 4, ascending=True)

	def test_sizes(self):
		self.assertEqual(len(self.tb.dut.i), 8)
		self.assertEqual(len(self.tb.dut.o), 8)
		for i in range(8):
			self.assertEqual(flen(self.tb.dut.i[i]), 4)
			self.assertEqual(flen(self.tb.dut.o[i]), 4)

	def test_sort(self):
		def cb(tb, tbp):
			for i in tb.dut.i:
				tbp.simulator.wr(i, randrange(1<<flen(i)))
			self.assertEqual(sorted(list(tbp.dut.i)), list(tbp.dut.o))
		self.run_with(cb, 20)

########NEW FILE########
__FILENAME__ = misc
from fractions import gcd
import collections

def flat_iteration(l):
	for element in l:
		if isinstance(element, collections.Iterable):
			for element2 in flat_iteration(element):
				yield element2
		else:
			yield element

def xdir(obj, return_values=False):
	for attr in dir(obj):
		if attr[:2] != "__" and attr[-2:] != "__":
			if return_values:
				yield attr, getattr(obj, attr)
			else:
				yield attr

def autotype(s):
	if s == "True":
		return True
	elif s == "False":
		return False
	try:
		return int(s, 0)
	except ValueError:
		pass
	return s

def gcd_multiple(numbers):
	l = len(numbers)
	if l == 1:
		return numbers[0]
	else:
		s = l//2
		return gcd(gcd_multiple(numbers[:s]), gcd_multiple(numbers[s:]))

########NEW FILE########
__FILENAME__ = treeviz
import cairo
import math

def _cairo_draw_node(ctx, dx, radius, color, outer_color, s):
	ctx.save()

	ctx.translate(dx, 0)

	ctx.set_line_width(0.0)
	gradient_color = cairo.RadialGradient(0, 0, 0, 0, 0, radius)
	gradient_color.add_color_stop_rgb(0, *color)
	gradient_color.add_color_stop_rgb(1, *outer_color)
	ctx.set_source(gradient_color)
	ctx.arc(0, 0, radius, 0, 2*math.pi)
	ctx.fill()

	lines = s.split("\n")
	textws = []
	texths = []
	for line in lines:
		x_bearing, y_bearing, w, h, x_advance, y_advance = ctx.text_extents(line)
		textws.append(w)
		texths.append(h + 2)
	ctx.translate(0, -sum(texths[1:])/2)
	for line, w, h in zip(lines, textws, texths):
		ctx.translate(-w/2, h/2)
		ctx.move_to(0, 0)
		ctx.set_source_rgb(0, 0, 0)
		ctx.show_text(line)
		ctx.translate(w/2, h/2)

	ctx.restore()

def _cairo_draw_connection(ctx, x0, y0, color0, x1, y1, color1):
	ctx.move_to(x0, y0)
	ctx.curve_to(x0, y0+20, x1, y1-20, x1, y1)
	ctx.set_line_width(1.2)
	gradient_color = cairo.LinearGradient(x0, y0, x1, y1)
	gradient_color.add_color_stop_rgb(0, *color0)
	gradient_color.add_color_stop_rgb(1, *color1)
	ctx.set_source(gradient_color)
	ctx.stroke()

class RenderNode:
	def __init__(self, label, children=None, color=(0.8, 0.8, 0.8), radius=40):
		self.label = label
		if children is None:
			children = []
		self.children = children
		self.color = color
		self.outer_color = (color[0]*3/5, color[1]*3/5, color[2]*3/5)
		self.radius = radius
		self.pitch = self.radius*3

	def get_dimensions(self):
		if self.children:
			cws, chs, cdxs = zip(*[c.get_dimensions() for c in self.children])
			w = sum(cws)
			h = self.pitch + max(chs)
			dx = cws[0]/4 - cws[-1]/4
		else:
			w = h = self.pitch
			dx = 0
		return w, h, dx

	def render(self, ctx):
		if self.children:
			cws, chs, cdxs = zip(*[c.get_dimensions() for c in self.children])
			first_child_x = -sum(cws)/2

			ctx.save()
			ctx.translate(first_child_x, self.pitch)
			for c, w in zip(self.children, cws):
				ctx.translate(w/2, 0)
				c.render(ctx)
				ctx.translate(w/2, 0)
			ctx.restore()

			dx = cws[0]/4 - cws[-1]/4

			current_x = first_child_x
			for c, w, cdx in zip(self.children, cws, cdxs):
				current_y = self.pitch - c.radius
				current_x += w/2
				_cairo_draw_connection(ctx, dx, self.radius, self.outer_color, current_x+cdx, current_y, c.outer_color)
				current_x += w/2
		else:
			dx = 0
		_cairo_draw_node(ctx, dx, self.radius, self.color, self.outer_color, self.label)

	def to_svg(self, name):
		w, h, dx = self.get_dimensions()
		surface = cairo.SVGSurface(name, w, h)
		ctx = cairo.Context(surface)
		ctx.translate(w/2, self.pitch/2)
		self.render(ctx)
		surface.finish()

def _test():
	xns = [RenderNode("X"+str(n)) for n in range(5)]
	yns = [RenderNode("Y"+str(n), [RenderNode("foo", color=(0.1*n, 0.5+0.2*n, 1.0-0.3*n))]) for n in range(3)]
	n1 = RenderNode("n1", yns)
	n2 = RenderNode("n2", xns, color=(0.8, 0.5, 0.9))
	top = RenderNode("top", [n1, n2])
	top.to_svg("test.svg")

if __name__ == "__main__":
	_test()

########NEW FILE########
