__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# reclass documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 26 12:56:14 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'reclass'
copyright = u'2013, martin f. krafft'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
import reclass.version
# The short X.Y version.
version = '.'.join(reclass.version.VERSION.split('.')[:2])
# The full version, including alpha/beta/rc tags.
release = reclass.version.VERSION

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
html_short_title = 'reclass'

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'reclassdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
'papersize': 'a4paper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'reclass.tex', u'reclass Documentation',
   u'martin f. krafft', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('manpage', 'reclass', u'command-line interface',
     [u'martin f. krafft'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'reclass', u'reclass Documentation',
   u'martin f. krafft', 'reclass', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = ansible
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# IMPORTANT NOTICE: I was kicked out of the Ansible community, and therefore
# I have no interest in developing this adapter anymore. If you use it and
# have changes, I will take your patch.
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import os, sys, posix, optparse

from reclass import get_storage, output
from reclass.core import Core
from reclass.errors import ReclassException
from reclass.config import find_and_read_configfile, get_options
from reclass.version import *
from reclass.constants import MODE_NODEINFO

def cli():
    try:
        # this adapter has to be symlinked to ansible_dir, so we can use this
        # information to initialise the inventory_base_uri to ansible_dir:
        ansible_dir = os.path.abspath(os.path.dirname(sys.argv[0]))

        defaults = {'inventory_base_uri': ansible_dir,
                    'pretty_print' : True,
                    'output' : 'json',
                    'applications_postfix': '_hosts'
                   }
        defaults.update(find_and_read_configfile())

        def add_ansible_options_group(parser, defaults):
            group = optparse.OptionGroup(parser, 'Ansible options',
                                         'Ansible-specific options')
            group.add_option('--applications-postfix',
                             dest='applications_postfix',
                             default=defaults.get('applications_postfix'),
                             help='postfix to append to applications to '\
                                  'turn them into groups')
            parser.add_option_group(group)

        options = get_options(RECLASS_NAME, VERSION, DESCRIPTION,
                              inventory_shortopt='-l',
                              inventory_longopt='--list',
                              inventory_help='output the inventory',
                              nodeinfo_shortopt='-t',
                              nodeinfo_longopt='--host',
                              nodeinfo_dest='hostname',
                              nodeinfo_help='output host_vars for the given host',
                              add_options_cb=add_ansible_options_group,
                              defaults=defaults)

        storage = get_storage(options.storage_type, options.nodes_uri,
                              options.classes_uri)
        class_mappings = defaults.get('class_mappings')
        reclass = Core(storage, class_mappings)

        if options.mode == MODE_NODEINFO:
            data = reclass.nodeinfo(options.hostname)
            # Massage and shift the data like Ansible wants it
            data['parameters']['__reclass__'] = data['__reclass__']
            for i in ('classes', 'applications'):
                data['parameters']['__reclass__'][i] = data[i]
            data = data['parameters']

        else:
            data = reclass.inventory()
            # Ansible inventory is only the list of groups. Groups are the set
            # of classes plus the set of applications with the postfix added:
            groups = data['classes']
            apps = data['applications']
            if options.applications_postfix:
                postfix = options.applications_postfix
                groups.update([(k + postfix, v) for k,v in apps.iteritems()])
            else:
                groups.update(apps)

            data = groups

        print output(data, options.output, options.pretty_print)

    except ReclassException, e:
        e.exit_with_message(sys.stderr)

    sys.exit(posix.EX_OK)

if __name__ == '__main__':
    cli()

########NEW FILE########
__FILENAME__ = salt
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import os, sys, posix

from reclass import get_storage, output
from reclass.core import Core
from reclass.errors import ReclassException
from reclass.config import find_and_read_configfile, get_options, \
        path_mangler
from reclass.constants import MODE_NODEINFO
from reclass.defaults import *
from reclass.version import *

def ext_pillar(minion_id, pillar,
               storage_type=OPT_STORAGE_TYPE,
               inventory_base_uri=OPT_INVENTORY_BASE_URI,
               nodes_uri=OPT_NODES_URI,
               classes_uri=OPT_CLASSES_URI,
               class_mappings=None,
               propagate_pillar_data_to_reclass=False):

    nodes_uri, classes_uri = path_mangler(inventory_base_uri,
                                          nodes_uri, classes_uri)
    storage = get_storage(storage_type, nodes_uri, classes_uri,
                          default_environment='base')
    input_data = None
    if propagate_pillar_data_to_reclass:
        input_data = pillar
    reclass = Core(storage, class_mappings, input_data=input_data)

    data = reclass.nodeinfo(minion_id)
    params = data.get('parameters', {})
    params['__reclass__'] = {}
    params['__reclass__']['nodename'] = minion_id
    params['__reclass__']['applications'] = data['applications']
    params['__reclass__']['classes'] = data['classes']
    params['__reclass__']['environment'] = data['environment']
    return params


def top(minion_id, storage_type=OPT_STORAGE_TYPE,
        inventory_base_uri=OPT_INVENTORY_BASE_URI, nodes_uri=OPT_NODES_URI,
        classes_uri=OPT_CLASSES_URI,
        class_mappings=None):

    nodes_uri, classes_uri = path_mangler(inventory_base_uri,
                                          nodes_uri, classes_uri)
    storage = get_storage(storage_type, nodes_uri, classes_uri,
                          default_environment='base')
    reclass = Core(storage, class_mappings, input_data=None)

    # if the minion_id is not None, then return just the applications for the
    # specific minion, otherwise return the entire top data (which we need for
    # CLI invocations of the adapter):
    if minion_id is not None:
        data = reclass.nodeinfo(minion_id)
        applications = data.get('applications', [])
        env = data['environment']
        return {env: applications}

    else:
        data = reclass.inventory()
        nodes = {}
        for node_id, node_data in data['nodes'].iteritems():
            env = node_data['environment']
            if env not in nodes:
                nodes[env] = {}
            nodes[env][node_id] = node_data['applications']

        return nodes


def cli():
    try:
        inventory_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
        defaults = {'pretty_print' : True,
                    'output' : 'yaml',
                    'inventory_base_uri': inventory_dir
                   }
        defaults.update(find_and_read_configfile())
        options = get_options(RECLASS_NAME, VERSION, DESCRIPTION,
                              inventory_shortopt='-t',
                              inventory_longopt='--top',
                              inventory_help='output the state tops (inventory)',
                              nodeinfo_shortopt='-p',
                              nodeinfo_longopt='--pillar',
                              nodeinfo_dest='nodename',
                              nodeinfo_help='output pillar data for a specific node',
                              defaults=defaults)
        class_mappings = defaults.get('class_mappings')

        if options.mode == MODE_NODEINFO:
            data = ext_pillar(options.nodename, {},
                              storage_type=options.storage_type,
                              inventory_base_uri=options.inventory_base_uri,
                              nodes_uri=options.nodes_uri,
                              classes_uri=options.classes_uri,
                              class_mappings=class_mappings)
        else:
            data = top(minion_id=None,
                       storage_type=options.storage_type,
                       inventory_base_uri=options.inventory_base_uri,
                       nodes_uri=options.nodes_uri,
                       classes_uri=options.classes_uri,
                       class_mappings=class_mappings)

        print output(data, options.output, options.pretty_print)

    except ReclassException, e:
        e.exit_with_message(sys.stderr)

    sys.exit(posix.EX_OK)

if __name__ == '__main__':
    cli()

########NEW FILE########
__FILENAME__ = cli
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import sys, os, posix

from reclass import get_storage, output
from reclass.core import Core
from reclass.config import find_and_read_configfile, get_options
from reclass.errors import ReclassException
from reclass.defaults import *
from reclass.constants import MODE_NODEINFO
from reclass.version import *

def main():
    try:
        defaults = {'pretty_print' : OPT_PRETTY_PRINT,
                    'output' : OPT_OUTPUT
                   }
        defaults.update(find_and_read_configfile())
        options = get_options(RECLASS_NAME, VERSION, DESCRIPTION,
                              defaults=defaults)

        storage = get_storage(options.storage_type, options.nodes_uri,
                              options.classes_uri, default_environment='base')
        class_mappings = defaults.get('class_mappings')
        reclass = Core(storage, class_mappings)

        if options.mode == MODE_NODEINFO:
            data = reclass.nodeinfo(options.nodename)

        else:
            data = reclass.inventory()

        print output(data, options.output, options.pretty_print)

    except ReclassException, e:
        e.exit_with_message(sys.stderr)

    sys.exit(posix.EX_OK)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = config
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import yaml, os, optparse, posix, sys

import errors
from defaults import *
from constants import MODE_NODEINFO, MODE_INVENTORY

def make_db_options_group(parser, defaults={}):
    ret = optparse.OptionGroup(parser, 'Database options',
                               'Configure from where {0} collects data'.format(parser.prog))
    ret.add_option('-s', '--storage-type', dest='storage_type',
                   default=defaults.get('storage_type', OPT_STORAGE_TYPE),
                   help='the type of storage backend to use [%default]')
    ret.add_option('-b', '--inventory-base-uri', dest='inventory_base_uri',
                   default=defaults.get('inventory_base_uri',
                                        OPT_INVENTORY_BASE_URI),
                   help='the base URI to prepend to nodes and classes [%default]'),
    ret.add_option('-u', '--nodes-uri', dest='nodes_uri',
                   default=defaults.get('nodes_uri', OPT_NODES_URI),
                   help='the URI to the nodes storage [%default]'),
    ret.add_option('-c', '--classes-uri', dest='classes_uri',
                   default=defaults.get('classes_uri', OPT_CLASSES_URI),
                   help='the URI to the classes storage [%default]')
    return ret


def make_output_options_group(parser, defaults={}):
    ret = optparse.OptionGroup(parser, 'Output options',
                               'Configure the way {0} prints data'.format(parser.prog))
    ret.add_option('-o', '--output', dest='output',
                   default=defaults.get('output', OPT_OUTPUT),
                   help='output format (yaml or json) [%default]')
    ret.add_option('-y', '--pretty-print', dest='pretty_print',
                   action="store_true",
                   default=defaults.get('pretty_print', OPT_PRETTY_PRINT),
                   help='try to make the output prettier [%default]')
    return ret


def make_modes_options_group(parser, inventory_shortopt, inventory_longopt,
                             inventory_help, nodeinfo_shortopt,
                             nodeinfo_longopt, nodeinfo_dest, nodeinfo_help):

    def _mode_checker_cb(option, opt_str, value, parser):
        if hasattr(parser.values, 'mode'):
            raise optparse.OptionValueError('Cannot specify multiple modes')

        if option == parser.get_option(nodeinfo_longopt):
            setattr(parser.values, 'mode', MODE_NODEINFO)
            setattr(parser.values, nodeinfo_dest, value)
        else:
            setattr(parser.values, 'mode', MODE_INVENTORY)
            setattr(parser.values, nodeinfo_dest, None)

    ret = optparse.OptionGroup(parser, 'Modes',
                               'Specify one of these to determine what to do.')
    ret.add_option(inventory_shortopt, inventory_longopt,
                   action='callback', callback=_mode_checker_cb,
                   help=inventory_help)
    ret.add_option(nodeinfo_shortopt, nodeinfo_longopt,
                   default=None, dest=nodeinfo_dest, type='string',
                   action='callback', callback=_mode_checker_cb,
                   help=nodeinfo_help)
    return ret


def make_parser_and_checker(name, version, description,
                            inventory_shortopt='-i',
                            inventory_longopt='--inventory',
                            inventory_help='output the entire inventory',
                            nodeinfo_shortopt='-n',
                            nodeinfo_longopt='--nodeinfo',
                            nodeinfo_dest='nodename',
                            nodeinfo_help='output information for a specific node',
                            add_options_cb=None,
                            defaults={}):

    parser = optparse.OptionParser(version=version)
    parser.prog = name
    parser.version = version
    parser.description = description.capitalize()
    parser.usage = '%prog [options] ( {0} | {1} {2} )'.format(inventory_longopt,
                                                             nodeinfo_longopt,
                                                             nodeinfo_dest.upper())
    parser.epilog = 'Exactly one mode has to be specified.'

    db_group = make_db_options_group(parser, defaults)
    parser.add_option_group(db_group)

    output_group = make_output_options_group(parser, defaults)
    parser.add_option_group(output_group)

    if callable(add_options_cb):
        add_options_cb(parser, defaults)

    modes_group = make_modes_options_group(parser, inventory_shortopt,
                                           inventory_longopt, inventory_help,
                                           nodeinfo_shortopt,
                                           nodeinfo_longopt, nodeinfo_dest,
                                           nodeinfo_help)
    parser.add_option_group(modes_group)

    def option_checker(options, args):
        if len(args) > 0:
            parser.error('No arguments allowed')
        elif not hasattr(options, 'mode') \
                or options.mode not in (MODE_NODEINFO, MODE_INVENTORY):
            parser.error('You need to specify exactly one mode '\
                         '({0} or {1})'.format(inventory_longopt,
                                               nodeinfo_longopt))
        elif options.mode == MODE_NODEINFO \
                and not getattr(options, nodeinfo_dest, None):
            parser.error('Mode {0} needs {1}'.format(nodeinfo_longopt,
                                                     nodeinfo_dest.upper()))
        elif options.inventory_base_uri is None and options.nodes_uri is None:
            parser.error('Must specify --inventory-base-uri or --nodes-uri')
        elif options.inventory_base_uri is None and options.classes_uri is None:
            parser.error('Must specify --inventory-base-uri or --classes-uri')

    return parser, option_checker


def path_mangler(inventory_base_uri, nodes_uri, classes_uri):

    if inventory_base_uri is None:
        # if inventory_base is not given, default to current directory
        inventory_base_uri = os.getcwd()

    nodes_uri = nodes_uri or 'nodes'
    classes_uri = classes_uri or 'classes'

    def _path_mangler_inner(path):
        ret = os.path.join(inventory_base_uri, path)
        ret = os.path.expanduser(ret)
        return os.path.abspath(ret)

    n, c = map(_path_mangler_inner, (nodes_uri, classes_uri))
    if n == c:
        raise errors.DuplicateUriError(n, c)
    common = os.path.commonprefix((n, c))
    if common == n or common == c:
        raise errors.UriOverlapError(n, c)

    return n, c


def get_options(name, version, description,
                            inventory_shortopt='-i',
                            inventory_longopt='--inventory',
                            inventory_help='output the entire inventory',
                            nodeinfo_shortopt='-n',
                            nodeinfo_longopt='--nodeinfo',
                            nodeinfo_dest='nodename',
                            nodeinfo_help='output information for a specific node',
                            add_options_cb=None,
                            defaults={}):

    parser, checker = make_parser_and_checker(name, version, description,
                                              inventory_shortopt,
                                              inventory_longopt,
                                              inventory_help,
                                              nodeinfo_shortopt,
                                              nodeinfo_longopt, nodeinfo_dest,
                                              nodeinfo_help,
                                              add_options_cb,
                                              defaults=defaults)
    options, args = parser.parse_args()
    checker(options, args)

    options.nodes_uri, options.classes_uri = \
            path_mangler(options.inventory_base_uri, options.nodes_uri,
                         options.classes_uri)

    return options


def vvv(msg):
    #print >>sys.stderr, msg
    pass


def find_and_read_configfile(filename=CONFIG_FILE_NAME,
                             dirs=CONFIG_FILE_SEARCH_PATH):
    for d in dirs:
        f = os.path.join(d, filename)
        if os.access(f, os.R_OK):
            vvv('Using config file: {0}'.format(f))
            return yaml.safe_load(file(f))
        elif os.path.isfile(f):
            raise PermissionsError('cannot read %s' % f)
    return {}

########NEW FILE########
__FILENAME__ = constants
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

class _Constant(object):

    def __init__(self, displayname):
        self._repr = displayname

    __str__ = __repr__ = lambda self: self._repr

MODE_NODEINFO = _Constant('NODEINFO')
MODE_INVENTORY = _Constant('INVENTORY')

########NEW FILE########
__FILENAME__ = core
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import time
#import types
import re
#import sys
import fnmatch
import shlex
from reclass.datatypes import Entity, Classes, Parameters
from reclass.errors import MappingFormatError, ClassNotFound

class Core(object):

    def __init__(self, storage, class_mappings, input_data=None):
        self._storage = storage
        self._class_mappings = class_mappings
        self._input_data = input_data

    @staticmethod
    def _get_timestamp():
        return time.strftime('%c')

    @staticmethod
    def _match_regexp(key, nodename):
        return re.search(key, nodename)

    @staticmethod
    def _match_glob(key, nodename):
        return fnmatch.fnmatchcase(nodename, key)

    @staticmethod
    def _shlex_split(instr):
        lexer = shlex.shlex(instr, posix=True)
        lexer.whitespace_split = True
        lexer.commenters = ''
        regexp = False
        if instr[0] == '/':
            lexer.quotes += '/'
            lexer.escapedquotes += '/'
            regexp = True
        try:
            key = lexer.get_token()
        except ValueError, e:
            raise MappingFormatError('Error in mapping "{0}": missing closing '
                                     'quote (or slash)'.format(instr))
        if regexp:
            key = '/{0}/'.format(key)
        return key, list(lexer)

    def _get_class_mappings_entity(self, nodename):
        if not self._class_mappings:
            return Entity(name='empty (class mappings)')
        c = Classes()
        for mapping in self._class_mappings:
            matched = False
            key, klasses = Core._shlex_split(mapping)
            if key[0] == ('/'):
                matched = Core._match_regexp(key[1:-1], nodename)
                if matched:
                    for klass in klasses:
                        c.append_if_new(matched.expand(klass))

            else:
                if Core._match_glob(key, nodename):
                    for klass in klasses:
                        c.append_if_new(klass)

        return Entity(classes=c,
                      name='class mappings for node {0}'.format(nodename))

    def _get_input_data_entity(self):
        if not self._input_data:
            return Entity(name='empty (input data)')
        p = Parameters(self._input_data)
        return Entity(parameters=p, name='input data')

    def _recurse_entity(self, entity, merge_base=None, seen=None, nodename=None):
        if seen is None:
            seen = {}

        if merge_base is None:
            merge_base = Entity(name='empty (@{0})'.format(nodename))

        for klass in entity.classes.as_list():
            if klass not in seen:
                try:
                    class_entity = self._storage.get_class(klass)
                except ClassNotFound, e:
                    e.set_nodename(nodename)
                    raise e

                descent = self._recurse_entity(class_entity, seen=seen,
                                               nodename=nodename)
                # on every iteration, we merge the result of the recursive
                # descent into what we have so far…
                merge_base.merge(descent)
                seen[klass] = True

        # … and finally, we merge what we have at this level into the
        # result of the iteration, so that elements at the current level
        # overwrite stuff defined by parents
        merge_base.merge(entity)
        return merge_base

    def _nodeinfo(self, nodename):
        node_entity = self._storage.get_node(nodename)
        base_entity = Entity(name='base')
        base_entity.merge(self._get_class_mappings_entity(node_entity.name))
        base_entity.merge(self._get_input_data_entity())
        seen = {}
        merge_base = self._recurse_entity(base_entity, seen=seen,
                                          nodename=base_entity.name)
        ret = self._recurse_entity(node_entity, merge_base, seen=seen,
                                   nodename=node_entity.name)
        ret.interpolate()
        return ret

    def _nodeinfo_as_dict(self, nodename, entity):
        ret = {'__reclass__' : {'node': entity.name, 'name': nodename,
                                'uri': entity.uri,
                                'environment': entity.environment,
                                'timestamp': Core._get_timestamp()
                               },
              }
        ret.update(entity.as_dict())
        return ret

    def nodeinfo(self, nodename):
        return self._nodeinfo_as_dict(nodename, self._nodeinfo(nodename))

    def inventory(self):
        entities = {}
        for n in self._storage.enumerate_nodes():
            entities[n] = self._nodeinfo(n)

        nodes = {}
        applications = {}
        classes = {}
        for f, nodeinfo in entities.iteritems():
            d = nodes[f] = self._nodeinfo_as_dict(f, nodeinfo)
            for a in d['applications']:
                if a in applications:
                    applications[a].append(f)
                else:
                    applications[a] = [f]
            for c in d['classes']:
                if c in classes:
                    classes[c].append(f)
                else:
                    classes[c] = [f]

        return {'__reclass__' : {'timestamp': Core._get_timestamp()},
                'nodes': nodes,
                'classes': classes,
                'applications': applications
               }

########NEW FILE########
__FILENAME__ = applications
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

from classes import Classes

class Applications(Classes):
    '''
    Extends Classes with the possibility to let specially formatted items
    remove earlier occurences of the item. For instance, if the "negater" is
    '~', then "adding" an element "~foo" to a list causes a previous element
    "foo" to be removed. If no such element exists, nothing happens, but
    a reference of the negation is kept, in case the instance is later used to
    extend another instance, in which case the negations should apply to the
    instance to be extended.
    '''
    DEFAULT_NEGATION_PREFIX = '~'

    def __init__(self, iterable=None,
                 negation_prefix=DEFAULT_NEGATION_PREFIX):
        self._negation_prefix = negation_prefix
        self._offset = len(negation_prefix)
        self._negations = []
        super(Applications, self).__init__(iterable)

    def _get_negation_prefix(self):
        return self._negation_prefix
    negation_prefix = property(_get_negation_prefix)

    def append_if_new(self, item):
        self._assert_is_string(item)
        if item.startswith(self._negation_prefix):
            item = item[self._offset:]
            self._negations.append(item)
            try:
                self._items.remove(item)
            except ValueError:
                pass
        else:
            super(Applications, self)._append_if_new(item)

    def merge_unique(self, iterable):
        if isinstance(iterable, self.__class__):
            # we might be extending ourselves to include negated applications,
            # in which case we need to remove our own content accordingly:
            for negation in iterable._negations:
                try:
                    self._items.remove(negation)
                except ValueError:
                    pass
            iterable = iterable.as_list()
        for i in iterable:
            self.append_if_new(i)

    def __repr__(self):
        contents = self._items + \
                ['%s%s' % (self._negation_prefix, i) for i in self._negations]
        return "%s(%r, %r)" % (self.__class__.__name__, contents,
                               self._negation_prefix)

########NEW FILE########
__FILENAME__ = classes
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import types
import os
from reclass.errors import InvalidClassnameError

INVALID_CHARACTERS_FOR_CLASSNAMES = ' ' + os.sep

class Classes(object):
    '''
    A very limited ordered set of strings with O(n) uniqueness constraints. It
    is neither a proper list or a proper set, on purpose, to keep things
    simple.
    '''
    def __init__(self, iterable=None):
        self._items = []
        if iterable is not None:
            self.merge_unique(iterable)

    def __len__(self):
        return len(self._items)

    def __eq__(self, rhs):
        if isinstance(rhs, list):
            return self._items == rhs
        else:
            try:
                return self._items == rhs._items
            except AttributeError as e:
                return False

    def __ne__(self, rhs):
        return not self.__eq__(rhs)

    def as_list(self):
        return self._items[:]

    def merge_unique(self, iterable):
        if isinstance(iterable, self.__class__):
            iterable = iterable.as_list()
        # Cannot just call list.extend here, as iterable's items might not
        # be unique by themselves, or in the context of self.
        for i in iterable:
            self.append_if_new(i)

    def _assert_is_string(self, item):
        if not isinstance(item, types.StringTypes):
            raise TypeError('%s instances can only contain strings, '\
                            'not %s' % (self.__class__.__name__, type(item)))

    def _assert_valid_characters(self, item):
        for c in INVALID_CHARACTERS_FOR_CLASSNAMES:
            if c in item:
                raise InvalidClassnameError(c, item)

    def _append_if_new(self, item):
        if item not in self._items:
            self._items.append(item)

    def append_if_new(self, item):
        self._assert_is_string(item)
        self._assert_valid_characters(item)
        self._append_if_new(item)

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__,
                           self._items)

########NEW FILE########
__FILENAME__ = entity
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from classes import Classes
from applications import Applications
from parameters import Parameters

class Entity(object):
    '''
    A collection of Classes, Parameters, and Applications, mainly as a wrapper
    for merging. The name and uri of an Entity will be updated to the name and
    uri of the Entity that is being merged.
    '''
    def __init__(self, classes=None, applications=None, parameters=None,
                 uri=None, name=None, environment=None):
        if classes is None: classes = Classes()
        self._set_classes(classes)
        if applications is None: applications = Applications()
        self._set_applications(applications)
        if parameters is None: parameters = Parameters()
        self._set_parameters(parameters)
        self._uri = uri or ''
        self._name = name or ''
        self._environment = environment or ''

    name = property(lambda s: s._name)
    uri = property(lambda s: s._uri)
    environment = property(lambda s: s._environment)
    classes = property(lambda s: s._classes)
    applications = property(lambda s: s._applications)
    parameters = property(lambda s: s._parameters)

    def _set_classes(self, classes):
        if not isinstance(classes, Classes):
            raise TypeError('Entity.classes cannot be set to '\
                            'instance of type %s' % type(classes))
        self._classes = classes

    def _set_applications(self, applications):
        if not isinstance(applications, Applications):
            raise TypeError('Entity.applications cannot be set to '\
                            'instance of type %s' % type(applications))
        self._applications = applications

    def _set_parameters(self, parameters):
        if not isinstance(parameters, Parameters):
            raise TypeError('Entity.parameters cannot be set to '\
                            'instance of type %s' % type(parameters))
        self._parameters = parameters

    def merge(self, other):
        self._classes.merge_unique(other._classes)
        self._applications.merge_unique(other._applications)
        self._parameters.merge(other._parameters)
        self._name = other.name
        self._uri = other.uri
        self._environment = other.environment

    def interpolate(self):
        self._parameters.interpolate()

    def __eq__(self, other):
        return isinstance(other, type(self)) \
                and self._applications == other._applications \
                and self._classes == other._classes \
                and self._parameters == other._parameters \
                and self._name == other._name \
                and self._uri == other._uri

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return "%s(%r, %r, %r, uri=%r, name=%r)" % (self.__class__.__name__,
                                                    self.classes,
                                                    self.applications,
                                                    self.parameters,
                                                    self.uri,
                                                    self.name)

    def as_dict(self):
        return {'classes': self._classes.as_list(),
                'applications': self._applications.as_list(),
                'parameters': self._parameters.as_dict(),
                'environment': self._environment
               }

########NEW FILE########
__FILENAME__ = parameters
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
import types

from reclass.defaults import PARAMETER_INTERPOLATION_DELIMITER
from reclass.utils.dictpath import DictPath
from reclass.utils.refvalue import RefValue
from reclass.errors import InfiniteRecursionError, UndefinedVariableError

class Parameters(object):
    '''
    A class to hold nested dictionaries with the following specialities:

      1. "merging" a dictionary (the "new" dictionary) into the current
         Parameters causes a recursive walk of the new dict, during which

         - scalars (incl. tuples) are replaced with the value from the new
           dictionary;
         - lists are extended, not replaced;
         - dictionaries are updated (using dict.update), not replaced;

      2. "interpolating" a dictionary means that values within the dictionary
         can reference other values in the same dictionary. Those references
         are collected during merging and then resolved during interpolation,
         which avoids having to walk the dictionary twice. If a referenced
         value contains references itself, those are resolved first, in
         topological order. Therefore, deep references work. Cyclical
         references cause an error.

    To support these specialities, this class only exposes very limited
    functionality and does not try to be a really mapping object.
    '''
    DEFAULT_PATH_DELIMITER = PARAMETER_INTERPOLATION_DELIMITER

    def __init__(self, mapping=None, delimiter=None):
        if delimiter is None:
            delimiter = Parameters.DEFAULT_PATH_DELIMITER
        self._delimiter = delimiter
        self._base = {}
        self._occurrences = {}
        if mapping is not None:
            # we initialise by merging, otherwise the list of references might
            # not be updated
            self.merge(mapping)

    delimiter = property(lambda self: self._delimiter)

    def __len__(self):
        return len(self._base)

    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self._base,
                               self.delimiter)

    def __eq__(self, other):
        return isinstance(other, type(self)) \
                and self._base == other._base \
                and self._delimiter == other._delimiter

    def __ne__(self, other):
        return not self.__eq__(other)

    def as_dict(self):
        return self._base.copy()

    def _update_scalar(self, cur, new, path):
        if self.delimiter is None or not isinstance(new, (types.StringTypes,
                                                          RefValue)):
            # either there is no delimiter defined (and hence no references
            # are being used), or the new value is not a string (and hence
            # cannot be turned into a RefValue), and not a RefValue. We can
            # shortcut and just return the new scalar
            return new

        elif isinstance(new, RefValue):
            # the new value is (already) a RefValue, so we need not touch it
            # at all
            ret = new

        else:
            # the new value is a string, let's see if it contains references,
            # by way of wrapping it in a RefValue and querying the result
            ret = RefValue(new, self.delimiter)
            if not ret.has_references():
                # do not replace with RefValue instance if there are no
                # references, i.e. discard the RefValue in ret, just return
                # the new value
                return new

        # So we now have a RefValue. Let's, keep a reference to the instance
        # we just created, in a dict indexed by the dictionary path, instead
        # of just a list. The keys are required to resolve dependencies during
        # interpolation
        self._occurrences[path] = ret
        return ret

    def _extend_list(self, cur, new, path):
        if isinstance(cur, list):
            ret = cur
            offset = len(cur)
        else:
            ret = [cur]
            offset = 1

        for i in xrange(len(new)):
            ret.append(self._merge_recurse(None, new[i], path.new_subpath(offset + i)))
        return ret

    def _merge_dict(self, cur, new, path):
        if isinstance(cur, dict):
            ret = cur
        else:
            # nothing sensible to do
            raise TypeError('Cannot merge dict into {0} '
                            'objects'.format(type(cur)))

        if self.delimiter is None:
            # a delimiter of None indicates that there is no value
            # processing to be done, and since there is no current
            # value, we do not need to walk the new dictionary:
            ret.update(new)
            return ret

        for key, newvalue in new.iteritems():
            ret[key] = self._merge_recurse(ret.get(key), newvalue,
                                           path.new_subpath(key))
        return ret

    def _merge_recurse(self, cur, new, path=None):
        if path is None:
            path = DictPath(self.delimiter)

        if isinstance(new, dict):
            if cur is None:
                cur = {}
            return self._merge_dict(cur, new, path)

        elif isinstance(new, list):
            if cur is None:
                cur = []
            return self._extend_list(cur, new, path)

        else:
            return self._update_scalar(cur, new, path)

    def merge(self, other):
        if isinstance(other, dict):
            self._base = self._merge_recurse(self._base, other, None)

        elif isinstance(other, self.__class__):
            self._base = self._merge_recurse(self._base, other._base,
                                             None)

        else:
            raise TypeError('Cannot merge %s objects into %s' % (type(other),
                            self.__class__.__name__))

    def has_unresolved_refs(self):
        return len(self._occurrences) > 0

    def interpolate(self):
        while self.has_unresolved_refs():
            # we could use a view here, but this is simple enough:
            # _interpolate_inner removes references from the refs hash after
            # processing them, so we cannot just iterate the dict
            path, refvalue = self._occurrences.iteritems().next()
            self._interpolate_inner(path, refvalue)

    def _interpolate_inner(self, path, refvalue):
        self._occurrences[path] = True  # mark as seen
        for ref in refvalue.get_references():
            path_from_ref = DictPath(self.delimiter, ref)
            try:
                refvalue_inner = self._occurrences[path_from_ref]

                # If there is no reference, then this will throw a KeyError,
                # look further down where this is caught and execution passed
                # to the next iteration of the loop
                #
                # If we get here, then the ref references another parameter,
                # requiring us to recurse, dereferencing first those refs that
                # are most used and are thus at the leaves of the dependency
                # tree.

                if refvalue_inner is True:
                    # every call to _interpolate_inner replaces the value of
                    # the saved occurrences of a reference with True.
                    # Therefore, if we encounter True instead of a refvalue,
                    # it means that we have already processed it and are now
                    # faced with a cyclical reference.
                    raise InfiniteRecursionError(path, ref)
                self._interpolate_inner(path_from_ref, refvalue_inner)

            except KeyError as e:
                # not actually an error, but we are done resolving all
                # dependencies of the current ref, so move on
                continue

        try:
            new = refvalue.render(self._base)
            path.set_value(self._base, new)

            # finally, remove the reference from the occurrences cache
            del self._occurrences[path]
        except UndefinedVariableError as e:
            raise UndefinedVariableError(e.var, path)


########NEW FILE########
__FILENAME__ = test_applications
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.datatypes import Applications, Classes
import unittest
try:
    import unittest.mock as mock
except ImportError:
    import mock

TESTLIST1 = ['one', 'two', 'three']
TESTLIST2 = ['red', 'green', '~two', '~three']
GOALLIST = ['one', 'red', 'green']

#TODO: mock out the underlying list

class TestApplications(unittest.TestCase):

    def test_inheritance(self):
        a = Applications()
        self.assertIsInstance(a, Classes)

    def test_constructor_negate(self):
        a = Applications(TESTLIST1 + TESTLIST2)
        self.assertSequenceEqual(a, GOALLIST)

    def test_merge_unique_negate_list(self):
        a = Applications(TESTLIST1)
        a.merge_unique(TESTLIST2)
        self.assertSequenceEqual(a, GOALLIST)

    def test_merge_unique_negate_instance(self):
        a = Applications(TESTLIST1)
        a.merge_unique(Applications(TESTLIST2))
        self.assertSequenceEqual(a, GOALLIST)

    def test_append_if_new_negate(self):
        a = Applications(TESTLIST1)
        a.append_if_new(TESTLIST2[2])
        self.assertSequenceEqual(a, TESTLIST1[::2])

    def test_repr_empty(self):
        negater = '%%'
        a = Applications(negation_prefix=negater)
        self.assertEqual('%r' % a, "%s(%r, '%s')" % (a.__class__.__name__, [], negater))

    def test_repr_contents(self):
        negater = '%%'
        a = Applications(TESTLIST1, negation_prefix=negater)
        self.assertEqual('%r' % a, "%s(%r, '%s')" % (a.__class__.__name__, TESTLIST1, negater))

    def test_repr_negations(self):
        negater = '~'
        a = Applications(TESTLIST2, negation_prefix=negater)
        self.assertEqual('%r' % a, "%s(%r, '%s')" % (a.__class__.__name__, TESTLIST2, negater))

    def test_repr_negations_interspersed(self):
        l = ['a', '~b', 'a', '~d']
        a = Applications(l)
        is_negation = lambda x: x.startswith(a.negation_prefix)
        GOAL = filter(lambda x: not is_negation(x), set(l)) + filter(is_negation, l)
        self.assertEqual('%r' % a, "%s(%r, '~')" % (a.__class__.__name__, GOAL))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_classes
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.datatypes import Classes
from reclass.datatypes.classes import INVALID_CHARACTERS_FOR_CLASSNAMES
import unittest
try:
    import unittest.mock as mock
except ImportError:
    import mock
from reclass.errors import InvalidClassnameError

TESTLIST1 = ['one', 'two', 'three']
TESTLIST2 = ['red', 'green', 'blue']

#TODO: mock out the underlying list

class TestClasses(unittest.TestCase):

    def test_len_empty(self):
        with mock.patch.object(Classes, 'merge_unique') as m:
            c = Classes()
            self.assertEqual(len(c), 0)
            self.assertFalse(m.called)

    def test_constructor(self):
        with mock.patch.object(Classes, 'merge_unique') as m:
            c = Classes(TESTLIST1)
            m.assert_called_once_with(TESTLIST1)

    def test_equality_list_empty(self):
        self.assertEqual(Classes(), [])

    def test_equality_list(self):
        self.assertEqual(Classes(TESTLIST1), TESTLIST1)

    def test_equality_instance_empty(self):
        self.assertEqual(Classes(), Classes())

    def test_equality_instance(self):
        self.assertEqual(Classes(TESTLIST1), Classes(TESTLIST1))

    def test_inequality(self):
        self.assertNotEqual(Classes(TESTLIST1), Classes(TESTLIST2))

    def test_construct_duplicates(self):
        c = Classes(TESTLIST1 + TESTLIST1)
        self.assertSequenceEqual(c, TESTLIST1)

    def test_append_if_new(self):
        c = Classes()
        c.append_if_new(TESTLIST1[0])
        self.assertEqual(len(c), 1)
        self.assertSequenceEqual(c, TESTLIST1[:1])

    def test_append_if_new_duplicate(self):
        c = Classes(TESTLIST1)
        c.append_if_new(TESTLIST1[0])
        self.assertEqual(len(c), len(TESTLIST1))
        self.assertSequenceEqual(c, TESTLIST1)

    def test_append_if_new_nonstring(self):
        c = Classes()
        with self.assertRaises(TypeError):
            c.append_if_new(0)

    def test_append_invalid_characters(self):
        c = Classes()
        invalid_name = ' '.join(('foo', 'bar'))
        with self.assertRaises(InvalidClassnameError):
            c.append_if_new(invalid_name)

    def test_merge_unique(self):
        c = Classes(TESTLIST1)
        c.merge_unique(TESTLIST2)
        self.assertSequenceEqual(c, TESTLIST1 + TESTLIST2)

    def test_merge_unique_duplicate1_list(self):
        c = Classes(TESTLIST1)
        c.merge_unique(TESTLIST1)
        self.assertSequenceEqual(c, TESTLIST1)

    def test_merge_unique_duplicate1_instance(self):
        c = Classes(TESTLIST1)
        c.merge_unique(Classes(TESTLIST1))
        self.assertSequenceEqual(c, TESTLIST1)

    def test_merge_unique_duplicate2_list(self):
        c = Classes(TESTLIST1)
        c.merge_unique(TESTLIST2 + TESTLIST2)
        self.assertSequenceEqual(c, TESTLIST1 + TESTLIST2)

    def test_merge_unique_duplicate2_instance(self):
        c = Classes(TESTLIST1)
        c.merge_unique(Classes(TESTLIST2 + TESTLIST2))
        self.assertSequenceEqual(c, TESTLIST1 + TESTLIST2)

    def test_merge_unique_nonstring(self):
        c = Classes()
        with self.assertRaises(TypeError):
            c.merge_unique([0,1,2])

    def test_repr_empty(self):
        c = Classes()
        self.assertEqual('%r' % c, '%s(%r)' % (c.__class__.__name__, []))

    def test_repr_contents(self):
        c = Classes(TESTLIST1)
        self.assertEqual('%r' % c, '%s(%r)' % (c.__class__.__name__, TESTLIST1))

    def test_as_list(self):
        c = Classes(TESTLIST1)
        self.assertListEqual(c.as_list(), TESTLIST1)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_entity
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.datatypes import Entity, Classes, Parameters, Applications
import unittest
try:
    import unittest.mock as mock
except ImportError:
    import mock

@mock.patch.multiple('reclass.datatypes', autospec=True, Classes=mock.DEFAULT,
                     Applications=mock.DEFAULT,
                     Parameters=mock.DEFAULT)
class TestEntity(unittest.TestCase):

    def _make_instances(self, Classes, Applications, Parameters):
        return Classes(), Applications(), Parameters()

    def test_constructor_default(self, **mocks):
        # Actually test the real objects by calling the default constructor,
        # all other tests shall pass instances to the constructor
        e = Entity()
        self.assertEqual(e.name, '')
        self.assertEqual(e.uri, '')
        self.assertIsInstance(e.classes, Classes)
        self.assertIsInstance(e.applications, Applications)
        self.assertIsInstance(e.parameters, Parameters)

    def test_constructor_empty(self, **types):
        instances = self._make_instances(**types)
        e = Entity(*instances)
        self.assertEqual(e.name, '')
        self.assertEqual(e.uri, '')
        cl, al, pl = [getattr(i, '__len__') for i in instances]
        self.assertEqual(len(e.classes), cl.return_value)
        cl.assert_called_once_with()
        self.assertEqual(len(e.applications), al.return_value)
        al.assert_called_once_with()
        self.assertEqual(len(e.parameters), pl.return_value)
        pl.assert_called_once_with()

    def test_constructor_empty_named(self, **types):
        name = 'empty'
        e = Entity(*self._make_instances(**types), name=name)
        self.assertEqual(e.name, name)

    def test_constructor_empty_uri(self, **types):
        uri = 'test://uri'
        e = Entity(*self._make_instances(**types), uri=uri)
        self.assertEqual(e.uri, uri)

    def test_constructor_empty_env(self, **types):
        env = 'not base'
        e = Entity(*self._make_instances(**types), environment=env)
        self.assertEqual(e.environment, env)

    def test_equal_empty(self, **types):
        instances = self._make_instances(**types)
        self.assertEqual(Entity(*instances), Entity(*instances))
        for i in instances:
            i.__eq__.assert_called_once_with(i)

    def test_equal_empty_named(self, **types):
        instances = self._make_instances(**types)
        self.assertEqual(Entity(*instances), Entity(*instances))
        name = 'empty'
        self.assertEqual(Entity(*instances, name=name),
                         Entity(*instances, name=name))

    def test_unequal_empty_uri(self, **types):
        instances = self._make_instances(**types)
        uri = 'test://uri'
        self.assertNotEqual(Entity(*instances, uri=uri),
                            Entity(*instances, uri=uri[::-1]))
        for i in instances:
            i.__eq__.assert_called_once_with(i)

    def test_unequal_empty_named(self, **types):
        instances = self._make_instances(**types)
        name = 'empty'
        self.assertNotEqual(Entity(*instances, name=name),
                            Entity(*instances, name=name[::-1]))
        for i in instances:
            i.__eq__.assert_called_once_with(i)

    def test_unequal_types(self, **types):
        instances = self._make_instances(**types)
        self.assertNotEqual(Entity(*instances, name='empty'),
                            None)
        for i in instances:
            self.assertEqual(i.__eq__.call_count, 0)

    def _test_constructor_wrong_types(self, which_replace, **types):
        instances = self._make_instances(**types)
        instances[which_replace] = 'Invalid type'
        e = Entity(*instances)

    def test_constructor_wrong_type_classes(self, **types):
        self.assertRaises(TypeError, self._test_constructor_wrong_types, 0)

    def test_constructor_wrong_type_applications(self, **types):
        self.assertRaises(TypeError, self._test_constructor_wrong_types, 1)

    def test_constructor_wrong_type_parameters(self, **types):
        self.assertRaises(TypeError, self._test_constructor_wrong_types, 2)

    def test_merge(self, **types):
        instances = self._make_instances(**types)
        e = Entity(*instances)
        e.merge(e)
        for i, fn in zip(instances, ('merge_unique', 'merge_unique', 'merge')):
            getattr(i, fn).assert_called_once_with(i)

    def test_merge_newname(self, **types):
        instances = self._make_instances(**types)
        newname = 'newname'
        e1 = Entity(*instances, name='oldname')
        e2 = Entity(*instances, name=newname)
        e1.merge(e2)
        self.assertEqual(e1.name, newname)

    def test_merge_newuri(self, **types):
        instances = self._make_instances(**types)
        newuri = 'test://uri2'
        e1 = Entity(*instances, uri='test://uri1')
        e2 = Entity(*instances, uri=newuri)
        e1.merge(e2)
        self.assertEqual(e1.uri, newuri)

    def test_merge_newenv(self, **types):
        instances = self._make_instances(**types)
        newenv = 'new env'
        e1 = Entity(*instances, environment='env')
        e2 = Entity(*instances, environment=newenv)
        e1.merge(e2)
        self.assertEqual(e1.environment, newenv)

    def test_as_dict(self, **types):
        instances = self._make_instances(**types)
        entity = Entity(*instances, name='test', environment='test')
        comp = {}
        comp['classes'] = instances[0].as_list()
        comp['applications'] = instances[1].as_list()
        comp['parameters'] = instances[2].as_dict()
        comp['environment'] = 'test'
        d = entity.as_dict()
        self.assertDictEqual(d, comp)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_parameters
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.datatypes import Parameters
from reclass.defaults import PARAMETER_INTERPOLATION_SENTINELS
from reclass.errors import InfiniteRecursionError
import unittest
try:
    import unittest.mock as mock
except ImportError:
    import mock

SIMPLE = {'one': 1, 'two': 2, 'three': 3}

class TestParameters(unittest.TestCase):

    def _construct_mocked_params(self, iterable=None, delimiter=None):
        p = Parameters(iterable, delimiter)
        self._base = base = p._base
        p._base = mock.MagicMock(spec_set=dict, wraps=base)
        p._base.__repr__ = mock.MagicMock(autospec=dict.__repr__,
                                          return_value=repr(base))
        return p, p._base

    def test_len_empty(self):
        p, b = self._construct_mocked_params()
        l = 0
        b.__len__.return_value = l
        self.assertEqual(len(p), l)
        b.__len__.assert_called_with()

    def test_constructor(self):
        p, b = self._construct_mocked_params(SIMPLE)
        l = len(SIMPLE)
        b.__len__.return_value = l
        self.assertEqual(len(p), l)
        b.__len__.assert_called_with()

    def test_repr_empty(self):
        p, b = self._construct_mocked_params()
        b.__repr__.return_value = repr({})
        self.assertEqual('%r' % p, '%s(%r, %r)' % (p.__class__.__name__, {},
                                                   Parameters.DEFAULT_PATH_DELIMITER))
        b.__repr__.assert_called_once_with()

    def test_repr(self):
        p, b = self._construct_mocked_params(SIMPLE)
        b.__repr__.return_value = repr(SIMPLE)
        self.assertEqual('%r' % p, '%s(%r, %r)' % (p.__class__.__name__, SIMPLE,
                                                   Parameters.DEFAULT_PATH_DELIMITER))
        b.__repr__.assert_called_once_with()

    def test_repr_delimiter(self):
        delim = '%'
        p, b = self._construct_mocked_params(SIMPLE, delim)
        b.__repr__.return_value = repr(SIMPLE)
        self.assertEqual('%r' % p, '%s(%r, %r)' % (p.__class__.__name__, SIMPLE, delim))
        b.__repr__.assert_called_once_with()

    def test_equal_empty(self):
        p1, b1 = self._construct_mocked_params()
        p2, b2 = self._construct_mocked_params()
        b1.__eq__.return_value = True
        self.assertEqual(p1, p2)
        b1.__eq__.assert_called_once_with(b2)

    def test_equal_default_delimiter(self):
        p1, b1 = self._construct_mocked_params(SIMPLE)
        p2, b2 = self._construct_mocked_params(SIMPLE,
                                        Parameters.DEFAULT_PATH_DELIMITER)
        b1.__eq__.return_value = True
        self.assertEqual(p1, p2)
        b1.__eq__.assert_called_once_with(b2)

    def test_equal_contents(self):
        p1, b1 = self._construct_mocked_params(SIMPLE)
        p2, b2 = self._construct_mocked_params(SIMPLE)
        b1.__eq__.return_value = True
        self.assertEqual(p1, p2)
        b1.__eq__.assert_called_once_with(b2)

    def test_unequal_content(self):
        p1, b1 = self._construct_mocked_params()
        p2, b2 = self._construct_mocked_params(SIMPLE)
        b1.__eq__.return_value = False
        self.assertNotEqual(p1, p2)
        b1.__eq__.assert_called_once_with(b2)

    def test_unequal_delimiter(self):
        p1, b1 = self._construct_mocked_params(delimiter=':')
        p2, b2 = self._construct_mocked_params(delimiter='%')
        b1.__eq__.return_value = False
        self.assertNotEqual(p1, p2)
        b1.__eq__.assert_called_once_with(b2)

    def test_unequal_types(self):
        p1, b1 = self._construct_mocked_params()
        self.assertNotEqual(p1, None)
        self.assertEqual(b1.__eq__.call_count, 0)

    def test_construct_wrong_type(self):
        with self.assertRaises(TypeError):
            self._construct_mocked_params('wrong type')

    def test_merge_wrong_type(self):
        p, b = self._construct_mocked_params()
        with self.assertRaises(TypeError):
            p.merge('wrong type')

    def test_get_dict(self):
        p, b = self._construct_mocked_params(SIMPLE)
        self.assertDictEqual(p.as_dict(), SIMPLE)

    def test_merge_scalars(self):
        p1, b1 = self._construct_mocked_params(SIMPLE)
        mergee = {'five':5,'four':4,'None':None,'tuple':(1,2,3)}
        p2, b2 = self._construct_mocked_params(mergee)
        p1.merge(p2)
        for key, value in mergee.iteritems():
            # check that each key, value in mergee resulted in a get call and
            # a __setitem__ call against b1 (the merge target)
            self.assertIn(mock.call(key), b1.get.call_args_list)
            self.assertIn(mock.call(key, value), b1.__setitem__.call_args_list)


class TestParametersNoMock(unittest.TestCase):

    def test_merge_scalars(self):
        p = Parameters(SIMPLE)
        mergee = {'five':5,'four':4,'None':None,'tuple':(1,2,3)}
        p.merge(mergee)
        goal = SIMPLE.copy()
        goal.update(mergee)
        self.assertDictEqual(p.as_dict(), goal)

    def test_merge_scalars_overwrite(self):
        p = Parameters(SIMPLE)
        mergee = {'two':5,'four':4,'three':None,'one':(1,2,3)}
        p.merge(mergee)
        goal = SIMPLE.copy()
        goal.update(mergee)
        self.assertDictEqual(p.as_dict(), goal)

    def test_merge_lists(self):
        l1 = [1,2,3]
        l2 = [2,3,4]
        p1 = Parameters(dict(list=l1[:]))
        p2 = Parameters(dict(list=l2))
        p1.merge(p2)
        self.assertListEqual(p1.as_dict()['list'], l1+l2)

    def test_merge_list_into_scalar(self):
        l = ['foo', 1, 2]
        p1 = Parameters(dict(key=l[0]))
        p1.merge(Parameters(dict(key=l[1:])))
        self.assertListEqual(p1.as_dict()['key'], l)

    def test_merge_scalar_over_list(self):
        l = ['foo', 1, 2]
        p1 = Parameters(dict(key=l[:2]))
        p1.merge(Parameters(dict(key=l[2])))
        self.assertEqual(p1.as_dict()['key'], l[2])

    def test_merge_dicts(self):
        mergee = {'five':5,'four':4,'None':None,'tuple':(1,2,3)}
        p = Parameters(dict(dict=SIMPLE))
        p.merge(Parameters(dict(dict=mergee)))
        goal = SIMPLE.copy()
        goal.update(mergee)
        self.assertDictEqual(p.as_dict(), dict(dict=goal))

    def test_merge_dicts_overwrite(self):
        mergee = {'two':5,'four':4,'three':None,'one':(1,2,3)}
        p = Parameters(dict(dict=SIMPLE))
        p.merge(Parameters(dict(dict=mergee)))
        goal = SIMPLE.copy()
        goal.update(mergee)
        self.assertDictEqual(p.as_dict(), dict(dict=goal))

    def test_merge_dict_into_scalar(self):
        p = Parameters(dict(base='foo'))
        with self.assertRaises(TypeError):
            p.merge(Parameters(dict(base=SIMPLE)))

    def test_merge_scalar_over_dict(self):
        p = Parameters(dict(base=SIMPLE))
        mergee = {'base':'foo'}
        p.merge(Parameters(mergee))
        self.assertDictEqual(p.as_dict(), mergee)

    def test_interpolate_single(self):
        v = 42
        d = {'foo': 'bar'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'bar': v}
        p = Parameters(d)
        p.interpolate()
        self.assertEqual(p.as_dict()['foo'], v)

    def test_interpolate_multiple(self):
        v = '42'
        d = {'foo': 'bar'.join(PARAMETER_INTERPOLATION_SENTINELS) + 'meep'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'bar': v[0],
             'meep': v[1]}
        p = Parameters(d)
        p.interpolate()
        self.assertEqual(p.as_dict()['foo'], v)

    def test_interpolate_multilevel(self):
        v = 42
        d = {'foo': 'bar'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'bar': 'meep'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'meep': v}
        p = Parameters(d)
        p.interpolate()
        self.assertEqual(p.as_dict()['foo'], v)

    def test_interpolate_list(self):
        l = [41,42,43]
        d = {'foo': 'bar'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'bar': l}
        p = Parameters(d)
        p.interpolate()
        self.assertEqual(p.as_dict()['foo'], l)

    def test_interpolate_infrecursion(self):
        v = 42
        d = {'foo': 'bar'.join(PARAMETER_INTERPOLATION_SENTINELS),
             'bar': 'foo'.join(PARAMETER_INTERPOLATION_SENTINELS)}
        p = Parameters(d)
        with self.assertRaises(InfiniteRecursionError):
            p.interpolate()

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = defaults
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
import os, sys
from version import RECLASS_NAME

# defaults for the command-line options
OPT_STORAGE_TYPE = 'yaml_fs'
OPT_INVENTORY_BASE_URI = os.path.join('/etc', RECLASS_NAME)
OPT_NODES_URI = 'nodes'
OPT_CLASSES_URI = 'classes'
OPT_PRETTY_PRINT = True
OPT_OUTPUT = 'yaml'

CONFIG_FILE_SEARCH_PATH = [os.getcwd(),
                           os.path.expanduser('~'),
                           OPT_INVENTORY_BASE_URI,
                           os.path.dirname(sys.argv[0])
                          ]
CONFIG_FILE_NAME = RECLASS_NAME + '-config.yml'

PARAMETER_INTERPOLATION_SENTINELS = ('${', '}')
PARAMETER_INTERPOLATION_DELIMITER = ':'

########NEW FILE########
__FILENAME__ = errors
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import posix, sys
import traceback

from reclass.defaults import PARAMETER_INTERPOLATION_SENTINELS

class ReclassException(Exception):

    def __init__(self, rc=posix.EX_SOFTWARE, msg=None):
        super(ReclassException, self).__init__()
        self._rc = rc
        self._msg = msg
        self._traceback = traceback.format_exc()

    message = property(lambda self: self._get_message())
    rc = property(lambda self: self._rc)

    def _get_message(self):
        if self._msg:
            return self._msg
        else:
            return 'No error message provided.'

    def exit_with_message(self, out=sys.stderr):
        print >>out, self.message
        if self._traceback:
            print >>out, self._traceback
        sys.exit(self.rc)


class PermissionError(ReclassException):

    def __init__(self, msg, rc=posix.EX_NOPERM):
        super(PermissionError, self).__init__(rc=rc, msg=msg)


class InvocationError(ReclassException):

    def __init__(self, msg, rc=posix.EX_USAGE):
        super(InvocationError, self).__init__(rc=rc, msg=msg)


class ConfigError(ReclassException):

    def __init__(self, msg, rc=posix.EX_CONFIG):
        super(ConfigError, self).__init__(rc=rc, msg=msg)


class DuplicateUriError(ConfigError):

    def __init__(self, nodes_uri, classes_uri):
        super(DuplicateUriError, self).__init__(msg=None)
        self._nodes_uri = nodes_uri
        self._classes_uri = classes_uri

    def _get_message(self):
        return "The inventory URIs must not be the same " \
               "for nodes and classes: {0}".format(self._nodes_uri)


class UriOverlapError(ConfigError):

    def __init__(self, nodes_uri, classes_uri):
        super(UriOverlapError, self).__init__(msg=None)
        self._nodes_uri = nodes_uri
        self._classes_uri = classes_uri

    def _get_message(self):
        msg = "The URIs for the nodes and classes inventories must not " \
              "overlap, but {0} and {1} do."
        return msg.format(self._nodes_uri, self._classes_uri)


class NotFoundError(ReclassException):

    def __init__(self, msg, rc=posix.EX_IOERR):
        super(NotFoundError, self).__init__(rc=rc, msg=msg)


class NodeNotFound(NotFoundError):

    def __init__(self, storage, nodename, uri):
        super(NodeNotFound, self).__init__(msg=None)
        self._storage = storage
        self._name = nodename
        self._uri = uri

    def _get_message(self):
        msg = "Node '{0}' not found under {1}://{2}"
        return msg.format(self._name, self._storage, self._uri)


class ClassNotFound(NotFoundError):

    def __init__(self, storage, classname, uri, nodename=None):
        super(ClassNotFound, self).__init__(msg=None)
        self._storage = storage
        self._name = classname
        self._uri = uri
        self._nodename = nodename

    def _get_message(self):
        if self._nodename:
            msg = "Class '{0}' (in ancestry of node '{1}') not found " \
                  "under {2}://{3}"
        else:
            msg = "Class '{0}' not found under {2}://{3}"
        return msg.format(self._name, self._nodename, self._storage, self._uri)

    def set_nodename(self, nodename):
        self._nodename = nodename


class InterpolationError(ReclassException):

    def __init__(self, msg, rc=posix.EX_DATAERR):
        super(InterpolationError, self).__init__(rc=rc, msg=msg)


class UndefinedVariableError(InterpolationError):

    def __init__(self, var, context=None):
        super(UndefinedVariableError, self).__init__(msg=None)
        self._var = var
        self._context = context

    def _get_message(self):
        msg = "Cannot resolve " + var.join(PARAMETER_INTERPOLATION_SENTINELS)
        if self._context:
            msg += ' in the context of %s' % self._context
        return msg

    def set_context(self, context):
        self._context = context


class IncompleteInterpolationError(InterpolationError):

    def __init__(self, string, end_sentinel):
        super(IncompleteInterpolationError, self).__init__(msg=None)
        self._ref = string.join(PARAMETER_INTERPOLATION_SENTINELS)
        self._end_sentinel = end_sentinel

    def _get_message(self):
        msg = "Missing '{0}' to end reference: {1}"
        return msg.format(self._end_sentinel, self._ref)


class InfiniteRecursionError(InterpolationError):

    def __init__(self, path, ref):
        super(InfiniteRecursionError, self).__init__(msg=None)
        self._path = path
        self._ref = ref.join(PARAMETER_INTERPOLATION_SENTINELS)

    def _get_message(self):
        msg = "Infinite recursion while resolving {0} at {1}"
        return msg.format(self._ref, self._path)


class MappingError(ReclassException):

    def __init__(self, msg, rc=posix.EX_DATAERR):
        super(MappingError, self).__init__(rc=rc, msg=msg)


class MappingFormatError(MappingError):

    def __init__(self, msg):
        super(MappingFormatError, self).__init__(msg)


class NameError(ReclassException):

    def __init__(self, msg, rc=posix.EX_DATAERR):
        super(NameError, self).__init__(rc=rc, msg=msg)


class InvalidClassnameError(NameError):

    def __init__(self, invalid_character, classname):
        super(InvalidClassnameError, self).__init__(msg=None)
        self._char = invalid_character
        self._classname = classname

    def _get_message(self):
        msg = "Invalid character '{0}' in class name '{1}'."
        return msg.format(self._char, classname)


class DuplicateNodeNameError(NameError):

    def __init__(self, storage, name, uri1, uri2):
        super(DuplicateNodeNameError, self).__init__(msg=None)
        self._storage = storage
        self._name = name
        self._uris = (uri1, uri2)

    def _get_message(self):
        msg = "{0}: Definition of node '{1}' in '{2}' collides with " \
              "definition in '{3}'. Nodes can only be defined once " \
              "per inventory."
        return msg.format(self._storage, self._name, self._uris[1], self._uris[0])

########NEW FILE########
__FILENAME__ = json_outputter
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.output import OutputterBase
import json

class Outputter(OutputterBase):

    def dump(self, data, pretty_print=False):
        separators = (',', ': ') if pretty_print else (',', ':')
        indent = 2 if pretty_print else None
        return json.dumps(data, indent=indent, separators=separators)

########NEW FILE########
__FILENAME__ = yaml_outputter
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.output import OutputterBase
import yaml

class Outputter(OutputterBase):

    def dump(self, data, pretty_print=False):
        return yaml.dump(data, default_flow_style=not pretty_print)

########NEW FILE########
__FILENAME__ = loader
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

class StorageBackendLoader(object):

    def __init__(self, storage_name):
        self._name = 'reclass.storage.' + storage_name
        try:
            self._module = __import__(self._name, globals(), locals(), self._name)
        except ImportError:
            raise NotImplementedError

    def load(self, klassname='ExternalNodeStorage'):
        klass = getattr(self._module, klassname, None)
        if klass is None:
            raise AttributeError('Storage backend class {0} does not export '
                                 '"{1}"'.format(self._name, klassname))

        return klass

########NEW FILE########
__FILENAME__ = memcache_proxy
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

from reclass.storage import NodeStorageBase

STORAGE_NAME = 'memcache_proxy'

class MemcacheProxy(NodeStorageBase):

    def __init__(self, real_storage, cache_classes=True, cache_nodes=True,
                 cache_nodelist=True):
        name = '{0}({1})'.format(STORAGE_NAME, real_storage.name)
        super(MemcacheProxy, self).__init__(name)
        self._real_storage = real_storage
        self._cache_classes = cache_classes
        if cache_classes:
            self._classes_cache = {}
        self._cache_nodes = cache_nodes
        if cache_nodes:
            self._nodes_cache = {}
        self._cache_nodelist = cache_nodelist
        if cache_nodelist:
            self._nodelist_cache = None

    name = property(lambda self: self._real_storage.name)

    @staticmethod
    def _cache_proxy(name, cache, getter):
        try:
            ret = cache[name]

        except KeyError, e:
            ret = getter(name)
            cache[name] = ret

        return ret

    def get_node(self, name):
        if not self._cache_nodes:
            return self._real_storage.get_node(name)

        return MemcacheProxy._cache_proxy(name, self._nodes_cache,
                                          self._real_storage.get_node)

    def get_class(self, name):
        if not self._cache_classes:
            return self._real_storage.get_class(name)

        return MemcacheProxy._cache_proxy(name, self._classes_cache,
                                          self._real_storage.get_class)

    def enumerate_nodes(self):
        if not self._cache_nodelist:
            return self._real_storage.enumerate_nodes()

        elif self._nodelist_cache is None:
            self._nodelist_cache = self._real_storage.enumerate_nodes()

        return self._nodelist_cache

########NEW FILE########
__FILENAME__ = test_loader
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.storage.loader import StorageBackendLoader

import unittest

class TestLoader(unittest.TestCase):

    def test_load(self):
        loader = StorageBackendLoader('yaml_fs')
        from reclass.storage.yaml_fs import ExternalNodeStorage as YamlFs
        self.assertEqual(loader.load(), YamlFs)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_memcache_proxy
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.storage.memcache_proxy import MemcacheProxy
from reclass.storage import NodeStorageBase

import unittest
try:
    import unittest.mock as mock
except ImportError:
    import mock

class TestMemcacheProxy(unittest.TestCase):

    def setUp(self):
        self._storage = mock.MagicMock(spec_set=NodeStorageBase)

    def test_no_nodes_caching(self):
        p = MemcacheProxy(self._storage, cache_nodes=False)
        NAME = 'foo'; NAME2 = 'bar'; RET = 'baz'
        self._storage.get_node.return_value = RET
        self.assertEqual(p.get_node(NAME), RET)
        self.assertEqual(p.get_node(NAME), RET)
        self.assertEqual(p.get_node(NAME2), RET)
        self.assertEqual(p.get_node(NAME2), RET)
        expected = [mock.call(NAME), mock.call(NAME),
                    mock.call(NAME2), mock.call(NAME2)]
        self.assertListEqual(self._storage.get_node.call_args_list, expected)

    def test_nodes_caching(self):
        p = MemcacheProxy(self._storage, cache_nodes=True)
        NAME = 'foo'; NAME2 = 'bar'; RET = 'baz'
        self._storage.get_node.return_value = RET
        self.assertEqual(p.get_node(NAME), RET)
        self.assertEqual(p.get_node(NAME), RET)
        self.assertEqual(p.get_node(NAME2), RET)
        self.assertEqual(p.get_node(NAME2), RET)
        expected = [mock.call(NAME), mock.call(NAME2)] # called once each
        self.assertListEqual(self._storage.get_node.call_args_list, expected)

    def test_no_classes_caching(self):
        p = MemcacheProxy(self._storage, cache_classes=False)
        NAME = 'foo'; NAME2 = 'bar'; RET = 'baz'
        self._storage.get_class.return_value = RET
        self.assertEqual(p.get_class(NAME), RET)
        self.assertEqual(p.get_class(NAME), RET)
        self.assertEqual(p.get_class(NAME2), RET)
        self.assertEqual(p.get_class(NAME2), RET)
        expected = [mock.call(NAME), mock.call(NAME),
                    mock.call(NAME2), mock.call(NAME2)]
        self.assertListEqual(self._storage.get_class.call_args_list, expected)

    def test_classes_caching(self):
        p = MemcacheProxy(self._storage, cache_classes=True)
        NAME = 'foo'; NAME2 = 'bar'; RET = 'baz'
        self._storage.get_class.return_value = RET
        self.assertEqual(p.get_class(NAME), RET)
        self.assertEqual(p.get_class(NAME), RET)
        self.assertEqual(p.get_class(NAME2), RET)
        self.assertEqual(p.get_class(NAME2), RET)
        expected = [mock.call(NAME), mock.call(NAME2)] # called once each
        self.assertListEqual(self._storage.get_class.call_args_list, expected)

    def test_nodelist_no_caching(self):
        p = MemcacheProxy(self._storage, cache_nodelist=False)
        p.enumerate_nodes()
        p.enumerate_nodes()
        expected = [mock.call(), mock.call()]
        self.assertListEqual(self._storage.enumerate_nodes.call_args_list, expected)

    def test_nodelist_caching(self):
        p = MemcacheProxy(self._storage, cache_nodelist=True)
        p.enumerate_nodes()
        p.enumerate_nodes()
        expected = [mock.call()] # once only
        self.assertListEqual(self._storage.enumerate_nodes.call_args_list, expected)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = directory
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
import os
import sys
from reclass.errors import NotFoundError

SKIPDIRS = ( 'CVS', 'SCCS' )
FILE_EXTENSION = '.yml'

def vvv(msg):
    #print >>sys.stderr, msg
    pass

class Directory(object):

    def __init__(self, path, fileclass=None):
        ''' Initialise a directory object '''
        if not os.path.isdir(path):
            raise NotFoundError('No such directory: %s' % path)
        if not os.access(path, os.R_OK|os.X_OK):
            raise NotFoundError('Cannot change to or read directory: %s' % path)
        self._path = path
        self._fileclass = fileclass
        self._files = {}

    def _register_files(self, dirpath, filenames):
        for f in filter(lambda f: f.endswith(FILE_EXTENSION), filenames):
            vvv('REGISTER {0}'.format(f))
            f = os.path.join(dirpath, f)
            ptr = None if not self._fileclass else self._fileclass(f)
            self._files[f] = ptr

    files = property(lambda self: self._files)

    def walk(self, register_fn=None):
        if not callable(register_fn): register_fn = self._register_files

        def _error(exc):
            raise(exc)

        for dirpath, dirnames, filenames in os.walk(self._path,
                                                    topdown=True,
                                                    onerror=_error,
                                                    followlinks=True):
            vvv('RECURSE {0}, {1} files, {2} subdirectories'.format(
                dirpath.replace(os.getcwd(), '.'), len(filenames), len(dirnames)))
            for d in dirnames:
                if d.startswith('.') or d in SKIPDIRS:
                    vvv('   SKIP subdirectory {0}'.format(d))
                    dirnames.remove(d)
            register_fn(dirpath, filenames)

    def __repr__(self):
        return '<{0} {1}>'.format(self.__class__.__name__, self._path)

########NEW FILE########
__FILENAME__ = yamlfile
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass import datatypes
import yaml
import os
from reclass.errors import NotFoundError

class YamlFile(object):

    def __init__(self, path):
        ''' Initialise a yamlfile object '''
        if not os.path.isfile(path):
            raise NotFoundError('No such file: %s' % path)
        if not os.access(path, os.R_OK):
            raise NotFoundError('Cannot open: %s' % path)
        self._path = path
        self._data = dict()
        self._read()
    path = property(lambda self: self._path)

    def _read(self):
        fp = file(self._path)
        data = yaml.safe_load(fp)
        if data is not None:
            self._data = data
        fp.close()

    def get_entity(self, name=None, default_environment=None):
        classes = self._data.get('classes')
        if classes is None:
            classes = []
        classes = datatypes.Classes(classes)

        applications = self._data.get('applications')
        if applications is None:
            applications = []
        applications = datatypes.Applications(applications)

        parameters = self._data.get('parameters')
        if parameters is None:
            parameters = {}
        parameters = datatypes.Parameters(parameters)

        env = self._data.get('environment', default_environment)

        if name is None:
            name = self._path

        return datatypes.Entity(classes, applications, parameters,
                                name=name, environment=env,
                                uri='yaml_fs://{0}'.format(self._path))

    def __repr__(self):
        return '<{0} {1}, {2}>'.format(self.__class__.__name__, self._path,
                                       self._data.keys())

########NEW FILE########
__FILENAME__ = dictpath
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import types, re

class DictPath(object):
    '''
    Represents a path into a nested dictionary.

    Given a dictionary like

      d['foo']['bar'] = 42

    it can be desirable to obtain a reference to the value stored in the
    sub-levels, allowing that value to be accessed and changed. Unfortunately,
    Python provides no easy way to do this, since

      ref = d['foo']['bar']

    does become a reference to the integer 42, but that reference is
    overwritten when one assigns to it. Hence, DictPath represents the path
    into a nested dictionary, and can be "applied to" a dictionary to obtain
    and set values, using a list of keys, or a string representation using
    a delimiter (which can be escaped):

      p = DictPath(':', 'foo:bar')
      p.get_value(d)
      p.set_value(d, 43)

    This is a bit backwards, but the right way around would require support by
    the dict() type.

    The primary purpose of this class within reclass is to cater for parameter
    interpolation, so that a reference such as ${foo:bar} in a parameter value
    may be resolved in the context of the Parameter collections (a nested
    dict).

    If the value is a list, then the "key" is assumed to be and interpreted as
    an integer index:

      d = {'list': [{'one':1},{'two':2}]}
      p = DictPath(':', 'list:1:two')
      p.get_value(d)  → 2

    This heuristic is okay within reclass, because dictionary keys (parameter
    names) will always be strings. Therefore it is okay to interpret each
    component of the path as a string, unless one finds a list at the current
    level down the nested dictionary.
    '''

    def __init__(self, delim, contents=None):
        self._delim = delim
        if contents is None:
            self._parts = []
        else:
            if isinstance(contents, types.StringTypes):
                self._parts = self._split_string(contents)
            elif isinstance(contents, tuple):
                self._parts = list(contents)
            elif isinstance(contents, list):
                self._parts = contents
            else:
                raise TypeError('DictPath() takes string or list, '\
                                'not %s' % type(contents))

    def __repr__(self):
        return "DictPath(%r, %r)" % (self._delim, str(self))

    def __str__(self):
        return self._delim.join(str(i) for i in self._parts)

    def __eq__(self, other):
        if isinstance(other, types.StringTypes):
            other = DictPath(self._delim, other)

        return self._parts == other._parts \
                and self._delim == other._delim

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(str(self))

    def _get_path(self):
        return self._parts
    path = property(_get_path)

    def _get_key(self):
        if len(self._parts) == 0:
            return None
        return self._parts[-1]

    def _get_innermost_container(self, base):
        container = base
        for i in self.path[:-1]:
            if isinstance(container, (list, tuple)):
                container = container[int(i)]
            else:
                container = container[i]
        return container

    def _split_string(self, string):
        return re.split(r'(?<!\\)' + re.escape(self._delim), string)

    def _escape_string(self, string):
        return string.replace(self._delim, '\\' + self._delim)

    def new_subpath(self, key):
        try:
            return DictPath(self._delim, self._parts + [self._escape_string(key)])
        except AttributeError as e:
            return DictPath(self._delim, self._parts + [key])

    def get_value(self, base):
        return self._get_innermost_container(base)[self._get_key()]

    def set_value(self, base, value):
        self._get_innermost_container(base)[self._get_key()] = value

########NEW FILE########
__FILENAME__ = refvalue
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import re

from reclass.utils.dictpath import DictPath
from reclass.defaults import PARAMETER_INTERPOLATION_SENTINELS, \
        PARAMETER_INTERPOLATION_DELIMITER
from reclass.errors import IncompleteInterpolationError, \
        UndefinedVariableError

_SENTINELS = [re.escape(s) for s in PARAMETER_INTERPOLATION_SENTINELS]
_RE = '{0}\s*(.+?)\s*{1}'.format(*_SENTINELS)

class RefValue(object):
    '''
    Isolates references in string values

    RefValue can be used to isolate and eventually expand references to other
    parameters in strings. Those references can then be iterated and rendered
    in the context of a dictionary to resolve those references.

    RefValue always gets constructed from a string, because templating
    — essentially this is what's going on — is necessarily always about
    strings. Therefore, generally, the rendered value of a RefValue instance
    will also be a string.

    Nevertheless, as this might not be desirable, RefValue will return the
    referenced variable without casting it to a string, if the templated
    string contains nothing but the reference itself.

    For instance:

      mydict = {'favcolour': 'yellow', 'answer': 42, 'list': [1,2,3]}
      RefValue('My favourite colour is ${favolour}').render(mydict)
      → 'My favourite colour is yellow'      # a string

      RefValue('The answer is ${answer}').render(mydict)
      → 'The answer is 42'                   # a string

      RefValue('${answer}').render(mydict)
      → 42                                   # an int

      RefValue('${list}').render(mydict)
      → [1,2,3]                              # an list

    The markers used to identify references are set in reclass.defaults, as is
    the default delimiter.
    '''

    INTERPOLATION_RE = re.compile(_RE)

    def __init__(self, string, delim=PARAMETER_INTERPOLATION_DELIMITER):
        self._strings = []
        self._refs = []
        self._delim = delim
        self._parse(string)

    def _parse(self, string):
        parts = RefValue.INTERPOLATION_RE.split(string)
        self._refs = parts[1:][::2]
        self._strings = parts[0:][::2]
        self._check_strings(string)

    def _check_strings(self, orig):
        for s in self._strings:
            pos = s.find(PARAMETER_INTERPOLATION_SENTINELS[0])
            if pos >= 0:
                raise IncompleteInterpolationError(orig,
                                                   PARAMETER_INTERPOLATION_SENTINELS[1])

    def _resolve(self, ref, context):
        path = DictPath(self._delim, ref)
        try:
            return path.get_value(context)
        except KeyError as e:
            raise UndefinedVariableError(ref)

    def has_references(self):
        return len(self._refs) > 0

    def get_references(self):
        return self._refs

    def _assemble(self, resolver):
        if not self.has_references():
            return self._strings[0]

        if self._strings == ['', '']:
            # preserve the type of the referenced variable
            return resolver(self._refs[0])

        # reassemble the string by taking a string and str(ref) pairwise
        ret = ''
        for i in range(0, len(self._refs)):
            ret += self._strings[i] + str(resolver(self._refs[i]))
        if len(self._strings) > len(self._refs):
            # and finally append a trailing string, if any
            ret += self._strings[-1]
        return ret

    def render(self, context):
        resolver = lambda s: self._resolve(s, context)
        return self._assemble(resolver)

    def __repr__(self):
        do_not_resolve = lambda s: s.join(PARAMETER_INTERPOLATION_SENTINELS)
        return 'RefValue(%r, %r)' % (self._assemble(do_not_resolve),
                                     self._delim)

########NEW FILE########
__FILENAME__ = test_dictpath
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
from reclass.utils.dictpath import DictPath
import unittest

class TestDictPath(unittest.TestCase):

    def test_constructor0(self):
        p = DictPath(':')
        self.assertListEqual(p._parts, [])

    def test_constructor_list(self):
        l = ['a', 'b', 'c']
        p = DictPath(':', l)
        self.assertListEqual(p._parts, l)

    def test_constructor_str(self):
        delim = ':'
        s = 'a{0}b{0}c'.format(delim)
        l = ['a', 'b', 'c']
        p = DictPath(delim, s)
        self.assertListEqual(p._parts, l)

    def test_constructor_str_escaped(self):
        delim = ':'
        s = 'a{0}b\{0}b{0}c'.format(delim)
        l = ['a', 'b\\{0}b'.format(delim), 'c']
        p = DictPath(delim, s)
        self.assertListEqual(p._parts, l)

    def test_constructor_invalid_type(self):
        with self.assertRaises(TypeError):
            p = DictPath(':', 5)

    def test_equality(self):
        delim = ':'
        s = 'a{0}b{0}c'.format(delim)
        l = ['a', 'b', 'c']
        p1 = DictPath(delim, s)
        p2 = DictPath(delim, l)
        self.assertEqual(p1, p2)

    def test_inequality_content(self):
        delim = ':'
        s = 'a{0}b{0}c'.format(delim)
        l = ['d', 'e', 'f']
        p1 = DictPath(delim, s)
        p2 = DictPath(delim, l)
        self.assertNotEqual(p1, p2)

    def test_inequality_delimiter(self):
        l = ['a', 'b', 'c']
        p1 = DictPath(':', l)
        p2 = DictPath('%', l)
        self.assertNotEqual(p1, p2)

    def test_repr(self):
        delim = '%'
        s = 'a:b\:b:c'
        p = DictPath(delim, s)
        self.assertEqual('%r' % p, 'DictPath(%r, %r)' % (delim, s))

    def test_str(self):
        s = 'a:b\:b:c'
        p = DictPath(':', s)
        self.assertEqual(str(p), s)

    def test_path_accessor(self):
        l = ['a', 'b', 'c']
        p = DictPath(':', l)
        self.assertListEqual(p.path, l)

    def test_new_subpath(self):
        l = ['a', 'b', 'c']
        p = DictPath(':', l[:-1])
        p = p.new_subpath(l[-1])
        self.assertListEqual(p.path, l)

    def test_get_value(self):
        v = 42
        l = ['a', 'b', 'c']
        d = {'a':{'b':{'c':v}}}
        p = DictPath(':', l)
        self.assertEqual(p.get_value(d), v)

    def test_get_value_escaped(self):
        v = 42
        l = ['a', 'b:b', 'c']
        d = {'a':{'b:b':{'c':v}}}
        p = DictPath(':', l)
        self.assertEqual(p.get_value(d), v)

    def test_get_value_listindex_list(self):
        v = 42
        l = ['a', 1, 'c']
        d = {'a':[None, {'c':v}, None]}
        p = DictPath(':', l)
        self.assertEqual(p.get_value(d), v)

    def test_get_value_listindex_str(self):
        v = 42
        s = 'a:1:c'
        d = {'a':[None, {'c':v}, None]}
        p = DictPath(':', s)
        self.assertEqual(p.get_value(d), v)

    def test_set_value(self):
        v = 42
        l = ['a', 'b', 'c']
        d = {'a':{'b':{'c':v}}}
        p = DictPath(':', l)
        p.set_value(d, v+1)
        self.assertEqual(d['a']['b']['c'], v+1)

    def test_set_value_escaped(self):
        v = 42
        l = ['a', 'b:b', 'c']
        d = {'a':{'b:b':{'c':v}}}
        p = DictPath(':', l)
        p.set_value(d, v+1)
        self.assertEqual(d['a']['b:b']['c'], v+1)

    def test_set_value_escaped_listindex_list(self):
        v = 42
        l = ['a', 1, 'c']
        d = {'a':[None, {'c':v}, None]}
        p = DictPath(':', l)
        p.set_value(d, v+1)
        self.assertEqual(d['a'][1]['c'], v+1)

    def test_set_value_escaped_listindex_str(self):
        v = 42
        s = 'a:1:c'
        d = {'a':[None, {'c':v}, None]}
        p = DictPath(':', s)
        p.set_value(d, v+1)
        self.assertEqual(d['a'][1]['c'], v+1)

    def test_get_nonexistent_value(self):
        l = ['a', 'd']
        p = DictPath(':', l)
        with self.assertRaises(KeyError):
            p.get_value(dict())

    def test_set_nonexistent_value(self):
        l = ['a', 'd']
        p = DictPath(':', l)
        with self.assertRaises(KeyError):
            p.set_value(dict(), 42)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_refvalue
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

from reclass.utils.refvalue import RefValue
from reclass.defaults import PARAMETER_INTERPOLATION_SENTINELS, \
        PARAMETER_INTERPOLATION_DELIMITER
from reclass.errors import UndefinedVariableError, \
        IncompleteInterpolationError
import unittest

def _var(s):
    return '%s%s%s' % (PARAMETER_INTERPOLATION_SENTINELS[0], s,
                       PARAMETER_INTERPOLATION_SENTINELS[1])

CONTEXT = {'favcolour':'yellow',
           'motd':{'greeting':'Servus!',
                   'colour':'${favcolour}'
                  },
           'int':1,
           'list':[1,2,3],
           'dict':{1:2,3:4},
           'bool':True
          }

def _poor_mans_template(s, var, value):
    return s.replace(_var(var), value)

class TestRefValue(unittest.TestCase):

    def test_simple_string(self):
        s = 'my cat likes to hide in boxes'
        tv = RefValue(s)
        self.assertFalse(tv.has_references())
        self.assertEquals(tv.render(CONTEXT), s)

    def _test_solo_ref(self, key):
        s = _var(key)
        tv = RefValue(s)
        res = tv.render(CONTEXT)
        self.assertTrue(tv.has_references())
        self.assertEqual(res, CONTEXT[key])

    def test_solo_ref_string(self):
        self._test_solo_ref('favcolour')

    def test_solo_ref_int(self):
        self._test_solo_ref('int')

    def test_solo_ref_list(self):
        self._test_solo_ref('list')

    def test_solo_ref_dict(self):
        self._test_solo_ref('dict')

    def test_solo_ref_bool(self):
        self._test_solo_ref('bool')

    def test_single_subst_bothends(self):
        s = 'I like ' + _var('favcolour') + ' and I like it'
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        self.assertEqual(tv.render(CONTEXT),
                         _poor_mans_template(s, 'favcolour',
                                             CONTEXT['favcolour']))

    def test_single_subst_start(self):
        s = _var('favcolour') + ' is my favourite colour'
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        self.assertEqual(tv.render(CONTEXT),
                         _poor_mans_template(s, 'favcolour',
                                             CONTEXT['favcolour']))

    def test_single_subst_end(self):
        s = 'I like ' + _var('favcolour')
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        self.assertEqual(tv.render(CONTEXT),
                         _poor_mans_template(s, 'favcolour',
                                             CONTEXT['favcolour']))

    def test_deep_subst_solo(self):
        var = PARAMETER_INTERPOLATION_DELIMITER.join(('motd', 'greeting'))
        s = _var(var)
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        self.assertEqual(tv.render(CONTEXT),
                         _poor_mans_template(s, var,
                                             CONTEXT['motd']['greeting']))

    def test_multiple_subst(self):
        greet = PARAMETER_INTERPOLATION_DELIMITER.join(('motd', 'greeting'))
        s = _var(greet) + ' I like ' + _var('favcolour') + '!'
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        want = _poor_mans_template(s, greet, CONTEXT['motd']['greeting'])
        want = _poor_mans_template(want, 'favcolour', CONTEXT['favcolour'])
        self.assertEqual(tv.render(CONTEXT), want)

    def test_multiple_subst_flush(self):
        greet = PARAMETER_INTERPOLATION_DELIMITER.join(('motd', 'greeting'))
        s = _var(greet) + ' I like ' + _var('favcolour')
        tv = RefValue(s)
        self.assertTrue(tv.has_references())
        want = _poor_mans_template(s, greet, CONTEXT['motd']['greeting'])
        want = _poor_mans_template(want, 'favcolour', CONTEXT['favcolour'])
        self.assertEqual(tv.render(CONTEXT), want)

    def test_undefined_variable(self):
        s = _var('no_such_variable')
        tv = RefValue(s)
        with self.assertRaises(UndefinedVariableError):
            tv.render(CONTEXT)

    def test_incomplete_variable(self):
        s = PARAMETER_INTERPOLATION_SENTINELS[0] + 'incomplete'
        with self.assertRaises(IncompleteInterpolationError):
            tv = RefValue(s)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = version
#
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–14 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#
RECLASS_NAME = 'reclass'
DESCRIPTION = 'merge data by recursive descent down an ancestry hierarchy'
VERSION = '1.3'
AUTHOR = 'martin f. krafft'
AUTHOR_EMAIL = 'reclass@pobox.madduck.net'
COPYRIGHT = 'Copyright © 2007–14 ' + AUTHOR
LICENCE = 'Artistic Licence 2.0'
URL = 'https://github.com/madduck/reclass'

########NEW FILE########
__FILENAME__ = reclass
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–13 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import reclass.cli
reclass.cli.main()

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This file is part of reclass (http://github.com/madduck/reclass)
#
# Copyright © 2007–13 martin f. krafft <madduck@madduck.net>
# Released under the terms of the Artistic Licence 2.0
#

import unittest
tests = unittest.TestLoader().discover('reclass')
unittest.TextTestRunner(verbosity=1).run(tests)

########NEW FILE########
