__FILENAME__ = haproxy_autoscale
from boto.ec2 import EC2Connection
from boto.ec2.securitygroup import SecurityGroup
import logging
from mako.template import Template
import urllib2

__version__ = '0.4'

def get_self_instance_id():
    '''
    Get this instance's id.
    '''
    logging.debug('get_self_instance_id()')
    response = urllib2.urlopen('http://169.254.169.254/1.0/meta-data/instance-id')
    instance_id = response.read()
    return instance_id


def steal_elastic_ip(access_key=None, secret_key=None, ip=None):
    '''
    Assign an elastic IP to this instance.
    '''
    logging.debug('steal_elastic_ip()')
    instance_id = get_self_instance_id()
    conn = EC2Connection(aws_access_key_id=access_key,
                         aws_secret_access_key=secret_key)
    conn.associate_address(instance_id=instance_id, public_ip=ip)


def get_running_instances(access_key=None, secret_key=None, security_group=None):
    '''
    Get all running instances. Only within a security group if specified.
    '''
    logging.debug('get_running_instances()')

    instances_all_regions_list = []
    conn = EC2Connection(aws_access_key_id=access_key,
                         aws_secret_access_key=secret_key)
    ec2_region_list = conn.get_all_regions()

    if security_group:
        for index, region in enumerate(ec2_region_list):
            conn = EC2Connection(aws_access_key_id=access_key,
                                 aws_secret_access_key=secret_key,
                                 region=ec2_region_list[index])
            running_instances = []
            for s in conn.get_all_security_groups():
               if s.name == security_group:
                   running_instances = [i for i in s.instances() if i.state == 'running']
            if running_instances:
                for instance in running_instances:
                    instances_all_regions_list.append(instance)
    else:
        for index, region in enumerate(ec2_region_list):
            conn = EC2Connection(aws_access_key_id=access_key,
                                 aws_secret_access_key=secret_key,
                                 region=ec2_region_list[index])
            reserved_instances = conn.get_all_instances()
            if reserved_instances:
                for reservation in reserved_instances:
                    for instance in reservation.instances:
                        if instance.stat == 'running':
                            instances_all_regions_list.append(instance)
    return instances_all_regions_list


def file_contents(filename=None, content=None):
    '''
    Just return the contents of a file as a string or write if content
    is specified. Returns the contents of the filename either way.
    '''
    logging.debug('file_contents()')
    if content:
        f = open(filename, 'w')
        f.write(content)
        f.close()
    
    try:
        f = open(filename, 'r')
        text = f.read()
        f.close()
    except:
        text = None

    return text


def generate_haproxy_config(template=None, instances=None):
    '''
    Generate an haproxy configuration based on the template and instances list.
    '''
    return Template(filename=template).render(instances=instances)


class Backends():
    # instances without these tags will be excluded from backends
    required_keys = ['AppName',
                     'AppPort']

    backend_templates = {'default': {'mode':'http',
                                     'option':'httpchk',
                                     'balance':'roundrobin'},
                         'ssl-backend': {'mode':'https',
                                         'option':'httpchk',
                                         'balance':'roundrobin'}}
    comment = ("# Autogenerated with haproxy_autoscale version %s"
               %__version__)


    def get_acls(self, instances_dict, tabindent, domain, prefixes=None):
        """Generate neatly printed cfg-worthy backends for haproxy.

            Args:
                instances_dict: haproxy_autoscale.get_running_instances return.
                tabindent: Int, number of spaces to prepend hanging config lines.
                domain: Str, TLD to serve all backends from.
                prefixes: List, strings to prepend to acls and backends.
            Returns:
                return_comment: Str, version comment information.
        """


        # flatten all security group lookups into single instance list
        self.all_instances = []
        for instance_list in instances_dict.values():
            for instance in instance_list:
                self.all_instances.append(instance)

        self.all_backends = []
        self.included_instances = []
        self.excluded_instances = []

        if type(prefixes) is list:
            for prefix in prefixes:
                self.required_keys.append(prefix)
        else:
            prefixes = []

        for instance in self.all_instances:
            instance.missing_tags = []
            for key in self.required_keys:
                if instance.tags.has_key(key) is False:
                    instance.missing_tags.append(key)
            if len(instance.missing_tags) is 0:
                self.included_instances.append(instance)
                app_name = instance.tags['AppName']
                prefix_str = ''
                if len(prefixes) > 0:
                    for prefix in prefixes:
                        prefix_str = prefix_str + "%s-" %instance.tags[prefix]
                
                backend_name = "%s%s" %(prefix_str, app_name)
                instance.tags['backend'] = backend_name
                if backend_name not in self.all_backends:
                    self.all_backends.append(backend_name)
            else:
                self.excluded_instances.append(instance)

        # generate acls and redirects
        tabindent_str = (' ' * tabindent)
        return_str = "\n%s%s" %(tabindent_str, self.comment)
        for backend in self.all_backends:
            return_str = return_str + ("\n%sacl %s hdr(host) -i %s.%s"
                                       %(tabindent_str, 
                                         backend,
                                         backend,
                                         domain))
            return_str = return_str + ("\n%suse_backend %s if %s"
                                       %(tabindent_str,
                                         backend,
                                         backend))
        return return_str


    def generate(self, template_name, tabindent, cookie=True):
        """Iterate over all backend objects and generate default backend.
        
        Args:
            template_name: Str, a haproxy_autoscale.Backends.backend_templates.
            tabindent: Int, number of spaces to prepend hanging config lines.
            cookie: Bool, False to disabled sticky sessions.
        Returns:
            return_str: Str, formatted haproxy backend text block.
        """

        template = self.backend_templates.get(template_name)
        tabindent_str = (' ' * tabindent)
        return_str = ''

        # generate backend cfg from template
        for backend in self.all_backends:
            return_str = return_str + ("\n\n%s\nbackend %s"
                                       %(self.comment, backend))
            for key,value in template.iteritems():
                return_str = return_str + "\n%s%s %s" %(tabindent_str,
                                                        key, value)
            if cookie is True:
                return_str = return_str + ("\n%scookie SERVERID insert"
                                           " indirect nocache" %tabindent_str)
            return_str = return_str + "\n"

            # populate backend with instances
            for instance in self.included_instances:
                if instance.tags['backend'] == backend:
                    return_str = return_str + ("\n%sserver %s %s:%s"
                                               %(tabindent_str,
                                                 instance.id,
                                                 instance.private_dns_name,
                                                 instance.tags['AppPort']))
                    if cookie is True:
                        return_str = return_str + " cookie %s" %(instance.id)

        return return_str

########NEW FILE########
__FILENAME__ = test_haproxy_template
"""Tests for python blocks within haproxy-autoscale mako templates."""

import logging
import os
import subprocess

import unittest
from tempfile import NamedTemporaryFile
import yaml

import haproxy_autoscale
from boto.ec2.connection import EC2Connection

BASE_DIR_STR = os.path.realpath(__file__)
INSTANCE_DATA_PATH=os.path.join(os.path.dirname(BASE_DIR_STR),
                                'data/running_instances_mock.yml')

class BotoEc2InstanceMock():
    """Mock boto.ec2.instance.Instance from yaml instance of HttpMock."""

    def __init__(self, mock_dict):
        for key in mock_dict.keys():
            setattr(self, key, mock_dict[key])


class templateTestCase(unittest.TestCase):

    def setUp(self):
        try:
            self.version = subprocess.check_output(['haproxy', '-vv'])
        except OSError as e:
            raise RuntimeError('No haproxy binary found in path')

        logging.NullHandler
        data_filehandle = open(INSTANCE_DATA_PATH)
        self.mock_data = yaml.safe_load(data_filehandle)
        mock_sg_one_str = self.mock_data.keys()[0]
        mock_instances_sg_one = []
        for instance_data in self.mock_data[mock_sg_one_str]:
            mock_instances_sg_one.append(BotoEc2InstanceMock(
                             self.mock_data[mock_sg_one_str][instance_data]))
        mock_instances = {mock_sg_one_str: mock_instances_sg_one}

        self.data_dir_str = os.path.join(os.path.dirname(BASE_DIR_STR), 'data')
                
        self.running_instances_mock = mock_instances


    def tearDown(self):
        #pass
        os.remove(self.test_conf_filepath)

    def test_simple_config(self):

        template = os.path.join(self.data_dir_str, 'simple_example.tpl')
        self.test_conf_filepath = NamedTemporaryFile(delete=True).name
        haproxy_conf_str = haproxy_autoscale.generate_haproxy_config(
                                        template=template,
                                        instances=self.running_instances_mock)
        haproxy_autoscale.file_contents(filename=self.test_conf_filepath,
                                        content=haproxy_conf_str)
        test_conf_output = check_conf(conf_filepath=self.test_conf_filepath)
        self.assertEqual(test_conf_output[0], True,
                     ("Configuration parsing failed:\n%s"
                      %test_conf_output[1]))


    @unittest.skip('stub')
    def test_find_required_tag(self):
        pass

    @unittest.skip('stub')
    def test_autobackend_config(self):
        template = os.path.join(self.data_dir_str,
                                            'autobackends_example.tpl')
        self.test_conf_filepath = NamedTemporaryFile(delete=True).name
        haproxy_conf_str = haproxy_autoscale.generate_haproxy_config(
                                        template=template,
                                        instances=self.running_instances_mock)
        haproxy_autoscale.file_contents(filename=self.test_conf_filepath,
                                        content=haproxy_conf_str)
        test_conf_output = check_conf(conf_filepath=self.test_conf_filepath)
        self.assertEqual(test_conf_output[0], True,
                     ("Configuration parsing failed:\n%s"
                      %test_conf_output[1]))

    def test_autobackend_one_prefix(self):
        template = os.path.join(self.data_dir_str,
                                            'autobackends_one_prefix_example.tpl')
        self.test_conf_filepath = NamedTemporaryFile(delete=True).name
        haproxy_conf_str = haproxy_autoscale.generate_haproxy_config(
                                        template=template,
                                        instances=self.running_instances_mock)
        haproxy_autoscale.file_contents(filename=self.test_conf_filepath,
                                        content=haproxy_conf_str)
        test_conf_output = check_conf(conf_filepath=self.test_conf_filepath)
        self.assertEqual(test_conf_output[0], True,
                     ("Configuration parsing failed:\n%s"
                      %test_conf_output[1]))

    def test_autobackend_three_prefixes(self):
        template = os.path.join(self.data_dir_str,
                                            'autobackends_three_prefixes_example.tpl')
        self.test_conf_filepath = NamedTemporaryFile(delete=True).name
        haproxy_conf_str = haproxy_autoscale.generate_haproxy_config(
                                        template=template,
                                        instances=self.running_instances_mock)
        haproxy_autoscale.file_contents(filename=self.test_conf_filepath,
                                        content=haproxy_conf_str)
        test_conf_output = check_conf(conf_filepath=self.test_conf_filepath)
        self.assertEqual(test_conf_output[0], True,
                     ("Configuration parsing failed:\n%s"
                      %test_conf_output[1]))

    @unittest.skip('stub')
    def test_skip_without_required_tag(self):
        pass


# TODO: merge tests to module haproxy-autoscale/tests branch and import here
def check_conf(conf_filepath):
    """Wrap haproxy -c -f.

    Args:
        conf_filepath: Str, path to an haproxy configuration file.
    Returns:
        valid_config: Bool, true if configuration passed parsing.
    """

    try:
        subprocess.check_output(['haproxy', '-c', '-f', conf_filepath],
                                stderr=subprocess.STDOUT)
        valid_config = True
        error_output = None
    except subprocess.CalledProcessError as e:
        valid_config = False
        error_output = e.output

    return (valid_config, error_output)


if __name__ == '__main__':
    templateTestSuite = (unittest.TestLoader().
                         loadTestsFromTestCase(templateTestCase))

########NEW FILE########
__FILENAME__ = update-haproxy
import boto.ec2.connection
from boto.ec2.connection import EC2Connection
from boto.ec2.securitygroup import SecurityGroup
from boto.ec2.instance import Instance
from mako.template import Template
import argparse
import os
import subprocess
import logging
from haproxy_autoscale import get_running_instances, file_contents, generate_haproxy_config, steal_elastic_ip
import urllib2


def main():
    # Parse up the command line arguments.
    parser = argparse.ArgumentParser(description='Update haproxy to use all instances running in a security group.')
    parser.add_argument('--security-group', required=True, nargs='+', type=str)
    parser.add_argument('--access-key', required=True)
    parser.add_argument('--secret-key', required=True)
    parser.add_argument('--output', default='haproxy.cfg',
                        help='Defaults to haproxy.cfg if not specified.')
    parser.add_argument('--template', default='templates/haproxy.tpl')
    parser.add_argument('--haproxy', default='./haproxy',
                        help='The haproxy binary to call. Defaults to haproxy if not specified.')
    parser.add_argument('--pid', default='/var/run/haproxy.pid',
                        help='The pid file for haproxy. Defaults to /var/run/haproxy.pid.')
    parser.add_argument('--eip',
                        help='The Elastic IP to bind to when VIP seems unhealthy.')
    parser.add_argument('--health-check-url',
                        help='The URL to check. Assigns EIP to self if health check fails.')
    args = parser.parse_args()

    # Fetch a list of all the instances in these security groups.
    instances = {}
    for security_group in args.security_group:
        logging.info('Getting instances for %s.' % security_group)
        instances[security_group] = get_running_instances(access_key=args.access_key,
                                                          secret_key=args.secret_key,
                                                          security_group=security_group)
    # Generate the new config from the template.
    logging.info('Generating configuration for haproxy.')
    new_configuration = generate_haproxy_config(template=args.template,
                                                instances=instances)
    
    # See if this new config is different. If it is then restart using it.
    # Otherwise just delete the temporary file and do nothing.
    logging.info('Comparing to existing configuration.')
    old_configuration = file_contents(filename=args.output)
    if new_configuration != old_configuration:
        logging.info('Existing configuration is outdated.')
        
        # Overwite the existing config file.
        logging.info('Writing new configuration.')
        file_contents(filename=args.output,
                      content=generate_haproxy_config(template=args.template,
                                                      instances=instances    ))
        
        # Get PID if haproxy is already running.
        logging.info('Fetching PID from %s.' % args.pid)
        pid = file_contents(filename=args.pid)
        
        # Restart haproxy.
        logging.info('Restarting haproxy.')
        command = '''%s -p %s -f %s -sf %s''' % (args.haproxy, args.pid, args.output, pid or '')
        logging.info('Executing: %s' % command)
        subprocess.call(command, shell=True)
    else:
        logging.info('Configuration unchanged. Skipping restart.')
    
    # Do a health check on the url if specified.
    try:
        if args.health_check_url and args.eip:
            logging.info('Performing health check.')
            try:
                logging.info('Checking %s' % args.health_check_url)
                response = urllib2.urlopen(args.health_check_url)
                logging.info('Response: %s' % response.read())
            except:
                # Assign the EIP to self.
                logging.warn('Health check failed. Assigning %s to self.' % args.eip)
                steal_elastic_ip(access_key=args.access_key,
                                 secret_key=args.secret_key,
                                 ip=args.eip                )
    except:
        pass



if __name__ == '__main__':
    logging.getLogger().setLevel(logging.INFO)
    main()

########NEW FILE########
