__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# ImageKit documentation build configuration file, created by
# sphinx-quickstart on Sun Sep 25 17:05:55 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import re, sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.settings'

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'ImageKit'
copyright = u'2011, Justin Driscoll, Bryan Veloso, Greg Newman, Chris Drackett & Matthew Tretter'

pkgmeta = {}
execfile(os.path.join(os.path.dirname(__file__), '..', 'imagekit',
                      'pkgmeta.py'), pkgmeta)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = re.match('\d+\.\d+', pkgmeta['__version__']).group()
# The full version, including alpha/beta/rc tags.
release = pkgmeta['__version__']

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'ImageKitdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'ImageKit.tex', u'ImageKit Documentation',
   u'Justin Driscoll, Bryan Veloso, Greg Newman, Chris Drackett \\& Matthew Tretter', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'imagekit', u'ImageKit Documentation',
     [u'Justin Driscoll, Bryan Veloso, Greg Newman, Chris Drackett & Matthew Tretter'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'ImageKit', u'ImageKit Documentation', u'Justin Driscoll, Bryan Veloso, Greg Newman, Chris Drackett & Matthew Tretter',
   'ImageKit', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

autoclass_content = 'both'

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = admin
from django.utils.translation import ugettext_lazy as _
from django.template.loader import render_to_string


class AdminThumbnail(object):
    """
    A convenience utility for adding thumbnails to Django's admin change list.

    """
    short_description = _('Thumbnail')
    allow_tags = True

    def __init__(self, image_field, template=None):
        """
        :param image_field: The name of the ImageField or ImageSpecField on the
            model to use for the thumbnail.
        :param template: The template with which to render the thumbnail

        """
        self.image_field = image_field
        self.template = template

    def __call__(self, obj):
        if callable(self.image_field):
            thumbnail = self.image_field(obj)
        else:
            try:
                thumbnail = getattr(obj, self.image_field)
            except AttributeError:
                raise Exception('The property %s is not defined on %s.' %
                        (self.image_field, obj.__class__.__name__))

        original_image = getattr(thumbnail, 'source', None) or thumbnail
        template = self.template or 'imagekit/admin/thumbnail.html'

        return render_to_string(template, {
            'model': obj,
            'thumbnail': thumbnail,
            'original_image': original_image,
        })

########NEW FILE########
__FILENAME__ = backends
from ..utils import get_singleton, sanitize_cache_key
import warnings
from copy import copy
from django.core.cache import get_cache
from django.core.exceptions import ImproperlyConfigured


class CacheFileState(object):
    EXISTS = 'exists'
    GENERATING = 'generating'
    DOES_NOT_EXIST = 'does_not_exist'


def get_default_cachefile_backend():
    """
    Get the default file backend.

    """
    from django.conf import settings
    return get_singleton(settings.IMAGEKIT_DEFAULT_CACHEFILE_BACKEND,
                         'file backend')


class InvalidFileBackendError(ImproperlyConfigured):
    pass


class AbstractCacheFileBackend(object):
    """
    An abstract cache file backend. This isn't used by any internal classes and
    is included simply to illustrate the minimum interface of a cache file
    backend for users who wish to implement their own.

    """
    def generate(self, file, force=False):
        raise NotImplementedError

    def exists(self, file):
        raise NotImplementedError


class CachedFileBackend(object):
    existence_check_timeout = 5
    """
    The number of seconds to wait before rechecking to see if the file exists.
    If the image is found to exist, that information will be cached using the
    timeout specified in your CACHES setting (which should be very high).
    However, when the file does not exist, you probably want to check again
    in a relatively short amount of time. This attribute allows you to do that.

    """

    @property
    def cache(self):
        if not getattr(self, '_cache', None):
            from django.conf import settings
            self._cache = get_cache(settings.IMAGEKIT_CACHE_BACKEND)
        return self._cache

    def get_key(self, file):
        from django.conf import settings
        return sanitize_cache_key('%s%s-state' %
                                  (settings.IMAGEKIT_CACHE_PREFIX, file.name))

    def get_state(self, file, check_if_unknown=True):
        key = self.get_key(file)
        state = self.cache.get(key)
        if state is None and check_if_unknown:
            exists = self._exists(file)
            state = CacheFileState.EXISTS if exists else CacheFileState.DOES_NOT_EXIST
            self.set_state(file, state)
        return state

    def set_state(self, file, state):
        key = self.get_key(file)
        if state == CacheFileState.DOES_NOT_EXIST:
            self.cache.set(key, state, self.existence_check_timeout)
        else:
            self.cache.set(key, state)

    def __getstate__(self):
        state = copy(self.__dict__)
        # Don't include the cache when pickling. It'll be reconstituted based
        # on the settings.
        state.pop('_cache', None)
        return state

    def exists(self, file):
        return self.get_state(file) == CacheFileState.EXISTS

    def generate(self, file, force=False):
        raise NotImplementedError

    def generate_now(self, file, force=False):
        if force or self.get_state(file) not in (CacheFileState.GENERATING, CacheFileState.EXISTS):
            self.set_state(file, CacheFileState.GENERATING)
            file._generate()
            self.set_state(file, CacheFileState.EXISTS)


class Simple(CachedFileBackend):
    """
    The most basic file backend. The storage is consulted to see if the file
    exists. Files are generated synchronously.

    """

    def generate(self, file, force=False):
        self.generate_now(file, force=force)

    def _exists(self, file):
        return bool(getattr(file, '_file', None)
                    or file.storage.exists(file.name))


def _generate_file(backend, file, force=False):
    backend.generate_now(file, force=force)


class BaseAsync(Simple):
    """
    Base class for cache file backends that generate files asynchronously.
    """
    def generate(self, file, force=False):
        # Schedule the file for generation, unless we know for sure we don't
        # need to. If an already-generated file sneaks through, that's okay;
        # ``generate_now`` will catch it. We just want to make sure we don't
        # schedule anything we know is unnecessary--but we also don't want to
        # force a costly existence check.
        state = self.get_state(file, check_if_unknown=False)
        if state not in (CacheFileState.GENERATING, CacheFileState.EXISTS):
            self.schedule_generation(file, force=force)

    def schedule_generation(self, file, force=False):
        # overwrite this to have the file generated in the background,
        # e. g. in a worker queue.
        raise NotImplementedError


try:
    from celery import task
except ImportError:
    pass
else:
    _celery_task = task(ignore_result=True)(_generate_file)


class Celery(BaseAsync):
    """
    A backend that uses Celery to generate the images.
    """
    def __init__(self, *args, **kwargs):
        try:
            import celery
        except ImportError:
            raise ImproperlyConfigured('You must install celery to use'
                                       ' imagekit.cachefiles.backends.Celery.')
        super(Celery, self).__init__(*args, **kwargs)

    def schedule_generation(self, file, force=False):
        _celery_task.delay(self, file, force=force)


# Stub class to preserve backwards compatibility and issue a warning
class Async(Celery):
    def __init__(self, *args, **kwargs):
        message = '{path}.Async is deprecated. Use {path}.Celery instead.'
        warnings.warn(message.format(path=__name__), DeprecationWarning)
        super(Async, self).__init__(*args, **kwargs)


try:
    from django_rq import job
except ImportError:
    pass
else:
    _rq_job = job('default', result_ttl=0)(_generate_file)


class RQ(BaseAsync):
    """
    A backend that uses RQ to generate the images.
    """
    def __init__(self, *args, **kwargs):
        try:
            import django_rq
        except ImportError:
            raise ImproperlyConfigured('You must install django-rq to use'
                                       ' imagekit.cachefiles.backends.RQ.')
        super(RQ, self).__init__(*args, **kwargs)

    def schedule_generation(self, file, force=False):
        _rq_job.delay(self, file, force=force)

########NEW FILE########
__FILENAME__ = namers
"""
Functions responsible for returning filenames for the given image generator.
Users are free to define their own functions; these are just some some sensible
choices.

"""

from django.conf import settings
import os
from ..utils import format_to_extension, suggest_extension


def source_name_as_path(generator):
    """
    A namer that, given the following source file name::

        photos/thumbnails/bulldog.jpg

    will generate a name like this::

        /path/to/generated/images/photos/thumbnails/bulldog/5ff3233527c5ac3e4b596343b440ff67.jpg

    where "/path/to/generated/images/" is the value specified by the
    ``IMAGEKIT_CACHEFILE_DIR`` setting.

    """
    source_filename = getattr(generator.source, 'name', None)

    if source_filename is None or os.path.isabs(source_filename):
        # Generally, we put the file right in the cache file directory.
        dir = settings.IMAGEKIT_CACHEFILE_DIR
    else:
        # For source files with relative names (like Django media files),
        # use the source's name to create the new filename.
        dir = os.path.join(settings.IMAGEKIT_CACHEFILE_DIR,
                           os.path.splitext(source_filename)[0])

    ext = suggest_extension(source_filename or '', generator.format)
    return os.path.normpath(os.path.join(dir,
                                         '%s%s' % (generator.get_hash(), ext)))


def source_name_dot_hash(generator):
    """
    A namer that, given the following source file name::

        photos/thumbnails/bulldog.jpg

    will generate a name like this::

        /path/to/generated/images/photos/thumbnails/bulldog.5ff3233527c5.jpg

    where "/path/to/generated/images/" is the value specified by the
    ``IMAGEKIT_CACHEFILE_DIR`` setting.

    """
    source_filename = getattr(generator.source, 'name', None)

    if source_filename is None or os.path.isabs(source_filename):
        # Generally, we put the file right in the cache file directory.
        dir = settings.IMAGEKIT_CACHEFILE_DIR
    else:
        # For source files with relative names (like Django media files),
        # use the source's name to create the new filename.
        dir = os.path.join(settings.IMAGEKIT_CACHEFILE_DIR,
                           os.path.dirname(source_filename))

    ext = suggest_extension(source_filename or '', generator.format)
    basename = os.path.basename(source_filename)
    return os.path.normpath(os.path.join(dir, '%s.%s%s' % (
            os.path.splitext(basename)[0], generator.get_hash()[:12], ext)))


def hash(generator):
    """
    A namer that, given the following source file name::

        photos/thumbnails/bulldog.jpg

    will generate a name like this::

        /path/to/generated/images/5ff3233527c5ac3e4b596343b440ff67.jpg

    where "/path/to/generated/images/" is the value specified by the
    ``IMAGEKIT_CACHEFILE_DIR`` setting.

    """
    format = getattr(generator, 'format', None)
    ext = format_to_extension(format) if format else ''
    return os.path.normpath(os.path.join(settings.IMAGEKIT_CACHEFILE_DIR,
                                         '%s%s' % (generator.get_hash(), ext)))

########NEW FILE########
__FILENAME__ = strategies
import six

from django.utils.functional import LazyObject
from ..lib import force_text
from ..utils import get_singleton


class JustInTime(object):
    """
    A strategy that ensures the file exists right before it's needed.

    """

    def on_existence_required(self, file):
        file.generate()

    def on_content_required(self, file):
        file.generate()


class Optimistic(object):
    """
    A strategy that acts immediately when the source file changes and assumes
    that the cache files will not be removed (i.e. it doesn't ensure the
    cache file exists when it's accessed).

    """

    def on_source_saved(self, file):
        file.generate()


class DictStrategy(object):
    def __init__(self, callbacks):
        for k, v in callbacks.items():
            setattr(self, k, v)


def load_strategy(strategy):
    if isinstance(strategy, six.string_types):
        strategy = get_singleton(strategy, 'cache file strategy')
    elif isinstance(strategy, dict):
        strategy = DictStrategy(strategy)
    elif callable(strategy):
        strategy = strategy()
    return strategy

########NEW FILE########
__FILENAME__ = conf
from appconf import AppConf
from django.conf import settings


class ImageKitConf(AppConf):
    CACHEFILE_NAMER = 'imagekit.cachefiles.namers.hash'
    SPEC_CACHEFILE_NAMER = 'imagekit.cachefiles.namers.source_name_as_path'
    CACHEFILE_DIR = 'CACHE/images'
    DEFAULT_CACHEFILE_BACKEND = 'imagekit.cachefiles.backends.Simple'
    DEFAULT_CACHEFILE_STRATEGY = 'imagekit.cachefiles.strategies.JustInTime'

    DEFAULT_FILE_STORAGE = None

    CACHE_BACKEND = None
    CACHE_PREFIX = 'imagekit:'
    USE_MEMCACHED_SAFE_CACHE_KEY = True

    def configure_cache_backend(self, value):
        if value is None:
            try:
                from django.core.cache.backends.dummy import DummyCache
            except ImportError:
                dummy_cache = 'dummy://'
            else:
                dummy_cache = 'django.core.cache.backends.dummy.DummyCache'

            # DEFAULT_CACHE_ALIAS doesn't exist in Django<=1.2
            try:
                from django.core.cache import DEFAULT_CACHE_ALIAS as default_cache_alias
            except ImportError:
                default_cache_alias = 'default'

            if settings.DEBUG:
                value = dummy_cache
            elif default_cache_alias in getattr(settings, 'CACHES', {}):
                value = default_cache_alias
            else:
                value = getattr(settings, 'CACHE_BACKEND', None) or dummy_cache

        return value

    def configure_default_file_storage(self, value):
        if value is None:
            value = settings.DEFAULT_FILE_STORAGE
        return value

########NEW FILE########
__FILENAME__ = exceptions
from pilkit.exceptions import UnknownExtension, UnknownFormat


class AlreadyRegistered(Exception):
    pass


class NotRegistered(Exception):
    pass


class MissingGeneratorId(Exception):
    pass


class MissingSource(ValueError):
    pass


# Aliases for backwards compatibility
UnknownExtensionError = UnknownExtension
UnknownFormatError = UnknownFormat

########NEW FILE########
__FILENAME__ = files
from __future__ import unicode_literals
import os

from django.core.files.base import File, ContentFile
from django.utils.encoding import smart_str
from .lib import smart_text
from .utils import format_to_mimetype, extension_to_mimetype


class BaseIKFile(File):
    """
    This class contains all of the methods we need from
    django.db.models.fields.files.FieldFile, but with the model stuff ripped
    out. It's only extended by one class, but we keep it separate for
    organizational reasons.

    """

    def __init__(self, storage):
        self.storage = storage

    def _require_file(self):
        if not self:
            raise ValueError()

    def _get_file(self):
        self._require_file()
        if not hasattr(self, '_file') or self._file is None:
            self._file = self.storage.open(self.name, 'rb')
        return self._file

    def _set_file(self, file):
        self._file = file

    def _del_file(self):
        del self._file

    file = property(_get_file, _set_file, _del_file)

    def _get_path(self):
        self._require_file()
        return self.storage.path(self.name)
    path = property(_get_path)

    def _get_url(self):
        self._require_file()
        return self.storage.url(self.name)
    url = property(_get_url)

    def _get_size(self):
        self._require_file()
        if not self._committed:
            return self.file.size
        return self.storage.size(self.name)
    size = property(_get_size)

    def open(self, mode='rb'):
        self._require_file()
        self.file.open(mode)

    def _get_closed(self):
        file = getattr(self, '_file', None)
        return file is None or file.closed
    closed = property(_get_closed)

    def close(self):
        file = getattr(self, '_file', None)
        if file is not None:
            file.close()


class IKContentFile(ContentFile):
    """
    Wraps a ContentFile in a file-like object with a filename and a
    content_type. A PIL image format can be optionally be provided as a content
    type hint.

    """
    def __init__(self, filename, content, format=None):
        self.file = ContentFile(content)
        self.file.name = filename
        mimetype = getattr(self.file, 'content_type', None)
        if format and not mimetype:
            mimetype = format_to_mimetype(format)
        if not mimetype:
            ext = os.path.splitext(filename or '')[1]
            mimetype = extension_to_mimetype(ext)
        self.file.content_type = mimetype

    @property
    def name(self):
        return self.file.name

    def __str__(self):
        return smart_str(self.file.name or '')

    def __unicode__(self):
        # Python 2
        return smart_text(self.file.name or '')

########NEW FILE########
__FILENAME__ = fields
from django.forms import ImageField
from ..specs import SpecHost
from ..utils import generate


class ProcessedImageField(ImageField, SpecHost):

    def __init__(self, processors=None, format=None, options=None,
                 autoconvert=True, spec_id=None, spec=None, *args, **kwargs):

        if spec_id is None:
            # Unlike model fields, form fields are never told their field name.
            # (Model fields are done so via `contribute_to_class()`.) Therefore
            # we can't really generate a good spec id automatically.
            raise TypeError('You must provide a spec_id')

        SpecHost.__init__(self, processors=processors, format=format,
                          options=options, autoconvert=autoconvert, spec=spec,
                          spec_id=spec_id)
        super(ProcessedImageField, self).__init__(*args, **kwargs)

    def clean(self, data, initial=None):
        data = super(ProcessedImageField, self).clean(data, initial)

        if data and data != initial:
            spec = self.get_spec(source=data)
            data = generate(spec)

        return data

########NEW FILE########
__FILENAME__ = generatorlibrary
from .registry import register
from .processors import Thumbnail as ThumbnailProcessor
from .specs import ImageSpec


class Thumbnail(ImageSpec):
    def __init__(self, width=None, height=None, anchor=None, crop=None, upscale=None, **kwargs):
        self.processors = [ThumbnailProcessor(width, height, anchor=anchor,
                                              crop=crop, upscale=upscale)]
        super(Thumbnail, self).__init__(**kwargs)


register.generator('imagekit:thumbnail', Thumbnail)

########NEW FILE########
__FILENAME__ = hashers
from copy import copy
from hashlib import md5
from pickle import MARK, DICT
try:
    from pickle import _Pickler
except ImportError:
    # Python 2 compatible
    from pickle import Pickler as _Pickler
from .lib import StringIO


class CanonicalizingPickler(_Pickler):
    dispatch = copy(_Pickler.dispatch)

    def save_set(self, obj):
        rv = obj.__reduce_ex__(0)
        rv = (rv[0], (sorted(rv[1][0]),), rv[2])
        self.save_reduce(obj=obj, *rv)

    dispatch[set] = save_set

    def save_dict(self, obj):
        write = self.write
        write(MARK + DICT)

        self.memoize(obj)
        self._batch_setitems(sorted(obj.items()))

    dispatch[dict] = save_dict


def pickle(obj):
    file = StringIO()
    CanonicalizingPickler(file, 0).dump(obj)
    return md5(file.getvalue()).hexdigest()

########NEW FILE########
__FILENAME__ = importers
import re
import sys


class ProcessorImporter(object):
    """
    The processors were moved to the PILKit project so they could be used
    separtely from ImageKit (which has a bunch of Django dependencies). However,
    there's no real need to expose this fact (and we want to maintain backwards
    compatibility), so we proxy all "imagekit.processors" imports to
    "pilkit.processors" using this object.

    """
    pattern = re.compile(r'^imagekit\.processors((\..*)?)$')

    def find_module(self, name, path=None):
        if self.pattern.match(name):
            return self

    def load_module(self, name):
        if name in sys.modules:
            return sys.modules[name]

        from django.utils.importlib import import_module
        new_name = self.pattern.sub(r'pilkit.processors\1', name)
        mod = import_module(new_name)
        sys.modules[name] = mod
        return mod


sys.meta_path.insert(0, ProcessorImporter())

########NEW FILE########
__FILENAME__ = lib
# flake8: noqa

# Required PIL classes may or may not be available from the root namespace
# depending on the installation method used.
try:
    from PIL import Image, ImageColor, ImageChops, ImageEnhance, ImageFile, \
            ImageFilter, ImageDraw, ImageStat
except ImportError:
    try:
        import Image
        import ImageColor
        import ImageChops
        import ImageEnhance
        import ImageFile
        import ImageFilter
        import ImageDraw
        import ImageStat
    except ImportError:
        raise ImportError('ImageKit was unable to import the Python Imaging Library. Please confirm it`s installed and available on your current Python path.')

try:
    from io import BytesIO as StringIO
except:
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO

try:
    from logging import NullHandler
except ImportError:
    from logging import Handler

    class NullHandler(Handler):
        def emit(self, record):
            pass

# Try to import `force_text` available from Django 1.5
# This function will replace `unicode` used in the code
# If Django version is under 1.5 then use `force_unicde`
# It is used for compatibility between Python 2 and Python 3
try:
    from django.utils.encoding import force_text, force_bytes, smart_text
except ImportError:
    # Django < 1.5
    from django.utils.encoding import (force_unicode as force_text,
                                       smart_str as force_bytes,
                                       smart_unicode as smart_text)

__all__ = ['Image', 'ImageColor', 'ImageChops', 'ImageEnhance', 'ImageFile',
           'ImageFilter', 'ImageDraw', 'ImageStat', 'StringIO', 'NullHandler',
           'force_text', 'force_bytes', 'smart_text']

########NEW FILE########
__FILENAME__ = generateimages
from django.core.management.base import BaseCommand
import re
from ...registry import generator_registry, cachefile_registry


class Command(BaseCommand):
    help = ("""Generate files for the specified image generators (or all of them if
none was provided). Simple, glob-like wildcards are allowed, with *
matching all characters within a segment, and ** matching across
segments. (Segments are separated with colons.) So, for example,
"a:*:c" will match "a:b:c", but not "a:b:x:c", whereas "a:**:c" will
match both. Subsegments are always matched, so "a" will match "a" as
well as "a:b" and "a:b:c".""")
    args = '[generator_ids]'

    def handle(self, *args, **options):
        generators = generator_registry.get_ids()

        if args:
            patterns = self.compile_patterns(args)
            generators = (id for id in generators if any(p.match(id) for p in patterns))

        for generator_id in generators:
            self.stdout.write('Validating generator: %s\n' % generator_id)
            for file in cachefile_registry.get(generator_id):
                self.stdout.write('  %s\n' % file)
                try:
                    # TODO: Allow other validation actions through command option
                    file.generate()
                except Exception as err:
                    # TODO: How should we handle failures? Don't want to error, but should call it out more than this.
                    self.stdout.write('    FAILED: %s\n' % err)

    def compile_patterns(self, generator_ids):
        return [self.compile_pattern(id) for id in generator_ids]

    def compile_pattern(self, generator_id):
        parts = re.split(r'(\*{1,2})', generator_id)
        pattern = ''
        for part in parts:
            if part == '*':
                pattern += '[^:]*'
            elif part == '**':
                pattern += '.*'
            else:
                pattern += re.escape(part)
        return re.compile('^%s(:.*)?$' % pattern)

########NEW FILE########
__FILENAME__ = files
from django.db.models.fields.files import ImageFieldFile
import os
from ...utils import suggest_extension, generate


class ProcessedImageFieldFile(ImageFieldFile):
    def save(self, name, content, save=True):
        filename, ext = os.path.splitext(name)
        spec = self.field.get_spec(source=content)
        ext = suggest_extension(name, spec.format)
        new_name = '%s%s' % (filename, ext)
        content = generate(spec)
        return super(ProcessedImageFieldFile, self).save(new_name, content, save)

########NEW FILE########
__FILENAME__ = utils
from ...cachefiles import ImageCacheFile


class ImageSpecFileDescriptor(object):
    def __init__(self, field, attname, source_field_name):
        self.attname = attname
        self.field = field
        self.source_field_name = source_field_name

    def __get__(self, instance, owner):
        if instance is None:
            return self.field
        else:
            source = getattr(instance, self.source_field_name)
            spec = self.field.get_spec(source=source)
            file = ImageCacheFile(spec)
            instance.__dict__[self.attname] = file
            return file

    def __set__(self, instance, value):
        instance.__dict__[self.attname] = value

########NEW FILE########
__FILENAME__ = pkgmeta
__title__ = 'django-imagekit'
__author__ = 'Matthew Tretter, Eric Eldredge, Bryan Veloso, Greg Newman, Chris Drackett, Justin Driscoll'
__version__ = '3.2.1'
__license__ = 'BSD'
__all__ = ['__title__', '__author__', '__version__', '__license__']

########NEW FILE########
__FILENAME__ = processors
"""
Looking for processors? They have moved to PILKit. See imagekit.importers for
details.

"""

########NEW FILE########
__FILENAME__ = registry
from .exceptions import AlreadyRegistered, NotRegistered
from .signals import content_required, existence_required, source_saved
from .utils import autodiscover, call_strategy_method


class GeneratorRegistry(object):
    """
    An object for registering generators. This registry provides
    a convenient way for a distributable app to define default generators
    without locking the users of the app into it.

    """
    def __init__(self):
        self._generators = {}
        content_required.connect(self.content_required_receiver)
        existence_required.connect(self.existence_required_receiver)

    def register(self, id, generator):
        registered_generator = self._generators.get(id)
        if registered_generator and generator != self._generators[id]:
            raise AlreadyRegistered('The generator with id %s is'
                                    ' already registered' % id)
        self._generators[id] = generator

    def unregister(self, id):
        try:
            del self._generators[id]
        except KeyError:
            raise NotRegistered('The generator with id %s is not'
                                ' registered' % id)

    def get(self, id, **kwargs):
        autodiscover()

        try:
            generator = self._generators[id]
        except KeyError:
            raise NotRegistered('The generator with id %s is not'
                                ' registered' % id)
        if callable(generator):
            return generator(**kwargs)
        else:
            return generator

    def get_ids(self):
        autodiscover()
        return self._generators.keys()

    def content_required_receiver(self, sender, file, **kwargs):
        self._receive(file, 'on_content_required')

    def existence_required_receiver(self, sender, file, **kwargs):
        self._receive(file, 'on_existence_required')

    def _receive(self, file, callback):
        generator = file.generator

        # FIXME: I guess this means you can't register functions?
        if generator.__class__ in self._generators.values():
            # Only invoke the strategy method for registered generators.
            call_strategy_method(file, callback)


class SourceGroupRegistry(object):
    """
    The source group registry is responsible for listening to source_* signals
    on source groups, and relaying them to the image generated file strategies
    of the appropriate generators.

    In addition, registering a new source group also registers its generated
    files with that registry.

    """
    _signals = {
        source_saved: 'on_source_saved',
    }

    def __init__(self):
        self._source_groups = {}
        for signal in self._signals.keys():
            signal.connect(self.source_group_receiver)

    def register(self, generator_id, source_group):
        from .specs.sourcegroups import SourceGroupFilesGenerator
        generator_ids = self._source_groups.setdefault(source_group, set())
        generator_ids.add(generator_id)
        cachefile_registry.register(generator_id,
                SourceGroupFilesGenerator(source_group, generator_id))

    def unregister(self, generator_id, source_group):
        from .specs.sourcegroups import SourceGroupFilesGenerator
        generator_ids = self._source_groups.setdefault(source_group, set())
        if generator_id in generator_ids:
            generator_ids.remove(generator_id)
            cachefile_registry.unregister(generator_id,
                    SourceGroupFilesGenerator(source_group, generator_id))

    def source_group_receiver(self, sender, source, signal, **kwargs):
        """
        Relay source group signals to the appropriate spec strategy.

        """
        from .cachefiles import ImageCacheFile
        source_group = sender

        # Ignore signals from unregistered groups.
        if source_group not in self._source_groups:
            return

        specs = [generator_registry.get(id, source=source) for id in
                self._source_groups[source_group]]
        callback_name = self._signals[signal]

        for spec in specs:
            file = ImageCacheFile(spec)
            call_strategy_method(file, callback_name)


class CacheFileRegistry(object):
    """
    An object for registering generated files with image generators. The two are
    associated with each other via a string id. We do this (as opposed to
    associating them directly by, for example, putting a ``cachefiles``
    attribute on image generators) so that image generators can be overridden
    without losing the associated files. That way, a distributable app can
    define its own generators without locking the users of the app into it.

    """

    def __init__(self):
        self._cachefiles = {}

    def register(self, generator_id, cachefiles):
        """
        Associates generated files with a generator id

        """
        if cachefiles not in self._cachefiles:
            self._cachefiles[cachefiles] = set()
        self._cachefiles[cachefiles].add(generator_id)

    def unregister(self, generator_id, cachefiles):
        """
        Disassociates generated files with a generator id

        """
        try:
            self._cachefiles[cachefiles].remove(generator_id)
        except KeyError:
            pass

    def get(self, generator_id):
        for k, v in self._cachefiles.items():
            if generator_id in v:
                for file in k():
                    yield file


class Register(object):
    """
    Register generators and generated files.

    """
    def generator(self, id, generator=None):
        if generator is None:
            # Return a decorator
            def decorator(cls):
                self.generator(id, cls)
                return cls
            return decorator

        generator_registry.register(id, generator)

    # iterable that returns kwargs or callable that returns iterable of kwargs
    def cachefiles(self, generator_id, cachefiles):
        cachefile_registry.register(generator_id, cachefiles)

    def source_group(self, generator_id, source_group):
        source_group_registry.register(generator_id, source_group)


class Unregister(object):
    """
    Unregister generators and generated files.

    """
    def generator(self, id):
        generator_registry.unregister(id)

    def cachefiles(self, generator_id, cachefiles):
        cachefile_registry.unregister(generator_id, cachefiles)

    def source_group(self, generator_id, source_group):
        source_group_registry.unregister(generator_id, source_group)


generator_registry = GeneratorRegistry()
cachefile_registry = CacheFileRegistry()
source_group_registry = SourceGroupRegistry()
register = Register()
unregister = Unregister()

########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal


# Generated file signals
content_required = Signal()
existence_required = Signal()

# Source group signals
source_saved = Signal()

########NEW FILE########
__FILENAME__ = sourcegroups
"""
Source groups are the means by which image spec sources are identified. They
have two responsibilities:

1. To dispatch ``source_saved`` signals. (These will be relayed to the
   corresponding specs' cache file strategies.)
2. To provide the source files that they represent, via a generator method named
   ``files()``. (This is used by the generateimages management command for
   "pre-caching" image files.)

"""

from django.db.models.signals import post_init, post_save
from django.utils.functional import wraps
import inspect
from ..cachefiles import LazyImageCacheFile
from ..signals import source_saved
from ..utils import get_nonabstract_descendants


def ik_model_receiver(fn):
    """
    A method decorator that filters out signals coming from models that don't
    have fields that function as ImageFieldSourceGroup sources.

    """
    @wraps(fn)
    def receiver(self, sender, **kwargs):
        if not inspect.isclass(sender):
            return
        for src in self._source_groups:
            if issubclass(sender, src.model_class):
                fn(self, sender=sender, **kwargs)

                # If we find a match, return. We don't want to handle the signal
                # more than once.
                return
    return receiver


class ModelSignalRouter(object):
    """
    Normally, ``ImageFieldSourceGroup`` would be directly responsible for
    watching for changes on the model field it represents. However, Django does
    not dispatch events for abstract base classes. Therefore, we must listen for
    the signals on all models and filter out those that aren't represented by
    ``ImageFieldSourceGroup``s. This class encapsulates that functionality.

    Related:
        https://github.com/matthewwithanm/django-imagekit/issues/126
        https://code.djangoproject.com/ticket/9318

    """

    def __init__(self):
        self._source_groups = []
        uid = 'ik_spec_field_receivers'
        post_init.connect(self.post_init_receiver, dispatch_uid=uid)
        post_save.connect(self.post_save_receiver, dispatch_uid=uid)

    def add(self, source_group):
        self._source_groups.append(source_group)

    def init_instance(self, instance):
        instance._ik = getattr(instance, '_ik', {})

    def update_source_hashes(self, instance):
        """
        Stores hashes of the source image files so that they can be compared
        later to see whether the source image has changed (and therefore whether
        the spec file needs to be regenerated).

        """
        self.init_instance(instance)
        instance._ik['source_hashes'] = dict((attname, hash(file_field))
                for attname, file_field in self.get_field_dict(instance).items())
        return instance._ik['source_hashes']

    def get_field_dict(self, instance):
        """
        Returns the source fields for the given instance, in a dictionary whose
        keys are the field names and values are the fields themselves.

        """
        return dict((src.image_field, getattr(instance, src.image_field)) for
                src in self._source_groups if isinstance(instance, src.model_class))

    @ik_model_receiver
    def post_save_receiver(self, sender, instance=None, created=False, raw=False, **kwargs):
        if not raw:
            self.init_instance(instance)
            old_hashes = instance._ik.get('source_hashes', {}).copy()
            new_hashes = self.update_source_hashes(instance)
            for attname, file in self.get_field_dict(instance).items():
                if file and old_hashes[attname] != new_hashes[attname]:
                    self.dispatch_signal(source_saved, file, sender, instance,
                                         attname)

    @ik_model_receiver
    def post_init_receiver(self, sender, instance=None, **kwargs):
        self.update_source_hashes(instance)

    def dispatch_signal(self, signal, file, model_class, instance, attname):
        """
        Dispatch the signal for each of the matching source groups. Note that
        more than one source can have the same model and image_field; it's
        important that we dispatch the signal for each.

        """
        for source_group in self._source_groups:
            if issubclass(model_class, source_group.model_class) and source_group.image_field == attname:
                signal.send(sender=source_group, source=file)


class ImageFieldSourceGroup(object):
    """
    A source group that repesents a particular field across all instances of a
    model and its subclasses.

    """
    def __init__(self, model_class, image_field):
        self.model_class = model_class
        self.image_field = image_field
        signal_router.add(self)

    def files(self):
        """
        A generator that returns the source files that this source group
        represents; in this case, a particular field of every instance of a
        particular model and its subclasses.

        """
        for model in get_nonabstract_descendants(self.model_class):
            for instance in model.objects.all().iterator():
                yield getattr(instance, self.image_field)


class SourceGroupFilesGenerator(object):
    """
    A Python generator that yields cache file objects for source groups.

    """
    def __init__(self, source_group, generator_id):
        self.source_group = source_group
        self.generator_id = generator_id

    def __eq__(self, other):
        return (isinstance(other, self.__class__)
            and self.__dict__ == other.__dict__)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash((self.source_group, self.generator_id))

    def __call__(self):
        for source_file in self.source_group.files():
            yield LazyImageCacheFile(self.generator_id,
                                              source=source_file)


signal_router = ModelSignalRouter()

########NEW FILE########
__FILENAME__ = compat
# flake8: noqa
"""
This module contains code from django.template.base
(sha 90d3af380e8efec0301dd91600c6686232de3943). Bundling this code allows us to
support older versions of Django that did not contain it (< 1.4).


Copyright (c) Django Software Foundation and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, 
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright 
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of Django nor the names of its contributors may be used
       to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

from django.template import TemplateSyntaxError
import re


# Regex for token keyword arguments
kwarg_re = re.compile(r"(?:(\w+)=)?(.+)")


def token_kwargs(bits, parser, support_legacy=False):
    """
    A utility method for parsing token keyword arguments.

    :param bits: A list containing remainder of the token (split by spaces)
        that is to be checked for arguments. Valid arguments will be removed
        from this list.

    :param support_legacy: If set to true ``True``, the legacy format
        ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1``
        format is allowed.

    :returns: A dictionary of the arguments retrieved from the ``bits`` token
        list.

    There is no requirement for all remaining token ``bits`` to be keyword
    arguments, so the dictionary will be returned as soon as an invalid
    argument format is reached.
    """
    if not bits:
        return {}
    match = kwarg_re.match(bits[0])
    kwarg_format = match and match.group(1)
    if not kwarg_format:
        if not support_legacy:
            return {}
        if len(bits) < 3 or bits[1] != 'as':
            return {}

    kwargs = {}
    while bits:
        if kwarg_format:
            match = kwarg_re.match(bits[0])
            if not match or not match.group(1):
                return kwargs
            key, value = match.groups()
            del bits[:1]
        else:
            if len(bits) < 3 or bits[1] != 'as':
                return kwargs
            key, value = bits[2], bits[0]
            del bits[:3]
        kwargs[key] = parser.compile_filter(value)
        if bits and not kwarg_format:
            if bits[0] != 'and':
                return kwargs
            del bits[:1]
    return kwargs


def parse_bits(parser, bits, params, varargs, varkw, defaults,
               takes_context, name):
    """
    Parses bits for template tag helpers (simple_tag, include_tag and
    assignment_tag), in particular by detecting syntax errors and by
    extracting positional and keyword arguments.
    """
    if takes_context:
        if params[0] == 'context':
            params = params[1:]
        else:
            raise TemplateSyntaxError(
                "'%s' is decorated with takes_context=True so it must "
                "have a first argument of 'context'" % name)
    args = []
    kwargs = {}
    unhandled_params = list(params)
    for bit in bits:
        # First we try to extract a potential kwarg from the bit
        kwarg = token_kwargs([bit], parser)
        if kwarg:
            # The kwarg was successfully extracted
            param, value = list(kwarg.items())[0]
            if param not in params and varkw is None:
                # An unexpected keyword argument was supplied
                raise TemplateSyntaxError(
                    "'%s' received unexpected keyword argument '%s'" %
                    (name, param))
            elif param in kwargs:
                # The keyword argument has already been supplied once
                raise TemplateSyntaxError(
                    "'%s' received multiple values for keyword argument '%s'" %
                    (name, param))
            else:
                # All good, record the keyword argument
                kwargs[str(param)] = value
                if param in unhandled_params:
                    # If using the keyword syntax for a positional arg, then
                    # consume it.
                    unhandled_params.remove(param)
        else:
            if kwargs:
                raise TemplateSyntaxError(
                    "'%s' received some positional argument(s) after some "
                    "keyword argument(s)" % name)
            else:
                # Record the positional argument
                args.append(parser.compile_filter(bit))
                try:
                    # Consume from the list of expected positional arguments
                    unhandled_params.pop(0)
                except IndexError:
                    if varargs is None:
                        raise TemplateSyntaxError(
                            "'%s' received too many positional arguments" %
                            name)
    if defaults is not None:
        # Consider the last n params handled, where n is the
        # number of defaults.
        unhandled_params = unhandled_params[:-len(defaults)]
    if unhandled_params:
        # Some positional arguments were not supplied
        raise TemplateSyntaxError(
            "'%s' did not receive value(s) for the argument(s): %s" %
            (name, ", ".join(["'%s'" % p for p in unhandled_params])))
    return args, kwargs

########NEW FILE########
__FILENAME__ = imagekit
from __future__ import unicode_literals

from django import template
from django.utils.html import escape
from django.utils.safestring import mark_safe

from .compat import parse_bits
from ..cachefiles import ImageCacheFile
from ..registry import generator_registry
from ..lib import force_text


register = template.Library()


ASSIGNMENT_DELIMETER = 'as'
HTML_ATTRS_DELIMITER = '--'
DEFAULT_THUMBNAIL_GENERATOR = 'imagekit:thumbnail'


def get_cachefile(context, generator_id, generator_kwargs, source=None):
    generator_id = generator_id.resolve(context)
    kwargs = dict((k, v.resolve(context)) for k, v in generator_kwargs.items())
    generator = generator_registry.get(generator_id, **kwargs)
    return ImageCacheFile(generator)


def parse_dimensions(dimensions):
    """
    Parse the width and height values from a dimension string. Valid values are
    '1x1', '1x', and 'x1'. If one of the dimensions is omitted, the parse result
    will be None for that value.

    """
    width, height = [d.strip() and int(d) or None for d in dimensions.split('x')]
    return dict(width=width, height=height)


class GenerateImageAssignmentNode(template.Node):

    def __init__(self, variable_name, generator_id, generator_kwargs):
        self._generator_id = generator_id
        self._generator_kwargs = generator_kwargs
        self._variable_name = variable_name

    def get_variable_name(self, context):
        return force_text(self._variable_name)

    def render(self, context):
        variable_name = self.get_variable_name(context)
        context[variable_name] = get_cachefile(context, self._generator_id,
                self._generator_kwargs)
        return ''


class GenerateImageTagNode(template.Node):

    def __init__(self, generator_id, generator_kwargs, html_attrs):
        self._generator_id = generator_id
        self._generator_kwargs = generator_kwargs
        self._html_attrs = html_attrs

    def render(self, context):
        file = get_cachefile(context, self._generator_id,
                self._generator_kwargs)
        attrs = dict((k, v.resolve(context)) for k, v in
                self._html_attrs.items())

        # Only add width and height if neither is specified (to allow for
        # proportional in-browser scaling).
        if not 'width' in attrs and not 'height' in attrs:
            attrs.update(width=file.width, height=file.height)

        attrs['src'] = file.url
        attr_str = ' '.join('%s="%s"' % (escape(k), escape(v)) for k, v in
                attrs.items())
        return mark_safe('<img %s />' % attr_str)


class ThumbnailAssignmentNode(template.Node):

    def __init__(self, variable_name, generator_id, dimensions, source, generator_kwargs):
        self._variable_name = variable_name
        self._generator_id = generator_id
        self._dimensions = dimensions
        self._source = source
        self._generator_kwargs = generator_kwargs

    def get_variable_name(self, context):
        return force_text(self._variable_name)

    def render(self, context):
        variable_name = self.get_variable_name(context)

        generator_id = self._generator_id.resolve(context) if self._generator_id else DEFAULT_THUMBNAIL_GENERATOR
        kwargs = dict((k, v.resolve(context)) for k, v in
                self._generator_kwargs.items())
        kwargs['source'] = self._source.resolve(context)
        kwargs.update(parse_dimensions(self._dimensions.resolve(context)))
        generator = generator_registry.get(generator_id, **kwargs)

        context[variable_name] = ImageCacheFile(generator)

        return ''


class ThumbnailImageTagNode(template.Node):

    def __init__(self, generator_id, dimensions, source, generator_kwargs, html_attrs):
        self._generator_id = generator_id
        self._dimensions = dimensions
        self._source = source
        self._generator_kwargs = generator_kwargs
        self._html_attrs = html_attrs

    def render(self, context):
        generator_id = self._generator_id.resolve(context) if self._generator_id else DEFAULT_THUMBNAIL_GENERATOR
        dimensions = parse_dimensions(self._dimensions.resolve(context))
        kwargs = dict((k, v.resolve(context)) for k, v in
                self._generator_kwargs.items())
        kwargs['source'] = self._source.resolve(context)
        kwargs.update(dimensions)
        generator = generator_registry.get(generator_id, **kwargs)

        file = ImageCacheFile(generator)

        attrs = dict((k, v.resolve(context)) for k, v in
                self._html_attrs.items())

        # Only add width and height if neither is specified (to allow for
        # proportional in-browser scaling).
        if not 'width' in attrs and not 'height' in attrs:
            attrs.update(width=file.width, height=file.height)

        attrs['src'] = file.url
        attr_str = ' '.join('%s="%s"' % (escape(k), escape(v)) for k, v in
                attrs.items())
        return mark_safe('<img %s />' % attr_str)


def parse_ik_tag_bits(parser, bits):
    """
    Parses the tag name, html attributes and variable name (for assignment tags)
    from the provided bits. The preceding bits may vary and are left to be
    parsed by specific tags.

    """
    varname = None
    html_attrs = {}
    tag_name = bits.pop(0)

    if len(bits) >= 2 and bits[-2] == ASSIGNMENT_DELIMETER:
        varname = bits[-1]
        bits = bits[:-2]

    if HTML_ATTRS_DELIMITER in bits:

        if varname:
            raise template.TemplateSyntaxError('Do not specify html attributes'
                    ' (using "%s") when using the "%s" tag as an assignment'
                    ' tag.' % (HTML_ATTRS_DELIMITER, tag_name))

        index = bits.index(HTML_ATTRS_DELIMITER)
        html_bits = bits[index + 1:]
        bits = bits[:index]

        if not html_bits:
            raise template.TemplateSyntaxError('Don\'t use "%s" unless you\'re'
                ' setting html attributes.' % HTML_ATTRS_DELIMITER)

        args, html_attrs = parse_bits(parser, html_bits, [], 'args',
                'kwargs', None, False, tag_name)
        if len(args):
            raise template.TemplateSyntaxError('All "%s" tag arguments after'
                    ' the "%s" token must be named.' % (tag_name,
                    HTML_ATTRS_DELIMITER))

    return (tag_name, bits, html_attrs, varname)


#@register.tag
def generateimage(parser, token):
    """
    Creates an image based on the provided arguments.

    By default::

        {% generateimage 'myapp:thumbnail' source=mymodel.profile_image %}

    generates an ``<img>`` tag::

        <img src="/path/to/34d944f200dd794bf1e6a7f37849f72b.jpg" width="100" height="100" />

    You can add additional attributes to the tag using "--". For example,
    this::

        {% generateimage 'myapp:thumbnail' source=mymodel.profile_image -- alt="Hello!" %}

    will result in the following markup::

        <img src="/path/to/34d944f200dd794bf1e6a7f37849f72b.jpg" width="100" height="100" alt="Hello!" />

    For more flexibility, ``generateimage`` also works as an assignment tag::

        {% generateimage 'myapp:thumbnail' source=mymodel.profile_image as th %}
        <img src="{{ th.url }}" width="{{ th.width }}" height="{{ th.height }}" />

    """
    bits = token.split_contents()

    tag_name, bits, html_attrs, varname = parse_ik_tag_bits(parser, bits)

    args, kwargs = parse_bits(parser, bits, ['generator_id'], 'args', 'kwargs',
            None, False, tag_name)

    if len(args) != 1:
        raise template.TemplateSyntaxError('The "%s" tag requires exactly one'
                ' unnamed argument (the generator id).' % tag_name)

    generator_id = args[0]

    if varname:
        return GenerateImageAssignmentNode(varname, generator_id, kwargs)
    else:
        return GenerateImageTagNode(generator_id, kwargs, html_attrs)


#@register.tag
def thumbnail(parser, token):
    """
    A convenient shortcut syntax for generating a thumbnail. The following::

        {% thumbnail '100x100' mymodel.profile_image %}

    is equivalent to::

        {% generateimage 'imagekit:thumbnail' source=mymodel.profile_image width=100 height=100 %}

    The thumbnail tag supports the "--" and "as" bits for adding html
    attributes and assigning to a variable, respectively. It also accepts the
    kwargs "anchor", and "crop".

    To use "smart cropping" (the ``SmartResize`` processor)::

        {% thumbnail '100x100' mymodel.profile_image %}

    To crop, anchoring the image to the top right (the ``ResizeToFill``
    processor)::

        {% thumbnail '100x100' mymodel.profile_image anchor='tr' %}

    To resize without cropping (using the ``ResizeToFit`` processor)::

        {% thumbnail '100x100' mymodel.profile_image crop=0 %}

    """
    bits = token.split_contents()

    tag_name, bits, html_attrs, varname = parse_ik_tag_bits(parser, bits)

    args, kwargs = parse_bits(parser, bits, [], 'args', 'kwargs',
            None, False, tag_name)

    if len(args) < 2:
        raise template.TemplateSyntaxError('The "%s" tag requires at least two'
                ' unnamed arguments: the dimensions and the source image.'
                % tag_name)
    elif len(args) > 3:
        raise template.TemplateSyntaxError('The "%s" tag accepts at most three'
                ' unnamed arguments: a generator id, the dimensions, and the'
                ' source image.' % tag_name)

    dimensions, source = args[-2:]
    generator_id = args[0] if len(args) > 2 else None

    if varname:
        return ThumbnailAssignmentNode(varname, generator_id, dimensions,
                source, kwargs)
    else:
        return ThumbnailImageTagNode(generator_id, dimensions, source, kwargs,
                html_attrs)


generateimage = register.tag(generateimage)
thumbnail = register.tag(thumbnail)

########NEW FILE########
__FILENAME__ = utils
from __future__ import unicode_literals
import logging
import re
from tempfile import NamedTemporaryFile
from hashlib import md5

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.files import File
from django.utils.importlib import import_module
from pilkit.utils import *
from .lib import NullHandler, force_bytes


bad_memcached_key_chars = re.compile('[\u0000-\u001f\\s]+')

_autodiscovered = False

def get_nonabstract_descendants(model):
    """ Returns all non-abstract descendants of the model. """
    if not model._meta.abstract:
        yield model
    for s in model.__subclasses__():
        for m in get_nonabstract_descendants(s):
            yield m


def get_by_qname(path, desc):
    try:
        dot = path.rindex('.')
    except ValueError:
        raise ImproperlyConfigured("%s isn't a %s module." % (path, desc))
    module, objname = path[:dot], path[dot + 1:]
    try:
        mod = import_module(module)
    except ImportError as e:
        raise ImproperlyConfigured('Error importing %s module %s: "%s"' %
                (desc, module, e))
    try:
        obj = getattr(mod, objname)
        return obj
    except AttributeError:
        raise ImproperlyConfigured('%s module "%s" does not define "%s"'
                % (desc[0].upper() + desc[1:], module, objname))


_singletons = {}


def get_singleton(class_path, desc):
    global _singletons
    cls = get_by_qname(class_path, desc)
    instance = _singletons.get(cls)
    if not instance:
        instance = _singletons[cls] = cls()
    return instance


def autodiscover():
    """
    Auto-discover INSTALLED_APPS imagegenerators.py modules and fail silently
    when not present. This forces an import on them to register any admin bits
    they may want.

    Copied from django.contrib.admin
    """
    global _autodiscovered

    if _autodiscovered:
        return

    from django.conf import settings
    from django.utils.importlib import import_module
    from django.utils.module_loading import module_has_submodule

    _autodiscovered = True

    for app in settings.INSTALLED_APPS:
        mod = import_module(app)
        # Attempt to import the app's admin module.
        try:
            import_module('%s.imagegenerators' % app)
        except:
            # Decide whether to bubble up this error. If the app just
            # doesn't have an imagegenerators module, we can ignore the error
            # attempting to import it, otherwise we want it to bubble up.
            if module_has_submodule(mod, 'imagegenerators'):
                raise


def get_logger(logger_name='imagekit', add_null_handler=True):
    logger = logging.getLogger(logger_name)
    if add_null_handler:
        logger.addHandler(NullHandler())
    return logger


def get_field_info(field_file):
    """
    A utility for easily extracting information about the host model from a
    Django FileField (or subclass). This is especially useful for when you want
    to alter processors based on a property of the source model. For example::

        class MySpec(ImageSpec):
            def __init__(self, source):
                instance, attname = get_field_info(source)
                self.processors = [SmartResize(instance.thumbnail_width,
                                               instance.thumbnail_height)]

    """
    return (
        getattr(field_file, 'instance', None),
        getattr(getattr(field_file, 'field', None), 'attname', None),
    )


def generate(generator):
    """
    Calls the ``generate()`` method of a generator instance, and then wraps the
    result in a Django File object so Django knows how to save it.

    """
    content = generator.generate()

    # If the file doesn't have a name, Django will raise an Exception while
    # trying to save it, so we create a named temporary file.
    if not getattr(content, 'name', None):
        f = NamedTemporaryFile()
        f.write(content.read())
        f.seek(0)
        content = f

    return File(content)


def call_strategy_method(file, method_name):
    strategy = getattr(file, 'cachefile_strategy', None)
    fn = getattr(strategy, method_name, None)
    if fn is not None:
        fn(file)


def sanitize_cache_key(key):
    if settings.IMAGEKIT_USE_MEMCACHED_SAFE_CACHE_KEY:
        # Memcached keys can't contain whitespace or control characters.
        new_key = bad_memcached_key_chars.sub('', key)

        # The also can't be > 250 chars long. Since we don't know what the
        # user's cache ``KEY_FUNCTION`` setting is like, we'll limit it to 200.
        if len(new_key) >= 200:
            new_key = '%s:%s' % (new_key[:200-33], md5(force_bytes(key)).hexdigest())

        key = new_key
    return key

########NEW FILE########
__FILENAME__ = testrunner
# A wrapper for Django's test runner.
# See http://ericholscher.com/blog/2009/jun/29/enable-setuppy-test-your-django-apps/
# and http://gremu.net/blog/2010/enable-setuppy-test-your-django-apps/
import os
import sys

os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.settings'
test_dir = os.path.dirname(__file__)
sys.path.insert(0, test_dir)

from django.test.utils import get_runner
from django.conf import settings


def run_tests():
    cls = get_runner(settings)
    runner = cls()
    failures = runner.run_tests(['tests'])
    sys.exit(failures)

########NEW FILE########
__FILENAME__ = imagegenerators
from imagekit import ImageSpec, register
from imagekit.processors import ResizeToFill


class TestSpec(ImageSpec):
    pass


class ResizeTo1PixelSquare(ImageSpec):
    def __init__(self, width=None, height=None, anchor=None, crop=None, **kwargs):
        self.processors = [ResizeToFill(1, 1)]
        super(ResizeTo1PixelSquare, self).__init__(**kwargs)


register.generator('testspec', TestSpec)
register.generator('1pxsq', ResizeTo1PixelSquare)

########NEW FILE########
__FILENAME__ = models
from django.db import models

from imagekit.models import ProcessedImageField
from imagekit.models import ImageSpecField
from imagekit.processors import Adjust, ResizeToFill, SmartCrop


class ImageModel(models.Model):
    image = models.ImageField(upload_to='b')


class Photo(models.Model):
    original_image = models.ImageField(upload_to='photos')

    # Implicit source field
    thumbnail = ImageSpecField([Adjust(contrast=1.2, sharpness=1.1),
                               ResizeToFill(50, 50)], format='JPEG',
                               options={'quality': 90})

    smartcropped_thumbnail = ImageSpecField([Adjust(contrast=1.2,
            sharpness=1.1), SmartCrop(50, 50)], source='original_image',
            format='JPEG', options={'quality': 90})


class ProcessedImageFieldModel(models.Model):
    processed = ProcessedImageField([SmartCrop(50, 50)], format='JPEG',
            options={'quality': 90}, upload_to='p')


class CountingCacheFileStrategy(object):
    def __init__(self):
        self.on_existence_required_count = 0
        self.on_content_required_count = 0
        self.on_source_saved_count = 0

    def on_existence_required(self, file):
        self.on_existence_required_count += 1

    def on_content_required(self, file):
        self.on_content_required_count += 1

    def on_source_saved(self, file):
        self.on_source_saved_count += 1


class AbstractImageModel(models.Model):
    original_image = models.ImageField(upload_to='photos')
    abstract_class_spec = ImageSpecField(source='original_image',
                                         format='JPEG',
                                         cachefile_strategy=CountingCacheFileStrategy())

    class Meta:
        abstract = True


class ConcreteImageModel(AbstractImageModel):
    pass


class ConcreteImageModelSubclass(ConcreteImageModel):
    pass

########NEW FILE########
__FILENAME__ = settings
import os

ADMINS = (
    ('test@example.com', 'TEST-R'),
)

BASE_PATH = os.path.abspath(os.path.dirname(__file__))

MEDIA_ROOT = os.path.normpath(os.path.join(BASE_PATH, 'media'))

# Django <= 1.2
DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = 'imagekit.db'
TEST_DATABASE_NAME = 'imagekit-test.db'

# Django >= 1.3
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'imagekit.db',
    },
}

SECRET_KEY = '_uobce43e5osp8xgzle*yag2_16%y$sf*5(12vfg25hpnxik_*'

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'imagekit',
    'tests',
    'django_nose',
]

TEST_RUNNER = 'django_nose.NoseTestSuiteRunner'
NOSE_ARGS = [
    '-s',
    '--with-progressive',

    # When the tests are run --with-coverage, these args configure coverage
    # reporting (requires coverage to be installed).
    # Without the --with-coverage flag, they have no effect.
    '--cover-tests',
    '--cover-html',
    '--cover-package=imagekit',
    '--cover-html-dir=%s' % os.path.join(BASE_PATH, 'cover')
]

DEBUG = True
TEMPLATE_DEBUG = DEBUG
CACHE_BACKEND = 'locmem://'

########NEW FILE########
__FILENAME__ = test_abstract_models
from imagekit.utils import get_nonabstract_descendants
from nose.tools import eq_
from . models import (AbstractImageModel, ConcreteImageModel,
                      ConcreteImageModelSubclass)


def test_nonabstract_descendants_generator():
    descendants = list(get_nonabstract_descendants(AbstractImageModel))
    eq_(descendants, [ConcreteImageModel, ConcreteImageModelSubclass])

########NEW FILE########
__FILENAME__ = test_cachefiles
from django.conf import settings
from hashlib import md5
from imagekit.cachefiles import ImageCacheFile, LazyImageCacheFile
from imagekit.cachefiles.backends import Simple
from imagekit.lib import force_bytes
from nose.tools import raises, eq_
from .imagegenerators import TestSpec
from .utils import (assert_file_is_truthy, assert_file_is_falsy,
                    DummyAsyncCacheFileBackend, get_unique_image_file,
                    get_image_file)


def test_no_source_falsiness():
    """
    Ensure cache files generated from sourceless specs are falsy.

    """
    spec = TestSpec(source=None)
    file = ImageCacheFile(spec)
    assert_file_is_falsy(file)


def test_sync_backend_truthiness():
    """
    Ensure that a cachefile with a synchronous cache file backend (the default)
    is truthy.

    """
    spec = TestSpec(source=get_unique_image_file())
    file = ImageCacheFile(spec)
    assert_file_is_truthy(file)


def test_async_backend_falsiness():
    """
    Ensure that a cachefile with an asynchronous cache file backend is falsy.

    """
    spec = TestSpec(source=get_unique_image_file())
    file = ImageCacheFile(spec, cachefile_backend=DummyAsyncCacheFileBackend())
    assert_file_is_falsy(file)


@raises(TestSpec.MissingSource)
def test_no_source_error():
    spec = TestSpec(source=None)
    file = ImageCacheFile(spec)
    file.generate()


def test_memcached_cache_key():
    """
    Ensure the default cachefile backend is sanitizing its cache key for
    memcached by default.

    """

    class MockFile(object):
        def __init__(self, name):
            self.name = name

    backend = Simple()
    extra_char_count = len('state-') + len(settings.IMAGEKIT_CACHE_PREFIX)

    length = 199 - extra_char_count
    filename = '1' * length
    file = MockFile(filename)
    eq_(backend.get_key(file), '%s%s-state' %
        (settings.IMAGEKIT_CACHE_PREFIX, file.name))

    length = 200 - extra_char_count
    filename = '1' * length
    file = MockFile(filename)
    eq_(backend.get_key(file), '%s%s:%s' % (
        settings.IMAGEKIT_CACHE_PREFIX,
        '1' * (200 - len(':') - 32 - len(settings.IMAGEKIT_CACHE_PREFIX)),
        md5(force_bytes('%s%s-state' % (settings.IMAGEKIT_CACHE_PREFIX, filename))).hexdigest()))


def test_lazyfile_stringification():
    file = LazyImageCacheFile('testspec', source=None)
    eq_(str(file), '')
    eq_(repr(file), '<ImageCacheFile: None>')

    source_file = get_image_file()
    file = LazyImageCacheFile('testspec', source=source_file)
    file.name = 'a.jpg'
    eq_(str(file), 'a.jpg')
    eq_(repr(file), '<ImageCacheFile: a.jpg>')

########NEW FILE########
__FILENAME__ = test_fields
from django import forms
from django.core.files.base import File
from django.core.files.uploadedfile import SimpleUploadedFile
from imagekit import forms as ikforms
from imagekit.processors import SmartCrop
from nose.tools import eq_
from . import imagegenerators  # noqa
from .models import ProcessedImageFieldModel, ImageModel
from .utils import get_image_file


def test_model_processedimagefield():
    instance = ProcessedImageFieldModel()
    file = File(get_image_file())
    instance.processed.save('whatever.jpeg', file)
    instance.save()

    eq_(instance.processed.width, 50)
    eq_(instance.processed.height, 50)


def test_form_processedimagefield():
    class TestForm(forms.ModelForm):
        image = ikforms.ProcessedImageField(spec_id='tests:testform_image',
                processors=[SmartCrop(50, 50)], format='JPEG')

        class Meta:
            model = ImageModel

    upload_file = get_image_file()
    file_dict = {'image': SimpleUploadedFile('abc.jpg', upload_file.read())}
    form = TestForm({}, file_dict)
    instance = form.save()

    eq_(instance.image.width, 50)
    eq_(instance.image.height, 50)

########NEW FILE########
__FILENAME__ = test_generateimage_tag
from django.template import TemplateSyntaxError
from nose.tools import eq_, assert_false, raises, assert_not_equal
from . import imagegenerators  # noqa
from .utils import render_tag, get_html_attrs


def test_img_tag():
    ttag = r"""{% generateimage 'testspec' source=img %}"""
    attrs = get_html_attrs(ttag)
    expected_attrs = set(['src', 'width', 'height'])
    eq_(set(attrs.keys()), expected_attrs)
    for k in expected_attrs:
        assert_not_equal(attrs[k].strip(), '')


def test_img_tag_attrs():
    ttag = r"""{% generateimage 'testspec' source=img -- alt="Hello" %}"""
    attrs = get_html_attrs(ttag)
    eq_(attrs.get('alt'), 'Hello')


@raises(TemplateSyntaxError)
def test_dangling_html_attrs_delimiter():
    ttag = r"""{% generateimage 'testspec' source=img -- %}"""
    render_tag(ttag)


@raises(TemplateSyntaxError)
def test_html_attrs_assignment():
    """
    You can either use generateimage as an assigment tag or specify html attrs,
    but not both.

    """
    ttag = r"""{% generateimage 'testspec' source=img -- alt="Hello" as th %}"""
    render_tag(ttag)


def test_single_dimension_attr():
    """
    If you only provide one of width or height, the other should not be added.

    """
    ttag = r"""{% generateimage 'testspec' source=img -- width="50" %}"""
    attrs = get_html_attrs(ttag)
    assert_false('height' in attrs)


def test_assignment_tag():
    ttag = r"""{% generateimage 'testspec' source=img as th %}{{ th.url }}"""
    html = render_tag(ttag)
    assert_not_equal(html.strip(), '')

########NEW FILE########
__FILENAME__ = test_serialization
"""
Make sure that the various IK classes can be successfully serialized and
deserialized. This is important when using IK with Celery.

"""

from imagekit.cachefiles import ImageCacheFile
from .imagegenerators import TestSpec
from .utils import create_photo, pickleback, get_unique_image_file


def test_imagespecfield():
    instance = create_photo('pickletest2.jpg')
    thumbnail = pickleback(instance.thumbnail)
    thumbnail.generate()


def test_circular_ref():
    """
    A model instance with a spec field in its dict shouldn't raise a KeyError.

    This corresponds to #234

    """
    instance = create_photo('pickletest3.jpg')
    instance.thumbnail  # Cause thumbnail to be added to instance's __dict__
    pickleback(instance)
	

def test_cachefiles():
    spec = TestSpec(source=get_unique_image_file())
    file = ImageCacheFile(spec)
    file.url
    # remove link to file from spec source generator
    # test __getstate__ of ImageCacheFile
    file.generator.source = None
    pickleback(file)

########NEW FILE########
__FILENAME__ = test_sourcegroups
from django.core.files import File
from imagekit.signals import source_saved
from imagekit.specs.sourcegroups import ImageFieldSourceGroup
from nose.tools import eq_
from . models import AbstractImageModel, ImageModel, ConcreteImageModel
from .utils import get_image_file


def make_counting_receiver(source_group):
    def receiver(sender, *args, **kwargs):
        if sender is source_group:
            receiver.count += 1
    receiver.count = 0
    return receiver


def test_source_saved_signal():
    """
    Creating a new instance with an image causes the source_saved signal to be
    dispatched.

    """
    source_group = ImageFieldSourceGroup(ImageModel, 'image')
    receiver = make_counting_receiver(source_group)
    source_saved.connect(receiver)
    ImageModel.objects.create(image=File(get_image_file()))
    eq_(receiver.count, 1)


def test_no_source_saved_signal():
    """
    Creating a new instance without an image shouldn't cause the source_saved
    signal to be dispatched.

    https://github.com/matthewwithanm/django-imagekit/issues/214

    """
    source_group = ImageFieldSourceGroup(ImageModel, 'image')
    receiver = make_counting_receiver(source_group)
    source_saved.connect(receiver)
    ImageModel.objects.create()
    eq_(receiver.count, 0)


def test_abstract_model_signals():
    """
    Source groups created for abstract models must cause signals to be
    dispatched on their concrete subclasses.

    """
    source_group = ImageFieldSourceGroup(AbstractImageModel, 'original_image')
    receiver = make_counting_receiver(source_group)
    source_saved.connect(receiver)
    ConcreteImageModel.objects.create(original_image=File(get_image_file()))
    eq_(receiver.count, 1)

########NEW FILE########
__FILENAME__ = test_thumbnail_tag
from django.template import TemplateSyntaxError
from nose.tools import eq_, raises, assert_not_equal
from . import imagegenerators  # noqa
from .utils import render_tag, get_html_attrs


def test_img_tag():
    ttag = r"""{% thumbnail '100x100' img %}"""
    attrs = get_html_attrs(ttag)
    expected_attrs = set(['src', 'width', 'height'])
    eq_(set(attrs.keys()), expected_attrs)
    for k in expected_attrs:
        assert_not_equal(attrs[k].strip(), '')


def test_img_tag_attrs():
    ttag = r"""{% thumbnail '100x100' img -- alt="Hello" %}"""
    attrs = get_html_attrs(ttag)
    eq_(attrs.get('alt'), 'Hello')


@raises(TemplateSyntaxError)
def test_dangling_html_attrs_delimiter():
    ttag = r"""{% thumbnail '100x100' img -- %}"""
    render_tag(ttag)


@raises(TemplateSyntaxError)
def test_not_enough_args():
    ttag = r"""{% thumbnail '100x100' %}"""
    render_tag(ttag)


@raises(TemplateSyntaxError)
def test_too_many_args():
    ttag = r"""{% thumbnail 'generator_id' '100x100' img 'extra' %}"""
    render_tag(ttag)


@raises(TemplateSyntaxError)
def test_html_attrs_assignment():
    """
    You can either use thumbnail as an assigment tag or specify html attrs,
    but not both.

    """
    ttag = r"""{% thumbnail '100x100' img -- alt="Hello" as th %}"""
    render_tag(ttag)


def test_assignment_tag():
    ttag = r"""{% thumbnail '100x100' img as th %}{{ th.url }}"""
    html = render_tag(ttag)
    assert_not_equal(html, '')


def test_single_dimension():
    ttag = r"""{% thumbnail '100x' img as th %}{{ th.width }}"""
    html = render_tag(ttag)
    eq_(html, '100')


def test_alternate_generator():
    ttag = r"""{% thumbnail '1pxsq' '100x' img as th %}{{ th.width }}"""
    html = render_tag(ttag)
    eq_(html, '1')

########NEW FILE########
__FILENAME__ = utils
from bs4 import BeautifulSoup
import os
from django.conf import settings
from django.core.files import File
from django.template import Context, Template
from imagekit.cachefiles.backends import Simple, CacheFileState
from imagekit.lib import Image, StringIO
from nose.tools import assert_true, assert_false
import pickle
from tempfile import NamedTemporaryFile
from .models import Photo


def get_image_file():
    """
    See also:

    http://en.wikipedia.org/wiki/Lenna
    http://sipi.usc.edu/database/database.php?volume=misc&image=12

    """
    path = os.path.join(settings.MEDIA_ROOT, 'lenna.png')
    return open(path, 'r+b')


def get_unique_image_file():
    file = NamedTemporaryFile()
    file.write(get_image_file().read())
    return file


def create_image():
    return Image.open(get_image_file())


def create_instance(model_class, image_name):
    instance = model_class()
    img = File(get_image_file())
    instance.original_image.save(image_name, img)
    instance.save()
    img.close()
    return instance


def create_photo(name):
    return create_instance(Photo, name)


def pickleback(obj):
    pickled = StringIO()
    pickle.dump(obj, pickled)
    pickled.seek(0)
    return pickle.load(pickled)


def render_tag(ttag):
    img = get_image_file()
    template = Template('{%% load imagekit %%}%s' % ttag)
    context = Context({'img': img})
    return template.render(context)


def get_html_attrs(ttag):
    return BeautifulSoup(render_tag(ttag)).img.attrs


def assert_file_is_falsy(file):
    assert_false(bool(file), 'File is not falsy')


def assert_file_is_truthy(file):
    assert_true(bool(file), 'File is not truthy')


class DummyAsyncCacheFileBackend(Simple):
    """
    A cache file backend meant to simulate async generation.

    """
    def generate(self, file, force=False):
        pass

########NEW FILE########
