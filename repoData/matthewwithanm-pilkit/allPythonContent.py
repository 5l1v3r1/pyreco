__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PILKit documentation build configuration file, created by
# sphinx-quickstart on Thu Feb  7 20:01:22 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import re, sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PILKit'
copyright = u'2013, Matthew Tretter'

pkgmeta = {}
pkgmeta_file = os.path.join(os.path.dirname(__file__), '..', '..', 'pilkit',
                            'pkgmeta.py')
with open(pkgmeta_file) as f:
    code = compile(f.read(), 'pkgmeta.py', 'exec')
    exec(code, pkgmeta)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = re.match('\d+\.\d+', pkgmeta['__version__']).group()
# The full version, including alpha/beta/rc tags.
release = pkgmeta['__version__']

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'PILKitdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PILKit.tex', u'PILKit Documentation',
   u'Matthew Tretter', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pilkit', u'PILKit Documentation',
     [u'Matthew Tretter'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'PILKit', u'PILKit Documentation',
   u'Matthew Tretter', 'PILKit', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = exceptions
class UnknownExtension(Exception):
    pass


class UnknownFormat(Exception):
    pass

########NEW FILE########
__FILENAME__ = lib
# flake8: noqa

# Required PIL classes may or may not be available from the root namespace
# depending on the installation method used.
try:
    from PIL import Image, ImageColor, ImageChops, ImageEnhance, ImageFile, \
            ImageFilter, ImageDraw, ImageStat
except ImportError:
    try:
        import Image
        import ImageColor
        import ImageChops
        import ImageEnhance
        import ImageFile
        import ImageFilter
        import ImageDraw
        import ImageStat
    except ImportError:
        raise ImportError('PILKit was unable to import the Python Imaging Library. Please confirm it`s installed and available on your current Python path.')

try:
    from io import BytesIO as StringIO
except ImportError as exc:
    try:
        from cStringIO import StringIO
    except ImportError:
        try:
            from StringIO import StringIO
        except ImportError:
            raise exc

try:
    string_types = [basestring, str]
except NameError:
    string_types = [str]

########NEW FILE########
__FILENAME__ = pkgmeta
__title__ = 'pilkit'
__author__ = 'Matthew Tretter'
__version__ = '1.1.9'
__license__ = 'BSD'
__all__ = ['__title__', '__author__', '__version__', '__license__']

########NEW FILE########
__FILENAME__ = base
from pilkit.lib import Image, ImageColor, ImageEnhance


class ProcessorPipeline(list):
    """
    A :class:`list` of other processors. This class allows any object that
    knows how to deal with a single processor to deal with a list of them.
    For example::

        processed_image = ProcessorPipeline([ProcessorA(), ProcessorB()]).process(image)

    """
    def process(self, img):
        for proc in self:
            img = proc.process(img)
        return img


class Adjust(object):
    """
    Performs color, brightness, contrast, and sharpness enhancements on the
    image. See :mod:`PIL.ImageEnhance` for more imformation.

    """
    def __init__(self, color=1.0, brightness=1.0, contrast=1.0, sharpness=1.0):
        """
        :param color: A number between 0 and 1 that specifies the saturation
            of the image. 0 corresponds to a completely desaturated image
            (black and white) and 1 to the original color.
            See :class:`PIL.ImageEnhance.Color`
        :param brightness: A number representing the brightness; 0 results in
            a completely black image whereas 1 corresponds to the brightness
            of the original. See :class:`PIL.ImageEnhance.Brightness`
        :param contrast: A number representing the contrast; 0 results in a
            completely gray image whereas 1 corresponds to the contrast of
            the original. See :class:`PIL.ImageEnhance.Contrast`
        :param sharpness: A number representing the sharpness; 0 results in a
            blurred image; 1 corresponds to the original sharpness; 2
            results in a sharpened image. See
            :class:`PIL.ImageEnhance.Sharpness`

        """
        self.color = color
        self.brightness = brightness
        self.contrast = contrast
        self.sharpness = sharpness

    def process(self, img):
        original = img = img.convert('RGBA')
        for name in ['Color', 'Brightness', 'Contrast', 'Sharpness']:
            factor = getattr(self, name.lower())
            if factor != 1.0:
                try:
                    img = getattr(ImageEnhance, name)(img).enhance(factor)
                except ValueError:
                    pass
                else:
                    # PIL's Color and Contrast filters both convert the image
                    # to L mode, losing transparency info, so we put it back.
                    # See https://github.com/jdriscoll/django-imagekit/issues/64
                    if name in ('Color', 'Contrast'):
                        img = Image.merge('RGBA', img.split()[:3] +
                                original.split()[3:4])
        return img


class Reflection(object):
    """
    Creates an image with a reflection.

    """
    def __init__(self, background_color='#FFFFFF', size=0.0, opacity=0.6):
        self.background_color = background_color
        self.size = size
        self.opacity = opacity

    def process(self, img):
        # Convert bgcolor string to RGB value.
        background_color = ImageColor.getrgb(self.background_color)
        # Handle palleted images.
        img = img.convert('RGBA')
        # Copy orignial image and flip the orientation.
        reflection = img.copy().transpose(Image.FLIP_TOP_BOTTOM)
        # Create a new image filled with the bgcolor the same size.
        background = Image.new("RGBA", img.size, background_color)
        # Calculate our alpha mask.
        start = int(255 - (255 * self.opacity))  # The start of our gradient.
        steps = int(255 * self.size)  # The number of intermedite values.
        increment = (255 - start) / float(steps)
        mask = Image.new('L', (1, 255))
        for y in range(255):
            if y < steps:
                val = int(y * increment + start)
            else:
                val = 255
            mask.putpixel((0, y), val)
        alpha_mask = mask.resize(img.size)
        # Merge the reflection onto our background color using the alpha mask.
        reflection = Image.composite(background, reflection, alpha_mask)
        # Crop the reflection.
        reflection_height = int(img.size[1] * self.size)
        reflection = reflection.crop((0, 0, img.size[0], reflection_height))
        # Create new image sized to hold both the original image and
        # the reflection.
        composite = Image.new("RGBA", (img.size[0], img.size[1] + reflection_height), background_color)
        # Paste the orignal image and the reflection into the composite image.
        composite.paste(img, (0, 0))
        composite.paste(reflection, (0, img.size[1]))
        # Return the image complete with reflection effect.
        return composite


class Transpose(object):
    """
    Rotates or flips the image.

    """
    AUTO = 'auto'
    FLIP_HORIZONTAL = Image.FLIP_LEFT_RIGHT
    FLIP_VERTICAL = Image.FLIP_TOP_BOTTOM
    ROTATE_90 = Image.ROTATE_90
    ROTATE_180 = Image.ROTATE_180
    ROTATE_270 = Image.ROTATE_270

    methods = [AUTO]
    _EXIF_ORIENTATION_STEPS = {
        1: [],
        2: [FLIP_HORIZONTAL],
        3: [ROTATE_180],
        4: [FLIP_VERTICAL],
        5: [ROTATE_270, FLIP_HORIZONTAL],
        6: [ROTATE_270],
        7: [ROTATE_90, FLIP_HORIZONTAL],
        8: [ROTATE_90],
    }

    def __init__(self, *args):
        """
        Possible arguments:
            - Transpose.AUTO
            - Transpose.FLIP_HORIZONTAL
            - Transpose.FLIP_VERTICAL
            - Transpose.ROTATE_90
            - Transpose.ROTATE_180
            - Transpose.ROTATE_270

        The order of the arguments dictates the order in which the
        Transposition steps are taken.

        If Transpose.AUTO is present, all other arguments are ignored, and
        the processor will attempt to rotate the image according to the
        EXIF Orientation data.

        """
        super(Transpose, self).__init__()
        if args:
            self.methods = args

    def process(self, img):
        if self.AUTO in self.methods:
            try:
                orientation = img._getexif()[0x0112]
                ops = self._EXIF_ORIENTATION_STEPS[orientation]
            except (IndexError, KeyError, TypeError, AttributeError):
                ops = []
        else:
            ops = self.methods
        for method in ops:
            img = img.transpose(method)
        return img


class Anchor(object):
    """
    Defines all the anchor points needed by the various processor classes.

    """
    TOP_LEFT = 'tl'
    TOP = 't'
    TOP_RIGHT = 'tr'
    BOTTOM_LEFT = 'bl'
    BOTTOM = 'b'
    BOTTOM_RIGHT = 'br'
    CENTER = 'c'
    LEFT = 'l'
    RIGHT = 'r'

    _ANCHOR_PTS = {
        TOP_LEFT: (0, 0),
        TOP: (0.5, 0),
        TOP_RIGHT: (1, 0),
        LEFT: (0, 0.5),
        CENTER: (0.5, 0.5),
        RIGHT: (1, 0.5),
        BOTTOM_LEFT: (0, 1),
        BOTTOM: (0.5, 1),
        BOTTOM_RIGHT: (1, 1),
    }

    @staticmethod
    def get_tuple(anchor):
        """Normalizes anchor values (strings or tuples) to tuples.

        """
        # If the user passed in one of the string values, convert it to a
        # percentage tuple.
        if anchor in Anchor._ANCHOR_PTS.keys():
            anchor = Anchor._ANCHOR_PTS[anchor]
        return anchor


class MakeOpaque(object):
    """
    Pastes the provided image onto an image of a solid color. Used for when you
    want to make transparent images opaque.

    """
    def __init__(self, background_color=(255, 255, 255)):
        self.background_color = background_color

    def process(self, img):
        new_img = Image.new('RGBA', img.size, self.background_color)
        new_img.paste(img, img)
        return new_img

########NEW FILE########
__FILENAME__ = crop
from .base import Anchor  # noqa
from .utils import histogram_entropy
from ..lib import Image, ImageChops, ImageDraw, ImageStat


class Side(object):
    TOP = 't'
    RIGHT = 'r'
    BOTTOM = 'b'
    LEFT = 'l'
    ALL = (TOP, RIGHT, BOTTOM, LEFT)


def _crop(img, bbox, sides=Side.ALL):
    bbox = (
        bbox[0] if Side.LEFT in sides else 0,
        bbox[1] if Side.TOP in sides else 0,
        bbox[2] if Side.RIGHT in sides else img.size[0],
        bbox[3] if Side.BOTTOM in sides else img.size[1],
    )
    return img.crop(bbox)


def detect_border_color(img):
    mask = Image.new('1', img.size, 1)
    w, h = img.size[0] - 2, img.size[1] - 2
    if w > 0 and h > 0:
        draw = ImageDraw.Draw(mask)
        draw.rectangle([1, 1, w, h], 0)
    return ImageStat.Stat(img.convert('RGBA').histogram(mask)).median


class TrimBorderColor(object):
    """Trims a color from the sides of an image.

    """
    def __init__(self, color=None, tolerance=0.3, sides=Side.ALL):
        """
        :param color: The color to trim from the image, in a 4-tuple RGBA value,
            where each component is an integer between 0 and 255, inclusive. If
            no color is provided, the processor will attempt to detect the
            border color automatically.
        :param tolerance: A number between 0 and 1 where 0. Zero is the least
            tolerant and one is the most.
        :param sides: A list of sides that should be trimmed. Possible values
            are provided by the :class:`Side` enum class.

        """
        self.color = color
        self.sides = sides
        self.tolerance = tolerance

    def process(self, img):
        source = img.convert('RGBA')
        border_color = self.color or tuple(detect_border_color(source))
        bg = Image.new('RGBA', img.size, border_color)
        diff = ImageChops.difference(source, bg)
        if self.tolerance not in (0, 1):
            # If tolerance is zero, we've already done the job. A tolerance of
            # one would mean to trim EVERY color, and since that would result
            # in a zero-sized image, we just ignore it.
            if not 0 <= self.tolerance <= 1:
                raise ValueError('%s is an invalid tolerance. Acceptable values'
                        ' are between 0 and 1 (inclusive).' % self.tolerance)
            tmp = ImageChops.constant(diff, int(self.tolerance * 255)) \
                    .convert('RGBA')
            diff = ImageChops.subtract(diff, tmp)

        bbox = diff.getbbox()
        if bbox:
            img = _crop(img, bbox, self.sides)
        return img


class Crop(object):
    """
    Crops an image, cropping it to the specified width and height. You may
    optionally provide either an anchor or x and y coordinates. This processor
    functions exactly the same as ``ResizeCanvas`` except that it will never
    enlarge the image.

    """

    def __init__(self, width=None, height=None, anchor=None, x=None, y=None):
        self.width = width
        self.height = height
        self.anchor = anchor
        self.x = x
        self.y = y

    def process(self, img):
        from .resize import ResizeCanvas

        original_width, original_height = img.size
        new_width, new_height = min(original_width, self.width), \
                min(original_height, self.height)

        return ResizeCanvas(new_width, new_height, anchor=self.anchor,
                x=self.x, y=self.y).process(img)


class SmartCrop(object):
    """
    Crop an image to the specified dimensions, whittling away the parts of the
    image with the least entropy.

    Based on smart crop implementation from easy-thumbnails:
        https://github.com/SmileyChris/easy-thumbnails/blob/master/easy_thumbnails/processors.py#L193

    """

    def __init__(self, width=None, height=None):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.

        """
        self.width = width
        self.height = height

    def compare_entropy(self, start_slice, end_slice, slice, difference):
        """
        Calculate the entropy of two slices (from the start and end of an axis),
        returning a tuple containing the amount that should be added to the start
        and removed from the end of the axis.

        """
        start_entropy = histogram_entropy(start_slice)
        end_entropy = histogram_entropy(end_slice)

        if end_entropy and abs(start_entropy / end_entropy - 1) < 0.01:
            # Less than 1% difference, remove from both sides.
            if difference >= slice * 2:
                return slice, slice
            half_slice = slice // 2
            return half_slice, slice - half_slice

        if start_entropy > end_entropy:
            return 0, slice
        else:
            return slice, 0

    def process(self, img):
        source_x, source_y = img.size
        diff_x = int(source_x - min(source_x, self.width))
        diff_y = int(source_y - min(source_y, self.height))
        left = top = 0
        right, bottom = source_x, source_y

        while diff_x:
            slice = min(diff_x, max(diff_x // 5, 10))
            start = img.crop((left, 0, left + slice, source_y))
            end = img.crop((right - slice, 0, right, source_y))
            add, remove = self.compare_entropy(start, end, slice, diff_x)
            left += add
            right -= remove
            diff_x = diff_x - add - remove

        while diff_y:
            slice = min(diff_y, max(diff_y // 5, 10))
            start = img.crop((0, top, source_x, top + slice))
            end = img.crop((0, bottom - slice, source_x, bottom))
            add, remove = self.compare_entropy(start, end, slice, diff_y)
            top += add
            bottom -= remove
            diff_y = diff_y - add - remove

        box = (left, top, right, bottom)
        img = img.crop(box)
        return img

########NEW FILE########
__FILENAME__ = resize
from .base import Anchor
from ..lib import Image


class Resize(object):
    """
    Resizes an image to the specified width and height.

    """
    def __init__(self, width, height, upscale=True):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.
        :param upscale: Should the image be enlarged if smaller than the dimensions?

        """
        self.width = width
        self.height = height
        self.upscale = upscale

    def process(self, img):
        if self.upscale or (self.width < img.size[0] and self.height < img.size[1]):
            img = img.convert('RGBA')
            img = img.resize((self.width, self.height), Image.ANTIALIAS)
        return img


class ResizeToCover(object):
    """
    Resizes the image to the smallest possible size that will entirely cover the
    provided dimensions. You probably won't be using this processor directly,
    but it's used internally by ``ResizeToFill`` and ``SmartResize``.

    """
    def __init__(self, width, height, upscale=True):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.

        """
        self.width, self.height = width, height
        self.upscale = upscale

    def process(self, img):
        original_width, original_height = img.size
        ratio = max(float(self.width) / original_width,
                float(self.height) / original_height)
        new_width, new_height = (int(round(original_width * ratio)),
                int(round(original_height * ratio)))
        img = Resize(new_width, new_height, upscale=self.upscale).process(img)
        return img


class ResizeToFill(object):
    """
    Resizes an image, cropping it to the exact specified width and height.

    """

    def __init__(self, width=None, height=None, anchor=None, upscale=True):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.
        :param anchor: Specifies which part of the image should be retained
            when cropping.
        :param upscale: Should the image be enlarged if smaller than the dimensions?

        """
        self.width = width
        self.height = height
        self.anchor = anchor
        self.upscale = upscale

    def process(self, img):
        from .crop import Crop
        img = ResizeToCover(self.width, self.height,
                            upscale=self.upscale).process(img)
        return Crop(self.width, self.height,
                    anchor=self.anchor).process(img)


class SmartResize(object):
    """
    The ``SmartResize`` processor is identical to ``ResizeToFill``, except that
    it uses entropy to crop the image instead of a user-specified anchor point.
    Internally, it simply runs the ``ResizeToCover`` and ``SmartCrop``
    processors in series.
    """
    def __init__(self, width, height, upscale=True):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.
        :param upscale: Should the image be enlarged if smaller than the dimensions?

        """
        self.width, self.height = width, height
        self.upscale = upscale

    def process(self, img):
        from .crop import SmartCrop
        img = ResizeToCover(self.width, self.height,
                            upscale=self.upscale).process(img)
        return SmartCrop(self.width, self.height).process(img)


class ResizeCanvas(object):
    """
    Resizes the canvas, using the provided background color if the new size is
    larger than the current image.

    """
    def __init__(self, width, height, color=None, anchor=None, x=None, y=None):
        """
        :param width: The target width, in pixels.
        :param height: The target height, in pixels.
        :param color: The background color to use for padding.
        :param anchor: Specifies the position of the original image on the new
            canvas. Valid values are:

            - Anchor.TOP_LEFT
            - Anchor.TOP
            - Anchor.TOP_RIGHT
            - Anchor.LEFT
            - Anchor.CENTER
            - Anchor.RIGHT
            - Anchor.BOTTOM_LEFT
            - Anchor.BOTTOM
            - Anchor.BOTTOM_RIGHT

            You may also pass a tuple that indicates the position in
            percentages. For example, ``(0, 0)`` corresponds to "top left",
            ``(0.5, 0.5)`` to "center" and ``(1, 1)`` to "bottom right". This is
            basically the same as using percentages in CSS background positions.

        """
        if x is not None or y is not None:
            if anchor:
                raise Exception('You may provide either an anchor or x and y'
                        ' coordinate, but not both.')
            else:
                self.x, self.y = x or 0, y or 0
                self.anchor = None
        else:
            self.anchor = anchor or Anchor.CENTER
            self.x = self.y = None

        self.width = width
        self.height = height
        self.color = color or (255, 255, 255, 0)

    def process(self, img):
        original_width, original_height = img.size

        if self.anchor:
            anchor = Anchor.get_tuple(self.anchor)
            trim_x, trim_y = self.width - original_width, \
                    self.height - original_height
            x = int(float(trim_x) * float(anchor[0]))
            y = int(float(trim_y) * float(anchor[1]))
        else:
            x, y = self.x, self.y

        new_img = Image.new('RGBA', (self.width, self.height), self.color)
        new_img.paste(img, (x, y))
        return new_img


class AddBorder(object):
    """
    Add a border of specific color and size to an image.

    """
    def __init__(self, thickness, color=None):
        """
        :param color: Color to use for the border
        :param thickness: Thickness of the border. Can be either an int or
            a 4-tuple of ints of the form (top, right, bottom, left).
        """
        self.color = color
        if isinstance(thickness, int):
            self.top = self.right = self.bottom = self.left = thickness
        else:
            self.top, self.right, self.bottom, self.left = thickness

    def process(self, img):
        new_width = img.size[0] + self.left + self.right
        new_height = img.size[1] + self.top + self.bottom
        return ResizeCanvas(new_width, new_height, color=self.color,
                x=self.left, y=self.top).process(img)


class ResizeToFit(object):
    """
    Resizes an image to fit within the specified dimensions.

    """

    def __init__(self, width=None, height=None, upscale=True, mat_color=None, anchor=Anchor.CENTER):
        """
        :param width: The maximum width of the desired image.
        :param height: The maximum height of the desired image.
        :param upscale: A boolean value specifying whether the image should
            be enlarged if its dimensions are smaller than the target
            dimensions.
        :param mat_color: If set, the target image size will be enforced and the
            specified color will be used as a background color to pad the image.

        """
        self.width = width
        self.height = height
        self.upscale = upscale
        self.mat_color = mat_color
        self.anchor = anchor

    def process(self, img):
        cur_width, cur_height = img.size
        if not self.width is None and not self.height is None:
            ratio = min(float(self.width) / cur_width,
                    float(self.height) / cur_height)
        else:
            if self.width is None:
                ratio = float(self.height) / cur_height
            else:
                ratio = float(self.width) / cur_width
        new_dimensions = (int(round(cur_width * ratio)),
                          int(round(cur_height * ratio)))
        img = Resize(new_dimensions[0], new_dimensions[1], upscale=self.upscale).process(img)
        if self.mat_color is not None:
            img = ResizeCanvas(self.width, self.height, self.mat_color, anchor=self.anchor).process(img)
        return img


class Thumbnail(object):
    """
    Resize the image for use as a thumbnail. Wraps ``ResizeToFill``,
    ``ResizeToFit``, and ``SmartResize``.

    Note: while it doesn't currently, in the future this processor may also
    sharpen based on the amount of reduction.

    """

    def __init__(self, width=None, height=None, anchor=None, crop=None, upscale=None):
        self.width = width
        self.height = height
        self.upscale = upscale
        if anchor:
            if crop is False:
                raise Exception("You can't specify an anchor point if crop is False.")
            else:
                crop = True
        elif crop is None:
            # Assume we are cropping if both a width and height are provided. If
            # only one is, we must be resizing to fit.
            crop = width is not None and height is not None

            # A default anchor if cropping.
            if crop and anchor is None:
                anchor = 'auto'
        self.crop = crop
        self.anchor = anchor

    def process(self, img):
        if self.crop:
            if not self.width or not self.height:
                raise Exception('You must provide both a width and height when'
                    ' cropping.')
            if self.anchor == 'auto':
                processor = SmartResize(width=self.width, height=self.height, upscale=self.upscale)
            else:
                processor = ResizeToFill(width=self.width, height=self.height, anchor=self.anchor, upscale=self.upscale)
        else:
            processor = ResizeToFit(width=self.width, height=self.height, upscale=self.upscale)
        return processor.process(img)

########NEW FILE########
__FILENAME__ = utils
import math
from ..lib import Image


def histogram_entropy(im):
    """
    Calculate the entropy of an images' histogram. Used for "smart cropping" in easy-thumbnails;
    see: https://raw.github.com/SmileyChris/easy-thumbnails/master/easy_thumbnails/utils.py

    """
    if not isinstance(im, Image.Image):
        return 0  # Fall back to a constant entropy.

    histogram = im.histogram()
    hist_ceil = float(sum(histogram))
    histonorm = [histocol / hist_ceil for histocol in histogram]

    return -sum([p * math.log(p, 2) for p in histonorm if p != 0])

########NEW FILE########
__FILENAME__ = utils
import os
import mimetypes
import sys
from io import UnsupportedOperation
from .exceptions import UnknownExtension, UnknownFormat
from .lib import Image, ImageFile, StringIO, string_types


RGBA_TRANSPARENCY_FORMATS = ['PNG']
PALETTE_TRANSPARENCY_FORMATS = ['PNG', 'GIF']
DEFAULT_EXTENSIONS = {
    'JPEG': '.jpg',
}


def img_to_fobj(img, format, autoconvert=True, **options):
    return save_image(img, StringIO(), format, options, autoconvert)


def open_image(target):
    target.seek(0)
    return Image.open(target)


_pil_init = 0


def _preinit_pil():
    """Loads the standard PIL file format drivers. Returns True if ``preinit()``
    was called (and there's a potential that more drivers were loaded) or False
    if there is no possibility that new drivers were loaded.

    """
    global _pil_init
    if _pil_init < 1:
        Image.preinit()
        _pil_init = 1
        return True
    return False


def _init_pil():
    """Loads all PIL file format drivers. Returns True if ``init()`` was called
    (and there's a potential that more drivers were loaded) or False if there is
    no possibility that new drivers were loaded.

    """
    global _pil_init
    _preinit_pil()
    if _pil_init < 2:
        Image.init()
        _pil_init = 2
        return True
    return False


def _extension_to_format(extension):
    return Image.EXTENSION.get(extension.lower())


def _format_to_extension(format):
    if format:
        format = format.upper()
        if format in DEFAULT_EXTENSIONS:
            ext = DEFAULT_EXTENSIONS[format]

            # It's not enough for an extension to be listed in
            # ``DEFAULT_EXTENSIONS``, it must also be recognized by PIL.
            if ext in Image.EXTENSION:
                return ext
        for k, v in Image.EXTENSION.items():
            if v == format:
                return k
    return None


def extension_to_mimetype(ext):
    try:
        filename = 'a%s' % (ext or '')  # guess_type requires a full filename, not just an extension
        mimetype = mimetypes.guess_type(filename)[0]
    except IndexError:
        mimetype = None
    return mimetype


def format_to_mimetype(format):
    return extension_to_mimetype(format_to_extension(format))


def extension_to_format(extension):
    """Returns the format that corresponds to the provided extension.

    """
    format = _extension_to_format(extension)
    if not format and _preinit_pil():
        format = _extension_to_format(extension)
    if not format and _init_pil():
        format = _extension_to_format(extension)
    if not format:
        raise UnknownExtension(extension)
    return format


def format_to_extension(format):
    """Returns the first extension that matches the provided format.

    """
    extension = None
    if format:
        extension = _format_to_extension(format)
        if not extension and _preinit_pil():
            extension = _format_to_extension(format)
        if not extension and _init_pil():
            extension = _format_to_extension(format)
    if not extension:
        raise UnknownFormat(format)
    return extension


def suggest_extension(name, format):
    original_extension = os.path.splitext(name)[1]
    try:
        suggested_extension = format_to_extension(format)
    except UnknownFormat:
        extension = original_extension
    else:
        if suggested_extension.lower() == original_extension.lower():
            extension = original_extension
        else:
            try:
                original_format = extension_to_format(original_extension)
            except UnknownExtension:
                extension = suggested_extension
            else:
                # If the formats match, give precedence to the original extension.
                if format.lower() == original_format.lower():
                    extension = original_extension
                else:
                    extension = suggested_extension
    return extension


class FileWrapper(object):

    def __init__(self, wrapped):
        super(FileWrapper, self).__setattr__('_wrapped', wrapped)

    def fileno(self):
        try:
            return self._wrapped.fileno()
        except UnsupportedOperation:
            raise AttributeError

    def __getattr__(self, name):
        return getattr(self._wrapped, name)

    def __setattr__(self, name, value):
        return setattr(self._wrapped, name, value)

    def __delattr__(self, key):
        return delattr(self._wrapped, key)


def save_image(img, outfile, format, options=None, autoconvert=True):
    """
    Wraps PIL's ``Image.save()`` method. There are two main benefits of using
    this function over PIL's:

    1. It gracefully handles the infamous "Suspension not allowed here" errors.
    2. It prepares the image for saving using ``prepare_image()``, which will do
        some common-sense processing given the target format.

    """
    options = options or {}

    if autoconvert:
        img, save_kwargs = prepare_image(img, format)
        # Use returned from prepare_image arguments for base
        # and update them with provided options. Then use the result
        save_kwargs.update(options)
        options = save_kwargs

    # Attempt to reset the file pointer.
    try:
        outfile.seek(0)
    except AttributeError:
        pass

    def save(fp):
        with quiet():
            img.save(fp, format, **options)

    # Some versions of PIL only catch AttributeErrors where they should also
    # catch UnsupportedOperation exceptions. To work around this, we wrap the
    # file with an object that will raise the type of error it wants.
    if any(isinstance(outfile, t) for t in string_types):
        # ...but don't wrap strings.
        wrapper = outfile
    else:
        wrapper = FileWrapper(outfile)

    try:
        save(wrapper)
    except IOError:
        # PIL can have problems saving large JPEGs if MAXBLOCK isn't big enough,
        # So if we have a problem saving, we temporarily increase it. See
        # http://github.com/matthewwithanm/django-imagekit/issues/50
        # https://github.com/matthewwithanm/django-imagekit/issues/134
        # https://github.com/python-imaging/Pillow/issues/148
        # https://github.com/matthewwithanm/pilkit/commit/0f914e8b40e3d30f28e04ffb759b262aa8a1a082#commitcomment-3885362

        # MAXBLOCK must be at least as big as...
        new_maxblock = max(
            (len(options['exif']) if 'exif' in options else 0) + 5,  # ...the entire exif header block
            img.size[0] * 4,  # ...a complete scan line
            3 * img.size[0] * img.size[1],  # ...3 bytes per every pixel in the image
        )
        if new_maxblock < ImageFile.MAXBLOCK:
            raise
        old_maxblock = ImageFile.MAXBLOCK
        ImageFile.MAXBLOCK = new_maxblock
        try:
            save(wrapper)
        finally:
            ImageFile.MAXBLOCK = old_maxblock

    try:
        outfile.seek(0)
    except AttributeError:
        pass

    return outfile


class quiet(object):
    """
    A context manager for suppressing the stderr activity of PIL's C libraries.
    Based on http://stackoverflow.com/a/978264/155370

    """
    def __enter__(self):
        self.stderr_fd = sys.__stderr__.fileno()
        self.null_fd = os.open(os.devnull, os.O_RDWR)
        self.old = os.dup(self.stderr_fd)
        os.dup2(self.null_fd, self.stderr_fd)

    def __exit__(self, *args, **kwargs):
        os.dup2(self.old, self.stderr_fd)
        os.close(self.null_fd)
        os.close(self.old)


def prepare_image(img, format):
    """
    Prepares the image for saving to the provided format by doing some
    common-sense conversions. This includes things like preserving transparency
    and quantizing. This function is used automatically by ``save_image()``
    immediately before saving unless you specify ``autoconvert=False``. It is
    provided as a utility for those doing their own processing.

    :param img: The image to prepare for saving.
    :param format: The format that the image will be saved to.

    """
    make_opaque = False
    save_kwargs = {}
    format = format.upper()

    if img.mode == 'RGBA':
        if format in RGBA_TRANSPARENCY_FORMATS:
            pass
        elif format in PALETTE_TRANSPARENCY_FORMATS:
            # If you're going from a format with alpha transparency to one
            # with palette transparency, transparency values will be
            # snapped: pixels that are more opaque than not will become
            # fully opaque; pixels that are more transparent than not will
            # become fully transparent. This will not produce a good-looking
            # result if your image contains varying levels of opacity; in
            # that case, you'll probably want to use a processor to composite
            # the image on a solid color. The reason we don't do this by
            # default is because not doing so allows processors to treat
            # RGBA-format images as a super-type of P-format images: if you
            # have an RGBA-format image with only a single transparent
            # color, and save it as a GIF, it will retain its transparency.
            # In other words, a P-format image converted to an
            # RGBA-formatted image by a processor and then saved as a
            # P-format image will give the expected results.

            # Work around a bug in PIL: split() doesn't check to see if
            # img is loaded.
            img.load()

            alpha = img.split()[-1]
            mask = Image.eval(alpha, lambda a: 255 if a <= 128 else 0)
            img = img.convert('RGB').convert('P', palette=Image.ADAPTIVE,
                    colors=255)
            img.paste(255, mask)
            save_kwargs['transparency'] = 255
        else:
            # Simply converting an RGBA-format image to an RGB one creates a
            # gross result, so we paste the image onto a white background. If
            # that's not what you want, that's fine: use a processor to deal
            # with the transparency however you want. This is simply a
            # sensible default that will always produce something that looks
            # good. Or at least, it will look better than just a straight
            # conversion.
            make_opaque = True
    elif img.mode == 'P':
        if format in PALETTE_TRANSPARENCY_FORMATS:
            try:
                save_kwargs['transparency'] = img.info['transparency']
            except KeyError:
                pass
        elif format in RGBA_TRANSPARENCY_FORMATS:
            # Currently PIL doesn't support any RGBA-mode formats that
            # aren't also P-mode formats, so this will never happen.
            img = img.convert('RGBA')
        else:
            make_opaque = True
    else:
        img = img.convert('RGB')

        # GIFs are always going to be in palette mode, so we can do a little
        # optimization. Note that the RGBA sources also use adaptive
        # quantization (above). Images that are already in P mode don't need
        # any quantization because their colors are already limited.
        if format == 'GIF':
            img = img.convert('P', palette=Image.ADAPTIVE)

    if make_opaque:
        from .processors import MakeOpaque
        img = MakeOpaque().process(img).convert('RGB')

    if format == 'JPEG':
        save_kwargs['optimize'] = True

    return img, save_kwargs


def process_image(img, processors=None, format=None, autoconvert=True, options=None):
    from .processors import ProcessorPipeline

    original_format = img.format

    # Run the processors
    img = ProcessorPipeline(processors or []).process(img)

    format = format or img.format or original_format or 'JPEG'
    options = options or {}
    return img_to_fobj(img, format, autoconvert, **options)

########NEW FILE########
__FILENAME__ = test_processors
from pilkit.lib import Image, ImageDraw
from pilkit.processors import (Resize, ResizeToFill, ResizeToFit, SmartCrop,
                               SmartResize)
from nose.tools import eq_, assert_true
from pilkit.processors.resize import Thumbnail
from .utils import create_image
import mock


def test_smartcrop():
    img = SmartCrop(100, 100).process(create_image())
    eq_(img.size, (100, 100))


def test_resizetofill():
    img = ResizeToFill(100, 100).process(create_image())
    eq_(img.size, (100, 100))


def test_resizetofit():
    # First create an image with aspect ratio 2:1...
    img = Image.new('RGB', (200, 100))

    # ...then resize it to fit within a 100x100 canvas.
    img = ResizeToFit(100, 100).process(img)

    # Assert that the image has maintained the aspect ratio.
    eq_(img.size, (100, 50))


def test_resize_rounding():
    """
    Regression test for matthewwithanm/pilkit#1
    """

    img = Image.new('RGB', (95, 95))
    img = ResizeToFill(28, 28).process(img)
    eq_(img.size, (28, 28))


def test_resizetofit_mat():
    img = Image.new('RGB', (200, 100))
    img = ResizeToFit(100, 100, mat_color=0x000000).process(img)
    eq_(img.size, (100, 100))


def test_resize_antialiasing():
    """
    Test that the Resize processor antialiases.

    The Resize processor is used by all of the Resize* variants, so this should
    cover all of resize processors. Basically, this is to test that it converts
    to RGBA mode before resizing.

    Related: jdriscoll/django-imagekit#192

    """
    # Create a palette image and draw a circle into it.
    img = Image.new('P', (500, 500), 1)
    img.putpalette([
        0,   0,   0,
        255, 255, 255,
        0,   0,   255,
    ])
    d = ImageDraw.ImageDraw(img)
    d.ellipse((100, 100, 400, 400), fill=2)

    # Resize the image using the Resize processor
    img = Resize(100, 100).process(img)

    # Count the number of colors
    color_count = len(list(filter(None, img.histogram())))

    assert_true(color_count > 2)


def test_upscale():
    """
    Test that the upscale argument works as expected.

    """

    img = Image.new('RGB', (100, 100))

    for P in [Resize, ResizeToFit, ResizeToFill, SmartResize]:
        img2 = P(500, 500, upscale=True).process(img)
        eq_(img2.size, (500, 500))

        img2 = P(500, 500, upscale=False).process(img)
        eq_(img2.size, (100, 100))


def test_should_raise_exception_if_anchor_is_passed_and_crop_is_set_to_false():
    try:
        Thumbnail(height=200, width=200, upscale=False, crop=False, anchor='t')
    except Exception as e:
        eq_(str(e), "You can't specify an anchor point if crop is False.")


def test_should_set_crop_to_true_if_anchor_is_passed_without_crop():
    thumb = Thumbnail(height=200, width=200, upscale=False, anchor='t')
    assert_true(thumb.crop)


def test_should_raise_exception_when_crop_is_passed_without_height_and_width():
    img = Image.new('RGB', (100, 100))
    try:
        Thumbnail(crop=True).process(img)
    except Exception as e:
        eq_(str(e), 'You must provide both a width and height when cropping.')


@mock.patch('pilkit.processors.resize.SmartResize')
def test_should_call_smartresize_when_crop_not_passed(my_mock):
    img = Image.new('RGB', (100, 100))
    Thumbnail(height=200, width=200, upscale=False).process(img)
    assert_true(my_mock.called)


@mock.patch('pilkit.processors.resize.SmartResize')
def test_should_repass_upscale_option_true(my_mock):
    img = Image.new('RGB', (100, 100))
    Thumbnail(height=200, width=200, upscale=True).process(img)
    my_mock.assert_called_once_with(width=200, upscale=True, height=200)


@mock.patch('pilkit.processors.resize.SmartResize')
def test_should_repass_upscale_option_false(my_mock):
    img = Image.new('RGB', (100, 100))
    Thumbnail(height=200, width=200, upscale=False).process(img)
    my_mock.assert_called_once_with(width=200, upscale=False, height=200)


@mock.patch('pilkit.processors.resize.ResizeToFill')
def test_should_call_resizetofill_when_crop_and_ancho_is_passed(my_mock):
    img = Image.new('RGB', (100, 100))
    Thumbnail(height=200, width=200, anchor='fake').process(img)
    assert_true(my_mock.called)

@mock.patch('pilkit.processors.resize.ResizeToFit')
def test_should_call_resizetofit_when_crop_is_not_passed(my_mock):
    img = Image.new('RGB', (100, 100))
    Thumbnail(height=200, width=200, crop=False).process(img)
    assert_true(my_mock.called)

########NEW FILE########
__FILENAME__ = test_utils
from io import UnsupportedOperation
from pilkit.exceptions import UnknownFormat, UnknownExtension
from pilkit.lib import Image
from pilkit.utils import (extension_to_format, format_to_extension, FileWrapper,
                          save_image, prepare_image)
from nose.tools import eq_, raises, ok_
from tempfile import NamedTemporaryFile
from .utils import create_image


def test_extension_to_format():
    eq_(extension_to_format('.jpeg'), 'JPEG')
    eq_(extension_to_format('.rgba'), 'SGI')


def test_format_to_extension_no_init():
    eq_(format_to_extension('PNG'), '.png')
    eq_(format_to_extension('ICO'), '.ico')


@raises(UnknownFormat)
def test_unknown_format():
    format_to_extension('TXT')


@raises(UnknownExtension)
def test_unknown_extension():
    extension_to_format('.txt')


def test_default_extension():
    """
    Ensure default extensions are honored.

    Since PIL's ``Image.EXTENSION`` lists ``'.jpe'`` before the more common
    JPEG extensions, it would normally be the extension we'd get for that
    format. ``pilkit.utils.DEFAULT_EXTENSIONS`` is our way of specifying which
    extensions we'd prefer, and this tests to make sure it's working.

    """
    eq_(format_to_extension('JPEG'), '.jpg')


@raises(AttributeError)
def test_filewrapper():

    class K(object):
        def fileno(self):
            raise UnsupportedOperation

    FileWrapper(K()).fileno()


def test_save_with_filename():
    """
    Test that ``save_image`` accepts filename strings (not just file objects).
    This is a test for GH-8.

    """
    im = create_image()
    outfile = NamedTemporaryFile()
    save_image(im, outfile.name, 'JPEG')
    outfile.close()


def test_format_normalization():
    """
    Make sure formats are normalized by ``prepare_image()``.
    See https://github.com/matthewwithanm/django-imagekit/issues/262
    """
    im = Image.new('RGBA', (100, 100))
    ok_('transparency' in prepare_image(im, 'gIF')[1])

########NEW FILE########
__FILENAME__ = utils
import os
from pilkit.lib import Image


def get_image_file():
    """
    See also:

    http://en.wikipedia.org/wiki/Lenna
    http://sipi.usc.edu/database/database.php?volume=misc&image=12

    """
    dir = os.path.dirname(__file__)
    path = os.path.join(dir, 'assets', 'lenna.png')
    return open(path, 'r+b')


def create_image():
    return Image.open(get_image_file())

########NEW FILE########
