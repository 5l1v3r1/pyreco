__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Plata documentation build configuration file
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

import PIL.Image
sys.modules['Image'] = PIL.Image

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('..'))
sys.path.append(os.path.abspath('../venv/lib/python2.7/site-packages'))
sys.path.append(os.path.abspath('../tests/'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'testapp.settings'

# -- General configuration ----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Plata'
copyright = u'2010, Feinheit GmbH and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

import plata

version = '.'.join(map(str, plata.VERSION))
# The full version, including alpha/beta/rc tags.
release = plata.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme_path = ['_theme']
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Platadoc'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
latex_paper_size = 'a4'

# The font size ('10pt', '11pt' or '12pt').
latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples (source start
# file, target name, title, author, documentclass [howto/manual]).
latex_documents = [(
    'index', 'Plata.tex', u'Plata Documentation',
    u'Feinheit GmbH and contributors', 'manual'
),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from . import models


class ProductPriceInline(admin.TabularInline):
    model = models.ProductPrice
    extra = 0


class ProductAdmin(admin.ModelAdmin):
    inlines = [ProductPriceInline]
    list_display = ('is_active', 'name', 'ordering')
    list_display_links = ('name',)
    list_filter = ('is_active',)
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name', 'description')

admin.site.register(models.Product, ProductAdmin)

admin.site.register(models.Contact,
    list_display=('user', 'zip_code', 'city', 'country'),
    )

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
sys.path.insert(0, '../..')

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
import sys

from django.contrib.auth.models import User
from django.db import models
from django.utils.translation import ugettext_lazy as _

from plata.product.models import ProductBase
from plata.shop.models import PriceBase


class Product(ProductBase):
    """(Nearly) the simplest product model ever"""

    is_active = models.BooleanField(_('is active'), default=True)
    name = models.CharField(_('name'), max_length=100)
    slug = models.SlugField(_('slug'), unique=True)
    ordering = models.PositiveIntegerField(_('ordering'), default=0)

    description = models.TextField(_('description'), blank=True)

    class Meta:
        ordering = ['ordering', 'name']
        verbose_name = _('product')
        verbose_name_plural = _('products')

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('plata_product_detail', (), {'object_id': self.pk})


class ProductPrice(PriceBase):
    product = models.ForeignKey(Product, verbose_name=_('product'),
        related_name='prices')

    class Meta:
        get_latest_by = 'id'
        ordering = ['-id']
        verbose_name = _('price')
        verbose_name_plural = _('prices')


class Contact(models.Model):
    ADDRESS_FIELDS = ['company', 'first_name', 'last_name', 'address',
        'zip_code', 'city', 'country']

    user = models.OneToOneField(User, verbose_name=_('user'),
        related_name='contactuser')
    #currency = CurrencyField(help_text=_('Preferred currency.'))

    company = models.CharField(_('company'), max_length=100, blank=True)
    first_name = models.CharField(_('first name'), max_length=100)
    last_name = models.CharField(_('last name'), max_length=100)
    address = models.TextField(_('address'))
    zip_code = models.CharField(_('ZIP code'), max_length=50)
    city = models.CharField(_('city'), max_length=100)
    country = models.CharField(_('country'), max_length=3, blank=True)

    def __unicode__(self):
        return unicode(self.user)

    def update_from_order(self, order, request=None):
        for field in self.ADDRESS_FIELDS:
            f = 'billing_' + field
            setattr(self, field, getattr(order, f))

########NEW FILE########
__FILENAME__ = settings
# Django settings for plata project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'plata.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Zurich'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'de-ch'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media/')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin_media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'pi!!eb6ym55$q)cy14k0c32svx#7(d=&_n&&=**8(3)avkirq$'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.request',

    'django.contrib.messages.context_processors.messages',
    'plata.context_processors.plata_context',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'custom.urls'

TEMPLATE_DIRS = (
    os.path.join(os.path.dirname(__file__), 'templates'),
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',

    'django.contrib.admin',

    'plata',
    'plata.discount',
    'plata.payment',
    'plata.product',
    'plata.shop',

    'custom',
)

# PLATA settings

#PLATA_PRICE_INCLUDES_TAX = False

PLATA_SHOP_CONTACT = 'custom.Contact'


POSTFINANCE = {
    'PSPID': 'plataTEST',
    'SHA1_IN': 'plataSHA1_IN',
    'SHA1_OUT': 'plataSHA1_OUT',
    'LIVE': False,
    }

PAYPAL = {
    'BUSINESS': 'example@paypal.com',
    'LIVE': False,
    }

PLATA_REPORTING_ADDRESSLINE = 'Example Corp. - 3. Example Street - 1234 Example'

STATIC_URL = '/static/'

# PLATA settings

TEST_RUNNER = 'options.test_utils.test_runner_with_coverage'
COVERAGE_MODULES = ['plata']

import logging, sys
logging.basicConfig(
    filename='plata.log',
    format='%(asctime)s %(levelname)s:%(name)s:%(message)s',
    level=logging.DEBUG,
    )

PLATA_SHOP_PRODUCT = 'custom.Product'
CURRENCIES = ('CHF',)

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import include, patterns, url
from django.contrib import admin
from django.shortcuts import redirect

from custom.views import shop


admin.autodiscover()


urlpatterns = patterns('',
    url(r'', include(shop.urls)),
    url(r'^admin/', include(admin.site.urls)),

    url(r'^$', lambda request: redirect('plata_product_list')),
    url(r'^products/$', 'custom.views.product_list',
        name='plata_product_list'),
    url(r'^products/(?P<object_id>\d+)/$', 'custom.views.product_detail',
        name='plata_product_detail'),

    url(r'^reporting/', include('plata.reporting.urls')),

    (r'^media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': os.path.join(os.path.dirname(__file__), 'media/')}),
)

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from django import forms
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.db.models import ObjectDoesNotExist
from django.shortcuts import get_object_or_404, redirect, render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext as _
from django.views import generic

from plata.discount.models import Discount
from plata.shop import forms as shop_forms
from plata.shop.views import Shop
from plata.shop.models import Order

from custom.models import Contact, Product


class CheckoutForm(shop_forms.BaseCheckoutForm):
    class Meta:
        fields = ['email'] + ['billing_%s' % f for f in Contact.ADDRESS_FIELDS]
        model = Order

    def __init__(self, *args, **kwargs):
        shop = kwargs.get('shop')
        request = kwargs.get('request')
        contact = shop.contact_from_user(request.user)

        if contact:
            initial = {}
            for f in contact.ADDRESS_FIELDS:
                initial['billing_%s' % f] = getattr(contact, f)
                kwargs['initial'] = initial
            initial['email'] = contact.user.email

        super(CheckoutForm, self).__init__(*args, **kwargs)

        if not contact:
            self.fields['create_account'] = forms.BooleanField(
                label=_('create account'),
                required=False, initial=True)


class CustomShop(Shop):
    def checkout_form(self, request, order):
        return CheckoutForm

shop = CustomShop(Contact, Order, Discount)


product_list = generic.ListView.as_view(
    queryset=Product.objects.filter(is_active=True),
    template_name='product/product_list.html',
    )


class OrderItemForm(forms.Form):
    quantity = forms.IntegerField(label=_('quantity'), initial=1,
        min_value=1, max_value=100)


def product_detail(request, object_id):
    product = get_object_or_404(Product.objects.filter(is_active=True), pk=object_id)

    if request.method == 'POST':
        form = OrderItemForm(request.POST)

        if form.is_valid():
            order = shop.order_from_request(request, create=True)
            try:
                order.modify_item(product, form.cleaned_data.get('quantity'))
                messages.success(request, _('The cart has been updated.'))
            except ValidationError, e:
                if e.code == 'order_sealed':
                    [messages.error(request, msg) for msg in e.messages]
                else:
                    raise

            return redirect('plata_shop_cart')
    else:
        form = OrderItemForm()

    return render_to_response('product/product_detail.html', {
        'object': product,
        'form': form,
        }, context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from . import models


class ProductAdmin(admin.ModelAdmin):
    list_display = ('is_active', 'name', 'ordering', 'unit_price')
    list_display_links = ('name',)
    list_filter = ('is_active',)
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name', 'description')

admin.site.register(models.Product, ProductAdmin)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
sys.path.insert(0, '../..')

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
import sys

from django.db import models
from django.utils.translation import ugettext_lazy as _

from plata.product.models import ProductBase
from plata.shop.models import PriceBase


class Product(ProductBase, PriceBase):
    """
    This product model is a price too, which means that only one price
    can exist. The administration interface is even simpler when following
    this approach.
    """

    is_active = models.BooleanField(_('is active'), default=True)
    name = models.CharField(_('name'), max_length=100)
    slug = models.SlugField(_('slug'), unique=True)
    ordering = models.PositiveIntegerField(_('ordering'), default=0)

    description = models.TextField(_('description'), blank=True)

    class Meta:
        ordering = ['ordering', 'name']
        verbose_name = _('product')
        verbose_name_plural = _('products')

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('plata_product_detail', (), {'object_id': self.pk})

    def get_price(self, *args, **kwargs):
        return self

    def handle_order_item(self, orderitem):
        ProductBase.handle_order_item(self, orderitem)
        PriceBase.handle_order_item(self, orderitem)

########NEW FILE########
__FILENAME__ = settings
# Django settings for plata project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'plata.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Zurich'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'de-ch'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media/')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin_media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'pi!!eb6ym55$q)cy14k0c32svx#7(d=&_n&&=**8(3)avkirq$'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.request',

    'django.contrib.messages.context_processors.messages',
    'plata.context_processors.plata_context',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'oneprice.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',

    'django.contrib.admin',

    'plata',
    'plata.contact',
    'plata.discount',
    'plata.payment',
    'plata.product',
    'plata.shop',

    'oneprice',
)

# PLATA settings

#PLATA_PRICE_INCLUDES_TAX = False

POSTFINANCE = {
    'PSPID': 'plataTEST',
    'SHA1_IN': 'plataSHA1_IN',
    'SHA1_OUT': 'plataSHA1_OUT',
    'LIVE': False,
    }

PAYPAL = {
    'BUSINESS': 'example@paypal.com',
    'LIVE': False,
    }

PLATA_REPORTING_ADDRESSLINE = 'Example Corp. - 3. Example Street - 1234 Example'

# PLATA settings

TEST_RUNNER = 'options.test_utils.test_runner_with_coverage'
COVERAGE_MODULES = ['plata']

import logging, sys
logging.basicConfig(
    filename='plata.log',
    format='%(asctime)s %(levelname)s:%(name)s:%(message)s',
    level=logging.DEBUG,
    )

PLATA_SHOP_PRODUCT = 'oneprice.Product'
CURRENCIES = ('CHF',)

STATIC_URL = '/static/'

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import include, patterns, url
from django.contrib import admin
from django.shortcuts import redirect

from oneprice.views import shop


admin.autodiscover()


urlpatterns = patterns('',
    url(r'', include(shop.urls)),
    url(r'^admin/', include(admin.site.urls)),

    url(r'^$', lambda request: redirect('plata_product_list')),
    url(r'^products/$', 'oneprice.views.product_list',
        name='plata_product_list'),
    url(r'^products/(?P<object_id>\d+)/$', 'oneprice.views.product_detail',
        name='plata_product_detail'),

    (r'^media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': os.path.join(os.path.dirname(__file__), 'media/')}),
)

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from django import forms
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.db.models import ObjectDoesNotExist
from django.shortcuts import get_object_or_404, redirect, render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext as _
from django.views import generic

from plata.contact.models import Contact
from plata.discount.models import Discount
from plata.shop.views import Shop
from plata.shop.models import Order

from oneprice.models import Product


shop = Shop(Contact, Order, Discount)


product_list = generic.ListView.as_view(
    queryset=Product.objects.filter(is_active=True),
    template_name='product/product_list.html',
    )


class OrderItemForm(forms.Form):
    quantity = forms.IntegerField(label=_('quantity'), initial=1,
        min_value=1, max_value=100)


def product_detail(request, object_id):
    product = get_object_or_404(Product.objects.filter(is_active=True), pk=object_id)

    if request.method == 'POST':
        form = OrderItemForm(request.POST)

        if form.is_valid():
            order = shop.order_from_request(request, create=True)
            try:
                order.modify_item(product, form.cleaned_data.get('quantity'))
                messages.success(request, _('The cart has been updated.'))
            except ValidationError, e:
                if e.code == 'order_sealed':
                    [messages.error(request, msg) for msg in e.messages]
                else:
                    raise

            return redirect('plata_shop_cart')
    else:
        form = OrderItemForm()

    return render_to_response('product/product_detail.html', {
        'object': product,
        'form': form,
        }, context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from . import models


class ProductPriceInline(admin.TabularInline):
    model = models.ProductPrice
    extra = 0


class ProductAdmin(admin.ModelAdmin):
    inlines = [ProductPriceInline]
    list_display = ('is_active', 'name', 'ordering')
    list_display_links = ('name',)
    list_filter = ('is_active',)
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name', 'description')

admin.site.register(models.Product, ProductAdmin)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
sys.path.insert(0, '../..')

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
import sys

from django.db import models
from django.utils.translation import ugettext_lazy as _

from plata.product.models import ProductBase
from plata.shop.models import PriceBase


class Product(ProductBase):
    """(Nearly) the simplest product model ever"""

    is_active = models.BooleanField(_('is active'), default=True)
    name = models.CharField(_('name'), max_length=100)
    slug = models.SlugField(_('slug'), unique=True)
    ordering = models.PositiveIntegerField(_('ordering'), default=0)

    description = models.TextField(_('description'), blank=True)

    class Meta:
        ordering = ['ordering', 'name']
        verbose_name = _('product')
        verbose_name_plural = _('products')

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('plata_product_detail', (), {'object_id': self.pk})


class ProductPrice(PriceBase):
    product = models.ForeignKey(Product, verbose_name=_('product'),
        related_name='prices')

    class Meta:
        get_latest_by = 'id'
        ordering = ['-id']
        verbose_name = _('price')
        verbose_name_plural = _('prices')

########NEW FILE########
__FILENAME__ = settings
# Django settings for plata project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'plata.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Zurich'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'de-ch'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media/')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a
# trailing slash.
# Examples: "http://foo.com/media/", "/media/".
ADMIN_MEDIA_PREFIX = '/admin_media/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'pi!!eb6ym55$q)cy14k0c32svx#7(d=&_n&&=**8(3)avkirq$'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.request',

    'django.contrib.messages.context_processors.messages',
    'plata.context_processors.plata_context',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'simple.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',

    'django.contrib.admin',

    'plata',
    'plata.contact',
    'plata.discount',
    'plata.payment',
    'plata.product',
    'plata.shop',

    'simple',
)

STATIC_URL = '/static/'

# PLATA settings

#PLATA_PRICE_INCLUDES_TAX = False

POSTFINANCE = {
    'PSPID': 'plataTEST',
    'SHA1_IN': 'plataSHA1_IN',
    'SHA1_OUT': 'plataSHA1_OUT',
    'LIVE': False,
    }

PAYPAL = {
    'BUSINESS': 'example@paypal.com',
    'LIVE': False,
    }

PLATA_REPORTING_ADDRESSLINE = 'Example Corp. - 3. Example Street - 1234 Example'

# PLATA settings

TEST_RUNNER = 'options.test_utils.test_runner_with_coverage'
COVERAGE_MODULES = ['plata']

import logging, sys
logging.basicConfig(
    filename='plata.log',
    format='%(asctime)s %(levelname)s:%(name)s:%(message)s',
    level=logging.DEBUG,
    )

PLATA_SHOP_PRODUCT = 'simple.Product'
CURRENCIES = ('CHF',)

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import include, patterns, url
from django.contrib import admin
from django.shortcuts import redirect

from simple.views import shop


admin.autodiscover()


urlpatterns = patterns('',
    url(r'', include(shop.urls)),
    url(r'^admin/', include(admin.site.urls)),

    url(r'^$', lambda request: redirect('plata_product_list')),
    url(r'^products/$', 'simple.views.product_list',
        name='plata_product_list'),
    url(r'^products/(?P<object_id>\d+)/$', 'simple.views.product_detail',
        name='plata_product_detail'),

    url(r'^reporting/', include('plata.reporting.urls')),

    (r'^media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': os.path.join(os.path.dirname(__file__), 'media/')}),
)

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from django import forms
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.db.models import ObjectDoesNotExist
from django.shortcuts import get_object_or_404, redirect, render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext as _
from django.views import generic

from plata.contact.models import Contact
from plata.discount.models import Discount
from plata.shop.views import Shop
from plata.shop.models import Order

from simple.models import Product


shop = Shop(Contact, Order, Discount)


product_list = generic.ListView.as_view(
    queryset=Product.objects.filter(is_active=True),
    template_name='product/product_list.html',
    )


class OrderItemForm(forms.Form):
    quantity = forms.IntegerField(label=_('quantity'), initial=1,
        min_value=1, max_value=100)


def product_detail(request, object_id):
    product = get_object_or_404(Product.objects.filter(is_active=True), pk=object_id)

    if request.method == 'POST':
        form = OrderItemForm(request.POST)

        if form.is_valid():
            order = shop.order_from_request(request, create=True)
            try:
                order.modify_item(product, form.cleaned_data.get('quantity'))
                messages.success(request, _('The cart has been updated.'))
            except ValidationError, e:
                if e.code == 'order_sealed':
                    [messages.error(request, msg) for msg in e.messages]
                else:
                    raise

            return redirect('plata_shop_cart')
    else:
        form = OrderItemForm()

    return render_to_response('product/product_detail.html', {
        'object': product,
        'form': form,
        }, context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from . import models


class ProductPriceInline(admin.TabularInline):
    model = models.ProductPrice
    extra = 0


class ProductAdmin(admin.ModelAdmin):
    inlines = [ProductPriceInline]
    list_display = ('is_active', 'name', 'ordering')
    list_display_links = ('name',)
    list_filter = ('is_active',)
    prepopulated_fields = {'slug': ('name',)}
    search_fields = ('name', 'description')

admin.site.register(models.Product, ProductAdmin)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
sys.path.insert(0, '../..')

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

import plata
from plata.product.models import ProductBase
from plata.shop.models import PriceBase


class Product(ProductBase):
    """(Nearly) the simplest product model ever"""

    is_active = models.BooleanField(_('is active'), default=True)
    name = models.CharField(_('name'), max_length=100)
    slug = models.SlugField(_('slug'), unique=True)
    ordering = models.PositiveIntegerField(_('ordering'), default=0)

    description = models.TextField(_('description'), blank=True)

    class Meta:
        ordering = ['ordering', 'name']
        verbose_name = _('product')
        verbose_name_plural = _('products')

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('plata_product_detail', (), {'object_id': self.pk})

    def get_price(self, currency=None, orderitem=None):
        if currency is None:
            currency = (orderitem.currency if orderitem else
                plata.shop_instance().default_currency())

        possible = self.prices.filter(
            currency=currency,
            from_quantity__lte=(orderitem.quantity if orderitem else 1))

        try:
            return possible.order_by('-from_quantity')[0]
        except IndexError:
            raise possible.model.DoesNotExist


class ProductPrice(PriceBase):
    product = models.ForeignKey(Product, verbose_name=_('product'),
        related_name='prices')
    from_quantity = models.IntegerField(_('From quantity'), default=1)

    class Meta:
        get_latest_by = 'id'
        ordering = ['from_quantity']
        verbose_name = _('price')
        verbose_name_plural = _('prices')

########NEW FILE########
__FILENAME__ = settings
# Django settings for plata project.

import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@domain.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'plata.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Zurich'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'de-ch'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = os.path.join(os.path.dirname(__file__), 'media/')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

STATIC_URL = '/static/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'pi!!eb6ym55$q)cy14k0c32svx#7(d=&_n&&=**8(3)avkirq$'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.request',

    'django.contrib.messages.context_processors.messages',
    'plata.context_processors.plata_context',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'staggered.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'django.contrib.admin',

    'plata',
    'plata.contact',
    'plata.discount',
    'plata.payment',
    'plata.product',
    'plata.shop',

    'staggered',
)

# PLATA settings

#PLATA_PRICE_INCLUDES_TAX = False

POSTFINANCE = {
    'PSPID': 'plataTEST',
    'SHA1_IN': 'plataSHA1_IN',
    'SHA1_OUT': 'plataSHA1_OUT',
    'LIVE': False,
    }

PAYPAL = {
    'BUSINESS': 'example@paypal.com',
    'LIVE': False,
    }

PLATA_REPORTING_ADDRESSLINE = 'Example Corp. - 3. Example Street - 1234 Example'

# PLATA settings

TEST_RUNNER = 'options.test_utils.test_runner_with_coverage'
COVERAGE_MODULES = ['plata']

import logging, sys
logging.basicConfig(
    filename='plata.log',
    format='%(asctime)s %(levelname)s:%(name)s:%(message)s',
    level=logging.DEBUG,
    )

PLATA_SHOP_PRODUCT = 'staggered.Product'
CURRENCIES = ('CHF',)

########NEW FILE########
__FILENAME__ = urls
import os

from django.conf.urls import include, patterns, url
from django.contrib import admin
from django.shortcuts import redirect

from staggered.views import shop


admin.autodiscover()


urlpatterns = patterns('',
    url(r'', include(shop.urls)),
    url(r'^admin/', include(admin.site.urls)),

    url(r'^$', lambda request: redirect('plata_product_list')),
    url(r'^products/$', 'staggered.views.product_list',
        name='plata_product_list'),
    url(r'^products/(?P<object_id>\d+)/$', 'staggered.views.product_detail',
        name='plata_product_detail'),

    (r'^media/(?P<path>.*)$', 'django.views.static.serve',
        {'document_root': os.path.join(os.path.dirname(__file__), 'media/')}),
)

from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns += staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from django import forms
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.db.models import ObjectDoesNotExist
from django.shortcuts import get_object_or_404, redirect, render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext as _
from django.views import generic

from plata.contact.models import Contact
from plata.discount.models import Discount
from plata.shop.views import Shop
from plata.shop.models import Order

from staggered.models import Product


shop = Shop(Contact, Order, Discount)


product_list = generic.ListView.as_view(
    queryset=Product.objects.filter(is_active=True),
    template_name='product/product_list.html',
    )


class OrderItemForm(forms.Form):
    quantity = forms.IntegerField(label=_('quantity'), initial=1,
        min_value=1, max_value=100)

    def __init__(self, *args, **kwargs):
        self.product = kwargs.pop('product')
        super(OrderItemForm, self).__init__(*args, **kwargs)

    def clean(self):
        data = super(OrderItemForm, self).clean()

        try:
            self.product.get_price() # Just for fun, isn't used afterwards
        except ObjectDoesNotExist:
            raise forms.ValidationError(_('Price could not be determined.'))

        return data


def product_detail(request, object_id):
    product = get_object_or_404(Product.objects.filter(is_active=True), pk=object_id)

    if request.method == 'POST':
        form = OrderItemForm(request.POST, product=product)

        if form.is_valid():
            order = shop.order_from_request(request, create=True)
            try:
                order.modify_item(product,
                    relative=form.cleaned_data.get('quantity'),
                    )
                messages.success(request, _('The cart has been updated.'))
            except ValidationError, e:
                if e.code == 'order_sealed':
                    [messages.error(request, msg) for msg in e.messages]
                else:
                    raise

            return redirect('plata_shop_cart')
    else:
        form = OrderItemForm(product=product)

    return render_to_response('product/product_detail.html', {
        'object': product,
        'form': form,
        }, context_instance=RequestContext(request))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from . import models


class ContactAdmin(admin.ModelAdmin):
    fieldsets = (
        (None, {'fields': ('created', 'user', 'dob', 'currency')}),
        (_('Billing address'), {
            'fields': models.Contact.address_fields('billing_'),
        }),
        (_('Shipping address'), {
            'fields': (
                ['shipping_same_as_billing']
                + models.Contact.address_fields('shipping_')),
        }),
        (_('Additional fields'), {
            'fields': ('notes',),
        }),
    )
    list_display = (
        '__unicode__', 'billing_first_name', 'billing_last_name',
        'billing_city', 'created')
    list_filter = ('user__is_active',)
    ordering = ('-created',)
    raw_id_fields = ('user',)
    search_fields = (
        ['user__first_name', 'user__last_name', 'user__email']
        + models.Contact.address_fields('billing_')
        + models.Contact.address_fields('shipping_')
    )


admin.site.register(models.Contact, ContactAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

from plata.shop import forms as shop_forms
from plata.shop.models import Order


class CheckoutForm(shop_forms.BaseCheckoutForm):
    class Meta:
        fields = ['notes', 'email', 'shipping_same_as_billing']
        fields.extend('billing_%s' % f for f in Order.ADDRESS_FIELDS)
        fields.extend('shipping_%s' % f for f in Order.ADDRESS_FIELDS)
        model = Order

    def __init__(self, *args, **kwargs):
        # BaseCheckoutForm.__init__ needs the following kwargs too, because
        # of this we do not pop() them here
        shop = kwargs.get('shop')
        request = kwargs.get('request')

        self.REQUIRED_ADDRESS_FIELDS = shop.contact_model.ADDRESS_FIELDS[:]
        self.REQUIRED_ADDRESS_FIELDS.remove('company')

        contact = shop.contact_from_user(request.user)

        if contact:
            initial = {
                'email': contact.user.email,
                'shipping_same_as_billing': contact.shipping_same_as_billing,
            }

            for f in contact.ADDRESS_FIELDS:
                initial['billing_%s' % f] = getattr(
                    contact,
                    'billing_%s' % f)
                initial['shipping_%s' % f] = getattr(
                    contact,
                    'shipping_%s' % f)

            kwargs['initial'] = initial

        elif request.user.is_authenticated():
            kwargs['initial'] = {
                'email': request.user.email,
                'billing_first_name': request.user.first_name,
                'billing_last_name': request.user.last_name,
            }

        super(CheckoutForm, self).__init__(*args, **kwargs)

        if not (contact or request.user.is_authenticated()):
            self.fields['create_account'] = forms.BooleanField(
                label=_('create account'),
                required=False, initial=True)

    def clean(self):
        data = super(CheckoutForm, self).clean()

        if not data.get('shipping_same_as_billing'):
            for f in self.REQUIRED_ADDRESS_FIELDS:
                field = 'shipping_%s' % f
                if not data.get(field):
                    self._errors[field] = self.error_class([
                        _('This field is required.')])

        return data

########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _

from plata.fields import CurrencyField
from plata.shop.models import BillingShippingAddress


class Contact(BillingShippingAddress):
    """
    Each user can have at most one of these

    Note: You do not have to use this model if you want to store the contact
    information somewhere else. If you use your own contact model, you should
    take care of two things:

    - ``Contact.update_from_order`` has to exist, and should fill in
      contact details from the order
    - You probably have to override ``Shop.checkout_form`` too - this method
      probably won't work for your custom contact model
    """

    user = models.OneToOneField(
        getattr(settings, 'AUTH_USER_MODEL', 'auth.User'),
        verbose_name=_('user'),
        related_name='contactuser')

    dob = models.DateField(_('date of birth'), blank=True, null=True)
    created = models.DateTimeField(_('created'), default=timezone.now)

    currency = CurrencyField(help_text=_('Preferred currency.'))
    notes = models.TextField(_('notes'), blank=True)

    class Meta:
        verbose_name = _('contact')
        verbose_name_plural = _('contacts')

    def __unicode__(self):
        return unicode(self.user)

    def update_from_order(self, order, request=None):
        """
        This method is called by the checkout step and is used to update
        the contact information from an order instance
        """

        self.currency = order.currency
        self.shipping_same_as_billing = order.shipping_same_as_billing

        for field in self.ADDRESS_FIELDS:
            f = 'shipping_' + field
            setattr(self, f, getattr(order, f))

            f = 'billing_' + field
            setattr(self, f, getattr(order, f))

########NEW FILE########
__FILENAME__ = context_processors
import plata


def plata_context(request):
    """
    Adds a few variables from Plata to the context if they are available:

    * ``plata.shop``: The current :class:`plata.shop.views.Shop` instance
    * ``plata.order``: The current order
    * ``plata.contact``: The current contact instance
    * ``plata.price_includes_tax``: Whether prices include tax or not
    """

    shop = plata.shop_instance()
    return {'plata': {
        'shop': shop,
        'order': shop.order_from_request(request),
        'contact': (shop.contact_from_user(request.user)
            if hasattr(request, 'user') else None),
        'price_includes_tax': shop.price_includes_tax(request),
    }} if shop else {}

########NEW FILE########
__FILENAME__ = default_settings
from decimal import Decimal

from django.conf import settings
from django.utils.translation import ugettext_lazy as _


#: Are prices shown with tax included or not? (Defaults to ``True``)
#: Please note that this setting is purely presentational and has no
#: influence on the values stored in the database.
PLATA_PRICE_INCLUDES_TAX = getattr(settings, 'PLATA_PRICE_INCLUDES_TAX', True)

#: List of order processors
#:
#: Plata does not check whether the selection makes any sense. This is your
#: responsibility.
PLATA_ORDER_PROCESSORS = getattr(settings, 'PLATA_ORDER_PROCESSORS', [
    'plata.shop.processors.InitializeOrderProcessor',
    'plata.shop.processors.DiscountProcessor',
    'plata.shop.processors.TaxProcessor',
    'plata.shop.processors.MeansOfPaymentDiscountProcessor',
    'plata.shop.processors.ItemSummationProcessor',
    'plata.shop.processors.ZeroShippingProcessor',
    'plata.shop.processors.OrderSummationProcessor',
])

#: Activated payment modules
PLATA_PAYMENT_MODULES = getattr(settings, 'PLATA_PAYMENT_MODULES', [
    'plata.payment.modules.cod.PaymentProcessor',
    'plata.payment.modules.postfinance.PaymentProcessor',
    'plata.payment.modules.paypal.PaymentProcessor',
])

#: Override payment module names without modifying the payment module code
#:
#: The key in this dictionary should use the ``key`` variable of the
#: respective payment module.
#:
#: Example::
#:
#:     PLATA_PAYMENT_MODULE_NAMES = {
#:         'paypal': 'PayPal and Credit Cards',
#:     }
PLATA_PAYMENT_MODULE_NAMES = getattr(
    settings, 'PLATA_PAYMENT_MODULE_NAMES', {})

#: ``FixedAmountShippingProcessor`` example configuration
#:
#: The cost must be specified with tax included.
PLATA_SHIPPING_FIXEDAMOUNT = getattr(settings, 'PLATA_SHIPPING_FIXEDAMOUNT', {
    'cost': Decimal('8.00'),
    'tax': Decimal('7.6'),
})

#: Stationery for invoice and packing slip PDF generation
PLATA_REPORTING_STATIONERY = getattr(
    settings,
    'PLATA_REPORTING_STATIONERY',
    'pdfdocument.elements.ExampleStationery')

#: PDF address line
PLATA_REPORTING_ADDRESSLINE = getattr(
    settings,
    'PLATA_REPORTING_ADDRESSLINE',
    '')

#: Transactional stock tracking
#:
#: ``'plata.product.stock'`` has to be included in ``INSTALLED_APPS`` for
#: this to work.
PLATA_STOCK_TRACKING = getattr(settings, 'PLATA_STOCK_TRACKING', False)
PLATA_STOCK_TRACKING_MODEL = getattr(
    settings,
    'PLATA_STOCK_TRACKING_MODEL',
    'stock.StockTransaction')

#: All available currencies. Use ISO 4217 currency codes in this list only.
CURRENCIES = getattr(settings, 'CURRENCIES', ('CHF', 'EUR', 'USD', 'CAD'))

#: Target of order item product foreign key (Defaults to ``'product.Product'``)
PLATA_SHOP_PRODUCT = getattr(settings, 'PLATA_SHOP_PRODUCT', 'product.Product')

#: Since ZIP code is far from universal, and more an L10N than I18N issue:
PLATA_ZIP_CODE_LABEL = getattr(settings, 'PLATA_ZIP_CODE_LABEL', _('ZIP code'))

########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

from plata.discount import models
from plata.utils import jsonize


class DiscountAdminForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super(DiscountAdminForm, self).__init__(*args, **kwargs)

        # Seems to be necessary because of the custom validation
        self.fields['config'].required = False

        choices = [
            (key, cfg.get('title', key))
            for key, cfg in self._meta.model.CONFIG_OPTIONS]

        self.fields['config_options'] = forms.MultipleChoiceField(
            choices=choices,
            label=_('Configuration options'),
            help_text=_('Save and continue editing to configure options.'),
        )

        config_fieldsets = []

        # Determine the list of selected configuration options
        # 1. POST data
        # 2. get data from the instance we are editing
        # 3. fall back to allowing all products in the discount

        try:
            selected = self.data.getlist('config_options')
        except AttributeError:
            if self.instance.pk:
                selected = self.instance.config.keys()
            else:
                selected = None

        selected = selected or ('all',)
        self.fields['config_options'].initial = selected

        for s in selected:
            cfg = dict(self._meta.model.CONFIG_OPTIONS)[s]

            # Always create a fieldset for selected configuration options,
            # even if we do not have any form fields.
            fieldset = [
                _('Discount configuration: %s') % cfg.get('title', s),
                {'fields': []},
            ]

            for k, f in cfg.get('form_fields', []):
                self.fields['%s_%s' % (s, k)] = f

                # Set initial value if we have one in the configuration
                if k in self.instance.config.get(s, {}):
                    f.initial = self.instance.config[s].get(k)

                fieldset[1]['fields'].append('%s_%s' % (s, k))

            config_fieldsets.append(fieldset)

        self.request._plata_discount_config_fieldsets = config_fieldsets

    def clean(self):
        data = self.cleaned_data

        if 'config' in self.changed_data:
            return data

        selected = data.get('config_options', [])
        config_options = {}

        for s in selected:
            cfg = dict(self._meta.model.CONFIG_OPTIONS)[s]

            option_item = {}
            for k, f in cfg.get('form_fields', []):
                key = '%s_%s' % (s, k)
                if key in data:
                    option_item[k] = data.get(key)

            config_options[s] = option_item

        self.instance.config = jsonize(config_options)
        data['config'] = self.instance.config
        return data


class DiscountAdmin(admin.ModelAdmin):
    form = DiscountAdminForm
    list_display = (
        'name', 'type', 'is_active', 'valid_from', 'valid_until', 'code',
        'value')
    list_filter = ('type', 'is_active')
    ordering = ('-valid_from',)
    search_fields = ('name', 'code', 'config')

    def get_form(self, request, obj=None, **kwargs):
        form_class = super(DiscountAdmin, self).get_form(
            request, obj=obj, **kwargs)
        # Generate a new type to be sure that the request stays inside this
        # request/response cycle.
        return type(form_class.__name__, (form_class,), {'request': request})

    def get_fieldsets(self, request, obj=None):
        fieldsets = super(DiscountAdmin, self).get_fieldsets(request, obj)
        if not hasattr(request, '_plata_discount_config_fieldsets'):
            return fieldsets

        fieldsets[0][1]['fields'].remove('config')

        fieldsets.append((_('Raw configuration'), {
            'fields': ('config',),
            'classes': ('collapse',),
        }))
        fieldsets.append((_('Configuration'), {
            'fields': ('config_options',),
        }))

        fieldsets.extend(
            request._plata_discount_config_fieldsets)

        return fieldsets


admin.site.register(models.Discount, DiscountAdmin)

########NEW FILE########
__FILENAME__ = models
from datetime import date
from decimal import Decimal
import random

from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import ObjectDoesNotExist, Q
from django.utils.translation import ugettext_lazy as _

import plata
from plata.fields import CurrencyField, JSONField
from plata.shop.models import TaxClass, Order


class DiscountBase(models.Model):
    """Base class for discounts and applied discounts"""

    AMOUNT_VOUCHER_EXCL_TAX = 10
    AMOUNT_VOUCHER_INCL_TAX = 20
    PERCENTAGE_VOUCHER = 30
    MEANS_OF_PAYMENT = 40

    TYPE_CHOICES = (
        (AMOUNT_VOUCHER_EXCL_TAX,
            _('amount voucher excl. tax (reduces total tax on order)')),
        (AMOUNT_VOUCHER_INCL_TAX,
            _('amount voucher incl. tax (reduces total tax on order)')),
        (PERCENTAGE_VOUCHER,
            _('percentage voucher (reduces total tax on order)')),
        (MEANS_OF_PAYMENT,
            _('means of payment (does not change total tax on order)')),
    )

    #: You can add and remove options at will, except for 'all': This option
    #: must always be available, and it cannot have any form fields
    CONFIG_OPTIONS = [
        ('all', {
            'title': _('All products'),
        }),
        ('exclude_sale', {
            'title': _('Exclude sale prices'),
            'orderitem_query': lambda **values: Q(is_sale=False),
        }),
    ]

    name = models.CharField(_('name'), max_length=100)

    type = models.PositiveIntegerField(_('type'), choices=TYPE_CHOICES)
    value = models.DecimalField(_('value'), max_digits=18, decimal_places=10)

    currency = CurrencyField(
        blank=True, null=True,
        help_text=_('Only required for amount discounts.'))
    tax_class = models.ForeignKey(
        TaxClass, verbose_name=_('tax class'),
        blank=True, null=True,
        help_text=_('Only required for amount discounts incl. tax.'))

    config = JSONField(
        _('configuration'), blank=True, help_text=_(
            'If you edit this field directly, changes below will be'
            ' ignored.'))

    class Meta:
        abstract = True

    def __unicode__(self):
        return self.name

    def save(self, *args, **kwargs):
        self.full_clean()
        super(DiscountBase, self).save(*args, **kwargs)
    save.alters_data = True

    def clean(self):
        if self.type == self.PERCENTAGE_VOUCHER:
            if self.currency or self.tax_class:
                raise ValidationError(_(
                    'Percentage discounts cannot have currency and tax'
                    ' class set.'))
        elif self.type == self.AMOUNT_VOUCHER_EXCL_TAX:
            if not self.currency:
                raise ValidationError(_(
                    'Amount discounts excl. tax need a currency.'))
            if self.tax_class:
                raise ValidationError(_(
                    'Amount discounts excl. tax cannot have tax class'
                    ' set.'))
        elif self.type == self.AMOUNT_VOUCHER_INCL_TAX:
            if not (self.currency and self.tax_class):
                raise ValidationError(_(
                    'Amount discounts incl. tax need a currency and a tax'
                    ' class.'))
        elif self.type == self.MEANS_OF_PAYMENT:
            if not self.currency:
                raise ValidationError(_('Means of payment need a currency.'))
            if self.tax_class:
                raise ValidationError(
                    _('Means of payment cannot have tax class set.'))
        else:
            raise ValidationError(_('Unknown discount type.'))

    def _eligible_products(self, order, items):
        """
        Return a list of products which are eligible for discounting using
        the discount configuration.
        """

        product_model = plata.product_model()

        products = product_model._default_manager.filter(
            id__in=[item.product_id for item in items])
        orderitems = order.items.model._default_manager.filter(
            id__in=[item.id for item in items])

        for key, parameters in self.config.items():
            parameters = dict((str(k), v) for k, v in parameters.items())

            cfg = dict(self.CONFIG_OPTIONS)[key]

            if 'product_query' in cfg:
                products = products.filter(
                    cfg['product_query'](**parameters))
            if 'orderitem_query' in cfg:
                orderitems = orderitems.filter(
                    cfg['orderitem_query'](**parameters))

        return products.filter(id__in=orderitems.values('product_id'))

    def apply(self, order, items, **kwargs):
        if not items:
            return

        if self.type == self.AMOUNT_VOUCHER_EXCL_TAX:
            self._apply_amount_discount(order, items, tax_included=False)
        elif self.type == self.AMOUNT_VOUCHER_INCL_TAX:
            self._apply_amount_discount(order, items, tax_included=True)
        elif self.type == self.PERCENTAGE_VOUCHER:
            self._apply_percentage_discount(order, items)
        elif self.type == self.MEANS_OF_PAYMENT:
            self._apply_means_of_payment(order, items)
        else:
            raise NotImplementedError('Unknown discount type %s' % self.type)

    def _apply_amount_discount(self, order, items, tax_included):
        """
        Apply amount discount evenly to all eligible order items

        Aggregates remaining discount (if discount is bigger than order total)
        """

        eligible_products = self._eligible_products(order, items).values_list(
            'id', flat=True)
        eligible_items = [
            item for item in items
            if item.product_id in eligible_products]

        if tax_included:
            discount = self.value / (1 + self.tax_class.rate / 100)
        else:
            discount = self.value

        items_subtotal = sum([
            item.discounted_subtotal_excl_tax for item in eligible_items
        ], Decimal('0.00'))

        # Don't allow bigger discounts than the items subtotal
        if discount > items_subtotal:
            self.remaining = discount - items_subtotal
            self.save()
            discount = items_subtotal

        for item in eligible_items:
            item._line_item_discount += (
                item.discounted_subtotal_excl_tax / items_subtotal * discount)

    def _apply_means_of_payment(self, order, items):
        self._apply_amount_discount(order, items, tax_included=False)

    def _apply_percentage_discount(self, order, items):
        """
        Apply percentage discount evenly to all eligible order items
        """

        eligible_products = self._eligible_products(order, items).values_list(
            'id', flat=True)

        factor = self.value / 100

        for item in items:
            if item.product_id not in eligible_products:
                continue

            item._line_item_discount += (
                item.discounted_subtotal_excl_tax * factor)


# Nearly all letters and digits, excluding those which can be easily confounded
RANDOM_CODE_CHARACTERS = (
    '23456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ')


def generate_random_code():
    return u''.join(random.sample(RANDOM_CODE_CHARACTERS, 10))


class Discount(DiscountBase):
    code = models.CharField(
        _('code'), max_length=30, unique=True, default=generate_random_code)

    is_active = models.BooleanField(_('is active'), default=True)
    valid_from = models.DateField(_('valid from'), default=date.today)
    valid_until = models.DateField(_('valid until'), blank=True, null=True)

    allowed_uses = models.IntegerField(
        _('number of allowed uses'),
        blank=True, null=True,
        help_text=_(
            'Leave empty if there is no limit on the number of uses'
            ' of this discount.'))
    used = models.IntegerField(_('number of times already used'), default=0)

    class Meta:
        verbose_name = _('discount')
        verbose_name_plural = _('discounts')

    def validate(self, order):
        """
        Validate whether this discount can be applied on the given order
        """

        messages = []
        if not self.is_active:
            messages.append(_('Discount is inactive.'))

        today = date.today()
        if today < self.valid_from:
            messages.append(_('Discount is not active yet.'))
        if self.valid_until and today > self.valid_until:
            messages.append(_('Discount is expired.'))

        if self.allowed_uses and self.used >= self.allowed_uses:
            messages.append(
                _('Allowed uses for this discount has already been reached.'))

        if (self.currency != order.currency and self.type in (
                self.AMOUNT_VOUCHER_EXCL_TAX,
                self.AMOUNT_VOUCHER_INCL_TAX,
                self.MEANS_OF_PAYMENT)):
            messages.append(_('Discount and order currencies do not match.'))

        if messages:
            raise ValidationError(messages)

        return True

    def add_to(self, order, recalculate=True):
        """
        Add discount to passed order

        Removes the previous discount if a discount with this code has
        already been added to the order before.
        """

        self.validate(order)

        try:
            order.applied_discounts.get(code=self.code).delete()
        except ObjectDoesNotExist:
            # Don't increment used count when discount has already been
            # applied
            self.used += 1
            self.save()

        instance = order.applied_discounts.create(
            code=self.code,
            type=self.type,
            name=self.name,
            value=self.value,
            currency=self.currency,
            tax_class=self.tax_class,
            config=self.config,
        )

        if recalculate:
            order.recalculate_total()

        return instance


class AppliedDiscountManager(models.Manager):
    """
    Default manager for the ``AppliedDiscount`` model
    """

    def remaining(self, order=None):
        """
        Calculate remaining discount excl. tax

        Can either be used as related manager::

            order.applied_discounts.remaining()

        or directly::

            AppliedDiscount.objects.remaining(order)
        """

        queryset = self.all()
        if order:
            queryset = queryset.filter(order=order)

        return sum((d.remaining for d in queryset), Decimal('0.00'))


class AppliedDiscount(DiscountBase):
    """
    Stores an applied discount, so that deletion of discounts does not
    affect orders.
    """

    order = models.ForeignKey(
        Order, related_name='applied_discounts', verbose_name=_('order'))
    # We could make this a ForeignKey to Discount.code, but we do not
    # want deletions to cascade to this table and we still need the code
    # for the PDF generation or whatever anyway.
    code = models.CharField(_('code'), max_length=30)
    remaining = models.DecimalField(
        _('remaining'),
        max_digits=18, decimal_places=10, default=0,
        help_text=_(
            'Discount amount excl. tax remaining after discount has'
            ' been applied.'))

    class Meta:
        ordering = ['type', 'name']
        verbose_name = _('applied discount')
        verbose_name_plural = _('applied discounts')

    objects = AppliedDiscountManager()

########NEW FILE########
__FILENAME__ = fields
import datetime
import logging
import re
import simplejson as json

from django import forms
from django.db import models
from django.utils.dateparse import parse_date, parse_datetime, parse_time
from django.utils.functional import curry
from django.utils.translation import ugettext_lazy as _

import plata


try:
    json.dumps([42], use_decimal=True)
except TypeError:  # pragma: no cover
    raise Exception('simplejson>=2.1 with support for use_decimal required.')


#: Field offering all defined currencies
CurrencyField = curry(
    models.CharField,
    _('currency'),
    max_length=3,
    choices=zip(plata.settings.CURRENCIES, plata.settings.CURRENCIES),
)


def json_encode_default(o):
    # See "Date Time String Format" in the ECMA-262 specification.
    if isinstance(o, datetime.datetime):
        return o.strftime('%Y-%m-%dT%H:%M:%S.%f%z')
    elif isinstance(o, datetime.date):
        return o.strftime('%Y-%m-%d')
    elif isinstance(o, datetime.time):
        return o.strftime('%H:%M:%S.%f%z')
    raise TypeError('Cannot encode %r' % o)


_PATTERNS = [
    (re.compile(r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}'), (
        lambda value: datetime.datetime.strptime(
            value,
            '%Y-%m-%dT%H:%M:%S.%f'),
        lambda value: datetime.datetime.strptime(
            value,
            '%Y-%m-%dT%H:%M:%S'),
        lambda value: parse_datetime(value),
    )),
    (re.compile(r'\d{4}-\d{2}-\d{2}'), (
        lambda value: parse_date(value),
    )),
    (re.compile(r'\d{2}:\d{2}:\d{2}'), (
        lambda value: parse_time(value),
    )),
]


def json_decode_hook(data):
    for key, value in list(data.items()):
        if not isinstance(value, basestring):
            continue

        for regex, fns in _PATTERNS:
            if regex.match(value):
                for fn in fns:
                    try:
                        data[key] = fn(value)
                        break
                    except ValueError:
                        pass

                break

    return data


class JSONFormField(forms.fields.CharField):
    def clean(self, value, *args, **kwargs):
        if value:
            try:
                # Run the value through JSON so we can normalize formatting
                # and at least learn about malformed data:
                value = json.dumps(
                    json.loads(
                        value,
                        use_decimal=True,
                        object_hook=json_decode_hook,
                    ),
                    use_decimal=True,
                    default=json_encode_default,
                )
            except ValueError:
                raise forms.ValidationError("Invalid JSON data!")

        return super(JSONFormField, self).clean(value, *args, **kwargs)


class JSONField(models.TextField):
    """
    TextField which transparently serializes/unserializes JSON objects

    See:
    http://www.djangosnippets.org/snippets/1478/
    """

    # Used so to_python() is called
    __metaclass__ = models.SubfieldBase

    formfield = JSONFormField

    def to_python(self, value):
        """Convert our string value to JSON after we load it from the DB"""

        if isinstance(value, dict):
            return value
        elif isinstance(value, basestring):
            # Avoid asking the JSON decoder to handle empty values:
            if not value:
                return {}

            try:
                return json.loads(
                    value, use_decimal=True,
                    object_hook=json_decode_hook)
            except ValueError:
                logging.getLogger("plata.fields").exception(
                    "Unable to deserialize stored JSONField data: %s", value)
                return {}
        else:
            assert value is None
            return {}

    def get_prep_value(self, value):
        """Convert our JSON object to a string before we save"""
        return self._flatten_value(value)

    def value_to_string(self, obj):
        """
        Extract our value from the passed object and return it in string form
        """

        if hasattr(obj, self.attname):
            value = getattr(obj, self.attname)
        else:
            assert isinstance(obj, dict)
            value = obj.get(self.attname, "")

        return self._flatten_value(value)

    def _flatten_value(self, value):
        """Return either a string, JSON-encoding dict()s as necessary"""
        if not value:
            return ""

        if isinstance(value, dict):
            value = json.dumps(
                value, use_decimal=True,
                default=json_encode_default)

        assert isinstance(value, basestring)

        return value

    def value_from_object(self, obj):
        return json.dumps(
            super(JSONField, self).value_from_object(obj),
            default=json_encode_default, use_decimal=True)


try:  # pragma: no cover
    from south.modelsinspector import add_introspection_rules
    JSONField_introspection_rule = ((JSONField,), [], {},)
    add_introspection_rules(
        rules=[JSONField_introspection_rule],
        patterns=["^plata\.fields"])
except ImportError:
    pass

########NEW FILE########
__FILENAME__ = models
# empty models.py for test suite support

########NEW FILE########
__FILENAME__ = base
import logging
import warnings

from django.utils.translation import ugettext_lazy as _, ugettext

import plata
from plata.shop import signals


logger = logging.getLogger('plata.payment')


class ProcessorBase(object):
    """Payment processor base class"""

    #: Safe key for this payment module (shouldn't contain special chars,
    #: spaces etc.)
    key = 'unnamed'

    #: Human-readable name for this payment module. You may use i18n here.
    default_name = 'unnamed'

    def __init__(self, shop):
        self.shop = shop

    @property
    def name(self):
        """
        Returns name of this payment module suitable for human consumption

        Defaults to ``default_name`` but can be overridden by placing an
        entry in ``PLATA_PAYMENT_MODULE_NAMES``. Example::

            PLATA_PAYMENT_MODULE_NAMES = {
                'paypal': _('Paypal and credit cards'),
                }
        """
        return plata.settings.PLATA_PAYMENT_MODULE_NAMES.get(
            self.key,
            self.default_name)

    @property
    def urls(self):
        """
        Returns URLconf definitions used by this payment processor

        This is especially useful for processors offering server-to-server
        communication such as Paypal's IPN (Instant Payment Notification)
        where Paypal communicates payment success immediately and directly,
        without involving the client.

        Define your own URLs in ``get_urls``.
        """
        return self.get_urls()

    def get_urls(self):
        """
        Defines URLs for this payment processor

        Note that these URLs are added directly to the shop views URLconf
        without prefixes. It is your responsability to namespace these URLs
        so they don't clash with shop views and other payment processors.
        """
        from django.conf.urls import patterns
        return patterns('')

    def enabled_for_request(self, request):
        """
        Decides whether this payment modules is available for a given request.

        Defaults to ``True``. If you need to disable payment modules for
        certain visitors or group of visitors, that is the method you are
        searching for.
        """
        return True

    def process_order_confirmed(self, request, order):
        """
        This is the initial entry point of payment modules and is called when
        the user has selected a payment module and accepted the terms and
        conditions of the shop.

        Must return a response which is presented to the user, i.e. a form
        with hidden values forwarding the user to the PSP or a redirect to
        the success page if no further processing is needed.
        """
        raise NotImplementedError  # pragma: no cover

    def clear_pending_payments(self, order):
        """
        Clear pending payments
        """
        logger.info('Clearing pending payments on %s' % order)
        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()
            for transaction in order.stock_transactions.filter(
                    type=StockTransaction.PAYMENT_PROCESS_RESERVATION):
                transaction.delete()

        order.payments.pending().delete()

    def create_pending_payment(self, order):
        """
        Create a pending payment
        """
        self.clear_pending_payments(order)
        logger.info('Creating pending payment on %s' % order)
        return order.payments.create(
            currency=order.currency,
            amount=order.balance_remaining,
            payment_module_key=self.key,
            payment_module=u'%s' % self.name,
        )

    def create_transactions(self, order, stage, **kwargs):
        """
        Create transactions for all order items. The real work is offloaded
        to ``StockTransaction.objects.bulk_create``.
        """

        if not plata.settings.PLATA_STOCK_TRACKING:
            warnings.warn(
                'StockTransaction.objects.create_transactions'
                ' currently has no effect when PLATA_STOCK_TRACKING = False.'
                ' This will change in the future. Change your code to only'
                ' call create_transactions when'
                ' plata.settings.PLATA_STOCK_TRACKING = True',
                DeprecationWarning, stacklevel=2)
            return
        StockTransaction = plata.stock_model()
        StockTransaction.objects.bulk_create(
            order,
            notes=_('%(stage)s: %(order)s processed by %(payment_module)s') % {
                'stage': stage,
                'order': order,
                'payment_module': self.name,
            },
            **kwargs)

    def order_paid(self, order, payment=None, request=None):
        """
        Call this when the order has been fully paid for

        This method does the following:

        - Sets order status to ``PAID``.
        - Calculates the remaining discount amount (if any) and calls the
          ``order_paid`` signal.
        - Clears pending payments which aren't interesting anymore anyway.
        """

        if order.status < order.PAID:
            logger.info('Order %s has been completely paid for using %s' % (
                order, self.name))
            order.update_status(order.PAID, 'Order has been paid')

            signal_kwargs = dict(
                sender=self,
                order=order,
                payment=payment,
                request=request)

            if order.discount_remaining:
                logger.info(
                    'Creating discount for remaining amount %s on'
                    ' order %s' % (order.discount_remaining, order))
                discount_model = self.shop.discount_model
                try:
                    discount = order.applied_discounts.filter(type__in=(
                        discount_model.AMOUNT_VOUCHER_EXCL_TAX,
                        discount_model.AMOUNT_VOUCHER_INCL_TAX,
                    )).order_by('type')[0]
                except IndexError:
                    # XXX: Remaining discount will be applicable to ALL
                    #products, not sure if this behavior is correct...
                    discount = None

                remaining_discount = discount_model.objects.create(
                    name=ugettext('Remaining discount for order %s') % (
                        order.order_id,
                    ),
                    type=discount_model.AMOUNT_VOUCHER_EXCL_TAX,
                    value=order.discount_remaining,
                    currency=order.currency,
                    config=getattr(discount, 'config', '{"all": {}}'),
                    allowed_uses=1,
                )

                signal_kwargs['remaining_discount'] = remaining_discount

            signals.order_paid.send(**signal_kwargs)
        self.clear_pending_payments(order)

    def already_paid(self, order):
        """
        Handles the case where a payment module is selected but the order
        is already completely paid for (f.e. because an amount discount has
        been used which covers the order).

        Does nothing if the order **status** is ``PAID`` already.
        """
        if order.status < order.PAID:
            logger.info('Order %s is already completely paid' % order)

            if plata.settings.PLATA_STOCK_TRACKING:
                StockTransaction = plata.stock_model()
                self.create_transactions(
                    order, _('sale'),
                    type=StockTransaction.SALE, negative=True)

            self.order_paid(order)

        return self.shop.redirect('plata_order_success')

########NEW FILE########
__FILENAME__ = cod
"""
Payment module for cash on delivery handling

Automatically completes every order passed.
"""

import logging

from django.utils import timezone
from django.utils.translation import ugettext_lazy as _

import plata
from plata.payment.modules.base import ProcessorBase
from plata.shop.models import OrderPayment


logger = logging.getLogger('plata.payment.cod')


class PaymentProcessor(ProcessorBase):
    key = 'cod'
    default_name = _('Cash on delivery')

    def process_order_confirmed(self, request, order):
        if not order.balance_remaining:
            return self.already_paid(order)

        logger.info('Processing order %s using COD' % order)

        payment = self.create_pending_payment(order)

        payment.status = OrderPayment.AUTHORIZED
        payment.authorized = timezone.now()
        payment.save()
        order = order.reload()

        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()
            self.create_transactions(
                order, _('sale'),
                type=StockTransaction.SALE, negative=True, payment=payment)
        self.order_paid(order, payment=payment, request=request)

        return self.shop.redirect('plata_order_success')

########NEW FILE########
__FILENAME__ = ogone
"""
Payment module for Ogone integration

Needs the following settings to work correctly::

    OGONE = {
        'PSPID': 'your_shop_id',
        'LIVE': True, # Or False
        'SHA1_IN': 'yourhash',
        'SHA1_OUT': 'yourotherhash',
        }
"""

from decimal import Decimal
from hashlib import sha1
import locale
import logging

from django.conf import settings
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseForbidden
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.utils.translation import (
    ugettext_lazy as _, get_language, to_locale)
from django.views.decorators.csrf import csrf_exempt

import plata
from plata.payment.modules.base import ProcessorBase
from plata.shop.models import OrderPayment


logger = logging.getLogger('plata.payment.ogone')

csrf_exempt_m = method_decorator(csrf_exempt)


# Copied from ogone test account backend
STATUSES = """\
0	Incomplete or invalid
1	Cancelled by client
2	Authorization refused
4	Order stored
40	Stored waiting external result
41	Waiting client payment
5	Authorized
50	Authorized waiting external result
51	Authorization waiting
52	Authorization not known
55	Stand-by
56	OK with scheduled payments
57	Error in scheduled payments
59	Authoriz. to get manually
6	Authorized and cancelled
61	Author. deletion waiting
62	Author. deletion uncertain
63	Author. deletion refused
64	Authorized and cancelled
7	Payment deleted
71	Payment deletion pending
72	Payment deletion uncertain
73	Payment deletion refused
74	Payment deleted
75	Deletion processed by merchant
8	Refund
81	Refund pending
82	Refund uncertain
83	Refund refused
84	Payment declined by the acquirer
85	Refund processed by merchant
9	Payment requested
91	Payment processing
92	Payment uncertain
93	Payment refused
94	Refund declined by the acquirer
95	Payment processed by merchant
99	Being processed"""

STATUS_DICT = dict(line.split('\t') for line in STATUSES.splitlines())


class PaymentProcessor(ProcessorBase):
    key = 'ogone'
    default_name = _('Ogone')

    def get_urls(self):
        from django.conf.urls import patterns, url

        return patterns(
            '',
            url(r'^payment/ogone/ipn/$', self.ipn,
                name='plata_payment_ogone_ipn'),
        )

    def process_order_confirmed(self, request, order):
        OGONE = settings.OGONE

        if not order.balance_remaining:
            return self.already_paid(order)

        logger.info('Processing order %s using Ogone' % order)

        payment = self.create_pending_payment(order)
        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()
            self.create_transactions(
                order, _('payment process reservation'),
                type=StockTransaction.PAYMENT_PROCESS_RESERVATION,
                negative=True, payment=payment)

        # params that will be hashed
        form_params = {
            'PSPID': OGONE['PSPID'],
            'orderID': 'Order-%d-%d' % (order.id, payment.id),
            'amount': u'%s' % int(
                order.balance_remaining.quantize(Decimal('0.00')) * 100),
            'currency': order.currency,
            'language': locale.normalize(
                to_locale(get_language())).split('.')[0],
            'CN': u'%s %s' % (
                order.billing_first_name,
                order.billing_last_name),
            'EMAIL': order.email,
            'ownerZIP': order.billing_zip_code,
            'owneraddress': order.billing_address,
            'ownertown': order.billing_city,
            'accepturl': u'http://%s%s' % (
                request.META.get('HTTP_HOST'),
                reverse('plata_order_success')),
            'declineurl': u'http://%s%s' % (
                request.META.get('HTTP_HOST'),
                reverse('plata_order_payment_failure')),
            'exceptionurl': u'http://%s%s' % (
                request.META.get('HTTP_HOST'),
                reverse('plata_order_payment_failure')),
            'cancelurl': u'http://%s%s' % (
                request.META.get('HTTP_HOST'),
                reverse('plata_order_payment_failure')),
        }
        # create hash
        value_strings = [
            u'{0}={1}{2}'.format(key.upper(), value, OGONE['SHA1_IN'])
            for key, value in form_params.items()]
        hash_string = u''.join(sorted(value_strings))
        encoded_hash_string = sha1(hash_string.encode('utf-8')).hexdigest()

        # add hash and additional params
        form_params.update({
            'SHASign': encoded_hash_string.upper(),
            'mode': OGONE['LIVE'] and 'prod' or 'test',
        })

        return self.shop.render(request, 'payment/%s_form.html' % self.key, {
            'order': order,
            'HTTP_HOST': request.META.get('HTTP_HOST'),
            'form_params': form_params,
            'locale': form_params['language'],
        })

    @csrf_exempt_m
    def ipn(self, request):
        OGONE = settings.OGONE

        try:
            parameters_repr = repr(request.POST.copy()).encode('utf-8')
            logger.info('IPN: Processing request data %s' % parameters_repr)

            try:
                orderID = request.POST['orderID']
                currency = request.POST['currency']
                amount = request.POST['amount']
                STATUS = request.POST['STATUS']
                PAYID = request.POST['PAYID']
                BRAND = request.POST['BRAND']
                SHASIGN = request.POST['SHASIGN']
            except KeyError, e:
                logger.error('IPN: Missing data in %s' % parameters_repr)
                return HttpResponseForbidden('Missing data')

            value_strings = [
                u'{0}={1}{2}'.format(key.upper(), value, OGONE['SHA1_OUT'])
                for key, value in request.POST.iteritems()
                if value and not key == 'SHASIGN']
            sha1_out = sha1(
                (u''.join(sorted(value_strings))).encode('utf-8')).hexdigest()

            if sha1_out.lower() != SHASIGN.lower():
                logger.error('IPN: Invalid hash in %s' % parameters_repr)
                return HttpResponseForbidden('Hash did not validate')

            try:
                order, order_id, payment_id = orderID.split('-')
            except ValueError:
                logger.error('IPN: Error getting order for %s' % orderID)
                return HttpResponseForbidden('Malformed order ID')

            # Try fetching the order and order payment objects
            # We create a new order payment object in case the old one
            # cannot be found.
            try:
                order = self.shop.order_model.objects.get(pk=order_id)
            except self.shop.order_model.DoesNotExist:
                logger.error('IPN: Order %s does not exist' % order_id)
                return HttpResponseForbidden(
                    'Order %s does not exist' % order_id)

            try:
                payment = order.payments.get(pk=payment_id)
            except order.payments.model.DoesNotExist:
                payment = order.payments.model(
                    order=order,
                    payment_module=u'%s' % self.name,
                )

            payment.status = OrderPayment.PROCESSED
            payment.currency = currency
            payment.amount = Decimal(amount)
            payment.data = request.POST.copy()
            payment.transaction_id = PAYID
            payment.payment_method = BRAND
            payment.notes = STATUS_DICT.get(STATUS)

            if STATUS in ('5', '9'):
                payment.authorized = timezone.now()
                payment.status = OrderPayment.AUTHORIZED

            payment.save()
            order = order.reload()

            logger.info(
                'IPN: Successfully processed IPN request for %s' % order)

            if payment.authorized and plata.settings.PLATA_STOCK_TRACKING:
                StockTransaction = plata.stock_model()
                self.create_transactions(
                    order, _('sale'),
                    type=StockTransaction.SALE, negative=True, payment=payment)

            if not order.balance_remaining:
                self.order_paid(order, payment=payment, request=request)

            return HttpResponse('OK')
        except Exception, e:
            logger.error('IPN: Processing failure %s' % unicode(e))
            raise

########NEW FILE########
__FILENAME__ = paypal
"""
Payment module for PayPal integration

Needs the following settings to work correctly::

    PAYPAL = {
        'BUSINESS': 'yourbusiness@paypal.com',
        'LIVE': True, # Or False
        }
"""

from decimal import Decimal
import logging
import urllib2

from django.conf import settings
from django.http import HttpResponse, HttpResponseForbidden
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.utils.translation import ugettext_lazy as _
from django.views.decorators.csrf import csrf_exempt

import plata
from plata.payment.modules.base import ProcessorBase
from plata.shop.models import OrderPayment


logger = logging.getLogger('plata.payment.paypal')

csrf_exempt_m = method_decorator(csrf_exempt)


class PaymentProcessor(ProcessorBase):
    key = 'paypal'
    default_name = _('Paypal')

    def get_urls(self):
        from django.conf.urls import patterns, url

        return patterns(
            '',
            url(r'^payment/paypal/ipn/$', self.ipn,
                name='plata_payment_paypal_ipn'),
        )

    def process_order_confirmed(self, request, order):
        PAYPAL = settings.PAYPAL

        if not order.balance_remaining:
            return self.already_paid(order)

        logger.info('Processing order %s using Paypal' % order)

        payment = self.create_pending_payment(order)
        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()
            self.create_transactions(
                order, _('payment process reservation'),
                type=StockTransaction.PAYMENT_PROCESS_RESERVATION,
                negative=True, payment=payment)

        if PAYPAL['LIVE']:
            PP_URL = "https://www.paypal.com/cgi-bin/webscr"
        else:
            PP_URL = "https://www.sandbox.paypal.com/cgi-bin/webscr"

        return self.shop.render(request, 'payment/%s_form.html' % self.key, {
            'order': order,
            'payment': payment,
            'RETURN_SCHEME': PAYPAL.get(
                'RETURN_SCHEME',
                'https' if request.is_secure() else 'http'
            ),
            'IPN_SCHEME': PAYPAL.get('IPN_SCHEME', 'http'),
            'HTTP_HOST': request.META.get('HTTP_HOST'),
            'post_url': PP_URL,
            'business': PAYPAL['BUSINESS'],
        })

    @csrf_exempt_m
    def ipn(self, request):
        if not request._read_started:
            if 'windows-1252' in request.body:
                if request.encoding != 'windows-1252':
                    request.encoding = 'windows-1252'
        else:  # middleware (or something else?) has triggered request reading
            if request.POST.get('charset') == 'windows-1252':
                if request.encoding != 'windows-1252':
                    # since the POST data has already been accessed,
                    # unicode characters may have already been lost and
                    # cannot be re-encoded.
                    # -- see https://code.djangoproject.com/ticket/14035
                    # Unfortunately, PayPal:
                    # a) defaults to windows-1252 encoding (why?!)
                    # b) doesn't indicate this in the Content-Type header
                    #    so Django cannot automatically detect it.
                    logger.warning(
                        'IPN received with charset=windows1252, however '
                        'the request encoding does not match. It may be '
                        'impossible to verify this IPN if the data contains '
                        'non-ASCII characters. Please either '
                        'a) update your PayPal preferences to use UTF-8 '
                        'b) configure your site so that IPN requests are '
                        'not ready before they reach the hanlder'
                    )

        PAYPAL = settings.PAYPAL

        if PAYPAL['LIVE']:
            PP_URL = "https://www.paypal.com/cgi-bin/webscr"
        else:
            PP_URL = "https://www.sandbox.paypal.com/cgi-bin/webscr"

        parameters = None

        try:
            parameters = request.POST.copy()
            parameters_repr = repr(parameters).encode('utf-8')

            if parameters:
                logger.info(
                    'IPN: Processing request data %s' % parameters_repr)

                querystring = 'cmd=_notify-validate&%s' % (
                    request.POST.urlencode()
                )
                status = urllib2.urlopen(PP_URL, querystring).read()

                if not status == "VERIFIED":
                    logger.error(
                        'IPN: Received status %s, '
                        'could not verify parameters %s' % (
                            status,
                            parameters_repr
                        )
                    )
                    logger.debug('Destination: %r ? %r', PP_URL, querystring)
                    logger.debug('Request: %r', request)
                    return HttpResponseForbidden('Unable to verify')

            if parameters:
                logger.info('IPN: Verified request %s' % parameters_repr)
                reference = parameters['txn_id']
                invoice_id = parameters['invoice']
                currency = parameters['mc_currency']
                amount = parameters['mc_gross']

                try:
                    order, order_id, payment_id = invoice_id.split('-')
                except ValueError:
                    logger.error(
                        'IPN: Error getting order for %s' % invoice_id)
                    return HttpResponseForbidden('Malformed order ID')

                try:
                    order = self.shop.order_model.objects.get(pk=order_id)
                except (self.shop.order_model.DoesNotExist, ValueError):
                    logger.error('IPN: Order %s does not exist' % order_id)
                    return HttpResponseForbidden(
                        'Order %s does not exist' % order_id)

                try:
                    payment = order.payments.get(pk=payment_id)
                except (order.payments.model.DoesNotExist, ValueError):
                    payment = order.payments.model(
                        order=order,
                        payment_module=u'%s' % self.name,
                    )

                payment.status = OrderPayment.PROCESSED
                payment.currency = currency
                payment.amount = Decimal(amount)
                payment.data = request.POST.copy()
                payment.transaction_id = reference
                payment.payment_method = payment.payment_module

                if parameters['payment_status'] == 'Completed':
                    payment.authorized = timezone.now()
                    payment.status = OrderPayment.AUTHORIZED

                payment.save()
                order = order.reload()

                logger.info(
                    'IPN: Successfully processed IPN request for %s' % order)

                if payment.authorized and plata.settings.PLATA_STOCK_TRACKING:
                    StockTransaction = plata.stock_model()
                    self.create_transactions(
                        order,
                        _('sale'),
                        type=StockTransaction.SALE,
                        negative=True,
                        payment=payment)

                if not order.balance_remaining:
                    self.order_paid(order, payment=payment, request=request)

                return HttpResponse("Ok")

        except Exception, e:
            logger.error('IPN: Processing failure %s' % unicode(e))
            raise
        else:
            logger.warning('IPN received without POST parameters')
            return HttpResponseForbidden('No parameters provided')

########NEW FILE########
__FILENAME__ = postfinance
"""
Payment module for Postfinance integration

Needs the following settings to work correctly::

    POSTFINANCE = {
        'PSPID': 'your_shop_id',
        'LIVE': True, # Or False
        'SHA1_IN': 'yourhash',
        'SHA1_OUT': 'yourotherhash',
        }
"""

from decimal import Decimal
from hashlib import sha1
import locale
import logging

from django.conf import settings
from django.http import HttpResponse, HttpResponseForbidden
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.utils.translation import (
    ugettext_lazy as _, get_language, to_locale)
from django.views.decorators.csrf import csrf_exempt

import plata
from plata.payment.modules.base import ProcessorBase
from plata.shop.models import OrderPayment


logger = logging.getLogger('plata.payment.postfinance')

csrf_exempt_m = method_decorator(csrf_exempt)


# Copied from http://e-payment.postfinance.ch/ncol/paymentinfos1.asp
STATUSES = """\
0	Incomplete or invalid
1	Cancelled by client
2	Authorization refused
4	Order stored
41	Waiting client payment
5	Authorized
51	Authorization waiting
52	Authorization not known
55	Stand-by
59	Authoriz. to get manually
6	Authorized and cancelled
61	Author. deletion waiting
62	Author. deletion uncertain
63	Author. deletion refused
64	Authorized and cancelled
7	Payment deleted
71	Payment deletion pending
72	Payment deletion uncertain
73	Payment deletion refused
74	Payment deleted
75	Deletion processed by merchant
8	Refund
81	Refund pending
82	Refund uncertain
83	Refund refused
84	Payment declined by the acquirer
85	Refund processed by merchant
9	Payment requested
91	Payment processing
92	Payment uncertain
93	Payment refused
94	Refund declined by the acquirer
95	Payment processed by merchant
99	Being processed"""

STATUS_DICT = dict(line.split('\t') for line in STATUSES.splitlines())


class PaymentProcessor(ProcessorBase):
    key = 'postfinance'
    default_name = _('Postfinance')

    def get_urls(self):
        from django.conf.urls import patterns, url

        return patterns(
            '',
            url(r'^payment/postfinance/ipn/$', self.ipn,
                name='plata_payment_postfinance_ipn'),
        )

    def process_order_confirmed(self, request, order):
        POSTFINANCE = settings.POSTFINANCE

        if not order.balance_remaining:
            return self.already_paid(order)

        logger.info('Processing order %s using Postfinance' % order)

        payment = self.create_pending_payment(order)
        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()
            self.create_transactions(
                order, _('payment process reservation'),
                type=StockTransaction.PAYMENT_PROCESS_RESERVATION,
                negative=True, payment=payment)

        form_params = {
            'orderID': 'Order-%d-%d' % (order.id, payment.id),
            'amount': u'%s' % int(
                order.balance_remaining.quantize(Decimal('0.00')) * 100),
            'currency': order.currency,
            'PSPID': POSTFINANCE['PSPID'],
            'mode': POSTFINANCE['LIVE'] and 'prod' or 'test',
        }

        form_params['SHASign'] = sha1(u''.join((
            form_params['orderID'],
            form_params['amount'],
            form_params['currency'],
            form_params['PSPID'],
            POSTFINANCE['SHA1_IN'],
        ))).hexdigest()

        return self.shop.render(request, 'payment/%s_form.html' % self.key, {
            'order': order,
            'HTTP_HOST': request.META.get('HTTP_HOST'),
            'form_params': form_params,
            'locale': locale.normalize(
                to_locale(get_language())).split('.')[0],
        })

    @csrf_exempt_m
    def ipn(self, request):
        POSTFINANCE = settings.POSTFINANCE

        try:
            parameters_repr = repr(request.POST.copy()).encode('utf-8')
            logger.info('IPN: Processing request data %s' % parameters_repr)

            try:
                orderID = request.POST['orderID']
                currency = request.POST['currency']
                amount = request.POST['amount']
                PM = request.POST['PM']
                ACCEPTANCE = request.POST['ACCEPTANCE']
                STATUS = request.POST['STATUS']
                CARDNO = request.POST['CARDNO']
                PAYID = request.POST['PAYID']
                NCERROR = request.POST['NCERROR']
                BRAND = request.POST['BRAND']
                SHASIGN = request.POST['SHASIGN']
            except KeyError:
                logger.error('IPN: Missing data in %s' % parameters_repr)
                return HttpResponseForbidden('Missing data')

            sha1_source = u''.join((
                orderID,
                currency,
                amount,
                PM,
                ACCEPTANCE,
                STATUS,
                CARDNO,
                PAYID,
                NCERROR,
                BRAND,
                POSTFINANCE['SHA1_OUT'],
            ))

            sha1_out = sha1(sha1_source).hexdigest()

            if sha1_out.lower() != SHASIGN.lower():
                logger.error('IPN: Invalid hash in %s' % parameters_repr)
                return HttpResponseForbidden('Hash did not validate')

            try:
                order, order_id, payment_id = orderID.split('-')
            except ValueError:
                logger.error('IPN: Error getting order for %s' % orderID)
                return HttpResponseForbidden('Malformed order ID')

            # Try fetching the order and order payment objects
            # We create a new order payment object in case the old one
            # cannot be found.
            try:
                order = self.shop.order_model.objects.get(pk=order_id)
            except self.shop.order_model.DoesNotExist:
                logger.error('IPN: Order %s does not exist' % order_id)
                return HttpResponseForbidden(
                    'Order %s does not exist' % order_id)

            try:
                payment = order.payments.get(pk=payment_id)
            except order.payments.model.DoesNotExist:
                payment = order.payments.model(
                    order=order,
                    payment_module=u'%s' % self.name,
                )

            payment.status = OrderPayment.PROCESSED
            payment.currency = currency
            payment.amount = Decimal(amount)
            payment.data = request.POST.copy()
            payment.transaction_id = PAYID
            payment.payment_method = BRAND
            payment.notes = STATUS_DICT.get(STATUS)

            if STATUS in ('5', '9'):
                payment.authorized = timezone.now()
                payment.status = OrderPayment.AUTHORIZED

            payment.save()
            order = order.reload()

            logger.info(
                'IPN: Successfully processed IPN request for %s' % order)

            if payment.authorized and plata.settings.PLATA_STOCK_TRACKING:
                StockTransaction = plata.stock_model()
                self.create_transactions(
                    order, _('sale'),
                    type=StockTransaction.SALE, negative=True, payment=payment)

            if not order.balance_remaining:
                self.order_paid(order, payment=payment, request=request)

            return HttpResponse('OK')
        except Exception, e:
            logger.error('IPN: Processing failure %s' % unicode(e))
            raise

########NEW FILE########
__FILENAME__ = models
"""
Product model base implementation -- you do not need to use this

It may save you some typing though.
"""

from django.db import models

import plata


class ProductBase(models.Model):
    """
    Product models must have two methods to be usable with Plata:

    - ``get_price``: Return a price instance
    - ``handle_order_item``: Fill in fields on the order item from the product,
      i.e. the name and the stock keeping unit.
    """

    class Meta:
        abstract = True

    def get_price(self, currency=None, orderitem=None):
        """
        This method is part of the public, required API of products. It returns
        either a price instance or raises a ``DoesNotExist`` exception.

        If you need more complex pricing schemes, override this method with
        your own implementation.
        """
        if currency is None:
            currency = (
                orderitem.currency if orderitem else
                plata.shop_instance().default_currency())

        try:
            # Let's hope that ordering=[-id] from the base price definition
            # makes any sense here :-)
            return self.prices.filter(currency=currency)[0]
        except IndexError:
            raise self.prices.model.DoesNotExist

    def handle_order_item(self, orderitem):
        """
        This method has to ensure that the information on the order item is
        sufficient for posteriority. Old orders should always be complete
        even if the products have been changed or deleted in the meantime.
        """
        orderitem.name = unicode(self)
        orderitem.sku = getattr(self, 'sku', u'')

########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

import plata
from . import models


if plata.settings.PLATA_STOCK_TRACKING:
    TYPE_CHOICES = [('', '---------')]
    TYPE_CHOICES.append((
        _('initial stock'),
        models.StockTransaction.TYPE_CHOICES[:2]))
    TYPE_CHOICES.append((
        _('purchases and sales'),
        models.StockTransaction.TYPE_CHOICES[2:4]))
    TYPE_CHOICES.append((
        _('stock management'),
        models.StockTransaction.TYPE_CHOICES[4:6]))
    TYPE_CHOICES.append((
        _('generic warehousing'),
        models.StockTransaction.TYPE_CHOICES[6:8]))
    TYPE_CHOICES.append((
        _('internal use'),
        models.StockTransaction.TYPE_CHOICES[8:]))

    class StockTransactionForm(forms.ModelForm):
        type = forms.ChoiceField(choices=TYPE_CHOICES)

    admin.site.register(
        models.Period,
        list_display=('name', 'notes', 'start'),
    )

    admin.site.register(
        models.StockTransaction,
        date_hierarchy='created',
        form=StockTransactionForm,
        list_display=(
            'period', 'created', 'product', 'type', 'change',
            'order', 'notes'),
        list_display_links=('created',),
        list_filter=('period', 'type'),
        raw_id_fields=('product', 'order', 'payment'),
        search_fields=('change', 'notes', 'name', 'sku'),
    )

########NEW FILE########
__FILENAME__ = models
"""
Exact, transactional stock tracking for Plata
=============================================

Follow these steps to enable this module:

- Ensure your product model has an ``items_in_stock`` field with the
  following definiton::

      items_in_stock = models.IntegerField(default=0)

- Add ``'plata.product.stock'`` to ``INSTALLED_APPS``.
- Set ``PLATA_STOCK_TRACKING = True`` to enable stock tracking in the
  checkout and payment processes.
- Optionally modify your add-to-cart forms on product detail pages to take
  into account ``items_in_stock``.
"""

from datetime import timedelta

from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import models
from django.db.models import Sum, Q, signals
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _, ugettext

import plata
from plata.shop.models import Order, OrderPayment


class PeriodManager(models.Manager):
    def current(self):
        """
        Return the newest active period
        """

        try:
            return self.filter(start__lte=timezone.now()).order_by(
                '-start')[0]
        except IndexError:
            return self.create(
                name=ugettext('Automatically created'),
                notes=ugettext(
                    'Automatically created because no period existed yet.'))


class Period(models.Model):
    """
    A period in which stock changes are tracked

    You might want to create a new period every year and create initial
    amount transactions for every variation.

    ``StockTransaction.objects.open_new_period`` does this automatically.
    """

    name = models.CharField(_('name'), max_length=100)
    notes = models.TextField(_('notes'), blank=True)
    start = models.DateTimeField(
        _('start'), default=timezone.now,
        help_text=_('Period starts at this time. May also be a future date.'))

    class Meta:
        # See https://github.com/matthiask/plata/issues/27
        abstract = not plata.settings.PLATA_STOCK_TRACKING
        get_latest_by = 'start'
        ordering = ['-start']
        verbose_name = _('period')
        verbose_name_plural = _('periods')

    objects = PeriodManager()

    def __unicode__(self):
        return self.name


class StockTransactionManager(models.Manager):
    def open_new_period(self, name=None):
        """
        Create a new period and create initial transactions for all product
        variations with their current ``items_in_stock`` value
        """

        period = Period.objects.create(name=name or ugettext('New period'))

        for p in plata.product_model()._default_manager.all():
            p.stock_transactions.create(
                period=period,
                type=StockTransaction.INITIAL,
                change=p.items_in_stock,
                notes=ugettext('New period'),
            )

    def items_in_stock(self, product, update=False, exclude_order=None,
                       include_reservations=False):
        """
        Determine the items in stock for the given product variation,
        optionally updating the ``items_in_stock`` field in the database.

        If ``exclude_order`` is given, ``update`` is always switched off
        and transactions from the given order aren't taken into account.

        If ``include_reservations`` is ``True``, ``update`` is always
        switched off.
        """

        queryset = self.filter(
            period=Period.objects.current(),
            product=product)

        if exclude_order:
            update = False
            queryset = queryset.filter(
                Q(order__isnull=True) | ~Q(order=exclude_order))

        if include_reservations:
            update = False
            queryset = queryset.exclude(
                type=self.model.PAYMENT_PROCESS_RESERVATION,
                created__lt=timezone.now() - timedelta(seconds=15 * 60))
        else:
            queryset = queryset.exclude(
                type=self.model.PAYMENT_PROCESS_RESERVATION)

        count = queryset.aggregate(items=Sum('change')).get('items') or 0

        product_model = plata.product_model()

        if isinstance(product, product_model):
            product.items_in_stock = count

        if update:
            product_model._default_manager.filter(
                id=getattr(product, 'pk', product)
            ).update(items_in_stock=count)

        return count

    def bulk_create(self, order, type, negative, **kwargs):
        """
        Create transactions in bulk for every order item

        Set ``negative`` to ``True`` for sales, lendings etc. (anything
        that diminishes the stock you have)
        """

        # Set negative to True for sales, lendings etc.

        factor = negative and -1 or 1

        for item in order.items.all():
            self.model.objects.create(
                product=item.product,
                type=type,
                change=item.quantity * factor,
                order=order,
                name=item.name,
                sku=item.sku,
                line_item_price=item._line_item_price,
                line_item_discount=item._line_item_discount,
                line_item_tax=item._line_item_tax,
                **kwargs)


class StockTransaction(models.Model):
    """
    Stores stock transactions transactionally :-)

    Stock transactions basically consist of a product variation reference,
    an amount, a type and a timestamp. The following types are available:

    - ``StockTransaction.INITIAL``: Initial amount, used when filling in the
      stock database
    - ``StockTransaction.CORRECTION``: Use this for any errors
    - ``StockTransaction.PURCHASE``: Product purchase from a supplier
    - ``StockTransaction.SALE``: Sales, f.e. through the webshop
    - ``StockTransaction.RETURNS``: Returned products (i.e. from lending)
    - ``StockTransaction.RESERVATION``: Reservations
    - ``StockTransaction.INCOMING``: Generic warehousing
    - ``StockTransaction.OUTGOING``: Generic warehousing
    - ``StockTransaction.PAYMENT_PROCESS_RESERVATION``: Product reservation
      during payment process

    Most of these types do not have a significance to Plata. The exceptions
    are:

    - ``INITIAL`` transactions are created by ``open_new_period``
    - ``SALE`` transactions are created when orders are confirmed
    - ``PAYMENT_PROCESS_RESERVATION`` transactions are created by payment
      modules which send the user to a different domain for payment data
      entry (f.e. PayPal). These transactions are also special in that they
      are only valid for 15 minutes. After 15 minutes, other customers are
      able to put the product in their cart and proceed to checkout again.
      This time period is a security measure against customers buying
      products at the same time which cannot be delivered afterwards because
      stock isn't available.
    """

    INITIAL = 10
    CORRECTION = 20
    PURCHASE = 30
    SALE = 40
    RETURNS = 50
    RESERVATION = 60

    # Generic warehousing
    INCOMING = 70
    OUTGOING = 80

    # Semi-internal use
    PAYMENT_PROCESS_RESERVATION = 100  # reservation during payment process

    TYPE_CHOICES = (
        (INITIAL, _('initial amount')),
        (CORRECTION, _('correction')),
        (PURCHASE, _('purchase')),
        (SALE, _('sale')),
        (RETURNS, _('returns')),
        (RESERVATION, _('reservation')),
        (INCOMING, _('incoming')),
        (OUTGOING, _('outgoing')),
        (PAYMENT_PROCESS_RESERVATION, _('payment process reservation')),
    )

    period = models.ForeignKey(
        Period, default=Period.objects.current,
        related_name='stock_transactions', verbose_name=_('period'))
    created = models.DateTimeField(_('created'), default=timezone.now)
    product = models.ForeignKey(
        plata.settings.PLATA_SHOP_PRODUCT,
        related_name='stock_transactions', verbose_name=_('product'),
        on_delete=models.SET_NULL, null=True)
    type = models.PositiveIntegerField(_('type'), choices=TYPE_CHOICES)
    change = models.IntegerField(
        _('change'),
        help_text=_(
            'Use negative numbers for sales, lendings and other'
            ' outgoings.'))
    order = models.ForeignKey(
        Order, blank=True, null=True,
        related_name='stock_transactions', verbose_name=_('order'))
    payment = models.ForeignKey(
        OrderPayment, blank=True, null=True,
        related_name='stock_transactions', verbose_name=_('order payment'))

    notes = models.TextField(_('notes'), blank=True)

    # There are purely informative fields; not required in any way
    # (but very useful for analysis down the road)
    name = models.CharField(_('name'), max_length=100, blank=True)
    sku = models.CharField(_('SKU'), max_length=100, blank=True)
    line_item_price = models.DecimalField(
        _('line item price'),
        max_digits=18, decimal_places=10, blank=True, null=True)
    line_item_discount = models.DecimalField(
        _('line item discount'),
        max_digits=18, decimal_places=10, blank=True, null=True)
    line_item_tax = models.DecimalField(
        _('line item tax'),
        max_digits=18, decimal_places=10, blank=True, null=True)

    class Meta:
        # See https://github.com/matthiask/plata/issues/27
        abstract = not plata.settings.PLATA_STOCK_TRACKING
        ordering = ['-id']
        verbose_name = _('stock transaction')
        verbose_name_plural = _('stock transactions')

    objects = StockTransactionManager()

    def __unicode__(self):
        return u'%s %s of %s' % (
            self.change,
            self.get_type_display(),
            self.product)

    def save(self, *args, **kwargs):
        if not self.period_id:
            self.period = Period.objects.current()

        if self.product and hasattr(self.product, 'handle_stock_transaction'):
            self.product.handle_stock_transaction(self)

        super(StockTransaction, self).save(*args, **kwargs)
    save.alters_data = True


def update_items_in_stock(instance, **kwargs):
    StockTransaction.objects.items_in_stock(instance.product_id, update=True)


def validate_order_stock_available(order):
    """
    Check whether enough stock is available for all selected products,
    taking into account payment process reservations.
    """
    for item in order.items.select_related('product'):
        if item.quantity > StockTransaction.objects.items_in_stock(
                item.product,
                exclude_order=order,
                include_reservations=True):
            raise ValidationError(
                _('Not enough stock available for %s.') % item.product,
                code='insufficient_stock')


if plata.settings.PLATA_STOCK_TRACKING:
    product_model = plata.product_model()
    try:
        product_model._meta.get_field('items_in_stock')
    except models.FieldDoesNotExist:
        raise ImproperlyConfigured(
            'Product model %r must have a field named `items_in_stock`' % (
                product_model,
            ))

    signals.post_delete.connect(
        update_items_in_stock,
        sender=StockTransaction)
    signals.post_save.connect(
        update_items_in_stock,
        sender=StockTransaction)

    Order.register_validator(
        validate_order_stock_available,
        Order.VALIDATE_CART)

########NEW FILE########
__FILENAME__ = order
from decimal import Decimal

from django.core.urlresolvers import get_callable
from django.utils.text import capfirst
from django.utils.translation import activate, ugettext as _

from pdfdocument.document import cm, mm
from pdfdocument.elements import create_stationery_fn

import plata


class OrderReport(object):
    def __init__(self, pdf, order):
        self.pdf = pdf
        self.order = order

        if order.language_code:
            activate(order.language_code)

    def init_letter(self):
        self.pdf.init_letter(page_fn=create_stationery_fn(
            get_callable(plata.settings.PLATA_REPORTING_STATIONERY)()))

    def address(self, address_key):
        """
        ``address_key`` must be one of ``shipping`` and ``billing``.
        """

        if plata.settings.PLATA_REPORTING_ADDRESSLINE:
            self.pdf.address_head(plata.settings.PLATA_REPORTING_ADDRESSLINE)

        self.pdf.address(self.order.addresses()[address_key])
        self.pdf.next_frame()

    def title(self, title=None):
        self.pdf.p(u'%s: %s' % (
            capfirst(_('order date')),
            self.order.confirmed.strftime('%d.%m.%Y')
            if self.order.confirmed else _('Not confirmed yet'),
        ))
        self.pdf.spacer(3 * mm)

        if not title:
            title = _('Order')
        self.pdf.h1(u'%s %s' % (title, self.order.order_id))
        self.pdf.hr()

    def items_without_prices(self):
        self.pdf.table(
            [
                (
                    _('SKU'),
                    capfirst(_('product')),
                    capfirst(_('quantity')),
                )
            ] + [
                (
                    item.sku,
                    item.name,
                    item.quantity,
                ) for item in self.order.items.all()
            ],
            (2 * cm, 13.4 * cm, 1 * cm), self.pdf.style.tableHead + (
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
            ))

    def items_with_prices(self):
        self.pdf.table(
            [
                (
                    _('SKU'),
                    capfirst(_('product')),
                    capfirst(_('quantity')),
                    capfirst(_('unit price')),
                    capfirst(_('line item price')),
                )
            ] + [
                (
                    item.sku,
                    item.name,
                    item.quantity,
                    u'%.2f' % item.unit_price,
                    u'%.2f' % item.discounted_subtotal,
                ) for item in self.order.items.all()
            ],
            (2 * cm, 6 * cm, 1 * cm, 3 * cm, 4.4 * cm),
            self.pdf.style.tableHead + (
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
            ))

    def summary(self):
        summary_table = [
            ('', ''),
            (capfirst(_('subtotal')), u'%.2f' % self.order.subtotal),
        ]

        if self.order.discount:
            summary_table.append((
                capfirst(_('discount')),
                u'%.2f' % self.order.discount))

        if self.order.shipping:
            summary_table.append((
                capfirst(_('shipping')),
                u'%.2f' % self.order.shipping))

        self.pdf.table(
            summary_table, (12 * cm, 4.4 * cm), self.pdf.style.table)

        self.pdf.spacer(1 * mm)

        total_title = u'%s %s' % (capfirst(_('total')), self.order.currency)

        if self.order.tax:
            if 'tax_details' in self.order.data:
                zero = Decimal('0.00')

                self.pdf.table([(
                    u'',
                    u'%s %s' % (
                        _('Incl. tax'),
                        u'%.1f%%' % row['tax_rate'],
                        ),
                    row['total'].quantize(zero),
                    row['tax_amount'].quantize(zero),
                    u'',
                    ) for rate, row in self.order.data['tax_details']],
                    (2 * cm, 4 * cm, 3 * cm, 3 * cm, 4.4 * cm),
                    self.pdf.style.table)

        self.pdf.table([
            (total_title, u'%.2f' % self.order.total),
            ], (12 * cm, 4.4 * cm), self.pdf.style.tableHead)

        self.pdf.spacer()

    def payment(self):
        if not self.order.balance_remaining:
            try:
                payment = self.order.payments.authorized()[0]
            except IndexError:
                payment = None

            if payment and payment.payment_method:
                self.pdf.p(
                    _('Already paid for with %(payment_method)s'
                        ' (Transaction %(transaction)s).') % {
                        'payment_method': payment.payment_method,
                        'transaction': payment.transaction_id,
                        })
            else:
                self.pdf.p(_('Already paid for.'))
        else:
            self.pdf.p(_('Not paid yet.'))

    def notes(self):
        if self.order.notes:
            self.pdf.spacer(10 * mm)
            self.pdf.p(capfirst(_('notes')), style=self.pdf.style.bold)
            self.pdf.spacer(1 * mm)
            self.pdf.p(self.order.notes)


def invoice_pdf(pdf, order):
    """PDF suitable for use as invoice"""

    report = OrderReport(pdf, order)
    report.init_letter()
    report.address('billing')
    report.title()
    report.items_with_prices()
    report.summary()
    report.payment()

    pdf.generate()


def packing_slip_pdf(pdf, order):
    """PDF suitable for use as packing slip"""

    report = OrderReport(pdf, order)
    report.init_letter()
    report.address('shipping')
    report.title()
    report.items_without_prices()
    report.notes()

    pdf.generate()

########NEW FILE########
__FILENAME__ = product
from collections import defaultdict

from django.db.models import Sum
from django.utils.text import capfirst
from django.utils.translation import ugettext as _

import plata
from plata.reporting.utils import XLSDocument


def product_xls():
    """
    Create a list of all product variations, including stock and aggregated
    stock transactions (by type)
    """

    from plata.product.stock.models import Period
    StockTransaction = plata.stock_model()

    xls = XLSDocument()
    xls.add_sheet(capfirst(_('products')))

    _transactions = StockTransaction.objects.filter(
        period=Period.objects.current(),
        ).order_by().values('product', 'type').annotate(Sum('change'))

    transactions = defaultdict(dict)
    for t in _transactions:
        transactions[t['product']][t['type']] = t['change__sum']

    titles = [
        capfirst(_('product')),
        _('SKU'),
        capfirst(_('stock')),
    ]
    titles.extend(
        unicode(name) for key, name in StockTransaction.TYPE_CHOICES)

    data = []

    for product in plata.product_model().objects.all().select_related():
        row = [
            product,
            getattr(product, 'sku', ''),
            getattr(product, 'items_in_stock', -1),
            ]
        row.extend(
            transactions[product.id].get(key, '')
            for key, name in StockTransaction.TYPE_CHOICES)
        data.append(row)

    xls.table(titles, data)
    return xls

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns(
    'plata.reporting.views',
    url(r'^product_xls/$', 'product_xls',
        name='plata_reporting_product_xls'),
    url(r'^invoice_pdf/(?P<order_id>\d+)/$', 'invoice_pdf',
        name='plata_reporting_invoice_pdf'),
    url(r'^packing_slip_pdf/(?P<order_id>\d+)/$', 'packing_slip_pdf',
        name='plata_reporting_packing_slip_pdf'),
)

########NEW FILE########
__FILENAME__ = utils
from datetime import date
from decimal import Decimal
from io import BytesIO
from openpyxl import Workbook


class XLSDocument(object):
    def __init__(self):
        self.workbook = Workbook(optimized_write=True)
        self.sheet = None

    def add_sheet(self, title=None):
        self.sheet = self.workbook.create_sheet(title=title)

    def table(self, titles, rows):
        if titles:
            self.sheet.append(titles)

        for row in rows:
            processed = []
            for i, value in enumerate(row):
                if isinstance(value, date):
                    processed.append(value.strftime('%Y-%m-%d'))
                elif isinstance(value, (int, float, Decimal)):
                    processed.append(value)
                elif value is None:
                    processed.append('-')
                else:
                    processed.append(unicode(value).strip())

            self.sheet.append(processed)

    def to_response(self, filename):
        from django.http import HttpResponse
        output = BytesIO()
        self.workbook.save(output)
        response = HttpResponse(
            output.getvalue(),
            content_type=(
                'application/vnd.openxmlformats-officedocument.'
                'spreadsheetml.sheet'),
            )
        output.close()
        response['Content-Disposition'] = 'attachment; filename="%s"' % (
            filename,
            )
        return response

########NEW FILE########
__FILENAME__ = views
from django.contrib.admin.views.decorators import staff_member_required
from django.shortcuts import get_object_or_404

from pdfdocument.utils import pdf_response

import plata
import plata.reporting.product
import plata.reporting.order


@staff_member_required
def product_xls(request):
    """
    Returns an XLS containing product information
    """
    return plata.reporting.product.product_xls().to_response('products.xlsx')


@staff_member_required
def invoice_pdf(request, order_id):
    """
    Returns the invoice PDF
    """
    order = get_object_or_404(plata.shop_instance().order_model, pk=order_id)

    pdf, response = pdf_response('invoice-%09d' % order.id)
    plata.reporting.order.invoice_pdf(pdf, order)
    return response


@staff_member_required
def packing_slip_pdf(request, order_id):
    """
    Returns the packing slip PDF
    """
    order = get_object_or_404(plata.shop_instance().order_model, pk=order_id)

    pdf, response = pdf_response('packing-slip-%09d' % order.id)
    plata.reporting.order.packing_slip_pdf(pdf, order)
    return response

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.core.urlresolvers import NoReverseMatch, reverse
from django.utils.translation import ugettext_lazy as _

from plata.discount.models import AppliedDiscount
from plata.shop import models


class OrderItemInline(admin.TabularInline):
    model = models.OrderItem
    raw_id_fields = ('product',)
    extra = 0


class AppliedDiscountInline(admin.TabularInline):
    model = AppliedDiscount
    extra = 0


class OrderStatusInline(admin.TabularInline):
    model = models.OrderStatus
    extra = 0


class OrderAdmin(admin.ModelAdmin):
    date_hierarchy = 'created'
    fieldsets = (
        (None, {
            'fields': (
                'created', 'confirmed', 'user', 'email',
                'language_code', 'status'),
        }),
        (_('Billing address'), {
            'fields': models.Order.address_fields('billing_'),
        }),
        (_('Shipping address'), {
            'fields': (
                ['shipping_same_as_billing']
                + models.Order.address_fields('shipping_')),
        }),
        (_('Order items'), {
            'fields': ('items_subtotal', 'items_discount', 'items_tax'),
        }),
        (_('Shipping'), {
            'fields': ('shipping_cost', 'shipping_discount', 'shipping_tax'),
        }),
        (_('Total'), {
            'fields': ('currency', 'total', 'paid'),
        }),
        (_('Additional fields'), {
            'fields': ('notes', 'data'),
        }),
    )
    inlines = [OrderItemInline, AppliedDiscountInline, OrderStatusInline]
    list_display = (
        'admin_order_id', 'created', 'user', 'status', 'total',
        'balance_remaining', 'admin_is_paid', 'additional_info')
    list_filter = ('status',)
    ordering = ['-created']
    raw_id_fields = ('user',)
    readonly_fields = ('status',)
    search_fields = (
        ['_order_id', 'email', 'total', 'notes']
        + models.Order.address_fields('billing_')
        + models.Order.address_fields('shipping_'))

    def admin_is_paid(self, instance):
        return not instance.balance_remaining
    admin_is_paid.short_description = _('is paid')
    admin_is_paid.boolean = True

    def admin_order_id(self, instance):
        return instance.order_id
    admin_order_id.short_description = _('order ID')
    admin_order_id.admin_order_field = '_order_id'

    def additional_info(self, instance):
        bits = []

        try:
            url = reverse(
                'plata_reporting_packing_slip_pdf',
                kwargs={'order_id': instance.id})
            bits.append(u'<a href="%s">%s</a>' % (url, _('Packing slip')))
        except NoReverseMatch:
            pass

        try:
            url = reverse(
                'plata_reporting_invoice_pdf',
                kwargs={'order_id': instance.id})
            bits.append(u'<a href="%s">%s</a>' % (url, _('Invoice')))
        except NoReverseMatch:
            pass

        return u', '.join(bits)
    additional_info.allow_tags = True
    additional_info.short_description = _('add. info')


class OrderPaymentAdmin(admin.ModelAdmin):
    date_hierarchy = 'timestamp'
    list_display = (
        'order', 'timestamp', 'currency', 'amount', 'status',
        'authorized', 'payment_module_key', 'notes_short')
    list_display_links = ('timestamp',)
    list_filter = ('status', 'payment_module_key')
    raw_id_fields = ('order',)
    search_fields = (
        'amount', 'payment_module', 'payment_method',
        'transaction_id', 'notes', 'data')

    notes_short = lambda self, obj: (
        obj.notes[:40] + '...' if len(obj.notes) > 50 else obj.notes)
    notes_short.short_description = _('notes')


admin.site.register(models.Order, OrderAdmin)
admin.site.register(models.OrderPayment, OrderPaymentAdmin)
admin.site.register(
    models.TaxClass,
    list_display=('name', 'rate', 'priority'),
    list_editable=('rate', 'priority'),
)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.contrib import auth

try:  # pragma: no cover
    from django.contrib.auth import get_user_model
    User = get_user_model()
except ImportError, e:
    from django.contrib.auth.models import User

from django.utils.translation import ugettext_lazy as _

from plata.shop import signals


class BaseCheckoutForm(forms.ModelForm):
    """
    Needs the request and the shop object as keyword argument
    """

    def __init__(self, *args, **kwargs):
        self.shop = kwargs.pop('shop')
        self.request = kwargs.pop('request')

        super(BaseCheckoutForm, self).__init__(*args, **kwargs)

    def clean(self):
        data = super(BaseCheckoutForm, self).clean()

        if data.get('email'):
            users = list(User.objects.filter(email=data.get('email')))

            if users:
                if self.request.user not in users:
                    if self.request.user.is_authenticated():
                        self._errors['email'] = self.error_class([
                            _('This e-mail address belongs to a different'
                                ' account.')])
                    else:
                        self._errors['email'] = self.error_class([
                            _('This e-mail address might belong to you, but'
                                ' we cannot know for sure because you are'
                                ' not authenticated yet.')])

        return data

    def save(self):
        """
        Save the order, create or update the contact information
        (if available) and return the saved order instance
        """
        order = super(BaseCheckoutForm, self).save(commit=False)
        contact = self.shop.contact_from_user(self.request.user)

        if contact:
            order.user = contact.user
        elif self.request.user.is_authenticated():
            order.user = self.request.user

        if (self.cleaned_data.get('create_account') and not contact) or (
                not contact and self.request.user.is_authenticated()):
            password = None
            email = self.cleaned_data.get('email')

            if not self.request.user.is_authenticated():
                password = User.objects.make_random_password()
                params = {'email': email, 'password': password}
                if getattr(User, 'USERNAME_FIELD', 'username') == 'username':
                    params['username'] = email[:30]  # FIXME
                user = User.objects.create_user(**params)
                user = auth.authenticate(username=email, password=password)
                auth.login(self.request, user)
            else:
                user = self.request.user

            contact = self.shop.contact_model(user=user)
            order.user = user

            signals.contact_created.send(
                sender=self.shop,
                user=user,
                contact=contact,
                password=password,
                request=self.request)

        order.save()

        if contact:
            contact.update_from_order(order, request=self.request)
            contact.save()

        return order


class DiscountForm(forms.Form):
    code = forms.CharField(label=_('code'), max_length=30, required=False)

    def __init__(self, *args, **kwargs):
        self.order = kwargs.pop('order')
        self.discount_model = kwargs.pop('discount_model')
        request = kwargs.pop('request')  # noqa
        shop = kwargs.pop('shop')  # noqa

        super(DiscountForm, self).__init__(*args, **kwargs)

    def clean_code(self):
        code = self.cleaned_data.get('code')
        if not code:
            return self.cleaned_data

        try:
            discount = self.discount_model.objects.get(code=code)
        except self.discount_model.DoesNotExist:
            raise forms.ValidationError(_('This code does not validate'))

        discount.validate(self.order)
        self.cleaned_data['discount'] = discount
        return code

    def save(self):
        """
        Save the discount (or do nothing if no discount code has been given)
        """
        if 'discount' in self.cleaned_data:
            self.cleaned_data['discount'].add_to(self.order)


class ConfirmationForm(forms.Form):
    terms_and_conditions = forms.BooleanField(
        label=_('I accept the terms and conditions.'),
        required=True)

    def __init__(self, *args, **kwargs):
        self.order = kwargs.pop('order')
        self.request = kwargs.pop('request')
        self.shop = kwargs.pop('shop')
        self.payment_modules = self.shop.get_payment_modules(self.request)

        super(ConfirmationForm, self).__init__(*args, **kwargs)

        method_choices = [(m.key, m.name) for m in self.payment_modules]
        if len(method_choices) > 1:
            method_choices.insert(0, ('', '---------'))
        self.fields['payment_method'] = forms.ChoiceField(
            label=_('Payment method'), choices=method_choices,
        )

    def clean(self):
        data = super(ConfirmationForm, self).clean()
        self.order.validate(self.order.VALIDATE_ALL)
        return data

    def process_confirmation(self):
        """
        Process the successful order submission
        """
        self.order.update_status(self.order.CONFIRMED, 'Confirmation given')
        signals.order_confirmed.send(
            sender=self.shop,
            order=self.order,
            request=self.request)

        module = dict(
            (m.key, m) for m in self.payment_modules
            )[self.cleaned_data['payment_method']]

        return module.process_order_confirmed(self.request, self.order)

########NEW FILE########
__FILENAME__ = models
from decimal import Decimal
import logging
import re

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.urlresolvers import get_callable
from django.db import models
from django.db.models import F, ObjectDoesNotExist, Sum
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _

from django_countries import CountryField

import plata
from plata.fields import CurrencyField, JSONField


logger = logging.getLogger('plata.shop.order')


class TaxClass(models.Model):
    """
    Tax class, storing a tax rate

    TODO informational / advisory currency or country fields?
    """

    name = models.CharField(_('name'), max_length=100)
    rate = models.DecimalField(
        _('rate'), max_digits=10, decimal_places=2,
        help_text=_('Tax rate in percent.'))
    priority = models.PositiveIntegerField(
        _('priority'), default=0,
        help_text=_(
            'Used to order the tax classes in the administration interface.'))

    class Meta:
        ordering = ['-priority']
        verbose_name = _('tax class')
        verbose_name_plural = _('tax classes')

    def __unicode__(self):
        return self.name


class BillingShippingAddress(models.Model):
    """
    Abstract base class for all models storing a billing and a shipping
    address
    """

    ADDRESS_FIELDS = [
        'company', 'first_name', 'last_name', 'address',
        'zip_code', 'city', 'country']

    billing_company = models.CharField(
        _('company'), max_length=100, blank=True)
    billing_first_name = models.CharField(_('first name'), max_length=100)
    billing_last_name = models.CharField(_('last name'), max_length=100)
    billing_address = models.TextField(_('address'))
    billing_zip_code = models.CharField(
        plata.settings.PLATA_ZIP_CODE_LABEL, max_length=50)
    billing_city = models.CharField(_('city'), max_length=100)
    billing_country = CountryField(_('country'), blank=True)

    shipping_same_as_billing = models.BooleanField(
        _('shipping address equals billing address'),
        default=True)

    shipping_company = models.CharField(
        _('company'), max_length=100, blank=True)
    shipping_first_name = models.CharField(
        _('first name'), max_length=100, blank=True)
    shipping_last_name = models.CharField(
        _('last name'), max_length=100, blank=True)
    shipping_address = models.TextField(_('address'), blank=True)
    shipping_zip_code = models.CharField(
        plata.settings.PLATA_ZIP_CODE_LABEL, max_length=50, blank=True)
    shipping_city = models.CharField(_('city'), max_length=100, blank=True)
    shipping_country = CountryField(_('country'), blank=True)

    class Meta:
        abstract = True

    def addresses(self):
        """
        Return a ``dict`` containing a billing and a shipping address, taking
        into account the value of the ``shipping_same_as_billing`` flag
        """
        billing = dict(
            (f, getattr(self, 'billing_%s' % f)) for f in self.ADDRESS_FIELDS)

        if self.shipping_same_as_billing:
            shipping = billing
        else:
            shipping = dict(
                (f, getattr(self, 'shipping_%s' % f))
                for f in self.ADDRESS_FIELDS)

        return {'billing': billing, 'shipping': shipping}

    @classmethod
    def address_fields(cls, prefix=''):
        return ['%s%s' % (prefix, f) for f in cls.ADDRESS_FIELDS]


class Order(BillingShippingAddress):
    """The main order model. Used for carts and orders alike."""
    #: Order object is a cart.
    CART = 10
    #: Checkout process has started.
    CHECKOUT = 20
    #: Order has been confirmed, but it not (completely) paid for yet.
    CONFIRMED = 30
    #: Order has been completely paid for.
    PAID = 40
    #: Order has been completed. Plata itself never sets this state,
    #: it is only meant for use by the shop owners.
    COMPLETED = 50

    STATUS_CHOICES = (
        (CART, _('Is a cart')),
        (CHECKOUT, _('Checkout process started')),
        (CONFIRMED, _('Order has been confirmed')),
        (PAID, _('Order has been paid')),
        (COMPLETED, _('Order has been completed')),
        )

    created = models.DateTimeField(_('created'), default=timezone.now)
    confirmed = models.DateTimeField(_('confirmed'), blank=True, null=True)
    user = models.ForeignKey(
        getattr(settings, 'AUTH_USER_MODEL', 'auth.User'),
        blank=True,
        null=True,
        verbose_name=_('user'),
        related_name='orders'
    )
    language_code = models.CharField(
        _('language'), max_length=10, default='', blank=True)
    status = models.PositiveIntegerField(
        _('status'), choices=STATUS_CHOICES, default=CART)

    _order_id = models.CharField(_('order ID'), max_length=20, blank=True)
    email = models.EmailField(_('e-mail address'))

    currency = CurrencyField()
    price_includes_tax = models.BooleanField(
        _('price includes tax'),
        default=plata.settings.PLATA_PRICE_INCLUDES_TAX)

    items_subtotal = models.DecimalField(
        _('subtotal'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'))
    items_discount = models.DecimalField(
        _('items discount'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'))
    items_tax = models.DecimalField(
        _('items tax'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'))

    shipping_method = models.CharField(
        _('shipping method'),
        max_length=100, blank=True)
    shipping_cost = models.DecimalField(
        _('shipping cost'),
        max_digits=18, decimal_places=10, blank=True, null=True)
    shipping_discount = models.DecimalField(
        _('shipping discount'),
        max_digits=18, decimal_places=10, blank=True, null=True)
    shipping_tax = models.DecimalField(
        _('shipping tax'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'))

    total = models.DecimalField(
        _('total'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'))

    paid = models.DecimalField(
        _('paid'),
        max_digits=18, decimal_places=10, default=Decimal('0.00'),
        help_text=_('This much has been paid already.'))

    notes = models.TextField(_('notes'), blank=True)

    data = JSONField(
        _('data'), blank=True,
        help_text=_('JSON-encoded additional data about the order payment.'))

    class Meta:
        verbose_name = _('order')
        verbose_name_plural = _('orders')

    def __unicode__(self):
        return self.order_id

    def save(self, *args, **kwargs):
        """Sequential order IDs for completed orders."""
        if not self._order_id and self.status >= self.PAID:
            try:
                order = Order.objects.exclude(_order_id='').order_by(
                    '-_order_id')[0]
                latest = int(re.sub(r'[^0-9]', '', order._order_id))
            except (IndexError, ValueError):
                latest = 0

            self._order_id = 'O-%09d' % (latest + 1)
        super(Order, self).save(*args, **kwargs)
    save.alters_data = True

    @property
    def order_id(self):
        """
        Returns ``_order_id`` (if it has been set) or a generic ID for this
        order.
        """
        if self._order_id:
            return self._order_id
        return u'No. %d' % self.id

    def recalculate_total(self, save=True):
        """
        Recalculates totals, discounts, taxes.
        """

        items = list(self.items.all())
        shared_state = {}

        processor_classes = [
            get_callable(processor)
            for processor in plata.settings.PLATA_ORDER_PROCESSORS]

        for p in (cls(shared_state) for cls in processor_classes):
            p.process(self, items)

        if save:
            self.save()
            [item.save() for item in items]

    @property
    def subtotal(self):
        """
        Returns the order subtotal.
        """
        # TODO: What about shipping?
        return sum(
            (item.subtotal for item in self.items.all()),
            Decimal('0.00')).quantize(Decimal('0.00'))

    @property
    def discount(self):
        """
        Returns the discount total.
        """
        # TODO: What about shipping?
        return (
            sum(
                (item.subtotal for item in self.items.all()),
                Decimal('0.00')
            ) - sum(
                (item.discounted_subtotal for item in self.items.all()),
                Decimal('0.00')
            )
        ).quantize(Decimal('0.00'))

    @property
    def shipping(self):
        """
        Returns the shipping cost, with or without tax depending on this
        order's ``price_includes_tax`` field.
        """
        if self.price_includes_tax:
            if self.shipping_cost is None:
                return None

            return (
                self.shipping_cost
                - self.shipping_discount
                + self.shipping_tax)
        else:
            logger.error(
                'Shipping calculation with'
                ' PLATA_PRICE_INCLUDES_TAX=False is not implemented yet')
            raise NotImplementedError

    @property
    def tax(self):
        """
        Returns the tax total for this order, meaning tax on order items and
        tax on shipping.
        """
        return (self.items_tax + self.shipping_tax).quantize(Decimal('0.00'))

    @property
    def balance_remaining(self):
        """
        Returns the balance which needs to be paid by the customer to fully
        pay this order. This value is not necessarily the same as the order
        total, because there can be more than one order payment in principle.
        """
        return (self.total - self.paid).quantize(Decimal('0.00'))

    def is_paid(self):
        import warnings
        warnings.warn(
            'Order.is_paid() has been deprecated because its name is'
            ' misleading. Test for `order.status >= order.PAID` or'
            ' `not order.balance_remaining yourself.',
            DeprecationWarning, stacklevel=2)
        return self.balance_remaining <= 0

    #: This validator is always called; basic consistency checks such as
    #: whether the currencies in the order match should be added here.
    VALIDATE_BASE = 10
    #: A cart which fails the criteria added to the ``VALIDATE_CART`` group
    #: isn't considered a valid cart and the user cannot proceed to the
    #: checkout form. Stuff such as stock checking, minimal order total
    #: checking, or maximal items checking might be added here.
    VALIDATE_CART = 20
    #: This should not be used while registering a validator, it's mostly
    #: useful as an argument to :meth:`~plata.shop.models.Order.validate`
    #: when you want to run all validators.
    VALIDATE_ALL = 100

    VALIDATORS = {}

    @classmethod
    def register_validator(cls, validator, group):
        """
        Registers another order validator in a validation group

        A validator is a callable accepting an order (and only an order).

        There are several types of order validators:

        - Base validators are always called
        - Cart validators: Need to validate for a valid cart
        - Checkout validators: Need to validate in the checkout process
        """

        cls.VALIDATORS.setdefault(group, []).append(validator)

    def validate(self, group):
        """
        Validates this order

        The argument determines which order validators are called:

        - ``Order.VALIDATE_BASE``
        - ``Order.VALIDATE_CART``
        - ``Order.VALIDATE_CHECKOUT``
        - ``Order.VALIDATE_ALL``
        """

        for g in sorted(g for g in self.VALIDATORS.keys() if g <= group):
            for validator in self.VALIDATORS[g]:
                validator(self)

    def is_confirmed(self):
        """
        Returns ``True`` if this order has already been confirmed and
        therefore cannot be modified anymore.
        """
        return self.status >= self.CONFIRMED

    def modify_item(self, product, relative=None, absolute=None,
                    recalculate=True, data=None, item=None, force_new=False):
        """
        Updates order with the given product

        - ``relative`` or ``absolute``: Add/subtract or define order item
          amount exactly
        - ``recalculate``: Recalculate order after cart modification
          (defaults to ``True``)
        - ``data``: Additional data for the order item; replaces the contents
          of the JSON field if it is not ``None``. Pass an empty dictionary
          if you want to reset the contents.
        - ``item``: The order item which should be modified. Will be
          automatically detected using the product if unspecified.
        - ``force_new``: Force the creation of a new order item, even if the
          product exists already in the cart (especially useful if the
          product is configurable).

        Returns the ``OrderItem`` instance; if quantity is zero, the order
        item instance is deleted, the ``pk`` attribute set to ``None`` but
        the order item is returned anyway.
        """

        assert (relative is None) != (absolute is None),\
            'One of relative or absolute must be provided.'
        assert not (force_new and item),\
            'Cannot set item and force_new at the same time.'

        if self.is_confirmed():
            raise ValidationError(
                _('Cannot modify order once it has been confirmed.'),
                code='order_sealed')

        if item is None and not force_new:
            try:
                item = self.items.get(product=product)
            except self.items.model.DoesNotExist:
                # Ok, product does not exist in cart yet.
                pass
            except self.items.model.MultipleObjectsReturned:
                # Oops. Product already exists several times. Stay on the
                # safe side and add a new one instead of trying to modify
                # another.
                if not force_new:
                    raise ValidationError(
                        _(
                            'The product already exists several times in the'
                            ' cart, and neither item nor force_new were'
                            ' given.'),
                        code='multiple')

        if item is None:
            item = self.items.model(
                order=self,
                product=product,
                quantity=0,
                currency=self.currency,
            )

        if relative is not None:
            item.quantity += relative
        else:
            item.quantity = absolute

        if item.quantity > 0:
            try:
                price = product.get_price(
                    currency=self.currency,
                    orderitem=item)
            except ObjectDoesNotExist:
                logger.error(
                    u'No price could be found for %s with currency %s' % (
                        product, self.currency))

                raise ValidationError(
                    _('The price could not be determined.'),
                    code='unknown_price')

            if data is not None:
                item.data = data

            price.handle_order_item(item)
            product.handle_order_item(item)
            item.save()
        else:
            if item.pk:
                item.delete()
                item.pk = None

        if recalculate:
            self.recalculate_total()

            # Reload item instance from DB to preserve field values
            # changed in recalculate_total
            if item.pk:
                item = self.items.get(pk=item.pk)

        try:
            self.validate(self.VALIDATE_BASE)
        except ValidationError:
            if item.pk:
                item.delete()
            raise

        return item

    @property
    def discount_remaining(self):
        """Remaining discount amount excl. tax"""
        return self.applied_discounts.remaining()

    def update_status(self, status, notes):
        """
        Update the order status
        """

        if status >= Order.CHECKOUT:
            if not self.items.count():
                raise ValidationError(
                    _('Cannot proceed to checkout without order items.'),
                    code='order_empty')

        logger.info('Promoting %s to status %s' % (self, status))

        instance = OrderStatus(
            order=self,
            status=status,
            notes=notes)
        instance.save()

    def reload(self):
        """
        Return this order instance, reloaded from the database

        Used f.e. inside the payment processors when adding new payment
        records etc.
        """

        return self.__class__._default_manager.get(pk=self.id)

    def items_in_order(self):
        """
        Returns the item count in the order

        This is different from ``order.items.count()`` because it counts items,
        not distinct products.
        """
        return self.items.aggregate(q=Sum('quantity'))['q'] or 0


def validate_order_currencies(order):
    """Check whether order contains more than one or an invalid currency"""
    currencies = set(order.items.values_list('currency', flat=True))
    if (currencies
            and (len(currencies) > 1 or order.currency not in currencies)):
        raise ValidationError(
            _('Order contains more than one currency.'),
            code='multiple_currency')


Order.register_validator(validate_order_currencies, Order.VALIDATE_BASE)


class OrderItem(models.Model):
    """Single order line item"""

    order = models.ForeignKey(Order, related_name='items')
    product = models.ForeignKey(
        plata.settings.PLATA_SHOP_PRODUCT,
        verbose_name=_('product'),
        blank=True, null=True, on_delete=models.SET_NULL)

    name = models.CharField(_('name'), max_length=100, blank=True)
    sku = models.CharField(_('SKU'), max_length=100, blank=True)

    quantity = models.IntegerField(_('quantity'))

    currency = CurrencyField()
    _unit_price = models.DecimalField(
        _('unit price'),
        max_digits=18, decimal_places=10,
        help_text=_('Unit price excl. tax'))
    _unit_tax = models.DecimalField(
        _('unit tax'),
        max_digits=18, decimal_places=10)

    tax_rate = models.DecimalField(
        _('tax rate'),
        max_digits=10, decimal_places=2)
    tax_class = models.ForeignKey(
        TaxClass, verbose_name=_('tax class'),
        blank=True, null=True, on_delete=models.SET_NULL)

    is_sale = models.BooleanField(_('is sale'))

    _line_item_price = models.DecimalField(
        _('line item price'),
        max_digits=18, decimal_places=10, default=0,
        help_text=_('Line item price excl. tax'))
    _line_item_discount = models.DecimalField(
        _('line item discount'),
        max_digits=18, decimal_places=10,
        blank=True, null=True,
        help_text=_('Discount excl. tax'))

    _line_item_tax = models.DecimalField(
        _('line item tax'),
        max_digits=18, decimal_places=10, default=0)

    data = JSONField(
        _('data'), blank=True,
        help_text=_('JSON-encoded additional data about the order payment.'))

    class Meta:
        ordering = ('product',)
        verbose_name = _('order item')
        verbose_name_plural = _('order items')

    def __unicode__(self):
        return _(u'%(quantity)s of %(name)s') % {
            'quantity': self.quantity,
            'name': self.name,
        }

    @property
    def unit_price(self):
        if self.order.price_includes_tax:
            return self._unit_price + self._unit_tax
        return self._unit_price

    @property
    def line_item_discount_excl_tax(self):
        return self._line_item_discount or 0

    @property
    def line_item_discount_incl_tax(self):
        return self.line_item_discount_excl_tax * (1 + self.tax_rate / 100)

    @property
    def line_item_discount(self):
        if self.order.price_includes_tax:
            return self.line_item_discount_incl_tax
        else:
            return self.line_item_discount_excl_tax

    @property
    def subtotal(self):
        return self.unit_price * self.quantity

    @property
    def discounted_subtotal_excl_tax(self):
        return self._line_item_price - (self._line_item_discount or 0)

    @property
    def discounted_subtotal_incl_tax(self):
        return self.discounted_subtotal_excl_tax + self._line_item_tax

    @property
    def discounted_subtotal(self):
        if self.order.price_includes_tax:
            return self.discounted_subtotal_incl_tax
        else:
            return self.discounted_subtotal_excl_tax


class OrderStatus(models.Model):
    """
    Order status

    Stored in separate model so that the order status changes stay
    visible for analysis after the fact.
    """

    order = models.ForeignKey(Order, related_name='statuses')
    created = models.DateTimeField(_('created'), default=timezone.now)
    status = models.PositiveIntegerField(
        _('status'), max_length=20, choices=Order.STATUS_CHOICES)
    notes = models.TextField(_('notes'), blank=True)

    class Meta:
        ordering = ('created', 'id')
        verbose_name = _('order status')
        verbose_name_plural = _('order statuses')

    def __unicode__(self):
        return _(u'Status %(status)s for %(order)s') % {
            'status': self.get_status_display(),
            'order': self.order,
        }

    def save(self, *args, **kwargs):
        super(OrderStatus, self).save(*args, **kwargs)
        self.order.status = self.status
        if self.status == Order.CONFIRMED:
            self.order.confirmed = timezone.now()
        elif self.status > Order.CONFIRMED and not self.order.confirmed:
            self.order.confirmed = timezone.now()
        elif self.status < Order.CONFIRMED:
            # Ensure that the confirmed date is not set
            self.order.confirmed = None
        self.order.save()
    save.alters_data = True


class OrderPaymentManager(models.Manager):
    def pending(self):
        return self.filter(status=self.model.PENDING)

    def authorized(self):
        return self.filter(authorized__isnull=False)


class OrderPayment(models.Model):
    """
    Order payment

    Stores additional data from the payment interface for analysis
    and accountability.
    """

    PENDING = 10
    PROCESSED = 20
    AUTHORIZED = 30

    STATUS_CHOICES = (
        (PENDING, _('pending')),
        (PROCESSED, _('processed')),
        (AUTHORIZED, _('authorized')),
    )

    order = models.ForeignKey(
        Order, verbose_name=_('order'), related_name='payments')
    timestamp = models.DateTimeField(_('timestamp'), default=timezone.now)
    status = models.PositiveIntegerField(
        _('status'), choices=STATUS_CHOICES, default=PENDING)

    currency = CurrencyField()
    amount = models.DecimalField(_('amount'), max_digits=10, decimal_places=2)
    payment_module_key = models.CharField(
        _('payment module key'),
        max_length=20,
        help_text=_(
            'Machine-readable identifier for the payment module used.'))
    payment_module = models.CharField(
        _('payment module'), max_length=50,
        blank=True,
        help_text=_('For example \'Cash on delivery\', \'PayPal\', ...'))
    payment_method = models.CharField(
        _('payment method'), max_length=50,
        blank=True,
        help_text=_(
            'For example \'MasterCard\', \'VISA\' or some other card.'))
    transaction_id = models.CharField(
        _('transaction ID'), max_length=50,
        blank=True,
        help_text=_(
            'Unique ID identifying this payment in the foreign system.'))

    authorized = models.DateTimeField(
        _('authorized'), blank=True, null=True,
        help_text=_('Point in time when payment has been authorized.'))

    notes = models.TextField(_('notes'), blank=True)

    data = JSONField(
        _('data'), blank=True,
        help_text=_('JSON-encoded additional data about the order payment.'))

    class Meta:
        ordering = ('-timestamp',)
        verbose_name = _('order payment')
        verbose_name_plural = _('order payments')

    objects = OrderPaymentManager()

    def __unicode__(self):
        return _(
            u'%(authorized)s of %(currency)s %(amount).2f for %(order)s'
        ) % {
            'authorized': (
                self.authorized and _(u'Authorized') or _(u'Not authorized')),
            'currency': self.currency,
            'amount': self.amount,
            'order': self.order,
        }

    def _recalculate_paid(self):
        paid = OrderPayment.objects.authorized().filter(
            order=self.order_id,
            currency=F('order__currency'),
        ).aggregate(total=Sum('amount'))['total'] or 0

        Order.objects.filter(id=self.order_id).update(paid=paid)

    def save(self, *args, **kwargs):
        super(OrderPayment, self).save(*args, **kwargs)
        self._recalculate_paid()

        if self.currency != self.order.currency:
            self.order.notes += (
                u'\n' + _('Currency of payment %s does not match.') % self)
            self.order.save()
    save.alters_data = True

    def delete(self, *args, **kwargs):
        super(OrderPayment, self).delete(*args, **kwargs)
        self._recalculate_paid()
    delete.alters_data = True


class PriceBase(models.Model):
    """
    Price for a given product, currency, tax class and time period

    Prices should not be changed or deleted but replaced by more recent
    prices. (Deleting old prices does not hurt, but the price history cannot
    be reconstructed anymore if you'd need it.)

    The concrete implementation needs to provide a foreign key to the
    product model.
    """

    class Meta:
        abstract = True
        ordering = ['-id']
        verbose_name = _('price')
        verbose_name_plural = _('prices')

    currency = CurrencyField()
    _unit_price = models.DecimalField(
        _('unit price'),
        max_digits=18, decimal_places=10)
    tax_included = models.BooleanField(
        _('tax included'),
        help_text=_('Is tax included in given unit price?'),
        default=plata.settings.PLATA_PRICE_INCLUDES_TAX)
    tax_class = models.ForeignKey(
        TaxClass, verbose_name=_('tax class'), related_name='+')

    def __unicode__(self):
        return u'%s %.2f' % (self.currency, self.unit_price)

    def __cmp__(self, other):
        return int(
            (self.unit_price_excl_tax - other.unit_price_excl_tax) * 100)

    def __hash__(self):
        return int(self.unit_price_excl_tax * 100)

    def handle_order_item(self, item):
        """
        Set price data on the ``OrderItem`` passed
        """
        item._unit_price = self.unit_price_excl_tax
        item._unit_tax = self.unit_tax
        item.tax_rate = self.tax_class.rate
        item.tax_class = self.tax_class
        item.is_sale = False  # Hardcoded; override in your own price class

    @property
    def unit_tax(self):
        return self.unit_price_excl_tax * (self.tax_class.rate / 100)

    @property
    def unit_price_incl_tax(self):
        if self.tax_included:
            return self._unit_price
        return self._unit_price * (1 + self.tax_class.rate / 100)

    @property
    def unit_price_excl_tax(self):
        if not self.tax_included:
            return self._unit_price
        return self._unit_price / (1 + self.tax_class.rate / 100)

    @property
    def unit_price(self):
        # TODO Fix this. We _should_ use shop.price_includes_tax here,
        # but there's no request and no order around...
        return self.unit_price_incl_tax

########NEW FILE########
__FILENAME__ = notifications
"""
Even though these shop signal handlers might be useful you might be better
of writing your own handlers for the three important signals:

- ``contact_created``: A new contact has been created during the checkout
  process
- ``order_confirmed``: The order has been confirmed, a payment method has
  been selected
- ``order_paid``: The order is fully paid

A real-world example follows::

    from django.utils.translation import activate

    from plata.shop import notifications, signals as shop_signals


    class EmailHandler(notifications.BaseHandler):
        ALWAYS = ['shopadmin@example.com']
        SHIPPING = ['warehouse@example.com']

        def __call__(self, sender, order, **kwargs):
            cash_on_delivery = False
            try:
                if (order.payments.all()[0].payment_module_key == 'cod'):
                    cash_on_delivery = True
            except:
                pass

            if order.language_code:
                activate(order.language_code)

            invoice_message = self.create_email_message(
                'plata/notifications/order_paid.txt',
                order=order,
                **kwargs)
            invoice_message.attach(order.order_id + '.pdf',
                self.invoice_pdf(order), 'application/pdf')
            invoice_message.to.append(order.email)
            invoice_message.bcc.extend(self.ALWAYS)

            packing_slip_message = self.create_email_message(
                'plata/notifications/packing_slip.txt',
                order=order,
                **kwargs)
            packing_slip_message.attach(
                order.order_id + '-LS.pdf',
                self.packing_slip_pdf(order),
                'application/pdf')
            packing_slip_message.to.extend(self.ALWAYS)

            if cash_on_delivery:
                invoice_message.bcc.extend(self.SHIPPING)
            else:
                packing_slip_message.to.extend(self.SHIPPING)

            invoice_message.send()
            packing_slip_message.send()

    shop_signals.contact_created.connect(
        notifications.ContactCreatedHandler(),
        weak=False)
    shop_signals.order_paid.connect(
        EmailHandler(),
        weak=False)
"""

from __future__ import with_statement

import contextlib
from io import BytesIO

from django.contrib.sites.models import get_current_site
from django.core.mail import EmailMessage
from django.template.loader import render_to_string
from django.utils.translation import activate


class BaseHandler(object):
    def invoice_pdf(self, order):
        from pdfdocument.document import PDFDocument
        from plata.reporting.order import invoice_pdf

        with contextlib.closing(BytesIO()) as content:
            pdf = PDFDocument(content)
            invoice_pdf(pdf, order)
            return content.getvalue()

    def packing_slip_pdf(self, order):
        from pdfdocument.document import PDFDocument
        from plata.reporting.order import packing_slip_pdf

        with contextlib.closing(BytesIO()) as content:
            pdf = PDFDocument(content)
            packing_slip_pdf(pdf, order)
            return content.getvalue()

    def context(self, ctx, **kwargs):
        request = ctx.get('request')
        if request is not None:
            ctx.update({
                'site': get_current_site(request),
            })
        ctx.update(kwargs)
        return ctx

    def create_email_message(self, template_name, **kwargs):
        email = render_to_string(
            template_name, self.context(kwargs)).splitlines()
        return EmailMessage(subject=email[0], body=u'\n'.join(email[2:]))


class EmailHandler(BaseHandler):
    def __init__(self, always_to=None, always_bcc=None):
        self.always_to = always_to
        self.always_bcc = always_bcc

    def __call__(self, sender, **kwargs):
        email = self.message(sender, **kwargs)

        if self.always_to:
            email.to += list(self.always_to)
        if self.always_bcc:
            email.bcc += list(self.always_bcc)

        # TODO log this, or send a replacement email to the shop owner
        email.send(fail_silently=True)


class ContactCreatedHandler(EmailHandler):
    """
    Send an e-mail message to a newly created contact, optionally BCC'ing
    the addresses passed as ``always_bcc`` upon handler initialization.

    Usage::

        signals.contact_created.connect(
            ContactCreatedHandler(),
            weak=False)

    or::

        signals.contact_created.connect(
            ContactCreatedHandler(always_bcc=['owner@example.com']),
            weak=False)
    """

    def message(self, sender, contact, **kwargs):
        message = self.create_email_message(
            'plata/notifications/contact_created.txt',
            contact=contact,
            **kwargs)
        message.to.append(contact.user.email)
        return message


class SendInvoiceHandler(EmailHandler):
    """
    Send an e-mail with attached invoice to the customer after successful
    order completion, optionally BCC'ing the addresses passed as
    ``always_bcc`` to the handler upon initialization.

    Usage::

        signals.order_paid.connect(
            SendInvoiceHandler(always_bcc=['owner@example.com']),
            weak=False)
    """

    def message(self, sender, order, **kwargs):
        if order.language_code:
            activate(order.language_code)

        message = self.create_email_message(
            'plata/notifications/order_paid.txt',
            order=order,
            **kwargs)

        message.to.append(order.email)
        message.attach(
            'invoice-%09d.pdf' % order.id,
            self.invoice_pdf(order),
            'application/pdf')
        return message


class SendPackingSlipHandler(EmailHandler):
    """
    Send an e-mail with attached packing slip to the addresses specified upon
    handler initialization. You should pass at least one address in either
    the ``always_to`` or the ``always_bcc`` argument, or else the e-mail
    will go nowhere.

    Usage::

        signals.order_paid.connect(
            SendPackingSlipHandler(always_to=['warehouse@example.com']),
            weak=False)
    """

    def message(self, sender, order, **kwargs):
        if order.language_code:
            activate(order.language_code)

        message = self.create_email_message(
            'plata/notifications/packing_slip.txt',
            order=order,
            **kwargs)
        message.attach(
            'packing-slip-%09d.pdf' % order.id,
            self.packing_slip_pdf(order),
            'application/pdf')
        return message


"""
from plata.shop import notifications, signals as shop_signals

shop_signals.contact_created.connect(
    notifications.ContactCreatedHandler(always_bcc=[]),
    weak=False)
shop_signals.order_paid.connect(
    notifications.SendInvoiceHandler(always_bcc=[]),
    weak=False)
shop_signals.order_paid.connect(
    notifications.SendPackingSlipHandler(
        always_to=[],
        always_bcc=[]),
    weak=False)
"""

########NEW FILE########
__FILENAME__ = processors
from decimal import Decimal, ROUND_HALF_UP

import plata
from plata.discount.models import DiscountBase


class ProcessorBase(object):
    """
    Order processor class base. Offers helper methods for order total
    aggregation and tax calculation.
    """

    def __init__(self, shared_state):
        self.shared_state = shared_state

    def split_cost(self, cost_incl_tax, tax_rate):
        """Split a cost incl. tax into the part excl. tax and the tax"""

        cost_incl_tax, tax_rate = Decimal(cost_incl_tax), Decimal(tax_rate)

        cost_excl_tax = cost_incl_tax / (1 + tax_rate / 100)
        return cost_excl_tax, cost_incl_tax - cost_excl_tax

    def add_tax_details(self, tax_details, tax_rate, price, discount,
                        tax_amount):
        """
        Add tax details grouped by tax_rate. Especially useful if orders
        potentially use more than one tax class. These values are not used
        for the order total calculation -- they are only needed to show the
        tax amount for different tax rates if this is necessary for your
        invoices.

        - ``tax_details``: The tax details dict, most often stored as
          ``order.data['tax_details'] = tax_details.items()``
        - ``tax_rate``: The tax rate of the current entry
        - ``price``: The price excl. tax
        - ``discount``: The discount amount (will be subtracted from the
          price before applying the tax)
        - ``tax_amount``: The exact amount; a bit redundant because this
          could be calculated using the values above as well

        See the taxes documentation or the standard invoice PDF generation
        code if you need to know more about the use of these values.
        """

        zero = Decimal('0.00')
        discount = discount or zero

        row = tax_details.setdefault(tax_rate, {
            'prices': zero,
            'discounts': zero,
            'tax_rate': tax_rate,
            'tax_amount': zero,
            'total': zero,
            })
        row['prices'] += price
        row['discounts'] += discount
        row['tax_amount'] += tax_amount

        row['total'] += price - discount + tax_amount

    def set_processor_value(self, group, key, value):
        self.shared_state.setdefault(group, {})[key] = value

    def get_processor_value(self, group, key=None):
        dic = self.shared_state.get(group, {})
        if key:
            return dic.get(key)
        return dic

    def process(self, order, items):
        """
        This is the method which must be implemented in order processor
        classes.
        """
        raise NotImplementedError  # pragma: no cover


class InitializeOrderProcessor(ProcessorBase):
    """
    Zero out all relevant order values and calculate line item prices
    excl. tax.
    """

    def process(self, order, items):
        order.items_subtotal = Decimal('0.00')
        order.items_tax = Decimal('0.00')
        order.items_discount = Decimal('0.00')

        for item in items:
            # Recalculate item stuff
            item._line_item_price = item.quantity * item._unit_price
            item._line_item_discount = Decimal('0.00')


class DiscountProcessor(ProcessorBase):
    """
    Apply all discounts which do not act as a means of payment but instead
    act on the subtotal
    """

    def process(self, order, items):
        remaining = Decimal('0.00')

        for applied in order.applied_discounts.exclude(
                type=DiscountBase.MEANS_OF_PAYMENT):
            applied.apply(order, items)
            remaining += applied.remaining

        discounts = order.data.get('discounts', {})
        discounts['remaining_subtotal'] = remaining
        order.data['discounts'] = discounts


class MeansOfPaymentDiscountProcessor(ProcessorBase):
    """
    Apply all discounts which act as a means of payment.
    """

    def process(self, order, items):
        remaining = Decimal('0.00')

        for applied in order.applied_discounts.filter(
                type=DiscountBase.MEANS_OF_PAYMENT):
            applied.apply(order, items)
            remaining += applied.remaining

        discounts = order.data.get('discounts', {})
        discounts['remaining_means_of_payment'] = remaining
        order.data['discounts'] = discounts


class TaxProcessor(ProcessorBase):
    """
    Calculate taxes for every line item and aggregate tax details.
    """

    def process(self, order, items):
        tax_details = {}

        for item in items:
            taxable = item._line_item_price - (item._line_item_discount or 0)
            item._line_item_tax = (taxable * item.tax_rate / 100).quantize(
                Decimal('0.0000000000'))

            self.add_tax_details(
                tax_details,
                item.tax_rate,
                item._line_item_price,
                item._line_item_discount,
                item._line_item_tax,
                )

        order.data['tax_details'] = tax_details.items()


class ItemSummationProcessor(ProcessorBase):
    """
    Sum up line item prices, discounts and taxes.
    """

    def process(self, order, items):
        for item in items:
            order.items_subtotal += item._line_item_price
            order.items_discount += item._line_item_discount or 0
            order.items_tax += item._line_item_tax

        self.set_processor_value(
            'total', 'items',
            order.items_subtotal - order.items_discount + order.items_tax)


class ZeroShippingProcessor(ProcessorBase):
    """
    Set shipping costs to zero.
    """

    def process(self, order, items):
        order.shipping_cost = Decimal('0.00')
        order.shipping_discount = Decimal('0.00')
        order.shipping_tax = Decimal('0.00')

        # Not strictly necessary
        self.set_processor_value('total', 'shipping', 0)


class FixedAmountShippingProcessor(ProcessorBase):
    """
    Set shipping costs to a fixed value. Uses ``PLATA_SHIPPING_FIXEDAMOUNT``.
    If you have differing needs you should probably implement your own
    shipping processor (and propose it for inclusion if you like) instead
    of extending this one.

    ::

        PLATA_SHIPPING_FIXEDAMOUNT = {
            'cost': Decimal('8.00'),
            'tax': Decimal('19.6'),
            }
    """

    def process(self, order, items):
        cost = plata.settings.PLATA_SHIPPING_FIXEDAMOUNT['cost']
        tax = plata.settings.PLATA_SHIPPING_FIXEDAMOUNT['tax']

        order.shipping_cost, __ = self.split_cost(cost, tax)
        order.shipping_discount = min(
            order.discount_remaining,
            order.shipping_cost,
        )
        order.shipping_tax = tax / 100 * (
            order.shipping_cost - order.shipping_discount)

        self.set_processor_value(
            'total', 'shipping',
            order.shipping_cost - order.shipping_discount
            + order.shipping_tax)

        tax_details = dict(order.data.get('tax_details', []))
        self.add_tax_details(
            tax_details, tax, order.shipping_cost,
            order.shipping_discount, order.shipping_tax)
        order.data['tax_details'] = tax_details.items()


class ApplyRemainingDiscountToShippingProcessor(ProcessorBase):
    """
    Apply the remaining discount to the shipping (if shipping is non-zero
    and there are any remaining discounts left)
    """

    def process(self, order, items):
        raise NotImplementedError(
            "ApplyRemainingDiscountToShippingProcessor is not implemented yet"
        )


class OrderSummationProcessor(ProcessorBase):
    """
    Sum up order total by adding up items and shipping totals.
    """

    def process(self, order, items):
        """
        The value must be quantized here, because otherwise f.e. the payment
        modules will be susceptible to rounding errors giving f.e. missing
        payments of 0.01 units.
        """

        total = sum(
            self.get_processor_value('total').values(),
            Decimal('0.00'),
        )

        order.total = total.quantize(Decimal('0.00'), rounding=ROUND_HALF_UP)

########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal

#: Emitted upon contact creation. Receives the user and contact instance
#: and the new password in cleartext.
contact_created = Signal(
    providing_args=['user', 'contact', 'password', 'request'],
)

#: Emitted upon order confirmation. Receives an order instance.
order_confirmed = Signal(
    providing_args=['order', 'request'],
)

#: Emitted when an order has been completely paid for. Receives the order
#: and payment instances and the remaining discount amount excl. tax, if
#: there is any.
order_paid = Signal(
    providing_args=['order', 'payment', 'remaining_discount', 'request'],
)

########NEW FILE########
__FILENAME__ = plata_tags
from django import forms, template
from django.db.models import ObjectDoesNotExist
from django.template.loader import render_to_string

import plata
import plata.context_processors


register = template.Library()


@register.simple_tag(takes_context=True)
def load_plata_context(context):
    """
    Conditionally run plata's context processor using {% load_plata_context %}

    Rather than having the overheads involved in globally adding it to
    TEMPLATE_CONTEXT_PROCESSORS.
    """
    if not 'plata' in context:
        context.update(
            plata.context_processors.plata_context(context['request'])
        )
    return ''


@register.filter
def quantity_ordered(product, order):
    """
    e.g. {% if product|quantity_ordered:plata.order > 0 %} ... {% endif %}
    """
    try:
        return order.items.values('quantity').get(product=product)['quantity']
    except ObjectDoesNotExist:
        return 0


def _type_class(item):
    if isinstance(item.field.widget, forms.CheckboxInput):
        return 'checkbox'
    elif isinstance(item.field.widget, forms.DateInput):
        return 'date'
    elif isinstance(item.field.widget, (
            forms.RadioSelect, forms.CheckboxSelectMultiple)):
        return 'list'
    return ''


@register.simple_tag
def form_items(form):
    """
    Render all form items::

        {% form_items form %}
    """
    return u''.join(render_to_string('_form_item.html', {
        'item': field,
        'is_checkbox': isinstance(field.field.widget, forms.CheckboxInput),
        'type_class': _type_class(field),
        }) for field in form)


@register.inclusion_tag('_form_item.html')
def form_item(item, additional_classes=None):
    """
    Helper for easy displaying of form items::

        {% for field in form %}{% form_item field %}{% endfor %}
    """

    return {
        'item': item,
        'additional_classes': additional_classes,
        'is_checkbox': isinstance(item.field.widget, forms.CheckboxInput),
        'type_class': _type_class(item),
        }


@register.inclusion_tag('_form_item_plain.html')
def form_item_plain(item, additional_classes=None):
    """
    Helper for easy displaying of form items without any additional
    tags (table cells or paragraphs) or labels::

        {% form_item_plain field %}
    """

    return {
        'item': item,
        'additional_classes': additional_classes,
        'is_checkbox': isinstance(item.field.widget, forms.CheckboxInput),
        'type_class': _type_class(item),
        }


@register.tag
def form_errors(parser, token):
    """
    Show all form and formset errors::

        {% form_errors form formset1 formset2 %}

    Silently ignores non-existant variables.
    """

    tokens = token.split_contents()

    return FormErrorsNode(*tokens[1:])


class FormErrorsNode(template.Node):
    def __init__(self, *items):
        self.items = [template.Variable(item) for item in items]

    def render(self, context):
        items = []
        for item in self.items:
            try:
                var = item.resolve(context)
                if isinstance(var, dict):
                    items.extend(var.values())
                elif isinstance(var, (list, tuple)):
                    items.extend(var)
                else:
                    items.append(var)
            except template.VariableDoesNotExist:
                # We do not care too much
                pass

        errors = False

        form_list = []
        formset_list = []

        for i in items:
            if isinstance(i, forms.BaseForm):
                form_list.append(i)
            else:
                formset_list.append(i)

            if (getattr(i, 'errors', None)
                    or getattr(i, 'non_field_errors', lambda: None)()):
                errors = True

        if not errors:
            return u''

        return render_to_string('_form_errors.html', {
            'forms': form_list,
            'formsets': formset_list,
            'errors': True,
            })

########NEW FILE########
__FILENAME__ = views
from functools import wraps
import logging

from django.conf.urls import include, patterns, url
from django.contrib import auth, messages
from django.contrib.auth.forms import AuthenticationForm
from django.core.exceptions import ValidationError
from django.core.urlresolvers import get_callable, reverse
from django.forms.models import ModelForm, inlineformset_factory
from django.http import HttpResponseRedirect
from django.shortcuts import render
from django.utils.translation import get_language, ugettext as _

import plata
from plata.shop import forms as shop_forms


logger = logging.getLogger('plata.shop.views')


def cart_not_empty(order, shop, request, **kwargs):
    """Redirect to cart if later in checkout process and cart empty"""
    if not order or not order.items.count():
        messages.warning(request, _('Cart is empty.'))
        return shop.redirect('plata_shop_cart')


def order_already_confirmed(order, shop, request, **kwargs):
    """
    Redirect to confirmation or already paid view if the order is already
    confirmed
    """
    if order and order.status >= order.CONFIRMED:
        if not order.balance_remaining:
            return shop.redirect('plata_order_success')
        messages.warning(request, _(
            'You have already confirmed this order earlier, but it is not'
            ' fully paid for yet.'))
        return HttpResponseRedirect(
            shop.reverse_url('plata_shop_confirmation') + '?confirmed=1')


def order_cart_validates(order, shop, request, **kwargs):
    """
    Redirect to cart if stock is insufficient and display an error message
    """
    if request.method != 'GET':
        return

    try:
        order.validate(order.VALIDATE_CART)
    except ValidationError, e:
        for message in e.messages:
            messages.error(request, message)
        return HttpResponseRedirect(
            shop.reverse_url('plata_shop_cart') + '?e=1')


def order_cart_warnings(order, shop, request, **kwargs):
    """Show warnings in cart, but don't redirect (meant as a replacement for
    ``order_cart_validates``, but usable on the cart view itself)"""
    if request.method != 'GET' or request.GET.get('e') or not order:
        return

    try:
        order.validate(order.VALIDATE_CART)
    except ValidationError, e:
        for message in e.messages:
            messages.warning(request, message)


def checkout_process_decorator(*checks):
    """
    Calls all passed checkout process decorators in turn::

        @checkout_process_decorator(order_already_confirmed,
            order_cart_validates)

    All checkout process decorators are called with the order, the shop
    instance and the request as keyword arguments. In the future, additional
    keywords might be added, your decorators should accept ``**kwargs`` as
    well for future compatibility.
    """

    def _dec(fn):
        def _fn(request, *args, **kwargs):
            shop = plata.shop_instance()
            order = shop.order_from_request(request)

            for check in checks:
                r = check(order=order, shop=shop, request=request)
                if r:
                    return r

            return fn(request, order=order, *args, **kwargs)
        return wraps(fn)(_fn)
    return _dec


class Shop(object):
    """
    Plata's view and shop processing logic is contained inside this class.

    Shop needs a few model classes with relations between them:

    - Contact model linking to Django's auth.user
    - Order model with order items and an applied discount model
    - Discount model
    - Default currency for the shop (if you do not override default_currency
      in your own Shop subclass)

    Example::

        shop_instance = Shop(Contact, Order, Discount)

        urlpatterns = patterns('',
            url(r'^shop/', include(shop_instance.urls)),
        )
    """

    #: The base template used in all default checkout templates
    base_template = 'base.html'
    cart_template = 'plata/shop_cart.html'
    checkout_template = 'plata/shop_checkout.html'
    discount_template = 'plata/shop_discounts.html'
    confirmation_template = 'plata/shop_confirmation.html'
    success_template = 'plata/shop_order_success.html'
    failure_template = 'plata/shop_order_payment_failure.html'

    def __init__(self, contact_model, order_model, discount_model,
                 default_currency=None, **kwargs):
        self.contact_model = contact_model
        self.order_model = order_model
        self.orderitem_model = self.order_model.items.related.model
        self.discount_model = discount_model
        self._default_currency = default_currency

        # Globally register the instance so that it can be accessed from
        # everywhere using plata.shop_instance()
        plata.register(self)

        for key, value in kwargs.items():
            if not hasattr(self, key):
                raise TypeError('%s() received an invalid keyword %r' % (
                    self.__class__.__name__, key))
            setattr(self, key, value)

    @property
    def urls(self):
        """Property offering access to the Shop-managed URL patterns"""
        return self.get_urls()

    def get_urls(self):
        return self.get_shop_urls() + self.get_payment_urls()

    def get_cart_url(self):
        return url(r'^cart/$', checkout_process_decorator(
            order_already_confirmed
        )(self.cart), name='plata_shop_cart')

    def get_checkout_url(self):
        return url(r'^checkout/$', checkout_process_decorator(
            cart_not_empty, order_already_confirmed, order_cart_validates,
        )(self.checkout), name='plata_shop_checkout')

    def get_discounts_url(self):
        return url(r'^discounts/$', checkout_process_decorator(
            cart_not_empty, order_already_confirmed, order_cart_validates,
        )(self.discounts), name='plata_shop_discounts')

    def get_confirmation_url(self):
        return url(r'^confirmation/$', checkout_process_decorator(
            cart_not_empty, order_cart_validates,
        )(self.confirmation), name='plata_shop_confirmation')

    def get_success_url(self):
        return url(
            r'^order/success/$',
            self.order_success,
            name='plata_order_success'
        )

    def get_failure_url(self):
        return url(
            r'^order/payment_failure/$',
            self.order_payment_failure,
            name='plata_order_payment_failure'
        )

    def get_new_url(self):
        return url(r'^order/new/$', self.order_new, name='plata_order_new')

    def get_shop_urls(self):
        return patterns(
            '',
            self.get_cart_url(),
            self.get_checkout_url(),
            self.get_discounts_url(),
            self.get_confirmation_url(),
            self.get_success_url(),
            self.get_failure_url(),
            self.get_new_url(),
        )

    def get_payment_urls(self):
        urls = [
            url(r'', include(module.urls))
            for module in self.get_payment_modules()
        ]
        return patterns('', *urls)

    def get_payment_modules(self, request=None):
        """
        Import and return all payment modules defined in
        ``PLATA_PAYMENT_MODULES``

        If request is given only applicable modules are loaded.
        """
        all_modules = [
            get_callable(module)(self)
            for module in plata.settings.PLATA_PAYMENT_MODULES]
        if not request:
            return all_modules
        return [
            module for module in all_modules
            if module.enabled_for_request(request)]

    def default_currency(self, request=None):
        """
        Return the default currency for instantiating new orders

        Override this with your own implementation if you have a
        multi-currency shop with auto-detection of currencies.
        """
        return self._default_currency or plata.settings.CURRENCIES[0]

    def price_includes_tax(self, request=None):
        """
        Return if the shop should show prices including tax

        This returns the PLATA_PRICE_INCLUDES_TAX settings by default
        and is meant to be overridden by subclassing the Shop.
        """
        if request:
            order = self.order_from_request(request)
            if order:
                return order.price_includes_tax
        return plata.settings.PLATA_PRICE_INCLUDES_TAX

    def set_order_on_request(self, request, order):
        """
        Helper method encapsulating the process of setting the current order
        in the session. Pass ``None`` if you want to remove any defined order
        from the session.
        """
        if order:
            request.session['shop_order'] = order.pk
        elif 'shop_order' in request.session:
            del request.session['shop_order']

    def order_from_request(self, request, create=False):
        """
        Instantiate the order instance for the current session. Optionally
        creates a new order instance if ``create=True``.

        Returns ``None`` if unable to find an offer.
        """
        try:
            order_pk = request.session.get('shop_order')
            if order_pk is None:
                raise ValueError("no order in session")
            return self.order_model.objects.get(pk=order_pk)
        except AttributeError:
            # request has no session
            return None
        except (ValueError, self.order_model.DoesNotExist):
            if create:
                contact = self.contact_from_user(request.user)

                order = self.order_model.objects.create(
                    currency=getattr(
                        contact,
                        'currency',
                        self.default_currency(request)),
                    user=getattr(
                        contact,
                        'user',
                        request.user if request.user.is_authenticated()
                        else None),
                    language_code=get_language(),
                )

                self.set_order_on_request(request, order)
                return order

        return None

    def contact_from_user(self, user):
        """
        Return the contact object bound to the current user if the user is
        authenticated. Returns ``None`` if no contact exists.
        """
        if not user.is_authenticated():
            return None

        try:
            return self.contact_model.objects.get(user=user)
        except self.contact_model.DoesNotExist:
            return None

    def get_context(self, request, context, **kwargs):
        """
        Helper method returning a context dict. Override this if you
        need additional context variables.
        """
        ctx = {
            'base_template': self.base_template,
        }
        ctx.update(context)
        ctx.update(kwargs)
        return ctx

    def render(self, request, template, context):
        """
        Helper which just passes everything on to ``django.shortcuts.render``
        """
        return render(request, template, context)

    def reverse_url(self, url_name, *args, **kwargs):
        """
        Hook for customizing the reverse function
        """
        return reverse(url_name, *args, **kwargs)

    def redirect(self, url_name, *args, **kwargs):
        """
        Hook for customizing the redirect function when used as application
        content
        """
        return HttpResponseRedirect(
            self.reverse_url(url_name, *args, **kwargs))

    def cart(self, request, order):
        """Shopping cart view"""

        if not order or not order.items.count():
            return self.render_cart_empty(request, {
                'progress': 'cart',
            })

        OrderItemFormset = inlineformset_factory(
            self.order_model,
            self.orderitem_model,
            form=getattr(self, 'form', ModelForm),
            extra=0,
            fields=('quantity',),
        )

        if request.method == 'POST':
            formset = OrderItemFormset(request.POST, instance=order)

            if formset.is_valid():
                changed = False

                # We cannot directly save the formset, because the additional
                # checks in modify_item must be performed.
                for form in formset.forms:
                    if not form.instance.product_id:
                        form.instance.delete()
                        messages.warning(request, _(
                            '%(name)s has been removed from the inventory'
                            ' and from your cart as well.') % {
                            'name': form.instance.name,
                        })
                        changed = True

                    elif (formset.can_delete
                            and formset._should_delete_form(form)):
                        if order.is_confirmed():
                            raise ValidationError(_(
                                'Cannot modify order once'
                                ' it has been confirmed.'),
                                code='order_sealed')

                        form.instance.delete()
                        changed = True

                    elif form.has_changed():
                        order.modify_item(
                            form.instance.product,
                            absolute=form.cleaned_data['quantity'],
                            recalculate=False,
                            item=form.instance,
                            )
                        changed = True

                if changed:
                    order.recalculate_total()
                    messages.success(request, _('The cart has been updated.'))

                if 'checkout' in request.POST:
                    return self.redirect('plata_shop_checkout')
                return HttpResponseRedirect('.')
        else:
            formset = OrderItemFormset(instance=order)

        return self.render_cart(request, {
            'order': order,
            'orderitemformset': formset,
            'progress': 'cart',
        })

    def render_cart_empty(self, request, context):
        """Renders a cart-is-empty page"""
        context.update({'empty': True})

        return self.render(
            request, self.cart_template, self.get_context(request, context))

    def render_cart(self, request, context):
        """Renders the shopping cart"""
        return self.render(
            request, self.cart_template, self.get_context(request, context))

    def checkout_form(self, request, order):
        """Returns the address form used in the first checkout step"""

        # Only import plata.contact if necessary and if this method isn't
        # overridden
        from plata.contact.forms import CheckoutForm
        return CheckoutForm

    def get_authentication_form(self, **kwargs):
        return AuthenticationForm(**kwargs)

    def checkout(self, request, order):
        """Handles the first step of the checkout process"""
        if not request.user.is_authenticated():
            if request.method == 'POST' and '_login' in request.POST:
                loginform = self.get_authentication_form(
                    data=request.POST,
                    prefix='login')

                if loginform.is_valid():
                    user = loginform.get_user()
                    auth.login(request, user)

                    order.user = user
                    order.save()

                    return HttpResponseRedirect('.')
            else:
                loginform = self.get_authentication_form(prefix='login')
        else:
            loginform = None

        if order.status < order.CHECKOUT:
            order.update_status(order.CHECKOUT, 'Checkout process started')

        OrderForm = self.checkout_form(request, order)

        orderform_kwargs = {
            'prefix': 'order',
            'instance': order,
            'request': request,
            'shop': self,
        }

        if request.method == 'POST' and '_checkout' in request.POST:
            orderform = OrderForm(request.POST, **orderform_kwargs)

            if orderform.is_valid():
                orderform.save()
                if self.include_discount_step(request):
                    return self.redirect('plata_shop_discounts')
                else:
                    return self.redirect('plata_shop_confirmation')
        else:
            orderform = OrderForm(**orderform_kwargs)

        return self.render_checkout(request, {
            'order': order,
            'loginform': loginform,
            'orderform': orderform,
            'progress': 'checkout',
        })

    def render_checkout(self, request, context):
        """Renders the checkout page"""
        return self.render(
            request,
            self.checkout_template,
            self.get_context(request, context)
        )

    def include_discount_step(self, request):
        return self.discount_model.objects.exists()

    def discounts_form(self, request, order):
        """Returns the discount form"""
        return shop_forms.DiscountForm

    def discounts(self, request, order):
        """Handles the discount code entry page"""
        if not self.include_discount_step(request):
            return self.redirect('plata_shop_confirmation')

        DiscountForm = self.discounts_form(request, order)

        kwargs = {
            'order': order,
            'discount_model': self.discount_model,
            'request': request,
            'shop': self,
        }

        if request.method == 'POST':
            form = DiscountForm(request.POST, **kwargs)

            if form.is_valid():
                form.save()

                if 'proceed' in request.POST:
                    return self.redirect('plata_shop_confirmation')
                return HttpResponseRedirect('.')
        else:
            form = DiscountForm(**kwargs)

        order.recalculate_total()

        return self.render_discounts(request, {
            'order': order,
            'form': form,
            'progress': 'discounts',
        })

    def render_discounts(self, request, context):
        """Renders the discount code entry page"""
        return self.render(
            request,
            self.discount_template,
            self.get_context(request, context)
        )

    def confirmation_form(self, request, order):
        """Returns the confirmation and payment module selection form"""
        return shop_forms.ConfirmationForm

    def confirmation(self, request, order):
        """
        Handles the order confirmation and payment module selection checkout
        step

        Hands off processing to the selected payment module if confirmation
        was successful.
        """
        order.recalculate_total()

        ConfirmationForm = self.confirmation_form(request, order)

        kwargs = {
            'order': order,
            'request': request,
            'shop': self,
        }

        if request.method == 'POST':
            form = ConfirmationForm(request.POST, **kwargs)

            if form.is_valid():
                return form.process_confirmation()
        else:
            form = ConfirmationForm(**kwargs)

        return self.render_confirmation(request, {
            'order': order,
            'form': form,
            # Whether the order had already been confirmed.
            'confirmed': request.GET.get('confirmed', False),
            'progress': 'confirmation',
        })

    def render_confirmation(self, request, context):
        """Renders the confirmation page"""
        return self.render(
            request,
            self.confirmation_template,
            self.get_context(request, context)
        )

    def order_success(self, request):
        """
        Handles order successes (e.g. when an order has been successfully
        paid for)
        """
        order = self.order_from_request(request)

        if not order:
            return self.order_new(request)

        if not order.balance_remaining:
            # Create a new, empty order right away. It makes no sense
            # to keep the completed order around anymore.
            self.set_order_on_request(request, order=None)

        return self.render(
            request,
            self.success_template,
            self.get_context(
                request, {
                    'order': order,
                    'progress': 'success',
                }
            )
        )

    def order_payment_failure(self, request):
        """Handles order payment failures"""
        order = self.order_from_request(request)

        logger.warn('Order payment failure for %s' % order.order_id)

        if plata.settings.PLATA_STOCK_TRACKING:
            StockTransaction = plata.stock_model()

            for transaction in order.stock_transactions.filter(
                    type=StockTransaction.PAYMENT_PROCESS_RESERVATION):
                transaction.delete()

        order.payments.pending().delete()

        if order.payments.authorized().exists():
            # There authorized order payments around!
            messages.warning(request, _('Payment failed, please try again.'))
            logger.warn(
                'Order %s is already partially paid, but payment'
                ' failed anyway!' % order.order_id)
        elif order.status > order.CHECKOUT and order.status < order.PAID:
            order.update_status(
                order.CHECKOUT,
                'Order payment failure, going back to checkout')
            messages.info(request, _(
                'Payment failed; you can continue editing your order and'
                ' try again.'))

        return self.render(
            request,
            self.failure_template,
            self.get_context(
                request, {
                    'order': order,
                    'progress': 'failure',
                }
            )
        )

    def order_new(self, request):
        """
        Forcibly create a new order and redirect user either to the frontpage
        or to the URL passed as ``next`` GET parameter
        """
        self.set_order_on_request(request, order=None)

        next = request.GET.get('next')
        if next:
            return HttpResponseRedirect(next)

        return HttpResponseRedirect('/')

########NEW FILE########
__FILENAME__ = utils
from django.db.models import Model


def jsonize(v):
    """
    Convert the discount configuration into a state in which it can be
    stored inside the JSON field.

    Some information is lost here; f.e. we only store the primary key
    of model objects, so you have to remember yourself which objects
    are meant by the primary key values.
    """

    if isinstance(v, dict):
        return dict((i1, jsonize(i2)) for i1, i2 in v.items())
    if hasattr(v, '__iter__'):
        return [jsonize(i) for i in v]
    if isinstance(v, Model):
        return v.pk
    return v

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os, sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testapp.settings")

    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from testapp.models import Product, Price


class PriceInline(admin.TabularInline):
    model = Price
    extra = 0


admin.site.register(Product,
    inlines=[PriceInline],
    )

########NEW FILE########
__FILENAME__ = models
from django.db import models

from plata.product.models import ProductBase
from plata.shop.models import PriceBase


class Product(ProductBase):
    name = models.CharField(max_length=100)
    items_in_stock = models.IntegerField(default=0)

    class Meta:
        ordering = ['name']

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ('plata_product_detail', (self.pk,), {})

    @property
    def sku(self):
        return u''


class Price(PriceBase):
    product = models.ForeignKey(Product, related_name='prices')

    class Meta:
        ordering = ['-id']

########NEW FILE########
__FILENAME__ = settings
# Django settings for testapp project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'test.db',
    }
}

TIME_ZONE = 'America/Chicago'
LANGUAGE_CODE = 'en-us'
SITE_ID = 1
USE_I18N = True
USE_L10N = True
USE_TZ = True
MEDIA_ROOT = ''
MEDIA_URL = ''
STATIC_ROOT = ''
STATIC_URL = '/static/'
STATICFILES_DIRS = (
)
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)
SECRET_KEY = '58_c#ha*osgvo(809%#@kf!4_ab((a4tl6ypa_0i_teh&amp;%dul$'
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)
MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',
    #'django.core.context_processors.tz',
    'django.core.context_processors.request',
    'django.contrib.messages.context_processors.messages',
    'plata.context_processors.plata_context',
)


ROOT_URLCONF = 'testapp.urls'
WSGI_APPLICATION = 'testapp.wsgi.application'

TEMPLATE_DIRS = (
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',

    'testapp',
    'plata',
    'plata.contact', # Not strictly required (contact model can be exchanged)
    'plata.discount',
    'plata.payment',
    'plata.product', # Does nothing
    'plata.product.stock', # Accurate stock tracking, not required
    'plata.shop',
)

PLATA_SHOP_PRODUCT = 'testapp.Product'
PLATA_STOCK_TRACKING = True
POSTFINANCE = {
    'PSPID': 'plataTEST',
    'SHA1_IN': 'plataSHA1_IN',
    'SHA1_OUT': 'plataSHA1_OUT',
    'LIVE': False,
    }

PAYPAL = {
    'BUSINESS': 'example@paypal.com',
    'LIVE': False,
    }

########NEW FILE########
__FILENAME__ = base
from datetime import date
from decimal import Decimal

from django.test import TestCase

try:  # pragma: no cover
  from django.contrib.auth import get_user_model
  User = get_user_model()
except ImportError, e:
  from django.contrib.auth.models import User

from django.contrib.auth.models import AnonymousUser

import plata
from plata.contact.models import Contact
from plata.product.stock.models import StockTransaction
from plata.shop import notifications, signals
from plata.shop.models import TaxClass, Order, OrderItem


signals.contact_created.connect(
    notifications.ContactCreatedHandler(always_bcc=['shop@example.com']),
    weak=False)
signals.order_paid.connect(
    notifications.SendInvoiceHandler(always_bcc=['shop@example.com']),
    weak=False)
signals.order_paid.connect(
    notifications.SendPackingSlipHandler(
        always_to=['shipping@example.com'],
        always_bcc=['shop@example.com']),
    weak=False)


class Empty(object):
    pass


def get_request(**kwargs):
    """
    Helper method which creates a mock request object
    """

    request = Empty()
    request.session = {}
    request.user = AnonymousUser()

    for k, v in kwargs.items():
       setattr(request, k, v)

    return request


PRODUCTION_CREATION_COUNTER = 0

class PlataTest(TestCase):
    def assertRaisesWithCode(self, exception, fn, code):
        try:
            fn()
        except exception, e:
            if e.code == code:
                return True
            raise
        raise Exception, '%s did not raise %s' % (fn, exception)

    def setUp(self):
        plata.settings.PLATA_PRICE_INCLUDES_TAX = True

    def create_contact(self):
        return Contact.objects.create(
            billing_company=u'BigCorp',
            billing_first_name=u'Hans',
            billing_last_name=u'Muster',
            billing_address=u'Musterstrasse 42',
            billing_zip_code=u'8042',
            billing_city=u'Beispielstadt',
            billing_country=u'CH',
            shipping_same_as_billing=True,
            currency='CHF',
            user=User.objects.create_user('hans', 'hans', 'hans'),
            )

    def create_order(self, contact=None):
        contact = contact or self.create_contact()

        return Order.objects.create(
            user=contact.user if contact else None,
            currency='CHF',
            )

    def create_orderitem(self, product, order):
        item = OrderItem(
            product=product,
            order=order,
            quantity=1,
            _unit_price=0,
            _unit_tax=0,
            tax_rate=0)
        product.handle_order_item(item)
        return item

    def create_tax_classes(self):
        self.tax_class, created = TaxClass.objects.get_or_create(
            name='Standard Swiss Tax Rate',
            rate=Decimal('7.60'),
            )

        self.tax_class_germany, created = TaxClass.objects.get_or_create(
            name='Umsatzsteuer (Germany)',
            rate=Decimal('19.60'),
            )

        self.tax_class_something, created = TaxClass.objects.get_or_create(
            name='Some tax rate',
            rate=Decimal('12.50'),
            )

        return self.tax_class, self.tax_class_germany, self.tax_class_something


    def create_product(self, stock=0):
        global PRODUCTION_CREATION_COUNTER
        PRODUCTION_CREATION_COUNTER += 1

        tax_class, tax_class_germany, tax_class_something = self.create_tax_classes()

        Product = plata.product_model()
        product = Product.objects.create(
            name='Test Product %s' % PRODUCTION_CREATION_COUNTER,
            )

        if stock:
            product.stock_transactions.create(
                type=StockTransaction.PURCHASE,
                change=stock,
                )

        # An old price in CHF which should not influence the rest of the tests
        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('99.90'),
            tax_included=True,
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('199.90'),
            tax_included=True,
            #valid_from=date(2000, 1, 1),
            #valid_until=date(2001, 1, 1),
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('299.90'),
            tax_included=True,
            #valid_from=date(2000, 1, 1),
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('299.90'),
            tax_included=True,
            #valid_from=date(2000, 7, 1),
            #is_sale=True,
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('79.90'),
            tax_included=True,
            #is_sale=True,
            )

        product.prices.create(
            currency='EUR',
            tax_class=tax_class_germany,
            _unit_price=Decimal('49.90'),
            tax_included=True,
            )

        product.prices.create(
            currency='CAD',
            tax_class=tax_class_something,
            _unit_price=Decimal('65.00'),
            tax_included=False,
            )

        """
        # A few prices which are not yet (or no more) active
        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('110.00'),
            tax_included=True,
            #is_active=False,
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('120.00'),
            tax_included=True,
            is_active=True,
            valid_from=date(2100, 1, 1),
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('130.00'),
            tax_included=True,
            is_active=True,
            valid_from=date(2000, 1, 1),
            valid_until=date(2001, 1, 1),
            )
        """

        return product

########NEW FILE########
__FILENAME__ = test_admin
from decimal import Decimal

from django.contrib.auth.models import User
from django.forms.models import model_to_dict

import plata
from plata.discount.models import Discount
from plata.shop.models import TaxClass

from .base import PlataTest


Product = plata.product_model()


class AdminTest(PlataTest):
    def setUp(self):
        u = User.objects.create_user('admin', 'admin@example.com', 'password')
        u.is_staff = True
        u.is_superuser = True
        u.save()

        product_model = Product
        self.product_admin_url = '/admin/%s/%s/' % (
            product_model._meta.app_label,
            product_model._meta.module_name,
            )

    def login(self):
        self.client.login(username='admin', password='password')

    def test_01_products(self):
        """Test whether the administration interface is well behaved"""
        self.login()

        TaxClass.objects.create(
            name='Standard Swiss Tax Rate',
            rate=Decimal('7.60'),
            )

        product_data = {
            'name': 'Product 3',
            'items_in_stock': 0,

            'prices-0-id': '',
            'prices-0-product': '',

            'prices-0-_unit_price': '79.90',
            'prices-0-currency': 'CHF',
            'prices-0-tax_class': '1',
            'prices-0-tax_included': 'on',

            'prices-INITIAL_FORMS': '0',
            'prices-MAX_NUM_FORMS': '',
            'prices-TOTAL_FORMS': '1',
            }

        self.client.post(self.product_admin_url + 'add/', product_data)
        self.assertEqual(Product.objects.count(), 1)

        self.assertEqual(
            self.client.post(self.product_admin_url + 'add/', product_data).status_code,
            302)

        self.assertEqual(Product.objects.count(), 2)

        p = Product.objects.get(pk=2)

        discount_data = {
            'name': 'Discount 1',
            'type': Discount.PERCENTAGE_VOUCHER,
            'value': 30,
            'code': 'discount1',
            'is_active': True,
            'valid_from': '2010-01-01',
            'valid_until': '',
            'allowed_uses': '',
            'used': 0,
            }

        self.assertContains(self.client.post('/admin/discount/discount/add/', discount_data),
            'required')

        # Does not redirect
        self.assertEqual(self.client.post('/admin/discount/discount/add/', discount_data).status_code, 200)

        discount_data['config_options'] = ('all',)
        self.assertRedirects(self.client.post('/admin/discount/discount/add/', discount_data),
            '/admin/discount/discount/')

        discount_data['config_options'] = ('exclude_sale',)
        discount_data['code'] += '-'
        self.client.post('/admin/discount/discount/add/', discount_data)
        self.assertContains(self.client.get('/admin/discount/discount/2/'),
            'Discount configuration: Exclude sale prices')

        discount_data['name'] = 'Discount 2'
        discount_data['code'] = 'discount2'
        self.assertRedirects(self.client.post('/admin/discount/discount/add/', discount_data),
            '/admin/discount/discount/')

        discount_data = model_to_dict(Discount.objects.get(pk=3))
        discount_data.update({
            'config_options': ('products',),
            'products_products': ('1'),
            'valid_from': '2010-01-01',
            'valid_until': '',
            'allowed_uses': '',
            'used': 0,
            'currency': '',
            'tax_class': '',

            # Manually modified config_json overrides anything selected in the
            # generated form items
            'config_json': u'{"all": {}}',
            })
        self.assertRedirects(self.client.post('/admin/discount/discount/3/', discount_data),
            '/admin/discount/discount/')

    def test_02_orders(self):
        self.create_product()
        order = self.create_order()
        self.login()

        orders = self.client.get('/admin/shop/order/')

        # Order item and list filter
        self.assertContains(orders, 'Is a cart', count=2)
        self.assertContains(orders, '/invoice_pdf/%d/' % order.id, count=1)
        self.assertContains(orders, '/packing_slip_pdf/%d/' % order.id,
            count=1)

########NEW FILE########
__FILENAME__ = test_models
from datetime import date, datetime
from decimal import Decimal
from io import BytesIO
import warnings

from django import forms
from django.core.exceptions import ValidationError
from django.core.serializers import serialize
from django.db.models import Q
from django.utils import timezone

from pdfdocument.document import PDFDocument

import plata
from plata.discount.models import Discount, DiscountBase
from plata.product.stock.models import Period, StockTransaction
import plata.reporting.order
from plata.shop.models import Order, OrderItem, OrderStatus, OrderPayment

from .base import PlataTest


Product = plata.product_model()


DiscountBase.CONFIG_OPTIONS.append(('name_filter', {
    'title': 'name_filter',
    'orderitem_query': lambda **values: Q(name__icontains=values.get('name')),
}))

DiscountBase.CONFIG_OPTIONS.append(('products', {
    'title': 'Explicitly define discountable products',
    'form_fields': [
        ('products', forms.ModelMultipleChoiceField(
            Product._default_manager.all(),
            required=True,
            )),
        ],
    'product_query': lambda products: Q(id__in=products),
    }))


class ModelTest(PlataTest):
    def test_00_test(self):
        """Test assertRaisesWithCode works as expected"""
        def raise_validationerror():
            raise ValidationError('test', code='test')

        def raise_notimplementederror():
            raise NotImplementedError

        self.assertRaisesWithCode(ValidationError, raise_validationerror, code='test')

        self.assertRaises(ValidationError,
            lambda: self.assertRaisesWithCode(ValidationError,
                raise_validationerror, code='something'))

        self.assertRaises(NotImplementedError,
            lambda: self.assertRaisesWithCode(ValidationError,
                raise_notimplementederror, code='something'))

        self.assertRaises(Exception,
            lambda: self.assertRaisesWithCode(ValidationError,
                lambda: None, code='something'))

    def test_01_basic_order(self):
        """Test basic order and product properties"""
        product = self.create_product()
        order = self.create_order()

        item_price = Decimal('79.90')
        line_item_price = item_price * 2
        order_total = Decimal('159.80')
        tax_factor = Decimal('1.076')

        price = product.get_price(currency=order.currency)
        self.assertEqual(price.currency, order.currency)
        self.assertAlmostEqual(price.unit_price, item_price)
        self.assertAlmostEqual(price.unit_price_incl_tax, price.unit_price)
        self.assertAlmostEqual(price.unit_price_excl_tax, item_price / tax_factor)
        self.assertAlmostEqual(price.unit_tax, price.unit_price_excl_tax * Decimal('0.076'))

        order.modify_item(product, 5)
        order.modify_item(product, -4)
        item = order.modify_item(product, 1)

        self.assertEqual(order.items.count(), 1)

        self.assertEqual(item.quantity, 2)

        self.assertAlmostEqual(order.items_subtotal, order_total / tax_factor)
        self.assertAlmostEqual(order.items_subtotal + order.items_tax, order_total)
        self.assertAlmostEqual(order.total, order_total)

        self.assertAlmostEqual(item._unit_price, item_price / tax_factor)
        self.assertAlmostEqual(item.discounted_subtotal_incl_tax, line_item_price)
        self.assertAlmostEqual(item.discounted_subtotal_excl_tax, line_item_price / tax_factor)
        self.assertAlmostEqual(item.discounted_subtotal_incl_tax, line_item_price)

        self.assertAlmostEqual(item.unit_price, item_price)
        self.assertAlmostEqual(item.line_item_discount, 0)
        self.assertAlmostEqual(item.discounted_subtotal, item.discounted_subtotal_incl_tax)

        self.assertAlmostEqual(order.shipping, Decimal('0.00'))

        # Switch around tax handling and re-test. Those two are the same
        # instance in Django >=1.5, but not in 1.4, because 1.4 is a bit less
        # smart about fetching the same object from the database again and
        # again when relations are involved.
        item.order.price_includes_tax = False
        order.price_includes_tax = False

        self.assertAlmostEqual(item.unit_price, item_price / tax_factor)
        self.assertAlmostEqual(item.line_item_discount, 0 / tax_factor)
        self.assertAlmostEqual(item.discounted_subtotal, item.discounted_subtotal_excl_tax)
        # XXX see PriceBase.unit_price self.assertAlmostEqual(price.unit_price, item_price / tax_factor)

        self.assertRaises(NotImplementedError, lambda: order.shipping)

        # Switch tax handling back
        order.price_includes_tax = True

        product.prices.all().delete()
        self.assertRaisesWithCode(ValidationError,
            lambda: order.modify_item(product, absolute=1),
            code='unknown_price')

    def test_02_eur_order(self):
        """Test basic order in EUR works as expected"""
        product = self.create_product()
        order = self.create_order()

        order.currency = 'EUR'
        order.save()

        item = order.modify_item(product, 2)

        self.assertEqual(item.unit_price, Decimal('49.90'))
        self.assertEqual(item.currency, order.currency)

    def test_03_mixed_currencies(self):
        """Test orders with mixed currencies are rejected during validation"""

        p1 = self.create_product()
        p2 = self.create_product()
        order = self.create_order()

        order.currency = 'CHF'
        i1 = order.modify_item(p1, 3)

        order.currency = 'EUR'
        self.assertRaisesWithCode(ValidationError, lambda: order.modify_item(p2, 2),
            code='multiple_currency')

        # Validation should still fail
        self.assertRaisesWithCode(ValidationError, lambda: order.validate(order.VALIDATE_BASE),
            code='multiple_currency')

        order.currency = 'CHF'
        # Order should validate now
        order.validate(order.VALIDATE_BASE)

    def test_04_order_modify_item(self):
        """Test Order.modify_item method is well behaving"""
        p1 = self.create_product()
        p2 = self.create_product()
        order = self.create_order()

        order.modify_item(p1, 42)
        order.modify_item(p2, 42)
        self.assertEqual(order.items.count(), 2)

        order.modify_item(p1, -42)
        self.assertEqual(order.items.count(), 1)

        item = order.modify_item(p1, relative=3)
        self.assertEqual(item.quantity, 3)
        item = order.modify_item(p1, relative=2)
        self.assertEqual(item.quantity, 5)
        item = order.modify_item(p1, absolute=33)
        self.assertEqual(item.quantity, 33)

    def test_05_order_status(self):
        """Test order status modification"""
        order = self.create_order()

        self.assertRaisesWithCode(ValidationError, lambda: order.update_status(
            Order.CHECKOUT,
            'Checkout process has started',
            ), code='order_empty')

        product = self.create_product()
        order.modify_item(product, 1)

        # Should be possible to update order status now
        order.update_status(
            Order.CONFIRMED,
            'Order has been confirmed',
            )

        # Should not be possible to modify order once checkout process has started
        self.assertRaisesWithCode(ValidationError, lambda: order.modify_item(product, 2),
            code='order_sealed')

        self.assertEqual(order.status, Order.CONFIRMED)
        self.assertEqual(Order.objects.get().status, Order.CONFIRMED)

    def test_06_order_percentage_discount(self):
        """Test a simple percentage discount"""
        order = self.create_order()
        p1 = self.create_product()
        p2 = self.create_product()

        order.modify_item(p1, 3)
        order.modify_item(p2, 5)

        discount = Discount.objects.create(
            is_active=False,
            type=Discount.PERCENTAGE_VOUCHER,
            code='asdf',
            name='Percentage discount',
            value=30)

        self.assertRaises(ValidationError, lambda: discount.add_to(order))
        discount.is_active = True
        discount.save()

        discount.add_to(order)
        order.recalculate_total()

        tax_factor = Decimal('1.076')
        item_price_incl_tax = Decimal('79.90')
        item_price_excl_tax = item_price_incl_tax / tax_factor

        order.recalculate_total()
        item = order.modify_item(p1, relative=0)
        item2 = order.modify_item(p2, relative=0)

        self.assertAlmostEqual(item.unit_price, item_price_incl_tax)
        self.assertAlmostEqual(item.line_item_discount, item_price_incl_tax * 3 * Decimal('0.30'))
        self.assertAlmostEqual(order.total,
            item.discounted_subtotal + item2.discounted_subtotal)

        order.price_includes_tax = False
        order.recalculate_total()
        item = order.modify_item(p1, 0)
        item2 = order.modify_item(p2, 0)

        self.assertAlmostEqual(item.unit_price, item_price_excl_tax)
        self.assertAlmostEqual(item.line_item_discount, item_price_excl_tax * 3 * Decimal('0.30'))
        self.assertAlmostEqual(order.total,
            item.discounted_subtotal + item2.discounted_subtotal + order.items_tax)

    def test_07_order_amount_discount(self):
        """Test a simple amount discount"""
        order = self.create_order()
        p1 = self.create_product()
        p2 = self.create_product()

        normal1 = order.modify_item(p1, 3)
        normal2 = order.modify_item(p2, 5)

        order.recalculate_total()
        self.assertAlmostEqual(order.total, Decimal('639.20'))

        discount = Discount.objects.create(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            code='asdf',
            name='Amount discount',
            value=Decimal('50.00'),
            is_active=True,
            tax_class=self.tax_class,
            currency='CHF')
        discount.add_to(order)
        order.recalculate_total()

        discounted1 = order.modify_item(p1, 0)
        discounted2 = order.modify_item(p2, 0)

        tax_factor = Decimal('1.076')
        item_price_incl_tax = Decimal('79.90')
        item_price_excl_tax = item_price_incl_tax / tax_factor

        self.assertAlmostEqual(order.total, Decimal('639.20') - Decimal('50.00'))

        self.assertAlmostEqual(normal1.unit_price, discounted1.unit_price)
        self.assertAlmostEqual(normal2.unit_price, discounted2.unit_price)
        self.assertAlmostEqual(normal1.unit_price, item_price_incl_tax)

        self.assertEqual(normal1.line_item_discount, 0)
        self.assertEqual(normal2.line_item_discount, 0)

        self.assertAlmostEqual(discounted1.line_item_discount, Decimal('50.00') / 8 * 3)
        self.assertAlmostEqual(discounted2.line_item_discount, Decimal('50.00') / 8 * 5)

        self.assertAlmostEqual(discounted1.discounted_subtotal, order.total / 8 * 3)
        self.assertAlmostEqual(discounted2.discounted_subtotal, order.total / 8 * 5)

        order.price_includes_tax = False
        order.recalculate_total()
        discounted1 = order.modify_item(p1, 0)
        discounted2 = order.modify_item(p2, 0)

        self.assertAlmostEqual(order.total, Decimal('639.20') - Decimal('50.00'))

        self.assertAlmostEqual(discounted1.unit_price, item_price_excl_tax)
        self.assertAlmostEqual(discounted1.line_item_discount, discount.value / tax_factor / 8 * 3)
        self.assertAlmostEqual(order.total,
            discounted1.discounted_subtotal + discounted2.discounted_subtotal + order.items_tax)

    def test_08_order_payment(self):
        """Test basic order payment model behavior"""
        order = self.create_order()
        product = self.create_product()

        order.modify_item(product, 10)
        order.recalculate_total()

        payment = order.payments.model(
            order=order,
            currency='CHF',
            amount=Decimal('49.90'),
            payment_method='Mafia style',
            )

        # The descriptor cannot be used through create(), therefore
        # we need this stupid little dance
        payment.data = {'anything': 42}
        payment.save()

        order = Order.objects.get(pk=order.pk)
        self.assertAlmostEqual(order.paid, 0)

        payment.authorized = timezone.now()
        payment.save()

        order = Order.objects.get(pk=order.pk)
        self.assertAlmostEqual(order.balance_remaining, order.total - payment.amount)

        self.assertEqual(order.payments.all()[0].data['anything'], 42)

        payment2 = order.payments.model(
            order=order.reload(),
            currency='EUR', # mismatch!
            amount=Decimal('100'),
            payment_method='Whatever',
            )
        payment2.data = {}
        payment2.save()

        order2 = order.reload()

        # Shouldn't have changed
        self.assertAlmostEqual(order2.balance_remaining, order.balance_remaining)
        self.assertNotEqual(order2.notes, order.notes)

    def test_09_selective_discount(self):
        """Test applying discounts with product restriction"""
        p1 = self.create_product()
        p2 = self.create_product()
        p2.name = 'Discountable'
        p2.save()

        d = Discount(
            type=Discount.PERCENTAGE_VOUCHER,
            name='Some discount',
            code='asdf',
            value=Decimal('30'),
            is_active=True,
            )

        d.config = {'name_filter': {'name': 'Discountable'}}
        d.save()

        order = self.create_order()
        order.modify_item(p1, 3)
        order.modify_item(p2, 2)
        d.add_to(order)
        order.recalculate_total()

        # Test that only one order item has its discount applied
        Product = plata.product_model()
        self.assertEqual(Product.objects.all().count(), 2)
        self.assertEqual(order.items.count(), 2)
        self.assertEqual(1,
            len([item for item in order.items.all() if item._line_item_discount]))

    def test_10_discount_validation(self):
        """Test discount validity periods"""
        order = self.create_order()
        d = Discount(
            is_active=False,
            valid_from=date(2100, 1, 1), # far future date
            valid_until=None,
            )

        try:
            d.validate(order)
        except ValidationError, e:
            self.assertEqual(len(e.messages), 2)

        d.is_active = True
        d.valid_until = date(2000, 1, 1)

        try:
            d.validate(order)
        except ValidationError, e:
            self.assertEqual(len(e.messages), 2)

    def test_11_multiple_discounts(self):
        """Test behavior of orders with more than one discount"""
        order = self.create_order()
        product = self.create_product()
        order.modify_item(product, 3)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, Decimal('239.70'))

        Discount.objects.create(
            type=Discount.PERCENTAGE_VOUCHER,
            name='Percentage',
            code='perc20',
            value=Decimal('20.00'),
            is_active=True,
            ).add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, Decimal('239.70') / 5 * 4)

        # Add unsaved discount
        Discount(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            name='Amount incl. tax',
            code='amount_incl_20',
            value=Decimal('20.00'),
            is_active=True,
            tax_class=self.tax_class,
            currency='CHF',
            ).add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, (Decimal('239.70') - 20) / 5 * 4)

    def test_12_order4567_test(self):
        """Reproduce order ID 4567 of a deployed satchmo shop installation"""
        order = self.create_order()

        p1 = self.create_product()
        p1.name = 'Kleid'
        p1.save()
        p1.prices.all().delete()
        p1.prices.create(
            _unit_price=160,
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class,
            )

        p2 = self.create_product()
        p2.prices.all().delete()
        p2.prices.create(
            _unit_price=280,
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class,
            )

        order.modify_item(p1, 1)
        order.modify_item(p2, 1)

        self.assertAlmostEqual(order.total, Decimal('440.00'))

        discount = Discount(
            type=Discount.PERCENTAGE_VOUCHER,
            name='Sonderrabatt Kleid',
            value=Decimal('20.00'),
            code='1234code',
            )
        discount.config = {'name_filter': {'name': 'Kleid'}}
        discount.save()

        discount.add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, 408)
        self.assertAlmostEqual(order.subtotal, 440)
        self.assertAlmostEqual(order.discount, 32)

    def test_13_order4206_test(self):
        """Reproduce order ID 4206 of a deployed satchmo shop installation"""
        order = self.create_order()

        p1 = self.create_product()
        p1.name = 'Venice'
        p1.save()
        p1.prices.all().delete()
        p1.prices.create(
            _unit_price=170,
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class,
            )

        p2 = self.create_product()
        p2.prices.all().delete()
        p2.prices.create(
            _unit_price=Decimal('40.80'),
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class,
            )

        order.modify_item(p1, 1)
        order.modify_item(p2, 1)

        discount = Discount(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            name='Sonderrabatt Venice',
            value=Decimal('20.00'),
            code='1234code',
            tax_class=self.tax_class,
            currency='CHF',
            )
        discount.config = {'name_filter': {'name': 'Venice'}}
        discount.save()

        discount.add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, Decimal('190.80'))
        self.assertAlmostEqual(order.subtotal, Decimal('210.80'))
        self.assertAlmostEqual(order.discount, 20)

    def test_14_invoice2009_0170_0002_test(self):
        """Reproduce invoide of a deployed metronom installation"""
        order = self.create_order()

        p = self.create_product()
        p.prices.all().delete()
        p.prices.create(
            _unit_price=1,
            tax_included=False,
            currency=order.currency,
            tax_class=self.tax_class,
            )

        order.modify_item(p, 952)
        order.modify_item(p, 120)

        discount = Discount.objects.create(
            type=Discount.AMOUNT_VOUCHER_EXCL_TAX,
            name='Discount',
            value=532,
            code='1234code',
            currency='CHF',
            )
        discount.add_to(order)

        order.price_includes_tax = False
        order.recalculate_total()

        self.assertAlmostEqual(order.subtotal, Decimal('1072.00'))
        self.assertAlmostEqual(order.discount, Decimal('532.00'))
        self.assertAlmostEqual(order.items_tax, Decimal('41.04'))
        self.assertAlmostEqual(order.total, Decimal('581.04'))

    def test_15_remaining_discount(self):
        """Test determination of remaining discount amount"""
        order = self.create_order()
        product = self.create_product()

        order.modify_item(product, 1)
        self.assertAlmostEqual(order.total, Decimal('79.90'))

        Discount.objects.create(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            name='Discount',
            value='100',
            code='1234code',
            tax_class=self.tax_class,
            currency='CHF',
            ).add_to(order)

        self.assertAlmostEqual(order.subtotal, Decimal('79.90'))
        self.assertAlmostEqual(order.discount, Decimal('79.90'))
        self.assertAlmostEqual(order.total, 0)
        self.assertAlmostEqual(order.discount_remaining, Decimal('20.10') / Decimal('1.076'))

    def test_16_payment(self):
        """Test order with payments and discounts"""
        order = self.create_order()
        product = self.create_product()

        order.modify_item(product, 3)
        self.assertAlmostEqual(order.balance_remaining, Decimal('79.90') * 3)

        payment = order.payments.create(
            currency=order.currency,
            amount=100,
            )

        self.assertAlmostEqual(order.balance_remaining, Decimal('79.90') * 3)

        payment.transaction_id = '1234' # Not strictly required
        payment.authorized = timezone.now()
        payment.save()

        order = Order.objects.get(pk=order.pk)
        self.assertAlmostEqual(order.balance_remaining, Decimal('139.70'))

        order.payments.create(
            currency=order.currency,
            amount=Decimal('139.70'),
            authorized=timezone.now(),
            )

        order = Order.objects.get(pk=order.pk)
        self.assertAlmostEqual(order.balance_remaining, Decimal('0.00'))

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self.assertTrue(order.is_paid())
            self.assertEqual(len(w), 1)
            self.assertTrue(
                'Order.is_paid() has been deprecated' in str(w[-1]))

        payment.delete()
        order = Order.objects.get(pk=order.pk)
        self.assertAlmostEqual(order.balance_remaining, Decimal('100.00'))

    def test_17_stocktransactions(self):
        """Simple stock transaction test"""
        order = self.create_order()
        product = self.create_product()
        Product = product.__class__

        period = Period.objects.create(
            name='Period 1',
            start=timezone.now(),
            )
        # Create a period which has been superceeded by Period 1
        Period.objects.create(
            name='Period 0',
            start=timezone.make_aware(datetime(2000, 1, 1, 0, 0),
                timezone.get_default_timezone()),
            )

        # Create a period in the far future
        Period.objects.create(
            name='Period 2',
            start=timezone.make_aware(datetime(2030, 1, 1, 0, 0),
                timezone.get_default_timezone()),
            )

        s = StockTransaction.objects.create(
            product=product,
            type=StockTransaction.INITIAL,
            change=10,
            )

        self.assertEqual(s.period, period)
        self.assertEqual(Product.objects.get(pk=product.id).items_in_stock, 10)

        StockTransaction.objects.create(
            product=product,
            type=StockTransaction.CORRECTION,
            change=-3,
            )

        self.assertEqual(StockTransaction.objects.items_in_stock(product), 7)

        StockTransaction.objects.create(
            product=product,
            type=StockTransaction.SALE,
            change=-2,
            )

        StockTransaction.objects.create(
            product=product,
            type=StockTransaction.PURCHASE,
            change=4,
            )

        StockTransaction.objects.open_new_period(name='Something')

        transaction = StockTransaction.objects.filter(product=product)[0]

        self.assertEqual(transaction.type, StockTransaction.INITIAL)
        self.assertEqual(transaction.change, 9)
        self.assertEqual(transaction.period.name, 'Something')

    def test_18_amount_discount_incl_tax(self):
        """Test discount amounts specified with tax included"""
        p1 = self.create_product()
        p2 = self.create_product()

        price = p1.get_price(currency='CAD')
        price.tax_class = self.tax_class_germany
        price.save()

        order = self.create_order()
        order.currency = 'CAD'
        order.save()

        normal1 = order.modify_item(p1, 3)
        normal2 = order.modify_item(p2, 5)

        order.recalculate_total()
        #self.assertAlmostEqual(order.total, Decimal('598.84'))
        # We use ROUND_HALF_UP now
        self.assertAlmostEqual(order.total, Decimal('598.85'))

        discount = Discount.objects.create(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            code='asdf',
            name='Amount discount',
            value=Decimal('50.00'),
            is_active=True,
            tax_class=self.tax_class_germany,
            currency='CAD',
            config='{"products": {"products": [%d]}}' % p1.id,
            )
        discount.add_to(order)
        order.recalculate_total()

        # Exact values after usage of different tax rates in same order
        #self.assertAlmostEqual(order.total, Decimal('548.84'))
        # We use ROUND_HALF_UP now
        self.assertAlmostEqual(order.total, Decimal('548.85'))
        self.assertAlmostEqual(order.discount, Decimal('50.00'))

    def test_20_shipping_discount(self):
        """Test applying discounts to shipping too"""
        order_processors = plata.settings.PLATA_ORDER_PROCESSORS[:]
        plata.settings.PLATA_ORDER_PROCESSORS[-2] = 'plata.shop.processors.FixedAmountShippingProcessor'

        p1 = self.create_product()
        p2 = self.create_product()
        order = self.create_order()
        normal1 = order.modify_item(p1, 3, recalculate=False)
        normal2 = order.modify_item(p2, 5)

        self.assertAlmostEqual(order.total, Decimal('639.20') + 8)

        discount = Discount.objects.create(
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            code='d2',
            name='d2',
            value=Decimal('640.00'),
            is_active=True,
            tax_class=self.tax_class,
            currency='CHF',
            )

        discount.add_to(order)
        self.assertAlmostEqual(order.total, Decimal('7.20'))

        discount.value = Decimal('650.00')
        discount.add_to(order)
        self.assertAlmostEqual(order.total, Decimal('0.00'))

        plata.settings.PLATA_ORDER_PROCESSORS = order_processors[:]

    def test_22_tax_rounding(self):
        """Test tax rounding behavior"""

        p1 = self.create_product(stock=10)
        order = self.create_order()

        p1.prices.all().delete()
        p1.prices.create(
            _unit_price=Decimal('84.005'),
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class_germany,
            )

        order.modify_item(p1, absolute=1)

        self.assertEqual(order.total, Decimal('84.01'))


        p1.prices.all().delete()
        p1.prices.create(
            _unit_price=Decimal('84.0049999999'),
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class_germany,
            )

        order.modify_item(p1, absolute=1)

        self.assertEqual(order.total, Decimal('84.00'))


        p1.prices.all().delete()
        p1.prices.create(
            _unit_price=Decimal('84.0050000001'),
            tax_included=True,
            currency=order.currency,
            tax_class=self.tax_class_germany,
            )

        order.modify_item(p1, absolute=1)

        self.assertEqual(order.total, Decimal('84.01'))

    def test_23_mixed_tax(self):
        order_processors = plata.settings.PLATA_ORDER_PROCESSORS[:]
        plata.settings.PLATA_ORDER_PROCESSORS[-2] = 'plata.shop.processors.FixedAmountShippingProcessor'

        p1 = self.create_product(stock=10)
        p2 = self.create_product(stock=10)

        p2.name = 'Test 2'
        p2.save()

        p2.prices.all().delete()
        p2.prices.create(
            currency='CHF',
            tax_class=self.tax_class_something,
            _unit_price=Decimal('59.90'),
            tax_included=True,
            )

        order = self.create_order()

        order.modify_item(p1, 5)
        order.modify_item(p2, 5)

        self.assertEqual(order.items.count(), 2)
        self.assertAlmostEqual(order.total, Decimal('707.00'))

        tax_details = dict(order.data['tax_details'])

        # Two tax rates
        self.assertEqual(len(tax_details), 2)

        self.assertAlmostEqual(tax_details[Decimal('12.5')]['tax_amount'], Decimal('33.28'), 2)
        self.assertAlmostEqual(tax_details[Decimal('7.6')]['tax_amount'], Decimal('28.78'), 2)

        # Shipping has to be added here too; otherwise it should be 399.50
        self.assertAlmostEqual(tax_details[Decimal('7.6')]['total'], Decimal('407.50'))

        plata.settings.PLATA_ORDER_PROCESSORS = order_processors[:]

    def test_24_uninitialized_order(self):
        # This should not crash; generating a PDF exercises the methods
        # and properties of the order
        plata.reporting.order.invoice_pdf(PDFDocument(BytesIO()),
            Order.objects.create())

    def test_25_discount_validation(self):
        p1 = self.create_product(stock=10)

        discount = Discount.objects.create(
            is_active=True,
            type=Discount.PERCENTAGE_VOUCHER,
            code='asdf',
            name='Percentage discount',
            value=30)

        discount.save() # should not raise

        discount.type = Discount.AMOUNT_VOUCHER_EXCL_TAX
        self.assertRaises(ValidationError, lambda: discount.save())

        discount.currency = 'CHF'
        discount.save() # should not raise

        discount.tax_class = self.tax_class
        self.assertRaises(ValidationError, lambda: discount.save())

        discount.type = Discount.AMOUNT_VOUCHER_INCL_TAX
        discount.save() # should not raise

        discount.currency = None
        self.assertRaises(ValidationError, lambda: discount.save())

        discount.type = 42
        self.assertRaises(ValidationError, lambda: discount.save())

        discount.type = Discount.AMOUNT_VOUCHER_INCL_TAX
        discount.currency = 'EUR'
        discount.save()

        order = self.create_order()
        order.modify_item(p1, 3)

        self.assertRaises(ValidationError, lambda: discount.add_to(order))

        discount.currency = order.currency
        discount.save()

        discount.add_to(order) # should not raise

    def test_26_discounts(self):
        """Discount testing reloaded"""
        tax_class, tax_class_germany, tax_class_something = self.create_tax_classes()

        product = Product.objects.create(
            name='Ein Paar Hosen',
            )

        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('100.00'),
            tax_included=True,
            )

        order = self.create_order()

        normal1 = order.modify_item(product, 1)

        order.recalculate_total()
        self.assertAlmostEqual(order.total, Decimal('100'))

        # Discount for which real money has been paid. Tax applies to
        # full order total
        discount = Discount.objects.create(
            type=Discount.MEANS_OF_PAYMENT,
            code='asdf',
            name='Amount discount',
            value=Decimal('20.00'),
            is_active=True,
            currency='CHF',
            )
        discount.add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, Decimal('80.00'))
        self.assertAlmostEqual(order.subtotal, Decimal('100.00'))
        self.assertAlmostEqual(order.tax,
            Decimal('100.00') - Decimal('100.00') / (1 + tax_class.rate / 100),
            places=2)

        # Voucher from a magazine or something -- tax only applies to
        # discounted value
        discount.type = Discount.AMOUNT_VOUCHER_INCL_TAX
        discount.tax_class = tax_class
        discount.save()
        discount.add_to(order)
        order.recalculate_total()

        self.assertAlmostEqual(order.total, Decimal('80.00'))
        self.assertAlmostEqual(order.subtotal, Decimal('100.00'))
        self.assertAlmostEqual(order.tax,
            Decimal('80.00') - Decimal('80.00') / (1 + tax_class.rate / 100),
            places=2)

    def test_27_unicode_representations(self):
        product = Product.objects.create(name='Test Product',)
        order = self.create_order()
        orderitem = self.create_orderitem(product, order)

        self.assertEqual(unicode(orderitem),
                         u'1 of Test Product')
        orderstatus = OrderStatus.objects.create(order=order, status=Order.PAID)
        self.assertEqual(unicode(orderstatus),
                         u'Status Order has been paid for O-000000001')
        orderpayment = OrderPayment.objects.create(
            order=order, currency=100, amount=1,
            authorized=timezone.now())
        self.assertEqual(unicode(orderpayment),
                         u'Authorized of 100 1.00 for O-000000001')

    def test_28_order_items_without_products(self):
        """Test order items where the product foreign key is NULL"""
        tax_class, tax_class_germany, tax_class_something = self.create_tax_classes()
        product = self.create_product()
        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('100.00'),
            tax_included=True,
            )

        order = self.create_order()
        item = order.modify_item(product, absolute=5)
        self.assertAlmostEqual(order.total, Decimal('500.00'))
        item.product = None
        item.save()
        order.recalculate_total()
        self.assertAlmostEqual(order.total, Decimal('500.00'))

        # Modifying the price and adding products again does not change the old
        # order item
        product.prices.update(_unit_price=Decimal('50.00'))
        order.modify_item(product, absolute=3)
        self.assertAlmostEqual(order.total, Decimal('650.00'))
        self.assertEqual(order.items.count(), 2)

    def test_29_product_with_several_orderitems(self):
        """The same product several times in the same cart"""

        tax_class, tax_class_germany, tax_class_something = self.create_tax_classes()
        product = self.create_product()
        product.prices.create(
            currency='CHF',
            tax_class=tax_class,
            _unit_price=Decimal('100.00'),
            tax_included=True,
            )

        order = self.create_order()
        order.modify_item(product, relative=1)
        self.assertEqual(order.items.count(), 1)
        order.modify_item(product, relative=1, force_new=False)
        self.assertEqual(order.items.count(), 1)
        order.modify_item(product, relative=1, force_new=True)
        self.assertEqual(order.items.count(), 2)
        any_item = order.modify_item(product, relative=1, force_new=True)
        self.assertEqual(order.items.count(), 3)

        # Now that we have the same product in the cart several times, fail
        # when neither item nor force_new are given.
        self.assertRaises(
            ValidationError,
            order.modify_item,
            product,
            relative=1,
            force_new=False,
            )
        self.assertEqual(order.items.count(), 3)

        # Verify that it works if the item is passed directly
        order.modify_item(product, relative=10, item=any_item)
        self.assertEqual(order.items.count(), 3)
        self.assertEqual(any_item.quantity, 11)

    def test_30_serialization(self):
        """Test the serialization capabilities of the JSON field code"""

        order = self.create_order()

        def _compare(data):
            order.data = data
            order.save()
            reloaded_order = Order.objects.get(pk=order.pk)
            self.assertEqual(data, reloaded_order.data)

        import django
        if django.VERSION >= (1, 5):
            timezone_now = timezone.now
        else:
            # XXX Somehow, this testcase always fails with timezones in
            # Django 1.4, and I'm too lazy right now.
            timezone_now = datetime.now

        _compare({
            'the_answer': 42,
            'the_cost': Decimal('37.50'),
            })

        _compare({
            'now': datetime.now().replace(microsecond=0),
            'now_with_ms': datetime.now(),
            })

        _compare({
            'now_tz': timezone_now().replace(microsecond=0),
            'now_tz_with_ms': timezone_now(),
            })

        _compare({
            'today': date.today(),
            })

        _compare({
            'now_tz_with_ms': timezone_now().time(),
            'now_with_ms': datetime.now().time(),
            'now_tz': timezone_now().replace(microsecond=0).time(),
            'now': datetime.now().replace(microsecond=0).time(),
            })

        # Test the value_to_string method of the model field
        serialized = serialize('json', Order.objects.all())
        self.assertTrue(isinstance(serialized, basestring))
        self.assertTrue('"model": "shop.order"' in serialized)
        self.assertTrue('\\"now_tz_with_ms\\"' in serialized)

########NEW FILE########
__FILENAME__ = test_views
from io import BytesIO
import os
import re
import warnings

from datetime import timedelta

from django.conf import settings

try:  # pragma: no cover
  from django.contrib.auth import get_user_model
  User = get_user_model()
except ImportError, e:
  from django.contrib.auth.models import User

from django.core import mail
from django.core.exceptions import ValidationError
from django.utils import timezone

import plata
from plata.contact.models import Contact
from plata.discount.models import Discount
from plata.product.stock.models import Period, StockTransaction
from plata.shop.models import Order, OrderPayment

from .base import PlataTest, get_request


Product = plata.product_model()


class ViewTest(PlataTest):
    def setUp(self):
        self.ORIG_TEMPLATE_DIRS = settings.TEMPLATE_DIRS
        settings.TEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates'),)

    def tearDown(self):
        settings.TEMPLATE_DIRS = self.ORIG_TEMPLATE_DIRS

    def test_01_cart_empty(self):
        """Test cart is empty redirects work properly"""
        self.assertContains(self.client.get('/cart/'), 'Cart is empty')
        self.assertRedirects(self.client.get('/checkout/'), '/cart/')
        self.assertRedirects(self.client.get('/discounts/'), '/cart/')
        self.assertRedirects(self.client.get('/confirmation/'), '/cart/')

    def test_02_authenticated_user_has_contact(self):
        """Test shop.contact_from_user works correctly"""
        user = User.objects.create_user('test', 'test@example.com',
            'testing')
        self.client.login(username='test', password='testing')

        contact = Contact.objects.create(user=user)
        shop = plata.shop_instance()

        request = get_request(user=user)

        self.assertEqual(shop.contact_from_user(request.user), contact)

    def test_03_product_detail(self):
        """Test product detail view and cart handling methods"""
        # Removed everything -- the minimal add to cart form is really,
        # really stupid. Nothing to test here.

    def test_04_shopping(self):
        """Test shopping, checkout and order PDF generation in one go"""
        self.assertEqual(Order.objects.count(), 0)
        p1 = self.create_product()
        p2 = self.create_product()
        p2.name = 'Test Product 2'
        p2.save()

        p1.stock_transactions.create(type=StockTransaction.PURCHASE, change=100)
        p2.stock_transactions.create(type=StockTransaction.PURCHASE, change=100)
        self.assertEqual(Product.objects.filter(items_in_stock=0).count(), 0)

        self.assertContains(self.client.get(p1.get_absolute_url()),
            p1.name)

        self.client.post(p1.get_absolute_url(), {
            'quantity': 5,
            })
        self.client.post(p2.get_absolute_url(), {
            'quantity': 3,
            })

        self.assertEqual(Order.objects.count(), 1)
        self.assertContains(self.client.get('/cart/'), 'value="5"')

        order = Order.objects.all()[0]
        i1 = order.modify_item(p1, 0)
        i2 = order.modify_item(p2, 0)

        self.assertRedirects(self.client.post('/cart/', {
            'items-INITIAL_FORMS': 2,
            'items-TOTAL_FORMS': 2,
            'items-MAX_NUM_FORMS': 2,

            'items-0-id': i1.id,
            'items-0-quantity': 6, # one additional item

            'items-1-id': i2.id,
            'items-1-quantity': i2.quantity,
            }), '/cart/')

        self.assertEqual(order.modify_item(p1, 0).quantity, 6)

        self.assertRedirects(self.client.post('/cart/', {
            'checkout': True,

            'items-INITIAL_FORMS': 2,
            'items-TOTAL_FORMS': 2,
            'items-MAX_NUM_FORMS': 2,

            'items-0-id': i1.id,
            'items-0-quantity': 6, # one additional item

            'items-1-id': i2.id,
            'items-1-quantity': 0,
            }), '/checkout/')

        self.assertEqual(order.modify_item(p1, 0).quantity, 6)
        self.assertEqual(order.items.count(), 1)

        self.client.post(p2.get_absolute_url(), {
            'quantity': 5,
            })
        self.assertEqual(order.items.count(), 2)

        # TODO test what happens when a product has been deleted from the
        # shop in the meantime (and orderitem.product = None)

        self.assertEqual(Order.objects.get().status, Order.CART)
        self.assertRedirects(self.client.post('/cart/', {
            'checkout': True,

            'items-INITIAL_FORMS': 2,
            'items-TOTAL_FORMS': 2,
            'items-MAX_NUM_FORMS': 2,

            'items-0-id': i1.id,
            'items-0-quantity': 6,
            'items-0-DELETE': True,

            'items-1-id': i2.id,
            'items-1-quantity': 5,
            }), '/checkout/')
        self.assertEqual(order.items.count(), 1)

        self.client.get('/checkout/')
        self.assertEqual(Order.objects.get().status, Order.CHECKOUT)

        self.assertEqual(self.client.post('/checkout/', {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Hans',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            #'order-shipping_same_as_billing': True, # billing information is missing...
            'order-email': 'something@example.com',
            'order-currency': 'CHF',
            }).status_code, 200) # ... therefore view does not redirect

        self.assertRedirects(self.client.post('/checkout/', {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Hans',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            'order-shipping_same_as_billing': True,
            'order-email': 'something@example.com',
            'order-currency': 'CHF',
            'order-notes': 'Test\n\nJust testing.',
            }), '/confirmation/')

        Discount.objects.create(
            is_active=True,
            type=Discount.PERCENTAGE_VOUCHER,
            code='asdf',
            name='Percentage discount',
            value=30)

        self.assertContains(self.client.post('/discounts/', {
            'code': 'something-invalid',
            }), 'not validate')

        self.assertRedirects(self.client.post('/discounts/', {
            'code': 'asdf',
            }), '/discounts/')

        self.assertRedirects(self.client.post('/discounts/', {
            'proceed': 'True',
            }), '/confirmation/')

        self.assertEqual(self.client.post('/confirmation/', {}).status_code, 200)
        self.assertEqual(Order.objects.get(pk=order.id).status, Order.CHECKOUT)

        self.assertContains(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'postfinance',
            }), 'SHASign')

        self.assertContains(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'paypal',
            }), 'cgi-bin/webscr')

        self.assertRedirects(self.client.post(p2.get_absolute_url(), {
            'quantity': 42,
            }), '/cart/', target_status_code=302)
        self.assertRedirects(self.client.post('/cart/', {
            'items-INITIAL_FORMS': 1,
            'items-TOTAL_FORMS': 1,
            'items-MAX_NUM_FORMS': 1,

            'items-0-id': i2.id,
            'items-0-quantity': 43,
            'items-0-DELETE': False,
            }), '/confirmation/?confirmed=1')
        self.assertTrue(Order.objects.all()[0].items.get(product=p2).quantity != 42)

        # Test this view works at all
        self.client.get('/order/payment_failure/')

        self.assertEqual(len(mail.outbox), 0)
        self.assertRedirects(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'cod',
            }), '/order/success/')
        self.assertEqual(len(mail.outbox), 2) # invoice and packing slip
        self.assertEqual(Order.objects.get(pk=order.id).status, Order.PAID)

        # Clear order
        self.assertRedirects(self.client.get('/order/new/?next=%s' % p1.get_absolute_url()),
            p1.get_absolute_url())
        # Can call URL several times without change in behavior
        self.assertRedirects(self.client.get('/order/new/'), '/',
            target_status_code=302)

        # Cart is empty
        self.assertRedirects(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'cod',
            }), '/cart/')

        self.assertRedirects(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'paypal',
            }), '/cart/')

        user = User.objects.create_superuser('admin', 'admin@example.com', 'password')

        self.client.login(username='admin', password='password')
        self.assertEqual(self.client.get('/reporting/invoice_pdf/%s/' % order.id)['Content-Type'],
            'application/pdf')
        self.assertEqual(self.client.get('/reporting/packing_slip_pdf/%s/' % order.id)['Content-Type'],
            'application/pdf')
        self.assertEqual(self.client.get('/reporting/product_xls/')['Content-Type'],
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

    def test_05_creation(self):
        """Test creation of orders through the shop object"""
        shop = plata.shop_instance()
        request = get_request()

        order = shop.order_from_request(request)
        self.assertEqual(order, None)

        order = shop.order_from_request(request, create=True)
        self.assertEqual(Order.objects.count(), 1)
        self.assertEqual(order.user, None)

    def test_06_postfinance_ipn(self):
        """Test Postfinance server-to-server request handling"""
        shop = plata.shop_instance()
        request = get_request()

        product = self.create_product()

        Period.objects.create(name='Test period')
        product.stock_transactions.create(type=StockTransaction.PURCHASE, change=10)
        self.client.post(product.get_absolute_url(), {
            'quantity': 5,
            })

        response = self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'postfinance',
            })
        self.assertContains(response, 'SHASign')
        self.assertContains(response, '721735bc3876094bb7e5ff075de8411d85494a66')

        self.assertEqual(StockTransaction.objects.count(), 2)
        self.assertEqual(Order.objects.get().status, Order.CONFIRMED)
        self.assertEqual(OrderPayment.objects.count(), 1)

        self.client.get('/order/payment_failure/')
        # payment process reservation should have been removed now,
        # this does not change anything else though
        self.assertEqual(StockTransaction.objects.count(), 1)
        self.assertEqual(Order.objects.get().status, Order.CHECKOUT)

        self.assertContains(self.client.post('/payment/postfinance/ipn/', {
            }), 'Missing data', status_code=403)

        order = Order.objects.get(pk=1)

        ipn_data = {
            'orderID': 'Order-1-1',
            'currency': order.currency,
            'amount': order.balance_remaining,
            'PM': 'Postfinance',
            'ACCEPTANCE': 'xxx',
            'STATUS': '5', # Authorized
            'CARDNO': 'xxxxxxxxxxxx1111',
            'PAYID': '123456789',
            'NCERROR': '',
            'BRAND': 'VISA',
            'SHASIGN': 'this-value-is-invalid',
            }

        self.assertContains(self.client.post('/payment/postfinance/ipn/', ipn_data),
            'Hash did not validate', status_code=403)

        ipn_data['SHASIGN'] = '4b4cf5f9a5f0b54cc119be3696f43f81139232ae'

        self.assertContains(self.client.post('/payment/postfinance/ipn/', ipn_data),
            'OK', status_code=200)

        order = Order.objects.get(pk=1)
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self.assertTrue(order.is_paid())
            self.assertEqual(len(w), 1)
            self.assertTrue(
                'Order.is_paid() has been deprecated' in str(w[-1]))
        self.assertTrue(order.status >= Order.PAID)

        self.assertEqual(StockTransaction.objects.count(), 2)

        # Manipulate paid amount
        order.paid -= 10
        order.save()
        self.assertRedirects(self.client.get('/cart/'), '/confirmation/?confirmed=1')

        self.assertContains(self.client.get('/order/success/'),
            '<h1>Order has been partially paid.</h1>')

        # Revert manipulation
        order.paid += 10
        order.save()
        self.assertRedirects(self.client.get('/checkout/'), '/order/success/')

    def test_07_paypal_ipn(self):
        """Test PayPal Instant Payment Notification handler"""
        paypal_ipn_data = {
            'txn_id': '123456789',
            'invoice': 'Order-1-1',
            'mc_currency': 'CHF',
            'mc_gross': '1234',
            'payment_status': 'Completed',
            'last_name': u'H\xe5konsen',
        }

        from plata.payment.modules import paypal
        import cgi
        def mock_urlopen(*args, **kwargs):
            qs = cgi.parse_qs(args[1].encode('ascii'))
            self.assertEqual(qs['cmd'][0], '_notify-validate')
            for k, v in paypal_ipn_data.iteritems():
                self.assertEqual(unicode(qs[k][0], 'utf-8'), v)
            s = BytesIO('VERIFIED')
            return s
        paypal.urllib2.urlopen = mock_urlopen

        shop = plata.shop_instance()
        request = get_request()

        product = self.create_product()
        product.stock_transactions.create(type=StockTransaction.PURCHASE, change=10)
        self.client.post(product.get_absolute_url(), {
            'quantity': 5,
            })

        response = self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'paypal',
            })
        self.assertContains(response, 'sandbox')

        self.assertEqual(StockTransaction.objects.count(), 2)
        self.assertEqual(Order.objects.count(), 1)
        self.assertEqual(OrderPayment.objects.count(), 1)

        self.assertContains(
            self.client.post('/payment/paypal/ipn/', paypal_ipn_data),
            'Ok'
        )

        # test windows-1252 encoded IPN also:
        self.assertContains(
            self.client.post(
                '/payment/paypal/ipn/',
                dict(
                    map(
                        lambda (k,v): (k, v.encode('windows-1252')),
                        dict(paypal_ipn_data, charset='windows-1252').items()
                    )
                ),
            ),
            'Ok'
        )

        order = Order.objects.get(pk=1)
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self.assertTrue(order.is_paid())
            self.assertEqual(len(w), 1)
            self.assertTrue(
                'Order.is_paid() has been deprecated' in str(w[-1]))

        self.assertEqual(
            set((
                StockTransaction.PURCHASE,
                StockTransaction.SALE,
                StockTransaction.PAYMENT_PROCESS_RESERVATION,
            )), set(StockTransaction.objects.values_list('type', flat=True)))

    def test_08_checkout_preexisting_user(self):
        """Test checkout behavior using already existing user without contact"""
        User.objects.create_user('else', 'else@example.com', 'test')

        user = User.objects.create_user('test', 'test@example.com', 'test')
        self.client.login(username='test', password='test')

        p1 = self.create_product(stock=100)
        self.client.post(p1.get_absolute_url(), {'quantity': 5})

        response = self.client.get('/checkout/')
        self.assertContains(response, 'Checkout')
        self.assertNotContains(response, 'login-username')

        checkout_data = {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Hans',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            'order-shipping_same_as_billing': True,
            'order-email': 'else@example.com',
            'order-currency': 'CHF',
            'order-create_account': True,
            }

        self.assertContains(self.client.post('/checkout/', checkout_data),
            'This e-mail address belongs to a different account')

        self.assertEqual(len(mail.outbox), 0)
        checkout_data['order-email'] = 'something@example.com'
        self.assertRedirects(self.client.post('/checkout/', checkout_data),
            '/confirmation/')
        self.assertEqual(len(mail.outbox), 1)

        # There should be exactly one contact object now
        contact = Contact.objects.get()
        self.assertEqual(contact.user.orders.count(), 1)
        self.assertEqual(contact.billing_city, 'Beispielstadt')

        # User e-mail address is unchanged
        self.assertEqual(contact.user.email, 'test@example.com')

    def test_09_checkout_create_user(self):
        """Test checkout behavior without existing user or contact"""
        User.objects.create_user('else', 'else@example.com', 'test')

        p1 = self.create_product(stock=100)
        self.client.post(p1.get_absolute_url(), {'quantity': 5})

        response = self.client.get('/checkout/')
        self.assertContains(response, 'Checkout')
        self.assertContains(response, 'login-username')

        checkout_data = {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Hans',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            'order-shipping_same_as_billing': True,
            'order-email': 'else@example.com',
            'order-currency': 'CHF',
            'order-create_account': True,
            }

        self.assertContains(self.client.post('/checkout/', checkout_data),
            'This e-mail address might belong to you, but we cannot know for sure because you are not authenticated yet')

        self.assertEqual(len(mail.outbox), 0)
        checkout_data['order-email'] = 'something@example.com'
        self.assertRedirects(self.client.post('/checkout/', checkout_data),
            '/confirmation/')
        self.assertEqual(len(mail.outbox), 1)

        # There should be exactly one contact object now
        contact = Contact.objects.get()
        self.assertEqual(contact.user.orders.count(), 1)
        self.assertEqual(contact.billing_city, 'Beispielstadt')

        self.assertEqual(contact.user.email, 'something@example.com')

        # New order
        self.client.post(p1.get_absolute_url(), {'quantity': 5})
        response = self.client.get('/checkout/')

        self.assertContains(response, 'value="something@example.com"')
        self.assertContains(response, 'value="Beispielstadt"')

    def test_10_login_in_checkout_preexisting_contact(self):
        """Test checkout behavior using already existing contact and user"""
        Contact.objects.create(
            user=User.objects.create_user('else@example.com', 'else@example.com', 'test'),
            currency='CHF',
            billing_first_name='Hans',
            billing_last_name='Muster',
            )

        p1 = self.create_product(stock=100)
        self.client.post(p1.get_absolute_url(), {'quantity': 5})

        response = self.client.get('/checkout/')
        self.assertContains(response, 'Checkout')
        self.assertContains(response, 'login-username')

        self.assertRedirects(self.client.post('/checkout/', {
            '_login': 1,
            'login-username': 'else@example.com',
            'login-password': 'test',
            }), '/checkout/')

        # Test that the order is still active after logging in
        response = self.client.get('/checkout/')
        self.assertContains(response, 'value="else@example.com"')
        self.assertContains(response, 'value="Muster"')

        checkout_data = {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Fritz',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            'order-shipping_same_as_billing': True,
            'order-email': 'else@example.com',
            'order-currency': 'CHF',
            'order-create_account': True,
            }

        self.assertEqual(len(mail.outbox), 0)
        self.assertRedirects(self.client.post('/checkout/', checkout_data),
            '/confirmation/')
        self.assertEqual(len(mail.outbox), 0)

        contact = Contact.objects.get()
        # First name should be updated in checkout processing
        self.assertEqual(contact.billing_first_name, 'Fritz')
        self.assertEqual(unicode(contact), 'else@example.com') # Username

        # Order should be assigned to contact
        self.assertEqual(Order.objects.count(), 1)
        self.assertEqual(contact.user.orders.count(), 1)

    def test_11_login_in_checkout_create_contact(self):
        """Test checkout using already existing user, but no contact"""
        User.objects.create_user('else@example.com', 'else@example.com', 'test')

        p1 = self.create_product(stock=100)
        self.client.post(p1.get_absolute_url(), {'quantity': 5})

        response = self.client.get('/checkout/')
        self.assertContains(response, 'Checkout')
        self.assertContains(response, 'login-username')

        self.assertRedirects(self.client.post('/checkout/', {
            '_login': 1,
            'login-username': 'else@example.com',
            'login-password': 'test',
            }), '/checkout/')

        checkout_data = {
            '_checkout': 1,
            'order-billing_company': u'BigCorp',
            'order-billing_first_name': u'Fritz',
            'order-billing_last_name': u'Muster',
            'order-billing_address': u'Musterstrasse 42',
            'order-billing_zip_code': u'8042',
            'order-billing_city': u'Beispielstadt',
            'order-billing_country': u'CH',
            'order-shipping_same_as_billing': True,
            'order-email': 'else@example.com',
            'order-currency': 'CHF',
            'order-create_account': True,
            }

        # If order wasn't active after logging in anymore, this would not work
        self.assertRedirects(self.client.post('/checkout/', checkout_data),
            '/confirmation/')

        contact = Contact.objects.get()
        self.assertEqual(contact.billing_first_name, 'Fritz')

        # Order should be assigned to contact
        self.assertEqual(Order.objects.count(), 1)
        self.assertEqual(contact.user.orders.count(), 1)

    def test_12_insufficient_stock(self):
        """Test insufficient stock handling in checkout process"""
        p1 = self.create_product(stock=10)
        self.client.post(p1.get_absolute_url(), {'quantity': 9})

        p1.stock_transactions.create(type=StockTransaction.SALE, change=-5)

        response = self.client.get('/checkout/')
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['Location'], 'http://testserver/cart/?e=1')

        self.assertContains(self.client.get('/cart/'),
            'Not enough stock available for')

    def test_13_expired_reservation(self):
        """Test payment process reservation expiration"""
        p1 = self.create_product(stock=10)

        self.assertEqual(
            p1.__class__.objects.get(pk=p1.pk).items_in_stock,
            10)

        p1.stock_transactions.create(
            type=StockTransaction.PAYMENT_PROCESS_RESERVATION,
            change=-7)

        # Payment process reservation stock transactions should not modify
        # the items_in_stock field
        self.assertEqual(
            p1.__class__.objects.get(pk=p1.pk).items_in_stock,
            10)

        self.assertEqual(StockTransaction.objects.items_in_stock(p1), 10)
        self.assertEqual(StockTransaction.objects.items_in_stock(p1,
            include_reservations=True), 3)

        StockTransaction.objects.update(created=timezone.now()-timedelta(minutes=10))
        self.assertEqual(StockTransaction.objects.items_in_stock(p1), 10)
        self.assertEqual(StockTransaction.objects.items_in_stock(p1,
            include_reservations=True), 3)

        StockTransaction.objects.update(created=timezone.now()-timedelta(minutes=20))
        self.assertEqual(StockTransaction.objects.items_in_stock(p1,
            include_reservations=True), 10)
        self.assertEqual(StockTransaction.objects.items_in_stock(p1), 10)

        order = self.create_order()
        order.modify_item(p1, relative=5)
        order.validate(order.VALIDATE_ALL)

        StockTransaction.objects.update(created=timezone.now()-timedelta(minutes=10))
        self.assertRaises(ValidationError, order.validate, order.VALIDATE_ALL)

    def test_14_remaining_discount(self):
        """Test that a new discount is created when there is an amount remaining"""
        p1 = self.create_product(stock=10)
        self.client.post(p1.get_absolute_url(), {'quantity': 5})

        discount = Discount.objects.create(
            name='Testname',
            type=Discount.AMOUNT_VOUCHER_INCL_TAX,
            value=1000,
            config='{"all":{}}',
            tax_class=self.tax_class,
            currency='CHF',
            )

        self.assertRedirects(self.client.post('/discounts/', {
            'code': discount.code,
            'proceed': 'True',
            }), '/confirmation/')

        self.assertRedirects(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'cod',
            }), '/order/success/')

        self.assertEqual(Discount.objects.count(), 2)

        order = Order.objects.get()
        new_discount = Discount.objects.exclude(code=discount.code).get()

        self.assertAlmostEqual(
            discount.value - sum(item.subtotal for item in order.items.all()),
            new_discount.value * (1 + self.tax_class.rate / 100))

        self.client.get('/order/new/')

        self.client.post(p1.get_absolute_url(), {'quantity': 1})
        self.assertRedirects(self.client.post('/discounts/', {
            'code': new_discount.code,
            'proceed': 'True',
            }), '/confirmation/')

        self.assertRedirects(self.client.post('/confirmation/', {
            'terms_and_conditions': True,
            'payment_method': 'cod',
            }), '/order/success/')

        self.client.get('/order/new/')
        self.client.get('/order/new/') # Should not do anything the second time
        self.client.post(p1.get_absolute_url(), {'quantity': 1})
        self.assertContains(self.client.post('/discounts/', {
            'code': new_discount.code,
            'proceed': 'True',
            }), 'Allowed uses for this discount has already been reached.')

        # Stock transactions must be created for orders which are paid from the start
        # 10 purchase, -5 sale, -1 sale
        self.assertEqual(StockTransaction.objects.count(), 3)
        p1 = Product.objects.get(pk=p1.pk)
        self.assertEqual(p1.items_in_stock, 4)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.shortcuts import redirect

from plata.contact.models import Contact
from plata.discount.models import Discount
from plata.shop.models import Order
from plata.shop.views import Shop


admin.autodiscover()

shop = Shop(
    contact_model=Contact,
    order_model=Order,
    discount_model=Discount,
    )


urlpatterns = patterns('',
    url(r'^$', lambda request: redirect('plata_product_list')),
    url(r'', include(shop.urls)),
    url(r'^products/$', 'testapp.views.product_list',
        name='plata_product_list'),
    url(r'^products/(\d+)/$', 'testapp.views.product_detail',
        name='plata_product_detail'),
    url(r'^admin/', include(admin.site.urls)),
    url(r'^reporting/', include('plata.reporting.urls')),
)

########NEW FILE########
__FILENAME__ = views
from django import forms
from django.contrib import messages
from django.shortcuts import get_object_or_404, redirect, render
from django.utils.translation import ugettext_lazy as _
from django.views import generic

import plata
from testapp.models import Product


product_list = generic.ListView.as_view(
    queryset=Product.objects.all(),
    paginate_by=10,
    template_name='product/product_list.html',
    )


class OrderItemForm(forms.Form):
    quantity = forms.IntegerField(label=_('quantity'), initial=1,
        min_value=1, max_value=100)


def product_detail(request, pk):
    product = get_object_or_404(Product, pk=pk)

    if request.method == 'POST':
        form = OrderItemForm(request.POST)

        if form.is_valid():
            shop = plata.shop_instance()
            order = shop.order_from_request(request, create=True)
            try:
                order.modify_item(product, form.cleaned_data.get('quantity'))
                messages.success(request, _('The cart has been updated.'))
            except forms.ValidationError, e:
                if e.code == 'order_sealed':
                    [messages.error(request, msg) for msg in e.messages]
                else:
                    raise

            return redirect('plata_shop_cart')
    else:
        form = OrderItemForm()

    return render(request, 'product/product_detail.html', {
        'object': product,
        'form': form,
        })

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for testapp project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testapp.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
