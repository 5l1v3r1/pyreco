__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Plata documentation build configuration file
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

from __future__ import absolute_import, unicode_literals

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('..'))
os.environ['DJANGO_SETTINGS_MODULE'] = 'conf'

# -- Make Django shut up
SECRET_KEY = 'YAY'

# -- General configuration ----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'Towel'
copyright = '2010-2012, Feinheit GmbH and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
import towel

version = '.'.join(map(str, towel.VERSION))
# The full version, including alpha/beta/rc tags.
release = towel.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme_path = ['_theme']
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Toweldoc'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
latex_paper_size = 'a4'

# The font size ('10pt', '11pt' or '12pt').
latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples (source start
# file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'Towel.tex', 'Towel Documentation',
    'Feinheit GmbH and contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


intersphinx_mapping = {
    'http://docs.python.org/': None,
    'django': (
        'http://docs.djangoproject.com/en/dev/',
        'http://docs.djangoproject.com/en/dev/_objects/',
        ),
    }

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from os.path import abspath, dirname
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testapp.settings")

    sys.path.insert(0, dirname(dirname(abspath(__file__))))

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = api
from __future__ import absolute_import, unicode_literals

from functools import partial

from django import forms
from django.utils.six.moves import http_client
from django.views.decorators.csrf import csrf_exempt

from towel.api import (
    API, APIException, Resource, RequestParser, Serializer,
    serialize_model_instance)

from .models import Group, Person, EmailAddress, Message


class MessageForm(forms.ModelForm):
    class Meta:
        model = Message


class MessageResource(Resource):
    def post_list(self, request, *args, **kwargs):
        form = MessageForm(request.POST)
        if not form.is_valid():
            raise APIException('Validation failed', data={
                'form': form.errors,
            })

        message = form.save()
        data = self.api.serialize_instance(
            message,
            build_absolute_uri=request.build_absolute_uri,
        )
        return self.serialize_response(
            data,
            status=http_client.CREATED,
            headers={'Location': data['__uri__']})


def info(request, api):
    response = RequestParser().parse(request)
    if response:
        return response

    return Serializer().serialize(
        {
            'hello': 'World!',
            'method': request.method,
            'data': request.POST.copy(),
        },
        request=request,
        status=200,
        output_format=request.GET.get('format'),
    )


api_v1 = API('v1', decorators=[
    csrf_exempt,
])

api_v1.register(Group)
api_v1.register(
    Person,
    serializer=partial(serialize_model_instance, exclude=('is_active',)),
)
api_v1.register(EmailAddress)
api_v1.register(
    Message,
    view_class=MessageResource,
)

api_v1.add_view(info)

########NEW FILE########
__FILENAME__ = models
from __future__ import absolute_import, unicode_literals

from django.db import models
from django.utils.encoding import python_2_unicode_compatible
from django.utils.timezone import now

from towel import deletion
from towel.managers import SearchManager
from towel.modelview import ModelViewURLs
from towel.resources.urls import model_resource_urls


class Group(models.Model):
    name = models.CharField(max_length=100)


class PersonManager(SearchManager):
    search_fields = ('family_name', 'given_name')


@python_2_unicode_compatible
class Person(models.Model):
    RELATIONSHIP_CHOICES = (
        ('', 'unspecified'),
        ('single', 'single'),
        ('relation', 'in a relationship'),
        ('married', 'married'),
        ('divorced', 'divorced'),
    )

    created = models.DateTimeField(default=now)
    is_active = models.BooleanField(default=True)
    family_name = models.CharField(max_length=100)
    given_name = models.CharField(max_length=100)
    relationship = models.CharField(
        max_length=20, blank=True,
        choices=RELATIONSHIP_CHOICES)
    groups = models.ManyToManyField(Group, related_name='members')

    objects = PersonManager()
    urls = ModelViewURLs(lambda obj: {'pk': obj.pk})

    class Meta:
        ordering = ['family_name', 'given_name']

    def __str__(self):
        return '%s %s' % (self.given_name, self.family_name)

    def get_absolute_url(self):
        return self.urls['detail']


class EmailManager(SearchManager):
    search_fields = ('person__family_name', 'person__given_name', 'email')


class EmailAddress(deletion.Model):
    person = models.ForeignKey(Person)
    email = models.EmailField()

    objects = EmailManager()
    urls = ModelViewURLs(lambda obj: {'pk': obj.pk})

    class Meta:
        ordering = ['email']
        verbose_name = 'email address'
        verbose_name_plural = 'email addresses'

    def __str__(self):
        return self.email

    def get_absolute_url(self):
        return self.urls['detail']


class Message(models.Model):
    """
    This model is used to test the behavior of
    ``save_formset_deletion_allowed_if_only``. The presence of message
    instances should protect email addresses from getting deleted.
    """
    sent_to = models.ForeignKey(EmailAddress)
    message = models.TextField()

    # No get_absolute_url method on purpose; is automatically added by
    # ModelView


class ResourceManager(SearchManager):
    search_fields = ('name',)


@model_resource_urls()
class Resource(models.Model):
    name = models.CharField(max_length=100)
    is_active = models.BooleanField(default=True)

    objects = ResourceManager()

    def __str__(self):
        return self.name

########NEW FILE########
__FILENAME__ = resources
from __future__ import absolute_import, unicode_literals

from django import forms
from django.conf.urls import patterns
from django.contrib import messages

from towel.forms import SearchForm
from towel.resources.urls import resource_url_fn

from testapp.models import Resource


class ResourceSearchForm(SearchForm):
    is_active = forms.NullBooleanField(required=False)


class ResourceViewMixin(object):
    def get_queryset(self):
        return super(ResourceViewMixin, self).get_queryset().select_related(
            'user')

    def allow_delete(self, object=None, silent=True):
        if object is None:
            return True
        return self.allow_delete_if_only(object, silent=silent)

    def get_batch_actions(self):
        return super(ResourceViewMixin, self).get_batch_actions() + [
            ('set_active', 'Set active', self.set_active),
        ]

    def set_active(self, queryset):
        class SetActiveForm(forms.Form):
            is_active = forms.NullBooleanField()

        if 'confirm' in self.request.POST:
            form = SetActiveForm(self.request.POST)
            if form.is_valid():
                is_active = form.cleaned_data['is_active']
                updated = queryset.update(is_active=is_active)
                messages.success(
                    self.request, '%s have been updated.' % updated)
                return queryset

        else:
            form = SetActiveForm()

        self.template_name_suffix = '_action'
        # context = resources.ModelResourceView.get_context_data(self,
        context = self.get_context_data(
            title='Set active',
            form=form,
            action_queryset=queryset,
            action_hidden_fields=self.batch_action_hidden_fields(queryset, [
                ('batch-action', 'set_active'),
                ('confirm', 1),
            ]),
        )
        return self.render_to_response(context)


resource_url = resource_url_fn(
    Resource,
    mixins=(ResourceViewMixin,),
    decorators=(),
)


urlpatterns = patterns(
    '',
    resource_url(
        'list',
        url=r'^$',
        paginate_by=5,
        search_form=ResourceSearchForm,
    ),
    resource_url('detail', url=r'^(?P<pk>\d+)/$'),
    resource_url('add', url=r'^add/$'),
    resource_url('edit'),
    resource_url('delete'),
)

########NEW FILE########
__FILENAME__ = settings
from __future__ import absolute_import, unicode_literals

import os

SITE_ID = 1

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
}

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.staticfiles',
    'django.contrib.messages',
    'towel',
    'testapp',
]

MEDIA_ROOT = '/media/'
STATIC_URL = '/static/'
BASEDIR = os.path.dirname(__file__)
MEDIA_ROOT = os.path.join(BASEDIR, 'media/')
STATIC_ROOT = os.path.join(BASEDIR, 'static/')
SECRET_KEY = 'supersikret'

ROOT_URLCONF = 'testapp.urls'
LANGUAGES = (('en', 'English'), ('de', 'German'))
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',
    'django.core.context_processors.request',
    'django.contrib.messages.context_processors.messages',
)

########NEW FILE########
__FILENAME__ = testapp_tags
from __future__ import absolute_import, unicode_literals

from django import template

from towel.utils import parse_args_and_kwargs, resolve_args_and_kwargs


register = template.Library()


@register.tag
def testtag(parser, token):
    return TestNode(
        *parse_args_and_kwargs(parser, token.split_contents()[1:]))


class TestNode(template.Node):
    def __init__(self, args, kwargs):
        self.args = args
        self.kwargs = kwargs

    def render(self, context):
        args, kwargs = resolve_args_and_kwargs(context, self.args, self.kwargs)

        return 'ARGS: %s\nKWARGS: %s\n' % (
            ','.join(str(arg) for arg in args),
            ','.join('%s=%s' % (k, v) for k, v in sorted(kwargs.items())),
        )

########NEW FILE########
__FILENAME__ = test_api
from __future__ import absolute_import, print_function, unicode_literals

import json

from django.core.urlresolvers import NoReverseMatch
from django.test import TestCase

from towel.api import api_reverse

from testapp.models import Group, Person, Message


class APITest(TestCase):
    def setUp(self):
        for i in range(100):
            person = Person.objects.create(
                given_name='Given %s' % i,
                family_name='Family %s' % i,
            )
            person.emailaddress_set.create(email='test%s@example.com' % i)
        self.api = self.get_json('/api/v1/')

    def get_json(self, uri, status_code=200):
        try:
            response = self.client.get(
                uri,
                HTTP_ACCEPT='application/json',
            )
            self.assertEqual(response.status_code, status_code)
            return json.loads(response.content.decode('utf-8'))
        except ValueError:
            print(uri, response.status_code, response.content)

    def test_info(self):
        self.assertEqual(self.client.get('/api/v1/').status_code, 406)
        response = self.client.get(
            '/api/v1/',
            HTTP_ACCEPT='application/json',
        )
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.content.decode('utf-8'))

        self.assertEqual(data['__str__'], 'v1')
        self.assertEqual(data['__uri__'], 'http://testserver/api/v1/')
        self.assertEqual(len(data['resources']), 4)
        self.assertEqual(
            data['person']['__uri__'],
            'http://testserver/api/v1/person/')
        self.assertEqual(
            data['emailaddress']['__uri__'],
            'http://testserver/api/v1/emailaddress/')
        self.assertEqual(
            data['message']['__uri__'],
            'http://testserver/api/v1/message/')
        self.assertEqual(
            data['group']['__uri__'],
            'http://testserver/api/v1/group/')

        self.assertEqual(len(data['views']), 1)

    def test_list_detail(self):
        person_uri = self.api['person']['__uri__']
        data = self.get_json(person_uri)

        self.assertEqual(len(data['objects']), 20)
        self.assertEqual(data['meta'], {
            'limit': 20,
            'next': 'http://testserver/api/v1/person/?limit=20&offset=20',
            'offset': 0,
            'previous': None,
            'total': 100,
        })

        first = Person.objects.order_by('id')[0]
        first_person = data['objects'][0]
        correct = {
            'id': first.pk,
            '__pk__': first.pk,
            '__pretty__': {
                'relationship': 'unspecified',
            },
            '__str__': 'Given 0 Family 0',
            '__uri__': 'http://testserver/api/v1/person/%s/' % first.pk,
            'family_name': 'Family 0',
            'given_name': 'Given 0',
            'relationship': '',
        }

        for key, value in correct.items():
            self.assertEqual(first_person[key], value)
        self.assertTrue('is_active' not in first_person)

        self.assertEqual(
            len(self.get_json(person_uri + '?limit=100')['objects']),
            100,
        )
        self.assertEqual(
            len(self.get_json(person_uri + '?limit=200')['objects']),
            100,
        )
        self.assertEqual(
            len(self.get_json(person_uri + '?limit=100&offset=50')['objects']),
            50,
        )

        data = self.get_json(first_person['__uri__'] + '?full=1')
        for key, value in correct.items():
            self.assertEqual(data[key], value)

        data = self.get_json(self.api['emailaddress']['__uri__'])
        first_email = data['objects'][0]
        self.assertEqual(data['meta']['total'], 100)
        self.assertEqual(first_email['email'], 'test0@example.com')

        data = self.get_json(first_email['__uri__'])
        self.assertEqual(data['person'], first_person['__uri__'])

        data = self.get_json(first_email['__uri__'] + '?full=1')
        self.assertEqual(data['person'], first_person)

        # Sets
        persons = ';'.join(
            str(person.pk) for person in Person.objects.all()[:5])
        data = self.get_json(person_uri + '%s/' % persons)

        self.assertFalse('meta' in data)
        self.assertEqual(len(data['objects']), 5)

        self.assertEqual(
            self.get_json(person_uri + '0;/', status_code=404),
            {'error': 'Some objects do not exist.'},
        )
        self.assertEqual(
            self.get_json(person_uri + '0/', status_code=404),
            {'error': 'No Person matches the given query.'},
        )

    def test_http_methods(self):
        response = self.client.options('/api/v1/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Allow'], 'GET, HEAD, OPTIONS')

        response = self.client.post('/api/v1/')
        self.assertEqual(response.status_code, 406)

        response = self.client.options(self.api['person']['__uri__'])
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Allow'], 'GET, HEAD, OPTIONS')

        response = self.client.post(
            '/api/v1/person/',
            HTTP_ACCEPT='application/json',
        )
        self.assertEqual(response.status_code, 405)

    def test_post_message(self):
        person = Person.objects.create()
        emailaddress = person.emailaddress_set.create()

        response = self.client.post('/api/v1/message/')
        self.assertEqual(response.status_code, 406)

        response = self.client.post('/api/v1/message/', {
        }, HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(response.status_code, 400)
        self.assertEqual(data['error'], 'Validation failed')
        self.assertEqual(
            data['form']['message'],
            ['This field is required.'])
        self.assertEqual(
            data['form']['sent_to'],
            ['This field is required.'])

        response = self.client.post('/api/v1/message/', {
            'message': 'Blabla',
            'sent_to': emailaddress.pk,
        }, HTTP_ACCEPT='application/json')
        self.assertEqual(response.status_code, 201)
        message = Message.objects.get()
        data = self.get_json(response['Location'])
        self.assertEqual(data['__pk__'], message.pk)

        response = self.client.post('/api/v1/message/', json.dumps({
            'message': 'Blabla',
            'sent_to': emailaddress.pk,
        }), 'application/json', HTTP_ACCEPT='application/json')
        self.assertEqual(response.status_code, 201)
        message = Message.objects.latest('pk')
        data = self.get_json(response['Location'])
        self.assertEqual(data['__pk__'], message.pk)

        self.assertEqual(Message.objects.count(), 2)

    def test_unsupported_content_type(self):
        response = self.client.post('/api/v1/message/', {
        })

        response = self.client.post(
            '/api/v1/message/',
            'blabla',
            'application/octet-stream',  # Unsupported
            HTTP_ACCEPT='application/json',
        )
        self.assertEqual(response.status_code, 415)

    def test_info_view(self):
        response = self.client.get(
            '/api/v1/info/',
            HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(data['hello'], 'World!')
        self.assertEqual(data['method'], 'GET')

        response = self.client.post('/api/v1/info/', {
            'bla': 'blaaa',
        }, HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(data['data']['bla'], 'blaaa')

        response = self.client.post('/api/v1/info/', json.dumps({
            'bla': 'blaaa',
        }), 'application/json', HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(data['data']['bla'], 'blaaa')

        response = self.client.put('/api/v1/info/', json.dumps({
            'bla': 'blaaa',
        }), 'application/json', HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(data['method'], 'PUT')
        self.assertEqual(data['data']['bla'], 'blaaa')

        response = self.client.delete(
            '/api/v1/info/',
            HTTP_ACCEPT='application/json')
        data = json.loads(response.content.decode('utf-8'))
        self.assertEqual(data['method'], 'DELETE')

    def test_api_reverse(self):
        person = Person.objects.create()
        self.assertEqual(
            api_reverse(Person, 'list', api_name='v1'),
            '/api/v1/person/',
        )
        self.assertEqual(
            api_reverse(Person, 'detail', api_name='v1', pk=person.pk),
            '/api/v1/person/%s/' % person.pk,
        )
        self.assertEqual(
            api_reverse(person, 'detail', api_name='v1', pk=person.pk),
            '/api/v1/person/%s/' % person.pk,
        )
        self.assertTrue(
            api_reverse(Person, 'set', api_name='v1', pks='2;3;4') in (
                '/api/v1/person/2;3;4/',
                '/api/v1/person/2%3B3%3B4/',  # Django 1.6 upwards does this
            )
        )
        self.assertEqual(
            api_reverse(
                Person, 'sets', api_name='v1', pks='2;3;4',
                fail_silently=True),
            None,
        )
        self.assertRaises(
            NoReverseMatch,
            api_reverse, Person, 'sets', api_name='v1', pks='2;')

    def test_serialization(self):
        person = Person.objects.order_by('id')[0]
        group = Group.objects.create(
            name='grouup',
        )
        person.groups.add(group)
        person.emailaddress_set.create(email='another@example.com')

        person_uri = api_reverse(
            person, 'detail', api_name='v1', pk=person.id)

        self.assertEqual(person.groups.count(), 1)
        self.assertEqual(person.emailaddress_set.count(), 2)

        data = self.get_json(person_uri)
        self.assertEqual(data['given_name'], 'Given 0')
        self.assertEqual(data['family_name'], 'Family 0')
        self.assertFalse('emailaddress_set' in data)
        self.assertFalse('groups' in data)

        data = self.get_json(person_uri + '?full=1')
        self.assertTrue('emailaddress_set' in data)
        self.assertTrue('groups' in data)

        data = self.get_json(self.api['group']['__uri__'])
        self.assertEqual(
            len(data['objects']),
            1)
        group_uri = data['objects'][0]['__uri__']

        data = self.get_json(group_uri)
        self.assertEqual(data['name'], 'grouup')
        self.assertFalse('members' in data)

        data = self.get_json(group_uri + '?full=1')
        self.assertEqual(data['name'], 'grouup')
        self.assertTrue('members' in data)
        self.assertEqual(len(data['members']), 1)

########NEW FILE########
__FILENAME__ = test_deletion
from __future__ import absolute_import, unicode_literals

from django.test import TestCase

from towel import deletion

from testapp.models import Person, EmailAddress


class DeletionTest(TestCase):
    def test_deletion(self):
        person = Person.objects.create()

        email = person.emailaddress_set.create()
        self.assertEqual(EmailAddress.objects.count(), 1)
        email.delete()
        self.assertEqual(EmailAddress.objects.count(), 0)
        email = person.emailaddress_set.create()
        self.assertEqual(EmailAddress.objects.count(), 1)
        with deletion.protect():
            email.delete()
        self.assertEqual(EmailAddress.objects.count(), 1)
        email.delete()
        self.assertEqual(EmailAddress.objects.count(), 0)

########NEW FILE########
__FILENAME__ = test_forms
from __future__ import absolute_import, unicode_literals

from datetime import timedelta

from django.core.urlresolvers import reverse
from django.test import TestCase
from django.utils import timezone

from testapp.models import Person, Message


class FormsTest(TestCase):
    def test_warningsform(self):
        person = Person.objects.create()
        emailaddress = person.emailaddress_set.create()

        self.assertEqual(
            self.client.get(person.urls['message']).status_code,
            200)
        self.assertEqual(
            self.client.post(person.urls['message']).status_code,
            200)

        response = self.client.post(person.urls['message'], {
            'sent_to': emailaddress.pk,
            'message': 'Hallo Welt',
        })
        self.assertRedirects(response, person.urls['detail'])
        self.assertEqual(Message.objects.count(), 1)

        response = self.client.post(person.urls['message'], {
            'sent_to': emailaddress.pk,
            'message': '   ',
        })
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Please review the following warnings:')

        response = self.client.post(person.urls['message'], {
            'sent_to': emailaddress.pk,
            'message': '   ',
            'ignore_warnings': 1,
        })
        self.assertRedirects(response, person.urls['detail'])
        self.assertEqual(Message.objects.count(), 2)

    def test_searchform(self):
        date = timezone.now().replace(year=2012, month=10, day=1)

        for i in range(100):
            Person.objects.create(
                given_name='Given %s' % i,
                family_name='Family %s' % i,
                is_active=bool(i % 3),
                created=date + timedelta(days=i),
            )

        list_url = reverse('testapp_person_list')

        self.assertContains(
            self.client.get(list_url),
            '<span>1 - 5 / 100</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=42'),
            '<span>1 - 1 / 1</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=is:active'),
            '<span>1 - 5 / 66</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=is:inactive'),
            '<span>1 - 5 / 34</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=active:yes'),
            '<span>1 - 5 / 66</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=active:off'),
            '<span>1 - 5 / 34</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query=year:2012'),
            '<span>1 - 5 / 92</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query="Given+1"+year%3A2012'),
            '<span>1 - 5 / 11</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query="%2BGiven+1"+year%3A2012'),
            '<span>1 - 5 / 11</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?query="-Given+1"+year%3A2012'),
            '<span>1 - 5 / 81</span>',
        )

        # Form field
        self.assertContains(
            self.client.get(list_url + '?is_active=1'),
            '<span>1 - 5 / 100</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?is_active=2'),
            '<span>1 - 5 / 66</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?is_active=3'),
            '<span>1 - 5 / 34</span>',
        )

        # Invalid query
        self.assertRedirects(
            self.client.get(list_url + '?created__year=abc'),
            list_url + '?clear=1',
        )

        # Mixed quick (only inactive) and form field (only active)
        # Form field takes precedence
        self.assertContains(
            self.client.get(list_url + '?is_active=2&query=is:inactive'),
            '<span>1 - 5 / 66</span>',
        )

        # Search form persistence
        self.assertContains(
            self.client.get(list_url + '?s=1&is_active=3'),
            '<span>1 - 5 / 34</span>',
        )
        self.assertContains(
            self.client.get(list_url),
            '<span>1 - 5 / 34</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?clear=1'),
            '<span>1 - 5 / 100</span>',
        )

        # Ordering
        self.assertContains(
            self.client.get(list_url),
            'Given 0 Family 0',
        )
        response = self.client.get(list_url + '?o=name')
        self.assertContains(response, 'Given 12 Family 12')
        self.assertContains(
            response,
            '<a class="ordering desc" href="?&o=-name"> name</a>')
        self.assertContains(
            response,
            '<a class="ordering " href="?&o=is_active"> is active</a>')

        response = self.client.get(list_url + '?o=-name')
        self.assertContains(response, 'Given 99 Family 99')
        self.assertContains(
            response,
            '<a class="ordering asc" href="?&o=name"> name</a>')
        self.assertContains(
            response,
            '<a class="ordering " href="?&o=is_active"> is active</a>')
        response = self.client.get(list_url + '?o=is_active')
        self.assertContains(response, 'Given 14 Family 14')
        self.assertNotContains(response, 'Given 12 Family 12')  # inactive
        self.assertContains(
            response,
            '<a class="ordering " href="?&o=name"> name</a>')
        self.assertContains(
            response,
            '<a class="ordering desc" href="?&o=-is_active"> is active</a>')

        # TODO multiple choice fields
        # TODO SearchForm.default


# TODO autocompletion widget tests?

########NEW FILE########
__FILENAME__ = test_modelview
from __future__ import absolute_import, unicode_literals

from django.core.urlresolvers import reverse
from django.utils.encoding import force_text
from django.test import TestCase

from testapp.models import Person, EmailAddress, Message


class ModelViewTest(TestCase):
    def test_list_view(self):
        for i in range(7):
            p = Person.objects.create(family_name='Family %r' % i)

        # paginate_by=5
        self.assertContains(
            self.client.get('/persons/'),
            'name="batch_', 5)
        self.assertContains(
            self.client.get('/persons/?page=2'),
            'name="batch_', 2)
        # Invalid page number -> first page
        self.assertContains(
            self.client.get('/persons/?page=abc'),
            'name="batch_', 5)
        # Empty page -> last page
        self.assertContains(
            self.client.get('/persons/?page=42'),
            'name="batch_', 2)
        # Everything
        self.assertContains(
            self.client.get('/persons/?all=1'),
            'name="batch_', 7)

        self.assertContains(
            self.client.get(p.get_absolute_url()),
            'Family 6')
        self.assertEqual(self.client.get('/persons/0/').status_code, 404)
        self.assertEqual(self.client.get('/persons/a/').status_code, 404)

    def test_crud(self):
        self.assertContains(self.client.get('/persons/add/'), '<form', 1)
        self.assertEqual(
            self.client.post('/persons/add/', {
                'family_name': '',
                'given_name': '',
                'emails-TOTAL_FORMS': 0,
                'emails-INITIAL_FORMS': 0,
                'emails-MAX_NUM_FORMS': 10,
            }).status_code,
            200)
        self.assertEqual(
            self.client.post('/persons/add/', {
                # Should not validate because of StrippedTextInput
                'family_name': ' ',
                'given_name': ' ',
                'emails-TOTAL_FORMS': 0,
                'emails-INITIAL_FORMS': 0,
                'emails-MAX_NUM_FORMS': 10,
            }).status_code,
            200)
        response = self.client.post('/persons/add/', {
            'family_name': 'Blub',
            'given_name': 'Blab',
            'emails-TOTAL_FORMS': 0,
            'emails-INITIAL_FORMS': 0,
            'emails-MAX_NUM_FORMS': 10,
        })
        person = Person.objects.get()
        self.assertRedirects(response, person.get_absolute_url())
        self.assertContains(
            self.client.get(person.get_absolute_url()),
            'Blab Blub')

        self.assertContains(
            self.client.get(person.urls['edit']),
            '<form', 1)
        response = self.client.post(person.urls['edit'], {
            'family_name': 'Blub',
            'given_name': 'Blabbba',
            'emails-TOTAL_FORMS': 0,
            'emails-INITIAL_FORMS': 0,
            'emails-MAX_NUM_FORMS': 10,
        })
        self.assertRedirects(response, person.get_absolute_url())
        self.assertContains(
            self.client.get(person.get_absolute_url()),
            'Blabbba Blub')

        # We still only have one person in the database
        self.assertEqual(force_text(Person.objects.get()), 'Blabbba Blub')

        # Open the deletion page
        response = self.client.get(person.urls['delete'])
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Person.objects.count(), 1)
        self.assertRedirects(
            self.client.post(person.urls['delete']),
            '/persons/')
        self.assertEqual(Person.objects.count(), 0)

    def test_crud_formsets(self):
        response = self.client.post('/persons/add/', {
            'family_name': 'Blub',
            'given_name': 'Blab',
            'emails-TOTAL_FORMS': 1,
            'emails-INITIAL_FORMS': 0,
            'emails-MAX_NUM_FORMS': 10,
            'emails-0-email': 'test@example.com',
        })
        person = Person.objects.get()
        emailaddress = person.emailaddress_set.get()
        self.assertEqual(emailaddress.email, 'test@example.com')

        # Deleting the person should not work because of the email addresses
        self.assertRedirects(
            self.client.get(person.urls['delete']),
            person.urls['detail'])
        response = self.client.post(person.urls['delete'])
        self.assertRedirects(response, person.urls['detail'])
        # Nothing has been deleted
        self.assertEqual(Person.objects.count(), 1)
        self.assertTrue(
            ('Deletion not allowed: There are email addresses related'
                ' to this object.') in str(response.cookies))

        # Add another email address
        self.assertRedirects(
            self.client.post(person.urls['edit'], {
                'family_name': 'Blub',
                'given_name': 'Blab',
                'emails-TOTAL_FORMS': 2,
                'emails-INITIAL_FORMS': 1,
                'emails-MAX_NUM_FORMS': 10,
                'emails-0-email': 'test1@example.com',
                'emails-0-id': emailaddress.id,
                'emails-1-email': 'test2@example.com',
            }),
            person.urls['detail'],
        )

        self.assertEqual(
            sorted(person.emailaddress_set.values_list('email', flat=True)),
            ['test1@example.com', 'test2@example.com'],
        )

        emailaddresses = list(person.emailaddress_set.order_by('id'))
        emailaddresses[0].message_set.create(message='Save me')

        # Try deleting both email addresses; deleting the first should fail
        # because of bound message instances.
        self.assertRedirects(
            self.client.post(person.urls['edit'], {
                'family_name': 'Blubbber',
                'given_name': 'Blab',
                'emails-TOTAL_FORMS': 2,
                'emails-INITIAL_FORMS': 2,
                'emails-MAX_NUM_FORMS': 10,
                'emails-0-email': 'test1@example.com',
                'emails-0-id': emailaddresses[0].id,
                'emails-0-DELETE': 1,
                'emails-1-email': 'test2@example.com',
                'emails-1-id': emailaddresses[1].id,
                'emails-1-DELETE': 1,
            }),
            person.urls['detail'],
        )

        self.assertEqual(
            sorted(person.emailaddress_set.values_list('email', flat=True)),
            ['test1@example.com'],
        )
        # However, editing the person instance should have succeeded
        self.assertContains(
            self.client.get(person.urls['detail']),
            'Blab Blubbber')

    def test_modelviewurls(self):
        person = Person.objects.create()

        self.assertEqual(
            person.urls['detail'],
            '/persons/%s/' % person.pk)
        self.assertEqual(
            person.urls['edit'],
            '/persons/%s/edit/' % person.pk)
        self.assertEqual(
            person.urls['delete'],
            '/persons/%s/delete/' % person.pk)
        self.assertEqual(
            person.urls['list'],
            '/persons/')

        self.assertEqual(reverse('testapp_person_list'), '/persons/')
        self.assertEqual(
            reverse('testapp_person_detail', kwargs={'pk': person.pk}),
            person.get_absolute_url(),
        )

    def test_emailaddress_views(self):
        emailaddress = EmailAddress.objects.create(
            person=Person.objects.create(
                given_name='Testa',
                family_name='Testi',
            ),
            email='test@example.com',
        )

        response = self.client.get(emailaddress.get_absolute_url())
        self.assertContains(response, 'Testa Testi')
        # <title>, <h2>, <table>
        self.assertContains(response, 'test@example.com', 3)
        self.assertContains(
            response,
            reverse('testapp_person_detail', kwargs={
                'pk': emailaddress.person_id,
            }),
        )

        list_url = reverse('testapp_emailaddress_list')

        response = self.client.get(list_url)
        self.assertContains(
            response,
            '<a href="/emailaddresses/%s/">test@example.com</a>' % (
                emailaddress.pk))
        self.assertContains(
            response,
            '<a href="/persons/%s/">Testa Testi</a>' % emailaddress.person_id)

        for i in range(10):
            EmailAddress.objects.create(
                person=Person.objects.create(
                    given_name='Testa',
                    family_name='Testi',
                    is_active=bool(i % 2),
                ),
                email='test%s@example.com' % i,
            )

        # The EmailAddressSearchForm defaults to only showing email addresses
        # of active persons.
        self.assertContains(
            self.client.get(list_url),
            '<span>1 - 5 / 6</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?person__is_active=1'),
            '<span>1 - 5 / 11</span>',
        )
        self.assertContains(
            self.client.get(list_url + '?person__is_active=3'),
            '<span>1 - 5 / 5</span>',
        )

        # Multiple choice it up a bit.
        self.assertContains(
            self.client.get(
                list_url +
                '?person__relationship=married&person__relationship=divorced',
            ),
            '<span>0 - 0 / 0</span>',
        )

    def test_batchform(self):
        for i in range(20):
            Person.objects.create(
                given_name='Given %s' % i,
                family_name='Family %s' % i,
            )

        self.assertContains(
            self.client.get('/persons/'),
            '<span>1 - 5 / 20</span>')

        response = self.client.post('/persons/', {
            'batchform': 1,
        })
        self.assertEqual(response.status_code, 200)
        self.assertContains(
            response,
            '<ul class="errorlist"><li>No items selected</li></ul>')

        self.assertEqual(Person.objects.filter(is_active=False).count(), 0)
        data = {
            'batchform': 1,
            'batch-is_active': 3,
        }
        for pk in Person.objects.values_list('id', flat=True)[:3]:
            data['batch_%s' % pk] = pk
        response = self.client.post('/persons/', data)
        self.assertRedirects(response, '/persons/')

        cookies = str(response.cookies)
        self.assertTrue('3 have been updated.' in cookies)
        self.assertTrue('Given 0 Family 0' in cookies)
        self.assertTrue('Given 1 Family 1' in cookies)
        self.assertTrue('Given 10 Family 10' in cookies)
        self.assertEqual(Person.objects.filter(is_active=False).count(), 3)

    def test_automatic_get_absolute_url(self):
        self.client.get('/messages/')

        self.assertTrue(hasattr(Message, 'get_absolute_url'))
        message = Message.objects.create(
            sent_to=EmailAddress.objects.create(
                person=Person.objects.create()
            ),
        )

        self.assertEqual(
            message.get_absolute_url(),
            '/messages/%s/' % message.pk)

########NEW FILE########
__FILENAME__ = test_mt
# TODO towel.mt tests

########NEW FILE########
__FILENAME__ = test_quick
from __future__ import absolute_import, unicode_literals

from datetime import date, timedelta
import re

from django.test import TestCase

from towel import quick

from testapp.models import Person


QUICK_RULES = [
    (re.compile(r'!!'), quick.static(important=True)),
    (re.compile(r'@(?P<family_name>\w+)'),
        quick.model_mapper(
            Person.objects.filter(is_active=True), 'assigned_to')),
    (re.compile(r'\^\+(?P<due>\d+)'),
        lambda v: {'due': date.today() + timedelta(days=int(v['due']))}),
    (re.compile(r'\^(?P<due>[^\s]+)'),
        quick.due_mapper('due')),
    (re.compile(r'=(?P<estimated_hours>[\d\.]+)h'),
        quick.identity()),
    (re.compile(r'relationship:\((?P<value>[^\)]*)\)'),
        quick.model_choices_mapper(
            Person.RELATIONSHIP_CHOICES, 'relationship')),
]


class QuickTest(TestCase):
    def test_parse_quickadd(self):
        data, rest = quick.parse_quickadd('', QUICK_RULES)
        self.assertEqual(list(data.items()), [])
        self.assertEqual(rest, [])

        data, rest = quick.parse_quickadd('!! do this do that', QUICK_RULES)
        self.assertEqual(list(data.items()), [('important', True)])
        self.assertEqual(' '.join(rest), 'do this do that')

        p_muster = Person.objects.create(family_name='Muster')
        Person.objects.create(family_name='Blaa')
        Person.objects.create()
        data, rest = quick.parse_quickadd('@Muster Phone call !!', QUICK_RULES)
        self.assertEqual(data['assigned_to'], p_muster.pk)
        self.assertEqual(data['assigned_to_'], p_muster)
        self.assertEqual(data['important'], True)
        self.assertEqual(rest, ['Phone', 'call'])

        data, rest = quick.parse_quickadd('@Unknown Phone', QUICK_RULES)
        self.assertTrue('assigned_to' not in data)
        self.assertEqual(rest, ['Phone'])
        # XXX Stop dropping unknowns?

        self.assertEqual(
            quick.parse_quickadd('^+3', QUICK_RULES)[0]['due'],
            date.today() + timedelta(days=3),
        )
        self.assertEqual(
            quick.parse_quickadd('^+42', QUICK_RULES)[0]['due'],
            date.today() + timedelta(days=42),
        )
        self.assertEqual(
            quick.parse_quickadd('^Today', QUICK_RULES)[0]['due'],
            date.today() + timedelta(days=0),
        )
        self.assertEqual(
            quick.parse_quickadd('^Tomorrow', QUICK_RULES)[0]['due'],
            date.today() + timedelta(days=1),
        )
        for name in (
                'Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,'
                'Sunday'.split(',')):
            due = quick.parse_quickadd('^%s' % name, QUICK_RULES)[0]['due']
            self.assertTrue(
                date.today() <= due < date.today() + timedelta(days=7))

        self.assertEqual(
            quick.parse_quickadd('=0.3h', QUICK_RULES)[0]['estimated_hours'],
            '0.3',
        )
        self.assertEqual(
            quick.parse_quickadd('=10.3h', QUICK_RULES)[0]['estimated_hours'],
            '10.3',
        )
        self.assertEqual(
            quick.parse_quickadd('=37h', QUICK_RULES)[0]['estimated_hours'],
            '37',
        )

        self.assertEqual(
            quick.parse_quickadd(
                'relationship:(unspecified)',
                QUICK_RULES)[0]['relationship'],
            '',
        )
        self.assertEqual(
            quick.parse_quickadd(
                'relationship:(married)',
                QUICK_RULES)[0]['relationship'],
            'married',
        )
        self.assertEqual(
            quick.parse_quickadd(
                'relationship:(in a relationship)',
                QUICK_RULES)[0]['relationship'],
            'relation',
        )
        self.assertTrue(
            'relation' not in quick.parse_quickadd(
                'relationship:(stupidity)', QUICK_RULES)[0])

########NEW FILE########
__FILENAME__ = test_resources
from __future__ import absolute_import, unicode_literals

from django.core.urlresolvers import reverse
from django.utils.encoding import force_text
from django.test import TestCase

from testapp.models import Resource


class ResourceTest(TestCase):
    def test_list_view(self):
        for i in range(7):
            r = Resource.objects.create(name='Resource {0}'.format(i))

        # paginate_by=5
        self.assertContains(
            self.client.get('/resources/'),
            'name="batch_', 5)
        self.assertContains(
            self.client.get('/resources/?page=2'),
            'name="batch_', 2)
        # Invalid page number -> first page
        self.assertContains(
            self.client.get('/resources/?page=abc'),
            'name="batch_', 5)
        # Empty page -> last page
        self.assertContains(
            self.client.get('/resources/?page=42'),
            'name="batch_', 2)

        self.assertContains(
            self.client.get(r.get_absolute_url()),
            'Resource 6')
        self.assertEqual(self.client.get('/resources/0/').status_code, 404)
        self.assertEqual(self.client.get('/resources/a/').status_code, 404)

    def test_crud(self):
        self.assertContains(self.client.get('/resources/add/'), '<form', 1)
        self.assertEqual(
            self.client.post('/resources/add/', {
                'name': '',
            }).status_code,
            200)
        self.assertEqual(
            self.client.post('/resources/add/', {
                # Should not validate because of StrippedTextInput
                'name': ' ',
            }).status_code,
            200)
        response = self.client.post('/resources/add/', {
            'name': 'Blub',
        })
        resource = Resource.objects.get()
        self.assertRedirects(response, resource.get_absolute_url())
        self.assertContains(
            self.client.get(resource.get_absolute_url()),
            'Blub')

        self.assertContains(
            self.client.get(resource.urls['edit']),
            '<form', 1)
        response = self.client.post(resource.urls['edit'], {
            'name': 'Blabbba',
        })
        self.assertRedirects(response, resource.get_absolute_url())
        self.assertContains(
            self.client.get(resource.get_absolute_url()),
            'Blabbba')

        # We still only have one resource in the database
        self.assertEqual(force_text(Resource.objects.get()), 'Blabbba')

        # Open the deletion page
        response = self.client.get(resource.urls['delete'])
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Resource.objects.count(), 1)
        self.assertRedirects(
            self.client.post(resource.urls['delete']),
            '/resources/')
        self.assertEqual(Resource.objects.count(), 0)

    def test_modelviewurls(self):
        resource = Resource.objects.create()

        self.assertEqual(
            resource.urls['detail'],
            '/resources/%s/' % resource.pk)
        self.assertEqual(
            resource.urls['edit'],
            '/resources/%s/edit/' % resource.pk)
        self.assertEqual(
            resource.urls['delete'],
            '/resources/%s/delete/' % resource.pk)
        self.assertEqual(
            resource.urls['list'],
            '/resources/')

        self.assertEqual(reverse('testapp_resource_list'), '/resources/')
        self.assertEqual(
            reverse('testapp_resource_detail', kwargs={'pk': resource.pk}),
            resource.get_absolute_url(),
        )

    def test_batchform(self):
        for i in range(20):
            Resource.objects.create(
                name='Resource %s' % i,
            )

        self.assertContains(
            self.client.get('/resources/'),
            '<span>1 - 5 / 20</span>')

        response = self.client.post('/resources/', {
            'batchform': 1,
        })
        self.assertEqual(response.status_code, 200)
        self.assertContains(
            response,
            '<ul class="errorlist"><li>No items selected</li></ul>')

        self.assertEqual(Resource.objects.filter(is_active=False).count(), 0)
        data = {
            'batchform': 1,
            'batch-action': 'set_active',
        }
        for pk in Resource.objects.values_list('id', flat=True)[:3]:
            data['batch_%s' % pk] = pk
        response = self.client.post('/resources/', data)
        self.assertContains(response, 'Set active')
        self.assertContains(
            response,
            '<option value="1" selected="selected">Unknown</option>')
        data['confirm'] = 1
        data['is_active'] = 3
        response = self.client.post('/resources/', data)
        self.assertRedirects(response, '/resources/')

        cookies = str(response.cookies)
        self.assertTrue('3 have been updated.' in cookies)
        self.assertTrue('Resource 0' in cookies)
        self.assertTrue('Resource 1' in cookies)
        self.assertTrue('Resource 2' in cookies)
        self.assertEqual(Resource.objects.filter(is_active=False).count(), 3)

########NEW FILE########
__FILENAME__ = test_utils
from __future__ import absolute_import, unicode_literals

from django.template import Template, Context
from django.test import TestCase

from towel.utils import (
    related_classes, safe_queryset_and, tryreverse, substitute_with)

from testapp.models import Person, EmailAddress


class UtilsTest(TestCase):
    def test_related_classes(self):
        """Test the functionality of towel.utils.related_classes"""
        person = Person.objects.create(
            family_name='Muster',
            given_name='Hans',
        )
        EmailAddress.objects.create(
            person=person,
            email='hans@example.com',
        )

        self.assertEqual(
            set(related_classes(person)),
            set((Person, EmailAddress)),
        )

    def test_safe_queryset_and(self):
        class AnyException(Exception):
            pass

        def _transform_nothing(queryset):
            raise AnyException

        qs1 = EmailAddress.objects.search('blub').transform(
            _transform_nothing).select_related()
        qs2 = EmailAddress.objects.distinct().reverse().select_related(
            'person')
        qs3 = EmailAddress.objects.all()

        qs = safe_queryset_and(safe_queryset_and(qs1, qs2), qs3)

        self.assertEqual(qs._transform_fns, [_transform_nothing])
        self.assertFalse(qs.query.standard_ordering)
        self.assertEqual(qs.query.select_related, {'person': {}})
        self.assertTrue(qs.query.distinct)
        self.assertEqual(qs.count(), 0)
        self.assertRaises(AnyException, list, qs)

        qs = safe_queryset_and(
            EmailAddress.objects.select_related(),
            EmailAddress.objects.select_related(),
        )

        self.assertTrue(qs.query.select_related)
        self.assertFalse(qs.query.distinct)

        qs = safe_queryset_and(
            EmailAddress.objects.all(),
            EmailAddress.objects.select_related(),
        )

        self.assertTrue(qs.query.select_related)

    def test_tryreverse(self):
        self.assertEqual(tryreverse('asdf42'), None)
        self.assertEqual(tryreverse('admin:index'), '/admin/')

    def test_substitute_with(self):
        p1 = Person.objects.create()
        p2 = Person.objects.create()

        p1.emailaddress_set.create()
        p1.emailaddress_set.create()
        p1.emailaddress_set.create()
        p2.emailaddress_set.create()
        p2.emailaddress_set.create()

        self.assertEqual(Person.objects.count(), 2)
        self.assertEqual(EmailAddress.objects.count(), 5)

        substitute_with(p1, p2)

        p = Person.objects.get()
        self.assertEqual(p2, p)
        self.assertEqual(EmailAddress.objects.count(), 5)

    def test_template_tag_helpers(self):
        testcases = [
            ('', ''),
            ('{% testtag %}', 'ARGS: KWARGS:'),
            ('{% testtag 3 4 5 %}', 'ARGS: 3,4,5 KWARGS:'),
            ('{% testtag 3 "4" 5 %}', 'ARGS: 3,4,5 KWARGS:'),
            ('{% testtag abcd "42" %}', 'ARGS: yay,42 KWARGS:'),
            ('{% testtag "abcd" "42" %}', 'ARGS: abcd,42 KWARGS:'),
            ('{% testtag "abcd" "42" a=b %}', 'ARGS: abcd,42 KWARGS: a='),
            ('{% testtag "abcd" a="b" "42" %}', 'ARGS: abcd,42 KWARGS: a=b'),
            ('{% testtag bla="blub" blo="blob" %}',
                'ARGS: KWARGS: bla=blub,blo=blob'),
            ('{% testtag bla=blub blo="blob" %}',
                'ARGS: KWARGS: bla=blubber,blo=blob'),
        ]

        for test, result in testcases:
            t = Template('{% load testapp_tags %}' + test)
            self.assertHTMLEqual(t.render(Context({
                'abcd': 'yay',
                'bla': 'blaaa',
                'blub': 'blubber',
            })), result)

########NEW FILE########
__FILENAME__ = urls
from __future__ import absolute_import, unicode_literals

from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.contrib.staticfiles.urls import staticfiles_urlpatterns

from .api import api_v1
from .views import person_views, emailaddress_views, message_views


admin.autodiscover()


urlpatterns = patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^api/v1/', include(api_v1.urls)),
    url(r'^persons/', include(person_views.urls)),
    url(r'^emailaddresses/', include(emailaddress_views.urls)),
    url(r'^messages/', include(message_views.urls)),

    url(r'^resources/', include('testapp.resources')),
) + staticfiles_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import, unicode_literals

import re

from django import forms
from django.contrib import messages
from django.shortcuts import redirect

from towel import quick
from towel.forms import BatchForm, SearchForm, WarningsForm
from towel.modelview import ModelView

from .models import Person, EmailAddress, Message


class PersonBatchForm(BatchForm):
    is_active = forms.NullBooleanField()

    def process(self):
        if self.cleaned_data.get('is_active') is not None:
            updated = self.batch_queryset.update(
                is_active=self.cleaned_data['is_active'])
            messages.success(self.request, '%s have been updated.' % updated)

        return self.batch_queryset


class PersonSearchForm(SearchForm):
    orderings = {
        'name': ('family_name', 'given_name'),
        'is_active': ('-is_active', 'family_name'),
    }

    quick_rules = [
        (re.compile(r'^is:active$'),
            quick.static(is_active=True)),
        (re.compile(r'^is:inactive$'),
            quick.static(is_active=False)),
        (re.compile(r'^active:(?P<bool>\w+)$'),
            quick.bool_mapper('is_active')),
        (re.compile(r'^year:(?P<year>\d{4})$'),
            lambda values: {'created__year': values['year']}),
    ]
    created__year = forms.IntegerField(required=False)
    is_active = forms.NullBooleanField(required=False)


class PersonForm(forms.ModelForm):
    class Meta:
        model = Person
        fields = ('family_name', 'given_name')


class MessageForm(forms.ModelForm, WarningsForm):
    class Meta:
        model = Message

    def __init__(self, *args, **kwargs):
        person = kwargs.pop('person')
        super(MessageForm, self).__init__(*args, **kwargs)
        self.fields['sent_to'].queryset = person.emailaddress_set.all()

    def clean(self):
        data = super(MessageForm, self).clean()

        if not data.get('message', '').strip():
            self.add_warning('Only spaces in message, really send?')

        return data


class PersonModelView(ModelView):
    def additional_urls(self):
        return (
            (r'^%(detail)s/message/$', self.message),
        )

    def deletion_allowed(self, request, instance):
        return self.deletion_allowed_if_only(request, instance, [Person])

    def save_formsets(self, request, form, formsets, change):
        self.save_formset_deletion_allowed_if_only(
            request, form, formsets['emails'], change, [EmailAddress])

    def message(self, request, *args, **kwargs):
        instance = self.get_object_or_404(request, *args, **kwargs)

        if request.method == 'POST':
            form = MessageForm(request.POST, person=instance)

            if form.is_valid():
                form.save()
                return redirect(instance)

        else:
            form = MessageForm(person=instance)

        return self.render(
            request,
            self.get_template(request, 'form'),
            self.get_context(request, {
                self.template_object_name: instance,
                'form': form,
            }),
        )


person_views = PersonModelView(
    Person,
    search_form=PersonSearchForm,
    search_form_everywhere=True,
    batch_form=PersonBatchForm,
    form_class=PersonForm,
    paginate_by=5,
    inlineformset_config={
        'emails': {'model': EmailAddress},
    },
)


class EmailAddressSearchForm(SearchForm):
    default = {
        'person__is_active': True,
        'person__relationship': ('', 'single'),
    }
    person__is_active = forms.NullBooleanField(required=False)
    person__relationship = forms.MultipleChoiceField(
        required=False, choices=Person.RELATIONSHIP_CHOICES)


emailaddress_views = ModelView(
    EmailAddress,
    paginate_by=5,
    search_form=EmailAddressSearchForm,
)


message_views = ModelView(
    Message,
    paginate_by=5,
)

########NEW FILE########
__FILENAME__ = api
from __future__ import absolute_import, unicode_literals

from django.core.urlresolvers import NoReverseMatch, reverse
from django.conf.urls import patterns, include, url
from django.db import models
from django.db.models.related import RelatedObject
from django.http import HttpResponse
from django.utils.encoding import force_text
from django.utils.functional import curry
from django.utils.six.moves import http_client
from django.views.decorators.csrf import csrf_exempt

from towel.utils import app_model_label
from .base import api_reverse
from .resources import Resource
from .serializers import Serializer


class API(object):
    """
    This is the main API object. It does not do much except give an overview
    over all resources. It will hold the necessary bits to have more than one
    API with the same models or resources at the same time (f.e. versions).

    Usage::

        # ... other imports ...
        from functools import partial
        from towel.api import API, serialize_model_instance

        api_v1 = API('v1')

        # Customize serialization: Never include phone numbers and email
        # addresses of customers in API output.
        api_v1.register(
            Customer,
            serializer=partial(serialize_model_instance,
                exclude=('phone', 'email')),
            view_init={
                'queryset': Customer.objects.filter(is_active=True),
                })

        api_v1.register(
            Product,
            view_init={
                'queryset': Product.objects.filter(is_active=True)
                })

        api_v1.register(
            Product,
            canonical=False,
            prefix=r'^library/',
            view_class=LibraryResource,
            view_init={
                'queryset': Product.objects.filter(is_active=True),
                })

        urlpatterns = patterns('',
            url(r'^v1/', include(api_v1.urls)),
        )

    With authentication::

        api_v2 = API('v2', decorators=[csrf_exempt, login_required])

        # register resources as before
    """

    def __init__(self, name, decorators=[csrf_exempt]):
        self.name = name
        self.decorators = decorators

        self.resources = []
        self.serializers = {}
        self.views = []

        self.default_serializer = serialize_model_instance

    @property
    def urls(self):
        """
        Inclusion point in your own URLconf

        Usage::

            from .views import api_v1

            urlpatterns = patterns('',
                url(r'^api/v1/', include(api_v1.urls)),
            )
        """

        def view(request):
            return self.root(request)
        for dec in reversed(self.decorators):
            view = dec(view)

        urlpatterns = [
            url(r'^$', view, name='api_%s' % self.name),
        ]

        for view in self.views:
            urlpatterns.append(url(view['prefix'], view['view']))

        for resource in self.resources:
            urlpatterns.append(url(
                resource['prefix'],
                include(resource['urlpatterns']),
            ))

        return patterns('', *urlpatterns)

    def root(self, request):
        """
        Main API view, returns a list of all available resources
        """
        if request.method == 'OPTIONS':
            response = HttpResponse()
            response['Allow'] = 'GET, HEAD, OPTIONS'
            response['Content-Length'] = 0
            return response

        elif request.method not in ('GET', 'HEAD'):
            return Serializer().serialize(
                {
                    'error': 'Not acceptable',
                },
                request=request,
                status=http_client.METHOD_NOT_ALLOWED,
                output_format=request.GET.get('format'),
            )

        response = {
            '__str__': self.name,
            '__uri__': request.build_absolute_uri(
                reverse('api_%s' % self.name)),
            'resources': [],
        }

        for view in self.views:
            response.setdefault('views', []).append({
                '__str__': view['prefix'].strip('^').strip('/'),
                '__uri__': request.build_absolute_uri(''.join((
                    response['__uri__'],
                    view['prefix'].strip('^')))),
            })

        for resource in self.resources:
            r = {
                '__str__': resource['model'].__name__.lower(),
                '__uri__': request.build_absolute_uri(''.join((
                    response['__uri__'],
                    resource['prefix'].strip('^')))),
            }

            response['resources'].append(r)
            if resource['canonical']:
                response[resource['model'].__name__.lower()] = r

        return Serializer().serialize(
            response,
            request=request,
            output_format=request.GET.get('format'))

    def register(self, model, view_class=None, canonical=True,
                 decorators=None, prefix=None, view_init=None,
                 serializer=None):
        """
        Registers another resource on this API. The sole required argument is
        the Django model which should be exposed. The other arguments are:

        - ``view_class``: The resource view class used, defaults to
          :class:`towel.api.Resource`.
        - ``canonical``: Whether this resource is the canonical location of
          the model in this API. Allows registering the same model several
          times in the API (only one location should be the canonical
          location!)
        - ``decorators``: A list of decorators which should be applied to the
          view. Function decorators only, method decorators aren't supported.
          The list is applied in reverse, the order is therefore the same as
          with the ``@`` notation. If unset, the set of decorators is
          determined from the API initialization. Pass an empty list if you
          want no decorators at all. Otherwise API POSTing will have to
          include a valid CSRF middleware token.
        - ``prefix``: The prefix for this model, defaults to the model name in
          lowercase. You should include a caret and a trailing slash if you
          specify this yourself (``prefix=r'^library/'``).
        - ``view_init``: Python dictionary which contains keyword arguments
          used during the instantiation of the ``view_class``.
        - ``serializer``: Function which takes a model instance, the API
          instance and additional keyword arguments (accept ``**kwargs`` for
          forward compatibility) and returns the serialized representation as
          a Python dict.
        """

        view_class = view_class or Resource
        view_init = view_init or {}

        if 'model' not in view_init:
            if 'queryset' in view_init:
                view_init['model'] = view_init['queryset'].model
            else:
                view_init['model'] = model

        view = view_class.as_view(api=self, **view_init)

        name = lambda ident: None
        if canonical:
            name = lambda ident: '_'.join(
                (self.name,) + app_model_label(model) + (ident,))

        if decorators is None:
            decorators = self.decorators

        if decorators:
            for dec in reversed(decorators):
                view = dec(view)

        self.resources.append({
            'model': model,
            'canonical': canonical,
            'prefix': prefix or r'^%s/' % model.__name__.lower(),
            'urlpatterns': patterns('', *[
                url(regex, view, data, name=name(suffix))
                for regex, suffix, data in view_class.urls
            ]),
        })

        if serializer:
            self.serializers[model] = serializer

    def set_default_serializer(self, serializer):
        """
        By default, ``serialize_model_instance`` is used to serialize models.
        This can be changed by passing a different function to this method.
        """
        self.default_serializer = serializer

    def serialize_instance(self, instance, **kwargs):
        """
        Returns a serialized version of the passed model instance

        This method should always be used for serialization, because it knows
        about custom serializers specified when registering resources with
        this API.
        """
        serializer = self.serializers.get(
            instance.__class__,
            self.default_serializer)
        return serializer(instance, api=self, **kwargs)

    def add_view(self, view, prefix=None, decorators=None):
        """
        Add custom views to this API

        The prefix is automatically determined if not given based on the
        function name.

        The view receives an additional keyword argument ``api`` containing
        the API instance.
        """

        prefix = prefix or r'^%s/' % view.__name__

        if decorators is None:
            decorators = self.decorators

        view = curry(view, api=self)
        for dec in reversed(decorators):
            view = dec(view)

        self.views.append({
            'prefix': prefix,
            'view': view,
        })


def serialize_model_instance(instance, api, inline_depth=0,
                             fields=(), exclude=(), only_registered=True,
                             build_absolute_uri=lambda uri: uri,
                             **kwargs):
    """
    Serializes a single model instance.

    If ``inline_depth`` is a positive number, ``inline_depth`` levels of
    related objects are inlined. The performance implications of this feature
    might be severe! Note: Additional arguments specified when calling
    ``serialize_model_instance`` such as ``exclude``, ``only_registered`` and
    further keyword arguments are currently **not** forwarded to inlined
    objects. Those parameters should be set upon resource registration time as
    documented in the ``API`` docstring above.

    The ``fields`` and ``exclude`` parameters are especially helpful when used
    together with ``functools.partial``.

    Set ``only_registered=False`` if you want to serialize models which do not
    have a canonical URI inside this API.

    ``build_absolute_uri`` should be a callable which transforms any passed
    URI fragment into an absolute URI including the protocol and the hostname,
    for example ``request.build_absolute_uri``.

    This implementation has a few characteristics you should be aware of:

    - Only objects which have a canonical URI inside this particular API are
      serialized; if no such URI exists, this method returns ``None``. This
      behavior can be overridden by passing ``only_registered=False``.
    - Many to many relations are only processed if ``inline_depth`` has a
      positive value. The reason for this design decision is that the database
      has to be queried for showing the URIs of related objects anyway and
      because of that we either show the full objects or nothing at all.
    - Some fields (currently only fields with choices) have a machine readable
      and a prettified value. The prettified values are delivered inside the
      ``__pretty__`` dictionary for your convenience.
    - The primary key of the model instance is always available as
      ``__pk__``.
    """

    # It's not exactly a fatal error, but it helps during development. This
    # statement will disappear in the future.
    assert not kwargs, 'Unknown keyword arguments to serialize_model_instance'

    uri = api_reverse(
        instance, 'detail', api_name=api.name, pk=instance.pk,
        fail_silently=True)

    if uri is None and only_registered:
        return None

    data = {
        '__uri__': build_absolute_uri(uri),
        '__str__': force_text(instance),
        '__pretty__': {},
        '__pk__': instance.pk,
    }
    opts = instance._meta

    for f_name in opts.get_all_field_names():
        f, model, direct, m2m = opts.get_field_by_name(f_name)

        if fields and f.name not in fields:
            continue

        if f.name in exclude:
            continue

        # TODO maybe check before querying the database whether the objects
        # are included in the API or only_registered=False?

        if isinstance(f, (models.ManyToManyField, RelatedObject)):
            if inline_depth > 0:
                is_relobj = isinstance(f, RelatedObject)
                name = f.get_accessor_name() if is_relobj else f.name

                if is_relobj and not f.field.rel.multiple:
                    try:
                        obj = getattr(instance, name)
                    except models.ObjectDoesNotExist:
                        obj = None

                    data[name] = api.serialize_instance(
                        obj,
                        inline_depth=inline_depth - 1,
                        build_absolute_uri=build_absolute_uri,
                        only_registered=only_registered,
                    ) if obj else None
                else:
                    related = [api.serialize_instance(
                        obj,
                        inline_depth=inline_depth - 1,
                        build_absolute_uri=build_absolute_uri,
                        only_registered=only_registered,
                    ) for obj in getattr(instance, name).all()]
                    if any(related):
                        data[name] = related

        elif f.rel:
            value = f.value_from_object(instance)
            if value is None:
                data[f.name] = None
                continue

            try:
                data[f.name] = build_absolute_uri(api_reverse(
                    f.rel.to,
                    'detail',
                    api_name=api.name,
                    pk=f.value_from_object(instance)))
            except NoReverseMatch:
                if only_registered:
                    continue

            if inline_depth > 0:
                related = getattr(instance, f.name)

                if related:
                    # XXX What about only_registered, kwargs? Should they be
                    # passed to other calls as well, or should we assume that
                    # customization can only happen using functools.partial
                    # upon registration time?
                    data[f.name] = api.serialize_instance(
                        related,
                        inline_depth=inline_depth - 1,
                        build_absolute_uri=build_absolute_uri,
                        only_registered=only_registered,
                    )

        elif isinstance(f, models.FileField):
            try:
                value = f.value_from_object(instance)
                data[f.name] = build_absolute_uri(value.url)
            except ValueError:
                data[f.name] = ''

        else:
            data[f.name] = f.value_from_object(instance)

            if f.flatchoices:
                data['__pretty__'][f.name] = force_text(
                    dict(f.flatchoices).get(data[f.name], '-'))

    return data

########NEW FILE########
__FILENAME__ = base
from __future__ import absolute_import, unicode_literals

from django.core.urlresolvers import NoReverseMatch, reverse
from django.utils.six.moves import http_client

from towel.utils import app_model_label


class APIException(Exception):
    """
    Custom exception which signals a problem detected somewhere inside
    the API machinery.

    Usage::

        # Use official W3C error names from ``httplib.responses``
        raise ClientError(status=httplib.NOT_ACCEPTABLE)

    or::

        raise ServerError('Not implemented, go away',
            status=httplib.NOT_IMPLEMENTED)

    Additional information can be passed through by setting the ``data``
    argument to a dict instance. The :py:exc:`~towel.api.APIException` handler
    will merge the dict into the default error data and return everything
    to the client::

        raise APIException('Validation failed', data={
            'form': form.errors,
            })
    """

    #: The default response is '400 Bad request'
    default_status = http_client.BAD_REQUEST

    def __init__(self, error_message=None, status=None, data={}):
        super(Exception, self).__init__(error_message)

        self.status = self.default_status if status is None else status
        if error_message is None:
            self.error_message = http_client.responses.get(self.status, '')
        else:
            self.error_message = error_message

        self.data = data


def api_reverse(model, ident, api_name='api', fail_silently=False, **kwargs):
    """
    Determines the canonical URL of API endpoints for arbitrary models

    ``model`` is the Django model you want to use, ident should be one of
    ``list``, ``set`` or ``detail`` at the moment, additional keyword arguments
    are forwarded to the ``django.core.urlresolvers.reverse`` call.

    Usage::

        api_reverse(Product, 'detail', pk=42)

    Passing an instance works too::

        api_reverse(instance, 'detail', pk=instance.pk)
    """
    try:
        return reverse(
            '_'.join(
                (api_name,) + app_model_label(model) + (ident,)),
            kwargs=kwargs)
    except NoReverseMatch:
        if fail_silently:
            return None
        raise

########NEW FILE########
__FILENAME__ = decorators
from __future__ import absolute_import, unicode_literals

from functools import wraps

from django.contrib.auth import authenticate
from django.http import HttpResponse
from django.utils.six.moves import http_client
from django.views.decorators.vary import vary_on_headers


def http_basic_auth(func):
    @wraps(func)
    @vary_on_headers('Authorization')
    def _decorator(request, *args, **kwargs):
        if 'HTTP_AUTHORIZATION' in request.META:
            meth, _, auth = request.META['HTTP_AUTHORIZATION'].partition(' ')
            if meth.lower() == 'basic':
                try:
                    auth = auth.strip().decode('base64')
                except Exception:  # binascii.Error, really.
                    return HttpResponse(
                        'Invalid authorization header',
                        status=http_client.BAD_REQUEST)

                username, sep, password = auth.partition(':')
                user = authenticate(username=username, password=password)
                if user:
                    request.user = user

        return func(request, *args, **kwargs)
    return _decorator

########NEW FILE########
__FILENAME__ = mimeparse
"""MIME-Type Parser

This module provides basic functions for handling mime-types. It can handle
matching mime-types against a list of media-ranges. See section 14.1 of the
HTTP specification [RFC 2616] for a complete explanation.

   http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1

Contents:
 - parse_mime_type():   Parses a mime-type into its component parts.
 - parse_media_range(): Media-ranges are mime-types with wild-cards and a 'q'
                          quality parameter.
 - quality():           Determines the quality ('q') of a mime-type when
                          compared against a list of media-ranges.
 - quality_parsed():    Just like quality() except the second parameter must be
                          pre-parsed.
 - best_match():        Choose the mime-type with the highest quality ('q')
                          from a list of candidates.
"""
from functools import reduce

__version__ = '0.1.4.1'
__author__ = 'Joe Gregorio'
__email__ = 'joe@bitworking.org'
__license__ = 'MIT License'
__credits__ = ''


def parse_mime_type(mime_type):
    """Parses a mime-type into its component parts.

    Carves up a mime-type and returns a tuple of the (type, subtype, params)
    where 'params' is a dictionary of all the parameters for the media range.
    For example, the media range 'application/xhtml;q=0.5' would get parsed
    into:

       ('application', 'xhtml', {'q', '0.5'})
    """
    parts = mime_type.split(';')
    params = dict([tuple([s.strip() for s in param.split('=', 1)])
                  for param in parts[1:]
                   ])
    full_type = parts[0].strip()
    # Java URLConnection class sends an Accept header that includes a
    # single '*'. Turn it into a legal wildcard.
    if full_type == '*':
        full_type = '*/*'
    (type, subtype) = full_type.split('/')

    return (type.strip(), subtype.strip(), params)


def parse_media_range(range):
    """Parse a media-range into its component parts.

    Carves up a media range and returns a tuple of the (type, subtype,
    params) where 'params' is a dictionary of all the parameters for the media
    range.  For example, the media range 'application/*;q=0.5' would get parsed
    into:

       ('application', '*', {'q', '0.5'})

    In addition this function also guarantees that there is a value for 'q'
    in the params dictionary, filling it in with a proper default if
    necessary.
    """
    (type, subtype, params) = parse_mime_type(range)
    if not 'q' in params or not params['q'] or \
            float(params['q']) > 1 or float(params['q']) < 0:
        params['q'] = '1'

    return (type, subtype, params)


def quality_and_fitness_parsed(mime_type, parsed_ranges):
    """Find the best match for a mime-type amongst parsed media-ranges.

    Find the best match for a given mime-type against a list of media_ranges
    that have already been parsed by parse_media_range(). Returns a tuple of
    the fitness value and the value of the 'q' quality parameter of the best
    match, or (-1, 0) if no match was found. Just as for quality_parsed(),
    'parsed_ranges' must be a list of parsed media ranges.
    """
    best_fitness = -1
    best_fit_q = 0
    (target_type, target_subtype, target_params) =\
        parse_media_range(mime_type)
    for (type, subtype, params) in parsed_ranges:
        type_match = (type == target_type or
                      type == '*' or
                      target_type == '*')
        subtype_match = (subtype == target_subtype or
                         subtype == '*' or
                         target_subtype == '*')
        if type_match and subtype_match:
            param_matches = reduce(lambda x, y: x + y, [1 for (key, value) in
                                   target_params.items() if key != 'q' and
                                   key in params and value == params[key]], 0)
            fitness = (type == target_type) and 100 or 0
            fitness += (subtype == target_subtype) and 10 or 0
            fitness += param_matches
            if fitness > best_fitness:
                best_fitness = fitness
                best_fit_q = params['q']

    return float(best_fit_q), best_fitness


def quality_parsed(mime_type, parsed_ranges):
    """Find the best match for a mime-type amongst parsed media-ranges.

    Find the best match for a given mime-type against a list of media_ranges
    that have already been parsed by parse_media_range(). Returns the 'q'
    quality parameter of the best match, 0 if no match was found. This function
    bahaves the same as quality() except that 'parsed_ranges' must be a list of
    parsed media ranges. """

    return quality_and_fitness_parsed(mime_type, parsed_ranges)[0]


def quality(mime_type, ranges):
    """Return the quality ('q') of a mime-type against a list of media-ranges.

    Returns the quality 'q' of a mime-type when compared against the
    media-ranges in ranges. For example:

    >>> quality('text/html','text/*;q=0.3, text/html;q=0.7,
                  text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5')
    0.7

    """
    parsed_ranges = [parse_media_range(r) for r in ranges.split(',')]

    return quality_parsed(mime_type, parsed_ranges)


def best_match(supported, header):
    """Return mime-type with the highest quality ('q') from list of candidates.

    Takes a list of supported mime-types and finds the best match for all the
    media-ranges listed in header. The value of header must be a string that
    conforms to the format of the HTTP Accept: header. The value of 'supported'
    is a list of mime-types. The list of supported mime-types should be sorted
    in order of increasing desirability, in case of a situation where there is
    a tie.

    >>> best_match(['application/xbel+xml', 'text/xml'],
                   'text/*;q=0.5,*/*; q=0.1')
    'text/xml'
    """
    split_header = _filter_blank(header.split(','))
    parsed_header = [parse_media_range(r) for r in split_header]
    weighted_matches = []
    pos = 0
    for mime_type in supported:
        weighted_matches.append((quality_and_fitness_parsed(mime_type,
                                 parsed_header), pos, mime_type))
        pos += 1
    weighted_matches.sort()

    return weighted_matches[-1][0][0] and weighted_matches[-1][2] or ''


def _filter_blank(i):
    for s in i:
        if s.strip():
            yield s

# flake8: noqa

########NEW FILE########
__FILENAME__ = parsers
from __future__ import absolute_import, unicode_literals

import json
import re

from django.utils.six.moves import http_client

from .serializers import Serializer


class RequestParser(object):
    """
    Parses the request body into a format independent of its content type.

    Does nothing for the following HTTP methods because they are not supposed
    to have a request body:

    - ``GET``
    - ``HEAD``
    - ``OPTIONS``
    - ``TRACE``
    - ``DELETE``

    Otherwise, the code tries determining a parser for the request. The
    following content types are supported:

    - ``application/x-www-form-urlencoded`` (the default)
    - ``multipart/form-data``
    - ``application/json``

    The two former content types are supported directly by Django, all
    capabilities and restrictions are inherited directly. When using JSON,
    file uploads are not supported.

    The parsed data is available as ``request.POST`` and ``request.FILES``.
    ``request.POST`` is used instead of something else even for ``PUT`` and
    ``PATCH`` requests (among others), because most code written for Django
    expects data to be provided under that name.
    """
    def parse(self, request):
        """
        Decides whether the request body should be parsed, and if yes, decides
        which parser to use. Returns a HTTP 415 Unsupported media type if the
        request isn't understood.
        """
        if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE', 'DELETE'):
            # Fall back to standard handling which only does stuff when
            # method == 'POST' anyway, that is, not now.
            return

        content_type = request.META.get(
            'CONTENT_TYPE', 'application/x-www-form-urlencoded')

        handlers = {
            r'^application/x-www-form-urlencoded': self.parse_form,
            r'^multipart/form-data': self.parse_form,
            r'^application/json': self.parse_json,
        }

        for pattern, handler in handlers.items():
            if re.match(pattern, content_type):
                return handler(request)

        return Serializer().serialize(
            {
                'error': '%r is not supported' % content_type,
            },
            request=request,
            status=http_client.UNSUPPORTED_MEDIA_TYPE,
            output_format=request.GET.get('format'),
        )

    def parse_form(self, request):
        """
        Simply calls Django's own request parsing, but changes the request
        method to ``'POST'`` so that the request body parsing actually happens
        as it should. The value of ``request.method`` is restored when
        parsing ends.
        """
        method = request.method
        request.method = 'POST'
        request._load_post_and_files()
        request.method = method

    def parse_json(self, request):
        """
        Unserializes the JSON in the body of the request and saves the result
        as ``request.POST``.
        """
        request.POST = json.loads(request.body.decode('utf-8'))

########NEW FILE########
__FILENAME__ = resources
from __future__ import absolute_import, unicode_literals

from collections import namedtuple
import logging

from django.http import Http404, HttpResponse
from django.shortcuts import get_object_or_404
from django.utils.six.moves import http_client
from django.views import generic

from .base import APIException, api_reverse
from .parsers import RequestParser
from .serializers import Serializer
from .utils import querystring


#: The ``page`` object from ``Resource.objects``
Page = namedtuple('Page', 'queryset offset limit full_queryset')

logger = logging.getLogger('towel.api')


class Resource(generic.View):
    """
    Resource for exposing Django models somewhat RESTy
    """

    #: The API to which this resource is bound to.
    api = None

    #: The model exposed by this resource.
    model = None

    #: Prefiltered queryset for this resource. Defaults to
    #: ``model._default_manager.all()`` if unset.
    queryset = None

    #: Default instance count for list views
    limit_per_page = 20
    #: Higher values than this will not be accepted for ``limit``
    max_limit_per_page = 1000

    #: Almost the same as ``django.views.generic.View.http_method_names`` but
    #: not quite, we allow ``patch`` as well.
    http_method_names = [
        'get', 'post', 'put', 'delete', 'head', 'patch', 'options', 'trace']

    #: A list of URL patterns which will be used by ``API.register`` to build
    #: the URLconf entries. The format is a list of tuples containing
    #: (regular expression, URL name suffix).
    urls = [
        (r'^$', 'list', {
            'request_type': 'list',
        }),
        (r'^(?P<pk>\d+)/$', 'detail', {
            'request_type': 'detail',
        }),
        (r'^(?P<pks>(?:\d+;)*\d+);?/$', 'set', {
            'request_type': 'set',
        }),
    ]

    def dispatch(self, request, *args, **kwargs):
        """
        This method is almost the same as Django's own
        ``generic.View.dispatch()``, but there are a few subtle differences:

        - It uses ``self.request``, ``self.args`` and ``self.kwargs`` in all
          places
        - It calls ``self.unserialize_request()`` after assigning the
          aforementioned variables on ``self`` which may modify all aspects and
          all variables (f.e.  deserialize a JSON request and serialize it
          again to look like a standard POST request) and only then determines
          whether the request should be handled by this view at all.
        - The return value of the ``get()``, ``post()`` etc. methods is passed
          to ``self.serialize_response()`` and only then returned to the
          client. The processing methods should return data (a ``dict``
          instance most of the time) which is then serialized into the
          requested format or some different supported format.
        """

        # The following three lines can be removed when we move to
        # Django 1.5 only
        self.request = request
        self.args = args
        self.kwargs = kwargs

        response = self.unserialize_request()
        if response:
            return response

        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        method = self.request.method.lower()
        if method == 'head':
            method = 'get'
        handler = self.http_method_not_allowed

        if method in self.http_method_names:
            self.request_type = kwargs.get('request_type')
            if (self.request_type
                    and hasattr(self, '%s_%s' % (method, self.request_type))):
                handler = getattr(self, '%s_%s' % (method, self.request_type))
            elif hasattr(self, method):
                handler = getattr(self, method)

        try:
            return self.serialize_response(
                handler(self.request, *self.args, **self.kwargs))
        except Http404 as exc:
            return self.serialize_response(
                {'error': exc.args[0]},
                status=http_client.NOT_FOUND)
        except APIException as exc:
            logger.warning(
                'APIException: %s, %r' % (exc, exc.__dict__),
                extra={
                    'request': self.request,
                })

            data = {
                'error': exc.error_message,
            }
            data.update(exc.data)
            return self.serialize_response(data, status=exc.status)

    def unserialize_request(self):
        """
        This method standardizes various aspects of the incoming request, f.e.
        decoding of JSON requests etc.

        The "real" processing methods should not have to distinguish between
        varying request types anymore.

        If this method returns anything, it is treated as a response and
        short-circuits the resource processing.
        """
        return RequestParser().parse(self.request)

    def serialize_response(self, response, status=http_client.OK,
                           headers=None):
        """
        Serializes the response into an appropriate format for the wire such
        as JSON. ``HttpResponse`` instances are returned directly.
        """
        if isinstance(response, HttpResponse):
            return response

        return Serializer().serialize(
            response,
            request=self.request,
            status=status,
            output_format=self.request.GET.get('format'),
            headers=headers)

    def get_query_set(self):
        """
        Returns the queryset used by this resource. If you need access or
        visibility control, add it here.
        """
        if self.queryset:
            return self.queryset._clone()
        elif self.model:
            return self.model._default_manager.all()

    def apply_filters(self, queryset):
        """
        Applies filters and search queries to the queryset. This method will
        only be called for list views, not when the user requested sets or
        single instances.
        """
        return queryset

    def detail_object_or_404(self):
        """
        Returns the current object for detail resources such as
        ``/api/product/1/``.
        """
        return get_object_or_404(self.get_query_set(), pk=self.kwargs['pk'])

    def set_objects_or_404(self):
        """
        Returns the current set of objects for set resources such as
        ``/api/product/1;3/``.
        """
        pks = set(pk for pk in self.kwargs['pks'].split(';') if pk)
        set_ = self.get_query_set().in_bulk(pks).values()

        if len(pks) != len(set_):
            raise Http404('Some objects do not exist.')

        return set_

    def page_objects_or_404(self):
        """
        Returns the current page for list resources such as
        ``/api/product/?limit=20&offset=40``. Applies filtering using
        ``apply_filters`` as well.
        """
        queryset = self.apply_filters(self.get_query_set())

        try:
            offset = int(self.request.GET.get('offset'))
        except (TypeError, ValueError):
            offset = 0

        try:
            limit = int(self.request.GET.get('limit'))
        except (TypeError, ValueError):
            limit = self.limit_per_page

        # Do not allow more than max_limit_per_page entries in one request,
        # ever
        limit = min(limit, self.max_limit_per_page)

        # Sanitize range
        offset = max(offset, 0)
        limit = max(limit, 0)

        return Page(queryset[offset:offset + limit], offset, limit, queryset)

    def get_detail(self, request, *args, **kwargs):
        kw = {}
        if request.GET.get('full'):
            kw['inline_depth'] = 1
        return self.api.serialize_instance(
            self.detail_object_or_404(),
            build_absolute_uri=request.build_absolute_uri,
            **kw)

    def get_set(self, request, *args, **kwargs):
        return {
            'objects': [
                self.api.serialize_instance(
                    instance,
                    build_absolute_uri=request.build_absolute_uri,
                ) for instance in self.set_objects_or_404()
            ],
        }

    def get_list(self, request, *args, **kwargs):
        page = self.page_objects_or_404()

        list_url = api_reverse(
            page.full_queryset.model, 'list', api_name=self.api.name)

        meta = {
            'offset': page.offset,
            'limit': page.limit,
            'total': page.full_queryset.count(),
            'previous': None,
            'next': None,
        }

        if page.offset > 0:
            meta['previous'] = request.build_absolute_uri('%s?%s' % (
                list_url,
                querystring(
                    self.request.GET,
                    exclude=('offset', 'limit'),
                    offset=max(0, page.offset - page.limit),
                    limit=page.limit,
                ),
            ))

        if page.offset + page.limit < meta['total']:
            meta['next'] = request.build_absolute_uri('%s?%s' % (
                list_url,
                querystring(
                    self.request.GET,
                    exclude=('offset', 'limit'),
                    offset=page.offset + page.limit,
                    limit=page.limit,
                ),
            ))

        return {
            'objects': [
                self.api.serialize_instance(
                    instance,
                    build_absolute_uri=request.build_absolute_uri,
                ) for instance in page.queryset],
            'meta': meta,
        }

    def options(self, request, *args, **kwargs):
        # XXX This will be removed as soon as we switch to Django 1.5 only
        response = HttpResponse()
        response['Allow'] = ', '.join(self._allowed_methods())
        response['Content-Length'] = 0
        return response

    def _allowed_methods(self):
        methods = set(m.upper() for m in self.http_method_names if (
            hasattr(self, m)
            or hasattr(self, '%s_%s' % (m, self.request_type))
        ))
        if 'GET' in methods:
            methods.add('HEAD')
        return sorted(methods)

########NEW FILE########
__FILENAME__ = serializers
from __future__ import absolute_import, unicode_literals

import json

from django.core.serializers.json import DjangoJSONEncoder
from django.http import HttpResponse
from django.utils.cache import patch_vary_headers
from django.utils.six.moves import http_client

from towel.api.mimeparse import best_match


class Serializer(object):
    """
    API response serializer

    Handles content type negotiation using the HTTP Accept header if the
    format isn't overridden.
    """
    def serialize(self, data, output_format=None, request=None,
                  status=http_client.OK, headers=None):
        """
        Returns a ``HttpResponse`` containing the serialized response in the
        format specified explicitly in ``output_format`` (either as a MIME
        type or as a simple identifier) or according to the HTTP Accept
        header specified in the passed request instance. The default status
        code is ``200 OK``, if that does not fit you'll have to specify a
        different code yourself.

        Returns a ``406 Not acceptable`` response if the requested format is
        unknown or unsupported. Currently, the following formats are
        supported:

        - ``json`` or ``application/json``

        Usage::

            return Serializer().serialize(
                {'response': 'Hello world'},
                output_format='application/json',
                status=httplib.OK)

        or::

            return Serializer().serialize(
                {'response': 'Hello world'},
                request=request,
                status=httplib.OK)
        """
        if output_format is None and request is None:
            raise TypeError(
                'Provide at least one of output_format and request.')

        if output_format is None:
            # Thanks django-tastypie!
            try:
                output_format = best_match(
                    reversed([
                        'application/json',
                    ]),
                    request.META.get('HTTP_ACCEPT', ''),
                )
            except (IndexError, ValueError):
                pass

        if output_format in ('application/json', 'json'):
            response = self.to_json(data)

        else:
            # Cannot raise ClientError here because the APIException handler
            # calls into this method too.
            response = HttpResponse('Not acceptable')
            status = http_client.NOT_ACCEPTABLE

        if headers:
            for key, value in headers.items():
                response[key] = value

        patch_vary_headers(response, ('Accept',))
        response.status_code = status
        return response

    def to_json(self, data):
        return HttpResponse(
            json.dumps(data, cls=DjangoJSONEncoder),
            content_type='application/json',
        )

########NEW FILE########
__FILENAME__ = utils
from __future__ import absolute_import, unicode_literals

from functools import reduce
import operator

from django.utils.encoding import force_text
from django.utils.http import urlencode


def querystring(data, exclude=(), **kwargs):
    """
    Returns a properly encoded querystring

    The supported arguments are as follows:

    - ``data`` should be a ``MultiValueDict`` instance (i.e. ``request.GET``)
    - ``exclude`` is a list of keys from ``data`` which should be skipped
    - Additional key-value pairs are accepted as keyword arguments

    Usage::

        next_page_url = querystring(
            request.GET,
            exclude=('page',),
            page=current + 1,
            )
    """
    items = reduce(operator.add, (
        list((k, v) for v in values)
        for k, values in data.lists() if k not in exclude
    ), [])

    for key, value in kwargs.items():
        items.append((key, force_text(value)))

    return urlencode(sorted(items))

########NEW FILE########
__FILENAME__ = auth
from __future__ import absolute_import, unicode_literals

from django.contrib.auth.backends import ModelBackend as _ModelBackend
from django.contrib.auth.models import User


class ModelBackend(_ModelBackend):
    """
    Add the following to your ``settings.py`` to be able to login with
    email addresses too::

        AUTHENTICATION_BACKENDS = (
            'towel.auth.ModelBackend',
        )
    """
    def authenticate(self, username=None, password=None):
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            try:
                user = User.objects.get(email=username)
            except User.DoesNotExist:
                return None

        if user.check_password(password):
            return user

        return None

########NEW FILE########
__FILENAME__ = deletion
"""
Helper module to circumvent Django's (arguably) broken formset saving behavior
where models are directly deleted even if ``commit=False`` is passed to the
formset's ``save()`` method.

Usage::

    class SafeModel(deletion.Model):
        # fields etc.


    instance = SafeModel.objects.get(...)
    with deletion.protect():
        instance.delete() # Does nothing
    instance.delete() # Actually deletes the instance!


Saving formsets::

    with deletion.protect():
        objects = formset.save()

    for obj in formset.deleted_objects: # Django provides this attribute
        obj.delete() # Or do something else, like checking whether the instance
                     # should really be deleted


This is achieved by overriding the model's ``delete()`` method with a different
version which does nothing if protection is active. If you override the
deletion method for some reason too, you have to ensure that the threadlocal
state is respected too.
"""

from __future__ import absolute_import, unicode_literals

from contextlib import contextmanager
from threading import local

from django.db import models


DEFAULT = None
PROTECT = 'protect'

_deletion = local()


def set_mode(mode):
    """
    Sets the protection mode. The argument should be one of:

    - ``deletion.DEFAULT``:
      Standard behavior, instances are deleted.
    - ``deletion.PROTECT``:
      ``delete()`` invocations on models inheriting ``deletion.Model`` are
      ignored.
    """
    _deletion.mode = mode


@contextmanager
def protect():
    """
    Wraps a code block with deletion protection

    Example::

        from towel import deletion

        instance = SafeModel.objects.get(...)
        with deletion.protect():
            # Does nothing
            instance.delete()

        # Actually deletes the instance
        instance.delete()
    """
    set_mode(PROTECT)
    yield
    set_mode(DEFAULT)


class Model(models.Model):
    """
    Safe model base class, inherit this model instead of the standard
    :py:class:`django.db.models.Model` if you want to take advantage of
    the :py:mod:`towel.deletion` module.
    """
    class Meta:
        abstract = True

    def delete(self, *args, **kwargs):
        """
        Deletion is skipped if inside a :py:func:`~towel.deletion.protect`
        block.
        """
        if getattr(_deletion, 'mode', None) == PROTECT:
            return
        super(Model, self).delete(*args, **kwargs)

########NEW FILE########
__FILENAME__ = forms
from __future__ import absolute_import, unicode_literals

import json

from django import forms
from django.db import models
from django.db.models import ObjectDoesNotExist
from django.forms.util import flatatt
from django.http import HttpResponse, QueryDict
from django.utils import six
from django.utils.encoding import force_text
from django.utils.functional import cached_property
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from towel import quick


class BatchForm(forms.Form):
    """
    This form class can be used to provide batch editing functionality
    in list views, similar to Django's admin actions.

    You have to implement your batch processing in the ``_context()``
    method. This method only receives one parameter, a queryset which
    is already filtered according to the selected items on the list view.
    Additionally, the current request is available as an attribute of the
    form instance, ``self.request``.

    The method ``process(self)`` may have the following return values:

    - A ``dict`` instance: Will be merged into the template context.
    - A ``HttpResponse`` instance: Will be returned directly to the client.
    - An iterable: The handler assumes successful processing of all objects
      contained in the iterable.
    - Nothing: Nothing happens.

    Usage example::

        class AddressBatchForm(BatchForm):
            subject = forms.CharField()
            body = forms.TextField()

            def process(self):
                # Form validation has already been taken care of
                subject = self.cleaned_data.get('subject')
                body = self.cleaned_data.get('body')

                if not (subject and body):
                    return {}

                sent = 0
                for item in self.batch_queryset:
                    send_mail(subject, body, settings.DEFAULT_SENDER,
                        [item.email])
                    sent += 1
                if sent:
                    messages.success(self.request, 'Sent %s emails.' % sent)

                return self.batch_queryset

        def addresses(request):
            queryset = Address.objects.all()
            batch_form = AddressBatchForm(request, queryset)
            ctx = {'addresses': queryset}

            if batch_form.should_process():
                result = form.process()
                if isinstance(result, HttpResponse):
                    return result
                elif isinstance(result, dict):
                    ctx.update(result)
                elif hasattr(result, '__iter__'):
                    messages.success(request,
                        _('Processed the following items: %s') % (
                            ', '.join(force_text(item) for item in result)))

                return HttpResponseRedirect('.')

            return render(request, 'addresses.html', ctx)

    Template code::

        {% load towel_batch_tags %}
        <form method="post" action=".">
            <ul>
            {% for address in addresses %}
                <li>
                {% batch_checkbox address.id batch_form %}
                {{ address }}
                </li>
            {% endfor %}
            </ul>

            {# Required! Otherwise, ``BatchForm.process`` does nothing. #}
            <input type="hidden" name="batchform" value="1" />

            <table>
                {{ batch_form }}
            </table>
            <button type="submit">Send mail to selected</button>
        </form>
    """

    _process = False
    ids = []

    def __init__(self, request, queryset, *args, **kwargs):
        kwargs.setdefault('prefix', 'batch')

        self.request = request
        self.queryset = queryset

        if request.method == 'POST' and 'batchform' in request.POST:
            self._process = True
            super(BatchForm, self).__init__(
                request.POST, request.FILES, *args, **kwargs)
        else:
            super(BatchForm, self).__init__(*args, **kwargs)

    def clean(self):
        """
        Cleans the batch form fields and checks whether at least one item
        had been selected.
        """
        data = super(BatchForm, self).clean()

        post_data = self.request.POST
        self.ids = [
            pk for pk in self.queryset.values_list('id', flat=True)
            if post_data.get('batch_%s' % pk)]

        if not self.ids:
            raise forms.ValidationError(_('No items selected'))

        return data

    def should_process(self):
        """
        Returns true when the submitted form was the batch form, and the
        batch form is valid.
        """
        return self._process and self.is_valid()

    @cached_property
    def batch_queryset(self):
        """
        Returns the queryset containing only items that have been selected
        for batch processing.
        """
        return self.queryset.filter(id__in=self.ids)

    def process(self):  # pragma: no cover
        """
        Actually processes the batch form submission. Override this with
        your own behavior.

        Batch forms may return the following types here (they are handled
        by ``ModelView.handle_batch_form``:

        - A ``HttpResponse``:
          Will be returned directly to the user.
        - An iterable:
          A success message will be generated containing all items in the
          iterable.
        """
        if hasattr(self, '_context'):
            import warnings
            warnings.warn(
                'The batch form \'%s.%s\' is still using \'_context\'.'
                ' Switch to using the new \'process\' method now!' % (
                    self.__class__.__module__,
                    self.__class__.__name__,
                ),
                DeprecationWarning,
            )

            ctx = self._context(self.batch_queryset)
            if 'response' in ctx:
                return ctx['response']
            return ctx

        raise NotImplementedError(
            'BatchForm.process has no default implementation.')


class SearchForm(forms.Form):
    """
    Supports persistence of searches (stores search in the session). Requires
    not only the GET parameters but the request object itself to work
    correctly.

    Usage example::

        class AddressManager(SearchManager):
            search_fields = ('first_name', 'last_name', 'address', 'email',
                'city', 'zip_code', 'created_by__email')

        class Address(models.Model):
            ...

            objects = AddressManager()

        class AddressSearchForm(SearchForm):
            orderings = {
                '': ('last_name', 'first_name'), # Default
                'dob': 'dob', # Sort by date of birth
                'random': lambda queryset: queryset.order_by('?'),
                }
            is_person = forms.NullBooleanField()

        def addresses(request):
            search_form = AddressSearchForm(request.GET, request=request)
            queryset = search_form.queryset(Address)
            ctx = {
                'addresses': queryset,
                'search_form': search_form,
                }
            return render(request, 'addresses.html', ctx)

    .. warning::

        All fields in the form need to have ``required=False`` set. Otherwise,
        form validation would already fail on the first visit on the list
        page (which would kind of defeat the purpose of a search form).

    Template code::

        <form method="get" action=".">
            <input type="hidden" name="s" value="1"> <!-- SearchForm search -->
            <table>
                {{ search_form }}
            </table>
            <button type="submit">Search</button>
        </form>

        {% for address in addresses %}
            ...
        {% endfor %}
    """

    #: Fields which are always excluded from automatic filtering
    #: in ``apply_filters``
    always_exclude = ('s', 'query', 'o')

    #: Default field values - used if not overridden by the user
    default = {}

    #: Ordering specification
    orderings = {}

    #: Quick rules, a list of (regex, mapper) tuples
    quick_rules = []

    #: Search form active?
    s = forms.CharField(required=False, widget=forms.HiddenInput(),
                        initial='1')

    #: Current ordering
    o = forms.CharField(required=False, widget=forms.HiddenInput())

    #: Full text search query
    query = forms.CharField(
        label=_('Query'),
        required=False,
        widget=forms.TextInput(attrs={'placeholder': _('Query')}))

    def __init__(self, data, *args, **kwargs):
        # Are the results filtered in any way?
        self.filtered = True
        # Is a persisted search active?
        self.persistency = False

        request = kwargs.pop('request')
        self.original_data = data
        super(SearchForm, self).__init__(
            self.prepare_data(data, request),
            *args, **kwargs)
        self.persist(request)
        self.post_init(request)

    def prepare_data(self, data, request):
        """
        Fill in default values from ``default`` if they aren't provided by
        the user.
        """

        if not self.default:
            return data

        data = data.copy()
        for key, value in self.default.items():
            if key not in data:
                if hasattr(value, '__call__'):
                    value = value(request)

                if hasattr(value, '__iter__'):
                    data.setlist(key, value)
                else:
                    data[key] = value
        return data

    def post_init(self, request):
        """
        Hook for customizations.
        """

        pass

    def persist(self, request):
        """
        Persist the search in the session, or load saved search if user
        isn't searching right now.
        """

        session_key = 'sf_%s.%s' % (
            self.__class__.__module__,
            self.__class__.__name__)

        if 'clear' in request.GET or 'n' in request.GET:
            if session_key in request.session:
                del request.session[session_key]

        if self.original_data and (
                set(self.original_data.keys()) & set(self.fields.keys())):
            data = self.data.copy()
            if 's' in data:
                del data['s']
                request.session[session_key] = data.urlencode()

        elif request.method == 'GET' and 's' not in request.GET:
            # try to get saved search from session
            if session_key in request.session:
                self.data = QueryDict(request.session[session_key])
                self.persistency = True

            else:
                self.filtered = False

        elif request.method == 'POST' and 's' not in request.POST:
            # It wasn't the search form which was POSTed, hopefully :-)
            self.filtered = False

    def searching(self):
        """
        Returns ``searching`` for use as CSS class if results are filtered
        by this search form in any way.
        """

        if self.persistency or self.safe_cleaned_data.get('s'):
            return 'searching'
        return ''

    @property
    def safe_cleaned_data(self):
        """
        Safely return a dictionary of values, even if search form isn't valid.
        """

        self.is_valid()
        try:
            return self.cleaned_data.copy()
        except AttributeError:
            return {}

    def fields_iterator(self):
        """
        Yield all additional search fields.
        """

        skip = ('query', 's', 'o')

        for field in self:
            if field.name not in skip:
                yield field

    def apply_filters(self, queryset, data, exclude=()):
        """
        Automatically apply filters

        Uses form field names for ``filter()`` argument construction.
        """

        exclude = list(exclude) + list(self.always_exclude)

        for field in self.fields.keys():
            if field in exclude:
                continue

            value = data.get(field)
            if (value and hasattr(value, '__iter__')
                    and not isinstance(value, six.string_types)):
                queryset = queryset.filter(**{'%s__in' % field: value})
            elif value or value is False:
                queryset = queryset.filter(**{field: value})

        if self.quick_rules:
            quick_only = set(data.keys()) - set(self.fields.keys())
            for field in quick_only:
                if field in exclude:
                    continue

                if field.endswith('_') and (
                        field[:-1] in quick_only or field[:-1] in self.fields):
                    # Either ``quick.model_mapper`` wanted to trick us and
                    # added the model instance, too, or the quick mechanism
                    # filled an existing form field which means that the
                    # attribute has already been handled above.
                    continue

                value = data.get(field)
                if value is not None:
                    queryset = queryset.filter(**{field: value})

        return queryset

    def apply_ordering(self, queryset, ordering=None):
        """
        Applies ordering if the value in ``o`` matches a key in
        ``self.orderings``. The ordering may also be reversed,
        in which case the ``o`` value should be prefixed with
        a minus sign.
        """
        if ordering is None:
            return queryset

        if ordering and ordering[0] == '-':
            order_by, desc = ordering[1:], True
        else:
            order_by, desc = ordering, False

        if order_by not in self.orderings:
            # Ignore ordering request if unknown
            return queryset

        order_by = self.orderings[order_by]

        if hasattr(order_by, '__call__'):
            queryset = order_by(queryset)
        elif isinstance(order_by, (list, tuple)):
            queryset = queryset.order_by(*order_by)
        else:
            queryset = queryset.order_by(order_by)

        if desc:
            return queryset.reverse()
        return queryset

    def query_data(self):
        """
        Return a fulltext query and structured data which can be converted into
        simple filter() calls
        """

        if not hasattr(self, '_query_data_cache'):
            data = self.safe_cleaned_data

            if self.quick_rules:
                data, query = quick.parse_quickadd(
                    data.get('query'),
                    self.quick_rules)
                query = ' '.join(query)

                # Data in form fields overrides any quick specifications
                for k, v in self.safe_cleaned_data.items():
                    if v is not None:
                        data[k] = v
            else:
                query = data.get('query')

            self._query_data_cache = query, data
        return self._query_data_cache

    def queryset(self, model):
        """
        Return the result of the search
        """

        query, data = self.query_data()
        queryset = model.objects.search(query)
        queryset = self.apply_filters(queryset, data)
        return self.apply_ordering(queryset, data.get('o'))


class WarningsForm(forms.BaseForm):
    """
    Form subclass which allows implementing validation warnings

    In contrast to Django's ``ValidationError``, these warnings may
    be ignored by checking a checkbox.

    The warnings support consists of the following methods and properties:

    * ``WarningsForm.add_warning(<warning>)``: Adds a new warning message
    * ``WarningsForm.warnings``: A list of warnings or an empty list if there
      are none.
    * ``WarningsForm.is_valid()``: Overridden ``Form.is_valid()``
      implementation which returns ``False`` for otherwise valid forms with
      warnings, if those warnings have not been explicitly ignored (by checking
      a checkbox or by passing ``ignore_warnings=True`` to ``is_valid()``.
    * An additional form field named ``ignore_warnings`` is available - this
      field should only be displayed if ``WarningsForm.warnings`` is non-emtpy.
    """
    def __init__(self, *args, **kwargs):
        super(WarningsForm, self).__init__(*args, **kwargs)

        self.fields['ignore_warnings'] = forms.BooleanField(
            label=_('Ignore warnings'), required=False)
        self.warnings = []

    def add_warning(self, warning):
        """
        Adds a new warning, should be called while cleaning the data
        """
        self.warnings.append(warning)

    def is_valid(self, ignore_warnings=False):
        """
        ``is_valid()`` override which returns ``False`` for forms with warnings
        if these warnings haven't been explicitly ignored
        """
        if not super(WarningsForm, self).is_valid():
            return False

        if self.warnings and not (
                ignore_warnings or self.cleaned_data.get('ignore_warnings')):
            return False

        return True


class StrippedInputMixin(object):
    def value_from_datadict(self, data, files, name):
        value = data.get(name, None)
        if isinstance(value, six.string_types):
            return value.strip()
        return value


class StrippedTextInput(StrippedInputMixin, forms.TextInput):
    """
    ``TextInput`` form widget subclass returning stripped contents only
    """
    pass


class StrippedTextarea(StrippedInputMixin, forms.Textarea):
    """
    ``Textarea`` form widget subclass returning stripped contents only
    """
    pass


def towel_formfield_callback(field, **kwargs):
    """
    Use this callback as ``formfield_callback`` if you want to use stripped
    text inputs and textareas automatically without manually specifying the
    widgets. Adds a ``dateinput`` class to date and datetime fields too.
    """

    if isinstance(field, models.CharField) and not field.choices:
        kwargs['widget'] = StrippedTextInput()
    elif isinstance(field, models.TextField):
        kwargs['widget'] = StrippedTextarea()
    elif isinstance(field, models.DateTimeField):
        kwargs['widget'] = forms.DateTimeInput(attrs={'class': 'dateinput'})
    elif isinstance(field, models.DateField):
        kwargs['widget'] = forms.DateInput(attrs={'class': 'dateinput'})

    return field.formfield(**kwargs)


#: Backwards compatibility, provide the function under the old name
#: ``stripped_formfield_callback`` too.
def stripped_formfield_callback(field, **kwargs):
    import warnings
    warnings.warn(
        'stripped_formfield_callback has been renamed to'
        ' towel_formfield_callback, please start using the new name.',
        DeprecationWarning, stacklevel=2)
    return towel_formfield_callback(field, **kwargs)


def autocompletion_response(queryset, limit=10):
    """
    Helper which returns a ``HttpResponse`` list of instances in a format
    suitable for consumption by jQuery UI Autocomplete, respectively
    ``towel.forms.ModelAutocompleteWidget``.
    """
    return HttpResponse(
        json.dumps([
            {
                'label': force_text(instance),
                'value': instance.pk,
            } for instance in queryset[:limit]
        ]),
        content_type='application/json',
    )


class ModelAutocompleteWidget(forms.TextInput):
    """
    Model autocompletion widget using jQuery UI Autocomplete

    Supports both querysets and JSON-returning AJAX handlers as data
    sources. Use as follows::

        class MyForm(forms.ModelForm):
            customer = forms.ModelChoiceField(Customer.objects.all(),
                widget=ModelAutocompleteWidget(url='/customers/search_ajax/'),
                )
            type = forms.ModelChoiceField(Type.objects.all(),
                widget=ModelAutocompleteWidget(queryset=Type.objects.all()),
                )

    You need to make sure that the jQuery UI files are loaded correctly
    yourself.
    """

    def __init__(self, attrs=None, url=None, queryset=None):
        assert (url is None) != (queryset is None), (
            'Provide either url or queryset')

        self.url = url
        self.queryset = queryset
        super(ModelAutocompleteWidget, self).__init__(attrs)

    def render(self, name, value, attrs=None, choices=()):
        if value is None:
            value = ''
        final_attrs = self.build_attrs(attrs, type='hidden', name=name)
        if value != '':
            # Only add the 'value' attribute if a value is non-empty.
            final_attrs['value'] = force_text(self._format_value(value))

        hidden = '<input%s />' % flatatt(final_attrs)

        final_attrs['type'] = 'text'
        final_attrs['id'] += '_ac'
        del final_attrs['name']

        try:
            instance = self.choices.queryset.get(pk=value)
            final_attrs['value'] = force_text(instance)
        except (ObjectDoesNotExist, ValueError, TypeError):
            final_attrs['value'] = ''

        if self.is_required:
            ac = '<input%s />' % flatatt(final_attrs)
        else:
            final_attrs.setdefault('class', '')
            final_attrs['class'] += ' ac_nullable'

            ac = (
                ' <a href="#" id="%(id)s_cl" class="ac_clear">'
                ' %(text)s</a>' % {
                    'id': final_attrs['id'][:-3],
                    'text': _('clear'),
                }
            ) + ('<input%s />' % flatatt(final_attrs))

        js = '''<script type="text/javascript">
$(function() {
    $('#%(id)s_ac').autocomplete({
        source: %(source)s,
        focus: function(event, ui) {
            $('#%(id)s_ac').val(ui.item.label);
            return false;
        },
        select: function(event, ui) {
            $('#%(id)s').val(ui.item.value).trigger('change');
            $('#%(id)s_ac').val(ui.item.label);
            return false;
        }
    }).bind('focus', function() {
        this.select();
    }).bind('blur', function() {
        if (!this.value)
            $('#%(id)s').val('');
    });
    $('#%(id)s_cl').click(function(){
        $('#%(id)s, #%(id)s_ac').val('');
        return false;
    });
});
</script>
''' % {'id': attrs.get('id', name), 'name': name, 'source': self._source()}

        return mark_safe(hidden + ac + js)

    def _source(self):
        if self.url:
            if hasattr(self.url, '__call__'):
                return '\'%s\'' % self.url()
            return '\'%s\'' % self.url
        else:
            data = json.dumps([
                {
                    'label': force_text(o),
                    'value': o.id,
                } for o in self.queryset.all()
            ])

            return '''function (request, response) {
    var data = %(data)s, ret = [], term = request.term.toLowerCase();
    for (var i=0; i<data.length; ++i) {
        if (data[i].label.toLowerCase().indexOf(term) != -1)
            ret.push(data[i]);
    }
    response(ret);
}
''' % {'data': data}


class InvalidEntry(object):
    pk = None


class MultipleAutocompletionWidget(forms.TextInput):
    """
    You should probably use harvest chosen instead.
    """
    def __init__(self, attrs=None, queryset=None):
        self.queryset = queryset
        super(MultipleAutocompletionWidget, self).__init__(attrs)

    def _possible(self):
        return dict((force_text(o).lower(), o) for o in self.queryset._clone())

    def render(self, name, value, attrs=None, choices=()):
        if value is None:
            value = []
        final_attrs = self.build_attrs(attrs, name=name, type='text')

        if value:
            value = ', '.join(
                force_text(o) for o in self.queryset.filter(id__in=value))

        js = '''<script type="text/javascript">
$(function() {
    function split( val ) {
        return val.split( /,\s*/ );
    }
    function extractLast( term ) {
        return split( term ).pop();
    }

    $( "#%(id)s" )
        // don't navigate away from the field on tab when selecting an item
        .bind( "keydown", function( event ) {
            if ( event.keyCode === $.ui.keyCode.TAB &&
                    $( this ).data( "autocomplete" ).menu.active ) {
                event.preventDefault();
            }
        })
        .autocomplete({
            source: %(source)s,
            search: function() {
                // custom minLength
                var term = extractLast( this.value );
                if ( term.length < 2 ) {
                    return false;
                }
            },
            focus: function() {
                // prevent value inserted on focus
                return false;
            },
            select: function( event, ui ) {
                var terms = split( this.value );
                // remove the current input
                terms.pop();
                // add the selected item
                terms.push( ui.item.value );
                // add placeholder to get the comma-and-space at the end
                terms.push( "" );
                this.value = terms.join( ", " );
                return false;
            }
    });
});
</script>
''' % {
            'id': final_attrs.get('id', name),
            'name': name,
            'source': self._source(),
        }

        return mark_safe(
            '<textarea%s>%s</textarea>' % (
                flatatt(final_attrs),
                value,
            ) + js
        )

    def value_from_datadict(self, data, files, name):
        value = data.get(name, None)
        if not value:
            return []

        possible = self._possible()
        values = [
            s for s in
            [s.strip() for s in value.lower().split(',')]
            if s]
        return list(set(possible.get(s, InvalidEntry).pk for s in values))

    def _source(self):
        return '''function(request, response) {
    response($.ui.autocomplete.filter(%(data)s, extractLast(request.term)));
    }''' % {
            'data': json.dumps(
                [force_text(o) for o in self.queryset._clone()]),
        }

########NEW FILE########
__FILENAME__ = frankenresource
from __future__ import absolute_import, unicode_literals

import httplib

from django.contrib.messages.api import get_messages

from towel.api import Resource, APIException


class FrankenResource(Resource):
    """
    Really ugly and hacky way of reusing customizations made in a ``ModelView``
    subclass for API resources. Reuses the following aspects of the
    ``ModelView`` instance:

    - Basic queryset filtering, i.e. ``get_query_set``
    - Form handling and saving, i.e. ``get_form``, ``get_form_instance``,
      ``save_form``, ``save_model`` and ``post_save``
    - Permissions management, i.e. ``adding_allowed``, ``editing_allowed``,
      ``deletion_allowed``
    """

    #: ``ModelView`` instance used for providing permissions and write
    #: access to the exposed model
    modelview = None

    def get_query_set(self):
        return self.modelview.get_query_set(self.request)

    def post_list(self, request, *args, **kwargs):
        """
        POST handler. Only supports full creation of objects by posting to
        the listing endpoint currently.
        """
        if not self.modelview.adding_allowed(request):
            raise APIException(status=httplib.FORBIDDEN)

        form_class = self.modelview.get_form(
            request,
            change=False)
        form = self.modelview.get_form_instance(
            request,
            form_class=form_class,
            change=False)

        try:
            is_valid = form.is_valid()
        except TypeError as exc:
            # This can happen when POSTing something of type
            # application/json with a list instead of a single entry,
            # e.g. {"customer_id": ["1"]}
            raise APIException('Malformed data', data={
                'exception': '%s' % exc})

        if not is_valid:
            raise APIException(data={
                'validation': form.errors,
            })

        instance = self.modelview.save_form(request, form, change=False)
        self.modelview.save_model(request, instance, form, change=False)
        self.modelview.post_save(request, instance, form, {}, change=False)

        data = self.api.serialize_instance(
            instance,
            build_absolute_uri=request.build_absolute_uri)
        return self.serialize_response(
            data,
            status=httplib.CREATED,
            headers={'Location': data['__uri__']})

    def put_detail(self, request, *args, **kwargs):
        """
        PUT handler. Only supports update of existing resources. Sets are not
        supported.

        You are required to provide the full set of fields, otherwise
        validation fails. If you are looking for partial updates, have a look
        at PATCH.
        """
        instance = self.detail_object_or_404()

        if not self.modelview.editing_allowed(request, instance):
            raise APIException(status=httplib.FORBIDDEN)

        # The ModelView code only does the right thing when method is POST
        request.method = 'POST'

        form_class = self.modelview.get_form(
            request,
            instance=instance,
            change=True)
        form = self.modelview.get_form_instance(
            request,
            form_class=form_class,
            instance=instance,
            change=True)

        if not form.is_valid():
            raise APIException(data={
                'validation': form.errors,
            })

        instance = self.modelview.save_form(request, form, change=True)
        self.modelview.save_model(request, instance, form, change=True)
        self.modelview.post_save(request, instance, form, {}, change=True)

        data = self.api.serialize_instance(
            instance, build_absolute_uri=request.build_absolute_uri)
        return self.serialize_response(data, status=httplib.OK)

    def patch_detail(self, request, *args, **kwargs):
        """
        PATCH handler. Only supports update of existing resources.

        This handler offloads the work to the PUT handler. It starts with the
        serialized representation from the database, overwrites values using
        the data from the PATCH request and calls PUT afterwards.
        """
        instance = self.detail_object_or_404()

        if not self.modelview.editing_allowed(request, instance):
            raise APIException(status=httplib.FORBIDDEN)

        data = self.api.serialize_instance(
            instance, build_absolute_uri=request.build_absolute_uri)
        for key in request.POST:
            if isinstance(data[key], (list, tuple)):
                data[key] = request.POST.getlist(key)
            else:
                data[key] = request.POST[key]
        request.POST = data

        return self.put_detail(request, *args, **kwargs)

    def delete_detail(self, request, *args, **kwargs):
        """
        DELETE handler. Only supports deletion of single items at the moment.
        """
        instance = self.detail_object_or_404()

        if not self.modelview.deletion_allowed(request, instance):
            raise APIException(status=httplib.FORBIDDEN, data={
                'messages': [{
                    'message': '%s' % msg,
                    'tags': msg.tags,
                } for msg in get_messages(request)],
            })

        instance.delete()
        return self.serialize_response({}, status=httplib.NO_CONTENT)

########NEW FILE########
__FILENAME__ = modelview
from __future__ import absolute_import, unicode_literals

import json

from django.forms.models import model_to_dict
from django.http import Http404, HttpResponse
from django.shortcuts import get_object_or_404, render

from towel.modelview import ModelView
from towel.utils import app_model_label, changed_regions


class EditLiveModelView(ModelView):
    #: The form class used for live editing. Should only contain fields
    #: for which editing through the editlive mechanism is allowed.
    editlive_form = None

    def editlive(self, request, *args, **kwargs):
        if not self.editlive_form:
            raise Http404('No live editing support.')

        instance = self.get_object_or_404(request, *args, **kwargs)

        data = model_to_dict(
            instance,
            fields=self.editlive_form._meta.fields,
            exclude=self.editlive_form._meta.exclude)

        for key, value in request.POST.items():
            data[key] = value

        form = self.editlive_form(data, instance=instance, request=request)

        if form.is_valid():
            return self.response_editlive(request, form.save(), form, {})

        return HttpResponse(
            json.dumps({'!form-errors': dict(form.errors)}),
            content_type='application/json')

    def response_editlive(self, request, new_instance, form, formsets):
        regions = {}
        self.render_detail(request, {
            self.template_object_name: new_instance,
            'regions': regions,
        })
        data = {'!form-errors': {}}
        data.update(changed_regions(regions, form.changed_data))
        return HttpResponse(json.dumps(data), content_type='application/json')


class ParentModelView(EditLiveModelView):
    def response_edit(self, request, new_instance, form, formsets):
        return self.response_editlive(request, new_instance, form, formsets)

    def render_form(self, request, context, change):
        if change:
            context.setdefault('base_template', 'modal.html')
        return super(ParentModelView, self).render_form(
            request, context, change=change)


class InlineModelView(EditLiveModelView):
    parent_attr = 'parent'

    @property
    def parent_class(self):
        return self.model._meta.get_field(self.parent_attr).rel.to

    def get_object(self, request, *args, **kwargs):
        if 'pk' in kwargs:
            kwargs[self.parent_attr] = kwargs.pop('parent')
        return super(InlineModelView, self).get_object(
            request, *args, **kwargs)

    def add_view(self, request, parent):
        request._parent = get_object_or_404(self.parent_class, id=parent)
        return super(InlineModelView, self).add_view(request)

    def save_model(self, request, instance, form, change):
        if hasattr(request, '_parent'):
            setattr(instance, self.parent_attr, request._parent)
        super(InlineModelView, self).save_model(
            request, instance, form=form, change=change)

    def response_add(self, request, instance, *args, **kwargs):
        regions = {}
        render(
            request,
            '%s/%s_detail.html' % app_model_label(self.parent_class),
            {
                'object': getattr(instance, self.parent_attr),
                'regions': regions,
            },
        )
        return HttpResponse(
            json.dumps(changed_regions(regions, [
                '%s_set' % self.model.__name__.lower(),
            ])),
            content_type='application/json',
        )

    response_delete = response_editlive = response_edit = response_add
    # TODO what about response_adding_denied, response_editing_denied and
    # response_deletion_denied?

########NEW FILE########
__FILENAME__ = managers
from __future__ import absolute_import, unicode_literals

from functools import reduce
import re

from django.db.models import Q

from towel import queryset_transform


def normalize_query(query_string,
                    findterms=re.compile(r'"([^"]+)"|(\S+)').findall,
                    normspace=re.compile(r'\s{2,}').sub):
    """
    Splits the query string in invidual keywords, getting rid of unecessary
    spaces and grouping quoted words together.

    Example::

        >>> normalize_query(' some random  words "with   quotes  " and spaces')
        ['some', 'random', 'words', 'with quotes', 'and', 'spaces']

    """
    return [normspace(' ', (t[0] or t[1]).strip())
            for t in findterms(query_string)]


class SearchManager(queryset_transform.TransformManager):
    """
    Stupid searching manager

    Does not use fulltext searching abilities of databases. Constructs a query
    searching specified fields for a freely definable search string. The
    individual terms may be grouped by using apostrophes, and can be prefixed
    with + or - signs to specify different searching modes::

        +django "shop software" -satchmo

    Usage example::

        class MyModelManager(SearchManager):
            search_fields = ('field1', 'name', 'related__field')

        class MyModel(models.Model):
            # ...

            objects = MyModelManager()

        MyModel.objects.search('yeah -no')
    """

    search_fields = ()

    def search(self, query):
        """
        This implementation stupidly forwards to _search, which does the
        gruntwork.

        Put your customizations in here.
        """

        return self._search(query)

    def _search(self, query, fields=None, queryset=None):
        if queryset is None:
            queryset = self.all()

        if fields is None:
            fields = self.search_fields

        if not query or not fields:
            return queryset

        for keyword in normalize_query(query):
            negate = False
            if len(keyword) > 1:
                if keyword[0] == '-':
                    keyword = keyword[1:]
                    negate = True
                elif keyword[0] == '+':
                    keyword = keyword[1:]

            if negate:
                q = reduce(
                    lambda p, q: p & q,
                    (~Q(**{'%s__icontains' % f: keyword}) for f in fields),
                    Q())
            else:
                q = reduce(
                    lambda p, q: p | q,
                    (Q(**{'%s__icontains' % f: keyword}) for f in fields),
                    Q())

            queryset = queryset.filter(q)

        return queryset

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = modelview
from __future__ import absolute_import, unicode_literals

from django import forms
from django.contrib import messages
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.core.urlresolvers import NoReverseMatch, reverse
from django.db import models, transaction
from django.forms.formsets import all_valid
from django.forms.models import modelform_factory, inlineformset_factory
from django.http import Http404, HttpResponse, HttpResponseRedirect
from django.shortcuts import redirect, render_to_response
from django.template import RequestContext
from django.utils import six
from django.utils.encoding import force_text
from django.utils.text import capfirst
from django.utils.translation import ugettext_lazy as _, ugettext

from towel import deletion, paginator
from towel.forms import towel_formfield_callback
from towel.utils import (
    app_model_label, related_classes, safe_queryset_and, tryreverse)


class ModelView(object):
    """
    ``ModelView`` offers list views, detail views and CRUD functionality
    """

    # Every view is wrapped with this decorator. Use this if you need
    # f.e. a simple way of ensuring a user is logged in before accessing
    # any view here.
    def view_decorator(self, func):
        """
        Returns the function as-is, does not apply permission checking or
        anything.
        """
        return func

    def crud_view_decorator(self, func):
        """
        Does what ``view_decorator`` above does (which is returning the passed
        view without applying any permission checking or anything).
        """
        return self.view_decorator(func)

    #: Used for detail and edit views
    template_object_name = 'object'

    #: Used for list views
    template_object_list_name = 'object_list'

    #: The base template which all default modelview templates inherit
    #: from
    base_template = 'base.html'

    #: The regular expression for detail URLs. Override this if you
    #: do not want the primary key in the URL.
    urlconf_detail_re = r'(?P<pk>\d+)'

    #: Paginate list views by this much. ``None`` means no pagination (the
    #: default).
    paginate_by = None

    #: By default, showing all objects on one page is allowed
    pagination_all_allowed = True

    #: The paginator class used for pagination
    paginator_class = paginator.Paginator

    #: The editing form class
    form_class = None

    #: Inline formsets. The key is the formset prefix and the formsets dict
    #: key at the same time, the value should be a dict instance which is
    #: used for the inlineformset_factory invocation.
    #:
    #: Example::
    #:
    #:     inlineformset_config = {
    #:         'steps': {'model': Step, 'form': CustomizedStepForm},
    #:         }
    #:
    inlineformset_config = {}

    #: Search form class
    search_form = None

    #: Search form is not only shown on list pages
    search_form_everywhere = False

    #: The form used for batch processing
    batch_form = None

    #: Messages dictionary to centrally control all possible messages
    default_messages = {
        'object_created': (
            messages.SUCCESS,
            _('The new object has been successfully created.')),
        'adding_denied': (
            messages.ERROR,
            _('You are not allowed to add objects.')),
        'object_updated': (
            messages.SUCCESS,
            _('The object has been successfully updated.')),
        'editing_denied': (
            messages.ERROR,
            _('You are not allowed to edit this object.')),
        'object_deleted': (
            messages.SUCCESS,
            _('The object has been successfully deleted.')),
        'deletion_denied': (
            messages.ERROR,
            _('You are not allowed to delete this object.')),
        'deletion_denied_related': (
            messages.ERROR,
            _('Deletion not allowed: There are %(pretty_classes)s related'
                ' to this object.')),
    }

    #: User defined messages
    custom_messages = {}

    def add_message(self, request, message, variables=None, level=None,
                    ignore=None, **kwargs):
        """
        This helper function is used to easily add messages for the current
        user.

        ``message`` may either be a key for the ``custom_messages`` and
        ``default_messages`` dictionary or a string containing the message
        itself.

        ``variables`` may be a dictionary used for string interpolation if the
        message contains placeholders.

        Some default messages already contain a message level specification
        (currently either ``SUCCESS`` or ``ERROR``). The default for all other
        messages is ``messages.INFO``, but this can be overridden by setting
        the ``level`` argument.

        If ``ignore`` is set to a list of message keys, all matching
        ``add_message`` calls during the current request-response cycle will
        be silently ignored.

        Additional keyword arguments are passed on directly to
        ``messages.add_message``. This can be used f.e. to easily add extra
        tags to the message.

        Usage::

            # Add the default object_created message
            self.add_message(request, 'object_created')

            # Add a custom message with a custom level
            self.add_message(request, _('Whatever you mean'),
                level=messages.WARNING)

            # Add extra tags to a default message
            self.add_message(request, 'deletion_denied', extra_tags='funky')

            # Fail loudly, please, if messages aren't enabled
            self.add_message(request, 'editing_denied', fail_silently=False)
        """

        message = force_text(message)

        ignorable = getattr(request, '_towel_add_message_ignore', [])
        if message in ignorable:
            return
        if ignore is not None:
            request._towel_add_message_ignore = ignore

        if message in self.custom_messages:
            message = self.custom_messages[message]
        elif message in self.default_messages:
            message = self.default_messages[message]

        if not isinstance(message, six.string_types):
            level = message[0]
            message = message[1]

        if variables:
            message = message % variables

        if level is None:
            level = messages.INFO

        # We should not fail if the messages framework is disabled
        kwargs.setdefault('fail_silently', True)

        messages.add_message(request, level, message, **kwargs)

    def __init__(self, model, **kwargs):
        self.model = model
        for key, value in kwargs.items():
            if not hasattr(self, key):
                raise TypeError('%s() received an invalid keyword %r' % (
                    self.__class__.__name__, key))
            setattr(self, key, value)

        if not hasattr(self.model, 'get_absolute_url'):
            # Add a simple primary key based URL to the model if it does not
            # have one yet
            self.model.get_absolute_url = models.permalink(
                lambda self: (
                    '%s_%s_detail' % app_model_label(self),
                    (self.pk,),
                    {}))

    def get_query_set(self, request, *args, **kwargs):
        """
        The queryset returned here is used for everything. Override this
        method if you want to show only a subset of objects to the current
        visitor.
        """
        return self.model._default_manager.all()

    def get_template(self, request, action):
        """
        Construct and return a template name for the given action.

        Example::

            self.get_template(request, 'list')

        returns the following template names for ``auth.User``::

            [
                'auth/user_list.html',
                'modelview/object_list.html',
            ]
        """
        return [
            '%s/%s_%s.html' % (app_model_label(self.model) + (action,)),
            'modelview/object_%s.html' % action,
        ]

    def get_urls(self):
        """
        Return all URLs known to this ``ModelView``. You probably do not
        need to override this except if you need more granular view
        decoration than offered with ``view_decorator`` and
        ``crud_view_decorator``. If you need additional URLs, use
        ``additional_urls`` instead.
        """
        from django.conf.urls import patterns, url
        info = app_model_label(self.model)

        urlpatterns = patterns(
            '',
            url(r'^$',
                self.view_decorator(self.list_view),
                name='%s_%s_list' % info),
            url(r'^add/$',
                self.crud_view_decorator(self.add_view),
                name='%s_%s_add' % info),
            url(r'^%s/edit/$' % self.urlconf_detail_re,
                self.crud_view_decorator(self.edit_view),
                name='%s_%s_edit' % info),
            url(r'^%s/delete/$' % self.urlconf_detail_re,
                self.crud_view_decorator(self.delete_view),
                name='%s_%s_delete' % info),
        )

        for spec in self.additional_urls():
            urlp, view = spec[:2]
            if len(spec) > 2:
                ident = spec[2]
            else:
                ident = view.__name__

            urlpatterns += patterns(
                '',
                url(
                    urlp % {
                        'detail': self.urlconf_detail_re,
                        'ident': ident,
                    },
                    view,
                    name=('%s_%s_%%s' % info) % ident
                ),
            )

        urlpatterns += patterns(
            '',
            url(r'^%s/$' % self.urlconf_detail_re,
                self.view_decorator(self.detail_view),
                name='%s_%s_detail' % info),
        )

        return urlpatterns

    def additional_urls(self):
        """
        Define additional URLs for the modelview.

        You are responsible yourself for wrapping the views with permission
        decorators etc.

        The following example will add three views; %(detail)s is replaced with
        the regular expression ``urlconf_detail_re``. The URL pattern name is
        determined by ``<app_label>_<model_name>_<ident>``, where ``ident`` is
        either the third argument in the URL specification or the function name
        of the passed view::

            return [
                (r'^autocomplete/$',
                    self.view_decorator(self.autocomplete)),
                (r'^%(detail)s/statistics/$',
                    self.view_decorator(self.statistics), 'anything'),
                (r'^%(detail)s/something/$',
                    self.crud_view_decorator(self.something), 'something'),
                ]
        """

        return ()

    @property
    def urls(self):
        """
        Property returning the return value of ``get_urls``. Should
        be used inside the URLconf::

            from towel.modelview import ModelView

            urlpatterns = patterns('',
                url(r'^prefix/', include(ModelView(Model).urls)),
            )
        """
        return self.get_urls()

    # HELPERS

    def get_object(self, request, *args, **kwargs):
        """
        Return an instance, raising ``DoesNotExist`` if an error occurs.

        The default implementation simply passes ``*args`` and
        ``**kwargs`` into ``queryset.get``.
        """
        queryset = self.get_query_set(request, *args, **kwargs)

        try:
            return queryset.get(*args, **kwargs)
        except (ValueError, ValidationError):
            raise self.model.DoesNotExist('No %s matches the given query.' % (
                self.model._meta.object_name))

    def get_object_or_404(self, request, *args, **kwargs):
        """
        Return an instance, raising a 404 if it could not be found.
        """
        try:
            return self.get_object(request, *args, **kwargs)
        except self.model.DoesNotExist:
            raise Http404('No %s matches the given query.' % (
                self.model._meta.object_name))

    def get_formfield_callback(self, request):
        """
        Returns a formfield callback used to initialize the model form and
        inline formsets.
        """
        return towel_formfield_callback

    def get_form(self, request, instance=None, change=None, **kwargs):
        """
        Return a form class for further use by add and edit views.

        Override this if you want to specify your own form class used
        for creating and editing objects.
        """

        kwargs.setdefault(
            'formfield_callback', self.get_formfield_callback(request))
        kwargs.setdefault('form', self.form_class or forms.ModelForm)

        return modelform_factory(self.model, **kwargs)

    def extend_args_if_post(self, request, args):
        """
        Helper which prepends POST and FILES to args if request method
        was POST. Ugly and helpful::

            args = self.extend_args_if_post(request, [])
            form = Form(*args, **kwargs)
        """

        if request.method == 'POST':
            args[:0] = [request.POST, request.FILES]

        return args

    def get_form_instance(self, request, form_class, instance=None,
                          change=None, **kwargs):
        """
        Returns the form instance

        Override this if your form class has special needs for instantiation.
        """
        args = self.extend_args_if_post(request, [])
        kwargs['instance'] = instance

        return form_class(*args, **kwargs)

    def get_formset_instances(self, request, instance=None, change=None,
                              **kwargs):
        """
        Return a dict of formset instances. You may freely choose the
        keys for this dict, use a SortedDict or something else as long
        as it has a 'values()' method.

        Please note that the instance passed here has not necessarily
        been saved to the database yet.
        """
        args = self.extend_args_if_post(request, [])
        kwargs['instance'] = instance

        formsets = {}

        formfield_callback = self.get_formfield_callback(request)

        for prefix, config in self.inlineformset_config.items():
            config.setdefault('form', forms.ModelForm)
            config.setdefault('formfield_callback', formfield_callback)

            cls = inlineformset_factory(self.model, extra=0, **config)
            formsets[prefix] = cls(prefix=prefix, *args, **kwargs)

        return formsets

    def get_deletion_form_instance(self, request, instance, **kwargs):
        """
        Returns a form instance which can be used to ask additional
        questions about the deletion before it actually takes place.

        Defaults to an empty form which only verifies that the deletion
        request has been POSTed.
        """
        if request.method == 'POST':
            return forms.Form(request.POST, request.FILES)
        return forms.Form()

    def save_form(self, request, form, change):
        """
        Return an unsaved instance when editing an object.
        """

        return form.save(commit=False)

    def save_model(self, request, instance, form, change):
        """
        Save an object to the database.
        """

        instance.save()

    def save_formsets(self, request, form, formsets, change):
        """
        Loop over all formsets, calling ``save_formset`` for each.
        """
        for formset in formsets.values():
            self.save_formset(request, form, formset, change)

    def save_formset(self, request, form, formset, change):
        """
        Save an individual formset
        """
        formset.save()

    def post_save(self, request, instance, form, formsets, change):
        """
        Hook for adding custom processing after forms, m2m relations
        and formsets have been saved.
        """

        pass

    # VIEW HELPERS

    def get_extra_context(self, request):
        """
        Returns a context containing the following useful variables:

        * ``verbose_name``
        * ``verbose_name_plural``
        * ``list_url``
        * ``add_url``
        * ``base_template``
        * ``adding_allowed``
        * ``search_form`` (if ``search_form_everywhere = True``)
        """
        info = app_model_label(self.model)

        return {
            'verbose_name': self.model._meta.verbose_name,
            'verbose_name_plural': self.model._meta.verbose_name_plural,
            'list_url': tryreverse('%s_%s_list' % info),
            'add_url': tryreverse('%s_%s_add' % info),
            'base_template': self.base_template,

            'adding_allowed': self.adding_allowed(request),

            'search_form': (
                self.search_form(request.GET, request=request)
                if self.search_form_everywhere else None),
        }

    def get_context(self, request, context):
        """
        Creates a ``RequestContext`` and merges the passed context
        and the return value of ``get_extra_context`` into it.
        """
        instance = RequestContext(request, self.get_extra_context(request))
        instance.update(context)
        return instance

    def render(self, request, template, context):
        """
        Render the whole shebang.
        """
        return render_to_response(template, context)

    def render_list(self, request, context):
        """
        Render the list view
        """
        return self.render(
            request,
            self.get_template(request, 'list'),
            self.get_context(request, context))

    def render_detail(self, request, context):
        """
        Render the detail view
        """
        return self.render(
            request,
            self.get_template(request, 'detail'),
            self.get_context(request, context))

    def render_form(self, request, context, change):
        """
        Render the add and edit views
        """
        return self.render(
            request,
            self.get_template(request, 'form'),
            self.get_context(request, context))

    def render_delete_confirmation(self, request, context):
        """
        Render the deletion confirmation page
        """
        return self.render(
            request,
            self.get_template(request, 'delete_confirmation'),
            self.get_context(request, context))

    def response_add(self, request, instance, form, formsets):
        """
        Return the response after successful addition of a new instance
        """
        self.add_message(request, 'object_created')

        if '_continue' in request.POST:
            return HttpResponseRedirect(instance.get_absolute_url() + 'edit/')

        return redirect(instance)

    def response_adding_denied(self, request):
        """
        Return the response when adding instances is denied
        """
        self.add_message(request, 'adding_denied')
        url = tryreverse('%s_%s_list' % app_model_label(self.model))
        return HttpResponseRedirect(url if url else '../../')

    def response_edit(self, request, instance, form, formsets):
        """
        Return the response after an instance has been successfully edited
        """
        self.add_message(request, 'object_updated')

        if '_continue' in request.POST:
            return HttpResponseRedirect('.')

        return redirect(instance)

    def response_editing_denied(self, request, instance):
        """
        Return the response when editing the given instance is denied
        """
        self.add_message(request, 'editing_denied')
        return redirect(instance)

    def response_delete(self, request, instance):
        """
        Return the response when an object has been successfully deleted
        """
        self.add_message(request, 'object_deleted')
        url = tryreverse('%s_%s_list' % app_model_label(self.model))
        return HttpResponseRedirect(url if url else '../../')

    def response_deletion_denied(self, request, instance):
        """
        Return the response when deleting the given instance is not allowed
        """
        self.add_message(request, 'deletion_denied')
        return redirect(instance)

    def paginate_object_list(self, request, queryset, paginate_by=10):
        """
        Helper which paginates the given object list

        Skips pagination if the magic ``all`` GET parameter is set.
        """
        paginator_obj = self.paginator_class(queryset, paginate_by)

        try:
            page = int(request.GET.get('page', '1'))
        except ValueError:
            page = 1

        try:
            page_obj = paginator_obj.page(page)
        except (paginator.EmptyPage, paginator.InvalidPage):
            page_obj = paginator_obj.page(paginator_obj.num_pages)

        if self.pagination_all_allowed and request.GET.get('all'):
            page_obj.object_list = queryset
            page_obj.show_all_objects = True
            page_obj.start_index = 1
            page_obj.end_index = paginator_obj.count

        return page_obj, paginator_obj

    # VIEWS

    def list_view(self, request, *args, **kwargs):
        """
        Handles the listing of objects

        This view knows how to paginate objects and is able
        to handle search and batch forms, too.
        """
        ctx = {}
        queryset = self.get_query_set(request, *args, **kwargs)
        ctx['root_%s' % self.template_object_list_name] = queryset

        queryset, response = self.handle_search_form(request, ctx, queryset)

        if response:
            return response

        response = self.handle_batch_form(request, ctx, queryset)
        if response:
            return response

        ctx['full_%s' % self.template_object_list_name] = queryset

        if self.paginate_by:
            page, paginator = self.paginate_object_list(
                request, queryset, self.paginate_by)

            ctx.update({
                self.template_object_list_name: page.object_list,
                'page': page,
                'paginator': paginator,
            })
        else:
            ctx[self.template_object_list_name] = queryset

        return self.render_list(request, ctx)

    def handle_search_form(self, request, ctx, queryset=None):
        """
        Must return a tuple consisting of a queryset and either a HttpResponse
        or ``None``
        """

        if queryset is None:
            queryset = self.get_query_set(request)

        if self.search_form:
            form = self.search_form(request.GET, request=request)
            if not form.is_valid():
                self.add_message(
                    request,
                    _('The search query was invalid.'),
                    level=messages.ERROR)

                if request.get_full_path().endswith('?clear=1'):
                    # No redirect loop generation
                    raise ImproperlyConfigured(
                        'Search form %r does not validate after'
                        ' clearing.' % form)

                return queryset, HttpResponseRedirect('?clear=1')

            queryset = safe_queryset_and(queryset, form.queryset(self.model))

            ctx['search_form'] = form

        return queryset, None

    def handle_batch_form(self, request, ctx, queryset):
        """
        May optionally return a HttpResponse which is directly returned to the
        browser
        """

        if not self.batch_form:
            return

        form = self.batch_form(request, queryset)
        ctx['batch_form'] = form

        if form.should_process():
            result = form.process()

            if isinstance(result, HttpResponse):
                return result

            elif hasattr(result, '__iter__'):
                messages.success(
                    request,
                    _('Processed the following items: <br>\n %s') % (
                        '<br>\n '.join(
                            force_text(item) for item in result)))

            elif result is not None:
                # Not None, but cannot make sense of it either.
                raise TypeError('Return value %r of %s.process() invalid.' % (
                    result,
                    form.__class__.__name__,
                ))

            url = tryreverse('%s_%s_list' % app_model_label(self.model))
            return HttpResponseRedirect(url if url else '.')

    def detail_view(self, request, *args, **kwargs):
        """
        Simple detail page view
        """
        instance = self.get_object_or_404(request, *args, **kwargs)

        return self.render_detail(request, {
            self.template_object_name: instance,
            'editing_allowed': self.editing_allowed(request, instance),
        })

    def adding_allowed(self, request):
        """
        By default, adding is allowed.
        """

        return True

    def process_form(self, request, instance=None, change=None):
        """
        Processes forms, used by ``add_view`` and ``edit_view``
        """

        new_instance = None
        valid = False
        ModelForm = self.get_form(request, instance, change=change)

        if request.method == 'POST':
            form = self.get_form_instance(
                request, ModelForm, instance=instance, change=change)

            if form.is_valid():
                new_instance = self.save_form(request, form, change=change)
                form_validated = True
            else:
                new_instance = self.model() if instance is None else instance
                form_validated = False

            formsets = self.get_formset_instances(
                request, instance=new_instance, change=change)

            if all_valid(formsets.values()) and form_validated:
                with transaction.commit_on_success():
                    self.save_model(request, new_instance, form, change=change)
                    form.save_m2m()
                    self.save_formsets(request, form, formsets, change=change)
                    self.post_save(
                        request, new_instance, form, formsets, change=change)

                valid = True
        else:
            form = self.get_form_instance(
                request, ModelForm, instance=instance, change=change)
            formsets = self.get_formset_instances(
                request, instance=instance, change=change)

        return form, formsets, new_instance, valid

    def add_view(self, request):
        """
        Add view with some additional formset handling
        """
        if not self.adding_allowed(request):
            return self.response_adding_denied(request)

        form, formsets, new_instance, valid = self.process_form(
            request, change=False)

        if valid:
            return self.response_add(request, new_instance, form, formsets)

        opts = self.model._meta

        context = {
            'title': capfirst(_('Add %s') % force_text(opts.verbose_name)),
            'form': form,
            'formsets': formsets,
        }

        return self.render_form(request, context, change=False)

    def editing_allowed(self, request, instance):
        """
        By default, editing is allowed.
        """

        return True

    def edit_view(self, request, *args, **kwargs):
        """
        Edit view with some additional formset handling
        """
        instance = self.get_object_or_404(request, *args, **kwargs)

        if not self.editing_allowed(request, instance):
            return self.response_editing_denied(request, instance)

        form, formsets, new_instance, valid = self.process_form(
            request, instance=instance, change=True)

        if valid:
            return self.response_edit(request, new_instance, form, formsets)

        opts = self.model._meta

        context = {
            'title': capfirst(
                _('Change %s') % force_text(opts.verbose_name)),
            'form': form,
            'formsets': formsets,
            self.template_object_name: instance,
        }

        return self.render_form(request, context, change=True)

    def deletion_allowed(self, request, instance):
        """
        By default, deletion is not allowed.
        """

        return False

    def deletion_allowed_if_only(self, request, instance, classes):
        """
        Helper which is most useful when used inside ``deletion_allowed``

        Allows the deletion if the deletion cascade only contains
        objects from the given classes. Adds a message if deletion is
        not allowed containing details which classes are preventing
        deletion.

        Example::

            def deletion_allowed(self, request, instance):
                return self.deletion_allowed_if_only(request, instance, [
                    Ticket, TicketUpdate])
        """
        related = set(related_classes(instance))

        related.discard(self.model)
        for class_ in classes:
            related.discard(class_)

        if len(related):
            pretty_classes = [
                force_text(class_._meta.verbose_name_plural)
                for class_ in related]

            if len(pretty_classes) > 1:
                pretty_classes = ''.join((
                    ', '.join('%s' % cls for cls in pretty_classes[:-1]),
                    ugettext(' and '),
                    '%s' % pretty_classes[-1],
                ))
            else:
                pretty_classes = pretty_classes[-1]

            self.add_message(
                request,
                'deletion_denied_related',
                {'pretty_classes': pretty_classes},
                ignore=('deletion_denied',),
            )

        return not len(related)

    def save_formset_deletion_allowed_if_only(self, request, form, formset,
                                              change, classes):
        """
        Helper which has is most useful when used inside ``save_formsets``

        To use this method properly, your model has to inherit from
        ``towel.deletion.Model``. This is NOT enforced. If you ignore this, the
        instances will be deleted by ``formset.save()`` as is the default with
        Django.

        Example::

            def save_formsets(self, requset, form, formsets, change):
                # Allow deleting states when the cascade includes
                # ``SomeModel`` instances only.
                self.save_formset_deletion_allowed_if_only(
                    request, form, formsets['states'], change, [SomeModel])

                # No special handling for other formsets
                self.save_formset(request, form, formsets['otherformset'],
                    change=change)

        """
        with deletion.protect():
            self.save_formset(request, form, formset, change)

        for instance in formset.deleted_objects:
            related = set(related_classes(instance))

            related.discard(instance.__class__)
            for class_ in classes:
                related.discard(class_)

            if len(related):
                pretty_classes = [
                    force_text(class_._meta.verbose_name_plural)
                    for class_ in related]

                if len(pretty_classes) > 1:
                    pretty_classes = ''.join((
                        ', '.join(pretty_classes[:-1]),
                        ugettext(' and '),
                        pretty_classes[-1],
                    ))
                else:
                    pretty_classes = pretty_classes[-1]

                self.add_message(request, 'deletion_denied_related', {
                    'pretty_classes': pretty_classes})
            else:
                instance.delete()

    def delete_view(self, request, *args, **kwargs):
        """
        Handles deletion
        """
        obj = self.get_object_or_404(request, *args, **kwargs)

        if not self.deletion_allowed(request, obj):
            return self.response_deletion_denied(request, obj)

        form = self.get_deletion_form_instance(request, obj)

        if form.is_valid():
            obj.delete()
            return self.response_delete(request, obj)
        else:
            if not hasattr(obj, '_collected_objects'):
                related_classes(obj)

            collected_objects = [
                (key._meta, len(value))
                for key, value in obj._collected_objects.items()]

            return self.render_delete_confirmation(request, {
                'title': capfirst(_('Delete %s') % force_text(
                    self.model._meta.verbose_name)),
                self.template_object_name: obj,
                'collected_objects': collected_objects,
                'form': form,
            })


class _MVUHelper(object):
    def __init__(self, viewname_pattern, kwargs):
        self.viewname_pattern = viewname_pattern
        self.kwargs = kwargs

    def __getitem__(self, item):
        return self.url(item)

    def url(self, item, *args, **kwargs):
        kw = self.kwargs.copy()
        if args:
            kw.setdefault('args', [])
            kw['args'].extend(args)
        elif kwargs:
            kw.setdefault('kwargs', {})
            kw['kwargs'].update(kwargs)

        try:
            return reverse(self.viewname_pattern % item, **kw)
        except NoReverseMatch as e:
            try:
                return reverse(self.viewname_pattern % item)
            except NoReverseMatch:
                # Re-raise exception with kwargs; it's more informative
                raise e


class ModelViewURLs(object):
    """
    Usage::

        class MyModel(models.Model):
            urls = ModelViewURLs(lambda obj: {'pk': obj.pk})

            def get_absolute_url(self):
                return self.urls['detail']

            def get_edit_url(self):
                return self.urls['edit']

            # ... etc
    """

    def __init__(self, reverse_args_fn=None):
        """
        Despite the name, ``reverse_args_fn`` is allowed to return kwargs
        (a dict instance) too
        """
        if reverse_args_fn:
            self.reverse_args_fn = reverse_args_fn
        else:
            self.reverse_args_fn = lambda obj: {'pk': obj.pk}

    def __get__(self, obj, objtype=None):
        if not hasattr(obj, '_modelviewurls_cache'):
            kwargs = {}
            data = self.reverse_args_fn(obj)
            if isinstance(data, dict):
                kwargs['kwargs'] = data
            else:
                kwargs['args'] = data

            viewname_pattern = '%s_%s_%%s' % app_model_label(obj)

            obj._modelviewurls_cache = _MVUHelper(viewname_pattern, kwargs)
        return obj._modelviewurls_cache

########NEW FILE########
__FILENAME__ = api
"""
Making ``towel.api`` multitenancy-aware
=======================================

All you need is a view decorator handling the permissions and a resource
subclass which makes sure that data is only ever shown from one tenant.
"""

from __future__ import absolute_import, unicode_literals

from functools import wraps

from django.http import HttpResponse
from django.utils.six.moves import http_client

from towel import api
from towel.utils import safe_queryset_and


def api_access(minimal):
    """
    Decorator which ensures that the current ``request.access`` model
    provides at least ``minimal`` access.
    """
    def _decorator(func):
        @wraps(func)
        def _fn(request, *args, **kwargs):
            if not request.access:
                return HttpResponse(
                    'No access',
                    status=http_client.UNAUTHORIZED)

            if request.access.access < minimal:
                return HttpResponse(
                    'Insufficient access',
                    status=http_client.UNAUTHORIZED)

            return func(request, *args, **kwargs)
        return _fn
    return _decorator


class Resource(api.Resource):
    """
    Resource subclass which automatically applies filtering by
    ``request.access`` to all querysets used.
    """
    def get_query_set(self):
        return safe_queryset_and(
            super(Resource, self).get_query_set(),
            self.model.objects.for_access(self.request.access),
        )

########NEW FILE########
__FILENAME__ = auth
"""
Authentication backend which preloads access and client models
==============================================================
"""

from __future__ import absolute_import, unicode_literals

from django.contrib.auth.models import User

from towel.auth import ModelBackend as _ModelBackend
from towel.mt import access_model, client_model


class ModelBackend(_ModelBackend):
    """
    Custom authentication backend for towel-mt

    This authentication backend serves two purposes:

    1. Allowing email addresses as usernames (``authenticate``)
    2. Minimizing DB accesses by fetching additional information about the
       current user earlier (``get_user``)
    """

    def get_user(self, user_id):
        Access = access_model()
        Client = client_model()
        try:
            access = Access.objects.select_related(
                'user',
                Client.__name__.lower(),
            ).get(user=user_id)

            # Ensure reverse accesses do not needlessly query the DB again.
            # Maybe Django already does that for us already... whatever.
            setattr(access.user, User.access.cache_name, access)
            return access.user
        except Access.DoesNotExist:
            pass

        try:
            # Fall back to raw user access
            return User.objects.get(id=user_id)
        except User.DoesNotExist:
            pass

        return None

########NEW FILE########
__FILENAME__ = forms
"""
Forms
=====

These three form subclasses will automatically add limitation by tenant
to all form fields with a ``queryset`` attribute.

.. warning::

    If you customized the dropdown using ``choices`` you have to limit the
    choices by the current tenant yourself.
"""

from __future__ import absolute_import, unicode_literals

from django import forms
from django.db.models import FieldDoesNotExist

from towel import forms as towel_forms
from towel.mt import client_model
from towel.utils import safe_queryset_and


def _process_fields(form, request):
    for field in form.fields.values():
        if hasattr(field, 'queryset'):
            model = field.queryset.model

            field.queryset = safe_queryset_and(
                field.queryset,
                model.objects.for_access(request.access),
            )


class Form(forms.Form):
    def __init__(self, *args, **kwargs):
        self.request = kwargs.pop('request')
        super(Form, self).__init__(*args, **kwargs)
        _process_fields(self, self.request)


class ModelForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        self.request = kwargs.pop('request')
        super(ModelForm, self).__init__(*args, **kwargs)
        _process_fields(self, self.request)

    def save(self, commit=True):
        Client = client_model()
        attr = Client.__name__.lower()
        try:
            field = self.instance._meta.get_field(attr)
        except FieldDoesNotExist:
            field = None
        if (field and field.rel and field.rel.to
                and issubclass(field.rel.to, Client)):
            setattr(self.instance, attr, getattr(self.request.access, attr))

        return super(ModelForm, self).save(commit=commit)


class SearchForm(towel_forms.SearchForm):
    def post_init(self, request):
        self.request = request
        _process_fields(self, self.request)


class BatchForm(towel_forms.BatchForm):
    def __init__(self, *args, **kwargs):
        super(BatchForm, self).__init__(*args, **kwargs)
        _process_fields(self, self.request)

########NEW FILE########
__FILENAME__ = middleware
"""
Middleware for a lazy ``request.access`` attribute
==================================================
"""

from __future__ import absolute_import, unicode_literals

from django.db.models import ObjectDoesNotExist
from django.utils.functional import SimpleLazyObject


def get_access(request):
    try:
        return request.user.access
    except (AttributeError, ObjectDoesNotExist):
        return None


class LazyAccessMiddleware(object):
    """
    This middleware (or something equivalent providing a ``request.access``
    attribute must be put in ``MIDDLEWARE_CLASSES`` to use the helpers in
    ``towel.mt``.
    """
    def process_request(self, request):
        request.access = SimpleLazyObject(lambda: get_access(request))

########NEW FILE########
__FILENAME__ = models
"""
Models for multitenant Django projects
======================================

The models for ``towel.mt`` have to be provided by the project where
``towel.mt`` is used, that's why this file is empty.

The simplest models might look like that::

    from django.contrib.auth.models import User
    from django.db import models


    class Client(models.Model):
        name = models.CharField(max_length=100)


    class Access(models.Model):
        EMPLOYEE = 10
        MANAGEMENT = 20

        ACCESS_CHOICES = (
            (EMPLOYEE, 'employee'),
            (MANAGEMENT, 'management'),
            )

        client = models.ForeignKey(Client)
        user = models.OneToOneField(User)
        access = models.SmallIntegerField(choices=ACCESS_CHOICES)


API methods can be protected as follows::

    from towel.api import API
    from towel.api.decorators import http_basic_auth
    from towel.mt.api import Resource, api_access

    # Require a valid login and an associated Access model:
    api_v1 = API('v1', decorators=[
        csrf_exempt,
        http_basic_auth,
        api_access(Access.EMPLOYEE),
        ])
    api_v1.register(SomeModel,
        view_class=Resource,
        )


Other views::

    from towel.mt import AccessDecorator

    # Do this once somewhere in your project
    access = AccessDecorator()


    @access(Access.MANAGEMENT)
    def management_only_view(request):
        # ...
"""
# Intentionally left empty.

from __future__ import absolute_import, unicode_literals

########NEW FILE########
__FILENAME__ = modelview
"""
``ModelView``
=============
==
As long as you use this class, everything should just work (tm).
"""

from __future__ import absolute_import, unicode_literals

from towel import modelview as towel_modelview

import towel.mt
from towel.mt.forms import ModelForm


class ModelView(towel_modelview.ModelView):
    """
    This model view subclass ensures that all querysets are already
    restricted to the current client.

    Furthermore, it requires certain access levels when accessing its
    views; the required access defaults to ``access.MANAGER`` (the
    highest access level), but can be overridden by setting
    ``view_access`` or ``crud_access`` when instantiating the model
    view.
    """

    #: Default access level for all views
    view_access = None

    #: Default access level for CRUD views, falls back to ``view_access``
    #: if not explicitly set
    crud_access = None

    #: The editing form class, defaults to ``towel.mt.forms.ModelForm``
    #: instead of ``django.forms.ModelForm``
    form_class = ModelForm

    def view_decorator(self, func):
        return towel.mt._access_decorator(self.view_access)(func)

    def crud_view_decorator(self, func):
        return towel.mt._access_decorator(
            self.crud_access or self.view_access)(func)

    def get_query_set(self, request, *args, **kwargs):
        return self.model.objects.for_access(request.access)

    def get_form_instance(self, request, form_class, instance=None,
                          change=None, **kwargs):
        args = self.extend_args_if_post(request, [])
        kwargs.update({
            'instance': instance,
            'request': request,  # towel.mt.forms needs that
        })

        return form_class(*args, **kwargs)

########NEW FILE########
__FILENAME__ = paginator
"""
Drop-in replacement for Django's ``django.core.paginator`` with additional
goodness

Django's paginator class has a ``page_range`` method returning a list of all
available pages. If you got lots and lots of pages this is not very helpful.
Towel's page class (**not** paginator class!) sports a ``page_range`` method
too which only returns a few pages at the beginning and at the end of the page
range and a few pages around the current page.

All you have to do to use this module is replacing all imports from
``django.core.paginator`` with ``towel.paginator``. All important classes and
all exceptions are available inside this module too.

The page range parameters can be customized by adding a ``PAGINATION`` setting.
The defaults are as follows::

    PAGINATION = {
        'START': 6, # pages at the beginning of the range
        'END': 6, # pages at the end of the range
        'AROUND': 5, # pages around the current page
        }
"""

from __future__ import absolute_import, unicode_literals

from django.conf import settings
from django.core import paginator


__all__ = ('InvalidPage', 'PageNotAnInteger', 'EmptyPage', 'Paginator', 'Page')


# Import useful exceptions into the local scope
InvalidPage = paginator.InvalidPage
PageNotAnInteger = paginator.PageNotAnInteger
EmptyPage = paginator.EmptyPage


#: Paginator configuration
PAGINATION = getattr(settings, 'PAGINATION', {
    'START': 6,   # items at the start
    'END': 6,     # items at the end
    'AROUND': 5,  # items around the current page
})


def filter_adjacent(iterable):
    """Collapse identical adjacent values"""
    # Generate an object guaranteed to not exist inside the iterable
    current = type(str('Marker'), (object,), {})

    for item in iterable:
        if item != current:
            current = item
            yield item


class Paginator(paginator.Paginator):
    """
    Custom paginator returning a Page object with an additional page_range
    method which can be used to implement Digg-style pagination
    """
    def page(self, number):
        return Page(paginator.Paginator.page(self, number))


class Page(paginator.Page):
    """
    Page object for Digg-style pagination
    """
    def __init__(self, page):
        # We do not call super.__init__, because we're only a wrapper / proxy
        self.__dict__ = page.__dict__

    @property
    def page_range(self):
        """
        Generates a list for displaying Digg-style pagination

        The page numbers which are left out are indicated with a ``None``
        value.  Please note that Django's paginator own ``page_range`` method
        isn't overwritten -- Django's ``page_range`` is a method of the
        ``Paginator`` class, not the ``Page`` class.

        Usage::

            {% for p in page.page_range %}
                {% if p == page.number %}
                    {{ p }} <!-- current page -->
                {% else %}
                    {% if p is None %}
                        &hellip;
                    {% else %}
                        <a href="?page={{ p }}">{{ p }}</a>
                    {% endif %}
                {% endif %}
            {% endfor %}
        """
        return filter_adjacent(self._generate_page_range())

    def _generate_page_range(self):
        num_pages = self.paginator.num_pages

        for i in range(1, num_pages + 1):
            if i <= PAGINATION['START']:
                yield i

            elif i > num_pages - PAGINATION['END']:
                yield i

            elif abs(self.number - i) <= PAGINATION['AROUND']:
                yield i

            else:
                yield None  # Ellipsis marker

########NEW FILE########
__FILENAME__ = queryset_transform
# Straight import from https://github.com/simonw/django-queryset-transform

"""
django_queryset_transform
=========================

Allows you to register a transforming map function with a Django QuerySet
that will be executed only when the QuerySet itself has been evaluated.

This allows you to build optimisations like "fetch all tags for these 10 rows"
while still benefiting from Django's lazy QuerySet evaluation.

For example::

    def lookup_tags(item_qs):
        item_pks = [item.pk for item in item_qs]
        m2mfield = Item._meta.get_field_by_name('tags')[0]
        tags_for_item = Tag.objects.filter(
            item__in = item_pks
        ).extra(select = {
            'item_id': '%s.%s' % (
                m2mfield.m2m_db_table(), m2mfield.m2m_column_name()
            )
        })
        tag_dict = {}
        for tag in tags_for_item:
            tag_dict.setdefault(tag.item_id, []).append(tag)
        for item in item_qs:
            item.fetched_tags = tag_dict.get(item.pk, [])

    qs = Item.objects.filter(name__contains = 'e').transform(lookup_tags)

    for item in qs:
        print item, item.fetched_tags

Prints::

    Winter comes to Ogglesbrook [<sledging>, <snow>, <winter>, <skating>]
    Summer now [<skating>, <sunny>]

But only executes two SQL queries - one to fetch the items, and one to fetch
ALL of the tags for those items.

Since the transformer function can transform an evaluated QuerySet, it
doesn't need to make extra database calls at all - it should work for things
like looking up additional data from a cache.multi_get() as well.

Originally inspired by http://github.com/lilspikey/django-batch-select/



LICENSE
=======

Copyright (c) 2010, Simon Willison.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of Django nor the names of its contributors may be used
       to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from __future__ import absolute_import, unicode_literals

from django.db import models


class TransformQuerySet(models.query.QuerySet):
    def __init__(self, *args, **kwargs):
        super(TransformQuerySet, self).__init__(*args, **kwargs)
        self._transform_fns = []

    def _clone(self, klass=None, setup=False, **kw):
        c = super(TransformQuerySet, self)._clone(klass, setup, **kw)
        c._transform_fns = self._transform_fns[:]
        return c

    def transform(self, *fn):
        c = self._clone()
        c._transform_fns.extend(fn)
        return c

    def iterator(self):
        result_iter = super(TransformQuerySet, self).iterator()
        if self._transform_fns:
            results = list(result_iter)
            for fn in self._transform_fns:
                fn(results)
            return iter(results)
        return result_iter


if hasattr(models.Manager, 'from_queryset'):
    TransformManager = models.Manager.from_queryset(TransformQuerySet)

else:
    class TransformManager(models.Manager):
        def get_queryset(self):
            return TransformQuerySet(self.model, using=self._db)

        def get_query_set(self):
            return TransformQuerySet(self.model, using=self._db)

        def transform(self, *fn):
            return self.get_query_set().transform(*fn)

########NEW FILE########
__FILENAME__ = quick
"""
This module beefs up the default full text search field to be a little
bit more versatile. It allows specifying patterns such as ``is:unread``
or ``!important`` which are extracted from the query string and returned
as standalone values allowing the implementation of a search syntax
known from f.e. Google Mail.

Quick rules always consist of two parts: A regular expression pulling
values out of the query string and a mapper which maps the values from
the regex to something else which may be directly usable by forms.

Usage example::

    QUICK_RULES = [
        (re.compile(r'!!'), quick.static(important=True)),
        (re.compile(r'@(?P<username>\w+)'),
            quick.model_mapper(User.objects.all(), 'assigned_to')),
        (re.compile(r'\^\+(?P<due>\d+)'),
            lambda v: {'due': date.today() + timedelta(days=int(v['due']))}),
        (re.compile(r'=(?P<estimated_hours>[\d\.]+)h'),
            quick.identity()),
        ]

    data, rest = quick.parse_quickadd(
        request.POST.get('quick', ''),
        QUICK_RULES)

    data['notes'] = ' '.join(rest)  # Everything which could not be parsed
                                    # is added to the ``notes`` field.
    form = TicketForm(data)

.. note::

   The mappers always get the regex matches ``dict`` and return a
   ``dict``.
"""

from __future__ import absolute_import, unicode_literals

from datetime import date, timedelta

from django.utils import dateformat
from django.utils.datastructures import MultiValueDict
from django.utils.encoding import force_text
from django.utils.translation import ugettext as _


def parse_quickadd(quick, regexes):
    """
    The main workhorse. Named ``parse_quickadd`` for historic reasons,
    can be used not only for adding but for searching etc. too. In fact,
    :class:`towel.forms.SearchForm` supports quick rules out of the box
    when they are specified in ``quick_rules``.
    """

    data = {}
    rest = []

    while quick:
        for regexp, extract in regexes:
            match = regexp.match(quick)
            if match:
                for key, value in extract(match.groupdict()).items():
                    data.setdefault(key, []).append(value)

                quick = quick[len(match.group(0)):].strip()
                break

        else:
            splitted = quick.split(' ', 1)
            if len(splitted) < 2:
                rest.append(quick)
                break

            rest.append(splitted[0])
            quick = splitted[1]

    return MultiValueDict(data), rest


def identity():
    """
    Identity mapper. Returns the values from the regular expression
    directly.
    """
    return (lambda value: value)


def model_mapper(queryset, attribute):
    """
    The regular expression needs to return a dict which is directly passed
    to ``queryset.get()``. As a speciality, this mapper returns both the
    primary key of the instance under the ``attribute`` name, and the instance
    itself as ``attribute_``.
    """
    def _fn(values):
        try:
            instance = queryset.get(**values)
            return {
                attribute: instance.pk,
                attribute + '_': instance,
            }
        except (queryset.model.DoesNotExist, KeyError, TypeError, ValueError):
            return {}
    return _fn


def static(**kwargs):
    """
    Return a predefined ``dict`` when the given regex matches.
    """
    return (lambda values: kwargs)


def model_choices_mapper(data, attribute):
    """
    Needs a ``value`` provided by the regular expression and returns
    the corresponding ``key`` value.

    Example::

        class Ticket(models.Model):
            VISIBILITY_CHOICES = (
                ('public', _('public')),
                ('private', _('private')),
                )
            visibility = models.CharField(choices=VISIBILITY_CHOICES)

        QUICK_RULES = [
            (re.compile(r'~(?P<value>[^\s]+)'), quick.model_choices_mapper(
                Ticket.VISIBILITY_CHOICES, 'visibility')),
            ]
    """
    def _fn(values):
        reverse = dict((force_text(value), key) for key, value in data)
        try:
            return {attribute: reverse[values['value']]}
        except KeyError:
            return {}
    return _fn


def due_mapper(attribute):
    """
    Understands ``Today``, ``Tomorrow``, the following five localized
    week day names or (partial) dates such as ``20.12.`` and ``01.03.2012``.
    """
    def _fn(values):
        today = date.today()
        due = values['due']

        days = [(dateformat.format(d, 'l'), d) for d in [
            (today + timedelta(days=d)) for d in range(2, 7)]]
        days.append((_('Today'), today))
        days.append((_('Tomorrow'), today + timedelta(days=1)))
        days = dict((k.lower(), value) for k, value in days)

        if due.lower() in days:
            return {attribute: days[due.lower()]}

        day = [today.year, today.month, today.day]
        try:
            for i, n in enumerate(due.split('.')):
                day[2 - i] = int(n, 10)
        except (IndexError, TypeError, ValueError):
            pass

        try:
            return {attribute: date(*day)}
        except (TypeError, ValueError):
            pass

        return {}
    return _fn


def bool_mapper(attribute):
    """
    Maps ``yes``, ``1`` and ``on`` to ``True`` and ``no``, ``0``
    and ``off`` to ``False``.
    """
    def _fn(values):
        if values['bool'].lower() in ('yes', '1', 'on', 'true'):
            return {attribute: True}
        elif values['bool'].lower() in ('no', '0', 'off', 'false'):
            return {attribute: False}
        return {}
    return _fn

########NEW FILE########
__FILENAME__ = base
"""
This is an experiment in splitting up the monolithic model view class into
smaller, more reusable parts, and using class-based views at the same time
(not the generic class based views, though)

The basic idea is that creating a new instance for every request and having
different classes handling different types of requests (listing, details,
editing etc.) are both really good ideas. That's what Django's class-based
views do, and they do it quite well. However, sharing functionality between
those different classes is hard: Adding limits to querysets centrally, adding
a common set of list/detail/crud views, adding the same context variables to
all views for the same Django model are all harder than they should be.

That's where ``towel.resources`` really shines. All views inherit from
``ModelResourceView`` which in turn inherits all functionality of
``django.views.generic.base.TemplateView``. Many methods such as
``get_queryset``, ``get_context_data``, ``get_form_kwargs`` etc. are closely
modelled after the generic class-based views of Django itself, the inheritance
hierarchy is a lot simpler and we use less mixins, and less inversion of
control which should make code written with ``towel.resources`` easier to
understand and follow.

At least that's one of our goals here.
"""

from __future__ import absolute_import, unicode_literals

import json

from django import forms
from django.contrib import messages
from django.core.exceptions import ImproperlyConfigured, PermissionDenied
from django.core.urlresolvers import NoReverseMatch
from django.forms.models import modelform_factory, model_to_dict
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, redirect
from django.utils.encoding import force_text
from django.utils.text import capfirst
from django.utils.translation import ugettext as _
from django.views.generic.base import TemplateView

from towel.forms import BatchForm, towel_formfield_callback
from towel.paginator import Paginator, EmptyPage, InvalidPage
from towel.utils import (
    app_model_label, changed_regions, related_classes, safe_queryset_and)


class ModelResourceView(TemplateView):
    """
    This is the base class of all views in ``towel.resources``.
    """

    #: The ``base_template`` variable is passed into the template context
    #: when rendering any templates. It's most useful when adding a base
    #: template which should always be used when rendering templates related
    #: to a single model. A practical example might be adding the same sidebar
    #: to all resources related to a specific model.
    base_template = 'base.html'

    #: The model. Required.
    model = None

    #: Overrides the queryset used for rendering. Override ``get_queryset``
    #: below if you have more advanced needs.
    queryset = None

    #: Part of the template name. Is set in most view classes to a sane value
    #: such as ``_list``, ``_detail``, ``_form`` or something similar.
    template_name_suffix = None

    def url(self, item, *args, **kwargs):
        """
        Helper for reversing URLs related to the resource model. Works the
        same way as ``towel.modelview.ModelViewURLs`` (and is most useful
        if used together).

        Usage examples::

            self.url('list')

            self.url('edit', pk=self.object.pk)
            # equals self.object.urls.url('edit') if using ModelViewURLs
        """
        fail_silently = kwargs.pop('fail_silently', False)

        try:
            if getattr(self, 'object', None):
                return self.object.urls.url(item, *args, **kwargs)
            return self.model().urls.url(item, *args, **kwargs)
        except NoReverseMatch:
            if not fail_silently:
                raise
            return None

    def get_title(self):
        """
        Returns a sane value for the ``title`` template context variable.
        """
        return None

    def get_context_data(self, **kwargs):
        """
        Fills the standard context with default variables useful for all
        model resource views:

        - ``base_template``: Described above.
        - ``verbose_name`` and ``verbose_name_plural``: Current model.
        - ``view``: The view instance.
        - ``add_url`` and ``list_url``: The mose important URLs for the model.
        - ``title``: Described above.
        """
        opts = self.model._meta
        context = {
            'base_template': self.base_template,
            'verbose_name': opts.verbose_name,
            'verbose_name_plural': opts.verbose_name_plural,
            'view': self,

            'add_url': self.url('add', fail_silently=True),
            'list_url': self.url('list', fail_silently=True),
        }
        title = self.get_title()
        if title:
            context['title'] = title
        context.update(kwargs)
        return context

    def get_template_names(self):
        """
        Returns a list of template names related to the current model and view:

        - ``self.template_name`` if it's set.
        - ``<app_label>/<model_name><template_name_suffix>.html
        - ``resources/object<template_name_suffix>.html
        """
        names = [
            '{0}/{1}{2}.html'.format(
                *(app_model_label(self.model) + (self.template_name_suffix,))),
            'resources/object{0}.html'.format(self.template_name_suffix),
        ]
        if self.template_name:
            names.insert(0, self.template_name)
        return names

    def get_queryset(self):
        """
        Returns the queryset used everywhere.

        Defaults to ``self.model._default_manager.all()``.
        """
        if self.queryset is not None:
            return self.queryset._clone()
        elif self.model is not None:
            return self.model._default_manager.all()
        else:
            raise ImproperlyConfigured("'%s' must define 'queryset' or 'model'"
                                       % self.__class__.__name__)

    def get_object(self):
        """
        Returns a single object for detail views or raises ``Http404``.

        The default implementation passes all keyword arguments extracted from
        the URL into ``get_object_or_404``.
        """
        return get_object_or_404(self.get_queryset(), **self.kwargs)

    def allow_add(self, silent=True):
        """
        Whether adding objects should be allowed. Defaults to ``True``.

        If ``silent=False`` you can optionally add a message in your own
        implementation.
        """
        return True

    def allow_edit(self, object=None, silent=True):
        """
        Whether editing objects should be allowed. Defaults to ``True``.

        Should determine whether editing objects is allowed under any
        circumstances if ``object=None``.
        """
        return True

    def allow_delete(self, object=None, silent=True):
        """
        Whether deleting objects should be allowed. Defaults to ``False``.

        Should determine whether editing objects is allowed under any
        circumstances if ``object=None``.

        Adds a message that deletion is not allowed when ``silent=False``.
        """
        if not silent:
            opts = self.model._meta
            if object is None:
                messages.error(self.request, _(
                    'You are not allowed to'
                    ' delete %(verbose_name_plural)s.'
                ) % opts.__dict__)
            else:
                messages.error(self.request, _(
                    'You are not allowed to'
                    ' delete this %(verbose_name)s.'
                ) % opts.__dict__)
        return False

    def allow_delete_if_only(self, object, related=(), silent=True):
        """
        This helper is most useful when used inside ``allow_delete``. It can
        be used to easily determine whether there are related instances which
        would be deleted as well.

        Returns ``True`` if the classes only belong to the model itself and
        to the clsasses mentioned in ``related``.
        """
        classes = set(related_classes(object)).difference(
            (self.model,), related)
        if not classes:
            return True
        if not silent:
            messages.error(
                self.request,
                _('Deletion not allowed because of related objects: %s') % (
                    ', '.join(
                        force_text(cls._meta.verbose_name_plural)
                        for cls in classes
                    ),
                )
            )
        return False


class ListView(ModelResourceView):
    """
    View used for listing objects. Has support for pagination, search forms
    and batch actions similar to the actions built into Django's admin
    interface.
    """

    #: Objects per page. Defaults to ``None`` which means no pagination.
    paginate_by = None

    #: Search form class.
    search_form = None

    #: ``object_list.html`` it is.
    template_name_suffix = '_list'

    def get_paginate_by(self, queryset):
        """
        Returns the value of ``self.paginate_by``.
        """
        # if self.paginate_all_allowed and self.request.GET.get('all'):
        #     return None
        return self.paginate_by

    def get_context_data(self, object_list=None, **kwargs):
        """
        Adds ``object_list`` to the context, and ``page`` and ``paginator``
        as well if paginating.
        """
        context = super(ListView, self).get_context_data(
            object_list=object_list, **kwargs)

        if object_list is not None:
            paginate_by = self.get_paginate_by(object_list)
            if paginate_by:
                paginator = Paginator(object_list, paginate_by)

                try:
                    page = int(self.request.GET.get('page'))
                except (TypeError, ValueError):
                    page = 1
                try:
                    page = paginator.page(page)
                except (EmptyPage, InvalidPage):
                    page = paginator.page(paginator.num_pages)

                context.update({
                    'object_list': page.object_list,
                    'page': page,
                    'paginator': paginator,
                })

        return context

    def get(self, request, *args, **kwargs):
        """
        Handles the search form and batch action handling.
        """
        self.object_list = self.get_queryset()
        context = {}

        if self.search_form:
            form = self.search_form(self.request.GET, request=self.request)
            if not form.is_valid():
                messages.error(
                    self.request, _('The search query was invalid.'))
                return HttpResponseRedirect('?clear=1')
            self.object_list = safe_queryset_and(
                self.object_list,
                form.queryset(self.model),
            )
            context['search_form'] = form

        context.update(self.get_context_data(object_list=self.object_list))

        actions = self.get_batch_actions()
        if actions:
            form = BatchForm(self.request, self.object_list)
            form.actions = actions
            form.fields['action'] = forms.ChoiceField(
                label=_('Action'),
                choices=[('', '---------')] + [row[:2] for row in actions],
                widget=forms.HiddenInput,
            )
            context['batch_form'] = form

            if form.should_process():
                action = form.cleaned_data.get('action')
                name, title, fn = [a for a in actions if action == a[0]][0]
                result = fn(form.batch_queryset)
                if isinstance(result, HttpResponse):
                    return result
                elif hasattr(result, '__iter__'):
                    messages.success(
                        self.request,
                        _(
                            '<p>Processed the following items:</p>'
                            ' <ul><li>%s</li></ul>'
                        ) % (
                            '</li><li>'.join(
                                force_text(item) for item in result
                            )
                        )
                    )
                elif result is not None:
                    # Not None, but cannot make sense of it either.
                    raise TypeError('Return value %r of %s invalid.' % (
                        result, fn.__name__))

                return redirect(self.url('list'))

        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        """
        Calls ``self.get`` because of the batch action handling.
        """
        return self.get(request, *args, **kwargs)

    def get_batch_actions(self):
        """
        Returns a list of batch action tuples ``(key, name, handler_fn)``

        * ``key``: Something nice, such as ``delete_selected``.
        * ``name``: Will be shown in the dropdown.
        * ``handler_fn``: Callable. Receives the request and the queryset.
        """
        return [
            ('delete_selected', _('Delete selected'), self.delete_selected),
        ]

    def batch_action_hidden_fields(self, queryset, additional=[]):
        """
        Returns a blob of HTML suitable for jumping back into the batch
        action handler. Most useful for batch action handlers needing to
        present a confirmation and/or form page to the user.

        See ``delete_selected`` below for the usage.
        """
        post_values = [('batchform', 1)] + additional + [
            ('batch_%s' % item.pk, '1') for item in queryset]

        return '\n'.join(
            '<input type="hidden" name="%s" value="%s">' % item
            for item in post_values)

    def delete_selected(self, queryset):
        """
        Action which deletes all selected items provided:

        - Their deletion is allowed.
        - Confirmation is given on a confirmation page.
        """
        allowed = [self.allow_delete(item) for item in queryset]
        queryset = [item for item, perm in zip(queryset, allowed) if perm]

        if not queryset:
            messages.error(self.request, _(
                'You are not allowed to delete any'
                ' object in the selection.'))
            return

        elif not all(allowed):
            messages.warning(self.request, _(
                'Deletion of some objects not allowed. Those have been'
                ' excluded from the selection already.'))

        if 'confirm' in self.request.POST:
            messages.success(self.request, _('Deletion successful.'))
            # Call all delete() methods individually
            [item.delete() for item in queryset]
            return

        context = super(ListView, self).get_context_data(
            title=_('Delete selected'),
            action_queryset=queryset,
            action_hidden_fields=self.batch_action_hidden_fields(queryset, [
                ('batch-action', 'delete_selected'),
                ('confirm', 1),
            ]),
        )
        self.template_name_suffix = '_action'
        return self.render_to_response(context)


class DetailView(ModelResourceView):
    """
    Detail view. Nuff said.
    """
    template_name_suffix = '_detail'

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        context = self.get_context_data(object=self.object)
        return self.render_to_response(context)

    @classmethod
    def render_regions(cls, view, **kwargs):
        """
        This is mostly helpful when using ``{% region %}`` template tags. It
        returns all regions when rendering the detail page of the passed
        view. Those regions still have to be filtered using ``changed_regions``
        if you do not want to exchange all snippets.

        When editing data which is used to render a detail page of the same
        or of a different, related model instance, rendering the detail page
        and extracting (potentially) changed parts is necessary for
        live-updating the affected HTML snippets in the frontend.

        This class method achieves exactly that.

        Usage examples::

            # When editing the same model as is on display
            regions = DetailView.render_regions(self)

            # When using towel.resources.inlines
            regions = DetailView.render_regions(self,
                model=self.get_parent_class(),
                object=self.parent,
                )
        """
        self = cls()
        self.request = view.request
        self.model = view.model
        self.object = view.object  # This is, of course, not always correct.
        for key, value in kwargs.items():
            setattr(self, key, value)

        regions = {}
        context = self.get_context_data(object=self.object, regions=regions)
        self.render_to_response(context).render()
        return regions


class FormView(ModelResourceView):
    """
    Base class for all views handling forms (creations and updates).
    """

    #: Base form class used for editing objects. The default implementation
    #: of ``get_form_class`` below always uses ``modelform_factory`` with
    #: a custom ``formfield_callback``.
    form_class = forms.ModelForm

    #: The object being edited (or ``None`` if creating a new object).
    object = None

    #: ``object_form.html`` should be enough for everyone.
    template_name_suffix = '_form'

    def get_title(self):
        """
        Returns titles suitable for adding or editing objects depending on
        whether ``self.object`` is set or not.
        """
        if self.object and self.object.pk:
            return capfirst(_('Edit %s') % self.object)
        return capfirst(_('Add %s') % self.model._meta.verbose_name)

    def get_form_kwargs(self, **kwargs):
        """
        Returns a dictionary suitable for initializing a model form instance
        when using the dictionary as keyword arguments.

        All passed keyword arguments are added to the dictionary, and may
        be used to override any of ``data``, ``files`` and ``instance``.
        """
        kw = {'instance': self.object}
        if self.request.method in ('POST', 'PUT'):
            kw.update({
                'data': self.request.POST,
                'files': self.request.FILES,
            })
        kw.update(kwargs)
        return kw

    def get_form_class(self):
        """
        Returns the form class used in the view.
        """
        return modelform_factory(
            self.model,
            form=self.form_class,
            formfield_callback=towel_formfield_callback)

    def get_form(self):
        """
        Returns the form instance used in the view.
        """
        return self.get_form_class()(**self.get_form_kwargs())

    def form_valid(self, form):
        """
        Processes the form if validation succeeded.

        The default implementation saves the form first and redirects to
        the detail URL of the returned instance.
        """
        self.object = form.save()
        messages.success(
            self.request,
            _('The %(verbose_name)s has been successfully saved.') %
            self.object._meta.__dict__,
        )
        return redirect(self.object)

    def form_invalid(self, form):
        """
        Processes the form if validation failed.

        The default implementation renders the form again.
        """
        context = self.get_context_data(form=form, object=self.object)
        return self.render_to_response(context)


class AddView(FormView):
    """
    View class handling the creation of new items.

    Checks whether adding objects is allowed first and redirects to the
    list URL for the current model if not.
    """
    def get(self, request, *args, **kwargs):
        if not self.allow_add(silent=False):
            return redirect(self.url('list'))
        form = self.get_form()
        return self.render_to_response(self.get_context_data(form=form))

    def post(self, request, *args, **kwargs):
        if not self.allow_add(silent=False):
            return redirect(self.url('list'))
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        return self.form_invalid(form)


class EditView(FormView):
    """
    View class handling the editing of existing items.

    Fetches the instance from the database first and checks whether editing
    it is allowed next. The permission check is done second because the result
    might depend on the exact object.

    The return value of not found versus permission denied exposes some
    additional information right now. This will not necessarily stay like that
    in the future, do not rely on it.
    """
    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        if not self.allow_edit(self.object, silent=False):
            return redirect(self.object)
        form = self.get_form()
        context = self.get_context_data(form=form, object=self.object)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        if not self.allow_edit(self.object, silent=False):
            return redirect(self.object)
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        return self.form_invalid(form)


class LiveUpdateAfterEditMixin(object):
    """
    Only uses the editlive mechanism for updating. The edit step happens
    inside a standard modal.
    """
    def form_valid(self, form):
        self.object = form.save()

        regions = DetailView.render_regions(self)
        data = {'!form-errors': {}}
        data.update(changed_regions(regions, form.changed_data))
        return HttpResponse(json.dumps(data), content_type='application/json')


class LiveFormView(LiveUpdateAfterEditMixin, FormView):
    """
    View most useful if the detail page contains editlive input fields. This
    is the POST-only resource for updates.

    Only supports updating fields on the model itself, and no many to many
    fields either.
    """
    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        if not self.allow_edit(self.object, silent=True):
            raise PermissionDenied

        form_class = self.get_form_class()
        data = model_to_dict(
            self.object,
            fields=form_class._meta.fields,
            exclude=form_class._meta.exclude)

        for key, value in request.POST.items():
            data[key] = value

        form = form_class(**self.get_form_kwargs(data=data))

        if form.is_valid():
            return self.form_valid(form)

        return HttpResponse(
            json.dumps({'!form-errors': dict(form.errors)}),
            content_type='application/json')


class PickerView(ModelResourceView):
    """
    View handling a picker opened in a modal layer. Requires the editlive
    Javascript code to be loaded for searches to work.
    """
    template_name_suffix = '_picker'

    def get_title(self):
        return capfirst(_('Select a %s') % self.model._meta.verbose_name)

    def get(self, request, *args, **kwargs):
        self.object_list = self.get_queryset()
        regions = None
        query = request.GET.get('query')

        if query is not None:
            self.object_list = safe_queryset_and(
                self.object_list,
                self.model.objects._search(query))
            regions = {}

        context = self.get_context_data(
            object_list=self.object_list,
            regions=regions)
        response = self.render_to_response(context)

        if query is not None:
            response.render()
            data = changed_regions(regions, ['object_list'])
            data['!keep'] = True  # Keep modal open
            return HttpResponse(
                json.dumps(data),
                content_type='application/json')

        return response


class DeleteView(ModelResourceView):
    """
    View class handling the deletion of items.

    Fetches the instance from the database first and checks whether deletion
    it is allowed next. The permission check is done second because the result
    might depend on the exact object.

    The return value of not found versus permission denied exposes some
    additional information right now. This will not necessarily stay like that
    in the future, do not rely on it.

    This view uses a form for the confirmation. The default form is empty and
    validates for all POST requests. You can optionally specify your own form
    if additional confirmation is required.
    """
    #: ``object_delete_confirmation.html``.
    template_name_suffix = '_delete_confirmation'

    #: The form class used for deletions.
    deletion_form_class = forms.Form

    def get_title(self):
        return capfirst(_('Delete %s') % self.object)

    def get_deletion_form(self):
        """
        Returns the form instance. Customize this method if you need custom
        form initialization; ``get_form_class`` and ``get_form_kwargs`` are
        not available for deletions for simplicity.
        """
        if self.request.method == 'POST':
            return self.deletion_form_class(self.request.POST)
        return self.deletion_form_class()

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        if not self.allow_delete(self.object, silent=False):
            return redirect(self.object)
        form = self.get_deletion_form()
        context = self.get_context_data(object=self.object, form=form)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        if not self.allow_delete(self.object, silent=False):
            return redirect(self.object)
        form = self.get_deletion_form()
        if form.is_valid():
            return self.deletion_form_valid(form)
        return self.deletion_form_invalid(form)

    def deletion_form_valid(self, form):
        """
        On successful form validation, the object is deleted and the user is
        redirected to the list view of the model.
        """
        self.object.delete()
        messages.success(
            self.request,
            _('The %(verbose_name)s has been successfully deleted.') %
            self.object._meta.__dict__,
        )
        return redirect(self.url('list'))

    def deletion_form_invalid(self, form):
        context = self.get_context_data(object=self.object, form=form)
        return self.render_to_response(context)

########NEW FILE########
__FILENAME__ = inlines
"""
This is mostly equivalent with Django's inline formsets mechanism, but
used together with editlive.
"""

from __future__ import absolute_import, unicode_literals

import json

from django.core.exceptions import PermissionDenied
from django.forms.models import model_to_dict
from django.http import HttpResponse
from django.shortcuts import get_object_or_404, redirect

from towel.resources.base import DetailView, FormView, LiveFormView, DeleteView
from towel.utils import changed_regions


class ChildMixin(object):
    base_template = 'modal.html'
    parent_attr = 'parent'

    def get_parent_class(self):
        return self.model._meta.get_field(self.parent_attr).rel.to

    def get_parent_queryset(self):
        return self.get_parent_class()._default_manager.all()

    def get_parent(self):
        return get_object_or_404(
            self.get_parent_queryset(),
            pk=self.kwargs[self.parent_attr])

    def update_parent(self):
        regions = DetailView.render_regions(
            self,
            model=self.parent.__class__,
            object=self.parent)

        return HttpResponse(
            json.dumps(changed_regions(regions, [
                '%s_set' % self.model.__name__.lower(),
            ])),
            content_type='application/json')


class ChildFormView(ChildMixin, FormView):
    def get_form_kwargs(self, **kwargs):
        kwargs['prefix'] = self.model.__name__.lower()
        return super(ChildMixin, self).get_form_kwargs(**kwargs)

    def form_valid(self, form):
        setattr(form.instance, self.parent_attr, self.parent)
        self.object = form.save()
        return self.update_parent()


class ChildAddView(ChildFormView):
    def get(self, request, *args, **kwargs):
        if not self.allow_add(silent=False):
            return redirect(self.url('list'))
        self.parent = self.get_parent()
        form = self.get_form()
        return self.render_to_response(self.get_context_data(form=form))

    def post(self, request, *args, **kwargs):
        if not self.allow_add(silent=False):
            return redirect(self.url('list'))
        self.parent = self.get_parent()
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        return self.form_invalid(form)


class ChildEditView(ChildFormView):
    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        self.parent = getattr(self.object, self.parent_attr)
        if not self.allow_edit(self.object, silent=False):
            return redirect(self.object)
        form = self.get_form()
        context = self.get_context_data(form=form, object=self.object)
        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        self.parent = getattr(self.object, self.parent_attr)
        if not self.allow_edit(self.object, silent=False):
            return redirect(self.object)
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        return self.form_invalid(form)


class LiveChildFormView(ChildMixin, LiveFormView):
    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        self.parent = getattr(self.object, self.parent_attr)
        if not self.allow_edit(self.object, silent=True):
            raise PermissionDenied

        form_class = self.get_form_class()
        data = model_to_dict(
            self.object,
            fields=form_class._meta.fields,
            exclude=form_class._meta.exclude)

        for key, value in request.POST.items():
            data[key] = value

        form = form_class(**self.get_form_kwargs(data=data))

        if form.is_valid():
            return self.form_valid(form)

        # TODO that's actually quite ugly
        return HttpResponse('%s' % form.errors)

    def form_valid(self, form):
        self.object = form.save()
        return self.update_parent()


class ChildDeleteView(ChildMixin, DeleteView):
    def deletion_form_valid(self, form):
        """
        On successful form validation, the object is deleted and the user is
        redirected to the list view of the model.
        """
        self.parent = self.get_parent()
        self.object.delete()
        return self.update_parent()

########NEW FILE########
__FILENAME__ = mt
from __future__ import absolute_import, unicode_literals

from django.core.exceptions import ImproperlyConfigured

from towel.utils import safe_queryset_and


class MultitenancyMixin(object):
    def get_queryset(self):
        if self.queryset is not None:
            return safe_queryset_and(
                self.queryset,
                self.queryset.model._default_manager.for_access(
                    self.request.access))
        elif self.model is not None:
            return self.model._default_manager.for_access(
                self.request.access)
        else:
            raise ImproperlyConfigured(
                "'%s' must define 'queryset' or 'model'"
                % self.__class__.__name__)

    def get_parent_queryset(self):
        # towel.resources.inlines.ChildFormView
        return self.get_parent_class()._default_manager.for_access(
            self.request.access)

    def get_form_kwargs(self, **kwargs):
        kwargs['request'] = self.request
        return super(MultitenancyMixin, self).get_form_kwargs(**kwargs)

########NEW FILE########
__FILENAME__ = urls
from __future__ import absolute_import, unicode_literals

from django.conf.urls import url as _url
from django.core.urlresolvers import NoReverseMatch, reverse

from towel import resources
from towel.utils import app_model_label


class _MRUHelper(object):
    def __init__(self, viewname_pattern, kwargs):
        self.viewname_pattern = viewname_pattern
        self.kwargs = kwargs

    def __getitem__(self, item):
        return self.url(item)

    def url(self, item, *args, **kwargs):
        kw = self.kwargs
        if kwargs:
            kw = kw.copy()
            kw['kwargs'].update(kwargs)

        try:
            return reverse(self.viewname_pattern % item, **kw)
        except NoReverseMatch as e:
            try:
                return reverse(self.viewname_pattern % item)
            except NoReverseMatch:
                # Re-raise exception with kwargs; it's more informative
                raise e


def model_resource_urls(
        reverse_kwargs_fn=lambda object: {'pk': object.pk},
        default='detail'):
    """
    Usage::

        @model_resource_urls()
        class MyModel(models.Model):
            pass

        instance = MyModel.objects.get(...)
        instance.urls.url('detail') == instance.get_absolute_url()
    """
    def _dec(cls):
        class _descriptor(object):
            def __get__(self, obj, objtype=None):
                viewname_pattern = '%s_%s_%%s' % app_model_label(obj)
                kwargs = {'kwargs': reverse_kwargs_fn(obj)}
                helper = obj.__dict__['urls'] = _MRUHelper(
                    viewname_pattern, kwargs)
                return helper

        cls.urls = _descriptor()
        cls.get_absolute_url = lambda self: self.urls.url(default)
        return cls
    return _dec


def resource_url_fn(
        model,
        urlconf_detail_re=r'(?P<pk>\d+)',
        mixins=(),
        decorators=(),
        **kwargs):
    """
    Returns a helper function most useful to easily create URLconf entries
    for model resources.

    The list of decorators should be ordered from the outside to the inside,
    in the same order as you would write them when using the ``@decorator``
    syntax.

    Usage::

        project_url = resource_url_fn(
            Project,
            mixins=(ProjectViewMixin,),
            decorators=(login_required,),
            )
        urlpatterns = patterns(
            '',
            project_url('list', url=r'^$', paginate_by=50),
            project_url('detail', url=r'^(?P<pk>\d+)/$'),
            project_url('add', url=r^add/$'),
            project_url('edit'),
            project_url('delete'),
        )

        # the project URLs will be:
        # ^$
        # ^(?P<pk>\d+)/$
        # ^add/$'
        # ^(?P<pk>\d+)/edit/$
        # ^(?P<pk>\d+)/delete/$

    The returned helper function comes with ``mixins`` and ``decorators``
    arguments too. They default to the values passed into the
    ``resource_url_fn``. If you use those arguments, you have to pass the
    full list of mixins and/or decorators you need. You can pass an empty
    list if some view does not need any mixins and/or decorators.
    """

    global_mixins = mixins
    global_decorators = decorators

    default_view_classes = {
        'list': resources.ListView,
        'detail': resources.DetailView,
        'add': resources.AddView,
        'edit': resources.EditView,
        'delete': resources.DeleteView,
    }

    def _fn(
            name,
            _sentinel=None,
            view=None,
            url=None,
            mixins=None,
            decorators=None,
            **kw):

        if _sentinel is not None:
            raise TypeError('name is the only non-keyword')

        urlregex = (
            r'^%s/%s/$' % (urlconf_detail_re, name)
            if url is None else url
        )

        urlname = '%s_%s_%s' % (app_model_label(model) + (name,))

        mixins = global_mixins if mixins is None else mixins
        decorators = global_decorators if decorators is None else decorators

        kws = kwargs.copy()
        kws.update(kw)

        view = default_view_classes[name] if view is None else view
        view = type(view.__name__, mixins + (view,), {})
        view = view.as_view(model=model, **kws)

        for dec in reversed(decorators):
            view = dec(view)

        return _url(urlregex, view, name=urlname)

    return _fn

########NEW FILE########
__FILENAME__ = modelview_detail
from __future__ import absolute_import, unicode_literals

from django import template
from django.db import models
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _


register = template.Library()


@register.filter
def model_details(instance, fields=None):
    """
    Returns a stream of ``verbose_name``, ``value`` pairs for the specified
    model instance::

        <table>
        {% for verbose_name, value in object|model_details %}
            <tr>
                <th>{{ verbose_name }}</th>
                <td>{{ value }}</td>
            </tr>
        {% endfor %}
        </table>
    """

    if not fields:
        _fields = instance._meta.fields
    else:
        _fields = [
            instance._meta.get_field_by_name(f)[0]
            for f in fields.split(',')]

    for f in _fields:
        if f.auto_created:
            continue

        if isinstance(f, models.ForeignKey):
            fk = getattr(instance, f.name)
            if hasattr(fk, 'get_absolute_url'):
                try:
                    value = mark_safe('<a href="%s">%s</a>' % (
                        fk.get_absolute_url(),
                        fk))
                except:  # Whatever.
                    value = fk
            else:
                value = fk

        elif f.choices:
            value = getattr(instance, 'get_%s_display' % f.name)()

        elif isinstance(f, (models.BooleanField, models.NullBooleanField)):
            value = getattr(instance, f.name)
            value = {
                True: _('yes'),
                False: _('no'),
                None: _('unknown'),
            }.get(value, value)

        else:
            value = getattr(instance, f.name)

        yield (f.verbose_name, value)

########NEW FILE########
__FILENAME__ = modelview_list
from __future__ import absolute_import, unicode_literals

from django import template
from django.db import models
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

from towel.templatetags import towel_resources


register = template.Library()


register.inclusion_tag('towel/_pagination.html', takes_context=True)(
    towel_resources.pagination)
register.inclusion_tag('towel/_ordering_link.html', takes_context=True)(
    towel_resources.ordering_link)
register.filter(towel_resources.querystring)


@register.filter
def model_row(instance, fields):
    """
    Shows a row in a modelview object list:

    ::

        {% for object in object_list %}
            <tr>
                {% for verbose_name, field in object|model_row:"name,url" %}
                    <td>{{ field }}</td>
                {% endfor %}
            </tr>
        {% endfor %}

    """

    for name in fields.split(','):
        try:
            f = instance._meta.get_field(name)
        except models.FieldDoesNotExist:
            attr = getattr(instance, name)
            if hasattr(attr, '__call__'):
                yield (name, attr())
            else:
                yield (name, attr)
            continue

        if isinstance(f, models.ForeignKey):
            fk = getattr(instance, f.name)
            if hasattr(fk, 'get_absolute_url'):
                value = mark_safe('<a href="%s">%s</a>' % (
                    fk.get_absolute_url(),
                    fk))
            else:
                value = fk

        elif f.choices:
            value = getattr(instance, 'get_%s_display' % f.name)()

        elif isinstance(f, (models.BooleanField, models.NullBooleanField)):
            value = getattr(instance, f.name)
            value = {
                True: _('yes'),
                False: _('no'),
                None: _('unknown'),
            }.get(value, value)

        else:
            value = getattr(instance, f.name)

        yield (f.verbose_name, value)

########NEW FILE########
__FILENAME__ = towel_batch_tags
from __future__ import absolute_import, unicode_literals

from django import template


register = template.Library()


@register.simple_tag
def batch_checkbox(form, id):
    """
    Checkbox which allows selecting objects for batch processing::

        {% for object in object_list %}
            {% batch_checkbox batch_form object.id %}
            {{ object }} etc...
        {% endfor %}

    This tag returns an empty string if ``batch_form`` does not exist for some
    reason. This makes it easier to write templates when you don't know if the
    batch form will be available or not (f.e. because of a permissions
    requirement).
    """

    if not form or not hasattr(form, 'ids'):
        return ''

    cb = '<input type="checkbox" name="batch_%s" value="%s" class="batch" %s>'

    if id in form.ids:
        return cb % (id, id, 'checked="checked" ')

    return cb % (id, id, '')

########NEW FILE########
__FILENAME__ = towel_form_tags
from __future__ import absolute_import, unicode_literals

from django import forms, template
from django.template.loader import render_to_string


register = template.Library()


def _type_class(item):
    if isinstance(item.field.widget, forms.CheckboxInput):
        return 'checkbox'
    elif isinstance(item.field.widget, forms.DateInput):
        return 'date'
    elif isinstance(item.field.widget, forms.HiddenInput):
        return 'hidden'
    elif isinstance(
            item.field.widget,
            (forms.RadioSelect, forms.CheckboxSelectMultiple)):
        return 'list'
    elif isinstance(item.field.widget, forms.Select):
        return 'choice'
    return 'default'


@register.simple_tag
def form_items(form):
    """
    Render all form items::

        {% form_items form %}
    """
    return ''.join(render_to_string('towel/_form_item.html', {
        'item': field,
        'is_checkbox': isinstance(field.field.widget, forms.CheckboxInput),
        'type_class': _type_class(field),
    }) for field in form if field.name != 'ignore_warnings')


@register.inclusion_tag('towel/_form_item.html')
def form_item(item, additional_classes=None):
    """
    Helper for easy displaying of form items:

    ::

        {% for field in form %}
            {% form_item field %}
        {% endfor %}
    """

    return {
        'item': item,
        'additional_classes': additional_classes,
        'is_checkbox': isinstance(item.field.widget, forms.CheckboxInput),
        'type_class': _type_class(item),
    }


@register.inclusion_tag('towel/_form_item_plain.html')
def form_item_plain(item, additional_classes=None):
    """
    Helper for easy displaying of form items without any additional
    tags (table cells or paragraphs) or labels::

        {% form_item_plain field %}
    """

    return {
        'item': item,
        'additional_classes': additional_classes,
        'is_checkbox': isinstance(item.field.widget, forms.CheckboxInput),
        'type_class': _type_class(item),
    }


@register.tag
def form_errors(parser, token):
    """
    Show all form and formset errors::

        {% form_errors form formset1 formset2 %}

    Silently ignores non-existant variables.
    """

    tokens = token.split_contents()

    return FormErrorsNode(*tokens[1:])


class FormErrorsNode(template.Node):
    def __init__(self, *items):
        self.items = [template.Variable(item) for item in items]

    def render(self, context):
        items = []
        for item in self.items:
            try:
                var = item.resolve(context)
                if isinstance(var, dict):
                    items.extend(var.values())
                elif isinstance(var, (list, tuple)):
                    items.extend(var)
                else:
                    items.append(var)
            except template.VariableDoesNotExist:
                # We do not care too much
                pass

        errors = False
        has_non_field_errors = False

        form_list = []
        formset_list = []

        for i in items:
            if isinstance(i, forms.BaseForm):
                form_list.append(i)
            else:
                formset_list.append(i)

            if getattr(i, 'non_field_errors', lambda: None)():
                errors = True
                has_non_field_errors = True
            if getattr(i, 'errors', None):
                errors = True

        if not errors:
            return ''

        return render_to_string('towel/_form_errors.html', {
            'forms': form_list,
            'formsets': formset_list,
            'errors': errors,
            'has_non_field_errors': has_non_field_errors,
        })


@register.tag
def form_warnings(parser, token):
    """
    Show all form and formset warnings::

        {% form_warnings form formset1 formset2 %}

    Silently ignores non-existant variables.
    """

    tokens = token.split_contents()

    return FormWarningsNode(*tokens[1:])


class FormWarningsNode(template.Node):
    def __init__(self, *items):
        self.items = [template.Variable(item) for item in items]

    def render(self, context):
        items = []
        for item in self.items:
            try:
                var = item.resolve(context)
                if isinstance(var, dict):
                    items.extend(var.values())
                elif isinstance(var, (list, tuple)):
                    items.extend(var)
                else:
                    items.append(var)
            except template.VariableDoesNotExist:
                # We do not care too much
                pass

        warnings = False

        form_list = []
        formset_list = []

        for i in items:
            if isinstance(i, forms.BaseForm):
                form_list.append(i)
                if getattr(i, 'warnings', None):
                    warnings = True
            else:
                formset_list.append(i)
                if any(getattr(f, 'warnings', None) for f in i):
                    warnings = True

        if not warnings:
            return ''

        return render_to_string('towel/_form_warnings.html', {
            'forms': form_list,
            'formsets': formset_list,
            'warnings': True,
        })


@register.tag
def dynamic_formset(parser, token):
    """
    Implements formsets where subforms can be added using the
    ``towel_add_subform`` javascript method::

        {% dynamic_formset formset "activities" %}
            ... form code
        {% enddynamic_formset %}
    """

    tokens = token.split_contents()
    nodelist = parser.parse(('enddynamic_formset',))
    parser.delete_first_token()

    return DynamicFormsetNode(tokens[1], tokens[2], nodelist)


class DynamicFormsetNode(template.Node):
    def __init__(self, formset, slug, nodelist):
        self.formset = template.Variable(formset)
        self.slug = template.Variable(slug)
        self.nodelist = nodelist

    def render(self, context):
        formset = self.formset.resolve(context)
        slug = self.slug.resolve(context)

        result = []

        context.update({
            'empty': True,
            'form_id': '%s-empty' % slug,
            'form': formset.empty_form,
        })
        result.append('<script type="text/template" id="%s-empty">' % slug)
        result.append(self.nodelist.render(context))
        result.append('</script>')
        context.pop()

        for idx, form in enumerate(formset.forms):
            context.update({
                'empty': False,
                'form_id': '%s-%s' % (slug, idx),
                'form': form,
            })
            result.append(self.nodelist.render(context))
            context.pop()

        return ''.join(result)

########NEW FILE########
__FILENAME__ = towel_region
from __future__ import absolute_import, unicode_literals

import re

from django import template
from django.utils.html import conditional_escape
from django.utils.safestring import mark_safe

from towel.utils import parse_args_and_kwargs, resolve_args_and_kwargs


register = template.Library()


def flatatt(attrs):
    """
    Convert a dictionary of attributes to a single string.
    The returned string will contain a leading space followed by key="value",
    XML-style pairs.  It is assumed that the keys do not need to be
    XML-escaped.  If the passed dictionary is empty, then return an empty
    string.
    """
    return ''.join([
        ' %s="%s"' % (k, conditional_escape(v))
        for k, v in attrs.items()])


@register.tag
def region(parser, token):
    """
    Defines a live-updateable region::

        {% region "identifier" fields="family_name,given_name" tag="div" %}
            {# Template code #}
        {% endregion %}

    The identifier should be a short string which is unique for the whole
    project, or at least for a given view. It is used to identify the region
    when live-updating, it should therefore be usable as a part of a HTML
    ``id`` attribute. The identifer should not start with an underscore,
    those names are reserved for internal bookkeeping.

    ``fields`` is a comma-separated list of fields (or other identifiers)
    which are used inside the given region. It is recommended to use the
    field and relation names here, but you are free to use anything you
    want. It can also be left empty if you purely want to update regions by
    their identifier.

    The ``tag`` argument defines the HTML tag used to render the region.
    The default tag is a ``div``.

    Additional keyword arguments will be rendered as attributes. This can
    be used to specify classes, data attributes or whatever you desire.
    """

    nodelist = parser.parse(('endregion',))
    parser.delete_first_token()

    return RegionNode(
        nodelist, *parse_args_and_kwargs(parser, token.split_contents()[1:]))


class RegionNode(template.Node):
    def __init__(self, nodelist, args, kwargs):
        self.nodelist = nodelist
        self.args = args
        self.kwargs = kwargs

    def render(self, context):
        args, kwargs = resolve_args_and_kwargs(context, self.args, self.kwargs)
        return self._render(context, *args, **kwargs)

    def _render(self, context, identifier, fields='', tag='div', **kwargs):
        regions = context.get('regions')

        region_id = 'twrg-%s' % identifier
        output = self.nodelist.render(context)

        if regions is not None:
            regions[region_id] = output
            dependencies = regions.setdefault('_dependencies', {})

            for field in re.split('[,\s]+', str(fields)):
                dependencies.setdefault(field, []).append(region_id)

        kwargs['id'] = region_id

        return mark_safe('<{tag} {attrs}>{output}</{tag}>'.format(
            attrs=flatatt(kwargs),
            output=output,
            tag=tag,
        ))

########NEW FILE########
__FILENAME__ = towel_resources
from __future__ import absolute_import, unicode_literals

from functools import reduce
import operator

from django import template
from django.utils import six
from django.utils.http import urlencode


register = template.Library()


@register.inclusion_tag('towel/_pagination.html', takes_context=True)
def pagination(context, page, paginator, where=None):
    """
    Shows pagination links::

        {% pagination current_page paginator %}

    The argument ``where`` can be used inside the pagination template to
    discern between pagination at the top and at the bottom of an object
    list (if you wish). The default object list template passes
    ``"top"`` or ``"bottom"`` to the pagination template. The default
    pagination template does nothing with this value though.
    """

    return {
        'context': context,
        'page': page,
        'paginator': paginator,
        'where': where,
    }


@register.filter
def querystring(data, exclude='page,all'):
    """
    Returns the current querystring, excluding specified GET parameters::

        {% request.GET|querystring:"page,all" %}
    """

    exclude = exclude.split(',')

    items = reduce(
        operator.add,
        (list((k, v) for v in values) for k, values
            in six.iterlists(data) if k not in exclude),
        [])

    return urlencode(sorted(items))


@register.inclusion_tag('towel/_ordering_link.html', takes_context=True)
def ordering_link(context, field, request, title='', base_url='', **kwargs):
    """
    Shows a table column header suitable for use as a link to change the
    ordering of objects in a list::

        {% ordering_link "" request title=_("Edition") %} {# default order #}
        {% ordering_link "customer" request title=_("Customer") %}
        {% ordering_link "state" request title=_("State") %}

    Required arguments are the field and the request. It is very much
    recommended to add a title too of course.

    ``ordering_link`` has an optional argument, ``base_url`` which is
    useful if you need to customize the link part before the question
    mark. The default behavior is to only add the query string, and nothing
    else to the ``href`` attribute.

    It is possible to specify a set of CSS classes too. The CSS classes
    ``'asc'`` and ``'desc'`` are added automatically by the code depending
    upon the ordering which would be selected if the ordering link were
    clicked (NOT the current ordering)::

        {% ordering_link "state" request title=_("State") classes="btn" %}

    The ``classes`` argument defaults to ``'ordering'``.
    """

    current = request.GET.get('o', '')

    # Automatically handle search form persistency
    data = request.GET.copy()
    if not data:
        form = context.get('search_form')
        if form is not None and getattr(form, 'persistency', False):
            data = form.data

    ctx = {
        'querystring': querystring(data, exclude='page,all,o'),
        'field': field,
        'used': current in (field, '-%s' % field),
        'descending': current == field,
        'title': title,
        'base_url': base_url,
    }
    ctx.update(kwargs)
    return ctx

########NEW FILE########
__FILENAME__ = verbose_name_tags
from __future__ import absolute_import, unicode_literals

import itertools

from django import template


register = template.Library()


PATHS = [
    '_meta',
    'queryset.model._meta',
    'instance._meta',
    'model._meta',
]


def _resolve(instance, last_part):
    for path in PATHS:
        o = instance
        found = True
        for part in itertools.chain(path.split('.'), [last_part]):
            try:
                o = getattr(o, part)
            except AttributeError:
                found = False
                break

        if found:
            return o


@register.filter
def verbose_name(item):
    """
    Pass in anything and it tries hard to return its ``verbose_name``::

        {{ form|verbose_name }}
        {{ object|verbose_name }}
        {{ formset|verbose_name }}
        {{ object_list|verbose_name }}
    """
    return _resolve(item, 'verbose_name')


@register.filter
def verbose_name_plural(item):
    """
    Pass in anything and it tries hard to return its ``verbose_name_plural``::

        {{ form|verbose_name_plural }}
        {{ object|verbose_name_plural }}
        {{ formset|verbose_name_plural }}
        {{ object_list|verbose_name_plural }}
    """
    return _resolve(item, 'verbose_name_plural')

########NEW FILE########
__FILENAME__ = utils
from __future__ import absolute_import, unicode_literals

import itertools
import re

from django.core.urlresolvers import NoReverseMatch, reverse
from django.db.models.deletion import Collector


def related_classes(instance):
    """
    Return all classes which would be deleted if the passed instance
    were deleted too by employing the cascade machinery of Django
    itself. Does **not** return instances, only classes.

    Note! When using Django 1.5, autogenerated models (many to many through
    models) are returned too.
    """
    collector = Collector(using=instance._state.db)
    # We really do not want fast deletion, we absolutely need to know whether
    # there are related objects around!
    collector.can_fast_delete = lambda *args, **kwargs: False
    collector.collect([instance])

    # Save collected objects for later referencing (well yes, it does return
    # instances but we don't have to tell anybody :-)
    instance._collected_objects = collector.data

    return collector.data.keys()


def safe_queryset_and(head, *tail):
    """
    Safe AND-ing of querysets. If one of both queries has its
    DISTINCT flag set, sets distinct on both querysets. Also takes extra
    care to preserve the result of the following queryset methods:

    * ``reverse()``
    * ``transform()``
    * ``select_related()``
    * ``prefetch_related()``
    """

    def _merge(qs1, qs2):
        if qs1.query.distinct or qs2.query.distinct:
            res = qs1.distinct() & qs2.distinct()
        else:
            res = qs1 & qs2

        res._transform_fns = list(set(
            getattr(qs1, '_transform_fns', [])
            + getattr(qs2, '_transform_fns', [])))

        if not (qs1.query.standard_ordering and qs2.query.standard_ordering):
            res.query.standard_ordering = False

        select_related = [qs1.query.select_related, qs2.query.select_related]
        if False in select_related:
            # We are not interested in the default value
            select_related.remove(False)

        if len(select_related) == 1:
            res.query.select_related = select_related[0]
        elif len(select_related) == 2:
            if True in select_related:
                # Prefer explicit select_related to generic select_related()
                select_related.remove(True)

            if len(select_related) > 0:
                # If we have two explicit select_related calls, take any
                res.query.select_related = select_related[0]
            else:
                res = res.select_related()

        res._prefetch_related_lookups = list(
            set(qs1._prefetch_related_lookups)
            | set(qs2._prefetch_related_lookups))

        return res

    while tail:
        head = _merge(head, tail[0])
        tail = tail[1:]
    return head


_KWARG_RE = re.compile("(?:([-\w]+)=)?(.+)")


def parse_args_and_kwargs(parser, bits):
    """
    Parses template tag arguments and keyword arguments

    Returns a tuple ``args, kwargs``.

    Usage::

        @register.tag
        def custom(parser, token):
            return CustomNode(*parse_args_and_kwargs(parser,
                token.split_contents()[1:]))

        class CustomNode(template.Node):
            def __init__(self, args, kwargs):
                self.args = args
                self.kwargs = kwargs

            def render(self, context):
                args, kwargs = resolve_args_and_kwargs(context, self.args,
                    self.kwargs)
                return self._render(context, *args, **kwargs):

            def _render(self, context, ...):
                # The real workhorse
    """
    args = []
    kwargs = {}

    for bit in bits:
        match = _KWARG_RE.match(bit)
        key, value = match.groups()
        value = parser.compile_filter(value)
        if key:
            kwargs[str(key)] = value
        else:
            args.append(value)

    return args, kwargs


def resolve_args_and_kwargs(context, args, kwargs):
    """
    Resolves arguments and keyword arguments parsed by
    ``parse_args_and_kwargs`` using the passed context instance

    See ``parse_args_and_kwargs`` for usage instructions.
    """
    return (
        [v.resolve(context) for v in args],
        dict((k, v.resolve(context)) for k, v in kwargs.items()),
    )


def changed_regions(regions, fields):
    """
    Returns a subset of regions which have to be updated when fields have
    been edited. To be used together with the ``{% regions %}`` template
    tag.

    Usage::

        regions = {}
        render(request, 'detail.html', {
            'object': instance,
            'regions': regions,
            })
        return HttpResponse(
            json.dumps(changed_regions(regions, ['emails', 'phones'])),
            content_type='application/json')
    """
    dependencies = regions.get('_dependencies', {})
    to_update = set(itertools.chain(*[
        dependencies.get(field, []) for field in fields]))

    return dict(
        (key, value) for key, value in regions.items() if key in to_update)


def tryreverse(*args, **kwargs):
    """
    Calls ``django.core.urlresolvers.reverse``, and returns ``None`` on
    failure instead of raising an exception.
    """
    try:
        return reverse(*args, **kwargs)
    except NoReverseMatch:
        return None


def substitute_with(to_delete, instance):
    """
    Substitute the first argument with the second in all relations,
    and delete the first argument afterwards.
    """
    assert to_delete.__class__ == instance.__class__
    assert to_delete.pk != instance.pk

    for related_object in to_delete._meta.get_all_related_objects():
        queryset = related_object.model._base_manager.complex_filter({
            related_object.field.name: to_delete.pk,
        })

        queryset.update(**{related_object.field.name: instance.pk})
    to_delete.delete()


def app_model_label(model):
    """
    Stop those deprecation warnings
    """
    try:
        return model._meta.app_label, model._meta.model_name
    except AttributeError:  # Django <1.6
        return model._meta.app_label, model._meta.module_name

########NEW FILE########
