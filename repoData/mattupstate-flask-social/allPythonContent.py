__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Social documentation build configuration file, created by
# sphinx-quickstart on Mon Mar 12 15:35:21 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('_themes'))
sys.path.append(os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Social'
copyright = u'2012, Matt Wright'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.6.2'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'github_fork': 'mattupstate/flask-social',
    'index_logo': False
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Socialdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Social.tex', u'Flask-Social Documentation',
   u'Matt Wright', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'Flask-Social', u'Flask-Social Documentation',
     [u'Matt Wright'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Flask-Social', u'Flask-Social Documentation',
   u'Matt Wright', 'Flask-Social', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Flask-Social'
epub_author = u'Matt Wright'
epub_publisher = u'Matt Wright'
epub_copyright = u'2012, Matt Wright'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

pygments_style = 'flask_theme_support.FlaskyStyle'

# fall back if theme is not there
try:
    __import__('flask_theme_support')
except ImportError, e:
    print '-' * 74
    print 'Warning: Flask themes unavailable.  Building with default theme'
    print 'If you want the Flask themes, run this command and build again:'
    print
    print '  git submodule update --init'
    print '-' * 74

    pygments_style = 'tango'
    html_theme = 'default'
    html_theme_options = {}

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
"""
    flask.ext.social.core
    ~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social core

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""
from importlib import import_module

from flask import current_app
from flask.ext.oauth import OAuthRemoteApp as BaseRemoteApp
from flask.ext.security import current_user
from werkzeug.local import LocalProxy

from .utils import get_config, update_recursive
from .views import create_blueprint

_security = LocalProxy(lambda: current_app.extensions['security'])

_social = LocalProxy(lambda: current_app.extensions['social'])

_datastore = LocalProxy(lambda: _social.datastore)

_logger = LocalProxy(lambda: current_app.logger)

default_config = {
    'SOCIAL_BLUEPRINT_NAME': 'social',
    'SOCIAL_URL_PREFIX': None,
    'SOCIAL_CONNECT_ALLOW_VIEW': '/',
    'SOCIAL_CONNECT_DENY_VIEW': '/',
    'SOCIAL_POST_OAUTH_CONNECT_SESSION_KEY': 'post_oauth_connect_url',
    'SOCIAL_POST_OAUTH_LOGIN_SESSION_KEY': 'post_oauth_login_url',
    'SOCIAL_APP_URL': 'http://localhost'
}


class OAuthRemoteApp(BaseRemoteApp):

    def __init__(self, id, module, install, *args, **kwargs):
        BaseRemoteApp.__init__(self, None, **kwargs)
        self.id = id
        self.module = module

    def get_connection(self):
        return _social.datastore.find_connection(provider_id=self.id,
                                                 user_id=current_user.id)

    def get_api(self):
        module = import_module(self.module)
        connection = self.get_connection()
        if connection is None:
            return None
        return module.get_api(connection=connection,
                              consumer_key=self.consumer_key,
                              consumer_secret=self.consumer_secret)


def _get_state(app, datastore, providers, **kwargs):
    config = get_config(app)

    for key in providers.keys():
        config.pop(key.upper())

    for key, value in config.items():
        kwargs[key.lower()] = value

    kwargs.update(dict(
        app=app,
        datastore=datastore,
        providers=providers))

    return _SocialState(**kwargs)


class _SocialState(object):

    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key.lower(), value)

    def __getattr__(self, name):
        try:
            return self.providers[name]
        except KeyError:
            msg = "'_SocialState' object has no attribute '%s'" % name
            raise AttributeError(msg)


def _get_token():
    # Social doesn't use the builtin remote method calls feature of the
    # Flask-OAuth extension so we don't need to return a token. This does,
    # however, need to be configured
    return None


class Social(object):

    def __init__(self, app=None, datastore=None):
        self.app = app
        self.datastore = datastore

        if app is not None and datastore is not None:
            self._state = self.init_app(app, datastore)

    def init_app(self, app, datastore=None):
        """Initialize the application with the Social extension

        :param app: The Flask application
        :param datastore: Connection datastore instance
        """

        datastore = datastore or self.datastore

        for key, value in default_config.items():
            app.config.setdefault(key, value)

        providers = dict()

        for key, config in app.config.items():
            if not key.startswith('SOCIAL_') or config is None or key in default_config:
                continue

            suffix = key.lower().replace('social_', '')
            default_module_name = 'flask_social.providers.%s' % suffix
            module_name = config.get('module', default_module_name)
            module = import_module(module_name)
            config = update_recursive(module.config, config)

            providers[config['id']] = OAuthRemoteApp(**config)
            providers[config['id']].tokengetter(_get_token)

        state = _get_state(app, datastore, providers)

        app.register_blueprint(create_blueprint(state, __name__))
        app.extensions['social'] = state

        return state

    def __getattr__(self, name):
        return getattr(self._state, name, None)

########NEW FILE########
__FILENAME__ = datastore
# -*- coding: utf-8 -*-
"""
    flask.ext.social.datastore
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains an abstracted social connection datastore.

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

from flask_security.datastore import SQLAlchemyDatastore, MongoEngineDatastore, \
    PeeweeDatastore


class ConnectionDatastore(object):
    """Abstracted oauth connection datastore. Always extend this class and
    implement parent methods

    :param db: An instance of a configured databse manager from a Flask
               extension such as Flask-SQLAlchemy or Flask-MongoEngine"""

    def __init__(self, connection_model):
        self.connection_model = connection_model

    def find_connection(self, **kwargs):
        raise NotImplementedError

    def find_connections(self, **kwargs):
        raise NotImplementedError

    def create_connection(self, **kwargs):
        return self.put(self.connection_model(**kwargs))

    def delete_connection(self, **kwargs):
        """Remove a single connection to a provider for the specified user."""
        conn = self.find_connection(**kwargs)
        if not conn:
            return False
        self.delete(conn)
        return True

    def delete_connections(self, **kwargs):
        """Remove a single connection to a provider for the specified user."""
        rv = False
        for c in self.find_connections(**kwargs):
            self.delete(c)
            rv = True
        return rv


class SQLAlchemyConnectionDatastore(SQLAlchemyDatastore, ConnectionDatastore):
    """A SQLAlchemy datastore implementation for Flask-Social."""

    def __init__(self, db, connection_model):
        SQLAlchemyDatastore.__init__(self, db)
        ConnectionDatastore.__init__(self, connection_model)

    def _query(self, **kwargs):
        return self.connection_model.query.filter_by(**kwargs)

    def find_connection(self, **kwargs):
        return self._query(**kwargs).first()

    def find_connections(self, **kwargs):
        return self._query(**kwargs)


class MongoEngineConnectionDatastore(MongoEngineDatastore, ConnectionDatastore):
    """A MongoEngine datastore implementation for Flask-Social."""

    def __init__(self, db, connection_model):
        MongoEngineDatastore.__init__(self, db)
        ConnectionDatastore.__init__(self, connection_model)

    def _query(self, **kwargs):
        try:
            from mongoengine.queryset import Q, QCombination
        except ImportError:
            from mongoengine.queryset.visitor import Q, QCombination
        queries = map(lambda i: Q(**{i[0]: i[1]}), kwargs.items())
        query = QCombination(QCombination.AND, queries)
        return self.connection_model.objects(query)

    def find_connection(self, **kwargs):
        return self._query(**kwargs).first()

    def find_connections(self, **kwargs):
        return self._query(**kwargs)


class PeeweeConnectionDatastore(PeeweeDatastore, ConnectionDatastore):
    """A Peewee datastore implementation for Flask-Social."""

    def __init__(self, db, connection_model):
        PeeweeDatastore.__init__(self, db)
        ConnectionDatastore.__init__(self, connection_model)

    def _query(self, **kwargs):
        if 'user_id' in kwargs:
            kwargs['user'] = kwargs.pop('user_id')
        try:
            return self.connection_model.filter(**kwargs).get()
        except self.connection_model.DoesNotExist:
            return None

    def create_connection(self, **kwargs):
        if 'user_id' in kwargs:
            kwargs['user'] = kwargs.pop('user_id')
        return self.put(self.connection_model(**kwargs))

    def find_connection(self, **kwargs):
        return self._query(**kwargs)

    def find_connections(self, **kwargs):
        return self._query(**kwargs)

########NEW FILE########
__FILENAME__ = facebook
# -*- coding: utf-8 -*-
"""
    flask.ext.social.providers.facebook
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social facebook code

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

from __future__ import absolute_import

import facebook

config = {
    'id': 'facebook',
    'name': 'Facebook',
    'install': 'pip install facebook-sdk',
    'module': 'flask_social.providers.facebook',
    'base_url': 'https://graph.facebook.com/',
    'request_token_url': None,
    'access_token_url': '/oauth/access_token',
    'authorize_url': 'https://www.facebook.com/dialog/oauth',
    'request_token_params': {
        'scope': 'email'
    }
}


def get_api(connection, **kwargs):
    return facebook.GraphAPI(getattr(connection, 'access_token'))


def get_provider_user_id(response, **kwargs):
    if response:
        graph = facebook.GraphAPI(response['access_token'])
        profile = graph.get_object("me")
        return profile['id']
    return None


def get_connection_values(response, **kwargs):
    if not response:
        return None

    access_token = response['access_token']
    graph = facebook.GraphAPI(access_token)
    profile = graph.get_object("me")
    profile_url = "http://facebook.com/profile.php?id=%s" % profile['id']
    image_url = "http://graph.facebook.com/%s/picture" % profile['id']

    return dict(
        provider_id=config['id'],
        provider_user_id=profile['id'],
        access_token=access_token,
        secret=None,
        display_name=profile.get('username', None),
        full_name = profile.get('name', None),
        profile_url=profile_url,
        image_url=image_url
    )

########NEW FILE########
__FILENAME__ = foursquare
# -*- coding: utf-8 -*-
"""
    flask.ext.social.providers.foursquare
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social foursquare code

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

from __future__ import absolute_import

import foursquare

config = {
    'id': 'foursquare',
    'name': 'foursquare',
    'install': 'pip install foursquare',
    'module': 'flask_social.providers.foursquare',
    'base_url': 'https://api.foursquare.com/v2/',
    'request_token_url': None,
    'access_token_url': 'https://foursquare.com/oauth2/access_token',
    'authorize_url': 'https://foursquare.com/oauth2/authenticate',
    'access_token_params': {
        'grant_type': 'authorization_code'
    },
    'request_token_params': {
        'response_type': 'code'
    }
}


def get_api(connection, **kwargs):
    return foursquare.Foursquare(
            access_token=getattr(connection, 'access_token'))


def get_provider_user_id(response, **kwargs):
    if response:
        api = foursquare.Foursquare(
            access_token=getattr(response, 'access_token'))
        return api.users()['user']['id']
    return None


def get_connection_values(response, **kwargs):
    if not response:
        return None

    access_token = response['access_token']
    api = foursquare.Foursquare(access_token=access_token)
    user = api.users()['user']
    profile_url = 'http://www.foursquare.com/user/' + user['id']
    image_url = '%s%s' % (user['photo']['prefix'], user['photo']['suffix'][1:])

    return dict(
        provider_id=config['id'],
        provider_user_id=user['id'],
        access_token=access_token,
        secret=None,
        display_name=profile_url.split('/')[-1:][0],
        full_name = '%s %s' % (user['firstName'], user['lastName']),
        profile_url=profile_url,
        image_url=image_url
    )

########NEW FILE########
__FILENAME__ = google
# -*- coding: utf-8 -*-
"""
    flask.ext.social.providers.google
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social google code

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

from __future__ import absolute_import

import httplib2
import oauth2client.client as googleoauth
import apiclient.discovery as googleapi

config = {
    'id': 'google',
    'name': 'Google',
    'install': 'pip install google-api-python-client',
    'module': 'flask_social.providers.google',
    'base_url': 'https://www.google.com/accounts/',
    'authorize_url': 'https://accounts.google.com/o/oauth2/auth',
    'access_token_url': 'https://accounts.google.com/o/oauth2/token',
    'request_token_url': None,
    'access_token_method': 'POST',
    'access_token_params': {
        'grant_type': 'authorization_code'
    },
    'request_token_params': {
        'response_type': 'code',
        'scope': 'https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/plus.me'
        #add ' https://www.googleapis.com/auth/userinfo.email' to scope to also get email
    }
}

def _get_api(credentials):
    http = httplib2.Http()
    http = credentials.authorize(http)
    api = googleapi.build('oauth2', 'v2', http=http)
    return api


def get_api(connection, **kwargs):
    credentials = googleoauth.AccessTokenCredentials(
        access_token=getattr(connection, 'access_token'),
        user_agent=''
    )
    return _get_api(credentials)


def get_provider_user_id(response, **kwargs):
    if response:
        credentials = googleoauth.AccessTokenCredentials(
            access_token=response['access_token'],
            user_agent=''
        )
        profile = _get_api(credentials).userinfo().get().execute()
        return profile['id']
    return None


def get_connection_values(response, **kwargs):
    if not response:
        return None

    access_token = response['access_token']

    credentials = googleoauth.AccessTokenCredentials(
        access_token=access_token,
        user_agent=''
    )

    profile = _get_api(credentials).userinfo().get().execute()
    return dict(
        provider_id=config['id'],
        provider_user_id=profile['id'],
        access_token=access_token,
        secret=None,
        display_name=profile['name'],
        full_name=profile['name'],
        profile_url=profile.get('link'),
        image_url=profile.get('picture')
    )

########NEW FILE########
__FILENAME__ = twitter
# -*- coding: utf-8 -*-
"""
    flask.ext.social.providers.twitter
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social twitter code

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

from __future__ import absolute_import

import twitter

config = {
    'id': 'twitter',
    'name': 'Twitter',
    'install': 'pip install python-twitter',
    'module': 'flask_social.providers.twitter',
    'base_url': 'http://api.twitter.com/1/',
    'request_token_url': 'https://api.twitter.com/oauth/request_token',
    'access_token_url': 'https://api.twitter.com/oauth/access_token',
    'authorize_url': 'https://api.twitter.com/oauth/authenticate'
}


def get_api(connection, **kwargs):
    return twitter.Api(consumer_key=kwargs.get('consumer_key'),
                       consumer_secret=kwargs.get('consumer_secret'),
                       access_token_key=connection.access_token,
                       access_token_secret=connection.secret)


def get_provider_user_id(response, **kwargs):
    return response['user_id'] if response else None


def get_connection_values(response=None, **kwargs):
    if not response:
        return None

    api = twitter.Api(consumer_key=kwargs.get('consumer_key'),
                      consumer_secret=kwargs.get('consumer_secret'),
                      access_token_key=response['oauth_token'],
                      access_token_secret=response['oauth_token_secret'])

    user = api.VerifyCredentials()

    return dict(
        provider_id=config['id'],
        provider_user_id=str(user.id),
        access_token=response['oauth_token'],
        secret=response['oauth_token_secret'],
        display_name='@%s' % user.screen_name,
        full_name = user.name,
        profile_url="http://twitter.com/%s" % user.screen_name,
        image_url=user.profile_image_url
    )

########NEW FILE########
__FILENAME__ = signals
# -*- coding: utf-8 -*-
"""
    flask.ext.social.signals
    ~~~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social signals

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""

import blinker

signals = blinker.Namespace()

connection_created = signals.signal("connection-created")

connection_failed = signals.signal("connection-failed")

connection_removed = signals.signal("connection-removed")

login_failed = signals.signal("login-failed")

login_completed = signals.signal("login-success")

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
"""
    flask.ext.social.utils
    ~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social utils

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""
import collections

from importlib import import_module

from flask import current_app, url_for, request, abort


def get_provider_or_404(provider_id):
    try:
        return current_app.extensions['social'].providers[provider_id]
    except KeyError:
        abort(404)


def config_value(key, app=None):
    app = app or current_app
    return app.config['SOCIAL_' + key.upper()]


def get_authorize_callback(endpoint, provider_id):
    """Get a qualified URL for the provider to return to upon authorization

    param: endpoint: Absolute path to append to the application's host
    """
    endpoint_prefix = config_value('BLUEPRINT_NAME')
    url = url_for(endpoint_prefix + '.' + endpoint, provider_id=provider_id)
    return request.url_root[:-1] + url


def get_connection_values_from_oauth_response(provider, oauth_response):
    if oauth_response is None:
        return None

    module = import_module(provider.module)

    return module.get_connection_values(
        oauth_response,
        consumer_key=provider.consumer_key,
        consumer_secret=provider.consumer_secret)


def get_config(app):
    """Conveniently get the social configuration for the specified
    application without the annoying 'SOCIAL_' prefix.

    :param app: The application to inspect
    """
    items = app.config.items()
    prefix = 'SOCIAL_'

    def strip_prefix(tup):
        return (tup[0].replace(prefix, ''), tup[1])

    return dict([strip_prefix(i) for i in items if i[0].startswith(prefix)])


def update_recursive(d, u):
    for k, v in u.iteritems():
        if isinstance(v, collections.Mapping):
            r = update_recursive(d.get(k, {}), v)
            d[k] = r
        else:
            d[k] = u[k]
    return d

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-
"""
    flask.ext.social.views
    ~~~~~~~~~~~~~~~~~~~~~~

    This module contains the Flask-Social views

    :copyright: (c) 2012 by Matt Wright.
    :license: MIT, see LICENSE for more details.
"""
from importlib import import_module

from flask import Blueprint, current_app, redirect, request, session, \
     after_this_request, abort, url_for
from flask.ext.security import current_user, login_required
from flask.ext.security.utils import get_post_login_redirect, login_user, \
     get_url, do_flash
from flask.ext.security.decorators import anonymous_user_required
from werkzeug.local import LocalProxy

from .signals import connection_removed, connection_created, \
     connection_failed, login_completed, login_failed
from .utils import config_value, get_provider_or_404, get_authorize_callback, \
     get_connection_values_from_oauth_response


# Convenient references
_security = LocalProxy(lambda: current_app.extensions['security'])

_social = LocalProxy(lambda: current_app.extensions['social'])

_datastore = LocalProxy(lambda: _social.datastore)

_logger = LocalProxy(lambda: current_app.logger)


def _commit(response=None):
    _datastore.commit()
    return response


@anonymous_user_required
def login(provider_id):
    """Starts the provider login OAuth flow"""
    provider = get_provider_or_404(provider_id)
    callback_url = get_authorize_callback('login', provider_id)
    post_login = request.form.get('next', get_post_login_redirect())
    session['post_oauth_login_url'] = post_login
    return provider.authorize(callback_url)


@login_required
def connect(provider_id):
    """Starts the provider connection OAuth flow"""
    provider = get_provider_or_404(provider_id)
    callback_url = get_authorize_callback('connect', provider_id)
    allow_view = get_url(config_value('CONNECT_ALLOW_VIEW'))
    pc = request.form.get('next', allow_view)
    session[config_value('POST_OAUTH_CONNECT_SESSION_KEY')] = pc
    return provider.authorize(callback_url)


@login_required
def remove_all_connections(provider_id):
    """Remove all connections for the authenticated user to the
    specified provider
    """
    provider = get_provider_or_404(provider_id)

    ctx = dict(provider=provider.name, user=current_user)

    deleted = _datastore.delete_connections(user_id=current_user.get_id(),
                                            provider_id=provider_id)
    if deleted:
        after_this_request(_commit)
        msg = ('All connections to %s removed' % provider.name, 'info')
        connection_removed.send(current_app._get_current_object(),
                                user=current_user._get_current_object(),
                                provider_id=provider_id)
    else:
        msg = ('Unable to remove connection to %(provider)s' % ctx, 'error')

    do_flash(*msg)
    return redirect(request.referrer)


@login_required
def remove_connection(provider_id, provider_user_id):
    """Remove a specific connection for the authenticated user to the
    specified provider
    """
    provider = get_provider_or_404(provider_id)

    ctx = dict(provider=provider.name, user=current_user,
               provider_user_id=provider_user_id)

    deleted = _datastore.delete_connection(user_id=current_user.get_id(),
                                           provider_id=provider_id,
                                           provider_user_id=provider_user_id)

    if deleted:
        after_this_request(_commit)
        msg = ('Connection to %(provider)s removed' % ctx, 'info')
        connection_removed.send(current_app._get_current_object(),
                                user=current_user._get_current_object(),
                                provider_id=provider_id)
    else:
        msg = ('Unabled to remove connection to %(provider)s' % ctx, 'error')

    do_flash(*msg)
    return redirect(request.referrer or get_post_login_redirect())


def connect_handler(cv, provider):
    """Shared method to handle the connection process

    :param connection_values: A dictionary containing the connection values
    :param provider_id: The provider ID the connection shoudl be made to
    """
    cv.setdefault('user_id', current_user.get_id())
    connection = _datastore.find_connection(**cv)

    if connection is None:
        after_this_request(_commit)
        connection = _datastore.create_connection(**cv)
        msg = ('Connection established to %s' % provider.name, 'success')
        connection_created.send(current_app._get_current_object(),
                                user=current_user._get_current_object(),
                                connection=connection)
    else:
        msg = ('A connection is already established with %s '
               'to your account' % provider.name, 'notice')
        connection_failed.send(current_app._get_current_object(),
                               user=current_user._get_current_object())

    redirect_url = session.pop(config_value('POST_OAUTH_CONNECT_SESSION_KEY'),
                               get_url(config_value('CONNECT_ALLOW_VIEW')))

    do_flash(*msg)
    return redirect(redirect_url)


def connect_callback(provider_id):
    provider = get_provider_or_404(provider_id)

    def connect(response):
        cv = get_connection_values_from_oauth_response(provider, response)
        return cv

    cv = provider.authorized_handler(connect)()
    if cv is None:
        do_flash('Access was denied by %s' % provider.name, 'error')
        return redirect(get_url(config_value('CONNECT_DENY_VIEW')))

    return connect_handler(cv, provider)


@anonymous_user_required
def login_handler(response, provider, query):
    """Shared method to handle the signin process"""

    connection = _datastore.find_connection(**query)

    if connection:
        after_this_request(_commit)
        user = connection.user
        login_user(user)
        key = _social.post_oauth_login_session_key
        redirect_url = session.pop(key, get_post_login_redirect())

        login_completed.send(current_app._get_current_object(),
                             provider=provider, user=user)

        return redirect(redirect_url)

    login_failed.send(current_app._get_current_object(),
                      provider=provider,
                      oauth_response=response)

    next = get_url(_security.login_manager.login_view)
    msg = '%s account not associated with an existing user' % provider.name
    do_flash(msg, 'error')
    return redirect(next)


def login_callback(provider_id):
    try:
        provider = _social.providers[provider_id]
        module = import_module(provider.module)
    except KeyError:
        abort(404)

    def login(response):
        _logger.debug('Received login response from '
                      '%s: %s' % (provider.name, response))

        if response is None:
            do_flash('Access was denied to your %s '
                     'account' % provider.name, 'error')
            return _security.login_manager.unauthorized(), None

        query = dict(provider_user_id=module.get_provider_user_id(response),
                     provider_id=provider_id)

        return response, query

    response, query = provider.authorized_handler(login)()
    if query is None:
        return response
    return login_handler(response, provider, query)


def create_blueprint(state, import_name):
    bp = Blueprint(state.blueprint_name, import_name,
                   url_prefix=state.url_prefix,
                   template_folder='templates')

    bp.route('/login/<provider_id>')(login_callback)

    bp.route('/login/<provider_id>',
             methods=['POST'])(login)

    bp.route('/connect/<provider_id>')(connect_callback)

    bp.route('/connect/<provider_id>',
             methods=['POST'])(connect)

    bp.route('/connect/<provider_id>',
             methods=['DELETE'])(remove_all_connections)

    bp.route('/connect/<provider_id>/<provider_user_id>',
             methods=['DELETE'])(remove_connection)

    return bp

########NEW FILE########
__FILENAME__ = release
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    make-release
    ~~~~~~~~~~~~

    Helper script that performs a release.  Does pretty much everything
    automatically for us.

    :copyright: (c) 2011 by Armin Ronacher.
    :license: BSD, see LICENSE for more details.
"""
import sys
import os
import re
from datetime import datetime, date
from subprocess import Popen, PIPE

_date_clean_re = re.compile(r'(\d+)(st|nd|rd|th)')


def installed_libraries():
    return Popen(['pip', 'freeze'], stdout=PIPE).communicate()[0]


def has_library_installed(library):
    return library + '==' in installed_libraries()


def parse_changelog():
    with open('CHANGES') as f:
        lineiter = iter(f)
        for line in lineiter:
            match = re.search('^Version\s+(.*)', line.strip())

            if match is None:
                continue

            version = match.group(1).strip()

            if lineiter.next().count('-') != len(line.strip()):
                fail('Invalid hyphen count below version line: %s', line.strip())

            while 1:
                released = lineiter.next().strip()
                if released:
                    break

            match = re.search(r'Released (\w+\s+\d+\w+\s+\d+)', released)

            if match is None:
                fail('Could not find release date in version %s' % version)

            datestr = parse_date(match.group(1).strip())

            return version, datestr


def bump_version(version):
    try:
        parts = map(int, version.split('.'))
    except ValueError:
        fail('Current version is not numeric')
    parts[-1] += 1
    return '.'.join(map(str, parts))


def parse_date(string):
    string = _date_clean_re.sub(r'\1', string)
    return datetime.strptime(string, '%B %d %Y')


def set_filename_version(filename, version_number, pattern):
    changed = []

    def inject_version(match):
        before, old, after = match.groups()
        changed.append(True)
        return before + version_number + after

    with open(filename) as f:
        contents = re.sub(r"^(\s*%s\s*=\s*')(.+?)(')(?sm)" % pattern,
                          inject_version, f.read())

    if not changed:
        fail('Could not find %s in %s', pattern, filename)

    with open(filename, 'w') as f:
        f.write(contents)


def set_init_version(version):
    info('Setting __init__.py version to %s', version)
    set_filename_version('flask_social/__init__.py', version, '__version__')


def set_setup_version(version):
    info('Setting setup.py version to %s', version)
    set_filename_version('setup.py', version, 'version')


def set_docs_version(version):
    info('Setting docs/conf.py version to %s', version)
    set_filename_version('docs/conf.py', version, 'version')


def build_and_upload():
    Popen([sys.executable, 'setup.py', 'sdist', 'build_sphinx', 'upload', 'upload_sphinx']).wait()


def fail(message, *args):
    print >> sys.stderr, 'Error:', message % args
    sys.exit(1)


def info(message, *args):
    print >> sys.stderr, message % args


def get_git_tags():
    return set(Popen(['git', 'tag'], stdout=PIPE).communicate()[0].splitlines())


def git_is_clean():
    return Popen(['git', 'diff', '--quiet']).wait() == 0


def make_git_commit(message, *args):
    message = message % args
    Popen(['git', 'commit', '-am', message]).wait()


def make_git_tag(tag):
    info('Tagging "%s"', tag)
    Popen(['git', 'tag', '-a', tag, '-m', '%s release' % tag]).wait()
    Popen(['git', 'push', '--tags']).wait()


def update_version(version):
    for f in [set_init_version, set_setup_version, set_docs_version]:
        f(version)


def get_branches():
    return set(Popen(['git', 'branch'], stdout=PIPE).communicate()[0].splitlines())


def branch_is(branch):
    return '* ' + branch in get_branches()


def main():
    os.chdir(os.path.join(os.path.dirname(__file__), '..'))

    rv = parse_changelog()

    if rv is None:
        fail('Could not parse changelog')

    version, release_date = rv

    tags = get_git_tags()

    for lib in ['Sphinx', 'Sphinx-PyPI-upload']:
        if not has_library_installed(lib):
            fail('Build requires that %s be installed', lib)

    if version in tags:
        fail('Version "%s" is already tagged', version)
    if release_date.date() != date.today():
        fail('Release date is not today')

    if not branch_is('master'):
        fail('You are not on the master branch')

    if not git_is_clean():
        fail('You have uncommitted changes in git')

    info('Releasing %s (release date %s)',
         version, release_date.strftime('%d/%m/%Y'))

    update_version(version)
    make_git_commit('Bump version number to %s', version)
    make_git_tag(version)
    build_and_upload()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = functional_tests
import unittest
import mock
from tests.test_app.sqlalchemy import create_app as create_sql_app
from tests.test_app.mongoengine import create_app as create_mongo_app
from tests.test_app.peewee_app import create_app as create_peewee_app

def get_mock_twitter_response():
    return {
        'oauth_token_secret': 'the_oauth_token_secret',
        'user_id': '1234',
        'oauth_token': 'the_oauth_token',
        'screen_name': 'twitter_username',
        'name': 'twitter_name'
    }


def get_mock_twitter_connection_values():
    return {
        'provider_id': 'twitter',
        'provider_user_id': '1234',
        'access_token': 'the_oauth_token',
        'secret': 'the_oauth_token_secret',
        'display_name': '@twitter_username',
        'full_name': 'twitter_name',
        'profile_url': 'http://twitter.com/twitter_username',
        'image_url': 'https://cdn.twitter.com/something.png'
    }


class SocialTest(unittest.TestCase):

    SOCIAL_CONFIG = None
    APP_TYPE = None

    def setUp(self):
        super(SocialTest, self).setUp()

        self.app = self._create_app(self.SOCIAL_CONFIG or None)
        self.app.debug = False
        self.app.config['TESTING'] = True
        self.client = self.app.test_client()

    def tearDown(self):
        super(SocialTest, self).tearDown()
        self.client.get('/logout')

    def _create_app(self, auth_config):
        app_type = self.APP_TYPE or 'sql'
        if app_type == 'sql':
            return create_sql_app(auth_config, False)
        if app_type == 'mongo':
            return create_mongo_app(auth_config, False)
        if app_type == 'peewee':
            return create_peewee_app(auth_config, False)

    def _post(self, route, data=None, content_type=None, follow_redirects=True, headers=None):
        content_type = content_type or 'application/x-www-form-urlencoded'
        return self.client.post(route, data=data,
                                follow_redirects=follow_redirects,
                                content_type=content_type, headers=headers)

    def _get(self, route, content_type=None, follow_redirects=None, headers=None):
        return self.client.get(route, follow_redirects=follow_redirects,
                               content_type=content_type or 'text/html',
                               headers=headers)

    def authenticate(self, email="matt@lp.com", password="password", endpoint=None, **kwargs):
        data = dict(email=email, password=password, remember='y')
        return self._post(endpoint or '/login', data=data, **kwargs)

    def assertIn(self, member, container, msg=None):
        if hasattr(unittest.TestCase, 'assertIn'):
            return unittest.TestCase.assertIn(self, member, container, msg)

        return self.assertTrue(member in container)

    def assertNotIn(self, member, container, msg=None):
        if hasattr(unittest.TestCase, 'assertNotIn'):
            return unittest.TestCase.assertNotIn(self, member, container, msg)

        return self.assertFalse(member in container)

    def assertIsNotNone(self, obj, msg=None):
        if hasattr(unittest.TestCase, 'assertIsNotNone'):
            return unittest.TestCase.assertIsNotNone(self, obj, msg)

        return self.assertTrue(obj is not None)


class TwitterSocialTests(SocialTest):

    @mock.patch('flask_social.providers.twitter.get_connection_values')
    @mock.patch('flask_oauth.OAuthRemoteApp.handle_oauth1_response')
    @mock.patch('flask_oauth.OAuthRemoteApp.authorize')
    def test_connect_twitter(self, mock_authorize, mock_handle_oauth1_response, mock_get_connection_values):
        mock_get_connection_values.return_value = get_mock_twitter_connection_values()
        mock_authorize.return_value = 'Should be a redirect'
        mock_handle_oauth1_response.return_value = get_mock_twitter_response()

        r = self.authenticate()

        self.assertIn('Hello', r.data)
        self._post('/connect/twitter')
        r = self._get('/connect/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        self.assertIn('Connection established to Twitter', r.data)

    @mock.patch('flask_social.providers.twitter.get_connection_values')
    @mock.patch('flask_oauth.OAuthRemoteApp.handle_oauth1_response')
    @mock.patch('flask_oauth.OAuthRemoteApp.authorize')
    def test_double_connect_twitter(self, mock_authorize, mock_handle_oauth1_response, mock_get_connection_values):
        mock_get_connection_values.return_value = get_mock_twitter_connection_values()
        mock_authorize.return_value = 'Should be a redirect'
        mock_handle_oauth1_response.return_value = get_mock_twitter_response()

        r = self.authenticate()

        for x in range(2):
            self._post('/connect/twitter')
            r = self._get('/connect/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        self.assertIn('A connection is already established with', r.data)

    @mock.patch('flask_social.providers.twitter.get_connection_values')
    @mock.patch('flask_oauth.OAuthRemoteApp.handle_oauth1_response')
    @mock.patch('flask_oauth.OAuthRemoteApp.authorize')
    def test_unconnected_twitter_login(self, mock_authorize, mock_handle_oauth1_response, mock_get_connection_values):
        mock_get_connection_values.return_value = get_mock_twitter_connection_values()
        mock_authorize.return_value = 'Should be a redirect'
        mock_handle_oauth1_response.return_value = get_mock_twitter_response()

        self._post('/login/twitter')
        r = self._get('/login/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        self.assertIn('Twitter account not associated with an existing user', r.data)

    @mock.patch('flask_social.providers.twitter.get_api')
    @mock.patch('flask_social.providers.twitter.get_connection_values')
    @mock.patch('flask_oauth.OAuthRemoteApp.handle_oauth1_response')
    @mock.patch('flask_oauth.OAuthRemoteApp.authorize')
    def test_connected_twitter_login(self, mock_authorize, mock_handle_oauth1_response,mock_get_twitter_api, mock_get_connection_values):
        mock_get_connection_values.return_value = get_mock_twitter_connection_values()
        mock_authorize.return_value = 'Should be a redirect'
        mock_handle_oauth1_response.return_value = get_mock_twitter_response()
        mock_get_twitter_api.return_value = get_mock_twitter_connection_values()

        self.authenticate()
        self._post('/connect/twitter')
        r = self._get('/connect/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        self.assertIn('Connection established to Twitter', r.data)
        self._get('/logout')
        self._post('/login/twitter')
        r = self._get('/login/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        self.assertIn("Hello matt@lp.com", r.data)

    @mock.patch('flask_social.providers.twitter.get_connection_values')
    @mock.patch('flask_oauth.OAuthRemoteApp.handle_oauth1_response')
    @mock.patch('flask_oauth.OAuthRemoteApp.authorize')
    def test_remove_connection(self, mock_authorize, mock_handle_oauth1_response, mock_get_connection_values):
        mock_get_connection_values.return_value = get_mock_twitter_connection_values()
        mock_authorize.return_value = 'Should be a redirect'
        mock_handle_oauth1_response.return_value = get_mock_twitter_response()

        self._post('/login', data=dict(email='matt@lp.com', password='password'))
        self._post('/connect/twitter')
        r = self._get('/connect/twitter?oauth_token=oauth_token&oauth_verifier=oauth_verifier', follow_redirects=True)
        r = self.client.delete('/connect/twitter/1234', follow_redirects=True)
        self.assertIn('Connection to Twitter removed', r.data)


class MongoEngineTwitterSocialTests(TwitterSocialTests):
    APP_TYPE = 'mongo'

class PeeweeTwitterSocialTests(TwitterSocialTests):
    APP_TYPE = 'peewee'

########NEW FILE########
__FILENAME__ = mongoengine
# -*- coding: utf-8 -*-

import sys
import os

sys.path.pop(0)
sys.path.insert(0, os.getcwd())

from flask.ext.mongoengine import MongoEngine
from flask.ext.security import Security, UserMixin, RoleMixin, \
     MongoEngineUserDatastore
from flask.ext.social import Social, MongoEngineConnectionDatastore

from tests.test_app import create_app as create_base_app, populate_data


def create_app(auth_config=None, debug=True):
    app = create_base_app(auth_config, debug)
    app.config['MONGODB_DB'] = 'flask_social_test'
    app.config['MONGODB_HOST'] = 'localhost'
    app.config['MONGODB_PORT'] = 27017

    db = MongoEngine(app)

    class Role(db.Document, RoleMixin):
        name = db.StringField(required=True, unique=True, max_length=80)
        description = db.StringField(max_length=255)

    class User(db.Document, UserMixin):
        email = db.StringField(unique=True, max_length=255)
        password = db.StringField(required=True, max_length=120)
        active = db.BooleanField(default=True)
        remember_token = db.StringField(max_length=255)
        authentication_token = db.StringField(max_length=255)
        roles = db.ListField(db.ReferenceField(Role), default=[])

        @property
        def connections(self):
            return Connection.objects(user_id=str(self.id))

    class Connection(db.Document):
        user_id = db.ObjectIdField()
        provider_id = db.StringField(max_length=255)
        provider_user_id = db.StringField(max_length=255)
        access_token = db.StringField(max_length=255)
        secret = db.StringField(max_length=255)
        display_name = db.StringField(max_length=255)
        full_name = db.StringField(max_length=255)
        profile_url = db.StringField(max_length=512)
        image_url = db.StringField(max_length=512)
        rank = db.IntField(default=1)

        @property
        def user(self):
            return User.objects(id=self.user_id).first()

    app.security = Security(app, MongoEngineUserDatastore(db, User, Role))
    app.social = Social(app, MongoEngineConnectionDatastore(db, Connection))

    @app.before_first_request
    def before_first_request():
        for m in [User, Role, Connection]:
            m.drop_collection()
        populate_data()

    return app

if __name__ == '__main__':
    create_app().run()

########NEW FILE########
__FILENAME__ = peewee_app
# -*- coding: utf-8 -*-

import sys
import os

sys.path.pop(0)
sys.path.insert(0, os.getcwd())

from flask_peewee.db import Database
from flask.ext.security import Security, UserMixin, RoleMixin, \
    PeeweeUserDatastore
from flask.ext.social import Social, PeeweeConnectionDatastore
from peewee import *

from tests.test_app import create_app as create_base_app, populate_data


def create_app(config=None, debug=True):
    app = create_base_app(config, debug)
    app.config['DATABASE'] = {
        'name': 'example2.db',
        'engine': 'peewee.SqliteDatabase',
    }

    db = Database(app)

    class Role(db.Model, RoleMixin):
        name = TextField(unique=True)
        description = TextField(null=True)

    class User(db.Model, UserMixin):
        email = TextField()
        password = TextField()
        last_login_at = DateTimeField(null=True)
        current_login_at = DateTimeField(null=True)
        last_login_ip = TextField(null=True)
        current_login_ip = TextField(null=True)
        login_count = IntegerField(null=True)
        active = BooleanField(default=True)
        confirmed_at = DateTimeField(null=True)

    class UserRoles(db.Model):
        """ Peewee does not have built-in many-to-many support, so we have to
        create this mapping class to link users to roles."""
        user = ForeignKeyField(User, related_name='roles')
        role = ForeignKeyField(Role, related_name='users')
        name = property(lambda self: self.role.name)
        description = property(lambda self: self.role.description)

    class Connection(db.Model):
        user = ForeignKeyField(User, related_name='connections')
        provider_id = TextField()
        provider_user_id = TextField()
        access_token = TextField()
        secret = TextField(null=True)
        display_name = TextField()
        full_name = TextField()
        profile_url = TextField()
        image_url = TextField()
        rank = IntegerField(null=True)

    app.security = Security(app, PeeweeUserDatastore(db, User, Role, UserRoles))
    app.social = Social(app, PeeweeConnectionDatastore(db, Connection))

    @app.before_first_request
    def before_first_request():
        for Model in (Role, User, UserRoles, Connection):
            Model.drop_table(fail_silently=True)
            Model.create_table(fail_silently=True)
        populate_data()

    return app

if __name__ == '__main__':
    create_app().run()

########NEW FILE########
__FILENAME__ = sqlalchemy
# -*- coding: utf-8 -*-

import sys
import os

sys.path.pop(0)
sys.path.insert(0, os.getcwd())

from flask.ext.security import Security, UserMixin, RoleMixin, \
     SQLAlchemyUserDatastore
from flask.ext.social import Social, SQLAlchemyConnectionDatastore
from flask.ext.sqlalchemy import SQLAlchemy

from tests.test_app import create_app as create_base_app, populate_data


def create_app(config=None, debug=True):
    app = create_base_app(config, debug)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'

    db = SQLAlchemy(app)

    roles_users = db.Table('roles_users',
        db.Column('user_id', db.Integer(), db.ForeignKey('user.id')),
        db.Column('role_id', db.Integer(), db.ForeignKey('role.id')))

    class Role(db.Model, RoleMixin):
        id = db.Column(db.Integer(), primary_key=True)
        name = db.Column(db.String(80), unique=True)
        description = db.Column(db.String(255))

    class User(db.Model, UserMixin):
        id = db.Column(db.Integer, primary_key=True)
        email = db.Column(db.String(255), unique=True)
        password = db.Column(db.String(120))
        active = db.Column(db.Boolean())
        roles = db.relationship('Role', secondary=roles_users,
                    backref=db.backref('users', lazy='dynamic'))
        connections = db.relationship('Connection',
                    backref=db.backref('user', lazy='joined'))

    class Connection(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
        provider_id = db.Column(db.String(255))
        provider_user_id = db.Column(db.String(255))
        access_token = db.Column(db.String(255))
        secret = db.Column(db.String(255))
        display_name = db.Column(db.String(255))
        full_name = db.Column(db.String(255))
        profile_url = db.Column(db.String(512))
        image_url = db.Column(db.String(512))
        rank = db.Column(db.Integer)

    app.security = Security(app, SQLAlchemyUserDatastore(db, User, Role))
    app.social = Social(app, SQLAlchemyConnectionDatastore(db, Connection))

    @app.before_first_request
    def before_first_request():
        db.drop_all()
        db.create_all()
        populate_data()

    return app

if __name__ == '__main__':
    create_app().run()

########NEW FILE########
__FILENAME__ = unit_tests
from unittest import TestCase
from flask_social.core import _SocialState


class FlaskSocialUnitTests(TestCase):

    def test_social_state_raises_attribute_error(self):
        state = _SocialState(providers={})
        self.assertRaises(AttributeError, lambda: state.something)

########NEW FILE########
