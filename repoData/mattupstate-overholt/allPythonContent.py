__FILENAME__ = env
from __future__ import with_statement

import sys
from os.path import dirname, abspath
sys.path.append(dirname(dirname(abspath(__file__))))

from alembic import context
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig

from overholt.models import *
from overholt.core import db
from overholt.api import create_app

app = create_app()

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    alembic_config = config.get_section(config.config_ini_section)
    alembic_config['sqlalchemy.url'] = app.config['SQLALCHEMY_DATABASE_URI']

    engine = engine_from_config(
                alembic_config,
                prefix='sqlalchemy.',
                poolclass=pool.NullPool)

    connection = engine.connect()
    context.configure(
                connection=connection,
                target_metadata=db.metadata
                )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

########NEW FILE########
__FILENAME__ = 4fe474604dbb_add_stores_managers_
"""Add `stores_managers` table

Revision ID: 4fe474604dbb
Revises: 5a0e003fafb2
Create Date: 2013-06-28 22:18:42.292040

"""

# revision identifiers, used by Alembic.
revision = '4fe474604dbb'
down_revision = '5a0e003fafb2'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('stores_managers',
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('store_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['store_id'], ['stores.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint()
    )
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('stores_managers')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 5a0e003fafb2_first_revision
"""First revision

Revision ID: 5a0e003fafb2
Revises: None
Create Date: 2013-06-24 11:37:45.113288

"""

# revision identifiers, used by Alembic.
revision = '5a0e003fafb2'
down_revision = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=True),
    sa.Column('password', sa.String(length=120), nullable=True),
    sa.Column('active', sa.Boolean(), nullable=True),
    sa.Column('confirmed_at', sa.DateTime(), nullable=True),
    sa.Column('last_login_at', sa.DateTime(), nullable=True),
    sa.Column('current_login_at', sa.DateTime(), nullable=True),
    sa.Column('last_login_ip', sa.String(length=100), nullable=True),
    sa.Column('current_login_ip', sa.String(length=100), nullable=True),
    sa.Column('login_count', sa.Integer(), nullable=True),
    sa.Column('registered_at', sa.DateTime(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('categories',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=True),
    sa.Column('description', sa.String(length=255), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('products',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('roles',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=80), nullable=True),
    sa.Column('description', sa.String(length=255), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('roles_users',
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('role_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['role_id'], ['roles.id'], ),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint()
    )
    op.create_table('products_categories',
    sa.Column('product_id', sa.Integer(), nullable=True),
    sa.Column('category_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['category_id'], ['categories.id'], ),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ),
    sa.PrimaryKeyConstraint()
    )
    op.create_table('stores',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=True),
    sa.Column('address', sa.String(length=255), nullable=True),
    sa.Column('city', sa.String(length=255), nullable=True),
    sa.Column('state', sa.String(length=255), nullable=True),
    sa.Column('zip_code', sa.String(length=255), nullable=True),
    sa.Column('manager_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['manager_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('stores_products',
    sa.Column('product_id', sa.Integer(), nullable=True),
    sa.Column('store_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], ),
    sa.ForeignKeyConstraint(['store_id'], ['stores.id'], ),
    sa.PrimaryKeyConstraint()
    )
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('stores_products')
    op.drop_table('stores')
    op.drop_table('products_categories')
    op.drop_table('roles_users')
    op.drop_table('roles')
    op.drop_table('products')
    op.drop_table('categories')
    op.drop_table('users')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Overholt documentation build configuration file, created by
# sphinx-quickstart on Tue Jun 25 13:03:08 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

sys.path.append(os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinxcontrib.autohttp.flask'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Overholt'
copyright = u'2013, Matt Wright'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Overholtdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Overholt.tex', u'Overholt Documentation',
   u'Matt Wright', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'overholt', u'Overholt Documentation',
     [u'Matt Wright'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Overholt', u'Overholt Documentation',
   u'Matt Wright', 'Overholt', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = manage
# -*- coding: utf-8 -*-
"""
    manage
    ~~~~~~

    Manager module
"""

from flask.ext.script import Manager

from overholt.api import create_app
from overholt.manage import CreateUserCommand, DeleteUserCommand, ListUsersCommand

manager = Manager(create_app())
manager.add_command('create_user', CreateUserCommand())
manager.add_command('delete_user', DeleteUserCommand())
manager.add_command('list_users', ListUsersCommand())

if __name__ == "__main__":
    manager.run()

########NEW FILE########
__FILENAME__ = products
# -*- coding: utf-8 -*-
"""
    overholt.api.products
    ~~~~~~~~~~~~~~~~~~~~~

    Product endpoints
"""

from flask import Blueprint, request

from ..forms import NewProductForm, UpdateProductForm
from ..services import products
from . import OverholtFormError, route

bp = Blueprint('products', __name__, url_prefix='/products')


@route(bp, '/')
def list():
    """Returns a list of product instances."""
    return products.all()


@route(bp, '/', methods=['POST'])
def create():
    """Creates a new product. Returns the new product instance."""
    form = NewProductForm()
    if form.validate_on_submit():
        return products.create(**request.json)
    raise OverholtFormError(form.errors)


@route(bp, '/<product_id>')
def show(product_id):
    """Returns a product instance."""
    return products.get_or_404(product_id)


@route(bp, '/<product_id>', methods=['PUT'])
def update(product_id):
    """Updates a product. Returns the updated product instance."""
    form = UpdateProductForm()
    if form.validate_on_submit():
        return products.update(products.get_or_404(product_id), **request.json)
    raise(OverholtFormError(form.errors))


@route(bp, '/<product_id>', methods=['DELETE'])
def delete(product_id):
    """Deletes a product. Returns a 204 response."""
    products.delete(products.get_or_404(product_id))
    return None, 204

########NEW FILE########
__FILENAME__ = stores
# -*- coding: utf-8 -*-
"""
    overholt.api.stores
    ~~~~~~~~~~~~~~~~~~~

    Store endpoints
"""

from flask import Blueprint, request

from ..forms import NewStoreForm, UpdateStoreForm
from ..services import stores as _stores, products as _products, users as _users
from ..tasks import send_manager_added_email, send_manager_removed_email
from . import OverholtFormError, route

bp = Blueprint('stores', __name__, url_prefix='/stores')


@route(bp, '/')
def list():
    """Returns a list of all store instances."""
    return _stores.all()


@route(bp, '/', methods=['POST'])
def new():
    """Creates a new store. Returns the new store instance."""
    form = NewStoreForm()
    if form.validate_on_submit():
        return _stores.create(**request.json)
    raise OverholtFormError(form.errors)


@route(bp, '/<store_id>')
def show(store_id):
    """Returns a store instance."""
    return _stores.get_or_404(store_id)


@route(bp, '/<store_id>', methods=['PUT'])
def update(store_id):
    """Updates a store. Returns the updated store instance."""
    form = UpdateStoreForm()
    if form.validate_on_submit():
        return _stores.update(_stores.get_or_404(store_id), **request.json)
    raise OverholtFormError(form.errors)


@route(bp, '/<store_id>', methods=['DELETE'])
def delete(store_id):
    """Deletes a store. Returns a 204 response."""
    _stores.delete(_stores.get_or_404(store_id))
    return None, 204


@route(bp, '/<store_id>/products')
def products(store_id):
    """Returns a list of product instances belonging to a store."""
    return _stores.get_or_404(store_id).products


@route(bp, '/<store_id>/products/<product_id>', methods=['PUT'])
def add_product(store_id, product_id):
    """Adds a product to a store. Returns the product instance."""
    return _stores.add_product(_stores.get_or_404(store_id),
                               _products.get_or_404(product_id))


@route(bp, '/<store_id>/products/<product_id>', methods=['DELETE'])
def remove_product(store_id, product_id):
    """Removes a product form a store. Returns a 204 response."""
    _stores.remove_product(_stores.get_or_404(store_id),
                           _products.get_or_404(product_id))
    return None, 204


@route(bp, '/<store_id>/managers')
def managers(store_id):
    return _stores.get_or_404(store_id).managers


@route(bp, '/<store_id>/managers/<user_id>', methods=['PUT'])
def add_manager(store_id, user_id):
    store, manager = _stores.add_manager(_stores.get_or_404(store_id),
                                         _users.get_or_404(user_id))
    send_manager_added_email.delay(manager.email)
    return store


@route(bp, '/<store_id>/managers/<user_id>', methods=['DELETE'])
def remove_manager(store_id, user_id):
    store, manager = _stores.remove_manager(_stores.get_or_404(store_id),
                                            _users.get_or_404(user_id))
    send_manager_removed_email.delay(manager.email)
    return None, 204

########NEW FILE########
__FILENAME__ = users
# -*- coding: utf-8 -*-
"""
    overholt.api.users
    ~~~~~~~~~~~~~~~~~~

    User endpoints
"""

from flask import Blueprint
from flask_login import current_user

from ..services import users
from . import route

bp = Blueprint('users', __name__, url_prefix='/users')


@route(bp, '/')
def whoami():
    """Returns the user instance of the currently authenticated user."""
    return current_user._get_current_object()


@route(bp, '/<user_id>')
def show(user_id):
    """Returns a user instance."""
    return users.get_or_404(user_id)

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
"""
    overholt.core
    ~~~~~~~~~~~~~

    core module
"""

from flask_mail import Mail
from flask_sqlalchemy import SQLAlchemy
from flask_security import Security

#: Flask-SQLAlchemy extension instance
db = SQLAlchemy()

#: Flask-Mail extension instance
mail = Mail()

#: Flask-Security extension instance
security = Security()


class OverholtError(Exception):
    """Base application error class."""

    def __init__(self, msg):
        self.msg = msg


class OverholtFormError(Exception):
    """Raise when an error processing a form occurs."""

    def __init__(self, errors=None):
        self.errors = errors


class Service(object):
    """A :class:`Service` instance encapsulates common SQLAlchemy model
    operations in the context of a :class:`Flask` application.
    """
    __model__ = None

    def _isinstance(self, model, raise_error=True):
        """Checks if the specified model instance matches the service's model.
        By default this method will raise a `ValueError` if the model is not the
        expected type.

        :param model: the model instance to check
        :param raise_error: flag to raise an error on a mismatch
        """
        rv = isinstance(model, self.__model__)
        if not rv and raise_error:
            raise ValueError('%s is not of type %s' % (model, self.__model__))
        return rv

    def _preprocess_params(self, kwargs):
        """Returns a preprocessed dictionary of parameters. Used by default
        before creating a new instance or updating an existing instance.

        :param kwargs: a dictionary of parameters
        """
        kwargs.pop('csrf_token', None)
        return kwargs

    def save(self, model):
        """Commits the model to the database and returns the model

        :param model: the model to save
        """
        self._isinstance(model)
        db.session.add(model)
        db.session.commit()
        return model

    def all(self):
        """Returns a generator containing all instances of the service's model.
        """
        return self.__model__.query.all()

    def get(self, id):
        """Returns an instance of the service's model with the specified id.
        Returns `None` if an instance with the specified id does not exist.

        :param id: the instance id
        """
        return self.__model__.query.get(id)

    def get_all(self, *ids):
        """Returns a list of instances of the service's model with the specified
        ids.

        :param *ids: instance ids
        """
        return self.__model__.query.filter(self.__model__.id.in_(ids)).all()

    def find(self, **kwargs):
        """Returns a list of instances of the service's model filtered by the
        specified key word arguments.

        :param **kwargs: filter parameters
        """
        return self.__model__.query.filter_by(**kwargs)

    def first(self, **kwargs):
        """Returns the first instance found of the service's model filtered by
        the specified key word arguments.

        :param **kwargs: filter parameters
        """
        return self.find(**kwargs).first()

    def get_or_404(self, id):
        """Returns an instance of the service's model with the specified id or
        raises an 404 error if an instance with the specified id does not exist.

        :param id: the instance id
        """
        return self.__model__.query.get_or_404(id)

    def new(self, **kwargs):
        """Returns a new, unsaved instance of the service's model class.

        :param **kwargs: instance parameters
        """
        return self.__model__(**self._preprocess_params(kwargs))

    def create(self, **kwargs):
        """Returns a new, saved instance of the service's model class.

        :param **kwargs: instance parameters
        """
        return self.save(self.new(**kwargs))

    def update(self, model, **kwargs):
        """Returns an updated instance of the service's model class.

        :param model: the model to update
        :param **kwargs: update parameters
        """
        self._isinstance(model)
        for k, v in self._preprocess_params(kwargs).items():
            setattr(model, k, v)
        self.save(model)
        return model

    def delete(self, model):
        """Immediately deletes the specified model instance.

        :param model: the model instance to delete
        """
        self._isinstance(model)
        db.session.delete(model)
        db.session.commit()

########NEW FILE########
__FILENAME__ = factory
# -*- coding: utf-8 -*-
"""
    overholt.factory
    ~~~~~~~~~~~~~~~~

    overholt factory module
"""

import os

from celery import Celery
from flask import Flask
from flask_security import SQLAlchemyUserDatastore

from .core import db, mail, security
from .helpers import register_blueprints
from .middleware import HTTPMethodOverrideMiddleware
from .models import User, Role


def create_app(package_name, package_path, settings_override=None,
               register_security_blueprint=True):
    """Returns a :class:`Flask` application instance configured with common
    functionality for the Overholt platform.

    :param package_name: application package name
    :param package_path: application package path
    :param settings_override: a dictionary of settings to override
    :param register_security_blueprint: flag to specify if the Flask-Security
                                        Blueprint should be registered. Defaults
                                        to `True`.
    """
    app = Flask(package_name, instance_relative_config=True)

    app.config.from_object('overholt.settings')
    app.config.from_pyfile('settings.cfg', silent=True)
    app.config.from_object(settings_override)

    db.init_app(app)
    mail.init_app(app)
    security.init_app(app, SQLAlchemyUserDatastore(db, User, Role),
                      register_blueprint=register_security_blueprint)

    register_blueprints(app, package_name, package_path)

    app.wsgi_app = HTTPMethodOverrideMiddleware(app.wsgi_app)

    return app


def create_celery_app(app=None):
    app = app or create_app('overholt', os.path.dirname(__file__))
    celery = Celery(__name__, broker=app.config['CELERY_BROKER_URL'])
    celery.conf.update(app.config)
    TaskBase = celery.Task

    class ContextTask(TaskBase):
        abstract = True

        def __call__(self, *args, **kwargs):
            with app.app_context():
                return TaskBase.__call__(self, *args, **kwargs)

    celery.Task = ContextTask
    return celery

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    overholt.forms
    ~~~~~~~~~~~~~~

    consolodated forms module
"""

from .products.forms import *
from .stores.forms import *
from .users.forms import *

########NEW FILE########
__FILENAME__ = assets
# -*- coding: utf-8 -*-
"""
    overholt.frontend.assets
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    frontend application asset "pipeline"
"""

from flask_assets import Environment, Bundle


#: application css bundle
css_overholt = Bundle("less/overholt.less",
                       filters="less", output="css/overholt.css",
                       debug=False)

#: consolidated css bundle
css_all = Bundle("css/bootstrap.min.css", css_overholt,
                 "css/bootstrap-responsive.min.css",
                 filters="cssmin", output="css/overholt.min.css")

#: vendor js bundle
js_vendor = Bundle("js/vendor/jquery-1.10.1.min.js",
                   "js/vendor/bootstrap-2.3.3.min.js",
                   "js/vendor/underscore-1.4.4.min.js",
                   "js/vendor/backbone-1.0.0.min.js",
                   filters="jsmin", output="js/vendor.min.js")

#: application js bundle
js_main = Bundle("coffee/*.coffee", filters="coffeescript", output="js/main.js")


def init_app(app):
    webassets = Environment(app)
    webassets.register('css_all', css_all)
    webassets.register('js_vendor', js_vendor)
    webassets.register('js_main', js_main)
    webassets.manifest = 'cache' if not app.debug else False
    webassets.cache = not app.debug
    webassets.debug = app.debug

########NEW FILE########
__FILENAME__ = dashboard


from flask import Blueprint, render_template

from . import route

bp = Blueprint('dashboard', __name__)


@route(bp, '/')
def index():
    """Returns the dashboard interface."""
    return render_template('dashboard.html')

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf-8 -*-
"""
    overholt.helpers
    ~~~~~~~~~~~~~~~~

    overholt helpers module
"""

import pkgutil
import importlib

from flask import Blueprint
from flask.json import JSONEncoder as BaseJSONEncoder


def register_blueprints(app, package_name, package_path):
    """Register all Blueprint instances on the specified Flask application found
    in all modules for the specified package.

    :param app: the Flask application
    :param package_name: the package name
    :param package_path: the package path
    """
    rv = []
    for _, name, _ in pkgutil.iter_modules(package_path):
        m = importlib.import_module('%s.%s' % (package_name, name))
        for item in dir(m):
            item = getattr(m, item)
            if isinstance(item, Blueprint):
                app.register_blueprint(item)
            rv.append(item)
    return rv


class JSONEncoder(BaseJSONEncoder):
    """Custom :class:`JSONEncoder` which respects objects that include the
    :class:`JsonSerializer` mixin.
    """
    def default(self, obj):
        if isinstance(obj, JsonSerializer):
            return obj.to_json()
        return super(JSONEncoder, self).default(obj)


class JsonSerializer(object):
    """A mixin that can be used to mark a SQLAlchemy model class which
    implements a :func:`to_json` method. The :func:`to_json` method is used
    in conjuction with the custom :class:`JSONEncoder` class. By default this
    mixin will assume all properties of the SQLAlchemy model are to be visible
    in the JSON output. Extend this class to customize which properties are
    public, hidden or modified before being being passed to the JSON serializer.
    """

    __json_public__ = None
    __json_hidden__ = None
    __json_modifiers__ = None

    def get_field_names(self):
        for p in self.__mapper__.iterate_properties:
            yield p.key

    def to_json(self):
        field_names = self.get_field_names()

        public = self.__json_public__ or field_names
        hidden = self.__json_hidden__ or []
        modifiers = self.__json_modifiers__ or dict()

        rv = dict()
        for key in public:
            rv[key] = getattr(self, key)
        for key, modifier in modifiers.items():
            value = getattr(self, key)
            rv[key] = modifier(value, self)
        for key in hidden:
            rv.pop(key, None)
        return rv

########NEW FILE########
__FILENAME__ = products
# -*- coding: utf-8 -*-
"""
    overholt.manage.products
    ~~~~~~~~~~~~~~~~~~~~~~~~

    product management commands
"""

########NEW FILE########
__FILENAME__ = stores
# -*- coding: utf-8 -*-
"""
    overholt.manage.stores
    ~~~~~~~~~~~~~~~~~~~~~~

    store management commands
"""

########NEW FILE########
__FILENAME__ = users
# -*- coding: utf-8 -*-
"""
    overholt.manage.users
    ~~~~~~~~~~~~~~~~~~~~~

    user management commands
"""

from flask import current_app
from flask.ext.script import Command, prompt, prompt_pass
from flask_security.forms import RegisterForm
from flask_security.registerable import register_user
from werkzeug.datastructures import MultiDict

from ..services import users


class CreateUserCommand(Command):
    """Create a user"""

    def run(self):
        email = prompt('Email')
        password = prompt_pass('Password')
        password_confirm = prompt_pass('Confirm Password')
        data = MultiDict(dict(email=email, password=password, password_confirm=password_confirm))
        form = RegisterForm(data, csrf_enabled=False)
        if form.validate():
            user = register_user(email=email, password=password)
            print '\nUser created successfully'
            print 'User(id=%s email=%s)' % (user.id, user.email)
            return
        print '\nError creating user:'
        for errors in form.errors.values():
            print '\n'.join(errors)


class DeleteUserCommand(Command):
    """Delete a user"""

    def run(self):
        email = prompt('Email')
        user = users.first(email=email)
        if not user:
            print 'Invalid user'
            return
        users.delete(user)
        print 'User deleted successfully'


class ListUsersCommand(Command):
    """List all users"""

    def run(self):
        for u in users.all():
            print 'User(id=%s email=%s)' % (u.id, u.email)

########NEW FILE########
__FILENAME__ = middleware
# -*- coding: utf-8 -*-
"""
    overholt.middleware
    ~~~~~~~~~~~~~~~~~~~

    middleware module
"""

from werkzeug import url_decode


class HTTPMethodOverrideMiddleware(object):
    """The HTTPMethodOverrideMiddleware middleware implements the hidden HTTP
    method technique. Not all web browsers support every HTTP method, such as
    DELETE and PUT. This middleware class allows clients to provide a method
    override parameter via an HTTP header value or a querystring parameter. This
    middleware will look for the header paramter first followed by the
    querystring. The default HTTP header name is `X-HTTP-METHOD-OVERRIDE` and
    the default querystring parameter name is `__METHOD__`. These can be changed
    via the constructor parameters `header_name` and `querystring_param`
    respectively. Additionally, a list of allowed HTTP methods may be specified
    via the `allowed_methods` constructor parameter. The default allowed methods
    are GET, HEAD, POST, DELETE, PUT, PATCH, and OPTIONS.
    """

    bodyless_methods = frozenset(['GET', 'HEAD', 'OPTIONS', 'DELETE'])

    def __init__(self, app, header_name=None,
                 querystring_param=None, allowed_methods=None):
        header_name = header_name or 'X-HTTP-METHOD-OVERRIDE'

        self.app = app
        self.header_name = 'HTTP_' + header_name.replace('-', '_')
        self.querystring_param = querystring_param or '__METHOD__'
        self.allowed_methods = frozenset(allowed_methods or
            ['GET', 'HEAD', 'POST', 'DELETE', 'PUT', 'PATCH', 'OPTIONS'])

    def _get_from_querystring(self, environ):
        if self.querystring_param in environ.get('QUERY_STRING', ''):
            args = url_decode(environ['QUERY_STRING'])
            return args.get(self.querystring_param)
        return None

    def _get_method_override(self, environ):
        return environ.get(self.header_name, None) or \
               self._get_from_querystring(environ) or ''

    def __call__(self, environ, start_response):
        method = self._get_method_override(environ).upper()

        if method in self.allowed_methods:
            method = method.encode('ascii', 'replace')
            environ['REQUEST_METHOD'] = method

        if method in self.bodyless_methods:
            environ['CONTENT_LENGTH'] = '0'

        return self.app(environ, start_response)

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
    overholt.models
    ~~~~~~~~~~~~~~~

    consolodated models module
"""

from .products.models import *
from .stores.models import *
from .users.models import *

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    overholt.products.forms
    ~~~~~~~~~~~~~~~~~~~~~~~

    Product forms
"""

from flask_wtf import Form, TextField, SelectMultipleField, Required, \
    Optional

from ..services import products

__all__ = ['NewProductForm', 'UpdateProductForm']


class ProductFormMixin(object):

    def __init__(self, *args, **kwargs):
        super(ProductFormMixin, self).__init__(*args, **kwargs)
        self.categories.choices = [(c.id, c.name) for c in products.categories.all()]


class NewProductForm(ProductFormMixin, Form):
    name = TextField('Name', validators=[Required()])
    categories = SelectMultipleField(
        'Categories', coerce=int, validators=[Required()])


class UpdateProductForm(ProductFormMixin, Form):
    name = TextField('Name', validators=[Optional()])
    categories = SelectMultipleField(
        'Categories', coerce=int, validators=[Optional()])

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
    overholt.products.models
    ~~~~~~~~~~~~~~~~~~~~~~

    Product models
"""

from ..core import db
from ..helpers import JsonSerializer


products_categories = db.Table(
    'products_categories',
    db.Column('product_id', db.Integer(), db.ForeignKey('products.id')),
    db.Column('category_id', db.Integer(), db.ForeignKey('categories.id')))


class CategoryJsonSerializer(JsonSerializer):
    __json_hidden__ = ['products']


class Category(CategoryJsonSerializer, db.Model):
    __tablename__ = 'categories'

    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(255))
    description = db.Column(db.String(255))


class ProductJsonSerializer(JsonSerializer):
    __json_hidden__ = ['stores']


class Product(ProductJsonSerializer, db.Model):
    __tablename__ = 'products'

    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(255))

    categories = db.relationship('Category',
                                 secondary=products_categories,
                                 backref=db.backref('products', lazy='joined'))

########NEW FILE########
__FILENAME__ = services
# -*- coding: utf-8 -*-
"""
    overholt.services
    ~~~~~~~~~~~~~~~~~

    services module
"""

from .products import ProductsService
from .stores import StoresService
from .users import UsersService

#: An instance of the :class:`ProductsService` class
products = ProductsService()

#: An instance of the :class:`StoresService` class
stores = StoresService()

#: An instance of the :class:`UsersService` class
users = UsersService()

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
"""
    overholt.settings
    ~~~~~~~~~~~~~~~

    overholt settings module
"""

DEBUG = True
SECRET_KEY = 'super-secret-key'

SQLALCHEMY_DATABASE_URI = 'mysql://root@33.33.33.10:3306/overholt'
CELERY_BROKER_URL = 'redis://33.33.33.10:6379/0'

MAIL_DEFAULT_SENDER = 'info@overholt.com'
MAIL_SERVER = 'smtp.postmarkapp.com'
MAIL_PORT = 25
MAIL_USE_TLS = True
MAIL_USERNAME = 'username'
MAIL_PASSWORD = 'password'

SECURITY_POST_LOGIN_VIEW = '/'
SECURITY_PASSWORD_HASH = 'plaintext'
SECURITY_PASSWORD_SALT = 'password_salt'
SECURITY_REMEMBER_SALT = 'remember_salt'
SECURITY_RESET_SALT = 'reset_salt'
SECURITY_RESET_WITHIN = '5 days'
SECURITY_CONFIRM_WITHIN = '5 days'
SECURITY_SEND_REGISTER_EMAIL = False

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    overholt.stores.forms
    ~~~~~~~~~~~~~~~~~~~~~

    Store forms
"""

from flask_wtf import Form, TextField, Required, Optional

__all__ = ['NewStoreForm', 'UpdateStoreForm']


class NewStoreForm(Form):
    name = TextField('Name', validators=[Required()])
    address = TextField('Address', validators=[Required()])
    city = TextField('City', validators=[Required()])
    state = TextField('State', validators=[Required()])
    zip_code = TextField('Zip Code', validators=[Required()])


class UpdateStoreForm(Form):
    name = TextField('Name', validators=[Optional()])
    address = TextField('Address', validators=[Optional()])
    city = TextField('City', validators=[Optional()])
    state = TextField('State', validators=[Optional()])
    zip_code = TextField('Zip Code', validators=[Optional()])

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
    overholt.stores.models
    ~~~~~~~~~~~~~~~~~~~~~~

    Store models
"""

from ..core import db
from ..helpers import JsonSerializer


stores_products = db.Table(
    'stores_products',
    db.Column('product_id', db.Integer(), db.ForeignKey('products.id')),
    db.Column('store_id', db.Integer(), db.ForeignKey('stores.id')))


stores_managers = db.Table(
    'stores_managers',
    db.Column('user_id', db.Integer(), db.ForeignKey('users.id')),
    db.Column('store_id', db.Integer(), db.ForeignKey('stores.id')))


class StoreJsonSerializer(JsonSerializer):
    pass


class Store(StoreJsonSerializer, db.Model):
    __tablename__ = 'stores'

    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(255))
    address = db.Column(db.String(255))
    city = db.Column(db.String(255))
    state = db.Column(db.String(255))
    zip_code = db.Column(db.String(255))
    manager_id = db.Column(db.ForeignKey('users.id'))

    managers = db.relationship('User', secondary=stores_managers,
                               backref=db.backref('stores', lazy='dynamic'))

    products = db.relationship('Product', secondary=stores_products,
                               backref=db.backref('stores', lazy='dynamic'))

########NEW FILE########
__FILENAME__ = tasks
# -*- coding: utf-8 -*-
"""
    overholt.tasks
    ~~~~~~~~~~~~~~

    overholt tasks module
"""

from .core import mail
from .factory import create_celery_app

celery = create_celery_app()


@celery.task
def send_manager_added_email(*recipients):
    print 'sending manager added email...'


@celery.task
def send_manager_removed_email(*recipients):
    print 'sending manager removed email...'

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    overholt.users.forms
    ~~~~~~~~~~~~~~~~~~~~

    User forms
"""

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
    overholt.users.models
    ~~~~~~~~~~~~~~~~~~~~~

    User models
"""

from flask_security import UserMixin, RoleMixin

from ..core import db
from ..helpers import JsonSerializer


roles_users = db.Table(
    'roles_users',
    db.Column('user_id', db.Integer(), db.ForeignKey('users.id')),
    db.Column('role_id', db.Integer(), db.ForeignKey('roles.id')))


class Role(RoleMixin, db.Model):
    __tablename__ = 'roles'

    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))

    def __eq__(self, other):
        return (self.name == other or
                self.name == getattr(other, 'name', None))

    def __ne__(self, other):
        return (self.name != other and
                self.name != getattr(other, 'name', None))


class UserJsonSerializer(JsonSerializer):
    __json_public__ = ['id', 'email']


class User(UserJsonSerializer, UserMixin, db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(120))
    active = db.Column(db.Boolean())
    confirmed_at = db.Column(db.DateTime())
    last_login_at = db.Column(db.DateTime())
    current_login_at = db.Column(db.DateTime())
    last_login_ip = db.Column(db.String(100))
    current_login_ip = db.Column(db.String(100))
    login_count = db.Column(db.Integer)
    registered_at = db.Column(db.DateTime())

    roles = db.relationship('Role', secondary=roles_users,
                            backref=db.backref('users', lazy='dynamic'))

########NEW FILE########
__FILENAME__ = product_tests
# -*- coding: utf-8 -*-
"""
    tests.api.product_tests
    ~~~~~~~~~~~~~~~~~~~~~~~

    api product tests module
"""

from ..factories import CategoryFactory, ProductFactory
from . import OverholtApiTestCase


class ProductApiTestCase(OverholtApiTestCase):

    def _create_fixtures(self):
        super(ProductApiTestCase, self)._create_fixtures()
        self.category = CategoryFactory()
        self.product = ProductFactory(categories=[self.category])

    def test_get_products(self):
        r = self.jget('/products')
        self.assertOkJson(r)

    def test_get_product(self):
        r = self.jget('/products/%s' % self.product.id)
        self.assertOkJson(r)

    def test_create_product(self):
        r = self.jpost('/products', data={
            'name': 'New Product',
            'categories': [self.category.id]
        })
        self.assertOkJson(r)

    def test_create_invalid_product(self):
        r = self.jpost('/products', data={
            'categories': [self.category.id]
        })
        self.assertBadJson(r)

    def test_update_product(self):
        r = self.jput('/products/%s' % self.product.id, data={
            'name': 'New Product'
        })
        self.assertOkJson(r)

    def test_delete_product(self):
        r = self.jdelete('/products/%s' % self.product.id)
        self.assertStatusCode(r, 204)

########NEW FILE########
__FILENAME__ = store_tests
# -*- coding: utf-8 -*-
"""
    tests.api.store_tests
    ~~~~~~~~~~~~~~~~~~~~~

    api store tests module
"""

from ..factories import StoreFactory, ProductFactory
from . import OverholtApiTestCase


class StoreApiTestCase(OverholtApiTestCase):

    def _create_fixtures(self):
        super(StoreApiTestCase, self)._create_fixtures()
        self.product = ProductFactory()
        self.store = StoreFactory(products=[self.product])

    def test_get_stores(self):
        r = self.jget('/stores')
        self.assertOkJson(r)

    def test_get_store(self):
        r = self.jget('/stores/%s' % self.store.id)
        self.assertOkJson(r)

    def test_create_store(self):
        r = self.jpost('/stores', data={
            'name': 'My Store',
            'address': '123 Overholt Drive',
            'city': 'Brooklyn',
            'state': 'New York',
            'zip_code': '12345'
        })
        self.assertOkJson(r)
        self.assertIn('"name": "My Store"', r.data)

    def test_create_invalid_store(self):
        r = self.jpost('/stores', data={
            'name': 'My Store'
        })
        self.assertBadJson(r)
        self.assertIn('"errors": {', r.data)

    def test_update_store(self):
        r = self.jput('/stores/%s' % self.store.id, data={
            'name': 'My New Store'
        })
        self.assertOkJson(r)
        self.assertIn('"name": "My New Store"', r.data)

    def test_delete_store(self):
        r = self.jdelete('/stores/%s' % self.store.id)
        self.assertStatusCode(r, 204)

    def test_get_products(self):
        r = self.jget('/stores/%s/products' % self.store.id)
        self.assertOkJson(r)

    def test_add_product(self):
        p = ProductFactory()
        e = '/stores/%s/products/%s' % (self.store.id, p.id)
        r = self.jput(e)
        self.assertOkJson(r)

    def test_remove_product(self):
        e = '/stores/%s/products/%s' % (self.store.id, self.product.id)
        r = self.jdelete(e)
        self.assertStatusCode(r, 204)

    def test_add_manager(self):
        e = '/stores/%s/managers/%s' % (self.store.id, self.user.id)
        r = self.jput(e)
        self.assertOkJson(r)

    def test_add_existing_manager(self):
        e = '/stores/%s/managers/%s' % (self.store.id, self.user.id)
        self.jput(e)
        r = self.jput(e)
        self.assertBadJson(r)

    def test_remove_manager(self):
        e = '/stores/%s/managers/%s' % (self.store.id, self.user.id)
        self.jput(e)
        r = self.jdelete(e)
        self.assertStatusCode(r, 204)

########NEW FILE########
__FILENAME__ = user_tests
# -*- coding: utf-8 -*-
"""
    tests.api.user_tests
    ~~~~~~~~~~~~~~~~~~~~

    api user tests module
"""

from . import OverholtApiTestCase


class UserApiTestCase(OverholtApiTestCase):

    def test_get_current_user(self):
        r = self.jget('/users')
        self.assertOkJson(r)

    def test_get_user(self):
        r = self.jget('/users/%s' % self.user.id)
        self.assertOkJson(r)

########NEW FILE########
__FILENAME__ = factories
# -*- coding: utf-8 -*-
"""
    tests.factories
    ~~~~~~~~~~~~~~~

    Overholt test factories module
"""

from datetime import datetime

from factory import Factory, Sequence, LazyAttribute
from flask_security.utils import encrypt_password

from overholt.core import db
from overholt.models import *


def create_sqlalchemy_model_function(class_to_create, *args, **kwargs):
    entity = class_to_create(**kwargs)
    db.session.add(entity)
    db.session.commit()
    return entity

Factory.set_creation_function(create_sqlalchemy_model_function)


class RoleFactory(Factory):
    FACTORY_FOR = Role
    name = 'admin'
    description = 'Administrator'


class UserFactory(Factory):
    FACTORY_FOR = User
    email = Sequence(lambda n: 'user{0}@overholt.com'.format(n))
    password = LazyAttribute(lambda a: encrypt_password('password'))
    last_login_at = datetime.utcnow()
    current_login_at = datetime.utcnow()
    last_login_ip = '127.0.0.1'
    current_login_ip = '127.0.0.1'
    login_count = 1
    roles = LazyAttribute(lambda _: [RoleFactory()])
    active = True


class StoreFactory(Factory):
    FACTORY_FOR = Store
    name = Sequence(lambda n: 'Store Number {0}'.format(n))
    address = '123 Overholt Alley'
    city = 'Overholt'
    state = 'New York'
    zip_code = '12345'


class ProductFactory(Factory):
    FACTORY_FOR = Product
    name = Sequence(lambda n: 'Product Number {0}'.format(n))


class CategoryFactory(Factory):
    FACTORY_FOR = Category
    name = Sequence(lambda n: 'Category {0}'.format(n))

########NEW FILE########
__FILENAME__ = dashboard_tests
# -*- coding: utf-8 -*-
"""
    tests.api.user_tests
    ~~~~~~~~~~~~~~~~~~~~

    api user tests module
"""

from . import OverholtFrontendTestCase


class DashboardTestCase(OverholtFrontendTestCase):

    def test_authenticated_dashboard_access(self):
        r = self.get('/')
        self.assertOk(r)
        self.assertIn('<h1>Dashboard</h1>', r.data)

    def test_unauthenticated_dashboard_access(self):
        self.get('/logout')
        r = self.get('/')
        self.assertOk(r)
        self.assertNotIn('<h1>Dashboard</h1>', r.data)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
"""
    tests.settings
    ~~~~~~~~~~~~~~

    tests settings module
"""

DEBUG = False
TESTING = True

SQLALCHEMY_POOL_SIZE = None
SQLALCHEMY_POOL_TIMEOUT = None
SQLALCHEMY_POOL_RECYCLE = None
SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
"""
    tests.utils
    ~~~~~~~~~~~

    test utilities
"""

import base64
import hmac

from datetime import datetime, timedelta
from hashlib import sha1

import simplejson as json

from werkzeug.utils import parse_cookie


def get_auth_headers(username=None, password=None):
    username = username or 'username'
    password = password or 'password'
    encoded = base64.b64encode('%s:%s' % (username, password))
    return {'Authorization': 'Basic ' + encoded}


class FlaskTestCaseMixin(object):

    def _create_csrf_token(self):
        csrf_key = 'csrf_token'
        with self.client.session_transaction() as session:
            session['csrf'] = csrf_key
        secret_key = self.app.config['SECRET_KEY']
        expires = (datetime.now() + timedelta(minutes=30)).strftime('%Y%m%d%H%M%S')
        csrf_build = '%s%s' % (csrf_key, expires)
        csrf_token = csrf_build.encode('utf8')
        csrf_hmac = hmac.new(secret_key, csrf_token, digestmod=sha1)
        self.csrf_token = '%s##%s' % (expires, csrf_hmac.hexdigest())

    def _html_data(self, kwargs):
        if 'data' in kwargs:
            kwargs['data']['csrf_token'] = self.csrf_token
        if not kwargs.get('content_type'):
            kwargs['content_type'] = 'application/x-www-form-urlencoded'
        return kwargs

    def _json_data(self, kwargs, csrf_enabled=True):
        if 'data' in kwargs:
            kwargs['data']['csrf_token'] = self.csrf_token
            kwargs['data'] = json.dumps(kwargs['data'])
        if not kwargs.get('content_type'):
            kwargs['content_type'] = 'application/json'
        return kwargs

    def _request(self, method, *args, **kwargs):
        kwargs.setdefault('content_type', 'text/html')
        kwargs.setdefault('follow_redirects', True)
        return method(*args, **kwargs)

    def _jrequest(self, *args, **kwargs):
        return self._request(*args, **kwargs)

    def get(self, *args, **kwargs):
        return self._request(self.client.get, *args, **kwargs)

    def post(self, *args, **kwargs):
        return self._request(self.client.post, *args, **self._html_data(kwargs))

    def put(self, *args, **kwargs):
        return self._request(self.client.put, *args, **self._html_data(kwargs))

    def delete(self, *args, **kwargs):
        return self._request(self.client.delete, *args, **kwargs)

    def jget(self, *args, **kwargs):
        return self._jrequest(self.client.get, *args, **kwargs)

    def jpost(self, *args, **kwargs):
        return self._jrequest(self.client.post, *args, **self._json_data(kwargs))

    def jput(self, *args, **kwargs):
        return self._jrequest(self.client.put, *args, **self._json_data(kwargs))

    def jdelete(self, *args, **kwargs):
        return self._jrequest(self.client.delete, *args, **kwargs)


    def getCookies(self, response):
        cookies = {}
        for value in response.headers.get_all("Set-Cookie"):
            cookies.update(parse_cookie(value))
        return cookies

    def assertStatusCode(self, response, status_code):
        """Assert the status code of a Flask test client response

        :param response: The test client response object
        :param status_code: The expected status code
        """
        self.assertEquals(status_code, response.status_code)
        return response

    def assertOk(self, response):
        """Test that response status code is 200

        :param response: The test client response object
        """
        return self.assertStatusCode(response, 200)

    def assertBadRequest(self, response):
        """Test that response status code is 400

        :param response: The test client response object
        """
        return self.assertStatusCode(response, 400)

    def assertForbidden(self, response):
        """Test that response status code is 403

        :param response: The test client response object
        """
        return self.assertStatusCode(response, 403)

    def assertNotFound(self, response):
        """Test that response status code is 404

        :param response: The test client response object
        """
        return self.assertStatusCode(response, 404)

    def assertContentType(self, response, content_type):
        """Assert the content-type of a Flask test client response

        :param response: The test client response object
        :param content_type: The expected content type
        """
        self.assertEquals(content_type, response.headers['Content-Type'])
        return response

    def assertOkHtml(self, response):
        """Assert the response status code is 200 and an HTML response

        :param response: The test client response object
        """
        return self.assertOk(
            self.assertContentType(response, 'text/html; charset=utf-8'))

    def assertJson(self, response):
        """Test that content returned is in JSON format

        :param response: The test client response object
        """
        return self.assertContentType(response, 'application/json')

    def assertOkJson(self, response):
        """Assert the response status code is 200 and a JSON response

        :param response: The test client response object
        """
        return self.assertOk(self.assertJson(response))

    def assertBadJson(self, response):
        """Assert the response status code is 400 and a JSON response

        :param response: The test client response object
        """
        return self.assertBadRequest(self.assertJson(response))

    def assertCookie(self, response, name):
        """Assert the response contains a cookie with the specified name

        :param response: The test client response object
        :param key: The cookie name
        :param value: The value of the cookie
        """
        self.assertIn(name, self.getCookies(response))

    def assertCookieEquals(self, response, name, value):
        """Assert the response contains a cookie with the specified value

        :param response: The test client response object
        :param name: The cookie name
        :param value: The value of the cookie
        """
        self.assertEquals(value, self.getCookies(response).get(name, None))

########NEW FILE########
__FILENAME__ = wsgi
# -*- coding: utf-8 -*-
"""
    wsgi
    ~~~~

    overholt wsgi module
"""

from werkzeug.serving import run_simple
from werkzeug.wsgi import DispatcherMiddleware

from overholt import api, frontend

application = DispatcherMiddleware(frontend.create_app(), {
    '/api': api.create_app()
})

if __name__ == "__main__":
    run_simple('0.0.0.0', 5000, application, use_reloader=True, use_debugger=True)

########NEW FILE########
