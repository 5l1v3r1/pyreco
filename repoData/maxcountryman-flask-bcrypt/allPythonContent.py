__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Bcrypt documentation build configuration file, created by
# sphinx-quickstart on Wed Dec 14 21:28:26 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Bcrypt'
copyright = u'2011, Max Countryman'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------
html_theme_options = {'github_fork': 'maxcountryman/flask-bcrypt', 'index_logo': False}

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Bcryptdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Bcrypt.tex', u'Flask-Bcrypt Documentation',
   u'Max Countryman', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'flask-bcrypt', u'Flask-Bcrypt Documentation',
     [u'Max Countryman'], 1)
]

########NEW FILE########
__FILENAME__ = flask_bcrypt
'''
    flaskext.bcrypt
    ---------------
    
    A Flask extension providing bcrypt hasing and comparison facilities.
    
    :copyright: (c) 2011 by Max Countryman.
    :license: BSD, see LICENSE for more details.
'''

from __future__ import absolute_import
from __future__ import print_function

__version_info__ = ('0', '6', '1')
__version__ = '.'.join(__version_info__)
__author__ = 'Max Countryman'
__license__ = 'BSD'
__copyright__ = '(c) 2011 by Max Countryman'
__all__ = ['Bcrypt', 'check_password_hash', 'generate_password_hash']

from werkzeug.security import safe_str_cmp

try:
    import bcrypt
except ImportError as e:
    print('py-bcrypt is required to use Flask-Bcrypt')
    raise e

from sys import version_info as PYVER
PYVER = PYVER[0]

def generate_password_hash(password, rounds=None):
    '''This helper function wraps the eponymous method of :class:`Bcrypt`. It 
    is intended to be used as a helper function at the expense of the 
    configuration variable provided when passing back the app object. In other 
    words this shortcut does not make use of the app object at all.
    
    To this this function, simple import it from the module and use it in a 
    similar fashion as the method would be used. Here is a quick example::
        
        from flask.ext.bcrypt import generate_password_hash
        pw_hash = generate_password_hash('hunter2', 10)
    
    :param password: The password to be hashed.
    :param rounds: The optional number of rounds.
    '''
    return Bcrypt().generate_password_hash(password, rounds)


def check_password_hash(pw_hash, password):
    '''This helper function wraps the eponymous method of :class:`Bcrypt.` It 
    is intended to be used as a helper function at the expense of the 
    configuration variable provided when passing back the app object. In other 
    words this shortcut does not make use of the app object at all.
    
    To this this function, simple import it from the module and use it in a 
    similar fashion as the method would be used. Here is a quick example::
        
        from flask.ext.bcrypt import check_password_hash
        check_password_hash(pw_hash, 'hunter2') # returns True
    
    :param pw_hash: The hash to be compared against.
    :param password: The password to compare.
    '''
    return Bcrypt().check_password_hash(pw_hash, password)


class Bcrypt(object):
    '''Bcrypt class container for password hashing and checking logic using 
    bcrypt, of course. This class may be used to intialize your Flask app 
    object. The purpose is to provide a simple interface for overriding 
    Werkzeug's built-in password hashing utilities.
    
    Although such methods are not actually overriden, the API is intentionally 
    made similar so that existing applications which make use of the previous 
    hashing functions might be easily adapted to the stronger facility of 
    bcrypt.
    
    To get started you will wrap your application's app object something like 
    this::
        
        app = Flask(__name__)
        bcrypt = Bcrypt(app)
    
    Now the two primary utility methods are exposed via this object, `bcrypt`.
    So in the context of the application, important data, such as passwords, 
    could be hashed using this syntax::
        
        password = 'hunter2'
        pw_hash = bcrypt.generate_password_hash(password)
    
    Once hashed, the value is irreversible. However in the case of validating 
    logins a simple hashing of candidate password and subsequent comparison. 
    Importantly a comparison should be done in constant time. This helps 
    prevent timing attacks. A simple utility method is provided for this::
        
        candidate = 'secret'
        bcrypt.check_password_hash(pw_hash, candidate)
    
    If both the candidate and the existing password hash are a match 
    `check_password_hash` returns True. Otherwise, it returns False.
        
    .. admonition:: Namespacing Issues 
        
        It's worth noting that if you use the format, `bcrypt = Bcrypt(app)` 
        you are effectively overriding the bcrypt module. Though it's unlikely 
        you would need to access the module outside of the scope of the 
        extension be aware that it's overriden.
        
        Alternatively consider using a different name, such as `flask_bcrypt 
        = Bcrypt(app)` to prevent naming collisions.
    
    Additionally a configuration value for `BCRYPT_LOG_ROUNDS` may be set in 
    the configuration of the Flask app. If none is provided this will 
    internally be assigned to 12. (This value is used in determining the 
    complexity of the encryption, see bcrypt for more details.)
    
    :param app: The Flask application object. Defaults to None.
    '''
    
    _log_rounds = 12
    
    def __init__(self, app=None):
        if app is not None:
            self.init_app(app)
    
    def init_app(self, app):
        '''Initalizes the application with the extension.
        
        :param app: The Flask application object.
        '''
        self._log_rounds = app.config.get('BCRYPT_LOG_ROUNDS', 12)
    
    def generate_password_hash(self, password, rounds=None):
        '''Generates a password hash using bcrypt. Specifying `rounds` 
        sets the log_rounds parameter of `bcrypt.gensalt()` which determines 
        the complexity of the salt. 12 is the default value.
        
        Example usage of :class:`generate_password_hash` might look something 
        like this::
            
            pw_hash = bcrypt.generate_password_hash('secret', 10)
        
        :param password: The password to be hashed.
        :param rounds: The optional number of rounds.
        '''
        
        if not password:
            raise ValueError('Password must be non-empty.')
        
        if rounds is None:
            rounds = self._log_rounds
        
        if PYVER < 3 and isinstance(password, unicode):
            password = password.encode('u8')
        elif PYVER >= 3 and isinstance(password, bytes):
            password = password.decode('utf-8')
        password = str(password)
        return bcrypt.hashpw(password, bcrypt.gensalt(rounds))
    
    def check_password_hash(self, pw_hash, password):
        '''Tests a password hash against a candidate password. The candidate 
        password is first hashed and then subsequently compared in constant 
        time to the existing hash. This will either return `True` or `False`.
        
        Example usage of :class:`check_password_hash` would look something 
        like this::
            
            pw_hash = bcrypt.generate_password_hash('secret', 10)
            bcrypt.check_password_hash(pw_hash, 'secret') # returns True
        
        :param pw_hash: The hash to be compared against.
        :param password: The password to compare.
        '''
        if PYVER < 3 and isinstance(password, unicode):
            password = password.encode('u8')
        elif PYVER >= 3 and isinstance(password, bytes):
            password = password.decode('utf-8')
        password = str(password)
        return safe_str_cmp(bcrypt.hashpw(password, pw_hash), pw_hash)

########NEW FILE########
__FILENAME__ = test_bcrypt
import unittest

import flask
from flask_bcrypt import Bcrypt, generate_password_hash, check_password_hash


class BasicTestCase(unittest.TestCase):

    def setUp(self):
        app = flask.Flask(__name__)
        app.config['BCRYPT_LOG_ROUNDS'] = 6
        self.bcrypt = Bcrypt(app)

    def test_is_string(self):
        pw_hash = self.bcrypt.generate_password_hash('secret')
        self.assertTrue(isinstance(pw_hash, str))

    def test_not_string(self):
        pw_hash = self.bcrypt.generate_password_hash(42)
        self.assertTrue(isinstance(pw_hash, str))

    def test_custom_rounds(self):
        password = 'secret'
        pw_hash1 = self.bcrypt.generate_password_hash(password, 5)
        self.assertNotEqual(password, pw_hash1)

    def test_check_hash(self):
        pw_hash = self.bcrypt.generate_password_hash('secret')
        # check a correct password
        self.assertTrue(self.bcrypt.check_password_hash(pw_hash, 'secret'))
        # check an incorrect password
        self.assertFalse(self.bcrypt.check_password_hash(pw_hash, 'hunter2'))
        # check unicode
        pw_hash = self.bcrypt.generate_password_hash(u'\u2603')
        self.assertTrue(self.bcrypt.check_password_hash(pw_hash, u'\u2603'))
        # check helpers
        pw_hash = generate_password_hash('hunter2')
        self.assertTrue(check_password_hash(pw_hash, 'hunter2'))

    def test_check_hash_unicode_is_utf8(self):
        password = u'\u2603'
        pw_hash = self.bcrypt.generate_password_hash(password)
        # check a correct password
        self.assertTrue(self.bcrypt.check_password_hash(pw_hash, b'\xe2\x98\x83'))

    def test_rounds_set(self):
        self.assertEqual(self.bcrypt._log_rounds, 6)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
