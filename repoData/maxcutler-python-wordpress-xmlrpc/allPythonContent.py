__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# python-wordpress-xmlrpc documentation build configuration file, created by
# sphinx-quickstart on Sun Apr 15 15:18:10 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'python-wordpress-xmlrpc'
copyright = u'2012, Max Cutler'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.2'
# The full version, including alpha/beta/rc tags.
release = '2.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'python-wordpress-xmlrpcdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'python-wordpress-xmlrpc.tex', u'python-wordpress-xmlrpc Documentation',
   u'Max Cutler', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'python-wordpress-xmlrpc', u'python-wordpress-xmlrpc Documentation',
     [u'Max Cutler'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'python-wordpress-xmlrpc', u'python-wordpress-xmlrpc Documentation',
   u'Max Cutler', 'python-wordpress-xmlrpc', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
  'python': ('http://python.readthedocs.org/en/latest/', None),
}

########NEW FILE########
__FILENAME__ = test_categories
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import taxonomies, posts
from wordpress_xmlrpc.wordpress import WordPressTerm, WordPressPost


class TestCategories(WordPressTestCase):

    @attr('categories')
    def test_get_tags(self):
        tags = self.client.call(taxonomies.GetTerms('post_tag'))
        for tag in tags:
            self.assertTrue(isinstance(tag, WordPressTerm))
            self.assertEquals(tag.taxonomy, 'post_tag')

    @attr('categories')
    def test_get_categories(self):
        cats = self.client.call(taxonomies.GetTerms('category'))
        for cat in cats:
            self.assertTrue(isinstance(cat, WordPressTerm))
            self.assertEquals(cat.taxonomy, 'category')

    @attr('categories')
    def test_category_lifecycle(self):
        # Create category object
        cat = WordPressTerm()
        cat.name = 'Test Category'
        cat.taxonomy = 'category'

        # Create the category in WordPress
        cat_id = self.client.call(taxonomies.NewTerm(cat))
        self.assertTrue(cat_id)
        cat.id = cat_id

        try:
            # Check that the new category shows in category suggestions
            suggestions = self.client.call(taxonomies.GetTerms('category', {'search': 'test'}))
            self.assertTrue(isinstance(suggestions, list))
            found = False
            for suggestion in suggestions:
                if suggestion.id == cat_id:
                    found = True
                    break
            self.assertTrue(found)
        finally:
            # Delete the category
            response = self.client.call(taxonomies.DeleteTerm(cat.taxonomy, cat.id))
            self.assertTrue(response)

    @attr('categories')
    def test_category_post(self):
        # create a test post
        post = WordPressPost()
        post.title = 'Test Post'
        post.slug = 'test-post'
        post.user = self.userid
        post.id = self.client.call(posts.NewPost(post))

        # create a test category
        cat = WordPressTerm()
        cat.name = 'Test Category'
        cat.taxonomy = 'category'
        cat.id = self.client.call(taxonomies.NewTerm(cat))

        # set category on post
        try:
            post.terms = [cat]
            response = self.client.call(posts.EditPost(post.id, post))
            self.assertTrue(response)

            # fetch categories for the post to verify
            post2 = self.client.call(posts.GetPost(post.id, ['terms']))
            post_cats = post2.terms
            self.assert_list_of_classes(post_cats, WordPressTerm)
            self.assertEqual(post_cats[0].id, cat.id)
        finally:
            # cleanup
            self.client.call(taxonomies.DeleteTerm(cat.taxonomy, cat.id))
            self.client.call(posts.DeletePost(post.id))

########NEW FILE########
__FILENAME__ = test_comments
import random

from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import comments, posts
from wordpress_xmlrpc.wordpress import WordPressComment, WordPressPost


class TestComments(WordPressTestCase):

    def setUp(self):
        super(TestComments, self).setUp()

        post = WordPressPost()
        post.title = 'Comments Test Post'
        post.slug = 'comments-test-post'
        post.user = self.userid
        self.post_id = self.client.call(posts.NewPost(post))

    @attr('comments')
    @attr('pycompat')
    def test_comment_repr(self):
        comment = WordPressComment()
        repr(comment)

    @attr('comments')
    def test_get_comment_status_list(self):
        status_list = self.client.call(comments.GetCommentStatusList())
        self.assertTrue(isinstance(status_list, dict))

    @attr('comments')
    def test_comment_lifecycle(self):
        comment = WordPressComment()
        comment.content = 'This is a test comment.'
        comment.user = self.userid

        # create comment
        comment_id = self.client.call(comments.NewComment(self.post_id, comment))
        self.assertTrue(comment_id)

        # edit comment
        comment.content = 'This is an edited comment.'
        response = self.client.call(comments.EditComment(comment_id, comment))
        self.assertTrue(response)

        # delete comment
        response = self.client.call(comments.DeleteComment(comment_id))
        self.assertTrue(response)

    @attr('comments')
    def test_post_comments(self):
        # create a bunch of comments
        comment_list = []

        counter = 0
        for i in range(1, random.randint(6, 15)):
            comment = WordPressComment()
            comment.content = 'Comment #%s' % counter
            comment.user = self.userid

            comment_id = self.client.call(comments.NewComment(self.post_id, comment))
            comment_list.append(comment_id)
            counter += 1

        # retrieve comment count
        comment_counts = self.client.call(comments.GetCommentCount(self.post_id))
        self.assertEqual(comment_counts['total_comments'], counter)

        # fetch a subset of the comments
        num_comments = 5
        post_comments = self.client.call(comments.GetComments({'post_id': self.post_id, 'number': num_comments}))
        self.assert_list_of_classes(post_comments, WordPressComment)
        self.assertEqual(num_comments, len(post_comments))

        # cleanup
        for comment in comment_list:
            self.client.call(comments.DeleteComment(comment))

    def tearDown(self):
        self.client.call(posts.DeletePost(self.post_id))
        super(WordPressTestCase, self).tearDown()

########NEW FILE########
__FILENAME__ = test_demo
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import demo


class TestDemo(WordPressTestCase):

    @attr('demo')
    def test_say_hello(self):
        response = self.client.call(demo.SayHello())
        self.assertEqual(response, "Hello!")

    @attr('demo')
    def test_add_two_numbers(self):
        sum = self.client.call(demo.AddTwoNumbers(2, 3))
        self.assertEqual(sum, 5)

########NEW FILE########
__FILENAME__ = test_fieldmaps
import datetime
import unittest

from nose.plugins.attrib import attr

from wordpress_xmlrpc.compat import xmlrpc_client
from wordpress_xmlrpc.exceptions import FieldConversionError
from wordpress_xmlrpc.fieldmaps import DateTimeFieldMap
from wordpress_xmlrpc.wordpress import WordPressBase


class SampleModel(WordPressBase):
    definition = {
        'date_created': DateTimeFieldMap('dateCreated'),
    }


class FieldMapsTestCase(unittest.TestCase):

    @attr('fieldmaps')
    def test_date_conversion(self):
        response = {
            'dateCreated': xmlrpc_client.DateTime('20111009T08:07:06'),
        }
        obj = SampleModel(response)

        self.assertTrue(hasattr(obj, 'date_created'))
        self.assertTrue(isinstance(obj.date_created, datetime.datetime))
        self.assertTrue(isinstance(obj.struct['dateCreated'], xmlrpc_client.DateTime))

    @attr('fieldmaps')
    def test_malformed_date_conversion(self):
        response = {
            'dateCreated': xmlrpc_client.DateTime('-0001113TT0::0::00'),
        }
        self.assertRaises(FieldConversionError, SampleModel, response)

    @attr('fieldmaps')
    def test_empty_date_with_timezone_is_accepted(self):
        response = {
            'dateCreated': xmlrpc_client.DateTime('00000000T00:00:00Z'),
        }
        obj = SampleModel(response)
        self.assertTrue(hasattr(obj, 'date_created'))
        self.assertEqual(obj.date_created, datetime.datetime(1, 1, 1, 0, 0))

########NEW FILE########
__FILENAME__ = test_media
import mimetypes

from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.compat import xmlrpc_client
from wordpress_xmlrpc.methods import media
from wordpress_xmlrpc.wordpress import WordPressMedia


class TestMedia(WordPressTestCase):

    @attr('media')
    @attr('pycompat')
    def test_media_repr(self):
        media = WordPressMedia()
        repr(media)

    @attr('media')
    def test_get_media_library(self):
        num_items = 10
        library = self.client.call(media.GetMediaLibrary({'number': num_items}))
        self.assert_list_of_classes(library, WordPressMedia)
        self.assertTrue(len(library) <= num_items)

    @attr('media')
    def test_get_media_item(self):
        # this method cannot yet be tested, as it's impossible to get an ID to query against
        # media_item = self.client.call(media.GetMediaItem(__))
        # self.assertTrue(isinstance(media_item, WordPressMedia))
        pass

    @attr('media')
    def test_upload_file(self):
        # note: due to limitations in the XML-RPC API, this test will always create a new media item
        filename = 'wordpress_logo.png'
        with open('tests/files/' + filename, "rb") as img:
            data = {
                'name': filename,
                'bits': xmlrpc_client.Binary(img.read()),
                'type': mimetypes.read_mime_types(filename) or mimetypes.guess_type(filename)[0],
            }
            response = self.client.call(media.UploadFile(data))
            self.assertTrue(isinstance(response, dict))

########NEW FILE########
__FILENAME__ = test_options
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import options
from wordpress_xmlrpc.wordpress import WordPressOption


class TestOptions(WordPressTestCase):

    @attr('options')
    @attr('pycompat')
    def test_option_repr(self):
        option = WordPressOption()
        repr(option)

    @attr('options')
    def test_get_all_options(self):
        opts = self.client.call(options.GetOptions([]))
        self.assert_list_of_classes(opts, WordPressOption)
        self.assertTrue(len(opts) > 0)

    @attr('options')
    def test_get_specific_options(self):
        desired_opts = ['date_format', 'time_format']
        opts = self.client.call(options.GetOptions(desired_opts))
        self.assert_list_of_classes(opts, WordPressOption)
        self.assertEqual(len(desired_opts), len(opts))
        self.assertEqual(set(desired_opts), set([opt.name for opt in opts]))

    @attr('options')
    def test_set_option(self):
        # get current value
        old_tagline = self.client.call(options.GetOptions('blog_tagline'))[0].value

        # change value
        new_tagline = 'New tagline'
        opts = self.client.call(options.SetOptions({'blog_tagline': new_tagline}))
        self.assertEqual(opts[0].value, new_tagline)

        # set back to original value
        response = self.client.call(options.SetOptions({'blog_tagline': old_tagline}))
        self.assertTrue(response)

########NEW FILE########
__FILENAME__ = test_pages
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import pages, posts
from wordpress_xmlrpc.wordpress import WordPressPage


class TestPages(WordPressTestCase):

    @attr('pages')
    @attr('pycompat')
    def test_page_repr(self):
        page = WordPressPage()
        repr(page)

    @attr('pages')
    def test_get_page_status_list(self):
        status_list = self.client.call(pages.GetPageStatusList())
        self.assertTrue(isinstance(status_list, dict))

    @attr('pages')
    def test_get_page_templates(self):
        templates = self.client.call(pages.GetPageTemplates())
        self.assertTrue(isinstance(templates, dict))
        self.assertTrue('Default' in templates)

    @attr('pages')
    def test_get_pages(self):
        page_list = self.client.call(posts.GetPosts({'post_type': 'page'}, results_class=WordPressPage))
        self.assert_list_of_classes(page_list, WordPressPage)

    @attr('pages')
    def test_page_lifecycle(self):
        page = WordPressPage()
        page.title = 'Test Page'
        page.content = 'This is my test page.'

        # create the page
        page_id = self.client.call(posts.NewPost(page))
        self.assertTrue(page_id)

        # fetch the newly created page
        page2 = self.client.call(posts.GetPost(page_id, results_class=WordPressPage))
        self.assertTrue(isinstance(page2, WordPressPage))
        self.assertEqual(str(page2.id), page_id)

        # edit the page
        page2.content += '<br><b>Updated:</b> This page has been updated.'
        response = self.client.call(posts.EditPost(page_id, page2))
        self.assertTrue(response)

        # delete the page
        response = self.client.call(posts.DeletePost(page_id))
        self.assertTrue(response)

    @attr('pages')
    def test_page_parent(self):
        parent_page = WordPressPage()
        parent_page.title = 'Parent page'
        parent_page.content = 'This is the parent page'
        parent_page.id = self.client.call(posts.NewPost(parent_page))
        self.assertTrue(parent_page.id)

        child_page = WordPressPage()
        child_page.title = 'Child page'
        child_page.content = 'This is the child page'
        child_page.parent_id = parent_page.id
        child_page.id = self.client.call(posts.NewPost(child_page))
        self.assertTrue(child_page.id)

        # re-fetch to confirm parent_id worked
        child_page2 = self.client.call(posts.GetPost(child_page.id))
        self.assertTrue(child_page2)
        self.assertEquals(child_page.parent_id, child_page2.parent_id)

        # cleanup
        self.client.call(posts.DeletePost(parent_page.id))
        self.client.call(posts.DeletePost(child_page.id))

########NEW FILE########
__FILENAME__ = test_posts
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import posts
from wordpress_xmlrpc.wordpress import WordPressPost, WordPressPostType


class TestPosts(WordPressTestCase):

    @attr('posts')
    @attr('pycompat')
    def test_post_repr(self):
        post = WordPressPost()
        repr(post)

    @attr('posts')
    def test_get_post_status_list(self):
        status_list = self.client.call(posts.GetPostStatusList())
        self.assertTrue(isinstance(status_list, dict))

    @attr('posts')
    def test_get_post_formats(self):
        formats = self.client.call(posts.GetPostFormats())
        self.assertTrue(isinstance(formats, dict))
        self.assertTrue('all' in formats)
        self.assertTrue('supported' in formats)

    @attr('posts')
    def test_get_posts(self):
        num_posts = 10
        recent_posts = self.client.call(posts.GetPosts({'number': num_posts}))
        self.assert_list_of_classes(recent_posts, WordPressPost)
        self.assertTrue(len(recent_posts) <= num_posts)

    @attr('posts')
    def test_post_lifecycle(self):
        # create a post object
        post = WordPressPost()
        post.title = 'Test post'
        post.slug = 'test-post'
        post.content = 'This is test post using the XML-RPC API.'
        post.comment_status = 'open'
        post.user = self.userid

        # create the post as a draft
        post_id = self.client.call(posts.NewPost(post))
        self.assertTrue(post_id)

        # fetch the newly-created post
        post2 = self.client.call(posts.GetPost(post_id))
        self.assertTrue(isinstance(post2, WordPressPost))
        self.assertEqual(str(post2.id), post_id)

        # update the post
        post2.content += '<br><b>Updated:</b> This post has been updated.'
        post2.post_status = 'publish'
        response = self.client.call(posts.EditPost(post_id, post2))
        self.assertTrue(response)

        # delete the post
        response = self.client.call(posts.DeletePost(post_id))
        self.assertTrue(response)

    @attr('post_types')
    def test_get_post_types(self):
        post_types = self.client.call(posts.GetPostTypes())
        self.assert_list_of_classes(post_types.values(), WordPressPostType)
        for name, post_type in post_types.items():
            self.assertEqual(name, post_type.name)

    @attr('post_types')
    def test_get_post_type(self):
        post_type = self.client.call(posts.GetPostType('post'))
        self.assertTrue(isinstance(post_type, WordPressPostType))

    @attr('posts')
    @attr('revisions')
    def test_revisions(self):
        original_title = 'Revisions test'
        post = WordPressPost()
        post.title = original_title
        post.slug = 'revisions-test'
        post.content = 'This is a test post using the XML-RPC API.'
        post_id = self.client.call(posts.NewPost(post))
        self.assertTrue(post_id)

        post.title = 'Revisions test updated'
        post.content += ' This is a second revision.'
        response = self.client.call(posts.EditPost(post_id, post))
        self.assertTrue(response)

        # test wp.getRevisions
        revision_list = self.client.call(posts.GetRevisions(post_id, ['post']))
        self.assert_list_of_classes(revision_list, WordPressPost)

        # workaround for WP bug #22686/22687
        # an auto-draft revision will survive wp.newPost, so pick the 2nd revision
        self.assertEqual(2, len(revision_list))
        real_rev = revision_list[1]
        self.assertTrue(real_rev)
        self.assertNotEquals(post_id, real_rev.id)

        # test wp.restoreRevision
        response2 = self.client.call(posts.RestoreRevision(real_rev.id))
        self.assertTrue(response2)
        post2 = self.client.call(posts.GetPost(post_id))
        self.assertEquals(original_title, post2.title)

        # cleanup
        self.client.call(posts.DeletePost(post_id))

########NEW FILE########
__FILENAME__ = test_taxonomies
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import taxonomies
from wordpress_xmlrpc.wordpress import WordPressTaxonomy, WordPressTerm


class TestTaxonomies(WordPressTestCase):

    @attr('taxonomies')
    @attr('pycompat')
    def test_taxonomy_repr(self):
        tax = WordPressTaxonomy()
        repr(tax)

    @attr('taxonomies')
    @attr('pycompat')
    def test_term_repr(self):
        term = WordPressTerm()
        repr(term)

    @attr('taxonomies')
    def test_get_taxonomies(self):
        taxs = self.client.call(taxonomies.GetTaxonomies())
        self.assert_list_of_classes(taxs, WordPressTaxonomy)

    @attr('taxonomies')
    def test_get_taxonomy(self):
        tax = self.client.call(taxonomies.GetTaxonomy('category'))
        self.assertTrue(isinstance(tax, WordPressTaxonomy))

    @attr('taxonomies')
    def test_taxonomy_fields_match(self):
        """
        Check that the fields returned by singular and plural versions are the same.
        """
        tax1 = self.client.call(taxonomies.GetTaxonomy('category'))
        tax2 = None

        # find category taxonomy in the list of all taxonomies
        taxs = self.client.call(taxonomies.GetTaxonomies())
        for tax in taxs:
            if tax.name == 'category':
                tax2 = tax
                break
        self.assertTrue(tax2 is not None)

        # compare the two field-by-field
        for field in tax1.definition.keys():
            self.assertEqual(getattr(tax1, field), getattr(tax2, field))

    @attr('taxonomies')
    @attr('terms')
    def test_get_terms(self):
        terms = self.client.call(taxonomies.GetTerms('category'))
        self.assert_list_of_classes(terms, WordPressTerm)

    @attr('taxonomies')
    @attr('terms')
    def test_get_term(self):
        term = self.client.call(taxonomies.GetTerm('category', 1))
        self.assertTrue(isinstance(term, WordPressTerm))

    @attr('taxonomies')
    @attr('terms')
    def test_term_lifecycle(self):
        term = WordPressTerm()
        term.name = 'Test Term'
        term.taxonomy = 'category'

        # create the term
        term_id = self.client.call(taxonomies.NewTerm(term))
        self.assertTrue(term_id)
        term.id = term_id

        # re-fetch to verify
        term2 = self.client.call(taxonomies.GetTerm(term.taxonomy, term.id))
        self.assertEqual(term.name, term2.name)

        # set a description and save
        term.description = "My test term"
        response = self.client.call(taxonomies.EditTerm(term.id, term))
        self.assertTrue(response)

        # re-fetch to verify
        term3 = self.client.call(taxonomies.GetTerm(term.taxonomy, term.id))
        self.assertEqual(term.description, term3.description)

        # delete the term
        response = self.client.call(taxonomies.DeleteTerm(term.taxonomy, term.id))
        self.assertTrue(response)

    @attr('taxonomies')
    @attr('terms')
    def test_term_parent_child(self):
        parent = WordPressTerm()
        parent.taxonomy = 'category'
        parent.name = 'Test Parent Term'

        parent_id = self.client.call(taxonomies.NewTerm(parent))
        self.assertTrue(parent_id)
        parent.id = parent_id

        child = WordPressTerm()
        child.taxonomy = parent.taxonomy
        child.name = 'Test Child Term'
        child.parent = parent.id

        child_id = self.client.call(taxonomies.NewTerm(child))
        self.assertTrue(child_id)
        child.id = child_id

        try:
            # re-fetch to verify
            child2 = self.client.call(taxonomies.GetTerm(child.taxonomy, child.id))
            self.assertEqual(child.parent, child2.parent)
        finally:
            # cleanup
            self.client.call(taxonomies.DeleteTerm(child.taxonomy, child.id))
            self.client.call(taxonomies.DeleteTerm(parent.taxonomy, parent.id))

    @attr('taxonomies')
    @attr('terms')
    def test_term_search(self):
        tag1 = WordPressTerm()
        tag1.taxonomy = 'post_tag'
        tag1.name = 'Test FoobarA'

        tag1_id = self.client.call(taxonomies.NewTerm(tag1))
        self.assertTrue(tag1_id)
        tag1.id = tag1_id

        tag2 = WordPressTerm()
        tag2.taxonomy = 'post_tag'
        tag2.name = 'Test FoobarB'

        tag2_id = self.client.call(taxonomies.NewTerm(tag2))
        self.assertTrue(tag2_id)
        tag2.id = tag2_id

        try:
            results = self.client.call(taxonomies.GetTerms('post_tag', {'search': 'foobarb'}))
            found_tag1 = False
            found_tag2 = False
            for tag in results:
                if tag.id == tag1_id:
                    found_tag1 = True
                elif tag.id == tag2_id:
                    found_tag2 = True
            self.assertFalse(found_tag1)
            self.assertTrue(found_tag2)
        finally:
            # cleanup
            self.client.call(taxonomies.DeleteTerm(tag1.taxonomy, tag1.id))
            self.client.call(taxonomies.DeleteTerm(tag2.taxonomy, tag2.id))

########NEW FILE########
__FILENAME__ = test_users
from nose.plugins.attrib import attr

from tests import WordPressTestCase

from wordpress_xmlrpc.methods import users
from wordpress_xmlrpc.wordpress import WordPressUser, WordPressBlog, WordPressAuthor


class TestUsers(WordPressTestCase):

    @attr('users')
    @attr('pycompat')
    def test_user_repr(self):
        user = WordPressUser()
        repr(user)

    @attr('users')
    @attr('pycompat')
    def test_author_repr(self):
        author = WordPressAuthor()
        repr(author)

    @attr('users')
    def test_get_user(self):
        user = self.client.call(users.GetUser(self.userid))
        self.assertTrue(isinstance(user, WordPressUser))
        self.assertEqual(user.username, self.username)

    @attr('users')
    def test_get_users(self):
        user_list = self.client.call(users.GetUsers())
        self.assert_list_of_classes(user_list, WordPressUser)
        found = False
        for user in user_list:
            if user.id == self.userid:
                found = True
                break
        self.assertTrue(found)

    @attr('users')
    def test_get_profile(self):
        user = self.client.call(users.GetProfile())
        self.assertTrue(isinstance(user, WordPressUser))
        self.assertEqual(user.username, self.username)

    @attr('users')
    def test_edit_profile(self):
        user = self.client.call(users.GetProfile())
        self.assertTrue(isinstance(user, WordPressUser))
        old_first_name = user.first_name
        new_first_name = 'Foo bar'
        user.first_name = new_first_name
        result = self.client.call(users.EditProfile(user))
        self.assertTrue(result)

        # check that the value changed
        user2 = self.client.call(users.GetProfile())
        self.assertEqual(new_first_name, user2.first_name)

        # cleanup
        user.first_name = old_first_name
        self.client.call(users.EditProfile(user))

    @attr('users')
    def test_get_user_blogs(self):
        blogs = self.client.call(users.GetUsersBlogs())
        self.assert_list_of_classes(blogs, WordPressBlog)

    @attr('users')
    def test_get_authors(self):
        authors = self.client.call(users.GetAuthors())
        self.assert_list_of_classes(authors, WordPressAuthor)

########NEW FILE########
__FILENAME__ = base
import collections
import sys

from wordpress_xmlrpc.compat import xmlrpc_client, dict_type
from wordpress_xmlrpc.exceptions import ServerConnectionError, UnsupportedXmlrpcMethodError, InvalidCredentialsError, XmlrpcDisabledError


class Client(object):
    """
    Connection to a WordPress XML-RPC API endpoint.

    To execute XML-RPC methods, pass an instance of an
    `XmlrpcMethod`-derived class to `Client`'s `call` method.
    """

    def __init__(self, url, username, password, blog_id=0):
        self.url = url
        self.username = username
        self.password = password
        self.blog_id = blog_id

        try:
            self.server = xmlrpc_client.ServerProxy(url, allow_none=True)
            self.supported_methods = self.server.mt.supportedMethods()
        except xmlrpc_client.ProtocolError:
            e = sys.exc_info()[1]
            raise ServerConnectionError(repr(e))

    def call(self, method):
        if method.method_name not in self.supported_methods:
            raise UnsupportedXmlrpcMethodError(method.method_name)

        server_method = getattr(self.server, method.method_name)
        args = method.get_args(self)

        try:
            raw_result = server_method(*args)
        except xmlrpc_client.Fault:
            e = sys.exc_info()[1]
            if e.faultCode == 403:
                raise InvalidCredentialsError(e.faultString)
            elif e.faultCode == 405:
                raise XmlrpcDisabledError(e.faultString)
            else:
                raise
        return method.process_result(raw_result)


class XmlrpcMethod(object):
    """
    Base class for XML-RPC methods.

    Child classes can override methods and properties to customize behavior:

    Properties:
        * `method_name`: XML-RPC method name (e.g., 'wp.getUserInfo')
        * `method_args`: Tuple of method-specific required parameters
        * `optional_args`: Tuple of method-specific optional parameters
        * `results_class`: Python class which will convert an XML-RPC response dict into an object
    """
    method_name = None
    method_args = tuple()
    optional_args = tuple()
    results_class = None

    def __init__(self, *args, **kwargs):
        if self.method_args or self.optional_args:
            if self.optional_args:
                max_num_args = len(self.method_args) + len(self.optional_args)
                if not (len(self.method_args) <= len(args) <= max_num_args):
                    raise ValueError("Invalid number of parameters to %s" % self.method_name)
            else:
                if len(args) != len(self.method_args):
                    raise ValueError("Invalid number of parameters to %s" % self.method_name)

            for i, arg_name in enumerate(self.method_args):
                setattr(self, arg_name, args[i])

            if self.optional_args:
                for i, arg_name in enumerate(self.optional_args, start=len(self.method_args)):
                    if i >= len(args):
                        break
                    setattr(self, arg_name, args[i])

        if 'results_class' in kwargs:
            self.results_class = kwargs['results_class']

    def default_args(self, client):
        """
        Builds set of method-non-specific arguments.
        """
        return tuple()

    def get_args(self, client):
        """
        Builds final set of XML-RPC method arguments based on
        the method's arguments, any default arguments, and their
        defined respective ordering.
        """
        default_args = self.default_args(client)

        if self.method_args or self.optional_args:
            optional_args = getattr(self, 'optional_args', tuple())
            args = []
            for arg in (self.method_args + optional_args):
                if hasattr(self, arg):
                    obj = getattr(self, arg)
                    if hasattr(obj, 'struct'):
                        args.append(obj.struct)
                    else:
                        args.append(obj)
            args = list(default_args) + args
        else:
            args = default_args

        return args

    def process_result(self, raw_result):
        """
        Performs actions on the raw result from the XML-RPC response.

        If a `results_class` is defined, the response will be converted
        into one or more object instances of that class.
        """
        if self.results_class and raw_result:
            if isinstance(raw_result, dict_type):
                return self.results_class(raw_result)
            elif isinstance(raw_result, collections.Iterable):
                return [self.results_class(result) for result in raw_result]

        return raw_result


class AnonymousMethod(XmlrpcMethod):
    """
    An XML-RPC method for which no authentication is required.
    """
    pass


class AuthenticatedMethod(XmlrpcMethod):
    """
    An XML-RPC method for which user authentication is required.

    Blog ID, username and password details will be passed from
    the `Client` instance to the method call.
    """

    def default_args(self, client):
        return (client.blog_id, client.username, client.password)

########NEW FILE########
__FILENAME__ = compat
try:
    import xmlrpclib as xmlrpc_client  # py2.x
except ImportError:
    from xmlrpc import client as xmlrpc_client  # py3.x


import types
try:
    dict_type = types.DictType  # py2.x
except AttributeError:
    dict_type = dict  # py3.x


try:
    from ConfigParser import ConfigParser  # py2.x
except ImportError:
    from configparser import ConfigParser  # py3.x

try:
    unicode('test')
except NameError:
    def unicode(s):
        return s

########NEW FILE########
__FILENAME__ = exceptions
class ServerConnectionError(Exception):
    """
    An error while attempting to connect to the XML-RPC endpoint.
    """
    pass


class UnsupportedXmlrpcMethodError(Exception):
    """
    An error while attempting to call a method that is not
    supported by the XML-RPC server.
    """
    pass


class XmlrpcDisabledError(Exception):
    """
    An error when XML-RPC services are disabled in WordPress.
    """
    pass


class InvalidCredentialsError(Exception):
    """
    An error when the XML-RPC server rejects the user's credentials
    (username/password combination).
    """
    pass


class FieldConversionError(Exception):
    """
    An error while converting field Python value to XML-RPC value type.

    Attributes:
        `field_name`: name of the field
        `input_value`: value that was passed to the conversion function
    """
    def __init__(self, field_name, error):
        self.field_name = field_name
        self.error = error

    def __str__(self):
        return repr(self)

    def __repr__(self):
        return self.field_name

########NEW FILE########
__FILENAME__ = fieldmaps
import datetime

from wordpress_xmlrpc.compat import xmlrpc_client


class FieldMap(object):
    """
    Container for settings mapping a WordPress XML-RPC request/response struct
    to a Python, programmer-friendly class.

    Parameters:
        `inputName`: name of the field in XML-RPC response.
        `outputNames`: (optional) list of field names to use when generating new XML-RPC request. defaults to `[inputName]`
        `default`: (optional) default value to use when none is supplied in XML-RPC response. defaults to `None`
        `conversion`: (optional) function to convert Python value to XML-RPC value for XML-RPC request.
    """

    def __init__(self, inputName, outputNames=None, default=None, conversion=None):
        self.name = inputName
        self.output_names = outputNames or [inputName]
        self.default = default
        self.conversion = conversion

    def convert_to_python(self, xmlrpc=None):
        """
        Extracts a value for the field from an XML-RPC response.
        """
        if xmlrpc:
            return xmlrpc.get(self.name, self.default)
        elif self.default:
            return self.default
        else:
            return None

    def convert_to_xmlrpc(self, input_value):
        """
        Convert a Python value to the expected XML-RPC value type.
        """
        if self.conversion:
            return self.conversion(input_value)
        else:
            return input_value

    def get_outputs(self, input_value):
        """
        Generate a set of output values for a given input.
        """
        output_value = self.convert_to_xmlrpc(input_value)

        output = {}
        for name in self.output_names:
            output[name] = output_value

        return output


class IntegerFieldMap(FieldMap):
    """
    FieldMap pre-configured for handling integer fields.
    """

    def __init__(self, *args, **kwargs):
        if 'conversion' not in kwargs:
            kwargs['conversion'] = int

        super(IntegerFieldMap, self).__init__(*args, **kwargs)


class DateTimeFieldMap(FieldMap):
    """
    FieldMap pre-configured for handling DateTime fields.
    """

    def __init__(self, *args, **kwargs):
        if 'conversion' not in kwargs:
            kwargs['conversion'] = xmlrpc_client.DateTime

        super(DateTimeFieldMap, self).__init__(*args, **kwargs)

    def convert_to_python(self, xmlrpc=None):
        if xmlrpc:
            # make sure we have an `xmlrpc_client.DateTime` instance
            raw_value = xmlrpc.get(self.name, self.default)
            if not isinstance(raw_value, xmlrpc_client.DateTime):
                raw_value = xmlrpc_client.DateTime(raw_value)

            # extract its timetuple and convert to datetime
            try:
                tt = raw_value.timetuple()
            except ValueError:
                # Workaround for a combination of Python and WordPress bug
                # which would return a null date for Draft posts. This is not
                # the case for recent versions of WP, but drafts created a that
                # time still have a null date.
                # The python bug is http://bugs.python.org/issue2623 and
                # affects xmlrpclib when fed a timezone aware DateTime
                if str(raw_value) == "00000000T00:00:00Z":
                    raw_value = xmlrpc_client.DateTime("00010101T00:00:00")
                    tt = raw_value.timetuple()
                else:
                    raise
            return datetime.datetime(*tuple(tt)[:6])
        elif self.default:
            return self.default
        else:
            return None


class TermsListFieldMap(FieldMap):
    """
    FieldMap that converts to/from WordPress objects.
    """
    def __init__(self, object_class, *args, **kwargs):
        self.object_class = object_class
        super(TermsListFieldMap, self).__init__(*args, **kwargs)

    def convert_to_python(self, xmlrpc=None):
        if xmlrpc and self.name in xmlrpc:
            values = []
            for value in xmlrpc.get(self.name):
                values.append(self.object_class(value))
            return values
        else:
            return []

    def convert_to_xmlrpc(self, input_value):
        if input_value:
            values = {}
            for term in input_value:
                if term.taxonomy not in values:
                    values[term.taxonomy] = []
                values[term.taxonomy].append(int(term.id))
            return values
        else:
            return None

########NEW FILE########
__FILENAME__ = comments
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressComment


class GetComment(AuthenticatedMethod):
    """
    Retrieve an individual comment.

    Parameters:
        `comment_id`: ID of the comment to retrieve.

    Returns: :class:`WordPressPost` instance.
    """
    method_name = 'wp.getComment'
    method_args = ('comment_id',)
    results_class = WordPressComment


class NewComment(AuthenticatedMethod):
    """
    Create a new comment on a post.

    Parameters:
        `post_id`: The id of the post to add a comment to.
        `comment`: A :class:`WordPressComment` instance with at least the `content` value set.

    Returns: ID of the newly-created comment (an integer).
    """
    method_name = 'wp.newComment'
    method_args = ('post_id', 'comment')


class NewAnonymousComment(AnonymousMethod):
    """
    Create a new comment on a post without authenticating.

    NOTE: Requires support on the blog by setting the following filter in a plugin or theme:

        add_filter( 'xmlrpc_allow_anonymous_comments', '__return_true' );

    Parameters:
        `post_id`: The id of the post to add a comment to.
        `comment`: A :class:`WordPressComment` instance with at least the `content` value set.

    Returns: ID of the newly-created comment (an integer).
    """
    method_name = 'wp.newComment'
    method_args = ('post_id', 'comment')


class EditComment(AuthenticatedMethod):
    """
    Edit an existing comment.

    Parameters:
        `comment_id`: The id of the comment to edit.
        `comment`: A :class:`WordPressComment` instance with at least the `content` value set.

    Returns: `True` on successful edit.
    """
    method_name = 'wp.editComment'
    method_args = ('comment_id', 'comment')


class DeleteComment(AuthenticatedMethod):
    """
    Delete an existing comment.

    Parameters:
        `comment_id`: The id of the comment to be deleted.

    Returns: `True` on successful deletion.
    """
    method_name = 'wp.deleteComment'
    method_args = ('comment_id',)


class GetCommentStatusList(AuthenticatedMethod):
    """
    Retrieve the set of possible blog comment statuses (e.g., "approve," "hold," "spam").

    Parameters:
        None

    Returns: `dict` of values and their pretty names.

    Example:
        >>> client.call(GetCommentStatusList())
        {'hold': 'Unapproved', 'approve': 'Approved', 'spam': 'Spam'}
    """
    method_name = 'wp.getCommentStatusList'


class GetCommentCount(AuthenticatedMethod):
    """
    Retrieve comment count for a specific post.

    Parameters:
        `post_id`: The id of the post to retrieve comment count for.

    Returns: `dict` of comment counts for the post divided by comment status.

    Example:
        >>> client.call(GetCommentCount(1))
        {'awaiting_moderation': '2', 'total_comments': 23, 'approved': '18', 'spam': 3}
    """
    method_name = 'wp.getCommentCount'
    method_args = ('post_id',)


class GetComments(AuthenticatedMethod):
    """
    Gets a set of comments for a post.

    Parameters:
        `filter`: a `dict` with the following values:
            * `post_id`: the id of the post to retrieve comments for
            * `status`: type of comments of comments to retrieve (optional, defaults to 'approve')
            * `number`: number of comments to retrieve (optional, defaults to 10)
            * `offset`: retrieval offset (optional, defaults to 0)

    Returns: `list` of :class:`WordPressComment` instances.
    """
    method_name = 'wp.getComments'
    method_args = ('filter',)
    results_class = WordPressComment

########NEW FILE########
__FILENAME__ = demo
from wordpress_xmlrpc.base import *


class SayHello(AnonymousMethod):
    method_name = 'demo.sayHello'


class AddTwoNumbers(AnonymousMethod):
    method_name = 'demo.addTwoNumbers'
    method_args = ('number1', 'number2')

########NEW FILE########
__FILENAME__ = media
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressMedia


class GetMediaLibrary(AuthenticatedMethod):
    """
    Retrieve filtered list of media library items.

    Parameters:
        `filter`: `dict` with optional keys:
            * `number`: number of media items to retrieve
            * `offset`: query offset
            * `parent_id`: ID of post the media item is attached to.
                         Use empty string (default) to show all media items.
                         Use `0` to show unattached media items.
            * `mime_type`: file mime-type to filter by (e.g., 'image/jpeg')

    Returns: `list` of :class:`WordPressMedia` instances.
    """
    method_name = 'wp.getMediaLibrary'
    method_args = ('filter',)
    results_class = WordPressMedia


class GetMediaItem(AuthenticatedMethod):
    """
    Retrieve an individual media item.

    Parameters:
        `attachment_id`: ID of the media item.

    Returns: :class:`WordPressMedia` instance.
    """
    method_name = 'wp.getMediaItem'
    method_args = ('attachment_id',)
    results_class = WordPressMedia


class UploadFile(AuthenticatedMethod):
    """
    Upload a file to the blog.

    Note: the file is not attached to or inserted into any blog posts.

    Parameters:
        `data`: `dict` with three items:
            * `name`: filename
            * `type`: MIME-type of the file
            * `bits`: base-64 encoded contents of the file. See xmlrpclib.Binary()
            * `overwrite` (optional): flag to override an existing file with this name

    Returns: `dict` with keys `id`, `file` (filename), `url` (public URL), and `type` (MIME-type).
    """
    method_name = 'wp.uploadFile'
    method_args = ('data',)

########NEW FILE########
__FILENAME__ = options
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressOption


class GetOptions(AuthenticatedMethod):
    """
    Retrieve list of blog options.

    Parameters:
        `options`: `list` of option names to retrieve; if empty, all options will be retrieved

    Returns: `list` of :class:`WordPressOption` instances.
    """
    method_name = 'wp.getOptions'
    method_args = ('options',)

    def process_result(self, options_dict):
        options = []
        for key, value in options_dict.items():
            value['name'] = key
            options.append(WordPressOption(value))
        return options


class SetOptions(GetOptions):
    """
    Update the value of an existing blog option.

    Parameters:
        `options`: `dict` of key/value pairs

    Returns: `list` of :class:`WordPressOption` instances representing the updated options.
    """
    method_name = 'wp.setOptions'
    method_args = ('options',)

########NEW FILE########
__FILENAME__ = pages
from wordpress_xmlrpc.base import *


class GetPageStatusList(AuthenticatedMethod):
    """
    Retrieve the set of possible blog page statuses (e.g., "draft," "private," "publish").

    Parameters:
        None

    Returns: `dict` of values and their pretty names.

    Example:
        >>> client.call(GetPageStatusList())
        {'draft': 'Draft', 'private': 'Private', 'publish': 'Published'}
    """
    method_name = 'wp.getPageStatusList'


class GetPageTemplates(AuthenticatedMethod):
    """
    Retrieve the list of blog templates.

    Parameters:
        None

    Returns: `dict` of values and their paths.

    Example:
        >>> client.call(GetPageTemplates())
        {'Default': 'default', 'Sidebar Template': 'sidebar-page.php', 'Showcase Template': 'showcase.php'}
    """
    method_name = 'wp.getPageTemplates'

########NEW FILE########
__FILENAME__ = posts
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressPost, WordPressPostType


class GetPosts(AuthenticatedMethod):
    """
    Retrieve posts from the blog.

    Parameters:
       `filter`: optional `dict` of filters:
            * `number`
            * `offset`
            * `orderby`
            * `order`: 'ASC' or 'DESC'
            * `post_type`: Defaults to 'post'
            * `post_status`

    Returns: `list` of :class:`WordPressPost` instances.
    """
    method_name = 'wp.getPosts'
    optional_args = ('filter', 'fields')
    results_class = WordPressPost


class GetPost(AuthenticatedMethod):
    """
    Retrieve an individual blog post.

    Parameters:
        `post_id`: ID of the blog post to retrieve.

    Returns: :class:`WordPressPost` instance.
    """
    method_name = 'wp.getPost'
    method_args = ('post_id',)
    optional_args = ('fields',)
    results_class = WordPressPost


class NewPost(AuthenticatedMethod):
    """
    Create a new post on the blog.

    Parameters:
        `content`: A :class:`WordPressPost` instance with at least the `title` and `content` values set.

    Returns: ID of the newly-created blog post (an integer).
    """
    method_name = 'wp.newPost'
    method_args = ('content',)


class EditPost(AuthenticatedMethod):
    """
    Edit an existing blog post.

    Parameters:
        `post_id`: ID of the blog post to edit.
        `content`: A :class:`WordPressPost` instance with the new values for the blog post.

    Returns: `True` on successful edit.
    """
    method_name = 'wp.editPost'
    method_args = ('post_id', 'content')


class DeletePost(AuthenticatedMethod):
    """
    Delete a blog post.

    Parameters:
        `post_id`: ID of the blog post to delete.

    Returns: `True` on successful deletion.
    """
    method_name = 'wp.deletePost'
    method_args = ('post_id', )


class GetPostStatusList(AuthenticatedMethod):
    """
    Retrieve the set of possible blog post statuses (e.g., "draft," "private," "publish").

    Parameters:
        None

    Returns: `dict` of values and their pretty names.

    Example:
        >>> client.call(GetPostStatusList())
        {'draft': 'Draft', 'private': 'Private', 'pending': 'Pending Review', 'publish': 'Published'}
    """
    method_name = 'wp.getPostStatusList'


class GetPostFormats(AuthenticatedMethod):
    """
    Retrieve the set of post formats used by the blog.

    Parameters:
        None

    Returns: `dict` containing a `dict` of all blog post formats (`all`)
             and a list of formats `supported` by the theme.

    Example:
        >>> client.call(GetPostFormats())
        {'all': {'status': 'Status', 'quote': 'Quote', 'image': 'Image', 'aside': 'Aside', 'standard': 'Standard', 'link': 'Link', 'chat': 'Chat', 'video': 'Video', 'audio': 'Audio', 'gallery': 'Gallery'},
         'supported': ['aside', 'link', 'gallery', 'status', 'quote', 'image']}
    """
    method_name = 'wp.getPostFormats'

    def get_args(self, client):
        args = super(GetPostFormats, self).get_args(client)
        args += ({'show-supported': True},)
        return args


class GetPostTypes(AuthenticatedMethod):
    """
    Retrieve a list of post types used by the blog.

    Parameters:
        None

    Returns: `dict` with names as keys and :class:`WordPressPostType` instances as values.
    """
    method_name = 'wp.getPostTypes'
    results_class = WordPressPostType

    def process_result(self, raw_result):
        result = {}
        for name, raw_value in raw_result.items():
            result[name] = self.results_class(raw_value)
        return result


class GetPostType(AuthenticatedMethod):
    """
    Retrieve an individual blog post type.

    Parameters:
        `post_type`: Name of the blog post type to retrieve.

    Returns: :class:`WordPressPostType` instance.
    """
    method_name = 'wp.getPostType'
    method_args = ('post_type',)
    results_class = WordPressPostType


class GetRevisions(AuthenticatedMethod):
    """
    Retrieve all revisions of a post.

    Parameters:
        `post_id`: ID of the post.

    Returns: `list` of :class:`WordPressPost` instances.
    """
    method_name = 'wp.getRevisions'
    method_args = ('post_id',)
    optional_args = ('fields',)
    results_class = WordPressPost


class RestoreRevision(AuthenticatedMethod):
    """
    Restores a post to a previous revision.

    Parameters:
        `revision_id`: ID of the revision to revert to.

    Returns: `True` on successful reversion.
    """
    method_name = 'wp.restoreRevision'
    method_args = ('revision_id',)

########NEW FILE########
__FILENAME__ = taxonomies
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressTaxonomy, WordPressTerm


class GetTaxonomies(AuthenticatedMethod):
    """
    Retrieve the list of available taxonomies for the blog.

    Parameters:
        None

    Returns: `list` of :class:`WordPressTaxonomy` instances.
    """
    method_name = 'wp.getTaxonomies'
    results_class = WordPressTaxonomy


class GetTaxonomy(AuthenticatedMethod):
    """
    Retrieve an individual taxonomy.

    Parameters:
        `taxonomy`: name of the taxonomy

    Returns: :class:`WordPressTaxonomy` instance.
    """
    method_name = 'wp.getTaxonomy'
    method_args = ('taxonomy',)
    results_class = WordPressTaxonomy


class GetTerms(AuthenticatedMethod):
    """
    Retrieve the list of available terms for a taxonomy.

    Parameters:
        `taxonomy`: name of the taxonomy

        `filter`: optional `dict` of filters:
            * `number`
            * `offset`
            * `orderby`
            * `order`: 'ASC' or 'DESC'
            * `hide_empty`: Whether to return terms with count==0
            * `search`: Case-insensitive search on term names

    Returns: `list` of :class:`WordPressTerm` instances.
    """
    method_name = 'wp.getTerms'
    method_args = ('taxonomy',)
    optional_args = ('filter',)
    results_class = WordPressTerm


class GetTerm(AuthenticatedMethod):
    """
    Retrieve an individual term.

    Parameters:
        `taxonomy`: name of the taxonomy

        `term_id`: ID of the term

    Returns: :class:`WordPressTerm` instance.
    """
    method_name = 'wp.getTerm'
    method_args = ('taxonomy', 'term_id')
    results_class = WordPressTerm


class NewTerm(AuthenticatedMethod):
    """
    Create new term.

    Parameters:
        `term`: instance of :class:`WordPressTerm`

    Returns: ID of newly-created term (an integer).
    """
    method_name = 'wp.newTerm'
    method_args = ('term',)


class EditTerm(AuthenticatedMethod):
    """
    Edit an existing term.

    Parameters:
        `term_id`: ID of the term to edit.

        `term`: A :class:`WordPressTerm` instance with the new values for the term.

    Returns: `True` on successful edit.
    """
    method_name = 'wp.editTerm'
    method_args = ('term_id', 'term')


class DeleteTerm(AuthenticatedMethod):
    """
    Delete a term.

    Parameters:
        `taxonomy`: name of the taxonomy

        `term_id`: ID of the term to delete.

    Returns: `True` on successful deletion.
    """
    method_name = 'wp.deleteTerm'
    method_args = ('taxonomy', 'term_id')

########NEW FILE########
__FILENAME__ = users
from wordpress_xmlrpc.base import *
from wordpress_xmlrpc.wordpress import WordPressBlog, WordPressAuthor, WordPressUser


class GetUsers(AuthenticatedMethod):
    """
    Retrieve list of users in the blog.

    Parameters:
        `filter`: optional `dict` of filters:
            * `number`
            * `offset`
            * `role`

        `fields`: optional `list` of fields to return. Specific fields, or groups 'basic' or 'all'.

    Returns: `list` of :class:`WordPressUser` instances.
    """
    method_name = 'wp.getUsers'
    optional_args = ('filter', 'fields')
    results_class = WordPressUser


class GetUser(AuthenticatedMethod):
    """
    Retrieve an individual user.

    Parameters:
        `user_id`: ID of the user
        `fields`: (optional) `list` of fields to return. Specific fields, or groups 'basic' or 'all'.

    Returns: :class:`WordPressUser` instance.
    """
    method_name = 'wp.getUser'
    method_args = ('user_id',)
    optional_args = ('fields',)
    results_class = WordPressUser


class GetProfile(AuthenticatedMethod):
    """
    Retrieve information about the connected user.

    Parameters:
        None

    Returns: instance of :class:`WordPressUser` representing the user whose credentials are being used with the XML-RPC API.
    """
    method_name = 'wp.getProfile'
    results_class = WordPressUser


class EditProfile(AuthenticatedMethod):
    """
    Edit profile fields of the connected user.

    Parameters:
        `user`: `WordPressUser` instance.

    Returns: `True` on successful edit.
    """
    method_name = 'wp.editProfile'
    method_args = ('user',)


class GetUserInfo(GetProfile):
    """Alias for GetProfile for backwards compatibility"""
    pass


class GetUsersBlogs(AuthenticatedMethod):
    """
    Retrieve list of blogs that this user belongs to.

    Parameters:
        None

    Returns: `list` of :class:`WordPressBlog` instances.
    """
    method_name = 'wp.getUsersBlogs'
    results_class = WordPressBlog

    def get_args(self, client):
        # strip off first (blog_id) parameter
        return super(GetUsersBlogs, self).get_args(client)[1:]


class GetAuthors(AuthenticatedMethod):
    """
    Retrieve list of authors in the blog.

    Parameters:
        None

    Returns: `list` of :class:`WordPressAuthor` instances.
    """
    method_name = 'wp.getAuthors'
    results_class = WordPressAuthor

########NEW FILE########
__FILENAME__ = wordpress
import sys
from .compat import *
from .fieldmaps import FieldMap, IntegerFieldMap, DateTimeFieldMap, TermsListFieldMap
from wordpress_xmlrpc.exceptions import FieldConversionError


class WordPressBase(object):
    """
    Base class for representing a WordPress object. Handles conversion
    of an XML-RPC response to an object, and construction of a `struct`
    to use in XML-RPC requests.

    Child classes should define a `definition` property that contains
    the list of fields and a `FieldMap` instance to handle conversion
    for XML-RPC calls.
    """
    definition = {}

    def __init__(self, xmlrpc=None):
        # create private variable containing all FieldMaps for the `definition`
        self._def = {}

        for key, value in self.definition.items():
            # if the definition was not a FieldMap, create a simple FieldMap
            if isinstance(value, FieldMap):
                self._def[key] = value
            else:
                self._def[key] = FieldMap(value)

            # convert and store the value on this instance if non-empty
            try:
                converted_value = self._def[key].convert_to_python(xmlrpc)
            except Exception:
                e = sys.exc_info()[1]
                raise FieldConversionError(key, e)
            if converted_value is not None:
                setattr(self, key, converted_value)

    @property
    def struct(self):
        """
        XML-RPC-friendly representation of the current object state
        """
        data = {}
        for var, fmap in self._def.items():
            if hasattr(self, var):
                data.update(fmap.get_outputs(getattr(self, var)))
        return data

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, str(self).encode('utf-8'))


class WordPressTaxonomy(WordPressBase):
    definition = {
        'name': FieldMap('name', default=''),
        'label': 'label',
        'labels': 'labels',
        'hierarchical': 'hierarchical',
        'public': 'public',
        'show_ui': 'show_ui',
        'cap': 'cap',
        'is_builtin': '_builtin',
        'object_type': 'object_type'
    }

    def __str__(self):
        if hasattr(self, 'name'):
            return self.name
        return unicode('')


class WordPressTerm(WordPressBase):
    definition = {
        'id': 'term_id',
        'group': 'term_group',
        'taxonomy': 'taxonomy',
        'taxonomy_id': 'term_taxonomy_id',
        'name': FieldMap('name', default=''),
        'slug': 'slug',
        'description': 'description',
        'parent': 'parent',
        'count': IntegerFieldMap('count')
    }

    def __str__(self):
        if hasattr(self, 'name'):
            return self.name
        return unicode('')


class WordPressPost(WordPressBase):
    definition = {
        'id': 'post_id',
        'user': 'post_author',
        'date': DateTimeFieldMap('post_date_gmt'),
        'date_modified': DateTimeFieldMap('post_modified_gmt'),
        'slug': 'post_name',
        'post_status': 'post_status',
        'title': FieldMap('post_title', default='Untitled'),
        'content': 'post_content',
        'excerpt': 'post_excerpt',
        'link': 'link',
        'comment_status': 'comment_status',
        'ping_status': 'ping_status',
        'terms': TermsListFieldMap(WordPressTerm, 'terms'),
        'terms_names': 'terms_names',
        'custom_fields': 'custom_fields',
        'enclosure': 'enclosure',
        'password': 'post_password',
        'post_format': 'post_format',
        'thumbnail': 'post_thumbnail',
        'sticky': 'sticky',
        'post_type': FieldMap('post_type', default='post'),
        'parent_id': 'post_parent',
        'menu_order': IntegerFieldMap('menu_order'),
        'guid': 'guid',
        'mime_type': 'post_mime_type',
    }

    def __str__(self):
        if hasattr(self, 'title'):
            return self.title
        return unicode('')


class WordPressPage(WordPressPost):
    definition = dict(WordPressPost.definition, **{
        'template': 'wp_page_template',
        'post_type': FieldMap('post_type', default='page'),
    })


class WordPressComment(WordPressBase):
    definition = {
        'id': 'comment_id',
        'user': 'user_id',
        'post': 'post_id',
        'post_title': 'post_title',
        'parent': 'comment_parent',
        'date_created': DateTimeFieldMap('date_created_gmt'),
        'status': 'status',
        'content': FieldMap('content', default=''),
        'link': 'link',
        'author': 'author',
        'author_url': 'author_url',
        'author_email': 'author_email',
        'author_ip': 'author_ip',
    }

    def __str__(self):
        if hasattr(self, 'content'):
            return self.content
        return unicode('')


class WordPressBlog(WordPressBase):
    definition = {
        'id': 'blogid',
        'name': FieldMap('blogName', default=''),
        'url': 'url',
        'xmlrpc': 'xmlrpc',
        'is_admin': FieldMap('isAdmin', default=False),
    }

    def __str__(self):
        if hasattr(self, 'name'):
            return self.name
        return unicode('')


class WordPressAuthor(WordPressBase):
    definition = {
        'id': 'user_id',
        'user_login': 'user_login',
        'display_name': FieldMap('display_name', default=''),
    }

    def __str__(self):
        if hasattr(self, 'display_name'):
            return self.display_name
        return unicode('')


class WordPressUser(WordPressBase):
    definition = {
        'id': 'user_id',
        'username': 'username',
        'roles': 'roles',
        'nickname': 'nickname',
        'url': 'url',
        'first_name': 'first_name',
        'last_name': 'last_name',
        'registered': DateTimeFieldMap('registered'),
        'bio': 'bio',
        'email': 'email',
        'nicename': 'nicename',
        'display_name': 'display_name',
    }

    def __str__(self):
        if hasattr(self, 'nickname'):
            return self.nickname
        return unicode('')


class WordPressMedia(WordPressBase):
    definition = {
        'id': 'attachment_id',
        'parent': 'parent',
        'title': FieldMap('title', default=''),
        'description': 'description',
        'caption': 'caption',
        'date_created': DateTimeFieldMap('date_created_gmt'),
        'link': 'link',
        'thumbnail': 'thumbnail',
        'metadata': 'metadata',
    }

    def __str__(self):
        if hasattr(self, 'title'):
            return self.title
        return unicode('')


class WordPressOption(WordPressBase):
    definition = {
        'name': FieldMap('name', default=''),
        'description': 'desc',
        'value': FieldMap('value', default=''),
        'read_only': FieldMap('readonly', default=False),
    }

    def __str__(self):
        if hasattr(self, 'name') and hasattr(self, 'value'):
            return '%s="%s"' % (self.name, self.value)
        return unicode('')


class WordPressPostType(WordPressBase):
    definition = {
        'name': 'name',
        'label': FieldMap('label', default=''),
        'labels': 'labels',
        'cap': 'cap',
        'map_meta_cap': 'map_meta_cap',
        'hierarchical': 'hierarchical',
        'menu_icon': 'menu_icon',
        'menu_position': 'menu_position',
        'public': 'public',
        'show_in_menu': 'show_in_menu',
        'taxonomies': 'taxonomies',
        'is_builtin': '_builtin',
        'supports': 'supports',
    }

    def __str__(self):
        if hasattr(self, 'name'):
            return self.name
        return unicode('')

########NEW FILE########
