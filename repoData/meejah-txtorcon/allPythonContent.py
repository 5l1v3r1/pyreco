__FILENAME__ = apilinks_sphinxext
'''
Sphinx/docutils extension to create links to pyDoctor documentation using
a RestructuredText interpreted text role that looks like this:

    :api:`python_object_to_link_to <label>`

for example:

    :api:`twisted.internet.defer.Deferred <Deferred>`

Note, this is downloaded from:

   https://bazaar.launchpad.net/~khorn/pydoctor/sphinxext/view/head:/apilinks_sphinxext.py
   
with a couple local tweaks ("label = full_name" and https for URL).
'''

def make_api_link(name, rawtext, text, lineno, inliner,
                     options={}, content=[]):

    from docutils import nodes, utils

    # quick, dirty, and ugly...
    if '<' in text and '>' in text:
        full_name, label = text.split('<')
        full_name = full_name.strip()
        label = label.strip('>').strip()
    else:
        full_name = text
        label = full_name

    #get the base url for api links from the config file
    env = inliner.document.settings.env
    base_url =  env.config.apilinks_base_url

    # not really sufficient, but just testing...
    # ...hmmm, maybe this is good enough after all
    ref = ''.join((base_url, full_name, '.html'))

    node = nodes.reference(rawtext, utils.unescape(label), refuri=ref,
                           **options)

    nodes = [node]
    sys_msgs = []
    return nodes, sys_msgs


# setup function to register the extension

def setup(app):
    app.add_config_value('apilinks_base_url', 
                         'https://twistedmatrix.com/documents/current/api/', 
                         'env')
    app.add_role('api', make_api_link)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# txtorcon documentation build configuration file, created by
# sphinx-quickstart on Thu Jan 26 13:04:28 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

## trying to set t his somewhere...
autodoc_member_order = 'bysource'
autodoc_default_flags = ['members', 'show-inheritance', 'undoc-members']
autoclass_content = 'both'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc',
              'sphinx.ext.todo',
              'sphinx.ext.autosummary',
              'sphinx.ext.todo',
              'sphinx.ext.coverage',
              'repoze.sphinx.autointerface',
              'apilinks_sphinxext'
              ]

todo_include_todos = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'txtorcon'
copyright = u'2012, meejah@meejah.ca'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
from txtorcon import __version__
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'
html_theme = 'scrolls'
html_theme = 'traditional'
html_theme = 'nature'
html_theme = 'pyramid'
html_theme = 'agogo'
html_theme = 'haiku'
html_theme_options = {
#   'stickysidebar': 'true',
#   'rightsidebar':'true',
    'nosidebar': 'false',
#    'full_logo': 'false'
    'sidebarwidth': '300'
    }

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = 'timaq4ygg2iegci7.onion: txtorcon documentation'

# A shorter title for the navigation bar.  Default is the same as html_title.
html_short_title = 'txtorcon docs'

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = 'avatar.png'
html_logo = 'logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'txtorcondoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'txtorcon.tex', u'txtorcon Documentation',
   u'meejah', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'txtorcon', u'txtorcon Documentation',
     [u'meejah'], 1)
]

########NEW FILE########
__FILENAME__ = attach_streams_by_country
#!/usr/bin/env python

##
## This uses a custom txtorcon.IStreamAttacher to force streams to use
## circuits that exit in the same country (as supplied by GeoIP) and
## builds such a circuit if one isn't available yet.
##
## Note that you can do something very similar to this with Tor's
## config file as well by setting something like:
##
## ExitNodes {us},{ca}
##
## ...in your torrc. The above just exits from those countries, not
## the one in which the Web server is located, however. So, this is a
## little redundant, but gives you the idea of how to do these sorts
## of things.
##
## Another thing to note is that the DNS lookup is a stream before the
## name is looked up, so the DNS lookup may occur from whatever stream
## Tor chose for that (we return None, which causes the attacher to
## tell Tor to attach that stream itself). This presents a problem for
## sites which optimize the server they deliver based on DNS -- if you
## lookup from X you'll get a server near/in X, which for our next
## step will make "the site" appear to be there.
##
## The only "solution" for this would be to do the lookup locally, but
## that defeats the purpose of Tor.
##

import random

from twisted.python import log
from twisted.internet import reactor, defer
from zope.interface import implements

import txtorcon


class MyStreamListener(txtorcon.StreamListenerMixin):

    def stream_new(self, stream):
        print "new stream:", stream.id, stream.target_host

    def stream_succeeded(self, stream):
        print "successful stream:", stream.id, stream.target_host

    def stream_attach(self, stream, circuit):
        print "stream", stream.id, " attached to circuit", circuit.id,
        print "with path:", '->'.join(map(lambda x: x.location.countrycode, circuit.path))


class MyAttacher(txtorcon.CircuitListenerMixin):
    implements(txtorcon.IStreamAttacher)

    def __init__(self, state):
        ## pointer to our TorState object
        self.state = state
        ## circuits for which we are awaiting completion so we can
        ## finish our attachment to them.
        self.waiting_circuits = []

    def waiting_on(self, circuit):
        for (circid, d, stream_cc) in self.waiting_circuits:
            if circuit.id == circid:
                return True
        return False

    def circuit_extend(self, circuit, router):
        "ICircuitListener"
        if circuit.purpose != 'GENERAL':
            return
        # only output for circuits we're waiting on
        if self.waiting_on(circuit):
            print "  circuit %d (%s). Path now %s" % (circuit.id, router.id_hex,
                                                      '->'.join(map(lambda x: x.location.countrycode,
                                                                    circuit.path)))

    def circuit_built(self, circuit):
        "ICircuitListener"
        if circuit.purpose != 'GENERAL':
            return

        print "circuit built", circuit.id, '->'.join(map(lambda r:
                                                         r.location.countrycode,
                                                         circuit.path))
        for (circid, d, stream_cc) in self.waiting_circuits:
            if circid == circuit.id:
                self.waiting_circuits.remove((circid, d, stream_cc))
                d.callback(circuit)

    def circuit_failed(self, circuit, kw):
        if self.waiting_on(circuit):
            print "A circuit we requested", circuit.id, "has failed. Reason:", kw['REASON']

            circid, d, stream_cc = None, None, None
            for x in self.waiting_circuits:
                if x[0] == circuit.id:
                    circid, d, stream_cc = x
            if d is None:
                raise Exception("Expected to find circuit.")

            self.waiting_circuits.remove((circid, d, stream_cc))
            print "Trying a new circuit build for", circid
            self.request_circuit_build(stream_cc, d)

    def attach_stream(self, stream, circuits):
        """
        IStreamAttacher API
        """
        if not stream.target_host in self.state.addrmap.addr:
            print "No AddrMap entry for", stream.target_host,
            print "so I don't know where it exits; get Tor to attach stream."
            return None

        ip = str(self.state.addrmap.addr[stream.target_host].ip)
        stream_cc = txtorcon.util.NetLocation(ip).countrycode
        print "Stream to", ip, "exiting in", stream_cc

        if stream_cc is None:
            ## returning None tells TorState to ask Tor to select a
            ## circuit instead
            print "   unknown country, Tor will assign stream"
            return None

        for circ in circuits.values():
            if circ.state != 'BUILT' or circ.purpose != 'GENERAL':
                continue

            circuit_cc = circ.path[-1].location.countrycode
            if circuit_cc is None:
                print "warning: don't know where circuit", circ.id, "exits"

            if circuit_cc == stream_cc:
                print "  found suitable circuit:", circ
                return circ

        ## if we get here, we haven't found a circuit that exits in
        ## the country GeoIP claims our target server is in, so we
        ## need to build one.
        print "Didn't find a circuit, building one"

        ## we need to return a Deferred which will callback with our
        ## circuit, however built_circuit only callbacks with the
        ## message from Tor saying it heard about our request. So when
        ## that happens, we push our real Deferred into the
        ## waiting_circuits list which will get pop'd at some point
        ## when the circuit_built() listener callback happens.

        d = defer.Deferred()
        self.request_circuit_build(stream_cc, d)
        return d

    def request_circuit_build(self, stream_cc, deferred_to_callback):
        ## for exits, we can select from any router that's in the
        ## correct country.
        last = filter(lambda x: x.location.countrycode == stream_cc,
                      self.state.routers.values())

        ## start with an entry guard, put anything in the middle and
        ## put one of our exits at the end.
        path = [random.choice(self.state.entry_guards.values()),
                random.choice(self.state.routers.values()),
                random.choice(last)]

        print "  requesting a circuit:", '->'.join(map(lambda r:
                                                       r.location.countrycode,
                                                       path))

        class AppendWaiting:
            def __init__(self, attacher, d, stream_cc):
                self.attacher = attacher
                self.d = d
                self.stream_cc = stream_cc

            def __call__(self, circ):
                """
                return from build_circuit is a Circuit. However, we
                want to wait until it is built before we can issue an
                attach on it and callback to the Deferred we issue
                here.
                """
                print "  my circuit is in progress", circ.id
                self.attacher.waiting_circuits.append((circ.id, self.d,
                                                       self.stream_cc))

        return self.state.build_circuit(path).addCallback(AppendWaiting(self, deferred_to_callback, stream_cc)).addErrback(log.err)


def do_setup(state):
    print "Connected to a Tor version", state.protocol.version

    attacher = MyAttacher(state)
    state.set_attacher(attacher, reactor)
    state.add_circuit_listener(attacher)

    state.add_stream_listener(MyStreamListener())

    print "Existing state when we connected:"
    print "Streams:"
    for s in state.streams.values():
        print ' ', s

    print
    print "General-purpose circuits:"
    for c in filter(lambda x: x.purpose == 'GENERAL', state.circuits.values()):
        print ' ', c.id, '->'.join(map(lambda x: x.location.countrycode,
                                       c.path))


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()

d = txtorcon.build_local_tor_connection(reactor)
d.addCallback(do_setup).addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = circuit_failure_rates
#!/usr/bin/env python

##
## This example uses ICircuitListener to monitor how many circuits have
## failed since the monitor started up. If this figure is more than 50%,
## a warning-level message is logged.
##
## Like the :ref:`stream_circuit_logger.py` example, we also log all new
## circuits.
##

import functools
import sys
import time
from twisted.internet import reactor, task
from twisted.python import usage
import txtorcon


class Options(usage.Options):
    """
    command-line options we understand
    """

    optParameters = [
        ['failed', 'f', 0, 'Starting value for number of failed circuits.', int],
        ['built', 'b', 0, 'Starting value for the total number of built cicuits.', int],
        ['connect', 'c', None, 'Tor control socket to connect to in host:port format, like "localhost:9051" (the default).'],
        ['delay', 'n', 60, 'Seconds to wait between status updates.', int]]

    def __init__(self):
        usage.Options.__init__(self)
        self['guards'] = []
        self.docs['guard'] = 'Specify the name, built and failed rates like "SomeTorNode,10,42". Can be specified multiple times.'

    def opt_guard(self, value):
        name, built, failed = value.split(',')
        self['guards'].append((name, int(built), int(failed)))


class CircuitFailureWatcher(txtorcon.CircuitListenerMixin):

    built_circuits = 0
    failed_circuits = 0
    percent = 0.0
    failed_circuit_ids = []
    per_guard_built = {}
    per_guard_failed = {}

    def print_update(self):
        print time.ctime(reactor.seconds()) + ': ' + self.information()

    def update_percent(self):
        self.percent = 100.0 * (float(self.failed_circuits) /
                                float(self.built_circuits +
                                      self.failed_circuits))
        if self.percent > 50.0:
            print 'WARNING: %02.1f percent of all routes have failed: %d failed, %d built' % (self.percent, self.failed_circuits, self.built_circuits)

    def information(self):
        rtn = '%02.1f%% of all circuits have failed: %d failed, %d built' % (self.percent, self.failed_circuits, self.built_circuits)
        for g in self.per_guard_built.keys():
            per_guard_percent = 100.0 * (self.per_guard_failed[g] /
                                         (self.per_guard_built[g] +
                                          self.per_guard_failed[g]))
            current = ' '
            for guard in self.state.entry_guards.values():
                if g == guard.name or g == guard.id_hex:
                    current = '*'
                    break
            rtn = rtn + '\n %s %s: %d built, %d failed: %02.1f%%' % (current, g, self.per_guard_built[g], self.per_guard_failed[g],
                                                                     per_guard_percent)
        return rtn

    def circuit_built(self, circuit):
        """ICircuitListener API"""
        # older tor versions will have empty build_flags
        if 'ONEHOP_TUNNEL' in circuit.build_flags:
            return

        if circuit.purpose == 'GENERAL':
            if len(circuit.path) > 0 and circuit.path[0] not in self.state.entry_guards.values():
                print "WEIRD: first circuit hop not in entry guards:", circuit, circuit.path, circuit.purpose
                return

            self.built_circuits += 1
            self.update_percent()

            if len(circuit.path) != 3 and len(circuit.path) != 4:
                print "WEIRD: circuit has odd pathlength:", circuit, circuit.path
            try:
                self.per_guard_built[circuit.path[0].unique_name] += 1.0
            except KeyError:
                self.per_guard_built[circuit.path[0].unique_name] = 1.0
                self.per_guard_failed[circuit.path[0].unique_name] = 0.0

    def circuit_failed(self, circuit, kw):
        """ICircuitListener API"""

        if kw['REASON'] != 'MEASUREMENT_EXPIRED':
            return

        # older tor versions will have empty build_flags
        if 'ONEHOP_TUNNEL' in circuit.build_flags:
            return

        if circuit.purpose == 'GENERAL':
            if len(circuit.path) > 1 and circuit.path[0] not in self.state.entry_guards.values():
                ## note that single-hop circuits are built for various
                ## internal reasons (and it seems they somtimes use
                ## GENERAL anyway)
                print "WEIRD: first circuit hop not in entry guards:", circuit, circuit.path
                return

            self.failed_circuits += 1
            print "failed", circuit.id
            if not circuit.id in self.failed_circuit_ids:
                self.failed_circuit_ids.append(circuit.id)
            else:
                print "WARNING: duplicate message for", circuit

            if len(circuit.path) > 0:
                try:
                    self.per_guard_failed[circuit.path[0].unique_name] += 1.0
                except KeyError:
                    self.per_guard_failed[circuit.path[0].unique_name] = 1.0
                    self.per_guard_built[circuit.path[0].unique_name] = 0.0

            self.update_percent()


def setup(options, listener, state):
    print 'Connected to a Tor version %s at %s' % (state.protocol.version,
                                                   state.protocol.transport.addr)
    listener.failed_circuits = int(options['failed'])
    listener.built_circuits = int(options['built'])
    listener.state = state  # FIXME use ctor (ditto for options, probably)
    for name, built, failed in options['guards']:
        listener.per_guard_built[name] = float(built)
        listener.per_guard_failed[name] = float(failed)

    for circ in filter(lambda x: x.purpose == 'GENERAL',
                       state.circuits.values()):
        if circ.state == 'BUILT':
            listener.circuit_built(circ)
    state.add_circuit_listener(listener)
    # print an update every minute
    task.LoopingCall(listener.print_update).start(options['delay'])


def setup_failed(arg):
    print "SETUP FAILED", arg
    print arg
    reactor.stop()


options = Options()
try:
    options.parseOptions(sys.argv[1:])
except usage.UsageError:
    print "This monitors circuit failure rates on multi-hop PURPOSE_GENERAL circuits only."
    print "Tor internally uses other circuit types or GENERAL single-hop circuits for"
    print "internal use and we try to ignore these."
    print
    print "Every minute, the summary is printed out. For each entry-guard your Tor is"
    print "currently using, a separate count and summary is printed."
    print
    print "Nothing is saved to disc. If you wish to start again with the same totals"
    print "as a previous run, use the options below. On exit, a command-line suitable"
    print "to do this is printed."
    print
    print options.getUsage()
    sys.exit(-1)


def on_shutdown(listener, *args):
    print '\nTo carry on where you left off, run:'
    print '  %s --failed %d --built %d' % (sys.argv[0],
                                           listener.failed_circuits,
                                           listener.built_circuits),
    for name in listener.per_guard_built.keys():
        print '--guard %s,%d,%d' % (name, listener.per_guard_built[name],
                                    listener.per_guard_failed[name]),
    print

listener = CircuitFailureWatcher()

reactor.addSystemEventTrigger('before', 'shutdown',
                              functools.partial(on_shutdown, listener))

if options['connect']:
    host, port = options['connect'].split(':')
    port = int(port)
    print 'Connecting to %s:%i...' % (host, port)
    d = txtorcon.build_local_tor_connection(reactor, host=host, port=port)
else:
    d = txtorcon.build_local_tor_connection(reactor)
d.addCallback(functools.partial(setup, options, listener))
d.addErrback(setup_failed)

reactor.run()

########NEW FILE########
__FILENAME__ = circuit_for_next_stream
#!/usr/bin/env python

##
## This allows you to create a particular circuit, which is then used
## for the very next (non-Tor-internal) stream created. The use-case
## here might be something like, "I'm going to connect a long-lived
## stream in a moment *cough*IRC*cough*, so I'd like a circuit through
## high-uptime nodes"
##

import sys
import functools
import random

from twisted.python import log
from twisted.internet import reactor
from zope.interface import implements

import txtorcon


class MyStreamListener(txtorcon.StreamListenerMixin):

    def stream_new(self, stream):
        print "new stream:", stream.id, stream.target_host

    def stream_succeeded(self, stream):
        print "successful stream:", stream.id, stream.target_host


class MyAttacher(txtorcon.CircuitListenerMixin, txtorcon.StreamListenerMixin):
    implements(txtorcon.IStreamAttacher)

    def __init__(self, state):
        self.state = state
        ## the circuit which we will use to attach the next stream to
        self.circuit = None

    def set_circuit(self, circuit):
        self.circuit = circuit

    def circuit_built(self, circuit):
        "ICircuitListener"

        if self.circuit is None:
            return

        if circuit != self.circuit:
            return

        print "Circuit built, awaiting next stream."

    def attach_stream(self, stream, circuits):
        """
        IStreamAttacher API
        """

        if self.circuit is not None:
            print "Attaching", stream, "to", self.circuit
            return self.circuit

        # let Tor connect this stream how it likes
        return None

    def stream_attach(self, stream, circuit):
        print "stream", stream.id, "attached to circuit", circuit.id,
        print "with path:", '->'.join(map(lambda x: x.location.countrycode, circuit.path))
        if self.circuit is circuit:
            print "...so we're done."
            reactor.stop()


def do_setup(path, state):
    print "Connected to a Tor version", state.protocol.version

    attacher = MyAttacher(state)
    state.set_attacher(attacher, reactor)
    state.add_circuit_listener(attacher)
    state.add_stream_listener(attacher)

    print "Existing state when we connected:"
    print "Streams:"
    for s in state.streams.values():
        print ' ', s

    print
    print "General-purpose circuits:"
    for c in filter(lambda x: x.purpose == 'GENERAL', state.circuits.values()):
        print ' ', c.id, '->'.join(map(lambda x: x.location.countrycode, c.path))

    print "Building our Circuit:", path
    real_path = []
    try:
        for name in path:
            print name
            if name == 'X':
                if len(real_path) == 0:
                    real_path.append(random.choice(state.entry_guards.values()))

                else:
                    real_path.append(random.choice(state.routers.values()))

            else:
                real_path.append(state.routers[name])

    except KeyError, e:
        print "Couldn't find router:", e
        sys.exit(1)

    print "...using routers:", real_path
    return state.build_circuit(real_path).addCallback(attacher.set_circuit).addErrback(log.err)


def setup_failed(arg):
    print "Setup Failed:", arg.getErrorMessage()
    reactor.stop()

if len(sys.argv) == 1:
    print "usage: %s router [router] [router] ..." % sys.argv[0]
    print
    print "       You may use X for a router name, in which case a random one will"
    print "       be selected (a random one of your entry guards if its in the first"
    print "       position)."
    sys.exit(1)

path = sys.argv[1:]

d = txtorcon.build_local_tor_connection(reactor)
d.addCallback(functools.partial(do_setup, path)).addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = disallow_streams_by_port
#!/usr/bin/env python

##
## This uses a very simple custom txtorcon.IStreamAttacher to disallow
## certain streams based solely on their port; by default it closes
## all streams on port 80 or 25 without ever attaching them to a
## circuit.
##
## For a more complex IStreamAttacher example, see
## attach_streams_by_country.py
##

from twisted.python import log
from twisted.internet import reactor
from zope.interface import implements

import txtorcon


def stream_closed(x):
    print "Stream closed:", x


class PortFilterAttacher:
    implements(txtorcon.IStreamAttacher)

    def __init__(self, state):
        self.state = state
        self.disallow_ports = [80, 25]
        print "Disallowing all streams to ports:",
        print ",".join(map(str, self.disallow_ports))

    def attach_stream(self, stream, circuits):
        """
        IStreamAttacher API
        """
        if stream.target_port in self.disallow_ports:
            print "Disallowing", stream, "to port", stream.target_port
            self.state.close_stream(stream).addCallback(stream_closed).addErrback(log.err)
            return txtorcon.TorState.DO_NOT_ATTACH

        # Ask Tor to assign stream to a circuit by itself
        return None


def do_setup(state):
    print "Connected to a Tor version", state.protocol.version

    state.set_attacher(PortFilterAttacher(), reactor)

    print "Existing streams:"
    for s in state.streams.values():
        print ' ', s


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


d = txtorcon.build_local_tor_connection(reactor)
d.addCallback(do_setup).addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = dump_config
#!/usr/bin/env python

##
## Simple usage example of TorConfig
##

import sys
import types
from twisted.internet import reactor
from txtorcon import build_local_tor_connection, TorConfig, DEFAULT_VALUE


def setup_complete(config):
    print "Got config"
    keys = config.config.keys()
    keys.sort()
    defaults = []
    for k in keys:
        if k == 'HiddenServices':
            for hs in config.config[k]:
                for xx in ['dir', 'version', 'authorize_client']:
                    if getattr(hs, xx):
                        print 'HiddenService%s %s' % (xx.capitalize(),
                                                      getattr(hs, xx))
                for port in hs.ports:
                    print 'HiddenServicePort', port
            continue

        v = getattr(config, k)
        if isinstance(v, types.ListType):
            for val in v:
                if val != DEFAULT_VALUE:
                    print k, val

        elif v == DEFAULT_VALUE:
            defaults.append(k)

        else:
            print k, v

    if 'defaults' in sys.argv:
        print "Set to default value:"
        for k in defaults:
            print "# %s" % k

    reactor.stop()


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


def bootstrap(c):
    conf = TorConfig(c)
    conf.post_bootstrap.addCallback(setup_complete).addErrback(setup_failed)
    print "Connection is live, bootstrapping state..."


d = build_local_tor_connection(reactor, build_state=False,
                               wait_for_proto=False)
# do not use addCallbacks() here, in case bootstrap has an error
d.addCallback(bootstrap).addErrback(setup_failed)

reactor.run()

########NEW FILE########
__FILENAME__ = launch_tor
#!/usr/bin/env python

##
## Launch a slave Tor by first making a TorConfig object.
##

import functools
from twisted.internet import reactor
import txtorcon


def finished(answer):
    print "Answer:", answer
    print "We could now do any sort of exciting thing we wanted..."
    print "...but instead, we'll just exit."
    reactor.stop()


def query_changed_config(answer, state):
    # now we'll ask for the ORPort back to prove it changed
    state.protocol.get_conf("ORPort").addCallback(finished)


def state_complete(config, state):
    print "We've completely booted up a TorState to a Tor version %s at PID %d" % (state.protocol.version, state.tor_pid)

    print "This Tor has the following %d Circuits:" % len(state.circuits)
    for c in state.circuits.values():
        print c

    config.SOCKSPort = 0
    config.ORPort = 9089
    # "save" may be poorly-named API; it serializes the options to the
    # running Tor (via SETCONF calls)
    config.save().addCallback(query_changed_config, state)


def setup_complete(config, proto):
    print "setup complete:", proto
    print "Building a TorState"
    state = txtorcon.TorState(proto.tor_protocol)
    # Pass the config object yet again, avoiding global state
    state.post_bootstrap.addCallback(functools.partial(state_complete, config))
    state.post_bootstrap.addErrback(setup_failed)


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


def updates(prog, tag, summary):
    print "%d%%: %s" % (prog, summary)


config = txtorcon.TorConfig()
config.OrPort = 1234
config.SocksPort = 9999


# Launch tor. The config-object is passed by the closure around
# setup_complete()
d = txtorcon.launch_tor(config, reactor, progress_updates=updates)
d.addCallback(functools.partial(setup_complete, config))
d.addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = launch_tor_endpoint
#!/usr/bin/env python

##
## Here we set up a Twisted Web server and then launch a slave tor
## with a configured hidden service directed at the Web server we set
## up. This uses TCPHiddenServiceEndpoint, which gives you slightly
## less control over how things are set up, but may be easier. See
## also the :ref:`launch_tor.py` example.
##


from twisted.internet import reactor
from twisted.web import server, resource
import txtorcon


class Simple(resource.Resource):
    isLeaf = True

    def render_GET(self, request):
        return "<html>Hello, world! I'm a hidden service!</html>"

site = server.Site(Simple())


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


def setup_complete(port):
    print "I have set up a hidden service, advertised at:"
    print "http://%s:%d" % (port.onion_uri, port.onion_port)
    print "locally listening on", port.getHost()


def setup_hidden_service(tor_process_protocol):
    config = txtorcon.TorConfig(tor_process_protocol.tor_protocol)
    public_port = 80
    hs_endpoint = txtorcon.TCPHiddenServiceEndpoint(reactor, config,
                                                    public_port)

    ## the important thing here is that "site" implements
    ## IProtocolFactory -- this could be any service at all,
    ## obviously.
    hs_endpoint.listen(site).addCallback(setup_complete).addErrback(setup_failed)


def updates(prog, tag, summary):
    print "%d%%: %s" % (prog, summary)

# set a couple options to avoid conflict with the defaults if a Tor is
# already running
config = txtorcon.TorConfig()
config.SOCKSPort = 0
config.ControlPort = 9089

d = txtorcon.launch_tor(config, reactor, progress_updates=updates, timeout=60)
d.addCallback(setup_hidden_service)
d.addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = launch_tor_with_hiddenservice
#!/usr/bin/env python

##
## Here we set up a Twisted Web server and then launch a slave tor
## with a configured hidden service directed at the Web server we set
## up.
##

import tempfile
import functools

from twisted.internet import reactor
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.web import server, resource

import txtorcon


class Simple(resource.Resource):
    isLeaf = True

    def render_GET(self, request):
        return "<html>Hello, world! I'm a hidden service!</html>"


def updates(prog, tag, summary):
    print "%d%%: %s" % (prog, summary)


def setup_complete(config, proto):
    print "Protocol completed"

    onion_address = config.HiddenServices[0].hostname

    print "I have a hidden (web) service running at:"
    print "http://%s (port %d)" % (onion_address, hs_public_port)
    print "The temporary directory for it is at:", config.HiddenServices[0].dir
    print
    print "For example, you should be able to visit it via:"
    print "  torsocks lynx http://%s" % onion_address


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()

hs_port = 9876
hs_public_port = 80
hs_temp = tempfile.mkdtemp(prefix='torhiddenservice')

## register something to clean up our tempdir
reactor.addSystemEventTrigger('before', 'shutdown',
                              functools.partial(txtorcon.util.delete_file_or_tree,
                                                hs_temp))

## configure the hidden service we want.
## obviously, we'd want a more-persistent place to keep the hidden
## service directory for a "real" setup. If the directory is empty at
## startup as here, Tor creates new keys etcetera (which IS the .onion
## address). That is, every time you run this script you get a new
## hidden service URI, which is probably not what you want.
## The launch_tor method adds other needed config directives to give
## us a minimal config.
config = txtorcon.TorConfig()
config.SOCKSPort = 0
config.ORPort = 9089
config.HiddenServices = [txtorcon.HiddenService(config, hs_temp, [str(hs_public_port) + " 127.0.0.1:" + str(hs_port)])]
config.save()

## next we set up our service to listen on hs_port which is forwarded
## (via the HiddenService options) from the hidden service address on
## port hs_public_port
site = server.Site(Simple())
hs_endpoint = TCP4ServerEndpoint(reactor, hs_port, interface='127.0.0.1')
hs_endpoint.listen(site)

## we've got our Twisted service listening locally and our options
## ready to go, so we now launch Tor. Once it's done (see above
## callbacks) we print out the .onion URI and then do "nothing"
## (i.e. let the Web server do its thing). Note that the way we've set
## up the slave Tor process, when we close the connection to it tor
## will exit.

d = txtorcon.launch_tor(config, reactor, progress_updates=updates)
d.addCallback(functools.partial(setup_complete, config))
d.addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = launch_tor_with_simplehttpd
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''Create a new tor node and add a simple http server to it, serving a given
directory over http. The server is single-threaded and very limited.

There are two arguments that can be passed via the commandline:
    -p\tThe internet-facing port the hidden service should listen on
    -d\tThe directory to serve via http

Example:
    ./launch_tor_with_simplehttpd.py -p 8080 -d /opt/files/
'''

import SimpleHTTPServer
import SocketServer
import functools
import getopt
import os
import sys
import tempfile
import thread

from twisted.internet import reactor

import txtorcon


def print_help():
    print __doc__


def print_tor_updates(prog, tag, summary):
    # Prints some status messages while booting tor
    print 'Tor booting [%d%%]: %s' % (prog, summary)


def start_httpd(httpd):
    # Create a new thread to serve requests
    print 'Starting httpd...'
    return thread.start_new_thread(httpd.serve_forever, ())


def stop_httpd(httpd):
    # Kill the httpd
    print 'Stopping httpd...'
    httpd.shutdown()


def setup_complete(config, port, proto):
    # Callback from twisted when tor has booted.
    # We create a reference to this function via functools.partial that
    # provides us with a reference to 'config' and 'port', twisted then adds
    # the 'proto' argument
    print '\nTor is now running. The hidden service is available at'
    print '\n\thttp://%s:%i\n' % (config.HiddenServices[0].hostname, port)
    # This is probably more secure than any other httpd...
    print '### DO NOT RELY ON THIS SERVER TO TRANSFER FILES IN A SECURE WAY ###'


def setup_failed(arg):
    # Callback from twisted if tor could not boot. Nothing to see here, move
    # along.
    print 'Failed to launch tor', arg
    reactor.stop()


def main():
    # Parse the commandline-options
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hd:p:')
    except getopt.GetoptError as excp:
        print str(excp)
        print_help()
        return 1

    serve_directory = '.'  # The default directory to serve files from
    hs_public_port = 8011  # The default port the hidden service is available on
    web_port = 4711  # The real server's local port
    web_host = '127.0.0.1'  # The real server is bound to localhost
    for o, a in opts:
        if o == '-d':
            serve_directory = a
        elif o == '-p':
            hs_public_port = int(a)
        elif o == '-h':
            print_help()
            return
        else:
            print 'Unknown option "%s"' % (o, )
            return 1

    # Sanitize path and set working directory there (for SimpleHTTPServer)
    serve_directory = os.path.abspath(serve_directory)
    if not os.path.exists(serve_directory):
        print 'Path "%s" does not exists, can\'t serve from there...' % \
            (serve_directory, )
        return 1
    os.chdir(serve_directory)

    # Create a new SimpleHTTPServer and serve it from another thread.
    # We create a callback to Twisted to shut it down when we exit.
    print 'Serving "%s" on %s:%i' % (serve_directory, web_host, web_port)
    httpd = SocketServer.TCPServer((web_host, web_port),
                                   SimpleHTTPServer.SimpleHTTPRequestHandler)
    start_httpd(httpd)
    reactor.addSystemEventTrigger('before', 'shutdown', stop_httpd, httpd=httpd)

    # Create a directory to hold our hidden service. Twisted will unlink it
    # when we exit.
    hs_temp = tempfile.mkdtemp(prefix='torhiddenservice')
    reactor.addSystemEventTrigger('before', 'shutdown',
                                  functools.partial(txtorcon.util.delete_file_or_tree, hs_temp))

    # Add the hidden service to a blank configuration
    config = txtorcon.TorConfig()
    config.SOCKSPort = 0
    config.ORPort = 9089
    config.HiddenServices = [txtorcon.HiddenService(config, hs_temp,
                                                    ['%i %s:%i' % (hs_public_port,
                                                                   web_host,
                                                                   web_port)])]
    config.save()

    # Now launch tor
    # Notice that we use a partial function as a callback so we have a
    # reference to the config object when tor is fully running.
    tordeferred = txtorcon.launch_tor(config, reactor,
                                      progress_updates=print_tor_updates)
    tordeferred.addCallback(functools.partial(setup_complete, config,
                                              hs_public_port))
    tordeferred.addErrback(setup_failed)

    reactor.run()


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = monitor
#!/usr/bin/env python

##
## Just listens for a few EVENTs from Tor (INFO NOTICE WARN ERR) and
## prints out the contents, so functions like a log monitor.
##

from twisted.internet import reactor
import txtorcon


def log(msg):
    print msg


def setup(proto):
    print "Connected to a Tor version", proto.version
    for event in ['INFO', 'NOTICE', 'WARN', 'ERR']:
        proto.add_event_listener(event, log)
    proto.get_info('status/version/current', 'version').addCallback(log)


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()

d = txtorcon.build_local_tor_connection(reactor, build_state=False)
d.addCallback(setup).addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = schedule_bandwidth
#!/usr/bin/env python

##
## Here, we do something possible-useful and schedule changes to the
## "BandWidthRate" and optionally "BandWidthBurst" settings in Tor.
##

import datetime
from twisted.internet import reactor
from twisted.internet.interfaces import IReactorTime
from txtorcon import build_local_tor_connection, TorConfig


class BandwidthUpdater:

    def __init__(self, config, scheduler):
        self.bandwidth = 0
        self.config = config
        self.scheduler = IReactorTime(scheduler)
        self.generator = self.next_update()

    def next_update(self):
        """
        Generator that gives out the next time to do a bandwidth update,
        as well as what the new bandwidth value should be. Here, we toggle
        the bandwidth every 20 minutes.
        """

        while True:
            if self.bandwidth:
                self.bandwidth = 0
                self.burst = 0
            else:
                self.bandwidth = 20 * 1024 * 1024
                self.burst = self.bandwidth
            yield (datetime.datetime.now() + datetime.timedelta(minutes=20),
                   self.bandwidth, self.burst)

    def do_update(self):
        x = self.generator.next()
        future = x[0]
        self.new_bandwidth = x[1]
        self.new_burst = x[2]

        tm = (future - datetime.datetime.now()).seconds
        self.scheduler.callLater(tm, self.really_update)
        print "waiting", tm, "seconds to adjust bandwidth"

    def really_update(self):
        print "setting bandwidth + burst to", self.new_bandwidth, self.new_burst
        self.config.set_config('BandWidthBurst', self.new_burst,
                               'BandWidthRate', self.new_bandwidth)
        self.doUpdate()


def setup_complete(conf):
    print "Connected."
    bwup = BandwidthUpdater(conf, reactor)
    bwup.do_update()


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


def bootstrap(proto):
    config = TorConfig(proto)
    config.post_bootstrap.addCallback(setup_complete).addErrback(setup_failed)
    print "Connection is live, bootstrapping config..."


d = build_local_tor_connection(reactor, build_state=False,
                               wait_for_proto=False)
d.addCallback(bootstrap).addErrback(setup_failed)

reactor.run()

########NEW FILE########
__FILENAME__ = stream_circuit_logger
#!/usr/bin/env python

##
## This uses an IStreamListener and an ICircuitListener to log all
## built circuits and all streams that succeed.
##

import sys
from twisted.python import log
from twisted.internet import reactor
import txtorcon


def logCircuit(circuit):
    path = '->'.join(map(lambda x: str(x.location.countrycode), circuit.path))
    log.msg('Circuit %d (%s) is %s for purpose "%s"' % (circuit.id, path, circuit.state, circuit.purpose))


def logStream(stream, state):
    circ = ''
    if stream.circuit:
        circ = ' via circuit %d (%s)' % (stream.circuit.id, '->'.join(map(lambda x: x.location.countrycode, stream.circuit.path)))
    proc = txtorcon.util.process_from_address(stream.source_addr, stream.source_port, state)
    if proc:
        proc = ' from process "%s"' % (proc, )

    elif stream.source_addr == '(Tor_internal)':
        proc = ' for Tor internal use'

    else:
        proc = ' from remote "%s:%s"' % (str(stream.source_addr), str(stream.source_port))
    log.msg('Stream %d to %s:%d attached%s%s' % (stream.id, stream.target_host, stream.target_port, circ, proc))


class StreamCircuitLogger(txtorcon.StreamListenerMixin, txtorcon.CircuitListenerMixin):

    def __init__(self, state):
        self.state = state

    def stream_attach(self, stream, circuit):
        logStream(stream, self.state)

    def stream_failed(self, stream, reason='', remote_reason='', **kw):
        print 'Stream %d failed because "%s"' % (stream.id, remote_reason)

    def circuit_built(self, circuit):
        logCircuit(circuit)

    def circuit_failed(self, circuit, **kw):
        log.msg('Circuit %d failed "%s"' % (circuit.id, kw['REASON']))


def setup(state):
    log.msg('Connected to a Tor version %s' % state.protocol.version)

    listener = StreamCircuitLogger(state)
    state.add_circuit_listener(listener)
    state.add_stream_listener(listener)

    state.protocol.add_event_listener('STATUS_GENERAL', log.msg)
    state.protocol.add_event_listener('STATUS_SERVER', log.msg)
    state.protocol.add_event_listener('STATUS_CLIENT', log.msg)

    log.msg('Existing state when we connected:')
    for s in state.streams.values():
        logStream(s, state)

    log.msg('Existing circuits:')
    for c in state.circuits.values():
        logCircuit(c)


def setup_failed(arg):
    print "SETUP FAILED", arg
    log.err(arg)
    reactor.stop()


log.startLogging(sys.stdout)

d = txtorcon.build_local_tor_connection(reactor)
d.addCallback(setup).addErrback(setup_failed)
reactor.run()

########NEW FILE########
__FILENAME__ = tor_info
#!/usr/bin/env python

##
## Simple usage example of TorInfo. This class does some magic so that
## once it's set up, all the attributes it has (or appears to) are
## GETINFO ones, in a heirarchy. So where GETINFO specifies
## "net/listeners/dns" TorInfo will have a "net" attribute that
## contains at least "listeners", etcetera. The leaves are all methods
## which return a Deferred. If the corresponding GETINFO takes an
## argument, so does the leaf.
##
## Go straight to "setup_complete" for the goods -- this is called
## after TorInfo and the underlying TorControlProtocol are set up.
##
## If you want to issue multiple GETINFO calls in one network
## transaction, you'll have to use TorControlProtocol's get_info
## instead.
##

import sys
from twisted.internet import reactor, defer
from txtorcon import TorInfo, build_local_tor_connection


def error(x):
    print "ERROR", x
    return x


@defer.inlineCallbacks
def recursive_dump(indent, obj, depth=0):
    if callable(obj):
        try:
            print "%s: " % obj,
            sys.stdout.flush()
            if obj.takes_arg:
                v = yield obj('arrrrrg')
            v = yield obj()
            v = v.replace('\n', '\\')
            if len(v) > 60:
                v = v[:50] + '...' + v[-7:]
        except Exception, e:
            v = 'ERROR: ' + str(e)
        print v

    else:
        indent = indent + '  '
        for x in obj:
            yield recursive_dump(indent, x, depth + 1)


@defer.inlineCallbacks
def setup_complete(info):
    print "Top-Level Things:", dir(info)

    if True:
        ## some examples of getting specific GETINFO callbacks
        v = yield info.version()
        ip = yield info.ip_to_country('1.2.3.4')
        boot_phase = yield info.status.bootstrap_phase()
        ns = yield info.ns.name('moria1')
        guards = yield info.entry_guards()

        print 'version:', v
        print '1.2.3.4 is in', ip
        print 'bootstrap-phase:', boot_phase
        print 'moria1:', ns
        print 'entry guards:', guards

    ## now we dump everything, one at a time
    d = recursive_dump('', info)
    d.addCallback(lambda x: reactor.stop())
    d.addErrback(error)


def setup_failed(arg):
    print "SETUP FAILED", arg
    reactor.stop()


def bootstrap(c):
    info = TorInfo(c)
    info.post_bootstrap.addCallback(setup_complete).addErrback(setup_failed)


d = build_local_tor_connection(reactor, build_state=False)
# do not use addCallbacks() here, in case bootstrap has an error
d.addCallback(bootstrap).addErrback(setup_failed)

reactor.run()

########NEW FILE########
__FILENAME__ = webui_server
#!/usr/bin/env python

from twisted.internet import reactor
from nevow.appserver import NevowSite
from nevow import loaders, tags, livepage
import txtorcon


def setup_failed(fail):
    print "It went sideways!", fail
    return fail


class TorPage(livepage.LivePage):
    # override for Nevow/twisted.web
    addSlash = True

    # defaults for this class
    continuous_update = True
    ctx = None
    torstate = None

    ## Could be done with XHTML 1.0, or a "real" templating language
    docFactory = loaders.stan(
        tags.html[
            tags.head[
                tags.directive('liveglue')],
            tags.body[
                tags.h1["Tor Launching..."],
                ## obviously you might want a javascript library or
                ## something here instead of this hackery...
                tags.div(id='progress', style='position:abso lute; left:20em; top:10px; width:300px; height:50px; border:2px solid black;background-color:#ffaaaa;')[
                    tags.div(id='progress_done', style='position:absolute; top:0px; left:0px; width:0%; height: 100%; background-color:#aaffaa;')],

                ## this is where the messages will go
                tags.div(id='status', style='padding:5px; background-color:#ffaaaa; text-indent:2em; width: 50em; font-weight:bold; border: 2px solid black;')[""]]])

    def goingLive(self, ctx, client):
        '''
        Overrides nevow method; not really safe to just save ctx,
        client in self for multiple clients, but nice and simple.
        '''

        self.ctx = ctx
        self.client = client

    def set_tor_state(self, state):
        self.tor_state = state

    def tor_update(self, percent, tag, summary):
        if self.ctx is None:
            print "I have no Web client yet, but got a Tor update:", percent, tag, summary
            return

        point = int(300 * (float(percent) / 100.0))
        self.client.send(livepage.js('''document.getElementById('progress_done').style.width = "%dpx";''' % point))

        if percent == 100:
            ## done, turn message box green too
            self.client.send(livepage.js('''document.getElementById("status").style.backgroundColor="#aaffaa";'''))

        if self.continuous_update:
            ## add a text node for each update, creating a continuous list
            self.client.send(livepage.js('''var newNode = document.createElement('div');
newNode.appendChild(document.createTextNode("%d%% -- %s"));
document.getElementById('status').appendChild(newNode);''' % (percent, summary)))

        else:
            self.client.send(livepage.set('status', "%d%% &mdash; %s" % (percent, summary)))


## This only properly works with one client (the last one to load the
## page). To work with multiples, we'd have to track all clients so
## sending async updates to them worked properly.
top_level = TorPage()

## minimal Tor configuration
config = txtorcon.TorConfig()
config.OrPort = 1234
config.SocksPort = 9999

## launch a Tor based on the above config; the callback will trigger
## when the TorControlProtocol and TorState instances are up and
## running (i.e. Tor process is launched, and we connected to it via
## control protocol and bootstrapped our notion of its state).
d = txtorcon.launch_tor(config, reactor, progress_updates=top_level.tor_update)
d.addCallback(top_level.set_tor_state)
d.addErrback(setup_failed)

print "Launching Tor and providing a Web interface on: \nhttp://localhost:8080\n"

## Start up the Web server
site = NevowSite(top_level)
reactor.listenTCP(8080, site)
reactor.run()

########NEW FILE########
__FILENAME__ = run
#!/usr/bin/env python

## this runs all the integration tests under here, exiting right away
## if any one does.
## FIXME can't I [ab]use trial or unittest for this??

import os
import sys
import subprocess

base_path = os.path.split(os.path.realpath(sys.argv[0]))[0]
print "PATH", base_path

for d in os.listdir(base_path):
    path = os.path.join(base_path, d, 'host_run')
    if os.path.exists(path):
        print
        print "Running Test:", d
        print path
        print
        ret = subprocess.check_call([path])
        if ret:
            print
            print "Test FAILED"
            sys.exit(ret)
        print
        print "Test successful."
        print
sys.exit(0)

########NEW FILE########
__FILENAME__ = test_addrmap
import datetime
from twisted.trial import unittest
from twisted.internet import task
from twisted.internet.interfaces import IReactorTime
from zope.interface import implements

from txtorcon.addrmap import AddrMap
from txtorcon.interface import IAddrListener


class AddrMapTests(unittest.TestCase):
    implements(IAddrListener)

    fmt = '%Y-%m-%d %H:%M:%S'

    def test_parse(self):
        """
        Make sure it's parsing things properly.
        """

        now = datetime.datetime.now() + datetime.timedelta(seconds=10)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=10)
        ## we need to not-barf on extra args as per control-spec.txt
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s" FOO=bar BAR=baz' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))
        am = AddrMap()
        am.update(line)
        addr = am.find('www.example.com')

        self.assertTrue(addr.ip == '72.30.2.43' or addr.ip.exploded == '72.30.2.43')
        ## maybe not the most robust, should convert to
        ## seconds-since-epoch instead? the net result of the parsing
        ## is we've rounded to seconds...
        self.assertEqual(addr.expires.ctime(), nowutc.ctime())

        line = 'www.example.com 72.30.2.43 "%s" "%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))
        am.update(line)
        self.assertEqual(addr.expires.ctime(), nowutc.ctime())

        ## this will have resulted in an expiry call, which we need to
        ## cancel to keep the reactor clean. for consistency, we use
        ## the IReactorTime interface from AddrMap
        am.scheduler.getDelayedCalls()[0].cancel()

    def test_expires(self):
        """
        Test simply expiry case
        """

        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        now = datetime.datetime.now() + datetime.timedelta(seconds=10)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=10)
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))

        am.update(line)

        self.assertTrue('www.example.com' in am.addr)
        ## advance time past when the expiry should have occurred
        clock.advance(10)
        self.assertTrue('www.example.com' not in am.addr)

    def test_expires_never(self):
        """
        Test a NEVER expires line, as in what we'd get a startup for a
        configured address-mapping.
        """

        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        line = 'www.example.com 72.30.2.43 "NEVER"'
        am.update(line)

        self.assertTrue('www.example.com' in am.addr)
        self.assertEqual(len(clock.getDelayedCalls()), 0)

    def test_expires_old(self):
        """
        Test something that expires before "now"
        """

        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        now = datetime.datetime.now() + datetime.timedelta(seconds=-10)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=-10)
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))

        am.update(line)
        self.assertTrue('www.example.com' in am.addr)
        ## arguably we shouldn't even have put this in the map maybe,
        ## but the reactor needs to iterate before our expiry callback
        ## gets called (right away) which is simulated by the
        ## clock.advance call
        clock.advance(0)
        self.assertTrue('www.example.com' not in am.addr)

    def test_expires_with_update(self):
        """
        This test updates the expiry time and checks that we properly
        delay our expiry callback.
        """
        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        ## now do an actual update to an existing Addr entry.
        now = datetime.datetime.now() + datetime.timedelta(seconds=10)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=10)
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))
        am.update(line)
        self.assertTrue(am.find('www.example.com'))

        ## the update
        now = datetime.datetime.now() + datetime.timedelta(seconds=20)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=20)
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))
        am.update(line)
        self.assertTrue('www.example.com' in am.addr)

        ## advance time by the old expiry value and we should still
        ## find the entry
        clock.advance(10)
        self.assertTrue('www.example.com' in am.addr)

        ## ...but advance past the new expiry (another 10 seconds) and
        ## it should vanish
        clock.advance(10)
        self.assertTrue('www.example.com' not in am.addr)

    def test_8596_cached_1(self):
        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        line = 'example.com 192.0.2.1 NEVER CACHED="YES"'
        am.update(line)

        self.assertTrue('example.com' in am.addr)
        self.assertEqual(len(clock.getDelayedCalls()), 0)

    def test_8596_cached_2(self):
        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        line = 'example.com 192.0.43.10 "2013-04-03 22:29:11" EXPIRES="2013-04-03 20:29:11" CACHED="NO"'
        am.update(line)

        self.assertTrue('example.com' in am.addr)
        self.assertEqual(len(clock.getDelayedCalls()), 1)

    def test_8596_cached_3(self):
        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)

        line = 'example.invalid <error> "2013-04-03 08:28:52" error=yes EXPIRES="2013-04-03 06:28:52" CACHE="NO"'
        am.update(line)

        self.assertTrue('example.invalid' not in am.addr)
        self.assertEqual(len(clock.getDelayedCalls()), 0)

    def addrmap_expired(self, name):
        self.expires.append(name)

    def addrmap_added(self, addr):
        self.addrmap.append(addr)

    def test_listeners(self):
        self.expires = []
        self.addrmap = []

        clock = task.Clock()
        am = AddrMap()
        am.scheduler = IReactorTime(clock)
        am.add_listener(self)

        now = datetime.datetime.now() + datetime.timedelta(seconds=10)
        nowutc = datetime.datetime.utcnow() + datetime.timedelta(seconds=10)
        line = 'www.example.com 72.30.2.43 "%s" EXPIRES="%s"' % (now.strftime(self.fmt), nowutc.strftime(self.fmt))

        am.update(line)

        ## see if our listener got an update
        a = am.find('www.example.com')
        self.assertEqual(self.addrmap, [a])

        ## advance time past when the expiry should have occurred
        clock.advance(10)

        ## check that our listener got an expires event
        self.assertEqual(self.expires, ['www.example.com'])

########NEW FILE########
__FILENAME__ = test_circuit
import datetime
import time
from twisted.trial import unittest
from twisted.internet import defer
from zope.interface import implements

from txtorcon import Circuit, Stream, TorControlProtocol, TorState
from txtorcon.interface import IRouterContainer, ICircuitListener, ICircuitContainer, CircuitListenerMixin


class FakeTorController(object):
    implements(IRouterContainer, ICircuitListener, ICircuitContainer)

    def __init__(self):
        self.routers = {}
        self.circuits = {}
        self.extend = []
        self.failed = []

    def router_from_id(self, i):
        return self.routers[i[:41]]

    def circuit_new(self, circuit):
        self.circuits[circuit.id] = circuit

    def circuit_extend(self, circuit, router):
        self.extend.append((circuit, router))

    def circuit_launched(self, circuit):
        pass

    def circuit_built(self, circuit):
        pass

    def circuit_closed(self, circuit, **kw):
        if circuit.id in self.circuits:
            del self.circuits[circuit.id]

    def circuit_failed(self, circuit, **kw):
        self.failed.append((circuit, kw))
        if circuit.id in self.circuits:
            del self.circuits[circuit.id]

    def find_circuit(self, circid):
        return self.circuits[circid]

    def close_circuit(self, circid):
        del self.circuits[circid]
        return defer.succeed('')


class FakeLocation:

    def __init__(self):
        self.countrycode = 'NA'


class FakeRouter:

    def __init__(self, hsh, nm):
        self.name = nm
        self.hash = hsh
        self.location = FakeLocation()

examples = ['CIRC 365 LAUNCHED PURPOSE=GENERAL',
            'CIRC 365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris PURPOSE=GENERAL',
            'CIRC 365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus PURPOSE=GENERAL',
            'CIRC 365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL',
            'CIRC 365 BUILT $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL',
            'CIRC 365 CLOSED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=FINISHED',
            'CIRC 365 FAILED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=TIMEOUT']


class CircuitTests(unittest.TestCase):

    def test_age(self):
        """
        make sure age does something sensible at least once.
        """
        tor = FakeTorController()

        circuit = Circuit(tor)
        now = datetime.datetime.now()
        update = '1 LAUNCHED PURPOSE=GENERAL TIME_CREATED=%s' % time.strftime('%Y-%m-%dT%H:%M:%S')
        circuit.update(update.split())
        diff = circuit.age(now=now)
        self.assertEquals(diff, 0)
        self.assertTrue(circuit.time_created is not None)

    def test_no_age_yet(self):
        """
        make sure age doesn't explode if there's no TIME_CREATED flag.
        """
        tor = FakeTorController()

        circuit = Circuit(tor)
        now = datetime.datetime.now()
        circuit.update('1 LAUNCHED PURPOSE=GENERAL'.split())
        self.assertTrue(circuit.time_created is None)
        diff = circuit.age(now=now)
        self.assertEquals(diff, None)

    def test_listener_mixin(self):
        listener = CircuitListenerMixin()
        from zope.interface.verify import verifyObject
        self.assertTrue(verifyObject(ICircuitListener, listener))

        ## call all the methods with None for each arg. This is mostly
        ## just to gratuitously increase test coverage, but also
        ## serves to ensure these methods don't just blow up
        for (methodname, desc) in ICircuitListener.namesAndDescriptions():
            method = getattr(listener, methodname)
            args = [None] * len(desc.positional)
            method(*args)

    def test_unlisten(self):
        tor = FakeTorController()
        tor.routers['$E11D2B2269CC25E67CA6C9FB5843497539A74FD0'] = FakeRouter('$E11D2B2269CC25E67CA6C9FB5843497539A74FD0', 'a')

        circuit = Circuit(tor)
        circuit.listen(tor)
        circuit.update('1 LAUNCHED PURPOSE=GENERAL'.split())
        circuit.unlisten(tor)
        circuit.update('1 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris PURPOSE=GENERAL'.split())
        self.assertEqual(len(tor.circuits), 1)
        self.assertTrue(1 in tor.circuits)
        self.assertEqual(len(tor.extend), 0)
        self.assertEqual(1, len(circuit.path))

    def test_path_update(self):
        cp = TorControlProtocol()
        state = TorState(cp, False)
        circuit = Circuit(state)
        circuit.update('1 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris PURPOSE=GENERAL'.split())
        self.assertEqual(1, len(circuit.path))
        self.assertEqual('$E11D2B2269CC25E67CA6C9FB5843497539A74FD0', circuit.path[0].id_hex)
        self.assertEqual('eris', circuit.path[0].name)

    def test_wrong_update(self):
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.listen(tor)
        circuit.update('1 LAUNCHED PURPOSE=GENERAL'.split())
        self.assertRaises(Exception, circuit.update, '2 LAUNCHED PURPOSE=GENERAL'.split())

    def test_closed_remaining_streams(self):
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.listen(tor)
        circuit.update('1 LAUNCHED PURPOSE=GENERAL'.split())
        stream = Stream(tor)
        stream.update("1 NEW 0 94.23.164.42.$43ED8310EB968746970896E8835C2F1991E50B69.exit:9001 SOURCE_ADDR=(Tor_internal):0 PURPOSE=DIR_FETCH".split())
        circuit.streams.append(stream)
        self.assertEqual(len(circuit.streams), 1)

        circuit.update('1 CLOSED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=FINISHED'.split())
        circuit.update('1 FAILED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=TIMEOUT'.split())
        errs = self.flushLoggedErrors()
        self.assertEqual(len(errs), 2)

    def test_updates(self):
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.listen(tor)
        tor.routers['$E11D2B2269CC25E67CA6C9FB5843497539A74FD0'] = FakeRouter('$E11D2B2269CC25E67CA6C9FB5843497539A74FD0', 'a')
        tor.routers['$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5'] = FakeRouter('$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5', 'b')
        tor.routers['$253DFF1838A2B7782BE7735F74E50090D46CA1BC'] = FakeRouter('$253DFF1838A2B7782BE7735F74E50090D46CA1BC', 'c')

        for ex in examples[:-1]:
            circuit.update(ex.split()[1:])
            self.assertEqual(circuit.state, ex.split()[2])
            self.assertEqual(circuit.purpose, 'GENERAL')
            if '$' in ex:
                self.assertEqual(len(circuit.path), len(ex.split()[3].split(',')))
                for (r, p) in zip(ex.split()[3].split(','), circuit.path):
                    d = r.split('=')[0]
                    self.assertEqual(d, p.hash)

    def test_extend_messages(self):
        tor = FakeTorController()
        a = FakeRouter('$E11D2B2269CC25E67CA6C9FB5843497539A74FD0', 'a')
        b = FakeRouter('$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5', 'b')
        c = FakeRouter('$253DFF1838A2B7782BE7735F74E50090D46CA1BC', 'c')
        tor.routers['$E11D2B2269CC25E67CA6C9FB5843497539A74FD0'] = a
        tor.routers['$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5'] = b
        tor.routers['$253DFF1838A2B7782BE7735F74E50090D46CA1BC'] = c

        circuit = Circuit(tor)
        circuit.listen(tor)

        circuit.update('365 LAUNCHED PURPOSE=GENERAL'.split())
        self.assertEqual(tor.extend, [])
        circuit.update('365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris PURPOSE=GENERAL'.split())
        self.assertEqual(len(tor.extend), 1)
        self.assertEqual(tor.extend[0], (circuit, a))

        circuit.update('365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus PURPOSE=GENERAL'.split())
        self.assertEqual(len(tor.extend), 2)
        self.assertEqual(tor.extend[0], (circuit, a))
        self.assertEqual(tor.extend[1], (circuit, b))

        circuit.update('365 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL'.split())
        self.assertEqual(len(tor.extend), 3)
        self.assertEqual(tor.extend[0], (circuit, a))
        self.assertEqual(tor.extend[1], (circuit, b))
        self.assertEqual(tor.extend[2], (circuit, c))

    def test_extends_no_path(self):
        '''
        without connectivity, it seems you get EXTENDS messages with no path update.
        '''
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.listen(tor)

        circuit.update('753 EXTENDED BUILD_FLAGS=IS_INTERNAL,NEED_CAPACITY,NEED_UPTIME PURPOSE=MEASURE_TIMEOUT TIME_CREATED=2012-07-30T18:23:18.956704'.split())
        self.assertEqual(tor.extend, [])
        self.assertEqual(circuit.path, [])
        self.assertTrue('IS_INTERNAL' in circuit.build_flags)
        self.assertTrue('NEED_CAPACITY' in circuit.build_flags)
        self.assertTrue('NEED_UPTIME' in circuit.build_flags)

    def test_str(self):
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.id = 1
        str(circuit)

    def test_failed_reason(self):
        tor = FakeTorController()
        circuit = Circuit(tor)
        circuit.listen(tor)
        circuit.update('1 FAILED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris PURPOSE=GENERAL REASON=TIMEOUT'.split())
        self.assertEqual(len(tor.failed), 1)
        circ, kw = tor.failed[0]
        self.assertEqual(circ, circuit)
        self.assertTrue('PURPOSE' in kw)
        self.assertTrue('REASON' in kw)
        self.assertEqual(kw['PURPOSE'], 'GENERAL')
        self.assertEqual(kw['REASON'], 'TIMEOUT')

    def test_close_circuit(self):
        tor = FakeTorController()
        a = FakeRouter('$E11D2B2269CC25E67CA6C9FB5843497539A74FD0', 'a')
        b = FakeRouter('$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5', 'b')
        c = FakeRouter('$253DFF1838A2B7782BE7735F74E50090D46CA1BC', 'c')
        tor.routers['$E11D2B2269CC25E67CA6C9FB5843497539A74FD0'] = a
        tor.routers['$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5'] = b
        tor.routers['$253DFF1838A2B7782BE7735F74E50090D46CA1BC'] = c

        circuit = Circuit(tor)
        circuit.listen(tor)

        circuit.update('123 EXTENDED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL'.split())

        self.assertEqual(3, len(circuit.path))
        d = circuit.close()
        # we already pretended that Tor answered "OK" to the
        # CLOSECIRCUIT call (see close_circuit() in FakeTorController
        # above) however the circuit isn't "really" closed yet...
        self.assertTrue(not d.called)
        ## not unit-test-y? shouldn't probably delve into internals I suppose...
        self.assertTrue(circuit._closing_deferred is not None)

        # simulate that Tor has really closed the circuit for us
        # this should cause our Deferred to callback
        circuit.update('123 CLOSED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=FINISHED'.split())

        # confirm that our circuit callback has been triggered already
        self.assertRaises(defer.AlreadyCalledError, d.callback, "should have been called already")
        return d

########NEW FILE########
__FILENAME__ = test_fsm

import txtorcon.spaghetti
from txtorcon.spaghetti import *
from twisted.trial import unittest

import os
import subprocess
import tempfile


class FsmTests(unittest.TestCase):

    def match(self, data):
        if data.split()[0] == '250':
            return True
        return False

    def test_reprs(self):
        """
        not really 'testing' here, going for code-coverage to simply
        call the __str__ methods to ensure they don't explode
        """

        a = State("A")
        b = State("B")
        tran = Transition(b, lambda x: None, lambda x: None)
        a.add_transition(tran)
        fsm = FSM([a, b])
        str(fsm)
        str(a)
        str(tran)
        tran.start_state = None
        str(tran)
        fsm.dotty()

    def test_no_init(self):
        fsm = FSM([])
        self.assertRaises(Exception, fsm.process, "")

    def test_no_init_ctor(self):
        fsm = FSM([])
        idle = State("I")
        str(idle)
        fsm.add_state(idle)
        self.assertWarns(RuntimeWarning, "No next state",
                         txtorcon.spaghetti.__file__, fsm.process, "")

    def test_no_matcher(self):
        idle = State("I")
        other = State("O")
        fsm = FSM([idle, other])

        idle.add_transition(Transition(other, None, None))
        fsm.process("")

    def test_bad_transition(self):
        self.assertRaises(Exception, Transition, None, self.match, None)

    def test_dotty(self):
        idle = State("I")
        fsm = FSM([idle])
        self.assertTrue(idle.dotty() in fsm.dotty())
        self.assertTrue("digraph" in fsm.dotty())
        fname = tempfile.mktemp() + '.dot'
        try:
            f = open(fname, 'w')
            f.write(fsm.dotty())
            f.close()
            try:
                proc = subprocess.Popen(('dot', fname),
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE)
            except OSError:
                # Graphviz probably not available; skip
                return
            else:
                _, stderr = proc.communicate()
                retcode = proc.poll()
                if retcode:
                    self.fail('Calling dot returned %i (%s)' % (retcode,
                                                                stderr))
        finally:
            os.unlink(fname)

    def test_handler_state(self):
        idle = State("I")
        cmd = State("C")

        idle.add_transitions([Transition(cmd,
                                         self.match,
                                         lambda x: idle)])

        fsm = FSM([idle, cmd])
        self.commands = []
        self.assertEqual(fsm.state, idle)
        fsm.process("250 OK\n")
        self.assertEqual(fsm.state, idle)

    def test_simple_machine(self):
        idle = State("I")
        cmd = State("C")

        idle.add_transitions([Transition(cmd,
                                         self.match,
                                         None)])

        fsm = FSM([idle, cmd])
        self.commands = []
        self.assertEqual(fsm.state, idle)
        fsm.process("250 OK\n")
        self.assertEqual(fsm.state, cmd)

    def doCommand(self, data):
        print "transition:", data

########NEW FILE########
__FILENAME__ = test_log
from twisted.trial import unittest

from txtorcon import log


class LoggingTests(unittest.TestCase):
    def test_debug(self):
        log.debug_logging()

########NEW FILE########
__FILENAME__ = test_router
from twisted.trial import unittest
from twisted.internet import defer

from txtorcon.router import Router, hexIdFromHash, hashFromHexId


class FakeController(object):
    def get_info_raw(self, i):
        return defer.succeed('250-ip-to-country/something=XX\r\n250 OK')


class UtilityTests(unittest.TestCase):

    def test_hex_converters(self):
        self.assertEqual(hexIdFromHash('AHhuQ8zFQJdT8l42Axxc6m6kNwI'), '$00786E43CCC5409753F25E36031C5CEA6EA43702')
        self.assertEqual(hashFromHexId('$00786E43CCC5409753F25E36031C5CEA6EA43702'), 'AHhuQ8zFQJdT8l42Axxc6m6kNwI')
        ## should work with or without leading $
        self.assertEqual(hexIdFromHash(hashFromHexId('00786E43CCC5409753F25E36031C5CEA6EA43702')), '$00786E43CCC5409753F25E36031C5CEA6EA43702')


class RouterTests(unittest.TestCase):

    def test_ctor(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        self.assertEqual(router.id_hex, "$00786E43CCC5409753F25E36031C5CEA6EA43702")
        self.assertEqual(router.policy, '')

    def test_unique_name(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        self.assertEqual(router.id_hex, "$00786E43CCC5409753F25E36031C5CEA6EA43702")
        self.assertEqual(router.unique_name, "$00786E43CCC5409753F25E36031C5CEA6EA43702")
        router.flags = ['Named']
        self.assertEqual(router.unique_name, "foo")

    def test_flags(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        router.flags = "Exit Fast Named Running V2Dir Valid".split()
        self.assertEqual(router.name_is_unique, True)

    def test_flags_from_string(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        router.flags = "Exit Fast Named Running V2Dir Valid"
        self.assertEqual(router.name_is_unique, True)

    def test_policy_accept(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        router.policy = "accept 25,128-256".split()
        self.assertTrue(router.accepts_port(25))
        for x in range(128, 256):
            self.assertTrue(router.accepts_port(x))
        self.assertTrue(not router.accepts_port(26))
        self.assertEqual(router.policy, 'accept 25,128-256')

    def test_policy_reject(self):
        controller = object()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "77.183.225.114",
                      "24051", "24052")
        router.policy = "reject 500-600,655,7766".split()
        for x in range(1, 500):
            self.assertTrue(router.accepts_port(x))
        for x in range(500, 601):
            self.assertTrue(not router.accepts_port(x))

        self.assertEqual(router.policy, 'reject 500-600,655,7766')

    def test_countrycode(self):
        class CountryCodeController(object):
            def get_info_raw(self, i):
                return defer.succeed('250-ip-to-country/127.1.2.3=ZZ\r\n250 OK')
        controller = CountryCodeController()
        router = Router(controller)
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "127.1.2.3",
                      "24051", "24052")

        self.assertEqual(router.location.countrycode, 'ZZ')

    def test_policy_error(self):
        router = Router(object())
        try:
            router.policy = 'foo 123'
            self.fail()
        except Exception, e:
            self.assertTrue("Don't understand" in str(e))

    def test_policy_not_set_error(self):
        router = Router(object())
        try:
            router.accepts_port(123)
            self.fail()
        except Exception, e:
            self.assertTrue("policy" in str(e))

    def test_repr(self):
        router = Router(FakeController())
        router.update("foo",
                      "AHhuQ8zFQJdT8l42Axxc6m6kNwI",
                      "MAANkj30tnFvmoh7FsjVFr+cmcs",
                      "2011-12-16 15:11:34",
                      "1.2.3.4",
                      "24051", "24052")
        router.flags = ['Named']
        repr(router)

    def test_repr_no_update(self):
        router = Router(FakeController())
        repr(router)

########NEW FILE########
__FILENAME__ = test_stream
from txtorcon.util import maybe_ip_addr
from twisted.trial import unittest
from twisted.internet import defer
from zope.interface import implements

from txtorcon import Stream, IStreamListener, ICircuitContainer, StreamListenerMixin


class FakeCircuit:
    def __init__(self, id=-999):
        self.streams = []
        self.id = id


class Listener(object):
    implements(IStreamListener)

    def __init__(self, expected):
        "expect is a list of tuples: (event, {key:value, key1:value1, ..})"
        self.expected = expected

    def checker(self, state, stream, *args, **kw):
        if self.expected[0][0] != state:
            raise RuntimeError('Expected event "%s" not "%s".' % (self.expected[0][0], state))
        for (k, v) in self.expected[0][1].items():
            if k == 'args':
                if v != args:
                    raise RuntimeError('Expected argument to have value "%s", not "%s"' % (v, args))
            elif k == 'kwargs':
                for (key, value) in v.items():
                    if not key in kw:
                        print key, value, k, v, kw
                        raise RuntimeError('Expected keyword argument for key "%s" but found nothing.' % key)
                    elif kw[key] != value:
                        raise RuntimeError('KW Argument expected "%s" but got "%s"' % (value, kw[key]))
            elif getattr(stream, k) != v:
                raise RuntimeError('Expected attribute "%s" to have value "%s", not "%s"' % (k, v, getattr(stream, k)))
        self.expected = self.expected[1:]

    def stream_new(self, stream):
        "a new stream has been created"
        self.checker('new', stream)

    def stream_succeeded(self, stream):
        "stream has succeeded"
        self.checker('succeeded', stream)

    def stream_attach(self, stream, circuit):
        "the stream has been attached to a circuit"
        self.checker('attach', stream, circuit)

    def stream_detach(self, stream, **kw):
        "the stream has been attached to a circuit"
        self.checker('detach', stream, **kw)

    def stream_closed(self, stream, **kw):
        "stream has been closed (won't be in controller's list anymore)"
        self.checker('closed', stream, **kw)

    def stream_failed(self, stream, **kw):
        "stream failed for some reason (won't be in controller's list anymore)"
        self.checker('failed', stream, **kw)


class StreamTests(unittest.TestCase):

    implements(ICircuitContainer)

    def find_circuit(self, id):
        return self.circuits[id]

    def close_circuit(self, circuit, **kw):
        raise NotImplementedError()

    def close_stream(self, stream, **kw):
        return defer.succeed('')

    def setUp(self):
        self.circuits = {}

    def test_lowercase_flags(self):
        ## testing an internal method, maybe a no-no?
        stream = Stream(self)
        kw = dict(FOO='bar', BAR='baz')
        flags = stream._create_flags(kw)
        self.assertTrue('FOO' in flags)
        self.assertTrue('foo' in flags)
        self.assertTrue(flags['foo'] is flags['FOO'])

        self.assertTrue('BAR' in flags)
        self.assertTrue('bar' in flags)
        self.assertTrue(flags['bar'] is flags['BAR'])

    def test_listener_mixin(self):
        listener = StreamListenerMixin()
        from zope.interface.verify import verifyObject
        self.assertTrue(verifyObject(IStreamListener, listener))

        ## call all the methods with None for each arg. This is mostly
        ## just to gratuitously increase test coverage, but also
        ## serves to ensure these methods don't just blow up
        for (methodname, desc) in IStreamListener.namesAndDescriptions():
            method = getattr(listener, methodname)
            args = [None] * len(desc.positional)
            method(*args)

    def test_circuit_already_valid_in_new(self):
        stream = Stream(self)
        stream.circuit = FakeCircuit(1)
        stream.update("1 NEW 0 94.23.164.42.$43ED8310EB968746970896E8835C2F1991E50B69.exit:9001 SOURCE_ADDR=(Tor_internal):0 PURPOSE=DIR_FETCH".split())
        errs = self.flushLoggedErrors()
        self.assertEqual(len(errs), 1)
        self.assertTrue('Weird' in errs[0].getErrorMessage())

    def test_magic_circuit_detach(self):
        stream = Stream(self)
        stream.circuit = FakeCircuit(1)
        stream.circuit.streams = [stream]
        stream.update("1 SENTCONNECT 0 94.23.164.42.$43ED8310EB968746970896E8835C2F1991E50B69.exit:9001 SOURCE_ADDR=(Tor_internal):0 PURPOSE=DIR_FETCH".split())
        self.assertTrue(stream.circuit is None)

    def test_args_in_ctor(self):
        stream = Stream(self)
        stream.update("1 NEW 0 94.23.164.42.$43ED8310EB968746970896E8835C2F1991E50B69.exit:9001 SOURCE_ADDR=(Tor_internal):0 PURPOSE=DIR_FETCH".split())
        self.assertEqual(stream.id, 1)
        self.assertEqual(stream.state, 'NEW')

    def test_parse_resolve(self):
        stream = Stream(self)
        stream.update("1604 NEWRESOLVE 0 www.google.ca:0 PURPOSE=DNS_REQUEST".split())
        self.assertEqual(stream.state, 'NEWRESOLVE')

    def test_listener_new(self):
        listener = Listener([('new', {'target_port':9001})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("1 NEW 0 94.23.164.42.$43ED8310EB968746970896E8835C2F1991E50B69.exit:9001 SOURCE_ADDR=(Tor_internal):0 PURPOSE=DIR_FETCH".split())

    def test_listener_attach(self):
        self.circuits[186] = FakeCircuit(186)

        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {'target_addr':maybe_ip_addr('1.2.3.4')})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("316 REMAP 186 1.2.3.4:80 SOURCE=EXIT".split())

        self.assertEqual(self.circuits[186].streams[0], stream)

    def test_listener_attach_no_remap(self):
        "Attachment is via SENTCONNECT on .onion addresses (for example)"
        self.circuits[186] = FakeCircuit(186)

        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("316 SENTCONNECT 186 1.2.3.4:80 SOURCE=EXIT".split())

        self.assertEqual(self.circuits[186].streams[0], stream)

    def test_update_wrong_stream(self):
        self.circuits[186] = FakeCircuit(186)

        stream = Stream(self)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        try:
            stream.update("999 SENTCONNECT 186 1.2.3.4:80 SOURCE=EXIT".split())
            self.fail()
        except Exception, e:
            self.assertTrue('wrong stream' in str(e))

    def test_update_illegal_state(self):
        self.circuits[186] = FakeCircuit(186)

        stream = Stream(self)
        try:
            stream.update("316 FOO 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
            self.fail()
        except Exception, e:
            self.assertTrue('Unknown state' in str(e))

    def test_listen_unlisten(self):
        self.circuits[186] = FakeCircuit(186)

        listener = Listener([])

        stream = Stream(self)
        stream.listen(listener)
        stream.unlisten(listener)
        self.assertEqual(len(stream.listeners), 0)

    def test_stream_changed(self):
        "Change a stream-id mid-stream."
        self.circuits[186] = FakeCircuit(186)

        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {}),
                             ('succeeded', {})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("316 SENTCONNECT 186 1.2.3.4:80 SOURCE=EXIT".split())
        self.assertEqual(self.circuits[186].streams[0], stream)

        # magically change circuit ID without a DETACHED, should fail
        stream.update("316 SUCCEEDED 999 1.2.3.4:80 SOURCE=EXIT".split())
        errs = self.flushLoggedErrors()
        self.assertEqual(len(errs), 1)
        # kind of fragile to look at strings, but...
        self.assertTrue('186 to 999' in str(errs[0]))

    def test_stream_changed_with_detach(self):
        "Change a stream-id mid-stream, but with a DETACHED message"
        self.circuits[123] = FakeCircuit(123)
        self.circuits[456] = FakeCircuit(456)

        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {}),
                             ('detach', {'kwargs': dict(reason='END', remote_reason='MISC')}),
                             ('attach', {})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("999 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("999 SENTCONNECT 123 1.2.3.4:80".split())
        self.assertEqual(len(self.circuits[123].streams), 1)
        self.assertEqual(self.circuits[123].streams[0], stream)

        stream.update("999 DETACHED 123 1.2.3.4:80 REASON=END REMOTE_REASON=MISC".split())
        self.assertEqual(len(self.circuits[123].streams), 0)

        stream.update("999 SENTCONNECT 456 1.2.3.4:80 SOURCE=EXIT".split())
        self.assertEqual(len(self.circuits[456].streams), 1)
        self.assertEqual(self.circuits[456].streams[0], stream)

    def test_listener_close(self):
        self.circuits[186] = FakeCircuit(186)

        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {'target_addr':maybe_ip_addr('1.2.3.4')}),
                             ('closed', {'kwargs': dict(REASON='END', REMOTE_REASON='DONE')})])
        stream = Stream(self)
        stream.listen(listener)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("316 REMAP 186 1.2.3.4:80 SOURCE=EXIT".split())
        stream.update("316 CLOSED 186 1.2.3.4:80 REASON=END REMOTE_REASON=DONE".split())

        self.assertEqual(len(self.circuits[186].streams), 0)

    def test_listener_fail(self):
        listener = Listener([('new', {'target_host':'www.yahoo.com', 'target_port':80}),
                             ('attach', {'target_addr':maybe_ip_addr('1.2.3.4')}),
                             ('failed', {'kwargs': dict(REASON='TIMEOUT', REMOTE_REASON='DESTROYED')})])
        stream = Stream(self)
        stream.listen(listener)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        self.circuits[186] = FakeCircuit(186)
        stream.update("316 REMAP 186 1.2.3.4:80 SOURCE=EXIT".split())
        stream.update("316 FAILED 0 1.2.3.4:80 REASON=TIMEOUT REMOTE_REASON=DESTROYED".split())

    def test_str(self):
        stream = Stream(self)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.circuit = FakeCircuit(1)
        str(stream)

    def test_ipv6(self):
        listener = Listener([('new', {'target_host':'::1', 'target_port':80})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("1234 NEW 0 ::1:80 SOURCE_ADDR=127.0.0.1:57349 PURPOSE=USER".split())

    def test_ipv6_remap(self):
        stream = Stream(self)
        stream.update("1234 REMAP 0 ::1:80 SOURCE_ADDR=127.0.0.1:57349 PURPOSE=USER".split())
        self.assertEqual(stream.target_addr, maybe_ip_addr('::1'))

    def test_ipv6_source(self):
        listener = Listener([('new', {'source_addr':maybe_ip_addr('::1'), 'source_port':12345})])

        stream = Stream(self)
        stream.listen(listener)
        stream.update("1234 NEW 0 127.0.0.1:80 SOURCE_ADDR=::1:12345 PURPOSE=USER".split())

    def test_states_and_uris(self):
        self.circuits[1] = FakeCircuit(1)

        stream = Stream(self)
        for address in ['1.2.3.4:80',
                        '1.2.3.4.315D5684D5343580D409F16119F78D776A58AEFB.exit:80',
                        'timaq4ygg2iegci7.onion:80']:

            line = "316 %s 1 %s REASON=FOO"
            for state in ['NEW', 'SUCCEEDED', 'REMAP',
                          'SENTCONNECT',
                          'DETACHED', 'NEWRESOLVE', 'SENTRESOLVE',
                          'FAILED', 'CLOSED']:
                stream.update((line % (state, address)).split(' '))
                self.assertEqual(stream.state, state)

    def test_close_stream(self):
        self.circuits[186] = FakeCircuit(186)
        stream = Stream(self)
        stream.update("316 NEW 0 www.yahoo.com:80 SOURCE_ADDR=127.0.0.1:55877 PURPOSE=USER".split())
        stream.update("316 REMAP 186 1.2.3.4:80 SOURCE=EXIT".split())

        self.assertEqual(len(self.circuits[186].streams), 1)

        d = stream.close()
        self.assertTrue(not d.called)
        self.assertEqual(len(self.circuits[186].streams), 1)

        stream.update("316 CLOSED 186 1.2.3.4:80 REASON=END REMOTE_REASON=DONE".split())
        self.assertTrue(d.called)
        self.assertEqual(len(self.circuits[186].streams), 0)

########NEW FILE########
__FILENAME__ = test_torconfig
import os
import shutil
import tempfile
import functools

from zope.interface import implements
from twisted.trial import unittest
from twisted.test import proto_helpers
from twisted.internet import defer, error, task
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.python.failure import Failure
from twisted.internet.interfaces import IReactorCore, IProtocolFactory, IReactorTCP, IListeningPort

from txtorcon import TorControlProtocol, ITorControlProtocol, TorConfig, DEFAULT_VALUE, HiddenService, launch_tor, TCPHiddenServiceEndpoint, TorNotFound
from txtorcon import torconfig

from txtorcon.util import delete_file_or_tree


class FakeControlProtocol:
    """
    This is a little weird, but in most tests the answer at the top of
    the list is sent back immediately in an already-called
    Deferred. However, if the answer list is empty at the time of the
    call, instead the returned Deferred is added to the pending list
    and answer_pending() may be called to have the next Deferred
    fire. (see test_slutty_postbootstrap for an example).

    It is done this way in case we need to have some other code run
    between the get_conf (or whatever) and the callback -- if the
    Deferred is already-fired when get_conf runs, there's a Very Good
    Chance (always?) that the callback just runs right away.
    """

    implements(ITorControlProtocol)     # actually, just get_info_raw

    def __init__(self, answers):
        self.answers = answers
        self.pending = []
        self.post_bootstrap = defer.succeed(self)
        self.sets = []
        self.events = {}

    def answer_pending(self, answer):
        d = self.pending[0]
        self.pending = self.pending[1:]
        d.callback(answer)

    def get_info_raw(self, info):
        if len(self.answers) == 0:
            d = defer.Deferred()
            self.pending.append(d)
            return d

        d = defer.succeed(self.answers[0])
        self.answers = self.answers[1:]
        return d

    def get_conf(self, info):
        if len(self.answers) == 0:
            d = defer.Deferred()
            self.pending.append(d)
            return d

        d = defer.succeed(self.answers[0])
        self.answers = self.answers[1:]
        return d

    get_conf_raw = get_conf             # up to test author ensure the answer is a raw string

    def set_conf(self, *args):
        for i in range(0, len(args), 2):
            self.sets.append((args[i], args[i + 1]))
        return defer.succeed('')

    def add_event_listener(self, nm, cb):
        self.events[nm] = cb


class CheckAnswer:

    def __init__(self, test, ans):
        self.answer = ans
        self.test = test

    def __call__(self, x):
        self.test.assertEqual(x, self.answer)


class ConfigTests(unittest.TestCase):
    """
    FIXME hmm, this all seems a little convoluted to test errors?
    Maybe not that bad.
    """

    def setUp(self):
        self.protocol = FakeControlProtocol([])

    def test_boolean_parse_error(self):
        self.protocol.answers.append('config/names=\nfoo Boolean')
        self.protocol.answers.append({'foo': 'bar'})
        cfg = TorConfig(self.protocol)
        self.assertEqual(cfg.get_type('foo'), torconfig.Boolean)
        errs = self.flushLoggedErrors(ValueError)
        self.assertEqual(len(errs), 1)
        ## dunno if asserting strings in messages is a good idea...
        self.assertTrue('invalid literal' in errs[0].getErrorMessage())

    def test_boolean_parser(self):
        self.protocol.answers.append('config/names=\nfoo Boolean\nbar Boolean')
        self.protocol.answers.append({'foo': '0'})
        self.protocol.answers.append({'bar': '1'})
        ## FIXME does a Tor controller only ever send "0" and "1" for
        ## true/false? Or do we need to accept others?

        conf = TorConfig(self.protocol)
        self.assertTrue(conf.foo is False)
        self.assertTrue(conf.bar is True)

    def test_boolean_auto_parser(self):
        self.protocol.answers.append('config/names=\nfoo Boolean+Auto\nbar Boolean+Auto\nbaz Boolean+Auto')
        self.protocol.answers.append({'foo': '0'})
        self.protocol.answers.append({'bar': '1'})
        self.protocol.answers.append({'baz': 'auto'})

        conf = TorConfig(self.protocol)
        self.assertTrue(conf.foo is 0)
        self.assertTrue(conf.bar is 1)
        self.assertTrue(conf.baz is -1)

    def test_string_parser(self):
        self.protocol.answers.append('config/names=\nfoo String')
        self.protocol.answers.append({'foo': 'bar'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.foo, 'bar')

    def test_int_parser(self):
        self.protocol.answers.append('config/names=\nfoo Integer')
        self.protocol.answers.append({'foo': '123'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.foo, 123)

    def test_int_parser_error(self):
        self.protocol.answers.append('config/names=\nfoo Integer')
        self.protocol.answers.append({'foo': '123foo'})
        TorConfig(self.protocol)
        errs = self.flushLoggedErrors(ValueError)
        self.assertEqual(len(errs), 1)
        self.assertTrue(isinstance(errs[0].value, ValueError))

    def test_int_parser_error_2(self):
        self.protocol.answers.append('config/names=\nfoo Integer')
        self.protocol.answers.append({'foo': '1.23'})
        TorConfig(self.protocol)
        errs = self.flushLoggedErrors(ValueError)
        self.assertEqual(len(errs), 1)
        self.assertTrue(isinstance(errs[0].value, ValueError))

    def test_linelist_parser(self):
        self.protocol.answers.append('config/names=\nfoo LineList')
        self.protocol.answers.append({'foo': 'bar\nbaz'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.foo, ['bar', 'baz'])

    def test_listlist_parser_with_list(self):
        self.protocol.answers.append('config/names=\nfoo LineList')
        self.protocol.answers.append({'foo': [1, 2, 3]})

        conf = TorConfig(self.protocol)
        self.assertEqual(conf.foo, ['1', '2', '3'])

    def test_float_parser(self):
        self.protocol.answers.append('config/names=\nfoo Float')
        self.protocol.answers.append({'foo': '1.23'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.foo, 1.23)

    def test_float_parser_error(self):
        self.protocol.answers.append('config/names=\nfoo Float')
        self.protocol.answers.append({'foo': '1.23fff'})
        TorConfig(self.protocol)
        errs = self.flushLoggedErrors(ValueError)
        self.assertEqual(len(errs), 1)
        self.assertTrue(isinstance(errs[0].value, ValueError))

    def test_list(self):
        self.protocol.answers.append('config/names=\nbing CommaList')
        self.protocol.answers.append({'bing': 'foo,bar,baz'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.config['bing'], ['foo', 'bar', 'baz'])
        # self.assertEqual(conf.bing, ['foo','bar','baz'])

    def test_single_list(self):
        self.protocol.answers.append('config/names=\nbing CommaList')
        self.protocol.answers.append({'bing': 'foo'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.config['bing'], ['foo'])

    def test_multi_list_space(self):
        self.protocol.answers.append('config/names=\nbing CommaList')
        self.protocol.answers.append({'bing': 'foo, bar , baz'})
        conf = TorConfig(self.protocol)
        self.assertEqual(conf.bing, ['foo', 'bar', 'baz'])

    def test_descriptor_access(self):
        self.protocol.answers.append('config/names=\nbing CommaList')
        self.protocol.answers.append({'bing': 'foo,bar'})

        conf = TorConfig(self.protocol)
        self.assertEqual(conf.config['bing'], ['foo', 'bar'])
        self.assertEqual(conf.bing, ['foo', 'bar'])

        self.protocol.answers.append('250 OK')
        conf.bing = ['a', 'b']
        self.assertEqual(conf.bing, ['foo', 'bar'])

        d = conf.save()

        def confirm(conf):
            self.assertEqual(conf.config['bing'], ['a', 'b'])
            self.assertEqual(conf.bing, ['a', 'b'])

        d.addCallbacks(confirm, self.fail)
        return d

    def test_unknown_descriptor(self):
        self.protocol.answers.append('config/names=\nbing CommaList')
        self.protocol.answers.append({'bing': 'foo'})

        conf = TorConfig(self.protocol)
        try:
            conf.foo
            self.assertTrue(False)
        except KeyError, e:
            self.assertTrue('foo' in str(e))

    def test_invalid_parser(self):
        self.protocol.answers.append('config/names=\nSomethingExciting NonExistantParserType')
        TorConfig(self.protocol)
        errs = self.flushLoggedErrors()
        self.assertEqual(len(errs), 1)
        self.assertTrue('NonExistantParserType' in str(errs[0]))

    def foo(self, *args):
        print "FOOO", args

    def test_slutty_postbootstrap(self):
        # test that doPostbootstrap still works in "slutty" mode
        self.protocol.answers.append('config/names=\nORPort Port')
        ## we can't answer right away, or we do all the _do_setup
        ## callbacks before _setup_ is set -- but we need to do an
        ## answer callback after that to trigger this bug

        conf = TorConfig(self.protocol)
        self.assertTrue('_setup_' in conf.__dict__)
        self.protocol.answer_pending({'ORPort': 1})

    def test_immediate_bootstrap(self):
        self.protocol.post_bootstrap = None
        self.protocol.answers.append('config/names=\nfoo Boolean')
        self.protocol.answers.append({'foo': '0'})
        conf = TorConfig(self.protocol)
        self.assertTrue('foo' in conf.config)

    def test_multiple_orports(self):
        self.protocol.post_bootstrap = None
        self.protocol.answers.append('config/names=\nOrPort CommaList')
        self.protocol.answers.append({'OrPort': '1234'})
        conf = TorConfig(self.protocol)
        conf.OrPort = ['1234', '4321']
        conf.save()
        self.assertEqual(self.protocol.sets, [('OrPort', '1234'),
                                              ('OrPort', '4321')])

    def test_set_multiple(self):
        self.protocol.answers.append('config/names=\nAwesomeKey String')
        self.protocol.answers.append({'AwesomeKey': 'foo'})

        conf = TorConfig(self.protocol)
        conf.awesomekey
        conf.awesomekey = 'baz'
        self.assertTrue(conf.needs_save())
        conf.awesomekey = 'nybble'
        conf.awesomekey = 'pac man'

        conf.save()

        self.assertEqual(len(self.protocol.sets), 1)
        self.assertEqual(self.protocol.sets[0], ('AwesomeKey', 'pac man'))

    def test_log_double_save(self):
        self.protocol.answers.append('config/names=\nLog LineList\nFoo String''')
        self.protocol.answers.append({'Log': 'notice file /var/log/tor/notices.log'})
        self.protocol.answers.append({'Foo': 'foo'})
        conf = TorConfig(self.protocol)

        conf.log.append('info file /tmp/foo.log')
        conf.foo = 'bar'
        self.assertTrue(conf.needs_save())
        conf.save()
        conf.save()  # just for the code coverage...

        self.assertTrue(not conf.needs_save())
        self.protocol.sets = []
        conf.save()
        self.assertEqual(self.protocol.sets, [])

    def test_set_save_modify(self):
        self.protocol.answers.append('config/names=\nLog LineList')
        self.protocol.answers.append({'Log': 'notice file /var/log/tor/notices.log'})
        conf = TorConfig(self.protocol)

        conf.log = []
        self.assertTrue(conf.needs_save())
        conf.save()

        conf.log.append('notice file /tmp/foo.log')
        self.assertTrue(conf.needs_save())

    def test_proper_sets(self):
        self.protocol.answers.append('config/names=\nLog LineList')
        self.protocol.answers.append({'Log': 'foo'})

        conf = TorConfig(self.protocol)
        conf.log.append('bar')
        conf.save()

        self.assertEqual(len(self.protocol.sets), 2)
        self.assertEqual(self.protocol.sets[0], ('Log', 'foo'))
        self.assertEqual(self.protocol.sets[1], ('Log', 'bar'))


class LogTests(unittest.TestCase):

    def setUp(self):
        self.protocol = FakeControlProtocol([])
        self.protocol.answers.append('config/names=\nLog LineList''')
        self.protocol.answers.append({'Log': 'notice file /var/log/tor/notices.log'})

    def test_log_set(self):
        conf = TorConfig(self.protocol)

        conf.log.append('info file /tmp/foo.log')
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(self.protocol.sets[0], ('Log', 'notice file /var/log/tor/notices.log'))
        self.assertEqual(self.protocol.sets[1], ('Log', 'info file /tmp/foo.log'))

    def test_log_set_capital(self):
        conf = TorConfig(self.protocol)

        conf.Log.append('info file /tmp/foo.log')
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(self.protocol.sets[0], ('Log', 'notice file /var/log/tor/notices.log'))
        self.assertEqual(self.protocol.sets[1], ('Log', 'info file /tmp/foo.log'))

    def test_log_set_index(self):
        conf = TorConfig(self.protocol)

        conf.log[0] = 'info file /tmp/foo.log'
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(self.protocol.sets[0], ('Log', 'info file /tmp/foo.log'))

    def test_log_set_slice(self):
        conf = TorConfig(self.protocol)

        conf.log[0:1] = ['info file /tmp/foo.log']
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(self.protocol.sets[0], ('Log', 'info file /tmp/foo.log'))

    def test_log_set_pop(self):
        conf = TorConfig(self.protocol)

        self.assertEqual(len(conf.log), 1)
        conf.log.pop()
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(len(conf.log), 0)
        self.assertEqual(len(self.protocol.sets), 0)

    def test_log_set_extend(self):
        conf = TorConfig(self.protocol)

        self.assertEqual(len(conf.log), 1)
        conf.log.extend(['info file /tmp/foo'])
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(len(conf.log), 2)
        self.assertEqual(len(self.protocol.sets), 2)
        self.assertEqual(self.protocol.sets[0], ('Log', 'notice file /var/log/tor/notices.log'))
        self.assertEqual(self.protocol.sets[1], ('Log', 'info file /tmp/foo'))

    def test_log_set_insert(self):
        conf = TorConfig(self.protocol)

        self.assertEqual(len(conf.log), 1)
        conf.log.insert(0, 'info file /tmp/foo')
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(len(conf.log), 2)
        self.assertEqual(len(self.protocol.sets), 2)
        self.assertEqual(self.protocol.sets[1], ('Log', 'notice file /var/log/tor/notices.log'))
        self.assertEqual(self.protocol.sets[0], ('Log', 'info file /tmp/foo'))

    def test_log_set_remove(self):
        conf = TorConfig(self.protocol)

        self.assertEqual(len(conf.log), 1)
        conf.log.remove('notice file /var/log/tor/notices.log')
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(len(conf.log), 0)
        self.assertEqual(len(self.protocol.sets), 0)

    def test_log_set_multiple(self):
        conf = TorConfig(self.protocol)

        self.assertEqual(len(conf.log), 1)
        conf.log[0] = 'foo'
        self.assertTrue(conf.needs_save())
        conf.log[0] = 'heavy'
        conf.log[0] = 'round'
        conf.save()

        self.assertEqual(len(self.protocol.sets), 1)
        self.assertEqual(self.protocol.sets[0], ('Log', 'round'))

    def test_set_wrong_object(self):
        conf = TorConfig(self.protocol)

        try:
            conf.log = ('this', 'is', 'a', 'tuple')
            self.fail()
        except ValueError, e:
            self.assertTrue('Not valid' in str(e))


class EventTests(unittest.TestCase):

    def test_conf_changed(self):
        control = FakeControlProtocol([])
        config = TorConfig(control)
        self.assertTrue('CONF_CHANGED' in control.events)

        control.events['CONF_CHANGED']('Foo=bar\nBar')
        self.assertEqual(len(config.config), 2)
        self.assertEqual(config.Foo, 'bar')
        self.assertEqual(config.Bar, DEFAULT_VALUE)


class CreateTorrcTests(unittest.TestCase):

    def test_create_torrc(self):
        config = TorConfig()
        config.SocksPort = 1234
        config.hiddenservices = [HiddenService(config, '/some/dir', '80 127.0.0.1:1234',
                                               'auth', 2)]
        config.Log = ['80 127.0.0.1:80', '90 127.0.0.1:90']
        config.save()
        torrc = config.create_torrc()
        lines = torrc.split('\n')
        lines.sort()
        torrc = '\n'.join(lines).strip()
        self.assertEqual(torrc, '''HiddenServiceAuthorizeClient auth
HiddenServiceDir /some/dir
HiddenServicePort 80 127.0.0.1:1234
HiddenServiceVersion 2
Log 80 127.0.0.1:80
Log 90 127.0.0.1:90
SocksPort 1234''')


class HiddenServiceTests(unittest.TestCase):

    def setUp(self):
        self.protocol = FakeControlProtocol([])
        self.protocol.answers.append('''config/names=
HiddenServiceOptions Virtual
HiddenServiceVersion Dependant
HiddenServiceAuthorizeClient Dependant''')

    def test_options_hidden(self):
        self.protocol.answers.append('HiddenServiceDir=/fake/path\nHiddenServicePort=80 127.0.0.1:1234\n')

        conf = TorConfig(self.protocol)
        self.assertTrue('HiddenServiceOptions' not in conf.config)
        self.assertEqual(len(conf.HiddenServices), 1)

        self.assertTrue(not conf.needs_save())
        conf.hiddenservices.append(HiddenService(conf, '/some/dir', '80 127.0.0.1:2345', 'auth', 2))
        conf.hiddenservices[0].ports.append('443 127.0.0.1:443')
        self.assertTrue(conf.needs_save())
        conf.save()
        self.assertEqual(conf.get_type('HiddenServices'), HiddenService)

        self.assertEqual(len(self.protocol.sets), 7)
        self.assertEqual(self.protocol.sets[0], ('HiddenServiceDir', '/fake/path'))
        self.assertEqual(self.protocol.sets[1], ('HiddenServicePort', '80 127.0.0.1:1234'))
        self.assertEqual(self.protocol.sets[2], ('HiddenServicePort', '443 127.0.0.1:443'))
        self.assertEqual(self.protocol.sets[3], ('HiddenServiceDir', '/some/dir'))
        self.assertEqual(self.protocol.sets[4], ('HiddenServicePort', '80 127.0.0.1:2345'))
        self.assertEqual(self.protocol.sets[5], ('HiddenServiceVersion', '2'))
        self.assertEqual(self.protocol.sets[6], ('HiddenServiceAuthorizeClient', 'auth'))

    def test_save_no_protocol(self):
        conf = TorConfig()
        conf.HiddenServices = [HiddenService(conf, '/fake/path', ['80 127.0.0.1:1234'])]
        conf.save()

    def test_two_hidden_services_before_save(self):
        conf = TorConfig()
        conf.HiddenServices = [HiddenService(conf, '/fake/path', ['80 127.0.0.1:1234'])]
        conf.HiddenServices.append(HiddenService(conf, '/fake/path/two', ['1234 127.0.0.1:1234']))
        conf.save()
        self.assertEqual(2, len(conf.HiddenServices))

    def test_onion_keys(self):
        self.protocol.answers.append('HiddenServiceDir=/fake/path\n')
        d = tempfile.mkdtemp()

        try:
            with open(os.path.join(d, 'hostname'), 'w') as f:
                f.write('public')
            with open(os.path.join(d, 'private_key'), 'w') as f:
                f.write('private')

            conf = TorConfig(self.protocol)
            hs = HiddenService(conf, d, [])

            self.assertEqual(hs.hostname, 'public')
            self.assertEqual(hs.private_key, 'private')

        finally:
            shutil.rmtree(d, ignore_errors=True)

    def test_modify_hidden_service(self):
        self.protocol.answers.append('HiddenServiceDir=/fake/path\nHiddenServicePort=80 127.0.0.1:1234\n')

        conf = TorConfig(self.protocol)
        conf.hiddenservices[0].version = 3
        self.assertTrue(conf.needs_save())

    def test_add_hidden_service_to_empty_config(self):
        conf = TorConfig()
        h = HiddenService(conf, '/fake/path', ['80 127.0.0.1:1234'], '', 3)
        conf.hiddenservices.append(h)
        self.assertEqual(len(conf.hiddenservices), 1)
        self.assertEqual(h, conf.hiddenservices[0])
        self.assertTrue(conf.needs_save())

    def test_multiple_append(self):
        conf = TorConfig()
        h0 = HiddenService(conf, '/fake/path', ['80 127.0.0.1:1234'], '', 3)
        h1 = HiddenService(conf, '/fake/path', ['90 127.0.0.1:4321'], '', 3)
        conf.hiddenservices.append(h0)
        conf.hiddenservices.append(h1)
        self.assertEqual(len(conf.hiddenservices), 2)
        self.assertEqual(h0, conf.hiddenservices[0])
        self.assertEqual(h1, conf.hiddenservices[1])
        self.assertTrue(conf.needs_save())

    def test_multiple_startup_services(self):
        conf = TorConfig(FakeControlProtocol(['config/names=']))
        conf._setup_hidden_services('''HiddenServiceDir=/fake/path
HiddenServicePort=80 127.0.0.1:1234
HiddenServiceVersion=2
HiddenServiceAuthorizeClient=basic
HiddenServiceDir=/some/other/fake/path
HiddenServicePort=80 127.0.0.1:1234
HiddenServicePort=90 127.0.0.1:2345''')

        self.assertEqual(len(conf.hiddenservices), 2)

        self.assertEqual(conf.hiddenservices[0].dir, '/fake/path')
        self.assertEqual(conf.hiddenservices[0].version, 2)
        self.assertEqual(conf.hiddenservices[0].authorize_client, 'basic')
        self.assertEqual(len(conf.hiddenservices[0].ports), 1)
        self.assertEqual(conf.hiddenservices[0].ports[0], '80 127.0.0.1:1234')

        self.assertEqual(conf.hiddenservices[1].dir, '/some/other/fake/path')
        self.assertEqual(len(conf.hiddenservices[1].ports), 2)
        self.assertEqual(conf.hiddenservices[1].ports[0], '80 127.0.0.1:1234')
        self.assertEqual(conf.hiddenservices[1].ports[1], '90 127.0.0.1:2345')

    def test_hidden_service_parse_error(self):
        conf = TorConfig(FakeControlProtocol(['config/names=']))
        try:
            conf._setup_hidden_services('''FakeHiddenServiceKey=foo''')
            self.fail()
        except RuntimeError, e:
            self.assertTrue('parse' in str(e))

    def test_multiple_modify_hidden_service(self):
        self.protocol.answers.append('HiddenServiceDir=/fake/path\nHiddenServicePort=80 127.0.0.1:1234\n')

        conf = TorConfig(self.protocol)
        conf.hiddenservices[0].version = 3
        self.assertTrue(conf.needs_save())
        conf.hiddenservices[0].version = 4
        conf.hiddenservices[0].version = 5

        self.assertEqual(conf.hiddenservices[0].version, 5)
        conf.save()
        self.assertEqual(len(self.protocol.sets), 3)
        self.assertEqual(self.protocol.sets[0], ('HiddenServiceDir', '/fake/path'))
        self.assertEqual(self.protocol.sets[1], ('HiddenServicePort', '80 127.0.0.1:1234'))
        self.assertEqual(self.protocol.sets[2], ('HiddenServiceVersion', '5'))

    def test_set_save_modify(self):
        self.protocol.answers.append('')

        conf = TorConfig(self.protocol)

        conf.hiddenservices = [HiddenService(conf, '/fake/path', ['80 127.0.0.1:1234'], '', 3)]
        self.assertTrue(conf.needs_save())
        conf.save()

        self.assertEqual(len(conf.hiddenservices), 1)
        self.assertEqual(conf.hiddenservices[0].dir, '/fake/path')
        self.assertEqual(conf.hiddenservices[0].version, 3)
        self.assertEqual(conf.hiddenservices[0].authorize_client, '')
        conf.hiddenservices[0].ports = ['123 127.0.0.1:4321']
        conf.save()

        self.assertTrue(not conf.needs_save())
        conf.hiddenservices[0].ports.append('90 127.0.0.1:2345')
        self.assertTrue(conf.needs_save())


class FakeReactor(task.Clock):
    implements(IReactorCore)

    def __init__(self, test, trans, on_protocol):
        super(FakeReactor, self).__init__()
        self.test = test
        self.transport = trans
        self.on_protocol = on_protocol

    def spawnProcess(self, processprotocol, bin, args, env, path, uid=None, gid=None, usePTY=None, childFDs=None):
        self.protocol = processprotocol
        self.protocol.makeConnection(self.transport)
        self.transport.process_protocol = processprotocol
        self.on_protocol(self.protocol)
        return self.transport

    def addSystemEventTrigger(self, *args):
        self.test.assertEqual(args[0], 'before')
        self.test.assertEqual(args[1], 'shutdown')
        ## we know this is just for the temporary file cleanup, so we
        ## nuke it right away to avoid polluting /tmp but calling the
        ## callback now.
        args[2]()

    def removeSystemEventTrigger(self, id):
        pass


class FakeProcessTransport(proto_helpers.StringTransportWithDisconnection):

    pid = -1

    def signalProcess(self, signame):
        self.process_protocol.processEnded(Failure(error.ProcessTerminated(signal=signame)))

    def closeStdin(self):
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('650 STATUS_CLIENT NOTICE BOOTSTRAP PROGRESS=90 TAG=circuit_create SUMMARY="Establishing a Tor circuit"\r\n')
        self.protocol.dataReceived('650 STATUS_CLIENT NOTICE BOOTSTRAP PROGRESS=100 TAG=done SUMMARY="Done"\r\n')


class FakeProcessTransportNeverBootstraps(FakeProcessTransport):

    pid = -1

    def closeStdin(self):
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('250 OK\r\n')
        self.protocol.dataReceived('650 STATUS_CLIENT NOTICE BOOTSTRAP PROGRESS=90 TAG=circuit_create SUMMARY="Establishing a Tor circuit"\r\n')


class LaunchTorTests(unittest.TestCase):

    def setUp(self):
        self.protocol = TorControlProtocol()
        self.protocol.connectionMade = lambda: None
        self.transport = proto_helpers.StringTransport()
        self.protocol.makeConnection(self.transport)
        self.clock = task.Clock()

    def setup_complete_with_timer(self, proto):
        proto._check_timeout.stop()
        proto.checkTimeout()

    def setup_complete_no_errors(self, proto, config):
        todel = proto.to_delete
        self.assertTrue(len(todel) > 0)
        proto.processEnded(Failure(error.ProcessDone(0)))
        self.assertEqual(len(proto.to_delete), 0)
        for f in todel:
            self.assertTrue(not os.path.exists(f))
        self.assertEqual(proto._timeout_delayed_call, None)

        ## make sure we set up the config to track the created tor
        ## protocol connection
        self.assertEquals(config.protocol, proto.tor_protocol)

    def setup_complete_fails(self, proto):
        todel = proto.to_delete
        self.assertTrue(len(todel) > 0)
        ## the "12" is just arbitrary, we check it later in the error-message
        proto.processEnded(Failure(error.ProcessTerminated(12, None, 'statusFIXME')))
        self.assertEqual(len(proto.to_delete), 0)
        for f in todel:
            self.assertTrue(not os.path.exists(f))

    def test_basic_launch(self):
        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999

        def connector(proto, trans):
            proto._set_valid_events('STATUS_CLIENT')
            proto.makeConnection(trans)
            proto.post_bootstrap.callback(proto)
            return proto.post_bootstrap

        class OnProgress:
            def __init__(self, test, expected):
                self.test = test
                self.expected = expected

            def __call__(self, percent, tag, summary):
                self.test.assertEqual(self.expected[0], (percent, tag, summary))
                self.expected = self.expected[1:]
                self.test.assertTrue('"' not in summary)
                self.test.assertTrue(percent >= 0 and percent <= 100)

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 100%\n')
            proto.progress = OnProgress(self, [(90, 'circuit_create', 'Establishing a Tor circuit'),
                                               (100, 'done', 'Done')])

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(connector, self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')
        d.addCallback(self.setup_complete_no_errors, config)
        return d

    def check_setup_failure(self, fail):
        self.assertTrue("with error-code 12" in fail.getErrorMessage())
        ## cancel the errback chain, we wanted this
        return None

    def test_launch_tor_fails(self):
        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999

        def connector(proto, trans):
            proto._set_valid_events('STATUS_CLIENT')
            proto.makeConnection(trans)
            proto.post_bootstrap.callback(proto)
            return proto.post_bootstrap

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(connector, self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')
        d.addCallback(self.setup_complete_fails)
        return self.assertFailure(d, Exception)

    def test_launch_with_timeout(self):
        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999
        timeout = 5

        def connector(proto, trans):
            proto._set_valid_events('STATUS_CLIENT')
            proto.makeConnection(trans)
            proto.post_bootstrap.callback(proto)
            return proto.post_bootstrap

        class OnProgress:
            def __init__(self, test, expected):
                self.test = test
                self.expected = expected

            def __call__(self, percent, tag, summary):
                self.test.assertEqual(self.expected[0], (percent, tag, summary))
                self.expected = self.expected[1:]
                self.test.assertTrue('"' not in summary)
                self.test.assertTrue(percent >= 0 and percent <= 100)

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransportNeverBootstraps()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(connector, self.protocol, self.transport)
        react = FakeReactor(self, trans, on_protocol)
        d = launch_tor(config, react, connection_creator=creator,
                       timeout=timeout, tor_binary='/bin/echo')
        # FakeReactor is a task.Clock subclass and +1 just to be sure
        react.advance(timeout + 1)

        self.assertTrue(d.called)
        self.assertTrue(d.result.getErrorMessage().strip().endswith('Tor was killed (TERM).'))
        return self.assertFailure(d, RuntimeError)

    def test_launch_with_timeout_that_doesnt_expire(self):
        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999
        timeout = 5

        def connector(proto, trans):
            proto._set_valid_events('STATUS_CLIENT')
            proto.makeConnection(trans)
            proto.post_bootstrap.callback(proto)
            return proto.post_bootstrap

        class OnProgress:
            def __init__(self, test, expected):
                self.test = test
                self.expected = expected

            def __call__(self, percent, tag, summary):
                self.test.assertEqual(self.expected[0], (percent, tag, summary))
                self.expected = self.expected[1:]
                self.test.assertTrue('"' not in summary)
                self.test.assertTrue(percent >= 0 and percent <= 100)

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(connector, self.protocol, self.transport)
        react = FakeReactor(self, trans, on_protocol)
        d = launch_tor(config, react, connection_creator=creator,
                       timeout=timeout, tor_binary='/bin/echo')
        # FakeReactor is a task.Clock subclass and +1 just to be sure
        react.advance(timeout + 1)

        self.assertTrue(d.called)
        self.assertTrue(d.result.tor_protocol == self.protocol)

    def setup_fails_stderr(self, fail):
        self.assertTrue('Something went horribly wrong!' in fail.getErrorMessage())
        ## cancel the errback chain, we wanted this
        return None

    def test_tor_produces_stderr_output(self):
        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999

        def connector(proto, trans):
            proto._set_valid_events('STATUS_CLIENT')
            proto.makeConnection(trans)
            proto.post_bootstrap.callback(proto)
            return proto.post_bootstrap

        def on_protocol(proto):
            proto.errReceived('Something went horribly wrong!\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(connector, self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol),
                       connection_creator=creator, tor_binary='/bin/echo')
        d.addCallback(self.fail)        # should't get callback
        d.addErrback(self.setup_fails_stderr)
        self.assertFalse(self.protocol.on_disconnect)
        return d

    def test_tor_connection_fails(self):
        """
        We fail to connect once, and then successfully connect --
        testing whether we're retrying properly on each Bootstrapped
        line from stdout.
        """

        config = TorConfig()
        config.OrPort = 1234
        config.SocksPort = 9999

        class Connector:
            count = 0

            def __call__(self, proto, trans):
                self.count += 1
                if self.count < 2:
                    return defer.fail(error.CannotListenError(None, None, None))

                proto._set_valid_events('STATUS_CLIENT')
                proto.makeConnection(trans)
                proto.post_bootstrap.callback(proto)
                return proto.post_bootstrap

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 90%\n')
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(Connector(), self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')
        d.addCallback(self.setup_complete_fails)
        return self.assertFailure(d, Exception)

    def test_tor_connection_user_data_dir(self):
        """
        Test that we don't delete a user-supplied data directory.
        """

        config = TorConfig()
        config.OrPort = 1234

        class Connector:
            def __call__(self, proto, trans):
                proto._set_valid_events('STATUS_CLIENT')
                proto.makeConnection(trans)
                proto.post_bootstrap.callback(proto)
                return proto.post_bootstrap

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 90%\n')
            proto.outReceived('Bootstrapped 100%\n')

        my_dir = tempfile.mkdtemp(prefix='tortmp')
        config.DataDirectory = my_dir
        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(Connector(), self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')

        def still_have_data_dir(proto, tester):
            proto.cleanup()  # FIXME? not really unit-testy as this is sort of internal function
            tester.assertTrue(os.path.exists(my_dir))
            delete_file_or_tree(my_dir)

        d.addCallback(still_have_data_dir, self)
        d.addErrback(self.fail)
        return d

    def test_tor_connection_user_control_port(self):
        """
        Confirm we use a user-supplied control-port properly
        """

        config = TorConfig()
        config.OrPort = 1234
        config.ControlPort = 4321

        class Connector:
            def __call__(self, proto, trans):
                proto._set_valid_events('STATUS_CLIENT')
                proto.makeConnection(trans)
                proto.post_bootstrap.callback(proto)
                return proto.post_bootstrap

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 90%\n')
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(Connector(), self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')

        def check_control_port(proto, tester):
            ## we just want to ensure launch_tor() didn't mess with
            ## the controlport we set
            tester.assertEquals(config.ControlPort, 4321)

        d.addCallback(check_control_port, self)
        d.addErrback(self.fail)
        return d

    def test_tor_connection_default_control_port(self):
        """
        Confirm a default control-port is set if not user-supplied.
        """

        config = TorConfig()

        class Connector:
            def __call__(self, proto, trans):
                proto._set_valid_events('STATUS_CLIENT')
                proto.makeConnection(trans)
                proto.post_bootstrap.callback(proto)
                return proto.post_bootstrap

        def on_protocol(proto):
            proto.outReceived('Bootstrapped 90%\n')
            proto.outReceived('Bootstrapped 100%\n')

        trans = FakeProcessTransport()
        trans.protocol = self.protocol
        self.othertrans = trans
        creator = functools.partial(Connector(), self.protocol, self.transport)
        d = launch_tor(config, FakeReactor(self, trans, on_protocol), connection_creator=creator, tor_binary='/bin/echo')

        def check_control_port(proto, tester):
            ## ensure ControlPort was set to a default value
            tester.assertEquals(config.ControlPort, 9052)

        d.addCallback(check_control_port, self)
        d.addErrback(self.fail)
        return d

    def confirm_progress(self, exp, *args, **kwargs):
        self.assertEqual(exp, args)
        self.got_progress = True

    def test_progress_updates(self):
        from txtorcon.torconfig import TorProcessProtocol

        self.got_progress = False
        proto = TorProcessProtocol(None, functools.partial(self.confirm_progress,
                                                           (10, 'tag', 'summary')))
        proto.progress(10, 'tag', 'summary')
        self.assertTrue(self.got_progress)

    def test_status_updates(self):
        from txtorcon.torconfig import TorProcessProtocol

        proto = TorProcessProtocol(None)
        proto.status_client("NOTICE CONSENSUS_ARRIVED")


class FakeProtocolFactory:
    implements(IProtocolFactory)

    def buildProtocol(self, addr):
        return None

    def doStart(self):
        return None

    def doStop(self):
        return None


class FakeListeningPort(object):
    implements(IListeningPort)

    def startListening(self):
        self.factory.doStart()

    def stopListening(self):
        self.factory.doStop()

    def getHost(self):
        return "host"


class FakeReactorTcp(object):
    implements(IReactorTCP)

    failures = 0

    def listenTCP(self, port, factory, **kwargs):
        if self.failures > 0:
            self.failures -= 1
            raise error.CannotListenError(None, None, None)

        p = FakeListeningPort()
        p.factory = factory
        p.startListening()
        return p


class EndpointTests(unittest.TestCase):

    def setUp(self):
        self.reactor = FakeReactorTcp()
        self.protocol = FakeControlProtocol([])
        self.config = TorConfig(self.protocol)

    def test_basic(self):
        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123)
        d = ep.listen(FakeProtocolFactory())
        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')
        self.config.bootstrap()
        self.assertEqual('127.0.0.1', ep.tcp_endpoint._interface)
        ## make sure _ListWrapper's __repr__ doesn't explode
        repr(self.config.HiddenServices)
        return d

    def test_multiple_listen(self):
        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123)
        d0 = ep.listen(FakeProtocolFactory())

        @defer.inlineCallbacks
        def more_listen(arg):
            yield arg.stopListening()
            d1 = ep.listen(FakeProtocolFactory())

            def foo(arg):
                return arg
            d1.addBoth(foo)
            defer.returnValue(arg)
            return
        d0.addBoth(more_listen)
        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')
        self.config.bootstrap()

        def check(arg):
            self.assertEqual('127.0.0.1', ep.tcp_endpoint._interface)
        d0.addCallback(check).addErrback(self.fail)
        return d0

    def test_bad_listener(self):
        def test_gen(*args, **kw):
            kw['interface'] = '0.0.0.0'
            return TCP4ServerEndpoint(*args, **kw)

        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123,
                                      endpoint_generator=test_gen)
        d = ep.listen(FakeProtocolFactory())

        class ErrorCallback(object):
            got_error = None

            def __call__(self, err, *args, **kw):
                self.got_error = err.value
        error_cb = ErrorCallback()
        d.addErrback(error_cb)

        ## enough answers so the config bootstraps properly
        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')
        self.config.bootstrap()

        ## now we should have attempted to listen on the endpoint our
        ## test_gen() is generating - which should be the "wrong"
        ## answer of anything (0.0.0.0)
        self.assertEqual('0.0.0.0', ep.tcp_endpoint._interface)

        ## ...and the point of this test; ensure we got an error
        ## trying to listen on not-127.*
        self.assertTrue(error_cb.got_error is not None)
        self.assertTrue(isinstance(error_cb.got_error, RuntimeError))
        return d

    def test_already_bootstrapped(self):
        self.protocol.answers.append('''config/names=
HiddenServiceOptions Virtual''')
        self.protocol.answers.append('HiddenServiceOptions')

        self.config.bootstrap()

        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123)
        d = ep.listen(FakeProtocolFactory())
        return d

    def test_explicit_data_dir(self):
        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123, '/mumble/mumble')
        d = ep.listen(FakeProtocolFactory())

        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')

        self.config.bootstrap()

        return d

    def test_explicit_data_dir_valid_hostname(self):
        datadir = tempfile.mkdtemp()
        with open(os.path.join(datadir, 'hostname'), 'w') as f:
            f.write('timaq4ygg2iegci7.onion')
        with open(os.path.join(datadir, 'private_key'), 'w') as f:
            f.write('foo\nbar')

        try:
            ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123, datadir)
            self.assertEqual(ep.onion_uri, 'timaq4ygg2iegci7.onion')
            self.assertEqual(ep.onion_private_key, 'foo\nbar')

        finally:
            shutil.rmtree(datadir, ignore_errors=True)

    def test_failure(self):
        self.reactor.failures = 2
        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123)
        d = ep.listen(FakeProtocolFactory())

        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')
        self.config.bootstrap()
        return d

    def check_error(self, failure):
        self.assertEqual(failure.type, error.CannotListenError)
        return None

    def test_too_many_failures(self):
        self.reactor.failures = 12
        ep = TCPHiddenServiceEndpoint(self.reactor, self.config, 123)
        d = ep.listen(FakeProtocolFactory())

        self.protocol.answers.append('config/names=\nHiddenServiceOptions Virtual')
        self.protocol.answers.append('HiddenServiceOptions')
        self.config.bootstrap()
        d.addErrback(self.check_error)
        return d


class ErrorTests(unittest.TestCase):
    def test_no_tor_binary(self):
        """FIXME: do I really need all this crap in here?"""
        from txtorcon import torconfig
        oldone = torconfig.find_tor_binary
        self.transport = proto_helpers.StringTransport()
        config = TorConfig()
        d = None

        class Connector:
            def __call__(self, proto, trans):
                proto._set_valid_events('STATUS_CLIENT')
                proto.makeConnection(trans)
                proto.post_bootstrap.callback(proto)
                return proto.post_bootstrap

        try:
            self.protocol = FakeControlProtocol([])
            torconfig.find_tor_binary = lambda: None
            trans = FakeProcessTransport()
            trans.protocol = self.protocol
            self.othertrans = trans
            creator = functools.partial(Connector(), self.protocol, self.transport)
            try:
                d = launch_tor(config, FakeReactor(self, trans, lambda x: None), connection_creator=creator)
                self.fail()

            except TorNotFound:
                pass  # success!
        finally:
            torconfig.find_tor_binary = oldone

        return d

########NEW FILE########
__FILENAME__ = test_torcontrolprotocol
from __future__ import with_statement

from twisted.python import log, failure
from twisted.trial import unittest
from twisted.test import proto_helpers
from twisted.internet import defer, error

from txtorcon import TorControlProtocol, TorProtocolFactory, TorState
from txtorcon import ITorControlProtocol
from txtorcon.torcontrolprotocol import parse_keywords, DEFAULT_VALUE
from txtorcon.util import hmac_sha256

import types
import functools
import tempfile
import base64


class CallbackChecker:
    def __init__(self, expected):
        self.expected_value = expected
        self.called_back = False

    def __call__(self, *args, **kwargs):
        v = args[0]
        if v != self.expected_value:
            print "WRONG"
            raise RuntimeError('Expected "%s" but got "%s"' % (self.expected_value, v))
        ##print "got correct value",v
        self.called_back = True
        return v


class InterfaceTests(unittest.TestCase):
    def test_implements(self):
        self.assertTrue(ITorControlProtocol.implementedBy(TorControlProtocol))

    def test_object_implements(self):
        self.assertTrue(ITorControlProtocol.providedBy(TorControlProtocol()))


class LogicTests(unittest.TestCase):

    def setUp(self):
        self.protocol = TorControlProtocol()
        self.protocol.connectionMade = lambda: None
        self.transport = proto_helpers.StringTransport()
        self.protocol.makeConnection(self.transport)

    def test_set_conf_wrong_args(self):
        ctl = TorControlProtocol()
        d = ctl.set_conf('a')
        self.assertTrue(d.called)
        self.assertTrue(d.result)
        self.assertTrue('even number' in d.result.getErrorMessage())
        ## ignore the error so trial doesn't get unhappy
        d.addErrback(lambda foo: True)
        return d


class FactoryTests(unittest.TestCase):
    def test_create(self):
        TorProtocolFactory().buildProtocol(None)


class AuthenticationTests(unittest.TestCase):

    def setUp(self):
        self.protocol = TorControlProtocol()
        self.transport = proto_helpers.StringTransport()

    def send(self, line):
        self.protocol.dataReceived(line.strip() + "\r\n")

    def test_authenticate_cookie(self):
        self.protocol.makeConnection(self.transport)
        self.assertEqual(self.transport.value(), 'PROTOCOLINFO 1\r\n')
        self.transport.clear()
        cookie_data = 'cookiedata!cookiedata!cookiedata'
        with open('authcookie', 'w') as f:
            f.write(cookie_data)
        self.send('250-PROTOCOLINFO 1')
        self.send('250-AUTH METHODS=COOKIE,HASHEDPASSWORD COOKIEFILE="authcookie"')
        self.send('250-VERSION Tor="0.2.2.34"')
        self.send('250 OK')

        self.assertEqual(self.transport.value(), 'AUTHENTICATE %s\r\n' % cookie_data.encode("hex"))

    def test_authenticate_password(self):
        self.protocol.password_function = lambda: 'foo'
        self.protocol.makeConnection(self.transport)
        self.assertEqual(self.transport.value(), 'PROTOCOLINFO 1\r\n')
        self.transport.clear()
        self.send('250-PROTOCOLINFO 1')
        self.send('250-AUTH METHODS=HASHEDPASSWORD')
        self.send('250-VERSION Tor="0.2.2.34"')
        self.send('250 OK')

        self.assertEqual(self.transport.value(), 'AUTHENTICATE %s\r\n' % "foo".encode("hex"))

    def test_authenticate_password_deferred(self):
        d = defer.Deferred()
        self.protocol.password_function = lambda: d
        self.protocol.makeConnection(self.transport)
        self.assertEqual(self.transport.value(), 'PROTOCOLINFO 1\r\n')
        self.transport.clear()
        self.send('250-PROTOCOLINFO 1')
        self.send('250-AUTH METHODS=HASHEDPASSWORD')
        self.send('250-VERSION Tor="0.2.2.34"')
        self.send('250 OK')

        ## make sure we haven't tried to authenticate before getting
        ## the password callback
        self.assertEqual(self.transport.value(), '')
        d.callback('foo')

        ## now make sure we DID try to authenticate
        self.assertEqual(self.transport.value(), 'AUTHENTICATE %s\r\n' % "foo".encode("hex"))

    def confirmAuthFailed(self, *args):
        self.auth_failed = True

    def test_authenticate_no_password(self):
        self.protocol.post_bootstrap.addErrback(self.confirmAuthFailed)
        self.auth_failed = False

        self.protocol.makeConnection(self.transport)
        self.assertEqual(self.transport.value(), 'PROTOCOLINFO 1\r\n')

        self.send('250-PROTOCOLINFO 1')
        self.send('250-AUTH METHODS=HASHEDPASSWORD')
        self.send('250-VERSION Tor="0.2.2.34"')
        self.send('250 OK')

        self.assertTrue(self.auth_failed)


class DisconnectionTests(unittest.TestCase):
    def setUp(self):
        self.protocol = TorControlProtocol()
        self.protocol.connectionMade = lambda: None
        self.transport = proto_helpers.StringTransportWithDisconnection()
        self.protocol.makeConnection(self.transport)
        ## why doesn't makeConnection do this?
        self.transport.protocol = self.protocol

    def tearDown(self):
        self.protocol = None

    def test_disconnect_callback(self):
        """
        see that we get our callback on_disconnect if the transport
        goes away
        """
        def it_was_called(*args):
            it_was_called.yes = True
            return None
        it_was_called.yes = False
        self.protocol.on_disconnect.addCallback(it_was_called).addErrback(it_was_called)
        f = failure.Failure(error.ConnectionDone("It's all over"))
        self.protocol.connectionLost(f)
        self.assertTrue(it_was_called.yes)

    def test_disconnect_errback(self):
        """
        see that we get our callback on_disconnect if the transport
        goes away
        """
        def it_was_called(*args):
            it_was_called.yes = True
            return None
        it_was_called.yes = False
        self.protocol.on_disconnect.addCallback(it_was_called).addErrback(it_was_called)
        f = failure.Failure(RuntimeError("The thing didn't do the stuff."))
        self.protocol.connectionLost(f)
        self.assertTrue(it_was_called.yes)


class ProtocolTests(unittest.TestCase):

    def setUp(self):
        self.protocol = TorControlProtocol()
        self.protocol.connectionMade = lambda: None
        self.transport = proto_helpers.StringTransport()
        self.protocol.makeConnection(self.transport)

    def tearDown(self):
        self.protocol = None

    def send(self, line):
        self.protocol.dataReceived(line.strip() + "\r\n")

    def test_statemachine_broadcast_no_code(self):
        try:
            self.protocol._broadcast_response("foo")
            self.fail()
        except RuntimeError, e:
            self.assertTrue('No code set yet' in str(e))

    def test_statemachine_broadcast_unknown_code(self):
        try:
            self.protocol.code = 999
            self.protocol._broadcast_response("foo")
            self.fail()
        except RuntimeError, e:
            self.assertTrue('Unknown code' in str(e))

    def test_statemachine_is_finish(self):
        self.assertTrue(not self.protocol._is_finish_line(''))
        self.assertTrue(self.protocol._is_finish_line('.'))
        self.assertTrue(self.protocol._is_finish_line('300 '))
        self.assertTrue(not self.protocol._is_finish_line('250-'))

    def test_statemachine_singleline(self):
        self.assertTrue(not self.protocol._is_single_line_response('foo'))

    def test_statemachine_continuation(self):
        try:
            self.protocol.code = 250
            self.protocol._is_continuation_line("123 ")
            self.fail()
        except RuntimeError, e:
            self.assertTrue('Unexpected code' in str(e))

    def test_statemachine_multiline(self):
        try:
            self.protocol.code = 250
            self.protocol._is_multi_line("123 ")
            self.fail()
        except RuntimeError, e:
            self.assertTrue('Unexpected code' in str(e))

    def auth_failed(self, msg):
        self.assertEqual(str(msg.value), '551 go away')
        self.got_auth_failed = True

    def test_authenticate_fail(self):
        self.got_auth_failed = False
        self.protocol._auth_failed = self.auth_failed

        self.protocol.password_function = lambda: 'foo'
        self.protocol._do_authenticate('''PROTOCOLINFO 1
AUTH METHODS=HASHEDPASSWORD
VERSION Tor="0.2.2.35"
OK''')
        self.send('551 go away\r\n')
        self.assertTrue(self.got_auth_failed)

    def test_authenticate_no_auth_line(self):
        try:
            self.protocol._do_authenticate('''PROTOCOLINFO 1
FOOAUTH METHODS=COOKIE,SAFECOOKIE COOKIEFILE="/dev/null"
VERSION Tor="0.2.2.35"
OK''')
            self.assertTrue(False)
        except RuntimeError, e:
            self.assertTrue('find AUTH line' in str(e))

    def test_authenticate_not_enough_cookie_data(self):
        with tempfile.NamedTemporaryFile() as cookietmp:
            cookietmp.write('x' * 35)  # too much data
            cookietmp.flush()

            try:
                self.protocol._do_authenticate('''PROTOCOLINFO 1
AUTH METHODS=COOKIE COOKIEFILE="%s"
VERSION Tor="0.2.2.35"
OK''' % cookietmp.name)
                self.assertTrue(False)
            except RuntimeError, e:
                self.assertTrue('cookie to be 32' in str(e))

    def test_authenticate_not_enough_safecookie_data(self):
        with tempfile.NamedTemporaryFile() as cookietmp:
            cookietmp.write('x' * 35)  # too much data
            cookietmp.flush()

            try:
                self.protocol._do_authenticate('''PROTOCOLINFO 1
AUTH METHODS=SAFECOOKIE COOKIEFILE="%s"
VERSION Tor="0.2.2.35"
OK''' % cookietmp.name)
                self.assertTrue(False)
            except RuntimeError, e:
                self.assertTrue('cookie to be 32' in str(e))

    def test_authenticate_safecookie(self):
        with tempfile.NamedTemporaryFile() as cookietmp:
            cookiedata = str(bytearray([0] * 32))
            cookietmp.write(cookiedata)
            cookietmp.flush()

            self.protocol._do_authenticate('''PROTOCOLINFO 1
AUTH METHODS=SAFECOOKIE COOKIEFILE="%s"
VERSION Tor="0.2.2.35"
OK''' % cookietmp.name)
            self.assertTrue('AUTHCHALLENGE SAFECOOKIE ' in self.transport.value())
            client_nonce = base64.b16decode(self.transport.value().split()[-1])
            self.transport.clear()
            server_nonce = str(bytearray([0] * 32))
            server_hash = hmac_sha256("Tor safe cookie authentication server-to-controller hash",
                                      cookiedata + client_nonce + server_nonce)

            self.send('250 AUTHCHALLENGE SERVERHASH=%s SERVERNONCE=%s' %
                      (base64.b16encode(server_hash), base64.b16encode(server_nonce)))
            self.assertTrue('AUTHENTICATE ' in self.transport.value())

    def test_authenticate_safecookie_wrong_hash(self):
        cookiedata = str(bytearray([0] * 32))
        server_nonce = str(bytearray([0] * 32))
        server_hash = str(bytearray([0] * 32))

        ## pretend we already did PROTOCOLINFO and read the cookie
        ## file
        self.protocol.cookie_data = cookiedata
        self.protocol.client_nonce = server_nonce  # all 0's anyway
        try:
            self.protocol._safecookie_authchallenge('250 AUTHCHALLENGE SERVERHASH=%s SERVERNONCE=%s' %
                                                    (base64.b16encode(server_hash), base64.b16encode(server_nonce)))
            self.assertTrue(False)
        except RuntimeError, e:
            self.assertTrue('hash not expected' in str(e))

    def confirm_version_events(self, arg):
        self.assertEqual(self.protocol.version, 'foo')
        events = 'GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL'.split()
        self.assertEqual(len(self.protocol.valid_events), len(events))
        self.assertTrue(all(x in self.protocol.valid_events for x in events))

    def test_bootstrap_callback(self):
        d = self.protocol.post_bootstrap
        d.addCallback(CallbackChecker(self.protocol))
        d.addCallback(self.confirm_version_events)

        events = 'GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL'
        self.protocol._bootstrap()

        ## answer all the requests generated by boostrapping etc.
        self.send("250-version=foo")
        self.send("250 OK")

        self.send("250-events/names=" + events)
        self.send("250 OK")

        self.send("250 OK")  # for USEFEATURE

        return d

    def test_async(self):
        """
        test the example from control-spec.txt to see that we
        handle interleaved async notifications properly.
        """
        self.protocol._set_valid_events('CIRC')
        self.protocol.add_event_listener('CIRC', lambda _: None)
        self.send("250 OK")

        d = self.protocol.get_conf("SOCKSPORT ORPORT")
        self.send("650 CIRC 1000 EXTENDED moria1,moria2")
        self.send("250-SOCKSPORT=9050")
        self.send("250 ORPORT=0")
        return d

    def test_async_multiline(self):
        ## same as above, but i think the 650's can be multline,
        ## too. Like:
        ## 650-CIRC 1000 EXTENDED moria1,moria2 0xBEEF
        ## 650-EXTRAMAGIC=99
        ## 650 ANONYMITY=high

        self.protocol._set_valid_events('CIRC')
        self.protocol.add_event_listener('CIRC', CallbackChecker("1000 EXTENDED moria1,moria2\nEXTRAMAGIC=99\nANONYMITY=high"))
        self.send("250 OK")

        d = self.protocol.get_conf("SOCKSPORT ORPORT")
        d.addCallback(CallbackChecker({"ORPORT": "0", "SOCKSPORT": "9050"}))
        self.send("650-CIRC 1000 EXTENDED moria1,moria2")
        self.send("650-EXTRAMAGIC=99")
        self.send("650 ANONYMITY=high")
        self.send("250-SOCKSPORT=9050")
        self.send("250 ORPORT=0")
        return d

    def test_multiline_plus(self):
        """
        """

        d = self.protocol.get_info("FOO")
        d.addCallback(CallbackChecker({"FOO": "\na\nb\nc"}))
        self.send("250+FOO=")
        self.send("a")
        self.send("b")
        self.send("c")
        self.send(".")
        self.send("250 OK")
        return d

    def incremental_check(self, expected, actual):
        if '=' in actual:
            return
        self.assertEqual(expected, actual)

    def test_getinfo_incremental(self):
        d = self.protocol.get_info_incremental("FOO", functools.partial(self.incremental_check, "bar"))
        self.send("250+FOO=")
        self.send("bar")
        self.send("bar")
        self.send(".")
        self.send("250 OK")
        return d

    def test_getinfo_incremental_continuation(self):
        d = self.protocol.get_info_incremental("FOO", functools.partial(self.incremental_check, "bar"))
        self.send("250-FOO=")
        self.send("250-bar")
        self.send("250-bar")
        self.send("250 OK")
        return d

    def test_getinfo_one_line(self):
        d = self.protocol.get_info("foo", functools.partial(self.incremental_check, "bar"))
        self.send('250 foo=bar')
        return d

    def test_getconf(self):
        d = self.protocol.get_conf("SOCKSPORT ORPORT")
        d.addCallback(CallbackChecker({'SocksPort': '9050', 'ORPort': '0'}))
        self.send("250-SocksPort=9050")
        self.send("250 ORPort=0")
        return d

    def test_getconf_raw(self):
        d = self.protocol.get_conf_raw("SOCKSPORT ORPORT")
        d.addCallback(CallbackChecker('SocksPort=9050\nORPort=0'))
        self.send("250-SocksPort=9050")
        self.send("250 ORPort=0")
        return d

    def response_ok(self, v):
        self.assertEqual(v, '')

    def test_setconf(self):
        d = self.protocol.set_conf("foo", "bar").addCallback(functools.partial(self.response_ok))
        self.send("250 OK")
        self._wait(d)
        self.assertEqual(self.transport.value(), "SETCONF foo=bar\r\n")

    def test_setconf_with_space(self):
        d = self.protocol.set_conf("foo", "a value with a space").addCallback(functools.partial(self.response_ok))
        self.send("250 OK")
        self._wait(d)
        self.assertEqual(self.transport.value(), 'SETCONF foo="a value with a space"\r\n')

    def test_setconf_multi(self):
        d = self.protocol.set_conf("foo", "bar", "baz", 1)
        self.send("250 OK")
        self._wait(d)
        self.assertEqual(self.transport.value(), "SETCONF foo=bar baz=1\r\n")

    def error(self, failure):
        print "ERROR", failure
        self.assertTrue(False)

    def test_twocommands(self):
        "Two commands on the wire before first response."
        d1 = self.protocol.get_conf("FOO")
        ht = {"a": "one", "b": "two"}
        d1.addCallback(CallbackChecker(ht)).addErrback(log.err)

        d2 = self.protocol.get_info_raw("BAR")
        d2.addCallback(CallbackChecker("bar")).addErrback(log.err)

        self.send("250-a=one")
        self.send("250-b=two")
        self.send("250 OK")
        self.send("250 bar")

        return d2

    def test_signal_error(self):
        try:
            self.protocol.signal('FOO')
            self.fail()
        except Exception, e:
            self.assertTrue('Invalid signal' in str(e))

    def test_signal(self):
        self.protocol.valid_signals = ['NEWNYM']
        self.protocol.signal('NEWNYM')
        self.assertEqual(self.transport.value(), 'SIGNAL NEWNYM\r\n')

    def test_650_after_authenticate(self):
        self.protocol._set_valid_events('CONF_CHANGED')
        self.protocol.add_event_listener('CONF_CHANGED', CallbackChecker("Foo=bar"))
        self.send("250 OK")

        self.send("650-CONF_CHANGED")
        self.send("650-Foo=bar")

    def test_notify_after_getinfo(self):
        self.protocol._set_valid_events('CIRC')
        self.protocol.add_event_listener('CIRC', CallbackChecker("1000 EXTENDED moria1,moria2"))
        self.send("250 OK")

        d = self.protocol.get_info("FOO")
        d.addCallback(CallbackChecker({'a': 'one'})).addErrback(self.fail)
        self.send("250-a=one")
        self.send("250 OK")
        self.send("650 CIRC 1000 EXTENDED moria1,moria2")
        return d

    def test_notify_error(self):
        self.protocol._set_valid_events('CIRC')

        try:
            self.send("650 CIRC 1000 EXTENDED moria1,moria2")
            self.assertTrue(False)
        except Exception, e:
            self.assertTrue("Wasn't listening" in str(e))

    def test_getinfo(self):
        d = self.protocol.get_info("version")
        d.addCallback(CallbackChecker({'version': '0.2.2.34'}))
        d.addErrback(self.fail)

        self.send("250-version=0.2.2.34")
        self.send("250 OK")

        self.assertEqual(self.transport.value(), "GETINFO version\r\n")
        return d

    def test_addevent(self):
        self.protocol._set_valid_events('FOO BAR')

        self.protocol.add_event_listener('FOO', lambda _: None)
        ## is it dangerous/ill-advised to depend on internal state of
        ## class under test?
        d = self.protocol.defer
        self.send("250 OK")
        self._wait(d)
        self.assertEqual(self.transport.value().split('\r\n')[-2], "SETEVENTS FOO")
        self.transport.clear()

        self.protocol.add_event_listener('BAR', lambda _: None)
        d = self.protocol.defer
        self.send("250 OK")
        self.assertTrue(self.transport.value() == "SETEVENTS FOO BAR\r\n" or
                        self.transport.value() == "SETEVENTS BAR FOO\r\n")
        self._wait(d)

        try:
            self.protocol.add_event_listener('SOMETHING_INVALID', lambda _: None)
            self.assertTrue(False)
        except:
            pass

    def test_eventlistener(self):
        self.protocol._set_valid_events('STREAM')

        class EventListener(object):
            stream_events = 0

            def __call__(self, data):
                self.stream_events += 1

        listener = EventListener()
        self.protocol.add_event_listener('STREAM', listener)

        d = self.protocol.defer
        self.send("250 OK")
        self._wait(d)
        self.send("650 STREAM 1234 NEW 4321 1.2.3.4:555 REASON=MISC")
        self.send("650 STREAM 2345 NEW 4321 2.3.4.5:666 REASON=MISC")
        self.assertEqual(listener.stream_events, 2)

    def test_remove_eventlistener(self):
        self.protocol._set_valid_events('STREAM')

        class EventListener(object):
            stream_events = 0

            def __call__(self, data):
                self.stream_events += 1

        listener = EventListener()
        self.protocol.add_event_listener('STREAM', listener)
        self.assertEqual(self.transport.value(), 'SETEVENTS STREAM\r\n')
        self.protocol.lineReceived("250 OK")
        self.transport.clear()
        self.protocol.remove_event_listener('STREAM', listener)
        self.assertEqual(self.transport.value(), 'SETEVENTS \r\n')

    def test_remove_eventlistener_multiple(self):
        self.protocol._set_valid_events('STREAM')

        class EventListener(object):
            stream_events = 0

            def __call__(self, data):
                self.stream_events += 1

        listener0 = EventListener()
        listener1 = EventListener()
        self.protocol.add_event_listener('STREAM', listener0)
        self.assertEqual(self.transport.value(), 'SETEVENTS STREAM\r\n')
        self.protocol.lineReceived("250 OK")
        self.transport.clear()
        ## add another one, shouldn't issue a tor command
        self.protocol.add_event_listener('STREAM', listener1)
        self.assertEqual(self.transport.value(), '')

        ## remove one, should still not issue a tor command
        self.protocol.remove_event_listener('STREAM', listener0)
        self.assertEqual(self.transport.value(), '')

        ## remove the other one, NOW should issue a command
        self.protocol.remove_event_listener('STREAM', listener1)
        self.assertEqual(self.transport.value(), 'SETEVENTS \r\n')

        ## try removing invalid event
        try:
            self.protocol.remove_event_listener('FOO', listener0)
            self.fail()
        except Exception, e:
            self.assertTrue('FOO' in str(e))

    def checkContinuation(self, v):
        self.assertEqual(v, "key=\nvalue0\nvalue1")

    def test_continuationLine(self):
        d = self.protocol.get_info_raw("key")

        d.addCallback(self.checkContinuation)

        self.send("250+key=")
        self.send("value0")
        self.send("value1")
        self.send(".")
        self.send("250 OK")

        return d

    def test_newdesc(self):
        """
        FIXME: this test is now maybe a little silly, it's just testing multiline GETINFO...
        (Real test is in TorStateTests.test_newdesc_parse)
        """

        self.protocol.get_info_raw('ns/id/624926802351575FF7E4E3D60EFA3BFB56E67E8A')
        d = self.protocol.defer
        d.addCallback(CallbackChecker("""ns/id/624926802351575FF7E4E3D60EFA3BFB56E67E8A=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid
w Bandwidth=518000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888"""))

        self.send("250+ns/id/624926802351575FF7E4E3D60EFA3BFB56E67E8A=")
        self.send("r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80")
        self.send("s Exit Fast Guard HSDir Named Running Stable V2Dir Valid")
        self.send("w Bandwidth=518000")
        self.send("p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888")
        self.send(".")
        self.send("250 OK")

        return d

    def test_plus_line_no_command(self):
        self.protocol.lineReceived("650+NS\r\n")
        self.protocol.lineReceived("r Gabor gFpAHsFOHGATy12ZUswRf0ZrqAU GG6GDp40cQfR3ODvkBT0r+Q09kw 2012-05-12 16:54:56 91.219.238.71 443 80\r\n")

    def test_minus_line_no_command(self):
        """
        haven't seen 600's use - "in the wild" but don't see why it's not possible
        """
        self.protocol._set_valid_events('NS')
        self.protocol.add_event_listener('NS', lambda _: None)
        self.protocol.lineReceived("650-NS\r\n")
        self.protocol.lineReceived("650 OK\r\n")


class ParseTests(unittest.TestCase):

    def setUp(self):
        self.controller = TorState(TorControlProtocol())
        self.controller.connectionMade = lambda _: None

    def test_keywords(self):
        x = parse_keywords('events/names=CIRC STREAM ORCONN BW DEBUG INFO NOTICE WARN ERR NEWDESC ADDRMAP AUTHDIR_NEWDESCS DESCCHANGED NS STATUS_GENERAL STATUS_CLIENT STATUS_SERVER GUARD STREAM_BW CLIENTS_SEEN NEWCONSENSUS BUILDTIMEOUT_SET')
        self.assertTrue('events/names' in x)
        self.assertEqual(x['events/names'], 'CIRC STREAM ORCONN BW DEBUG INFO NOTICE WARN ERR NEWDESC ADDRMAP AUTHDIR_NEWDESCS DESCCHANGED NS STATUS_GENERAL STATUS_CLIENT STATUS_SERVER GUARD STREAM_BW CLIENTS_SEEN NEWCONSENSUS BUILDTIMEOUT_SET')
        self.assertEqual(len(x.keys()), 1)

    def test_keywords_mutli_equals(self):
        x = parse_keywords('foo=something subvalue="foo"')
        self.assertEqual(len(x), 1)
        self.assertTrue('foo' in x)
        self.assertEqual(x['foo'], 'something subvalue="foo"')

    def test_default_keywords(self):
        x = parse_keywords('foo')
        self.assertEqual(len(x), 1)
        self.assertTrue('foo' in x)
        self.assertEqual(x['foo'], DEFAULT_VALUE)

    def test_multientry_keywords_2(self):
        x = parse_keywords('foo=bar\nfoo=zarimba')
        self.assertEqual(len(x), 1)
        self.assertTrue(isinstance(x['foo'], types.ListType))
        self.assertEqual(len(x['foo']), 2)
        self.assertEqual(x['foo'][0], 'bar')
        self.assertEqual(x['foo'][1], 'zarimba')

    def test_multientry_keywords_3(self):
        x = parse_keywords('foo=bar\nfoo=baz\nfoo=zarimba')
        self.assertEqual(len(x), 1)
        self.assertTrue(isinstance(x['foo'], types.ListType))
        self.assertEqual(len(x['foo']), 3)
        self.assertEqual(x['foo'][0], 'bar')
        self.assertEqual(x['foo'][1], 'baz')
        self.assertEqual(x['foo'][2], 'zarimba')

    def test_multientry_keywords_4(self):
        x = parse_keywords('foo=bar\nfoo=baz\nfoo=zarimba\nfoo=foo')
        self.assertEqual(len(x), 1)
        self.assertTrue(isinstance(x['foo'], types.ListType))
        self.assertEqual(len(x['foo']), 4)
        self.assertEqual(x['foo'][0], 'bar')
        self.assertEqual(x['foo'][1], 'baz')
        self.assertEqual(x['foo'][2], 'zarimba')
        self.assertEqual(x['foo'][3], 'foo')

    def test_multiline_keywords_with_spaces(self):
        x = parse_keywords('''ns/name/foo=
r foo aaaam7E7h1vY5Prk8v9/nSRCydY BBBBOfum4CtAYuOgf/D33Qq5+rk 2013-10-27 06:22:18 1.2.3.4 9001 9030
s Fast Guard HSDir Running Stable V2Dir Valid
w Bandwidth=1234
ns/name/bar=
r bar aaaaHgNYtTVPw5hHTO28J4je5i8 BBBBBUaJaBFSU/HDrTxnSh+D3+fY 2013-10-27 07:48:56 1.2.4.5 9001 9030
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid
w Bandwidth=1234
OK
''')
        self.assertEqual(2, len(x))
        keys = x.keys()
        keys.sort()
        self.assertEqual(keys, ['ns/name/bar', 'ns/name/foo'])

    def test_multiline_keywords(self):
        x = parse_keywords('''Foo=bar\nBar''')
        self.assertEqual(x, {'Foo': 'bar\nBar'})
        x = parse_keywords('''Foo=bar\nBar''', multiline_values=False)
        self.assertEqual(x, {'Foo': 'bar',
                             'Bar': DEFAULT_VALUE})

    def test_unquoted_keywords(self):
        x = parse_keywords('''Tor="0.1.2.3.4-rc44"''')
        self.assertEqual(x, {'Tor': '0.1.2.3.4-rc44'})

    def test_unquoted_keywords_singlequote(self):
        x = parse_keywords("Tor='0.1.2.3.4-rc44'")
        self.assertEqual(x, {'Tor': '0.1.2.3.4-rc44'})

    def test_unquoted_keywords_empty(self):
        x = parse_keywords('foo=')
        self.assertEqual(x, {'foo': ''})

    def test_network_status(self):
        self.controller._update_network_status("""ns/all=
r right2privassy3 ADQ6gCT3DiFHKPDFr3rODBUI8HM JehnjB8l4Js47dyjLCEmE8VJqao 2011-12-02 03:36:40 50.63.8.215 9023 0
s Exit Fast Named Running Stable Valid
w Bandwidth=53
p accept 80,1194,1220,1293,1500,1533,1677,1723,1863,2082-2083,2086-2087,2095-2096,2102-2104,3128,3389,3690,4321,4643,5050,5190,5222-5223,5228,5900,6660-6669,6679,6697,8000,8008,8074,8080,8087-8088,8443,8888,9418,9999-10000,19294,19638
r Unnamed AHe2V2pmj4Yfn0H9+Np3lci7htU T/g7ZLzG/ooqCn+gdLd9Jjh+AEI 2011-12-02 15:52:09 84.101.216.232 443 9030
s Exit Fast Running V2Dir Valid
w Bandwidth=33
p reject 25,119,135-139,445,563,1214,4661-4666,6346-6429,6699,6881-6999""")
        ## the routers list is always keyed with both name and hash
        self.assertEqual(len(self.controller.routers_by_name), 2)
        self.assertTrue('right2privassy3' in self.controller.routers)
        self.assertTrue('Unnamed' in self.controller.routers)

        self.controller.routers.clear()
        self.controller.routers_by_name.clear()

    def test_circuit_status(self):
        self.controller._update_network_status("""ns/all=
r wildnl f+Ty/+B6lgYr0Ntbf67O/L2M8ZI c1iK/kPPXKGZZvwXRWbvL9eCfSc 2011-12-02 19:07:05 209.159.142.164 9001 0
s Exit Fast Named Running Stable Valid
w Bandwidth=1900
p reject 25,119,135-139,445,563,1214,4661-4666,6346-6429,6699,6881-6999
r l0l wYXUpLBpzVWfzVSMgGO0dThdd38 KIJC+W1SHeaFOj/BVsEAgxbtQNM 2011-12-02 13:43:39 94.23.168.39 443 80
s Fast Named Running Stable V2Dir Valid
w Bandwidth=22800
p reject 1-65535
r Tecumseh /xAD0tFLS50Dkz+O37xGyVLoKlk yJHbad7MFl1VW2/23RxrPKBTOIE 2011-12-02 09:44:10 76.73.48.211 22 9030
s Fast Guard HSDir Named Running Stable V2Dir Valid
w Bandwidth=18700
p reject 1-65535""")
        self.controller._circuit_status("""circuit-status=
4472 BUILT $FF1003D2D14B4B9D03933F8EDFBC46C952E82A59=Tecumseh,$C185D4A4B069CD559FCD548C8063B475385D777F=l0l,$7FE4F2FFE07A96062BD0DB5B7FAECEFCBD8CF192=wildnl PURPOSE=GENERAL""")
        self.assertEqual(len(self.controller.circuits), 1)
        self.assertTrue(4472 in self.controller.circuits)

        self.controller.routers.clear()
        self.controller.routers_by_name.clear()
        self.controller.circuits.clear()

########NEW FILE########
__FILENAME__ = test_torinfo
from zope.interface import implements
from twisted.trial import unittest
from twisted.test import proto_helpers
from twisted.internet import defer

from txtorcon import ITorControlProtocol, TorInfo, TorControlProtocol


class FakeControlProtocol:
    """
    """

    implements(ITorControlProtocol)

    def __init__(self, answers):
        self.answers = answers
        self.post_bootstrap = defer.succeed(self)

    def get_info_raw(self, info):
        if len(self.answers) == 0:
            d = defer.Deferred()
            self.pending.append(d)
            return d

        d = defer.succeed(self.answers[0])
        self.answers = self.answers[1:]
        return d
    get_info = get_info_raw


class CheckAnswer:
    def __init__(self, test, ans):
        self.answer = ans
        self.test = test

    def __call__(self, x):
        self.test.assertEqual(x, self.answer)


class MagicContainerTests(unittest.TestCase):

    def test_repr(self):
        from txtorcon.torinfo import MagicContainer
        m = MagicContainer('foo')
        self.assertTrue(repr(m) == 'foo')
        self.assertTrue(str(m) == 'foo')

        m._setup_complete()
        self.assertTrue(repr(m) == 'foo')
        self.assertTrue(str(m) == 'foo')


class ProtocolIntegrationTests(unittest.TestCase):
    """
    Tests which use a real TorControlProtocol objects, not a mock.
    """

    def setUp(self):
        self.protocol = TorControlProtocol(lambda: defer.succeed('foo'))
        self.transport = proto_helpers.StringTransport()

    def send(self, line):
        self.protocol.dataReceived(line.strip() + "\r\n")

    @defer.inlineCallbacks
    def test_with_arg(self):
        info = TorInfo(self.protocol)
        pb = info.post_bootstrap

        ## now we hook up the protocol like it connected to a real Tor
        self.protocol.makeConnection(self.transport)

        ## answer all the requests generated by TorControlProtocol boostrapping etc.
        self.send('250-AUTH METHODS=PASSWORD')
        self.send('250 OK')

        ## response to AUTHENTICATE
        self.send('250 OK')

        ## now we're in _bootstrap() in TorControlProtocol()
        self.send("250-version=foo")
        self.send("250 OK")

        self.send("250-events/names=")
        self.send("250 OK")

        self.send("250 OK")  # for USEFEATURE

        ## do the TorInfo magic
        self.send('250-info/names=')
        self.send('250-multi/path/arg/* a documentation string')
        self.send('250 OK')

        ## we had to save this up above due to the "interesting" way
        ## TorInfo switches to become a possible-nice magic thingy
        ## that does attribute-access for you.
        yield pb

        self.assertTrue(hasattr(info, 'multi'))
        self.assertTrue(hasattr(getattr(info, 'multi'), 'path'))
        self.assertTrue(hasattr(getattr(getattr(info, 'multi'), 'path'), 'arg'))

        ## Finally! The test! We see if we can get this multi-path
        ## value with an argument...
        ## a "real" tor example is "net/listeners/socks" which shows
        ## up in info/names as "net/listeners/*"

        d = info.multi.path.arg('quux')
        d.addCallback(CheckAnswer(self, 'foo'))
        self.send("250-multi/path/arg/quux=foo")
        self.send("250 OK")
        yield d


class InfoTests(unittest.TestCase):

    def setUp(self):
        self.protocol = FakeControlProtocol([])

    def test_simple(self):
        self.protocol.answers.append('''info/names=
something a documentation string
multi/path a documentation string
''')
        info = TorInfo(self.protocol)
        self.assertTrue(hasattr(info, 'something'))
        self.assertTrue(hasattr(info, 'multi'))
        self.assertTrue(hasattr(getattr(info, 'multi'), 'path'))

        self.protocol.answers.append('something=\nfoo')

        d = info.something()
        d.addCallback(CheckAnswer(self, 'foo'))
        return d

    def test_same_prefix(self):
        self.protocol.answers.append('''info/names=
something/one a documentation string
something/two a second documentation string
''')
        info = TorInfo(self.protocol)

        self.assertTrue(hasattr(info, 'something'))
        self.assertTrue(hasattr(info.something, 'one'))
        self.assertTrue(hasattr(info.something, 'two'))

        self.protocol.answers.append('something/two=bar')

        d = info.something.two()
        d.addCallback(CheckAnswer(self, 'bar'))
        return d

    def test_attribute_access(self):
        '''
        test that our post-setup TorInfo pretends to only have
        attributes that correspond to (valid) GETINFO calls.
        '''

        self.protocol.answers.append('''info/names=
something/one a documentation string
something/two a second documentation string
''')
        info = TorInfo(self.protocol)

        self.assertTrue(dir(info) == ['something'])
        self.assertTrue(dir(info.something) == ['one', 'two'] or
                        dir(info.something) == ['two', 'one'])

    def test_iterator_access(self):
        '''
        confirm we can use the iterator protocol
        '''

        self.protocol.answers.append('''info/names=
something/one a documentation string
something/two a second documentation string
''')
        info = TorInfo(self.protocol)

        self.assertTrue(len(info) == 1)
        all = []
        for x in info:
            all.append(x)
        self.assertTrue(len(all) == 1)

        self.assertTrue(len(info.something) == 2)
        all = []
        for x in info.something:
            all.append(x)
        self.assertTrue(len(all) == 2)

    def handle_error(self, f):
        if 'Already had something' in f.getErrorMessage():
            self.error_happened = True

    def test_prefix_error(self):
        self.protocol.answers.append('''info/names=
something not allowed I hope
something/one a documentation string
''')
        self.error_happened = False
        TorInfo(self.protocol, self.handle_error)
        self.assertTrue(self.error_happened)

    def test_prefix_error_other_order(self):
        self.protocol.answers.append('''info/names=
other/one a documentation string
other not allowed I hope
''')
        self.error_happened = False
        TorInfo(self.protocol, self.handle_error)
        self.assertTrue(self.error_happened)

    def test_with_arg(self):
        self.protocol.answers.append('''info/names=
multi/path/arg/* a documentation string
''')
        info = TorInfo(self.protocol)
        self.assertTrue(hasattr(info, 'multi'))
        self.assertTrue(hasattr(getattr(info, 'multi'), 'path'))
        self.assertTrue(hasattr(getattr(getattr(info, 'multi'), 'path'), 'arg'))

        ## FIXME should have a test that "really" goes out through TorControlProtocol instance for this stuff...
        ## TorControlProtocol now strips the OK line...
        self.protocol.answers.append('multi/path/arg/quux=\nbar\nbaz\nquux')

        try:
            info.multi.path.arg()
            self.assertTrue(False)
        except TypeError:
            pass

        d = info.multi.path.arg('quux')
        d.addCallback(CheckAnswer(self, 'bar\nbaz\nquux'))
        return d

    def test_with_arg_error(self):
        self.protocol.answers.append('''info/names=
multi/no-arg docstring
''')
        info = TorInfo(self.protocol)

        try:
            info.multi.no_arg('an argument')
            self.assertTrue(False)
        except TypeError:
            pass

    def test_dump(self):
        self.protocol.answers.append('''info/names=
multi/path/arg/* a documentation string
''')
        info = TorInfo(self.protocol)
        info.dump()

    def test_config_star_workaround(self):
        '''
        ensure we ignore config/* for now
        '''

        self.protocol.answers.append('''info/names=
config/* a documentation string
''')
        info = TorInfo(self.protocol)
        self.assertTrue(dir(info) == [])

    def test_other_bootstrap(self):
        self.protocol.answers.append('''info/names=
multi/path/arg/* a documentation string
''')
        self.protocol.post_bootstrap = None
        TorInfo(self.protocol)

    def test_str(self):
        '''rather silly test to cover string creation'''
        self.protocol.answers.append('''info/names=
version docstring
foo/* bar
''')
        info = TorInfo(self.protocol)

        ## not the end of the world if this fails
        self.assertTrue(str(info.version) == "version()")
        self.assertTrue(str(info.foo) == "foo(arg)")

########NEW FILE########
__FILENAME__ = test_torstate
from zope.interface import implements
from zope.interface.verify import verifyClass
from twisted.trial import unittest
from twisted.test import proto_helpers
from twisted.internet import task, defer
from twisted.internet.interfaces import IStreamClientEndpoint, IReactorCore

import os
import tempfile

from txtorcon import TorControlProtocol, TorProtocolError, TorState, Stream, Circuit, build_tor_connection
from txtorcon.interface import ITorControlProtocol, IStreamAttacher, ICircuitListener, IStreamListener, StreamListenerMixin, CircuitListenerMixin


class CircuitListener(object):
    implements(ICircuitListener)

    def __init__(self, expected):
        "expect is a list of tuples: (event, {key:value, key1:value1, ..})"
        self.expected = expected

    def checker(self, state, circuit, arg=None):
        if self.expected[0][0] != state:
            raise RuntimeError('Expected event "%s" not "%s".' % (self.expected[0][0], state))
        for (k, v) in self.expected[0][1].items():
            if k == 'arg':
                if v != arg:
                    raise RuntimeError('Expected argument to have value "%s", not "%s"' % (arg, v))
            elif getattr(circuit, k) != v:
                raise RuntimeError('Expected attribute "%s" to have value "%s", not "%s"' % (k, v, getattr(circuit, k)))
        self.expected = self.expected[1:]

    def circuit_new(self, circuit):
        self.checker('new', circuit)

    def circuit_launched(self, circuit):
        self.checker('launched', circuit)

    def circuit_extend(self, circuit, router):
        self.checker('extend', circuit, router)

    def circuit_built(self, circuit):
        self.checker('built', circuit)

    def circuit_closed(self, circuit, **kw):
        self.checker('closed', circuit, **kw)

    def circuit_failed(self, circuit, **kw):
        self.checker('failed', circuit, **kw)


class StreamListener(object):
    implements(IStreamListener)

    def __init__(self, expected):
        "expect is a list of tuples: (event, {key:value, key1:value1, ..})"
        self.expected = expected

    def checker(self, state, stream, arg=None):
        if self.expected[0][0] != state:
            raise RuntimeError('Expected event "%s" not "%s".' % (self.expected[0][0], state))
        for (k, v) in self.expected[0][1].items():
            if k == 'arg':
                if v != arg:
                    raise RuntimeError('Expected argument to have value "%s", not "%s"' % (arg, v))
            elif getattr(stream, k) != v:
                raise RuntimeError('Expected attribute "%s" to have value "%s", not "%s"' % (k, v, getattr(stream, k)))
        self.expected = self.expected[1:]

    def stream_new(self, stream):
        self.checker('new', stream)

    def stream_succeeded(self, stream):
        self.checker('succeeded', stream)

    def stream_attach(self, stream, circuit):
        self.checker('attach', stream, circuit)

    def stream_closed(self, stream):
        self.checker('closed', stream)

    def stream_failed(self, stream, reason, remote_reason):
        self.checker('failed', stream, reason)


class FakeReactor:
    implements(IReactorCore)

    def __init__(self, test):
        self.test = test

    def addSystemEventTrigger(self, *args):
        self.test.assertEqual(args[0], 'before')
        self.test.assertEqual(args[1], 'shutdown')
        self.test.assertEqual(args[2], self.test.state.undo_attacher)
        return 1

    def removeSystemEventTrigger(self, id):
        self.test.assertEqual(id, 1)

    def connectTCP(self, *args, **kw):
        """for testing build_tor_connection"""
        raise RuntimeError('connectTCP: ' + str(args))

    def connectUNIX(self, *args, **kw):
        """for testing build_tor_connection"""
        raise RuntimeError('connectUNIX: ' + str(args))


class FakeCircuit:

    def __init__(self, id=-999):
        self.streams = []
        self.id = id
        self.state = 'BOGUS'


class FakeEndpoint:
    implements(IStreamClientEndpoint)

    def get_info_raw(self, keys):
        return defer.succeed('\r\n'.join(map(lambda k: '%s=' % k, keys.split())))

    def get_info_incremental(self, key, linecb):
        linecb('%s=' % key)
        return defer.succeed('')

    def connect(self, protocol_factory):
        self.proto = TorControlProtocol()
        self.proto.transport = proto_helpers.StringTransport()
        self.proto.get_info_raw = self.get_info_raw
        self.proto.get_info_incremental = self.get_info_incremental
        self.proto._set_valid_events('GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL')

        return defer.succeed(self.proto)


class FakeEndpointAnswers:
    implements(IStreamClientEndpoint)

    def __init__(self, answers):
        self.answers = answers
        # since we use pop() we need these to be "backwards"
        self.answers.reverse()

    def get_info_raw(self, keys):
        ans = ''
        for k in keys.split():
            if len(self.answers) == 0:
                raise TorProtocolError(551, "ran out of answers")
            ans += '%s=%s\r\n' % (k, self.answers.pop())
        return ans[:-2]                 # don't want trailing \r\n

    def get_info_incremental(self, key, linecb):
        linecb('%s=%s' % (key, self.answers.pop()))
        return defer.succeed('')

    def connect(self, protocol_factory):
        self.proto = TorControlProtocol()
        self.proto.transport = proto_helpers.StringTransport()
        self.proto.get_info_raw = self.get_info_raw
        self.proto.get_info_incremental = self.get_info_incremental
        self.proto._set_valid_events('GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL')

        return defer.succeed(self.proto)


class FakeControlProtocol:
    implements(ITorControlProtocol)  # actually we don't, it's a lie

    def __init__(self):
        self.is_owned = None
        self.post_bootstrap = defer.succeed(self)
        self.on_disconnect = defer.Deferred()


class InternalMethodsTests(unittest.TestCase):

    def test_state_diagram(self):
        TorState(FakeControlProtocol(), bootstrap=False, write_state_diagram=True)
        self.assertTrue(os.path.exists('routerfsm.dot'))


class BootstrapTests(unittest.TestCase):

    def confirm_proto(self, x):
        self.assertTrue(isinstance(x, TorControlProtocol))
        self.assertTrue(x.post_bootstrap.called)

    def confirm_state(self, x):
        self.assertTrue(isinstance(x, TorState))
        self.assertTrue(x.post_bootstrap.called)
        return x

    def test_build(self):
        p = FakeEndpoint()
        d = build_tor_connection(p, build_state=False)
        d.addCallback(self.confirm_proto)
        p.proto.post_bootstrap.callback(p.proto)
        return d

    def test_build_tcp(self):
        d = build_tor_connection((FakeReactor(self), '127.0.0.1', 1234))
        d.addCallback(self.fail)
        d.addErrback(lambda x: None)
        return d

    def test_build_unix(self):
        tf = tempfile.NamedTemporaryFile()
        d = build_tor_connection((FakeReactor(self), tf.name))
        d.addCallback(self.fail)
        d.addErrback(lambda x: None)
        return d

    def test_build_unix_wrong_permissions(self):
        self.assertRaises(ValueError, build_tor_connection, (FakeReactor(self), 'a non-existant filename'))

    def test_build_wrong_size_tuple(self):
        self.assertRaises(TypeError, build_tor_connection, (1, 2, 3, 4))

    def test_build_wrong_args_entirely(self):
        self.assertRaises(TypeError, build_tor_connection, 'incorrect argument')

    def confirm_pid(self, state):
        self.assertEqual(state.tor_pid, 1234)

    def confirm_no_pid(self, state):
        self.assertEqual(state.tor_pid, 0)

    def test_build_with_answers(self):
        p = FakeEndpointAnswers(['',     # ns/all
                                 '',     # circuit-status
                                 '',     # stream-status
                                 '',     # address-mappings/all
                                 '',     # entry-guards
                                 '1234'  # PID
                                 ])

        d = build_tor_connection(p, build_state=True)
        d.addCallback(self.confirm_state).addErrback(self.fail)
        d.addCallback(self.confirm_pid).addErrback(self.fail)
        p.proto.post_bootstrap.callback(p.proto)
        return d

    def test_build_with_answers_no_pid(self):
        p = FakeEndpointAnswers(['',    # ns/all
                                 '',    # circuit-status
                                 '',    # stream-status
                                 '',    # address-mappings/all
                                 ''     # entry-guards
                                 ])

        d = build_tor_connection(p, build_state=True)
        d.addCallback(self.confirm_state)
        d.addCallback(self.confirm_no_pid)
        p.proto.post_bootstrap.callback(p.proto)
        return d


class StateTests(unittest.TestCase):

    def setUp(self):
        self.protocol = TorControlProtocol()
        self.state = TorState(self.protocol)
        self.protocol.connectionMade = lambda: None
        self.transport = proto_helpers.StringTransport()
        self.protocol.makeConnection(self.transport)

    def test_close_stream_with_attacher(self):
        class MyAttacher(object):
            implements(IStreamAttacher)

            def __init__(self):
                self.streams = []

            def attach_stream(self, stream, circuits):
                self.streams.append(stream)
                return None

        attacher = MyAttacher()
        self.state.set_attacher(attacher, FakeReactor(self))
        self.state._stream_update("76 CLOSED 0 www.example.com:0 REASON=DONE")

    def test_stream_update(self):
        ## we use a circuit ID of 0 so it doesn't try to look anything up but it's
        ## not really correct to have a  SUCCEEDED w/o a valid circuit, I don't think
        self.state._stream_update('1610 SUCCEEDED 0 74.125.224.243:80')
        self.assertTrue(1610 in self.state.streams)

    def test_single_streams(self):
        self.state.circuits[496] = FakeCircuit(496)
        self.state._stream_status('stream-status=123 SUCCEEDED 496 www.example.com:6667')
        self.assertEqual(len(self.state.streams), 1)

    def send(self, line):
        self.protocol.dataReceived(line.strip() + "\r\n")

    def test_bootstrap_callback(self):
        '''
        FIXME: something is still screwy with this; try throwing an
        exception from TorState.bootstrap and we'll just hang...
        '''

        d = self.state.post_bootstrap

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250+circuit-status=")
        self.send(".")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250-address-mappings/all=")
        self.send("250 OK")

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        fakerouter = object()
        self.state.routers['$0000000000000000000000000000000000000000'] = fakerouter
        self.state.routers['$9999999999999999999999999999999999999999'] = fakerouter
        self.send("250+entry-guards=")
        self.send("$0000000000000000000000000000000000000000=name up")
        self.send("$1111111111111111111111111111111111111111=foo up")
        self.send("$9999999999999999999999999999999999999999=eman unusable 2012-01-01 22:00:00")
        self.send(".")
        self.send("250 OK")

        ## implicitly created Router object for the $1111...11 lookup
        ## but 0.0.0.0 will have to country, so Router will ask Tor
        ## for one via GETINFO ip-to-country
        self.send("250-ip-to-country/0.0.0.0=??")
        self.send("250 OK")

        self.assertEqual(len(self.state.entry_guards), 2)
        self.assertTrue('$0000000000000000000000000000000000000000' in self.state.entry_guards)
        self.assertEqual(self.state.entry_guards['$0000000000000000000000000000000000000000'], fakerouter)
        self.assertTrue('$1111111111111111111111111111111111111111' in self.state.entry_guards)

        self.assertEqual(len(self.state.unusable_entry_guards), 1)
        self.assertTrue('$9999999999999999999999999999999999999999' in self.state.unusable_entry_guards[0])

        return d

    def test_bootstrap_existing_addresses(self):
        '''
        FIXME: something is still screwy with this; try throwing an
        exception from TorState.bootstrap and we'll just hang...
        '''

        d = self.state.post_bootstrap

        clock = task.Clock()
        self.state.addrmap.scheduler = clock

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250+circuit-status=")
        self.send(".")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250+address-mappings/all=")
        self.send('www.example.com 127.0.0.1 "2012-01-01 00:00:00"')
        self.send('subdomain.example.com 10.0.0.0 "2012-01-01 00:01:02"')
        self.send('.')
        self.send('250 OK')

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("250-entry-guards=")
        self.send("250 OK")

        self.send("250 OK")

        self.assertEqual(len(self.state.addrmap.addr), 2)
        self.assertTrue('www.example.com' in self.state.addrmap.addr)
        self.assertTrue('subdomain.example.com' in self.state.addrmap.addr)

        return d

    def test_bootstrap_single_existing_circuit(self):
        '''
        test with exactly one circuit. should probably test with 2 as
        well, since there was a bug with the handling of just one.
        '''

        d = self.state.post_bootstrap

        clock = task.Clock()
        self.state.addrmap.scheduler = clock

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250-circuit-status=123 BUILT PURPOSE=GENERAL")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250+address-mappings/all=")
        self.send('.')
        self.send('250 OK')

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("250-entry-guards=")
        self.send("250 OK")

        self.send("250 OK")

        self.assertTrue(self.state.find_circuit(123))
        self.assertEquals(len(self.state.circuits), 1)

        return d

    def test_unset_attacher(self):

        class MyAttacher(object):
            implements(IStreamAttacher)

            def attach_stream(self, stream, circuits):
                return None

        fr = FakeReactor(self)
        self.state.set_attacher(MyAttacher(), fr)
        self.send("250 OK")
        self.state.set_attacher(None, fr)
        self.send("250 OK")
        self.assertEqual(self.transport.value(), 'SETCONF __LeaveStreamsUnattached=1\r\nSETCONF __LeaveStreamsUnattached=0\r\n')

    def test_attacher(self):
        class MyAttacher(object):
            implements(IStreamAttacher)

            def __init__(self):
                self.streams = []
                self.answer = None

            def attach_stream(self, stream, circuits):
                self.streams.append(stream)
                return self.answer

        attacher = MyAttacher()
        self.state.set_attacher(attacher, FakeReactor(self))
        events = 'GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL'
        self.protocol._set_valid_events(events)
        self.state._add_events()
        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("650 STREAM 1 NEW 0 ca.yahoo.com:80 SOURCE_ADDR=127.0.0.1:54327 PURPOSE=USER")
        self.send("650 STREAM 1 REMAP 0 87.248.112.181:80 SOURCE=CACHE")
        self.assertEqual(len(attacher.streams), 1)
        self.assertEqual(attacher.streams[0].id, 1)
        self.assertEqual(len(self.protocol.commands), 1)
        self.assertEqual(self.protocol.commands[0][1], 'ATTACHSTREAM 1 0')

        # we should totally ignore .exit URIs
        attacher.streams = []
        self.send("650 STREAM 2 NEW 0 10.0.0.0.$E11D2B2269CC25E67CA6C9FB5843497539A74FD0.exit:80 SOURCE_ADDR=127.0.0.1:12345 PURPOSE=TIME")
        self.assertEqual(len(attacher.streams), 0)
        self.assertEqual(len(self.protocol.commands), 1)

        # we should NOT ignore .onion URIs
        attacher.streams = []
        self.send("650 STREAM 3 NEW 0 xxxxxxxxxxxxxxxx.onion:80 SOURCE_ADDR=127.0.0.1:12345 PURPOSE=TIME")
        self.assertEqual(len(attacher.streams), 1)
        self.assertEqual(len(self.protocol.commands), 2)
        self.assertEqual(self.protocol.commands[1][1], 'ATTACHSTREAM 3 0')

        # normal attach
        circ = FakeCircuit(1)
        circ.state = 'BUILT'
        self.state.circuits[1] = circ
        attacher.answer = circ
        self.send("650 STREAM 4 NEW 0 xxxxxxxxxxxxxxxx.onion:80 SOURCE_ADDR=127.0.0.1:12345 PURPOSE=TIME")
        self.assertEqual(len(attacher.streams), 2)
        self.assertEqual(len(self.protocol.commands), 3)
        self.assertEqual(self.protocol.commands[2][1], 'ATTACHSTREAM 4 1')

    def test_attacher_defer(self):
        class MyAttacher(object):
            implements(IStreamAttacher)

            def __init__(self, answer):
                self.streams = []
                self.answer = answer

            def attach_stream(self, stream, circuits):
                self.streams.append(stream)
                return defer.succeed(self.answer)

        self.state.circuits[1] = FakeCircuit(1)
        attacher = MyAttacher(self.state.circuits[1])
        self.state.set_attacher(attacher, FakeReactor(self))

        ## boilerplate to finish enough set-up in the protocol so it
        ## works
        events = 'GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL'
        self.protocol._set_valid_events(events)
        self.state._add_events()
        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("650 STREAM 1 NEW 0 ca.yahoo.com:80 SOURCE_ADDR=127.0.0.1:54327 PURPOSE=USER")
        self.send("650 STREAM 1 REMAP 0 87.248.112.181:80 SOURCE=CACHE")
        self.assertEqual(len(attacher.streams), 1)
        self.assertEqual(attacher.streams[0].id, 1)
        self.assertEqual(len(self.protocol.commands), 1)
        self.assertEqual(self.protocol.commands[0][1], 'ATTACHSTREAM 1 1')

    def test_attacher_errors(self):
        class MyAttacher(object):
            implements(IStreamAttacher)

            def __init__(self, answer):
                self.streams = []
                self.answer = answer

            def attach_stream(self, stream, circuits):
                return self.answer

        self.state.circuits[1] = FakeCircuit(1)
        attacher = MyAttacher(FakeCircuit(2))
        self.state.set_attacher(attacher, FakeReactor(self))

        stream = Stream(self.state)
        stream.id = 3
        msg = ''
        try:
            self.state._maybe_attach(stream)
        except Exception, e:
            msg = str(e)
        self.assertTrue('circuit unknown' in msg)

        attacher.answer = self.state.circuits[1]
        msg = ''
        try:
            self.state._maybe_attach(stream)
        except Exception, e:
            msg = str(e)
        self.assertTrue('only attach to BUILT' in msg)

    def test_attacher_no_attach(self):
        class MyAttacher(object):
            implements(IStreamAttacher)

            def __init__(self):
                self.streams = []

            def attach_stream(self, stream, circuits):
                self.streams.append(stream)
                return TorState.DO_NOT_ATTACH

        attacher = MyAttacher()
        self.state.set_attacher(attacher, FakeReactor(self))
        events = 'GUARD STREAM CIRC NS NEWCONSENSUS ORCONN NEWDESC ADDRMAP STATUS_GENERAL'
        self.protocol._set_valid_events(events)
        self.state._add_events()
        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.transport.clear()
        self.send("650 STREAM 1 NEW 0 ca.yahoo.com:80 SOURCE_ADDR=127.0.0.1:54327 PURPOSE=USER")
        self.send("650 STREAM 1 REMAP 0 87.248.112.181:80 SOURCE=CACHE")
        self.assertEqual(len(attacher.streams), 1)
        self.assertEqual(attacher.streams[0].id, 1)
        print self.transport.value()
        self.assertEqual(self.transport.value(), '')

    def test_close_stream_with_id(self):
        stream = Stream(self.state)
        stream.id = 1

        self.state.streams[1] = stream
        self.state.close_stream(stream)
        self.assertEqual(self.transport.value(), 'CLOSESTREAM 1 1\r\n')

    def test_close_stream_with_stream(self):
        stream = Stream(self.state)
        stream.id = 1

        self.state.streams[1] = stream
        self.state.close_stream(stream.id)
        self.assertEqual(self.transport.value(), 'CLOSESTREAM 1 1\r\n')

    def test_close_stream_invalid_reason(self):
        stream = Stream(self.state)
        stream.id = 1
        self.state.streams[1] = stream
        self.assertRaises(ValueError, self.state.close_stream, stream, 'FOO_INVALID_REASON')

    def test_close_circuit_with_id(self):
        circuit = Circuit(self.state)
        circuit.id = 1

        self.state.circuits[1] = circuit
        self.state.close_circuit(circuit.id)
        self.assertEqual(self.transport.value(), 'CLOSECIRCUIT 1\r\n')

    def test_close_circuit_with_circuit(self):
        circuit = Circuit(self.state)
        circuit.id = 1

        self.state.circuits[1] = circuit
        self.state.close_circuit(circuit)
        self.assertEqual(self.transport.value(), 'CLOSECIRCUIT 1\r\n')

    def test_close_circuit_with_flags(self):
        circuit = Circuit(self.state)
        circuit.id = 1
        # try:
        #     self.state.close_circuit(circuit.id, IfUnused=True)
        #     self.assertTrue(False)
        # except KeyError:
        #     pass

        self.state.circuits[1] = circuit
        self.state.close_circuit(circuit.id, IfUnused=True)
        self.assertEqual(self.transport.value(), 'CLOSECIRCUIT 1 IfUnused\r\n')

    def test_circuit_destroy(self):
        self.state._circuit_update('365 LAUNCHED PURPOSE=GENERAL')
        self.assertTrue(365 in self.state.circuits)
        self.state._circuit_update('365 FAILED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=TIMEOUT')
        self.assertTrue(365 not in self.state.circuits)

    def test_circuit_destroy_already(self):
        self.state._circuit_update('365 LAUNCHED PURPOSE=GENERAL')
        self.assertTrue(365 in self.state.circuits)
        self.state._circuit_update('365 CLOSED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=TIMEOUT')
        self.assertTrue(365 not in self.state.circuits)
        self.state._circuit_update('365 CLOSED $E11D2B2269CC25E67CA6C9FB5843497539A74FD0=eris,$50DD343021E509EB3A5A7FD0D8A4F8364AFBDCB5=venus,$253DFF1838A2B7782BE7735F74E50090D46CA1BC=chomsky PURPOSE=GENERAL REASON=TIMEOUT')
        self.assertTrue(365 not in self.state.circuits)

    def test_circuit_listener(self):
        events = 'CIRC STREAM ORCONN BW DEBUG INFO NOTICE WARN ERR NEWDESC ADDRMAP AUTHDIR_NEWDESCS DESCCHANGED NS STATUS_GENERAL STATUS_CLIENT STATUS_SERVER GUARD STREAM_BW CLIENTS_SEEN NEWCONSENSUS BUILDTIMEOUT_SET'
        self.protocol._set_valid_events(events)
        self.state._add_events()
        for ignored in self.state.event_map.items():
            self.send("250 OK")

        ## we use this router later on in an EXTEND
        self.state._update_network_status("""ns/all=
r PPrivCom012 2CGDscCeHXeV/y1xFrq1EGqj5g4 QX7NVLwx7pwCuk6s8sxB4rdaCKI 2011-12-20 08:34:19 84.19.178.6 9001 0
s Fast Guard Running Stable Unnamed Valid
w Bandwidth=51500
p reject 1-65535""")

        expected = [('new', {'id':456}),
                    ('launched', {}),
                    ('extend', {'id':123})
                    ]
        listen = CircuitListener(expected)
        ## first add a Circuit before we listen
        self.protocol.dataReceived("650 CIRC 123 LAUNCHED PURPOSE=GENERAL\r\n")
        self.assertEqual(len(self.state.circuits), 1)

        ## make sure we get added to existing circuits
        self.state.add_circuit_listener(listen)
        self.assertTrue(listen in self.state.circuits.values()[0].listeners)

        ## now add a Circuit after we started listening
        self.protocol.dataReceived("650 CIRC 456 LAUNCHED PURPOSE=GENERAL\r\n")
        self.assertEqual(len(self.state.circuits), 2)
        self.assertTrue(listen in self.state.circuits.values()[0].listeners)
        self.assertTrue(listen in self.state.circuits.values()[1].listeners)

        ## now update the first Circuit to ensure we're really, really
        ## listening
        self.protocol.dataReceived("650 CIRC 123 EXTENDED $D82183B1C09E1D7795FF2D7116BAB5106AA3E60E~PPrivCom012 PURPOSE=GENERAL\r\n")
        self.assertEqual(len(listen.expected), 0)

    def test_router_from_id_invalid_key(self):
        self.failUnlessRaises(KeyError, self.state.router_from_id, 'somethingcompletelydifferent..thatis42long')

    def test_router_from_named_router(self):
        r = self.state.router_from_id('$AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=foo')
        self.assertEqual(r.id_hex, '$AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
        self.assertEqual(r.unique_name, 'foo')

    def confirm_router_state(self, x):
        self.assertTrue('$624926802351575FF7E4E3D60EFA3BFB56E67E8A' in self.state.routers)
        router = self.state.routers['$624926802351575FF7E4E3D60EFA3BFB56E67E8A']
        self.assertTrue('exit' in router.flags)
        self.assertTrue('fast' in router.flags)
        self.assertTrue('guard' in router.flags)
        self.assertTrue('hsdir' in router.flags)
        self.assertTrue('named' in router.flags)
        self.assertTrue('running' in router.flags)
        self.assertTrue('stable' in router.flags)
        self.assertTrue('v2dir' in router.flags)
        self.assertTrue('valid' in router.flags)
        self.assertTrue('futureproof' in router.flags)
        self.assertEqual(router.bandwidth, 518000)
        self.assertTrue(router.accepts_port(43))
        self.assertTrue(router.accepts_port(53))
        self.assertTrue(not router.accepts_port(44))
        self.assertTrue(router.accepts_port(989))
        self.assertTrue(router.accepts_port(990))
        self.assertTrue(not router.accepts_port(991))
        self.assertTrue(not router.accepts_port(988))

    def test_router_with_ipv6_address(self):
        self.state._update_network_status("""ns/all=
r PPrivCom012 2CGDscCeHXeV/y1xFrq1EGqj5g4 QX7NVLwx7pwCuk6s8sxB4rdaCKI 2011-12-20 08:34:19 84.19.178.6 9001 0
a [2001:0:0:0::0]:4321
s Fast Guard Running Stable Named Valid
w Bandwidth=51500
p reject 1-65535""")
        self.assertEqual(len(self.state.routers_by_name['PPrivCom012'][0].ip_v6), 1)
        self.assertEqual(self.state.routers_by_name['PPrivCom012'][0].ip_v6[0], '[2001:0:0:0::0]:4321')

    def test_invalid_routers(self):
        try:
            self.state._update_network_status('''ns/all=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=518000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888
.''')
            self.fail()

        except RuntimeError, e:
            self.assertTrue('"s "' in str(e))

    def test_routers_no_policy(self):
        """
        ensure we can parse a router descriptor which has no p line
        """

        self.state._update_network_status('''ns/all=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=518000
r PPrivCom012 2CGDscCeHXeV/y1xFrq1EGqj5g4 QX7NVLwx7pwCuk6s8sxB4rdaCKI 2011-12-20 08:34:19 84.19.178.6 9001 0
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=518000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888
.''')
        self.assertTrue('fake' in self.state.routers.keys())
        self.assertTrue('PPrivCom012' in self.state.routers.keys())

    def test_routers_no_bandwidth(self):
        """
        ensure we can parse a router descriptor which has no w line
        """

        self.state._update_network_status('''ns/all=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
r PPrivCom012 2CGDscCeHXeV/y1xFrq1EGqj5g4 QX7NVLwx7pwCuk6s8sxB4rdaCKI 2011-12-20 08:34:19 84.19.178.6 9001 0
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=518000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888
.''')
        self.assertTrue('fake' in self.state.routers.keys())
        self.assertTrue('PPrivCom012' in self.state.routers.keys())

    def test_router_factory(self):
        self.state._update_network_status('''ns/all=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=518000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888
r fake YxxmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof
w Bandwidth=543000
p accept 43,53
.''')
        self.assertTrue('$624926802351575FF7E4E3D60EFA3BFB56E67E8A' in self.state.routers)
        r = self.state.routers['$624926802351575FF7E4E3D60EFA3BFB56E67E8A']
        self.assertEqual(r.controller, self.state.protocol)
        self.assertEqual(r.bandwidth, 518000)
        self.assertEqual(len(self.state.routers_by_name['fake']), 2)

        ## now we do an update
        self.state._update_network_status('''ns/all=
r fake YkkmgCNRV1/35OPWDvo7+1bmfoo tanLV/4ZfzpYQW0xtGFqAa46foo 2011-12-12 16:29:16 12.45.56.78 443 80
s Exit Fast Guard HSDir Named Running Stable V2Dir Valid FutureProof Authority
w Bandwidth=543000
p accept 43,53,79-81,110,143,194,220,443,953,989-990,993,995,1194,1293,1723,1863,2082-2083,2086-2087,2095-2096,3128,4321,5050,5190,5222-5223,6679,6697,7771,8000,8008,8080-8081,8090,8118,8123,8181,8300,8443,8888
.''')
        self.assertEqual(r.bandwidth, 543000)

    def test_empty_stream_update(self):
        self.state._stream_update('''stream-status=''')

    def test_addrmap(self):
        self.state._addr_map('example.com 127.0.0.1 "2012-01-01 00:00:00" EXPIRES=NEVER')

    def test_double_newconsensus(self):
        """
        The arrival of a second NEWCONSENSUS event causes parsing
        errors.
        """

        ## bootstrap the TorState so we can send it a "real" 650
        ## update

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250+circuit-status=")
        self.send(".")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250-address-mappings/all=")
        self.send('250 OK')

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("250-entry-guards=")
        self.send("250 OK")

        self.send("250 OK")

        ## state is now bootstrapped, we can send our NEWCONSENSUS update

        self.protocol.dataReceived('\r\n'.join('''650+NEWCONSENSUS
r Unnamed ABJlguUFz1lvQS0jq8nhTdRiXEk /zIVUg1tKMUeyUBoyimzorbQN9E 2012-05-23 01:10:22 219.94.255.254 9001 0
s Fast Guard Running Stable Valid
w Bandwidth=166
p reject 1-65535
.
650 OK
'''.split('\n')))

        self.protocol.dataReceived('\r\n'.join('''650+NEWCONSENSUS
r Unnamed ABJlguUFz1lvQS0jq8nhTdRiXEk /zIVUg1tKMUeyUBoyimzorbQN9E 2012-05-23 01:10:22 219.94.255.254 9001 0
s Fast Guard Running Stable Valid
w Bandwidth=166
p reject 1-65535
.
650 OK
'''.split('\n')))

        self.assertTrue('Unnamed' in self.state.routers)
        self.assertTrue('$00126582E505CF596F412D23ABC9E14DD4625C49' in self.state.routers)

    def test_NEWCONSENSUS_ends_with_OK_on_w(self):
        """
        The arrival of a second NEWCONSENSUS event causes parsing
        errors.
        """

        ## bootstrap the TorState so we can send it a "real" 650
        ## update

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250+circuit-status=")
        self.send(".")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250-address-mappings/all=")
        self.send('250 OK')

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("250-entry-guards=")
        self.send("250 OK")

        self.send("250 OK")

        ## state is now bootstrapped, we can send our NEWCONSENSUS update

        self.protocol.dataReceived('\r\n'.join('''650+NEWCONSENSUS
r Unnamed ABJlguUFz1lvQS0jq8nhTdRiXEk /zIVUg1tKMUeyUBoyimzorbQN9E 2012-05-23 01:10:22 219.94.255.254 9001 0
s Fast Guard Running Stable Valid
w Bandwidth=166
.
650 OK
'''.split('\n')))

        self.assertTrue('Unnamed' in self.state.routers)
        self.assertTrue('$00126582E505CF596F412D23ABC9E14DD4625C49' in self.state.routers)

    def test_NEWCONSENSUS_ends_with_OK_on_s(self):
        """
        The arrival of a second NEWCONSENSUS event causes parsing
        errors.
        """

        ## bootstrap the TorState so we can send it a "real" 650
        ## update

        self.protocol._set_valid_events(' '.join(self.state.event_map.keys()))
        self.state._bootstrap()

        self.send("250+ns/all=")
        self.send(".")
        self.send("250 OK")

        self.send("250+circuit-status=")
        self.send(".")
        self.send("250 OK")

        self.send("250-stream-status=")
        self.send("250 OK")

        self.send("250-address-mappings/all=")
        self.send('250 OK')

        for ignored in self.state.event_map.items():
            self.send("250 OK")

        self.send("250-entry-guards=")
        self.send("250 OK")

        self.send("250 OK")

        ## state is now bootstrapped, we can send our NEWCONSENSUS update

        self.protocol.dataReceived('\r\n'.join('''650+NEWCONSENSUS
r Unnamed ABJlguUFz1lvQS0jq8nhTdRiXEk /zIVUg1tKMUeyUBoyimzorbQN9E 2012-05-23 01:10:22 219.94.255.254 9001 0
s Fast Guard Running Stable Valid
.
650 OK
'''.split('\n')))

        self.assertTrue('Unnamed' in self.state.routers)
        self.assertTrue('$00126582E505CF596F412D23ABC9E14DD4625C49' in self.state.routers)

    def test_stream_create(self):
        self.state._stream_update('1610 NEW 0 1.2.3.4:56')
        self.assertTrue(1610 in self.state.streams)

    def test_stream_destroy(self):
        self.state._stream_update('1610 NEW 0 1.2.3.4:56')
        self.assertTrue(1610 in self.state.streams)
        self.state._stream_update("1610 FAILED 0 www.example.com:0 REASON=DONE REMOTE_REASON=FAILED")
        self.assertTrue(1610 not in self.state.streams)

    def test_stream_detach(self):
        circ = FakeCircuit(1)
        circ.state = 'BUILT'
        self.state.circuits[1] = circ

        self.state._stream_update('1610 NEW 0 1.2.3.4:56')
        self.assertTrue(1610 in self.state.streams)
        self.state._stream_update("1610 SUCCEEDED 1 4.3.2.1:80")
        self.assertEqual(self.state.streams[1610].circuit, circ)

        self.state._stream_update("1610 DETACHED 0 www.example.com:0 REASON=DONE REMOTE_REASON=FAILED")
        self.assertEqual(self.state.streams[1610].circuit, None)

    def test_stream_listener(self):
        self.protocol._set_valid_events('CIRC STREAM ORCONN BW DEBUG INFO NOTICE WARN ERR NEWDESC ADDRMAP AUTHDIR_NEWDESCS DESCCHANGED NS STATUS_GENERAL STATUS_CLIENT STATUS_SERVER GUARD STREAM_BW CLIENTS_SEEN NEWCONSENSUS BUILDTIMEOUT_SET')
        self.state._add_events()
        for ignored in self.state.event_map.items():
            self.send("250 OK")

        expected = [('new', {}),
                    ]
        listen = StreamListener(expected)
        self.send("650 STREAM 77 NEW 0 www.yahoo.cn:80 SOURCE_ADDR=127.0.0.1:54315 PURPOSE=USER")
        self.state.add_stream_listener(listen)

        self.assertTrue(listen in self.state.streams.values()[0].listeners)
        self.assertEqual(len(self.state.streams), 1)
        self.assertEqual(len(listen.expected), 1)

        self.send("650 STREAM 78 NEW 0 www.yahoo.cn:80 SOURCE_ADDR=127.0.0.1:54315 PURPOSE=USER")
        self.assertEqual(len(self.state.streams), 2)
        self.assertEqual(len(listen.expected), 0)

    def test_build_circuit(self):
        class FakeRouter:
            def __init__(self, i):
                self.id_hex = i
                self.flags = []

        path = []
        for x in range(3):
            path.append(FakeRouter("$%040d" % x))
        ## can't just check flags for guard status, need to know if
        ## it's in the running Tor's notion of Entry Guards
        path[0].flags = ['guard']

        self.state.build_circuit(path)
        self.assertEqual(self.transport.value(), 'EXTENDCIRCUIT 0 0000000000000000000000000000000000000000,0000000000000000000000000000000000000001,0000000000000000000000000000000000000002\r\n')
        ## should have gotten a warning about this not being an entry
        ## guard
        self.assertEqual(len(self.flushWarnings()), 1)

    def test_build_circuit_no_routers(self):
        self.state.build_circuit()
        self.assertEqual(self.transport.value(), 'EXTENDCIRCUIT 0\r\n')

    def circuit_callback(self, circ):
        self.assertTrue(isinstance(circ, Circuit))
        self.assertEqual(circ.id, 1234)

    def test_build_circuit_final_callback(self):
        class FakeRouter:
            def __init__(self, i):
                self.id_hex = i
                self.flags = []

        path = []
        for x in range(3):
            path.append(FakeRouter("$%040d" % x))
        ## can't just check flags for guard status, need to know if
        ## it's in the running Tor's notion of Entry Guards
        path[0].flags = ['guard']

        ## FIXME TODO we should verify we get a circuit_new event for
        ## this circuit

        d = self.state.build_circuit(path)
        d.addCallback(self.circuit_callback)
        self.assertEqual(self.transport.value(), 'EXTENDCIRCUIT 0 0000000000000000000000000000000000000000,0000000000000000000000000000000000000001,0000000000000000000000000000000000000002\r\n')
        self.send('250 EXTENDED 1234')
        ## should have gotten a warning about this not being an entry
        ## guard
        self.assertEqual(len(self.flushWarnings()), 1)
        return d

    def test_build_circuit_error(self):
        """
        tests that we check the callback properly
        """

        try:
            self.state._find_circuit_after_extend("FOO 1234")
            self.assertTrue(False)
        except RuntimeError, e:
            self.assertTrue('Expected EXTENDED' in str(e))

    def test_listener_mixins(self):
        self.assertTrue(verifyClass(IStreamListener, StreamListenerMixin))
        self.assertTrue(verifyClass(ICircuitListener, CircuitListenerMixin))

########NEW FILE########
__FILENAME__ = test_util
from twisted.trial import unittest
from twisted.internet import defer
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet.interfaces import IProtocolFactory
from zope.interface import implements

from txtorcon.util import process_from_address, delete_file_or_tree, find_keywords, ip_from_int, find_tor_binary

import os
import tempfile


class FakeState:
    tor_pid = 0


class FakeProtocolFactory:
    implements(IProtocolFactory)

    def doStart(self):
        "IProtocolFactory API"

    def doStop(self):
        "IProtocolFactory API"

    def buildProtocol(self, addr):
        "IProtocolFactory API"
        return None


class TestIPFromInt(unittest.TestCase):

    def test_cast(self):
        self.assertEqual(ip_from_int(0x7f000001), '127.0.0.1')


class TestGeoIpDatabaseLoading(unittest.TestCase):

    def test_bad_geoip_path(self):
        "fail gracefully if a db is missing"
        from txtorcon import util
        self.assertRaises(IOError, util.create_geoip, '_missing_path_')


class TestFindKeywords(unittest.TestCase):

    def test_filter(self):
        "make sure we filter out keys that look like router IDs"
        self.assertEqual(find_keywords("foo=bar $1234567890=routername baz=quux".split()),
                         {'foo': 'bar', 'baz': 'quux'})


class FakeGeoIP(object):
    def __init__(self, version=2):
        self.version = version

    def record_by_addr(self, ip):
        r = dict(country_code='XX',
                 latitude=50.0,
                 longitude=0.0,
                 city='City')
        if self.version == 2:
            r['region_code'] = 'Region'
        else:
            r['region_name'] = 'Region'
        return r


class TestNetLocation(unittest.TestCase):

    def test_valid_lookup_v2(self):
        from txtorcon import util
        orig = util.city
        try:
            util.city = FakeGeoIP(version=2)
            nl = util.NetLocation('127.0.0.1')
            self.assertTrue(nl.city)
            self.assertEquals(nl.city[0], 'City')
            self.assertEquals(nl.city[1], 'Region')
        finally:
            util.ity = orig

    def test_valid_lookup_v3(self):
        from txtorcon import util
        orig = util.city
        try:
            util.city = FakeGeoIP(version=3)
            nl = util.NetLocation('127.0.0.1')
            self.assertTrue(nl.city)
            self.assertEquals(nl.city[0], 'City')
            self.assertEquals(nl.city[1], 'Region')
        finally:
            util.ity = orig

    def test_city_fails(self):
        "make sure we don't fail if the city lookup excepts"
        from txtorcon import util
        orig = util.city
        try:
            class Thrower(object):
                def record_by_addr(*args, **kw):
                    raise RuntimeError("testing failure")
            util.city = Thrower()
            nl = util.NetLocation('127.0.0.1')
            self.assertEqual(None, nl.city)

        finally:
            util.city = orig

    def test_no_city_db(self):
        "ensure we lookup from country if we have no city"
        from txtorcon import util
        origcity = util.city
        origcountry = util.country
        try:
            util.city = None
            obj = object()

            class CountryCoder(object):
                def country_code_by_addr(self, ipaddr):
                    return obj
            util.country = CountryCoder()
            nl = util.NetLocation('127.0.0.1')
            self.assertEqual(obj, nl.countrycode)

        finally:
            util.city = origcity
            util.country = origcountry

    def test_no_city_or_country_db(self):
        "ensure we lookup from asn if we have no city or country"
        from txtorcon import util
        origcity = util.city
        origcountry = util.country
        origasn = util.asn
        try:
            util.city = None
            util.country = None

            class Thrower:
                def org_by_addr(*args, **kw):
                    raise RuntimeError("testing failure")
            util.asn = Thrower()
            nl = util.NetLocation('127.0.0.1')
            self.assertEqual('', nl.countrycode)

        finally:
            util.city = origcity
            util.country = origcountry
            util.asn = origasn


class TestProcessFromUtil(unittest.TestCase):

    def setUp(self):
        self.fakestate = FakeState()

    def test_none(self):
        "ensure we do something useful on a None address"
        self.assertEqual(process_from_address(None, 80, self.fakestate), None)

    def test_internal(self):
        "look up the (Tor_internal) PID"
        pfa = process_from_address('(Tor_internal)', 80, self.fakestate)
        # depends on whether you have psutil installed or not, and on
        # whether your system always has a PID 0 process...
        self.assertEqual(pfa, self.fakestate.tor_pid)

    def test_internal_no_state(self):
        "look up the (Tor_internal) PID"
        pfa = process_from_address('(Tor_internal)', 80)
        # depends on whether you have psutil installed or not, and on
        # whether your system always has a PID 0 process...
        self.assertEqual(pfa, None)

    @defer.inlineCallbacks
    def test_real_addr(self):
        ## FIXME should choose a port which definitely isn't used.

        ## it's apparently frowned upon to use the "real" reactor in
        ## tests, but I was using "nc" before, and I think this is
        ## preferable.
        from twisted.internet import reactor
        listener = yield TCP4ServerEndpoint(reactor, 9887).listen(FakeProtocolFactory())

        try:
            pid = process_from_address('0.0.0.0', 9887, self.fakestate)
        finally:
            listener.stopListening()

        self.assertEqual(pid, os.getpid())


class TestDelete(unittest.TestCase):

    def test_delete_file(self):
        (fd, f) = tempfile.mkstemp()
        os.write(fd, 'some\ndata\n')
        os.close(fd)
        self.assertTrue(os.path.exists(f))
        delete_file_or_tree(f)
        self.assertTrue(not os.path.exists(f))

    def test_delete_tree(self):
        d = tempfile.mkdtemp()
        f = open(os.path.join(d, 'foo'), 'w')
        f.write('foo\n')
        f.close()

        self.assertTrue(os.path.exists(d))
        self.assertTrue(os.path.isdir(d))
        self.assertTrue(os.path.exists(os.path.join(d, 'foo')))

        delete_file_or_tree(d)

        self.assertTrue(not os.path.exists(d))
        self.assertTrue(not os.path.exists(os.path.join(d, 'foo')))


class TestFindTor(unittest.TestCase):

    def test_simple_find_tor(self):
        ## just test that this doesn't raise an exception
        find_tor_binary()

    def test_find_tor_globs(self):
        "test searching by globs"
        find_tor_binary(system_tor=False)

    def test_find_tor_unfound(self):
        "test searching by globs"
        self.assertEqual(None, find_tor_binary(system_tor=False, globs=()))

########NEW FILE########
__FILENAME__ = test_util_imports
from twisted.trial import unittest

import sys
import types
import functools


def fake_import(orig, name, *args, **kw):
    ##print "IMPORTING", name
    if name in ['GeoIP', 'ipaddr']:
        raise ImportError('testing!')
    return orig(*((name,) + args), **kw)


class TestImports(unittest.TestCase):

    def test_no_GeoIP(self):
        """
        Make sure we don't explode if there's no ipaddr module
        """

        global __import__
        orig = __import__
        try:
            # attempt to ensure we've unimportted txtorcon.util
            del sys.modules['txtorcon.util']
            import gc
            gc.collect()

            # replace global import with our test import, which will
            # throw on GeoIP import no matter what
            global __builtins__
            __builtins__['__import__'] = functools.partial(fake_import, orig)

            # now ensure we set up all the databases as "None" when we
            # import w/o the GeoIP thing available.
            import txtorcon.util
            ipa = txtorcon.util.maybe_ip_addr('127.0.0.1')
            self.assertTrue(isinstance(ipa, types.StringType))

        finally:
            __import__ = orig

    def test_no_ipaddr(self):
        """
        make sure the code we run if there's no GeoIP installed
        doesn't do anything horrific
        """

        global __import__
        orig = __import__
        try:
            # attempt to ensure we've unimportted txtorcon.util
            del sys.modules['txtorcon.util']
            import gc
            gc.collect()

            # replace global import with our test import, which will
            # throw on GeoIP import no matter what
            global __builtins__
            __builtins__['__import__'] = functools.partial(fake_import, orig)

            # now ensure we set up all the databases as "None" when we
            # import w/o the GeoIP thing available.
            import txtorcon.util
            self.assertEqual(None, txtorcon.util.city)
            self.assertEqual(None, txtorcon.util.asn)
            self.assertEqual(None, txtorcon.util.country)

        finally:
            __import__ = orig

########NEW FILE########
__FILENAME__ = addrmap
from txtorcon.interface import IAddrListener
from txtorcon.util import maybe_ip_addr

from twisted.internet.interfaces import IReactorTime
from twisted.internet import reactor

import datetime
import shlex


class Addr(object):
    """
    One address mapping (e.g. example.com -> 127.0.0.1)
    """

    def __init__(self, map):
        """
        map is an AddrMap instance, used for scheduling expiries and
        updating the map.
        """

        self.map = map

        self.ip = None
        self.name = None
        self.expiry = None
        self.expires = None
        self.created = None

    def update(self, *args):
        """
        deals with an update from Tor; see parsing logic in torcontroller
        """

        gmtexpires = None
        (name, ip, expires) = args[:3]

        for arg in args:
            if arg.lower().startswith('expires='):
                gmtexpires = arg[8:]

        if gmtexpires is None:
            if len(args) == 3:
                gmtexpires = expires
            elif len(args) > 3:
                if args[2] == 'NEVER':
                    gmtexpires = args[2]
                else:
                    gmtexpires = args[3]

        self.name = name                # "www.example.com"
        self.ip = maybe_ip_addr(ip)     # IPV4Address instance, or string

        if self.ip == '<error>':
            self._expire()
            return

        fmt = "%Y-%m-%d %H:%M:%S"

        ## if we already have expiry times, etc then we want to
        ## properly delay our timeout

        oldexpires = self.expires

        if gmtexpires.upper() == 'NEVER':
            ## FIXME can I just select a date 100 years in the future instead?
            self.expires = None
        else:
            self.expires = datetime.datetime.strptime(gmtexpires, fmt)
        self.created = datetime.datetime.utcnow()

        if self.expires is not None:
            if oldexpires is None:
                if self.expires <= self.created:
                    diff = datetime.timedelta(seconds=0)
                else:
                    diff = self.expires - self.created
                self.expiry = self.map.scheduler.callLater(diff.seconds, self._expire)

            else:
                diff = self.expires - oldexpires
                self.expiry.delay(diff.seconds)

    def _expire(self):
        """
        callback done via callLater
        """
        del self.map.addr[self.name]
        self.map.notify("addrmap_expired", *[self.name], **{})


class AddrMap(object):
    """
    A collection of Addr objects mapping domains to addresses, with
    automatic expiry.

    FIXME: need listener interface, so far:

    addrmap_added(Addr)
    addrmap_expired(name)
    """
    def __init__(self):
        self.addr = {}
        self.scheduler = IReactorTime(reactor)
        self.listeners = []

    def update(self, update):
        """
        Deal with an update from Tor; either creates a new Addr object
        or find existing one and calls update() on it.
        """

        params = shlex.split(update)
        if params[0] in self.addr:
            self.addr[params[0]].update(*params)

        else:
            a = Addr(self)
            self.addr[params[0]] = a
            a.update(*params)
            self.notify("addrmap_added", *[a], **{})

    def find(self, name_or_ip):
        "FIXME should make this class a dict-like (or subclass?)"
        return self.addr[name_or_ip]

    def notify(self, method, *args, **kwargs):
        for listener in self.listeners:
            getattr(listener, method)(*args, **kwargs)

    def add_listener(self, listener):
        if not listener in self.listeners:
            self.listeners.append(IAddrListener(listener))

########NEW FILE########
__FILENAME__ = circuit
import time
import datetime

from twisted.python import log
from twisted.internet import defer
from interface import IRouterContainer

from txtorcon.util import find_keywords

#look like "2014-01-25T02:12:14.593772"
TIME_FORMAT = '%Y-%m-%dT%H:%M:%S'


class Circuit(object):
    """
    Used by :class:`txtorcon.TorState` to represent one of Tor's circuits.

    This is kept up-to-date by the :class`txtorcon.TorState` that owns it, and
    individual circuits can be listened to for updates (or listen to
    every one using :meth:`txtorcon.TorState.add_circuit_listener`)

    :ivar path:
        contains a list of :class:`txtorcon.Router` objects
        representing the path this Circuit takes. Mostly this will be
        3 or 4 routers long. Note that internally Tor uses single-hop
        paths for some things. See also the *purpose*
        instance-variable.

    :ivar streams:
        contains a list of Stream objects representing all streams
        currently attached to this circuit.

    :ivar state:
        contains a string from Tor describing the current state of the
        stream. From control-spec.txt section 4.1.2, these are:

            - NEW: New request to connect
            - NEWRESOLVE: New request to resolve an address
            - REMAP: Address re-mapped to another
            - SENTCONNECT: Sent a connect cell along a circuit
            - SENTRESOLVE: Sent a resolve cell along a circuit
            - SUCCEEDED: Received a reply; stream established
            - FAILED: Stream failed and not retriable
            - CLOSED: Stream closed
            - DETACHED: Detached from circuit; still retriable

    :ivar purpose:
        The reason this circuit was built. Values can currently be one
        of (but see control-spec.txt 4.1.1):

          - GENERAL
          - HS_CLIENT_INTRO
          - HS_CLIENT_REND
          - HS_SERVICE_INTRO
          - HS_SERVICE_REND
          - TESTING
          - CONTROLLER

        For most purposes, you'll want to look at GENERAL circuits only.

    :ivar id:
        The ID of this circuit, a number (or None if unset).
    """

    def __init__(self, routercontainer):
        """
        :param routercontainer: should implement
        :class:`txtorcon.interface.IRouterContainer`.
        """
        self.listeners = []
        self.router_container = IRouterContainer(routercontainer)
        self.torstate = routercontainer
        self.path = []
        self.streams = []
        self.purpose = None
        self.id = None
        self.state = 'UNKNOWN'
        self.build_flags = []
        self.flags = {}

        ## this is used to hold a Deferred that will callback() when
        ## this circuit is being CLOSED or FAILED.
        self._closing_deferred = None

        ## caches parsed value for time_created()
        self._time_created = None

    @property
    def time_created(self):
        if self._time_created is not None:
            return self._time_created
        if 'TIME_CREATED' in self.flags:
            ## strip off milliseconds
            t = self.flags['TIME_CREATED'].split('.')[0]
            tstruct = time.strptime(t, TIME_FORMAT)
            self._time_created = datetime.datetime(*tstruct[:7])
        return self._time_created

    def listen(self, listener):
        if listener not in self.listeners:
            self.listeners.append(listener)

    def unlisten(self, listener):
        self.listeners.remove(listener)

    def close(self, **kw):
        """
        This asks Tor to close the underlying circuit object. See
        :method:`txtorcon.torstate.TorState.close_circuit`
        for details.

        You may pass keyword arguments to take care of any Flags Tor
        accepts for the CLOSECIRCUIT command. Currently, this is only
        "IfUnused". So for example: circ.close(IfUnused=True)

        :return: Deferred which callbacks with this Circuit instance
        ONLY after Tor has confirmed it is gone (not simply that the
        CLOSECIRCUIT command has been queued). This could be a while
        if you included IfUnused.
        """

        self._closing_deferred = defer.Deferred()

        def close_command_is_queued(*args):
            return self._closing_deferred
        d = self.torstate.close_circuit(self.id, **kw)
        d.addCallback(close_command_is_queued)
        return self._closing_deferred

    def age(self, now=datetime.datetime.now()):
        """
        Returns an integer which is the difference in seconds from
        'now' to when this circuit was created.

        Returns None if there is no created-time.
        """
        if not self.time_created:
            return None
        return (now - self.time_created).seconds

    def _create_flags(self, kw):
        "this clones the kw dict, adding a lower-case version of every key (duplicated in stream.py; put in util?)"

        flags = {}
        for k in kw.keys():
            flags[k] = kw[k]
            flags[k.lower()] = kw[k]
        return flags

    def update(self, args):
        ##print "Circuit.update:",args
        if self.id is None:
            self.id = int(args[0])
            [x.circuit_new(self) for x in self.listeners]

        else:
            if int(args[0]) != self.id:
                raise RuntimeError("Update for wrong circuit.")
        self.state = args[1]

        kw = find_keywords(args)
        self.flags = kw
        if 'PURPOSE' in kw:
            self.purpose = kw['PURPOSE']
        if 'BUILD_FLAGS' in kw:
            self.build_flags = kw['BUILD_FLAGS'].split(',')

        if self.state == 'LAUNCHED':
            self.path = []
            [x.circuit_launched(self) for x in self.listeners]
        else:
            if self.state != 'FAILED' and self.state != 'CLOSED' and len(args) > 2:
                self.update_path(args[2].split(','))

        if self.state == 'BUILT':
            [x.circuit_built(self) for x in self.listeners]

        elif self.state == 'CLOSED':
            if len(self.streams) > 0:
                ## FIXME it seems this can/does happen if a remote
                ## router crashes or otherwise shuts down a circuit
                ## with streams on it still
                log.err(RuntimeError("Circuit is %s but still has %d streams" %
                                     (self.state, len(self.streams))))
            flags = self._create_flags(kw)
            self.maybe_call_closing_deferred()
            [x.circuit_closed(self, **flags) for x in self.listeners]

        elif self.state == 'FAILED':
            if len(self.streams) > 0:
                log.err(RuntimeError("Circuit is %s but still has %d streams" %
                                     (self.state, len(self.streams))))
            flags = self._create_flags(kw)
            self.maybe_call_closing_deferred()
            [x.circuit_failed(self, **flags) for x in self.listeners]

    def maybe_call_closing_deferred(self):
        """
        Used internally to callback on the _closing_deferred if it
        exists.
        """

        if self._closing_deferred:
            self._closing_deferred.callback(self)
            self._closing_deferred = None

    def update_path(self, path):
        """
        There are EXTENDED messages which don't include any routers at
        all, and any of the EXTENDED messages may have some arbitrary
        flags in them. So far, they're all upper-case and none start
        with $ luckily. The routers in the path should all be
        LongName-style router names (this depends on them starting
        with $).

        For further complication, it's possible to extend a circuit to
        a router which isn't in the consensus. nickm via #tor thought
        this might happen in the case of hidden services choosing a
        rendevouz point not in the current consensus.
        """

        oldpath = self.path
        self.path = []
        for p in path:
            if p[0] != '$':
                break

            ## this will create a Router if we give it a router
            ## LongName that doesn't yet exist
            router = self.router_container.router_from_id(p)

            self.path.append(router)
            if len(self.path) > len(oldpath):
                [x.circuit_extend(self, router) for x in self.listeners]
                oldpath = self.path

    def __str__(self):
        return "<Circuit %d %s [%s] for %s>" % (self.id, self.state, ' '.join(map(lambda x: x.ip, self.path)), self.purpose)

########NEW FILE########
__FILENAME__ = interface
from zope.interface import implements, Interface, Attribute


class IStreamListener(Interface):
    """
    Notifications about changes to a :class:`txtorcon.Stream`.

    If you wish for your listener to be added to *all* new streams,
    see :meth:`txtorcon.TorState.add_stream_listener`.
    """

    def stream_new(stream):
        "a new stream has been created"

    def stream_succeeded(stream):
        "stream has succeeded"

    def stream_attach(stream, circuit):
        "the stream has been attached to a circuit"

    def stream_detach(stream, **kw):
        """
        the stream has been detached from its circuit

        :param kw:
            provides any flags for this event, which will include at
            least REASON (but may include anything). See control-spec.
        """

    def stream_closed(stream, **kw):
        """
        stream has been closed (won't be in controller's list anymore).

        :param kw:
            provides any flags for this event, which will include at
            least REASON (but may include anything). See control-spec.
        """

    def stream_failed(stream, **kw):
        """
        stream failed for some reason (won't be in controller's list anymore).

        :param kw:
            a dict of all the flags for the stream failure; see
            control-spec but these will include REASON and sometimes
            REMOTE_REASON (if the remote Tor closed the
            connection). Both an all-uppercase and all-lowercase
            version of each keyword is supplied (by the library; Tor
            provides all-uppercase only). Others may include
            BUILD_FLAGS, PURPOSE, HS_STATE, REND_QUERY, TIME_CREATED
            (or anything else).
        """


class StreamListenerMixin(object):
    """
    Implements all of :class:`txtorcon.IStreamListener` with no-op
    methods. You may subclass from this if you don't care about most
    of the notifications.
    """

    implements(IStreamListener)

    def stream_new(self, stream):
        pass

    def stream_succeeded(self, stream):
        pass

    def stream_attach(self, stream, circuit):
        pass

    def stream_detach(self, stream, **kw):
        pass

    def stream_closed(self, stream, **kw):
        pass

    def stream_failed(self, stream, **kw):
        pass


class IStreamAttacher(Interface):
    """
    Used by :class:`txtorcon.TorState` to map streams to circuits (see
    :meth:`txtorcon.TorState.set_attacher`).

    Each time a new :class:`txtorcon.Stream` is created, this
    interface will be queried to find out which
    :class:`txtorcon.Circuit` it should be attached to.
    """

    def attach_stream(stream, circuits):
        """
        :param stream:
            The stream to attach, which will be in NEW or NEWRESOLVE
            state.

        :param circuits:
            all currently available :class:`txtorcon.Circuit` objects
            in the :class:`txtorcon.TorState` in a dict indexed by id.
            Note they are *not* limited to BUILT circuits.

        You should return a :class:`txtorcon.Circuit` instance which
        should be at state BUILT in the currently running Tor. You may
        also return a Deferred which will callback with the desired
        circuit. In this case, you will probably need to be aware that
        the callback from :meth:`txtorcon.TorState.build_circuit` does
        NOT call back with a Circuit (just Tor's response of 'EXTEND
        1234') and any circuit you do return must be in the BUILT
        state anyway (which the above will not).

        See :ref:`attach_streams_by_country.py` for a complete
        example of using a Deferred in an IStreamAttacher.

        Alternatively, you may return None in which case the Tor
        controller will be told to choose a circuit itself.

        Note that Tor will refuse to attach to any circuit not in
        BUILT state; see ATTACHSTREAM in control-spec.txt

        Note also that although you get a request to attach a stream
        that ends in .onion Tor doesn't currently let you specify how
        to attach .onion addresses and will always give a 551 error.
        """


class ICircuitContainer(Interface):
    """
    An interface that contains a bunch of Circuit objects and can look
    them up by id.
    """

    def find_circuit(id):
        ":return: a circuit for the id, or exception."

    def close_circuit(circuit, **kwargs):
        """
        Close a circuit.
        :return: a Deferred which callbacks when the closing process
        is started (not necessarily finished inside Tor).
        """

    ## FIXME do we need an IStreamContainer that Stream instances get?
    ## (Currently, they get an ICircuitContainer...)
    def close_stream(stream, **kwargs):
        """
        Close a stream.
        :return: a Deferred which callbacks when the closing process
        is started (not necessarily finished inside Tor).
        """


class ICircuitListener(Interface):
    """
    An interface to listen for updates to Circuits.
    """

    def circuit_new(circuit):
        """A new circuit has been created.  You'll always get one of
        these for every Circuit even if it doesn't go through the "launched"
        state."""

    def circuit_launched(circuit):
        "A new circuit has been started."

    def circuit_extend(circuit, router):
        "A circuit has been extended to include a new router hop."

    def circuit_built(circuit):
        """
        A circuit has been extended to all hops (usually 3 for user
        circuits).
        """

    def circuit_closed(circuit, **kw):
        """
        A circuit has been closed cleanly (won't be in controller's list any more).

        :param kw:
            A dict of additional args. REASON is alsways included, and
            often REMOTE_REASON also. See the control-spec
            documentation.  As of this writing, REASON is one of the
            following strings: MISC, RESOLVEFAILED, CONNECTREFUSED,
            EXITPOLICY, DESTROY, DONE, TIMEOUT, NOROUTE, HIBERNATING,
            INTERNAL,RESOURCELIMIT, CONNRESET, TORPROTOCOL,
            NOTDIRECTORY, END, PRIVATE_ADDR. However, don't depend on
            that: it could be anything.

            To facilitate declaring args you want in the method
            (e.g. circuit_failed(self, circuit, reason=None,
            remote_reason=None, **kw)) lower-case versions of all the
            keys are also provided (pointing to the same -- usually
            UPPERCASE -- strings as the upper-case keys).
        """

    def circuit_failed(circuit, **kw):
        """
        A circuit has been closed because something went wrong.

        The circuit won't be in the TorState's list anymore.

        :param kw:
            A dict of additional args. REASON is alsways included, and
            often REMOTE_REASON also. See the control-spec
            documentation.  As of this writing, REASON is one of the
            following strings: MISC, RESOLVEFAILED, CONNECTREFUSED,
            EXITPOLICY, DESTROY, DONE, TIMEOUT, NOROUTE, HIBERNATING,
            INTERNAL,RESOURCELIMIT, CONNRESET, TORPROTOCOL,
            NOTDIRECTORY, END, PRIVATE_ADDR. However, don't depend on
            that: it could be anything.

            To facilitate declaring args you want in the method
            (e.g. circuit_failed(self, circuit, reason=None,
            remote_reason=None, **kw)) lower-case versions of all the
            keys are also provided (pointing to the same -- usually
            UPPERCASE -- strings as the upper-case keys).
        """


class CircuitListenerMixin(object):
    """
    Implements all of ICircuitListener with no-op methods. Subclass
    from this if you don't care about most of the notifications.
    """
    implements(ICircuitListener)

    def circuit_new(self, circuit):
        pass

    def circuit_launched(self, circuit):
        pass

    def circuit_extend(self, circuit, router):
        pass

    def circuit_built(self, circuit):
        pass

    def circuit_closed(self, circuit, **kw):
        pass

    def circuit_failed(self, circuit, **kw):
        pass


class ITorControlProtocol(Interface):
    """
    This defines the API to the TorController object.

    This is the usual entry-point to this library, and you shouldn't
    need to call methods outside this interface.
    """

    def get_info(info):
        """
        :return: a Deferred which will callback with the info keys you
           asked for. For values ones, see control-spec.
        """

    def get_conf(*args):
        """
        Returns one or many configuration values via Deferred. See
        control-spec for valid keys. The value will be a dictionary.
        """

    def signal(signal_name):
        """
        Issues a signal to Tor. See control-spec or .valid_signals for
        which ones are available and their return values.
        """

    def build_circuit(routers):
        """
        Builds a circuit consisting of exactly the routers specified,
        in order.  This issues a series of EXTENDCIRCUIT calls to Tor;
        the deferred returned from this is for the final
        EXTEND. FIXME: should return the Circuit instance, but
        currently returns final extend message 'EXTEND 1234' for
        example.
        """

    def close_circuit(circuit):
        """
        Asks Tor to close the circuit. Note that the Circuit instance
        is only removed as a result of the next CIRC CLOSED event. The
        Deferred returned from this method callbacks when the
        CLOSECIRCUIT command has successfully executed, not when the
        circuit is actually gone.

        If you wish to know when this circuit is actually gone, add an
        ICircuitListener and wait for circuit_closed()
        """

    def add_circuit_listener(icircuitlistener):
        """
        Add an implementor of :class:`txtorcon.interface.ICircuitListener`
        which will be added to all new circuits as well as all
        existing ones (you won't, however, get circuit_new calls for
        the existing ones)
        """

    def add_stream_listener(istreamlistener):
        """
        Add an implementor of :class:`txtorcon.interface.IStreamListener`
        which will be added to all new circuits as well as all
        existing ones (you won't, however, get stream_new calls for
        the existing ones)
        """

    def add_event_listener(evt, callback):
        """
        Add a listener to an Event object. This may be called multiple
        times for the same event. Every time the event happens, the
        callback method will be called. The callback has one argument
        (a string, the contents of the event, minus the '650' and the
        name of the event)

        FIXME: should have an interface for the callback.
        """


class IRouterContainer(Interface):

    unique_routers = Attribute("contains a list of all the Router instances")

    def router_from_id(routerid):
        """
        Note that this method MUST always return a Router instance --
        if you ask for a router ID that didn't yet exist, it is
        created (although without IP addresses and such because it
        wasn't in the consensus). You may find out if a Router came
        from the 'GETINFO ns/all' list by checking the from_consensus
        attribute. This is to simplify code like in Circuit.update()
        that needs to handle the case where an EXTENDED circuit event
        is the only time we've seen a Router -- it's possible for Tor
        to do things with routers not in the consensus (like extend
        circuits to them).

        :return: a router by its ID.
        """


class IAddrListener(Interface):
    def addrmap_added(addr):
        """
        A new address was added to the address map.
        """

    def addrmap_expired(name):
        """
        An address has expired from the address map.
        """

########NEW FILE########
__FILENAME__ = log
"""
This module handles txtorcon debug messages.
"""

from twisted.python import log as twlog

__all__ = ['txtorlog']

txtorlog = twlog.LogPublisher()


def debug_logging():
    stdobserver = twlog.PythonLoggingObserver('txtorcon')
    fileobserver = twlog.FileLogObserver(open('txtorcon.log', 'w'))

    txtorlog.addObserver(stdobserver.emit)
    txtorlog.addObserver(fileobserver.emit)

########NEW FILE########
__FILENAME__ = router
from util import NetLocation
import types


def hexIdFromHash(thehash):
    """
    From the base-64 encoded hashes Tor uses, this produces the longer
    hex-encoded hashes.
    """
    return "$" + (thehash + "=").decode("base64").encode("hex").upper()


def hashFromHexId(hexid):
    """
    From a hex fingerprint id, convert back to base-64 encoded value.
    """
    if hexid[0] == '$':
        hexid = hexid[1:]
    return hexid.decode("hex").encode("base64")[:-2]


class PortRange(object):
    """
    Represents a range of ports for Router policies.
    """
    def __init__(self, a, b):
        self.min = a
        self.max = b

    def __cmp__(self, b):
        if b >= self.min and b <= self.max:
            return 0
        return 1

    def __str__(self):
        return "%d-%d" % (self.min, self.max)


class Router(object):
    """
    Represents a Tor Router, including location.

    The controller you pass in is really only used to do get_info
    calls for ip-to-country/IP in case the
    :class:`txtorcon.util.NetLocation` stuff fails to find a country.

    After an .update() call, the id_hex attribute contains a
    hex-encoded long hash (suitable, for example, to use in a
    ``GETINFO ns/id/*`` call).

    After setting the policy property you may call accepts_port() to
    find out if the router will accept a given port. This works with
    the reject or accept based policies.
    """

    def __init__(self, controller):
        self.controller = controller
        self._flags = []
        self.bandwidth = 0
        self.name_is_unique = False
        self.accepted_ports = None
        self.rejected_ports = None
        self.id_hex = None
        self._location = None
        self.from_consensus = False
        self.ip = 'unknown'
        self.ip_v6 = []                 # most routers have no IPv6 addresses

    unique_name = property(lambda x: x.name_is_unique and x.name or x.id_hex)
    "has the hex id if this router's name is not unique, or its name otherwise"

    def update(self, name, idhash, orhash, modified, ip, orport, dirport):
        self.name = name
        self.id_hash = idhash
        self.or_hash = orhash
        self.modified = modified
        self.ip = ip
        self.or_port = orport
        self.dir_port = dirport
        self._location = None

        self.id_hex = hexIdFromHash(self.id_hash)

    @property
    def location(self):
        """
        A NetLocation instance with some GeoIP or pygeoip information
        about location, asn, city (if available).
        """
        if self._location:
            return self._location

        if self.ip != 'unknown':
            self._location = NetLocation(self.ip)
        else:
            self._location = NetLocation(None)
        if not self._location.countrycode and self.ip != 'unknown':
            ## see if Tor is magic and knows more...
            self.controller.get_info_raw('ip-to-country/' + self.ip).addCallback(self._set_country)
        return self._location

    @property
    def flags(self):
        """
        A list of all the flags for this Router, each one an
        all-lower-case string.
        """
        return self._flags

    @flags.setter
    def flags(self, flags):
        """
        It might be nice to make flags not a list of strings. This is
        made harder by the control-spec: `...controllers MUST tolerate
        unrecognized flags and lines...`

        There is some current work in Twisted for open-ended constants
        (enums) support however, it seems.
        """
        if isinstance(flags, types.StringType):
            flags = flags.split()
        self._flags = map(lambda x: x.lower(), flags)
        self.name_is_unique = 'named' in self._flags

    @property
    def bandwidth(self):
        """The reported bandwidth of this Router."""
        return self._bandwidth

    @bandwidth.setter
    def bandwidth(self, bw):
        self._bandwidth = int(bw)

    @property
    def policy(self):
        """
        Port policies for this Router.
        :return: a string describing the policy
        """
        if self.accepted_ports:
            return 'accept ' + ','.join(map(str, self.accepted_ports))
        elif self.rejected_ports:
            return 'reject ' + ','.join(map(str, self.rejected_ports))
        else:
            return ''

    @policy.setter
    def policy(self, args):
        """
        setter for the policy descriptor
        """

        word = args[0]
        if word == 'reject':
            self.accepted_ports = None
            self.rejected_ports = []
            target = self.rejected_ports

        elif word == 'accept':
            self.accepted_ports = []
            self.rejected_ports = None
            target = self.accepted_ports

        else:
            raise RuntimeError("Don't understand policy word \"%s\"" % word)

        for port in args[1].split(','):
            if '-' in port:
                (a, b) = port.split('-')
                target.append(PortRange(int(a), int(b)))
            else:
                target.append(int(port))

    def accepts_port(self, port):
        """
        Query whether this Router will accept the given port.
        """

        if self.rejected_ports is None and self.accepted_ports is None:
            raise RuntimeError("policy hasn't been set yet")

        if self.rejected_ports:
            for x in self.rejected_ports:
                if port == x:
                    return False
            return True

        for x in self.accepted_ports:
            if port == x:
                return True
        return False

    def _set_country(self, c):
        """
        callback if we used Tor's GETINFO ip-to-country
        """

        self.location.countrycode = c.split()[0].split('=')[1].strip().upper()

    def __repr__(self):
        n = self.id_hex
        if self.name_is_unique:
            n = self.name
        return "<Router %s %s %s>" % (n, self.location.countrycode,
                                      self.policy)

########NEW FILE########
__FILENAME__ = spaghetti
import warnings


class FSM(object):
    """
    Override Matcher and Handler and pass instances to add_handler to
    create transitions between states. If a transition handles
    something, it returns the next state.

    If you want something to track global state, but it in your data
    instance passed to process so that transitions, states can access
    it.
    """

    states = []
    state = None

    def __init__(self, states):
        """first state is the initial state"""
        if len(states) > 0:
            self.state = states[0]
        self.states = states

    def process(self, data):
        #print self,"process",data
        if self.state is None:
            raise RuntimeError("There is no initial state.")
        next_state = self.state.process(data)
        if next_state:
            #print "changing to",next_state.name,next_state
            self.state = next_state
        else:
            warnings.warn("No next state", RuntimeWarning)

    def add_state(self, state):
        ## first added state is initial state
        if len(self.states) == 0:
            self.state = state
        self.states.append(state)

    def dotty(self):
        r = 'digraph fsm {\n\n'
        for s in self.states:
            r = r + s.dotty()
        r = r + '\n}\n'
        return r


class State(object):
    def __init__(self, name):
        self.name = name
        self.transitions = []

    def process(self, data):
        #print self.name,"process",data
        for t in self.transitions:
            r = t.process(data)
            if r is not None:
                return r
        return None

    def add_transition(self, t):
        self.transitions.append(t)
        t.start_state = self

    def add_transitions(self, transitions):
        for t in transitions:
            self.add_transition(t)

    def __str__(self):
        r = '<State %s [' % self.name
        for t in self.transitions:
            r = r + (' ->%s ' % t.next_state.name)
        r = r + ']>'
        return r

    def dotty(self):
        r = '%s;\n' % self.name
        r = r + 'edge [fontsize=8]\n'
        r = r + 'rankdir=TB;\nnodesep=2;\n'
        for t in self.transitions:
            r = r + '%s -> %s [label="%s\\n%s"]\n' % (self.name,
                                                      t.next_state.name,
                                                      t.matcher.__name__,
                                                      t.handler.__name__)
        return r


class Transition(object):
    def __init__(self, next_state, matcher, handler):
        self.matcher = matcher
        self.handler = handler
        self.start_state = None
        self.next_state = next_state
        if self.next_state is None:
            raise RuntimeError("next_state must be valid")
        #print self,self.matcher,self.handler

    def match(self, data):
        """
        used by process; calls handler if matcher returns true for
        data by default. may override instead of providing a matcher
        methdo to ctor.
        """
        #print self,"match",data,self.matcher
        if self.matcher is not None:
            return self.matcher(data)
        return True

    def handle(self, data):
        """
        return next state. May override in a subclass to change
        behavior or pass a handler method to ctor
        """
        if self.handler:
            state = self.handler(data)
            #print "got",state
            if state is None:
                return self.next_state
            return state
        return self.next_state

    def process(self, data):
        """return next state, or None if not handled."""
        #print self,"process",data
        if self.match(data):
            return self.handle(data)
        return None

    def __str__(self):
        if self.start_state:
            return "<Transition %s->%s>" % (self.start_state.name,
                                            self.next_state.name)
        return "<Transition ->%s>" % (self.next_state.name,)

########NEW FILE########
__FILENAME__ = stream
"""
Contains an implementation of a :class:`Stream abstraction used by
:class:`TorState to represent all streams in Tor's state. There is
also an interface called :class:`interface.IStreamListener` for
listening for stream updates (see also
:meth:`TorState.add_stream_listener`) and the interface called
:class:interface.IStreamAttacher` used by :class:`TorState` as a way
to attach streams to circuits "by hand"

"""

from twisted.python import log
from twisted.internet import defer
from txtorcon.interface import ICircuitContainer, IStreamListener
from txtorcon.util import find_keywords, maybe_ip_addr


class Stream(object):
    """
    Represents an active stream in Tor's state (:class:`txtorcon.TorState`).

    :ivar circuit:
        Streams will generally be attached to circuits pretty
        quickly. If they are attached, circuit will be a
        :class:`txtorcon.Circuit` instance or None if this stream
        isn't yet attached to a circuit.

    :ivar state:
        Tor's idea of the stream's state, one of:
          - NEW: New request to connect
          - NEWRESOLVE: New request to resolve an address
          - REMAP: Address re-mapped to another
          - SENTCONNECT: Sent a connect cell along a circuit
          - SENTRESOLVE: Sent a resolve cell along a circuit
          - SUCCEEDED: Received a reply; stream established
          - FAILED: Stream failed and not retriable
          - CLOSED: Stream closed
          - DETACHED: Detached from circuit; still retriable

    :ivar target_host:
        Something like www.example.com -- the host the stream is destined for.

    :ivar target_port:
        The port the stream will exit to.

    :ivar target_addr:
        Target address, looked up (usually) by Tor (e.g. 127.0.0.1).

    :ivar id:
        The ID of this stream, a number (or None if unset).
    """

    def __init__(self, circuitcontainer):
        """
        :param circuitcontainer: an object which implements
        :class:`interface.ICircuitContainer`
        """

        self.circuit_container = ICircuitContainer(circuitcontainer)

        ## FIXME: Sphinx doesn't seem to understand these variable
        ## docstrings, so consolidate with above if Sphinx is the
        ## answer -- actually it does, so long as the :ivar: things
        ## are never mentioned it seems.

        self.id = None
        """An int, Tor's ID for this :class:`txtorcon.Circuit`"""

        self.state = None
        """A string, Tor's idea of the state of this
        :class:`txtorcon.Stream`"""

        self.target_host = None
        """Usually a hostname, but sometimes an IP address (e.g. when
        we query existing state from Tor)"""

        self.target_addr = None
        """If available, the IP address we're connecting to (if None,
        see target_host instead)."""

        self.target_port = 0
        """The port we're connecting to."""

        self.circuit = None
        """If we've attached to a :class:`txtorcon.Circuit`, this will
        be an instance of :class:`txtorcon.Circuit` (otherwise None)."""

        self.listeners = []
        """A list of all connected
        :class:`txtorcon.interface.ICircuitListener` instances."""

        self.source_addr = None
        """If available, the address from which this Stream originated
        (e.g. local process, etc). See get_process() also."""

        self.source_port = 0
        """If available, the port from which this Stream
        originated. See get_process() also."""

        self.flags = {}
        """All flags from last update to this Stream. str->str"""

        self._closing_deferred = None
        """Internal. Holds Deferred that will callback when this
        stream is CLOSED, FAILED (or DETACHED??)"""

    def listen(self, listen):
        """
        Attach an :class:`txtorcon.interface.IStreamListener` to this stream.

        See also :meth:`txtorcon.TorState.add_stream_listener` to
        listen to all streams.

        :param listen: something that knows
        :class:`txtorcon.interface.IStreamListener`
        """

        listener = IStreamListener(listen)
        if listener not in self.listeners:
            self.listeners.append(listener)

    def unlisten(self, listener):
        self.listeners.remove(listener)

    def close(self, **kw):
        """
        This asks Tor to close the underlying stream object. See
        :method:`txtorcon.interface.ITorControlProtocol.close_stream`
        for details.

        Although Tor currently takes no flags, it allows you to; any
        keyword arguments are passed through as flags.

        NOTE that the callback delivered from this method only
        callbacks after the underlying stream is really destroyed
        (*not* just when the CLOSESTREAM command has successfully
        completed).
        """

        self._closing_deferred = defer.Deferred()

        def close_command_is_queued(*args):
            return self._closing_deferred
        d = self.circuit_container.close_stream(self, **kw)
        d.addCallback(close_command_is_queued)
        return self._closing_deferred

    def _create_flags(self, kw):
        "this clones the kw dict, adding a lower-case version of every key (duplicated in circuit.py; consider putting in util?)"

        flags = {}
        for k in kw.keys():
            flags[k] = kw[k]
            flags[k.lower()] = flags[k]
        return flags

    def update(self, args):
        ## print "update",self.id,args

        if self.id is None:
            self.id = int(args[0])
        else:
            if self.id != int(args[0]):
                raise RuntimeError("Update for wrong stream.")

        kw = find_keywords(args)
        self.flags = kw

        if 'SOURCE_ADDR' in kw:
            last_colon = kw['SOURCE_ADDR'].rfind(':')
            self.source_addr = kw['SOURCE_ADDR'][:last_colon]
            if self.source_addr != '(Tor_internal)':
                self.source_addr = maybe_ip_addr(self.source_addr)
            self.source_port = int(kw['SOURCE_ADDR'][last_colon + 1:])

        self.state = args[1]
        if self.state in ['NEW', 'NEWRESOLVE', 'SUCCEEDED']:
            if self.target_host is None:
                last_colon = args[3].rfind(':')
                self.target_host = args[3][:last_colon]
                self.target_port = int(args[3][last_colon + 1:])

            self.target_port = int(self.target_port)
            if self.state == 'NEW':
                if self.circuit is not None:
                    log.err(RuntimeError("Weird: circuit valid in NEW"))
                [x.stream_new(self) for x in self.listeners]
            else:
                [x.stream_succeeded(self) for x in self.listeners]

        elif self.state == 'REMAP':
            self.target_addr = maybe_ip_addr(args[3][:args[3].rfind(':')])

        elif self.state == 'CLOSED':
            if self.circuit:
                self.circuit.streams.remove(self)
            self.circuit = None
            self.maybe_call_closing_deferred()
            flags = self._create_flags(kw)
            [x.stream_closed(self, **flags) for x in self.listeners]

        elif self.state == 'FAILED':
            if self.circuit:
                self.circuit.streams.remove(self)
            self.circuit = None
            self.maybe_call_closing_deferred()
            # build lower-case version of all flags
            flags = self._create_flags(kw)
            [x.stream_failed(self, **flags) for x in self.listeners]

        elif self.state == 'SENTCONNECT':
            pass  # print 'SENTCONNECT',self,args

        elif self.state == 'DETACHED':
            if self.circuit:
                self.circuit.streams.remove(self)
                self.circuit = None

            ## FIXME does this count as closed?
            ##self.maybe_call_closing_deferred()
            flags = self._create_flags(kw)
            [x.stream_detach(self, **flags) for x in self.listeners]

        elif self.state in ['NEWRESOLVE', 'SENTRESOLVE']:
            pass  # print self.state, self, args

        else:
            raise RuntimeError("Unknown state: %s" % self.state)

        ## see if we attached to a circuit. I believe this only
        ## happens on a SENTCONNECT or REMAP. DETACHED is excluded so
        ## we don't immediately re-add the circuit we just detached
        ## from
        if self.state not in ['CLOSED', 'FAILED', 'DETACHED']:
            cid = int(args[2])
            if cid == 0:
                if self.circuit and self in self.circuit.streams:
                    self.circuit.streams.remove(self)
                self.circuit = None

            else:
                if self.circuit is None:
                    self.circuit = self.circuit_container.find_circuit(cid)
                    if self not in self.circuit.streams:
                        self.circuit.streams.append(self)
                        [x.stream_attach(self, self.circuit) for x in self.listeners]

                else:
                    if self.circuit.id != cid:
                        log.err(RuntimeError('Circuit ID changed from %d to %d.' % (self.circuit.id, cid)))

    def maybe_call_closing_deferred(self):
        """
        Used internally to callback on the _closing_deferred if it
        exists.
        """

        if self._closing_deferred:
            self._closing_deferred.callback(self)
            self._closing_deferred = None

    def __str__(self):
        c = ''
        if self.circuit:
            c = 'on %d ' % self.circuit.id
        return "<Stream %s %d %s%s -> %s port %d>" % (self.state,
                                                      self.id,
                                                      c,
                                                      self.target_host,
                                                      str(self.target_addr),
                                                      self.target_port)

########NEW FILE########
__FILENAME__ = torconfig
from __future__ import with_statement

import os
import sys
import string
import types
import functools
import random
import tempfile
from StringIO import StringIO
import shlex
if sys.platform in ('linux2', 'darwin'):
    import pwd

from twisted.python import log
from twisted.internet import defer, error, protocol
from twisted.internet.interfaces import IStreamServerEndpoint, IReactorTime
from twisted.internet.endpoints import TCP4ClientEndpoint, TCP4ServerEndpoint
from zope.interface import implements

from txtorcon.torcontrolprotocol import parse_keywords, TorProtocolFactory
from txtorcon.util import delete_file_or_tree, find_keywords, find_tor_binary
from txtorcon.log import txtorlog
from txtorcon.interface import ITorControlProtocol


class TorNotFound(RuntimeError):
    """
    Raised by launch_tor() in case the tor binary was unspecified and could
    not be found by consulting the shell.
    """


def DefaultTCP4EndpointGenerator(*args, **kw):
    """
    Default generator used to create server-side TCP4ServerEndpoint
    instances. Sets interface='127.0.0.1' instead of the default ('',
    which means all).

    (We use a generator so we can try random ports in case something
    is listening on one; perhaps it would be more straightfoward to
    simply allow an endpoint to be passed to TCPHiddenServiceEndpoint
    instead and fail right away in case something is listening?)
    """

    kw['interface'] = '127.0.0.1'
    return TCP4ServerEndpoint(*args, **kw)


class TCPHiddenServiceEndpoint(object):
    """
    This represents something listening on an arbitrary local port
    that has a Tor configured with a Hidden Service pointing at
    it. :api:`twisted.internet.endpoints.TCP4ServerEndpoint
    <TCP4ServerEndpoint>` is used under the hood to do the local
    listening.

    :ivar onion_uri: the public key, like `timaq4ygg2iegci7.onion`
        which came from the data_dir's `hostname` file

    :ivar onion_private_key: the contents of `data_dir/private_key`

    :ivar data_dir: the data directory, either passed in or created
        with `tempfile.mkstemp`

    :ivar public_port: the port we are advertising
    """

    implements(IStreamServerEndpoint)

    def __init__(self, reactor, config, public_port, data_dir=None,
                 port_generator=functools.partial(random.randrange, 1024, 65534),
                 endpoint_generator=DefaultTCP4EndpointGenerator):
        """
        :param reactor:
            :api:`twisted.internet.interfaces.IReactorTCP` provider

        :param config:
            :class:`txtorcon.TorConfig` instance (doesn't need to be
            bootstrapped). Note that `save()` will be called on this
            at least once. FIXME should I just accept a
            TorControlProtocol instance instead, and create my own
            TorConfig?

        :param public_port:
            The port number we will advertise in the hidden serivces
            directory.

        :param data_dir:
            The hidden-service data directory; if None, one will be
            created in /tmp. This contains the public + private keys
            for the onion uri. If you didn't specify a directory, it's
            up to you to save the public/private keys later if you
            want to re-launch the same hidden service at a different
            time.

        :param port_generator:
            A callable that generates a new random port to try
            listening on. Defaults to `random.randrange(1024, 65535)`

        :param endpoint_generator:
            A callable that generates a new instance of something that
            implements IServerEndpoint (by default TCP4ServerEndpoint)
        """

        self.public_port = public_port
        self.data_dir = data_dir
        self.onion_uri = None
        self.onion_private_key = None
        if self.data_dir:
            self._update_onion(self.data_dir)

        else:
            self.data_dir = tempfile.mkdtemp(prefix='tortmp')

        # shouldn't need to use these
        self.reactor = reactor
        self.config = config
        self.hiddenservice = None
        self.port_generator = port_generator
        self.endpoint_generator = endpoint_generator

        self.retries = 0

        self.defer = defer.Deferred()

    def _update_onion(self, thedir):
        """
        Used internally to update the `onion_uri` and
        `onion_private_key` members.
        """

        hn = os.path.join(thedir, 'hostname')
        pk = os.path.join(thedir, 'private_key')
        try:
            with open(hn, 'r') as hnfile:
                self.onion_uri = hnfile.read().strip()
        except IOError:
            self.onion_uri = None

        try:
            with open(pk, 'r') as pkfile:
                self.onion_private_key = pkfile.read().strip()
        except IOError:
            self.onion_private_key = None

    def _create_hiddenservice(self, arg):
        """
        Internal callback to create a hidden-service config in the
        running Tor (via the `config` member).
        """

        ## FIXME this should be anything that doesn't currently have a
        ## listener, and we should check that....or keep trying random
        ## ports if the "real" listen fails?
        self.listen_port = 80

        self.hiddenservice = HiddenService(self.config, self.data_dir,
                                           ['%d 127.0.0.1:%d' % (self.public_port,
                                                                 self.listen_port)])
        self.config.HiddenServices.append(self.hiddenservice)
        return arg

    def listen(self, protocolfactory):
        """
        Implement :api:`twisted.internet.interfaces.IStreamServerEndpoint <IStreamServerEndpoint>`.

        Returns a Deferred that delivers an
        :api:`twisted.internet.interfaces.IPort` instance that also
        has at least `onion_uri` and `onion_private_key` members set
        (both strings). Really this is just what
        :api:`twisted.internet.endpoints.TCP4ServerEndpoint
        <TCP4ServerEndpoint>`.listen() returned, with a few members set. At
        this point, Tor will have fully started up and successfully
        accepted the hidden service's config.
        """

        self.protocolfactory = protocolfactory
        if self.hiddenservice is None:
            ## we don't have a hidden service yet, but if the config
            ## isn't bootstrapped, we need to wait for it first
            if self.config.post_bootstrap:
                d = self.config.post_bootstrap.addCallback(self._create_hiddenservice)

            else:
                self._create_hiddenservice(None)
                d = self.config.save()

        else:
            ## we already have a hidden service created, but still
            ## want a Deferred so the _create_listener flow is the
            ## same
            d = defer.succeed(self)

        d.addCallback(self._create_listener).addErrback(self._retry_local_port)
        return d

    def _retry_local_port(self, failure):
        """
        Handles :api:`twisted.internet.error.CannotListenError` by
        trying again on another port. After 10 failures, we give up
        and propogate the error.
        """
        failure.trap(error.CannotListenError)

        self.retries += 1
        if self.retries > 10:
            return failure
        self.listen_port = self.port_generator()
        ## we do want to overwrite the whole list, not append
        self.hiddenservice.ports = ['%d 127.0.0.1:%d' % (self.public_port,
                                                         self.listen_port)]
        d = self.config.save()
        d.addCallback(self._create_listener).addErrback(self._retry_local_port)
        return d

    def check_local_endpoint(self, ep):
        """
        This tries to sanity-check ep to see if it's a local address
        or not and returns True or False.

        Currently, 'local' means either it starts with '127.' or is
        '::1'
        """

        if hasattr(ep, '_interface'):
            is_local = ep._interface.startswith('127.') or ep._interface == '::1'
            if not is_local:
                return False
        return True

    def _create_listener(self, proto):
        """
        Creates the local TCP4ServerEndpoint instance, returning a
        Deferred delivering an :api:`twisted.internet.interfaces.IPort` instance that also has
        :meth:`TCPHiddenServiceEndpoint._add_attributes` called
        against it (adds `onion_uri` and `onion_private_key` members).
        """

        self._update_onion(self.hiddenservice.dir)

        self.tcp_endpoint = self.endpoint_generator(self.reactor, self.listen_port)
        if not self.check_local_endpoint(self.tcp_endpoint):
            raise RuntimeError("Endpoint doesn't appear to be a local interface.")
        d = self.tcp_endpoint.listen(self.protocolfactory)
        d.addCallback(self._add_attributes).addErrback(self._retry_local_port)
        return d

    def _add_attributes(self, port):
        port.onion_uri = self.onion_uri
        port.onion_port = self.public_port
        return port


class TorProcessProtocol(protocol.ProcessProtocol):

    def __init__(self, connection_creator, progress_updates=None, config=None,
                 ireactortime=None, timeout=None):
        """
        This will read the output from a Tor process and attempt a
        connection to its control port when it sees any 'Bootstrapped'
        message on stdout. You probably don't need to use this
        directly except as the return value from the
        :func:`txtorcon.launch_tor` method. tor_protocol contains a
        valid :class:`txtorcon.TorControlProtocol` instance by that
        point.

        connection_creator is a callable that should return a Deferred
        that callbacks with a :class:`txtorcon.TorControlProtocol`;
        see :func:`txtorcon.launch_tor` for the default one which is a
        functools.partial that will call
        ``connect(TorProtocolFactory())`` on an appropriate
        :api:`twisted.internet.endpoints.TCP4ClientEndpoint`

        :param connection_creator: A no-parameter callable which
            returns a Deferred which promises a :api:`twisted.internet.interfaces.IStreamClientEndpoint <IStreamClientEndpoint>`

        :param progress_updates: A callback which received progress
            updates with three args: percent, tag, summary

        :param config: a TorConfig object to connect to the
            TorControlProtocl from the launched tor (should it succeed)

        :param ireactortime:
            An object implementing IReactorTime (i.e. a reactor) which
            needs to be supplied if you pass a timeout.

        :param timeout:
            An int representing the timeout in seconds. If we are
            unable to reach 100% by this time we will consider the
            setting up of Tor to have failed. Must supply ireactortime
            if you supply this.

        :ivar tor_protocol: The TorControlProtocol instance connected
            to the Tor this :api:`twisted.internet.protocol.ProcessProtocol <ProcessProtocol>`` is speaking to. Will be valid
            when the `connected_cb` callback runs.

        :ivar connected_cb: Triggered when the Tor process we
            represent is fully bootstrapped

        """

        self.config = config
        self.tor_protocol = None
        self.connection_creator = connection_creator
        self.progress_updates = progress_updates

        self.connected_cb = defer.Deferred()

        self.attempted_connect = False
        self.to_delete = []
        self.stderr = []
        self.stdout = []

        self._setup_complete = False
        self._did_timeout = False
        self._timeout_delayed_call = None
        if timeout:
            if not ireactortime:
                raise RuntimeError('Must supply an IReactorTime object when supplying a timeout')
            ireactortime = IReactorTime(ireactortime)
            self._timeout_delayed_call = ireactortime.callLater(timeout, self.timeout_expired)

    def outReceived(self, data):
        """
        :api:`twisted.internet.protocol.ProcessProtocol <ProcessProtocol>` API
        """

        self.stdout.append(data)

        ## minor hack: we can't try this in connectionMade because
        ## that's when the process first starts up so Tor hasn't
        ## opened any ports properly yet. So, we presume that after
        ## its first output we're good-to-go. If this fails, we'll
        ## reset and try again at the next output (see this class'
        ## tor_connection_failed)

        txtorlog.msg(data)
        if not self.attempted_connect and 'Bootstrap' in data:
            self.attempted_connect = True
            d = self.connection_creator()
            d.addCallback(self.tor_connected)
            d.addErrback(self.tor_connection_failed)

    def timeout_expired(self):
        """
        A timeout was supplied during setup, and the time has run out.
        """

        try:
            self.transport.signalProcess('TERM')
        except error.ProcessExitedAlready:
            self.transport.loseConnection()
        self._did_timeout = True

    def errReceived(self, data):
        """
        :api:`twisted.internet.protocol.ProcessProtocol <ProcessProtocol>` API
        """

        self.stderr.append(data)
        self.transport.loseConnection()
        raise RuntimeError("Received stderr output from slave Tor process: " + data)

    def cleanup(self):
        """
        Clean up my temporary files.
        """

        [delete_file_or_tree(f) for f in self.to_delete]
        self.to_delete = []

    def processEnded(self, status):
        """
        :api:`twisted.internet.protocol.ProcessProtocol <ProcessProtocol>` API
        """

        self.cleanup()

        if isinstance(status.value, error.ProcessDone) and not self._did_timeout:
            return

        if status.value.exitCode is None:
            if self._did_timeout:
                err = RuntimeError('\n'.join(self.stdout) + "\n\nTimeout waiting for Tor launch..")
            else:
                err = RuntimeError('\n'.join(self.stdout) + "\n\nTor was killed (%s)." % status.value.signal)
        else:
            err = RuntimeError('\n'.join(self.stdout) + "\n\nTor exited with error-code %d" % status.value.exitCode)
        self.connected_cb.errback(err)

    def progress(self, percent, tag, summary):
        """
        Can be overridden or monkey-patched if you want to get
        progress updates yourself.
        """

        if self.progress_updates:
            self.progress_updates(percent, tag, summary)

    ## the below are all callbacks

    def tor_connection_failed(self, failure):
        ## FIXME more robust error-handling please, like a timeout so
        ## we don't just wait forever after 100% bootstrapped (that
        ## is, we're ignoring these errors, but shouldn't do so after
        ## we'll stop trying)
        self.attempted_connect = False

    def status_client(self, arg):
        args = shlex.split(arg)
        if args[1] != 'BOOTSTRAP':
            return

        kw = find_keywords(args)
        prog = int(kw['PROGRESS'])
        tag = kw['TAG']
        summary = kw['SUMMARY']
        self.progress(prog, tag, summary)

        if prog == 100:
            if self._timeout_delayed_call:
                self._timeout_delayed_call.cancel()
                self._timeout_delayed_call = None
            self.connected_cb.callback(self)

    def tor_connected(self, proto):
        txtorlog.msg("tor_connected %s" % proto)

        self.tor_protocol = proto
        if self.config is not None:
            self.config._update_proto(proto)
        self.tor_protocol.is_owned = self.transport.pid
        self.tor_protocol.post_bootstrap.addCallback(self.protocol_bootstrapped).addErrback(self.tor_connection_failed)

    def protocol_bootstrapped(self, proto):
        txtorlog.msg("Protocol is bootstrapped")

        self.tor_protocol.add_event_listener('STATUS_CLIENT', self.status_client)

        ## FIXME: should really listen for these to complete as well
        ## as bootstrap etc. For now, we'll be optimistic.
        self.tor_protocol.queue_command('TAKEOWNERSHIP')
        self.tor_protocol.queue_command('RESETCONF __OwningControllerProcess')


def launch_tor(config, reactor,
               tor_binary=None,
               progress_updates=None,
               connection_creator=None,
               timeout=None):
    """
    launches a new Tor process with the given config.

    If Tor prints anything on stderr, we kill off the process, close
    the TorControlProtocol and raise an exception.

    :param config: an instance of :class:`txtorcon.TorConfig` with any
        configuration values you want. :meth:`txtorcon.TorConfig.save`
        should have been called already (anything unsaved won't make
        it into the torrc produced). If ControlPort isn't set, 9052 is
        used; if DataDirectory isn't set, tempdir is used to create
        one.

    :param reactor: a Twisted IReactorCore implementation (usually
        twisted.internet.reactor)

    :param tor_binary: path to the Tor binary to run. Tries to find the tor
        binary if unset.

    :param progress_updates: a callback which gets progress updates; gets as
         args: percent, tag, summary (FIXME make an interface for this).

    :param connection_creator: is mostly available to ease testing, so
        you probably don't want to supply this. If supplied, it is a
        callable that should return a Deferred that delivers an
        :api:`twisted.internet.interfaces.IProtocol <IProtocol>` or ConnectError.
        See :api:`twisted.internet.interfaces.IStreamClientEndpoint`.connect

    :return: a Deferred which callbacks with a TorProcessProtocol
        connected to the fully-bootstrapped Tor; this has a
        :class:`txtorcon.TorControlProtocol` instance as `.tor_protocol`. In Tor,
        ``__OwningControllerProcess`` will be set and TAKEOWNERSHIP will have
        been called, so if you close the TorControlProtocol the Tor should
        exit also (see `control-spec <https://gitweb.torproject.org/torspec.git/blob/HEAD:/control-spec.txt>`_ 3.23).

    HACKS:

     1. It's hard to know when Tor has both (completely!) written its
        authentication cookie file AND is listening on the control
        port. It seems that waiting for the first 'bootstrap' message on
        stdout is sufficient. Seems fragile...and doesn't work 100% of
        the time, so FIXME look at Tor source.

    """

    ## We have a slight problem with the approach: we need to pass a
    ## few minimum values to a torrc file so that Tor will start up
    ## enough that we may connect to it. Ideally, we'd be able to
    ## start a Tor up which doesn't really do anything except provide
    ## "AUTHENTICATE" and "GETINFO config/names" so we can do our
    ## config validation.

    ## the other option here is to simply write a torrc version of our
    ## config and get Tor to load that...which might be the best
    ## option anyway.

    if tor_binary is None:
        tor_binary = find_tor_binary()
    if tor_binary is None:
        # We fail right here instead of waiting for the reactor to start
        raise TorNotFound('Tor binary could not be found')

    if config.needs_save():
        log.msg("Config was unsaved when launch_tor() called; calling save().")
        config.save()

    try:
        data_directory = config.DataDirectory
        user_set_data_directory = True
    except KeyError:
        user_set_data_directory = False
        data_directory = tempfile.mkdtemp(prefix='tortmp')
        config.DataDirectory = data_directory

        # Set ownership on the temp-dir to the user tor will drop privileges to
        # when executing as root.
        try:
            user = config.User
        except KeyError:
            pass
        else:
            if sys.platform in ('linux2', 'darwin') and os.geteuid() == 0:
                os.chown(data_directory, pwd.getpwnam(user).pw_uid, -1)

    try:
        control_port = config.ControlPort
    except KeyError:
        control_port = 9052
        config.ControlPort = control_port

    config.CookieAuthentication = 1
    config.__OwningControllerProcess = os.getpid()
    config.save()

    (fd, torrc) = tempfile.mkstemp(prefix='tortmp')
    os.write(fd, config.create_torrc())
    os.close(fd)

    # txtorlog.msg('Running with config:\n', open(torrc, 'r').read())

    if connection_creator is None:
        connection_creator = functools.partial(TCP4ClientEndpoint(reactor, 'localhost', control_port).connect,
                                               TorProtocolFactory())
    process_protocol = TorProcessProtocol(connection_creator, progress_updates, config, reactor, timeout)

    # we set both to_delete and the shutdown events because this
    # process might be shut down way before the reactor, but if the
    # reactor bombs out without the subprocess getting closed cleanly,
    # we'll want the system shutdown events triggered so the temporary
    # files get cleaned up

    # we don't want to delete the user's directories, just our
    # temporary ones
    if user_set_data_directory:
        process_protocol.to_delete = [torrc]
        reactor.addSystemEventTrigger('before', 'shutdown',
                                      functools.partial(delete_file_or_tree,
                                                        torrc))
    else:
        process_protocol.to_delete = [torrc, data_directory]
        reactor.addSystemEventTrigger('before', 'shutdown',
                                      functools.partial(delete_file_or_tree,
                                                        torrc,
                                                        data_directory))

    try:
        transport = reactor.spawnProcess(process_protocol, tor_binary,
                                         args=(tor_binary, '-f', torrc),
                                         env={'HOME': data_directory},
                                         path=data_directory)
        #FIXME? don't need rest of the args: uid, gid, usePTY, childFDs)
        transport.closeStdin()

    except RuntimeError, e:
        process_protocol.connected_cb.errback(e)

    return process_protocol.connected_cb


class TorConfigType(object):
    """
    Base class for all configuration types, which function as parsers
    and un-parsers.
    """

    def parse(self, s):
        """
        Given the string s, this should return a parsed representation
        of it.
        """
        return s

    def validate(self, s, instance, name):
        """
        If s is not a valid type for this object, an exception should
        be thrown. The validated object should be returned.
        """
        return s


class Boolean(TorConfigType):
    def parse(self, s):
        if int(s):
            return True
        return False


class Boolean_Auto(TorConfigType):
    """
    weird class-name, but see the parser for these which is *mostly*
    just the classname <==> string from Tor, except for something
    called Boolean+Auto which is replace()d to be Boolean_Auto
    """

    def parse(self, s):
        if s == 'auto' or int(s) < 0:
            return -1
        if int(s):
            return 1
        return 0


class Integer(TorConfigType):
    def parse(self, s):
        return int(s)


class SignedInteger(Integer):
    pass


class Port(Integer):
    pass


class TimeInterval(Integer):
    pass


## not actually used?
class TimeMsecInterval(TorConfigType):
    pass


class DataSize(Integer):
    pass


class Float(TorConfigType):
    def parse(self, s):
        return float(s)


## unused also?
class Time(TorConfigType):
    pass


class CommaList(TorConfigType):
    def parse(self, s):
        return map(string.strip, s.split(','))


## FIXME: is this really a comma-list?
class RouterList(CommaList):
    pass


class String(TorConfigType):
    pass


class Filename(String):
    pass


class LineList(TorConfigType):
    def parse(self, s):
        if isinstance(s, types.ListType):
            return map(str, s)
        return map(string.strip, s.split('\n'))

    def validate(self, obj, instance, name):
        if not isinstance(obj, types.ListType):
            raise ValueError("Not valid for %s: %s" % (self.__class__, obj))
        return _ListWrapper(obj, functools.partial(instance.mark_unsaved, name))

config_types = [Boolean, Boolean_Auto, LineList, Integer, SignedInteger, Port,
                TimeInterval, TimeMsecInterval,
                DataSize, Float, Time, CommaList, String, LineList, Filename,
                RouterList]


def _wrapture(orig):
    """
    Returns a new method that wraps orig (the original method) with
    something that first calls on_modify from the
    instance. _ListWrapper uses this to wrap all methods that modify
    the list.
    """

#    @functools.wraps(orig)
    def foo(*args):
        obj = args[0]
        obj.on_modify()
        return orig(*args)
    return foo


class _ListWrapper(list):
    """
    Do some voodoo to wrap lists so that if you do anything to modify
    it, we mark the config as needing saving.

    FIXME: really worth it to preserve attribute-style access? seems
    to be okay from an exterior API perspective....
    """

    def __init__(self, thelist, on_modify_cb):
        list.__init__(self, thelist)
        self.on_modify = on_modify_cb

    __setitem__ = _wrapture(list.__setitem__)
    __setslice__ = _wrapture(list.__setslice__)
    append = _wrapture(list.append)
    extend = _wrapture(list.extend)
    insert = _wrapture(list.insert)
    remove = _wrapture(list.remove)
    pop = _wrapture(list.pop)

    def __repr__(self):
        return '_ListWrapper' + super(_ListWrapper, self).__repr__()


class HiddenService(object):
    """
    Because hidden service configuration is handled specially by Tor,
    we wrap the config in this class. This corresponds to the
    HiddenServiceDir, HiddenServicePort, HiddenServiceVersion and
    HiddenServiceAuthorizeClient lines from the config. If you want
    multiple HiddenServicePort lines, simply append more strings to
    the ports member.

    To create an additional hidden service, append a new instance of
    this class to the config (ignore the conf argument)::

    state.hiddenservices.append(HiddenService('/path/to/dir', ['80 127.0.0.1:1234']))
    """

    def __init__(self, config, thedir, ports, auth=None, ver=2):
        """
        config is the TorConfig to which this will belong (FIXME,
        can't we make this automatic somehow?), thedir corresponds to
        'HiddenServiceDir' and will ultimately contain a 'hostname'
        and 'private_key' file, ports is a list of lines corresponding
        to HiddenServicePort (like '80 127.0.0.1:1234' to advertise a
        hidden service at port 80 and redirect it internally on
        127.0.0.1:1234). auth corresponds to
        HiddenServiceAuthenticateClient line (FIXME: is that lines?)
        and ver corresponds to HiddenServiceVersion and is always 2
        right now.
        """

        self.conf = config
        self.dir = thedir
        self.version = ver
        self.authorize_client = auth

        ## there are two magic attributes, "hostname" and "private_key"
        ## these are gotten from the dir if they're still None when
        ## accessed. Note that after a SETCONF has returned '250 OK'
        ## it seems from tor code that the keys will always have been
        ## created on disk by that point

        if not isinstance(ports, types.ListType):
            ports = [ports]
        self.ports = _ListWrapper(ports, functools.partial(self.conf.mark_unsaved,
                                                           'HiddenServices'))

    def __setattr__(self, name, value):
        """
        We override the default behavior so that we can mark
        HiddenServices as unsaved in our TorConfig object if anything
        is changed.
        """

        if name in ['dir', 'version', 'authorize_client', 'ports'] and self.conf:
            self.conf.mark_unsaved('HiddenServices')
        if isinstance(value, types.ListType):
            value = _ListWrapper(value, functools.partial(self.conf.mark_unsaved,
                                                          'HiddenServices'))
        self.__dict__[name] = value

    def __getattr__(self, name):
        if name in ('hostname', 'private_key'):
            with open(os.path.join(self.dir, name)) as f:
                self.__dict__[name] = f.read().strip()
        return self.__dict__[name]

    def config_attributes(self):
        """
        Helper method used by TorConfig when generating a torrc file.
        """

        rtn = [('HiddenServiceDir', self.dir)]
        for x in self.ports:
            rtn.append(('HiddenServicePort', x))
        if self.version:
            rtn.append(('HiddenServiceVersion', self.version))
        if self.authorize_client:
            rtn.append(('HiddenServiceAuthorizeClient', self.authorize_client))
        return rtn


class TorConfig(object):
    """
    This class abstracts out Tor's config so that you don't have to
    realize things like: in order to successfully set multiple listen
    addresses, you must put them all (and the or-ports) in one SETCONF
    call.

    Also, it gives easy access to all the configuration options
    present. This is loaded at "bootstrap" time (when all values are
    loaded) providing attribute-based access thereafter. If you set an
    item AND we're bootstrapped to a Tor, THEN that valud is NOT
    reflected in Tor until you do save() -- and neither is it
    reflected in the TorConfig instance until that time. So, you might
    get slightly confusing behavior like: ``config.SOCKSPort=1234;
    print config.SOCKSPort`` which will still print 9050 or whatever
    the original value is. (TODO is this really a good idea?
    Especially since we "need" the other behavior for "build config
    from scratch" use-case)

    You may also use this class to construct a configuration from
    scratch (e.g. to give to :func:`txtorcon.launch_tor`). In this
    case, values are reflected right away. (If we're not bootstrapped
    to a Tor, this is the mode).

    Note that you do not need to call save() if you're just using
    TorConfig to create a .torrc file or for input to launch_tor().

    This listens for CONF_CHANGED events to update the cached data in
    the event other controllers (etc) changed it.

    FIXME: when is CONF_CHANGED introduced in Tor? Can we do anything
    like it for prior versions?

    FIXME:

        - HiddenServiceOptions is special: GETCONF on it returns
        several (well, two) values. Besides adding the two keys 'by
        hand' do we need to do anything special? Can't we just depend
        on users doing 'conf.hiddenservicedir = foo' AND
        'conf.hiddenserviceport = bar' before a save() ?

        - once I determine a value is default, is there any way to
          actually get what this value is?
    """

    def __init__(self, control=None):
        self.config = {}
        '''Current configuration, by keys.'''

        if control is None:
            self.protocol = None
            self.__dict__['_slutty_'] = None
            self.__dict__['config']['HiddenServices'] = _ListWrapper([], functools.partial(self.mark_unsaved, 'HiddenServices'))

        else:
            self.protocol = ITorControlProtocol(control)

        self.unsaved = {}
        '''Configuration that has been changed since last save().'''

        self.parsers = {}
        '''Instances of the parser classes, subclasses of TorConfigType'''

        self.post_bootstrap = defer.Deferred()
        if self.protocol:
            if self.protocol.post_bootstrap:
                self.protocol.post_bootstrap.addCallback(self.bootstrap).addErrback(log.err)
            else:
                self.bootstrap()

        else:
            self.post_bootstrap.callback(self)

        self.__dict__['_setup_'] = None

    def _update_proto(self, proto):
        """
        internal method, used by launch_tor to update the protocol after we're set up.
        """
        self.__dict__['protocol'] = proto

    def __setattr__(self, name, value):
        """
        we override this so that we can provide direct attribute
        access to our config items, and move them into self.unsaved
        when they've been changed. hiddenservices have to be special
        unfortunately. the _setup_ thing is so that we can set up the
        attributes we need in the constructor without uusing __dict__
        all over the place.
        """

        if '_setup_' in self.__dict__:
            name = self._find_real_name(name)
            if '_slutty_' not in self.__dict__ and name.lower() != 'hiddenservices':
                value = self.parsers[name].validate(value, self, name)
            if isinstance(value, types.ListType):
                value = _ListWrapper(value, functools.partial(self.mark_unsaved, name))

            name = self._find_real_name(name)
            self.unsaved[name] = value

        else:
            super(TorConfig, self).__setattr__(name, value)

    def __getattr__(self, name):
        """
        on purpose, we don't return self.saved if the key is in there
        because I want the config to represent the running Tor not
        ``things which might get into the running Tor if save() were
        to be called''
        """

        rn = self._find_real_name(name)
        if '_slutty_' in self.__dict__ and rn in self.unsaved:
            return self.unsaved[rn]
        return self.config[rn]

    def get_type(self, name):
        """
        return the type of a config key.

        :param: name the key

        FIXME can we do something more-clever than this for client
        code to determine what sort of thing a key is?
        """

        if name.lower() == 'hiddenservices':
            return HiddenService
        return type(self.parsers[name])

    def _conf_changed(self, arg):
        """
        internal callback. from control-spec:

        4.1.18. Configuration changed

          The syntax is:
             StartReplyLine *(MidReplyLine) EndReplyLine

             StartReplyLine = "650-CONF_CHANGED" CRLF
             MidReplyLine = "650-" KEYWORD ["=" VALUE] CRLF
             EndReplyLine = "650 OK"

          Tor configuration options have changed (such as via a SETCONF or RELOAD
          signal). KEYWORD and VALUE specify the configuration option that was changed.
          Undefined configuration options contain only the KEYWORD.
        """

        conf = parse_keywords(arg, multiline_values=False)
        for (k, v) in conf.items():
            ## v will be txtorcon.DEFAULT_VALUE already from
            ## parse_keywords if it was unspecified
            self.config[self._find_real_name(k)] = v

    def bootstrap(self, *args):
        try:
            self.protocol.add_event_listener('CONF_CHANGED', self._conf_changed)
        except RuntimeError:
            ## for Tor versions which don't understand CONF_CHANGED
            ## there's nothing we can really do.
            log.msg("Can't listen for CONF_CHANGED event; won't stay up-to-date with other clients.")
        return self.protocol.get_info_raw("config/names").addCallbacks(self._do_setup, log.err).addCallback(self.do_post_bootstrap).addErrback(log.err)

    def do_post_bootstrap(self, *args):
        self.post_bootstrap.callback(self)
        self.__dict__['post_bootstrap'] = None

    def needs_save(self):
        return len(self.unsaved) > 0

    def mark_unsaved(self, name):
        name = self._find_real_name(name)
        if name in self.config and name not in self.unsaved:
            self.unsaved[name] = self.config[self._find_real_name(name)]

    def save(self):
        """
        Save any outstanding items. This returns a Deferred which will
        errback if Tor was unhappy with anything, or callback with
        this TorConfig object on success.
        """

        if not self.needs_save():
            return defer.succeed(self)

        args = []
        for (key, value) in self.unsaved.items():
            if key == 'HiddenServices':
                self.config['HiddenServices'] = value
                for hs in value:
                    args.append('HiddenServiceDir')
                    args.append(hs.dir)
                    for p in hs.ports:
                        args.append('HiddenServicePort')
                        args.append(str(p))
                    if hs.version:
                        args.append('HiddenServiceVersion')
                        args.append(str(hs.version))
                    if hs.authorize_client:
                        args.append('HiddenServiceAuthorizeClient')
                        args.append(hs.authorize_client)
                continue

            if isinstance(value, types.ListType):
                for x in value:
                    args.append(key)
                    args.append(str(x))

            else:
                args.append(key)
                args.append(value)

            # FIXME in future we should wait for CONF_CHANGED and
            # update then, right?
            self.config[self._find_real_name(key)] = value

        ## FIXME might want to re-think this, but currently there's no
        ## way to put things into a config and get them out again
        ## nicely...unless you just don't assign a protocol
        if self.protocol:
            d = self.protocol.set_conf(*args)
            d.addCallback(self._save_completed)
            d.addErrback(log.err)
            return d

        else:
            self._save_completed()
            return defer.succeed(self)

    def _save_completed(self, *args):
        '''internal callback'''
        self.__dict__['unsaved'] = {}
        return self

    def _find_real_name(self, name):
        for x in self.__dict__['config'].keys():
            if x.lower() == name:
                return x
        return name

    @defer.inlineCallbacks
    def _do_setup(self, data):
        for line in data.split('\n'):
            if line == "config/names=":
                continue

            (name, value) = line.split()
            if name == 'HiddenServiceOptions':
                ## set up the "special-case" hidden service stuff
                servicelines = yield self.protocol.get_conf_raw('HiddenServiceOptions')
                self._setup_hidden_services(servicelines)
                continue

            if value == 'Dependant':
                continue

            ## there's a thing called "Boolean+Auto" which is -1 for
            ## auto, 0 for false and 1 for true. could be nicer if it
            ## was called AutoBoolean or something, but...
            value = value.replace('+', '_')

            inst = None
            # FIXME: put parser classes in dict instead?
            for cls in config_types:
                if cls.__name__ == value:
                    inst = cls()
            if not inst:
                raise RuntimeError("Don't have a parser for: " + value)
            v = yield self.protocol.get_conf(name)
            v = v[name]

            self.parsers[name] = inst

            if value == 'LineList':
                ## FIXME should move to the parse() method, but it
                ## doesn't have access to conf object etc.
                self.config[self._find_real_name(name)] = _ListWrapper(self.parsers[name].parse(v), functools.partial(self.mark_unsaved, name))

            else:
                self.config[self._find_real_name(name)] = self.parsers[name].parse(v)

        # can't just return in @inlineCallbacks-decorated methods
        defer.returnValue(self)

    def _setup_hidden_services(self, servicelines):
        hs = []
        directory = None
        ports = []
        ver = None
        auth = None
        for line in servicelines.split('\n'):
            if not len(line.strip()):
                continue

            if line == 'HiddenServiceOptions':
                continue
            k, v = line.split('=')
            if k == 'HiddenServiceDir':
                if directory is not None:
                    hs.append(HiddenService(self, directory, ports, auth, ver))
                directory = v
                ports = []
                ver = None
                auth = None

            elif k == 'HiddenServicePort':
                ports.append(v)

            elif k == 'HiddenServiceVersion':
                ver = int(v)

            elif k == 'HiddenServiceAuthorizeClient':
                auth = v

            else:
                raise RuntimeError("Can't parse HiddenServiceOptions: " + k)

        if directory is not None:
            hs.append(HiddenService(self, directory, ports, auth, ver))

        name = 'HiddenServices'
        self.config[name] = _ListWrapper(hs, functools.partial(self.mark_unsaved, name))

    def create_torrc(self):
        rtn = StringIO()

        for (k, v) in self.config.items() + self.unsaved.items():
            if type(v) is _ListWrapper:
                if k.lower() == 'hiddenservices':
                    for x in v:
                        for (kk, vv) in x.config_attributes():
                            rtn.write('%s %s\n' % (kk, vv))

                else:
                    for x in v:
                        rtn.write('%s %s\n' % (k, x))

            else:
                rtn.write('%s %s\n' % (k, v))

        return rtn.getvalue()

########NEW FILE########
__FILENAME__ = torcontrolprotocol
from __future__ import with_statement

from twisted.python import log
from twisted.internet import defer
from twisted.internet.interfaces import IProtocolFactory
from twisted.internet.error import ConnectionDone
from twisted.protocols.basic import LineOnlyReceiver
from zope.interface import implements

from txtorcon.util import hmac_sha256, compare_via_hash
from txtorcon.log import txtorlog

from txtorcon.interface import ITorControlProtocol
from spaghetti import FSM, State, Transition

import os
import re
import types
import base64

DEFAULT_VALUE = 'DEFAULT'
DEBUG = False


class TorProtocolError(RuntimeError):
    """
    Happens on 500-level responses in the protocol, almost certainly
    in an errback chain.

    :ivar code: the actual error code
    :ivar text: other text from the protocol
    """

    def __init__(self, code, text):
        self.code = code
        self.text = text
        super(TorProtocolError, self).__init__(text)

    def __str__(self):
        return str(self.code) + ' ' + self.text


class TorProtocolFactory(object):
    """
    Builds TorControlProtocol objects. Implements IProtocolFactory for
    Twisted interaction.

    If your running Tor doesn't support COOKIE authentication, then
    you should supply a password callback.
    """

    implements(IProtocolFactory)

    def __init__(self, password_function=lambda: None):
        """
        Builds protocols to talk to a Tor client on the specified
        address. For example::

        TCP4ClientEndpoint(reactor, "localhost", 9051).connect(TorProtocolFactory())
        reactor.run()

        By default, COOKIE authentication is used if
        available.

        :param password_function:
           If supplied, this is a zero-argument method that returns a
           password (or a Deferred). By default, it returns None. This
           is only queried if the Tor we connect to doesn't support
           (or hasn't enabled) COOKIE authentication.
        """
        self.password_function = password_function

    def doStart(self):
        ":api:`twisted.internet.interfaces.IProtocolFactory` API"

    def doStop(self):
        ":api:`twisted.internet.interfaces.IProtocolFactory` API"

    def buildProtocol(self, addr):
        ":api:`twisted.internet.interfaces.IProtocolFactory` API"
        proto = TorControlProtocol(self.password_function)
        proto.factory = self
        return proto


class Event(object):
    """
    A class representing one of the valid EVENTs that Tor
    supports.

    This allows you to listen for such an event; see
    TorController.add_event The callbacks will be called every time
    the event in question is received.
    """
    def __init__(self, name):
        self.name = name
        self.callbacks = []

    def listen(self, cb):
        self.callbacks.append(cb)

    def unlisten(self, cb):
        self.callbacks.remove(cb)

    def got_update(self, data):
        #print self.name,"got_update:",data
        for cb in self.callbacks:
            cb(data)


def unquote(word):
    if len(word) == 0:
        return word
    if word[0] == '"' and word[-1] == '"':
        return word[1:-1]
    elif word[0] == "'" and word[-1] == "'":
        return word[1:-1]
    return word


def parse_keywords(lines, multiline_values=True):
    """
    Utility method to parse name=value pairs (GETINFO etc). Takes a
    string with newline-separated lines and expects at most one = sign
    per line. Accumulates multi-line values.

    :param multiline_values:
        The default is True which allows for multi-line values until a
        line with the next = sign on it. So: '''Foo=bar\nBar'''
        produces one key, 'Foo', with value 'bar\nBar' -- set to
        False, there would be two keys: 'Foo' with value 'bar' and
        'Bar' with value DEFAULT_VALUE.
    """

    rtn = {}
    key = None
    value = ''
    ## FIXME could use some refactoring to reduce code duplication!
    for line in lines.split('\n'):
        if line.strip() == 'OK':
            continue

        if '=' in line and ' ' not in line.split('=', 1)[0]:
            if key:
                if key in rtn:
                    if isinstance(rtn[key], types.ListType):
                        rtn[key].append(unquote(value))
                    else:
                        rtn[key] = [rtn[key], unquote(value)]
                else:
                    rtn[key] = unquote(value)
            (key, value) = line.split('=', 1)

        else:
            if key is None:
                rtn[line.strip()] = DEFAULT_VALUE

            elif multiline_values is False:
                rtn[key] = value
                rtn[line.strip()] = DEFAULT_VALUE
                key = None
                value = ''

            else:
                value = value + '\n' + line
    if key:
        if key in rtn:
            if isinstance(rtn[key], types.ListType):
                rtn[key].append(unquote(value))
            else:
                rtn[key] = [rtn[key], unquote(value)]
        else:
            rtn[key] = unquote(value)
    return rtn


class TorControlProtocol(LineOnlyReceiver):
    """
    This is the main class that talks to a Tor and implements the "raw"
    procotol.

    This instance does not track state; see :class:`txtorcon.TorState`
    for the current state of all Circuits, Streams and Routers.

    :meth:`txtorcon.TorState.build_circuit` allows you to build custom
    circuits.

    :meth:`txtorcon.TorControlProtocol.add_event_listener` can be used
    to listen for specific events.

    To see how circuit and stream listeners are used, see
    :class:`txtorcon.TorState`, which is also the place to go if you
    wish to add your own stream or circuit listeners.
    """

    implements(ITorControlProtocol)

    def __init__(self, password_function=None, api_version=1):
        """
        :param password_function:
            A zero-argument callable which returns a password (or
            Deferred). It is only called if the Tor doesn't have
            COOKIE authentication turned on. Tor's default is COOKIE.

        :param api_version:
            Specifies which version of the API you wish to use. This
            is to ease transitions to new API arguments or meanings in
            the future -- current users can safely set this to its
            current default value (1) to be sure their usage of
            public-facing methods in this object won't change.
            Introduced in 0.9.2. The following API versions are known:
                * ``api_version=1``: 0.9.2 and later; the current API version.
        """

        self.password_function = password_function
        """If set, a callable to query for a password to use for
        authentication to Tor (default is to use COOKIE, however). May
        return Deferred."""

        self.version = None
        """Version of Tor we've connected to."""

        self.is_owned = None
        """If not None, this is the PID of the Tor process we own
        (TAKEOWNERSHIP, etc)."""

        self.events = {}
        """events we've subscribed to (keyed by name like "GUARD", "STREAM")"""

        self.valid_events = {}
        """all valid events (name -> Event instance)"""

        self.valid_signals = []
        """A list of all valid signals we accept from Tor"""

        if api_version == 0:
            api_version = 1
        self.api_version = api_version

        self.on_disconnect = defer.Deferred()
        """
        This Deferred is triggered when the connection is closed. If
        there was an error, the errback is called instead.
        """

        self.post_bootstrap = defer.Deferred()
        """
        This Deferred is triggered when we're done setting up
        (authentication, getting information from Tor). You will want
        to use this to do things with the :class:`TorControlProtocol`
        class when it's set up, like::

            def setup_complete(proto):
                print "Setup complete, attached to Tor version",proto.version

            def setup(proto):
                proto.post_bootstrap.addCallback(setup_complete)

            TCP4ClientEndpoint(reactor, "localhost", 9051).connect(TorProtocolFactory())
            d.addCallback(setup)

        See the helper method :func:`txtorcon.build_tor_connection`.
        """

        ## variables related to the state machine
        self.defer = None               # Deferred we returned for the current command
        self.response = ''
        self.code = None
        self.command = None             # currently processing this command
        self.commands = []              # queued commands

        ## Here we build up the state machine. Mostly it's pretty
        ## simply, confounded by the fact that 600's (notify) can come
        ## at any time AND can be multi-line itself. Luckily, these
        ## can't be nested, nor can the responses be interleaved.

        idle = State("IDLE")
        recv = State("RECV")
        recvmulti = State("RECV_PLUS")
        recvnotify = State("NOTIFY_MULTILINE")

        idle.add_transition(Transition(idle,
                                       self._is_single_line_response,
                                       self._broadcast_response))
        idle.add_transition(Transition(recvmulti,
                                       self._is_multi_line,
                                       self._start_command))
        idle.add_transition(Transition(recv,
                                       self._is_continuation_line,
                                       self._start_command))

        recv.add_transition(Transition(recvmulti,
                                       self._is_multi_line,
                                       self._accumulate_response))
        recv.add_transition(Transition(recv,
                                       self._is_continuation_line,
                                       self._accumulate_response))
        recv.add_transition(Transition(idle,
                                       self._is_finish_line,
                                       self._broadcast_response))

        recvmulti.add_transition(Transition(recv,
                                            self._is_end_line,
                                            lambda x: None))
        recvmulti.add_transition(Transition(recvmulti,
                                            self._is_not_end_line,
                                            self._accumulate_multi_response))

        self.fsm = FSM([recvnotify, idle, recvmulti, recv])
        self.state_idle = idle
        ## hand-set initial state default start state is first in the
        ## list; the above looks nice in dotty though
        self.fsm.state = idle
        if DEBUG:
            self.debuglog = open('txtorcon-debug.log', 'w')
            with open('fsm.dot', 'w') as fsmfile:
                fsmfile.write(self.fsm.dotty())

    ## see end of file for all the state machine matcher and
    ## transition methods.

    def get_info_raw(self, *args):
        """
        Mostly for internal use; gives you the raw string back from
        the GETINFO command. See :meth:`getinfo <txtorcon.TorControlProtocol.get_info>`
        """
        info = ' '.join(map(lambda x: str(x), list(args)))
        return self.queue_command('GETINFO %s' % info)

    def get_info_incremental(self, key, line_cb):
        """
        Mostly for internal use; calls GETINFO for a single key and
        calls line_cb with each line received, as it is received.

        See :meth:`getinfo <txtorcon.TorControlProtocol.get_info>`
        """

        def strip_ok_and_call(line):
            if line.strip() != 'OK':
                line_cb(line)
        return self.queue_command('GETINFO %s' % key, strip_ok_and_call)

    ## The following methods are the main TorController API and
    ## probably the most interesting for users.

    def get_info(self, *args):
        """
        Uses GETINFO to obtain informatoin from Tor.

        :param args:
            should be a list or tuple of strings which are valid
            information keys. For valid keys, see control-spec.txt
            from torspec.

            .. todo:: make some way to automagically obtain valid
                keys, either from running Tor or parsing control-spec

        :return:
            a ``Deferred`` which will callback with a dict containing
            the keys you asked for. This just inserts ``parse_keywords``
            in the callback chain; if you want to avoid the parsing
            into a dict, you can use get_info_raw instead.
        """
        return self.get_info_raw(*args).addCallback(parse_keywords)

    def get_conf(self, *args):
        """
        Uses GETCONF to obtain configuration values from Tor.

        :param args: any number of strings which are keys to get. To
            get all valid configuraiton names, you can call:
            ``get_info('config/names')``

        :return: a Deferred which callbacks with one or many
            configuration values (depends on what you asked for). See
            control-spec for valid keys (you can also use TorConfig which
            will come set up with all the keys that are valid). The value
            will be a dict.

        Note that Tor differentiates between an empty value and a
        default value; in the raw protocol one looks like '250
        MyFamily' versus '250 MyFamily=' where the latter is set to
        the empty string and the former is a default value. We
        differentiate these by setting the value in the dict to
        DEFAULT_VALUE for the default value case, or an empty string
        otherwise.
        """

        return self.queue_command('GETCONF %s' % ' '.join(args)).addCallback(parse_keywords).addErrback(log.err)

    def get_conf_raw(self, *args):
        """
        Same as get_conf, except that the results are not parsed into a dict
        """

        return self.queue_command('GETCONF %s' % ' '.join(args))

    def set_conf(self, *args):
        """
        set configuration values. see control-spec for valid
        keys. args is treated as a list containing name then value
        pairs. For example, ``set_conf('foo', 'bar')`` will (attempt
        to) set the key 'foo' to value 'bar'.

        :return: a ``Deferred`` that will callback with the response
            ('OK') or errback with the error code and message (e.g.
            ``"552 Unrecognized option: Unknown option 'foo'.  Failing."``)
        """
        if len(args) % 2:
            d = defer.Deferred()
            d.errback(RuntimeError("Expected an even number of arguments."))
            return d
        strargs = map(lambda x: str(x), args)
        keys = [strargs[i] for i in range(0, len(strargs), 2)]
        values = [strargs[i] for i in range(1, len(strargs), 2)]

        def maybe_quote(s):
            if ' ' in s:
                return '"%s"' % s
            return s
        values = map(maybe_quote, values)
        args = ' '.join(map(lambda x, y: '%s=%s' % (x, y), keys, values))
        return self.queue_command('SETCONF ' + args)

    def signal(self, nm):
        """
        Issues a signal to Tor. See control-spec or
        :attr:`txtorcon.TorControlProtocol.valid_signals` for which ones
        are available and their return values.

        :return: a ``Deferred`` which callbacks with Tor's response
            (``OK`` or something like ``552 Unrecognized signal code "foo"``).
        """
        if not nm in self.valid_signals:
            raise RuntimeError("Invalid signal " + nm)
        return self.queue_command('SIGNAL %s' % nm)

    def add_event_listener(self, evt, callback):
        """
        :param evt: event name, see also
        :var:`txtorcon.TorControlProtocol.events` .keys()

        Add a listener to an Event object. This may be called multiple
        times for the same event. If it's the first listener, a new
        SETEVENTS call will be initiated to Tor.

        Currently the callback is any callable that takes a single
        argument, that is the text collected for the event from the
        tor control protocol.

        :Return: ``None``

        .. todo::
            need an interface for the callback
            show how to tie in Stem parsing if you want
        """

        if not evt in self.valid_events.values():
            try:
                evt = self.valid_events[evt]
            except:
                raise RuntimeError("Unknown event type: " + evt)

        if evt.name not in self.events:
            self.events[evt.name] = evt
            self.queue_command('SETEVENTS %s' % ' '.join(self.events.keys()))
        evt.listen(callback)
        return None

    def remove_event_listener(self, evt, cb):
        if not evt in self.valid_events.values():
            try:
                evt = self.valid_events[evt]
            except:
                raise RuntimeError("Unknown event type: " + evt)

        evt.unlisten(cb)
        if len(evt.callbacks) == 0:
            del self.events[evt.name]
            self.queue_command('SETEVENTS %s' % ' '.join(self.events.keys()))

    def protocolinfo(self):
        """
        :return: a Deferred which will give you PROTOCOLINFO; see control-spec
        """

        return self.queue_command("PROTOCOLINFO 1")

    def authenticate(self, passphrase):
        """Call the AUTHENTICATE command."""
        return self.queue_command('AUTHENTICATE ' + passphrase.encode("hex"))

    def quit(self):
        """
        Sends the QUIT command, which asks Tor to hang up on this
        controller connection.

        If you've taken ownership of the Tor to which you're
        connected, this should also cause it to exit. Otherwise, it
        won't.
        """
        return self.queue_command('QUIT')

    def queue_command(self, cmd, arg=None):
        """
        returns a Deferred which will fire with the response data when
        we get it

        Note that basically every request is ultimately funelled
        through this command.
        """

        d = defer.Deferred()
        self.commands.append((d, cmd, arg))
        self._maybe_issue_command()
        return d

    ## the remaining methods are internal API implementations,
    ## callbacks and state-tracking methods -- you shouldn't have any
    ## need to call them.

    def lineReceived(self, line):
        """
        :api:`twisted.protocols.basic.LineOnlyReceiver` API
        """

        if DEBUG:
            self.debuglog.write(line + '\n')
            self.debuglog.flush()

        self.fsm.process(line)

    def connectionMade(self):
        "Protocol API"
        txtorlog.msg('got connection, authenticating')
        self.protocolinfo().addCallback(self._do_authenticate).addErrback(self._auth_failed)

    def connectionLost(self, reason):
        "Protocol API"
        txtorlog.msg('connection terminated: ' + str(reason))
        if self.on_disconnect.callbacks:
            if reason.check(ConnectionDone):
                self.on_disconnect.callback(self)
            else:
                self.on_disconnect.errback(reason)
        self.on_disconnect = None
        return None

    def _handle_notify(self, code, rest):
        """
        Internal method to deal with 600-level responses.
        """

        firstline = rest[:rest.find('\n')]
        args = firstline.split()
        if args[0] in self.events:
            self.events[args[0]].got_update(rest[len(args[0]) + 1:])
            return

        raise RuntimeError("Wasn't listening for event of type " + args[0])

    def _maybe_issue_command(self):
        """
        If there's at least one command queued and we're not currently
        processing a command, this will issue the next one on the
        wire.
        """
        if self.command:
            return

        if len(self.commands):
            self.command = self.commands.pop(0)
            (d, cmd, cmd_arg) = self.command
            self.defer = d

            if DEBUG:
                #print "NOTIFY",code,rest
                self.debuglog.write(cmd + '\n')
                self.debuglog.flush()

            self.transport.write(cmd + '\r\n')

    def _auth_failed(self, fail):
        """
        Errback if authentication fails.
        """

        if self.post_bootstrap:
            self.post_bootstrap.errback(fail)
            return None
        return fail

    def _safecookie_authchallenge(self, reply):
        """
        Callback on AUTHCHALLENGE SAFECOOKIE
        """

        kw = parse_keywords(reply.replace(' ', '\n'))

        server_hash = base64.b16decode(kw['SERVERHASH'])
        server_nonce = base64.b16decode(kw['SERVERNONCE'])
        ## FIXME put string in global. or something.
        expected_server_hash = hmac_sha256("Tor safe cookie authentication server-to-controller hash",
                                           self.cookie_data + self.client_nonce + server_nonce)

        if not compare_via_hash(expected_server_hash, server_hash):
            raise RuntimeError('Server hash not expected; wanted "%s" and got "%s".' % (base64.b16encode(expected_server_hash),
                                                                                        base64.b16encode(server_hash)))

        client_hash = hmac_sha256("Tor safe cookie authentication controller-to-server hash",
                                  self.cookie_data + self.client_nonce + server_nonce)
        client_hash_hex = base64.b16encode(client_hash)
        return self.queue_command('AUTHENTICATE %s' % client_hash_hex)

    def _do_authenticate(self, protoinfo):
        """
        Callback on PROTOCOLINFO to actually authenticate once we know
        what's supported.
        """

        methods = None
        for line in protoinfo.split('\n'):
            if line[:5] == 'AUTH ':
                kw = parse_keywords(line[5:].replace(' ', '\n'))
                methods = kw['METHODS'].split(',')
        if not methods:
            raise RuntimeError("Didn't find AUTH line in PROTOCOLINFO response.")

        if 'SAFECOOKIE' in methods:
            cookie = re.search('COOKIEFILE="(.*)"', protoinfo).group(1)
            self.cookie_data = open(cookie, 'r').read()
            if len(self.cookie_data) != 32:
                raise RuntimeError("Expected authentication cookie to be 32 bytes, got %d" % len(self.cookie_data))
            txtorlog.msg("Using SAFECOOKIE authentication", cookie,
                         len(self.cookie_data), "bytes")
            self.client_nonce = os.urandom(32)

            d = self.queue_command('AUTHCHALLENGE SAFECOOKIE %s' % base64.b16encode(self.client_nonce))
            d.addCallback(self._safecookie_authchallenge).addCallback(self._bootstrap).addErrback(self._auth_failed)
            return

        elif 'COOKIE' in methods:
            cookie = re.search('COOKIEFILE="(.*)"', protoinfo).group(1)
            with open(cookie, 'r') as cookiefile:
                data = cookiefile.read()
            if len(data) != 32:
                raise RuntimeError("Expected authentication cookie to be 32 bytes, got %d" % len(data))
            txtorlog.msg("Using COOKIE authentication", cookie, len(data), "bytes")
            self.authenticate(data).addCallback(self._bootstrap).addErrback(self._auth_failed)
            return

        if self.password_function:
            passwd = defer.maybeDeferred(self.password_function)
            passwd.addCallback(self._do_password_authentication).addErrback(self._auth_failed)
            return

        raise RuntimeError("The Tor I connected to doesn't support SAFECOOKIE nor COOKIE authentication and I have no password_function specified.")

    def _do_password_authentication(self, passwd):
        if not passwd:
            raise RuntimeError("No password available.")
        self.authenticate(passwd).addCallback(self._bootstrap).addErrback(self._auth_failed)

    def _set_valid_events(self, events):
        "used as a callback; see _bootstrap"
        self.valid_events = {}
        for x in events.split():
            self.valid_events[x] = Event(x)

    @defer.inlineCallbacks
    def _bootstrap(self, *args):
        """
        The inlineCallbacks decorator allows us to make this method
        look synchronous; see the Twisted docs. Each yeild is for a
        Deferred after which the method continues. When this method
        finally exits, we're set up and do the post_bootstrap
        callback.
        """

        ## unfortunately I don't see a way to get this from the runing
        ## tor like the events...so this was taken from some version
        ## of the control-spec and must be kept up-to-date (or accpet
        ## any signal name and just wait for the reply?
        self.valid_signals = ["RELOAD", "DUMP", "DEBUG", "NEWNYM", "CLEARDNSCACHE"]

        self.version = yield self.get_info('version')
        self.version = self.version['version']
        txtorlog.msg("Connected to a Tor with VERSION", self.version)
        eventnames = yield self.get_info('events/names')
        eventnames = eventnames['events/names']
        self._set_valid_events(eventnames)

        yield self.queue_command('USEFEATURE EXTENDED_EVENTS')

        self.post_bootstrap.callback(self)
        self.post_bootstrap = None
        defer.returnValue(self)

    ##
    ## State Machine transitions and matchers. See the __init__ method
    ## for a way to output a GraphViz dot diagram of the machine.
    ##

    def _is_end_line(self, line):
        "for FSM"
        return line.strip() == '.'

    def _is_not_end_line(self, line):
        "for FSM"
        return not self._is_end_line(line)

    def _is_single_line_response(self, line):
        "for FSM"
        try:
            code = int(line[:3])
        except:
            return False

        sl = len(line) > 3 and line[3] == ' '
        #print "single line?",line,sl
        if sl:
            self.code = code
            return True
        return False

    def _start_command(self, line):
        "for FSM"
        # print "startCommand",self.code,line
        self.code = int(line[:3])
        # print "startCommand:",self.code
        if self.command and self.command[2] is not None:
            self.command[2](line[4:])
        else:
            self.response = line[4:] + '\n'
        return None

    def _is_continuation_line(self, line):
        "for FSM"
        # print "isContinuationLine",self.code,line
        code = int(line[:3])
        if self.code and self.code != code:
            raise RuntimeError("Unexpected code %d, wanted %d" % (code,
                                                                  self.code))
        return line[3] == '-'

    def _is_multi_line(self, line):
        "for FSM"
        # print "isMultiLine",self.code,line,line[3] == '+'
        code = int(line[:3])
        if self.code and self.code != code:
            raise RuntimeError("Unexpected code %d, wanted %d" % (code,
                                                                  self.code))
        return line[3] == '+'

    def _accumulate_multi_response(self, line):
        "for FSM"
        if self.command and self.command[2] is not None:
            self.command[2](line)

        else:
            self.response += (line + '\n')
        return None

    def _accumulate_response(self, line):
        "for FSM"
        if self.command and self.command[2] is not None:
            self.command[2](line[4:])

        else:
            self.response += (line[4:] + '\n')
        return None

    def _is_finish_line(self, line):
        "for FSM"
        # print "isFinish",line
        if len(line) < 1:
            return False
        if line[0] == '.':
            return True
        if len(line) > 3 and line[3] == ' ':
            return True
        return False

    def _broadcast_response(self, line):
        "for FSM"
        # print "BCAST",line
        if len(line) > 3:
            if self.code >= 200 and self.code < 300 and self.command and self.command[2] is not None:
                self.command[2](line[4:])
                resp = ''

            else:
                resp = self.response + line[4:]
        else:
            resp = self.response
        self.response = ''
        if self.code >= 200 and self.code < 300:
            if self.defer is None:
                raise RuntimeError("Got a response, but didn't issue a command.")
            if resp.endswith('\nOK'):
                resp = resp[:-3]
            self.defer.callback(resp)
        elif self.code >= 500 and self.code < 600:
            err = TorProtocolError(self.code, resp)
            self.defer.errback(err)
        elif self.code >= 600 and self.code < 700:
            self._handle_notify(self.code, resp)
            self.code = None
            return
        elif self.code is None:
            raise RuntimeError("No code set yet in broadcast response.")
        else:
            raise RuntimeError("Unknown code in broadcast response %d." % self.code)

        ## note: we don't do this for 600-level responses
        self.command = None
        self.code = None
        self.defer = None
        self._maybe_issue_command()
        return None

########NEW FILE########
__FILENAME__ = torinfo
import functools
from twisted.internet import defer

from txtorcon.interface import ITorControlProtocol


class MagicContainer(object):
    """
    This merely contains 1 or more methods or further MagicContainer
    instances; see _do_setup in TorInfo.

    Once _setup_complete() is called, this behaves differently so that
    one can get nicer access to GETINFO things from TorInfo --
    specifically dir() and so forth pretend that there are only
    methods/attributes that pertain to actual Tor GETINFO keys.

    See TorInfo.
    """

    def __init__(self, n):
        self._txtorcon_name = n
        self.attrs = {}
        self._setup = False

    def _setup_complete(self):
        self._setup = True

    def _add_attribute(self, n, v):
        self.attrs[n] = v

    def __repr__(self):
        return object.__getattribute__(self, '_txtorcon_name')

    def __getitem__(self, idx):
        return object.__getattribute__(self, 'attrs').items()[idx][1]

    def __len__(self):
        return len(object.__getattribute__(self, 'attrs'))

    def __getattribute__(self, name):
        sup = super(MagicContainer, self)
        if sup.__getattribute__('_setup') is False:
            return sup.__getattribute__(name)

        attrs = sup.__getattribute__('attrs')
        if name == '__members__':
            return attrs.keys()

        else:
            try:
                return attrs[name]
            except KeyError:
                if name in ['dump']:
                    return object.__getattribute__(self, name)
                raise AttributeError(name)

    def dump(self, prefix):
        prefix = prefix + '.' + object.__getattribute__(self, '_txtorcon_name')
        for x in object.__getattribute__(self, 'attrs').values():
            x.dump(prefix)


class ConfigMethod(object):
    def __init__(self, info_key, protocol, takes_arg=False):
        self.info_key = info_key
        self.proto = protocol
        self.takes_arg = takes_arg

    def dump(self, prefix):
        n = self.info_key.replace('/', '.')
        n = n.replace('-', '_')
        s = '%s(%s)' % (n, 'arg' if self.takes_arg else '')
        #print s
        return s

    def __call__(self, *args):
        if self.takes_arg:
            if len(args) != 1:
                raise TypeError('"%s" takes exactly one argument' % self.info_key)
            req = '%s/%s' % (self.info_key, str(args[0]))

        else:
            if len(args) != 0:
                raise TypeError('"%s" takes no arguments' % self.info_key)

            req = self.info_key

        def stripper(key, arg):
            ## strip "keyname="
            ## sometimes keyname= is followed by a newline, so the final .strip()
            return arg.strip()[len(key) + 1:].strip()

        return self.proto.get_info_raw(req).addCallback(functools.partial(stripper, req))

    def __str__(self):
        arg = ''
        if self.takes_arg:
            arg = 'arg'
        return '%s(%s)' % (self.info_key.replace('-', '_'), arg)


class TorInfo(object):
    """
    Implements some attribute magic over top of TorControlProtocol so
    that all the available GETINFO values are gettable in a little
    easier fashion. Dashes are replaced by underscores (since dashes
    aren't valid in method/attribute names for Python). Some of the
    magic methods will take a single string argument if the
    corresponding Tor GETINFO would take one (in 'GETINFO info/names'
    it will end with '/*', and the same in torspec). In either case,
    the method returns a Deferred which will callback with the
    requested value, always a string.

    For example (see also examples/tor_info.py):

        proto = TorControlProtocol()
        #...
        def cb(arg):
            print arg
        info = TorInfo(proto)
        info.traffic.written().addCallback(cb)
        info.ip_to_country('8.8.8.8').addCallback(cb)

    For interactive use -- or even checking things progammatically -- TorInfo
    pretends it only has attributes that coorespond to valid GETINFO calls.
    So for example, dir(info) will only return all the currently valid top-level
    things. In the above example this might be ['traffic', 'ip_to_country'] (of
    course in practice this is a much longer list). And "dir(info.traffic)" might
    return ['read', 'written']

    For something similar to this for configuration (GETCONF, SETCONF) see
    TorConfig which is quite a lot more complicated (internally) since you can set
    config items.

    NOTE that 'GETINFO config/*' is not supported as it's the only case that's not a
    leaf, but theoretically a method.
    """

    def __init__(self, control, errback=None):
        self._setup = False
        self.attrs = {}
        '''After _setup is True, these are all we show as attributes.'''

        self.protocol = ITorControlProtocol(control)
        self.errback = errback

        self.post_bootstrap = defer.Deferred()
        if self.protocol.post_bootstrap:
            self.protocol.post_bootstrap.addCallback(self.bootstrap)

        else:
            self.bootstrap()

    def _add_attribute(self, n, v):
        self.attrs[n] = v

    ## iterator protocol

    def __getitem__(self, idx):
        return object.__getattribute__(self, 'attrs').items()[idx][1]

    def __len__(self):
        return len(object.__getattribute__(self, 'attrs'))

    ## change our attribute behavior based on the value of _setup

    def __getattribute__(self, name):
        sup = super(TorInfo, self)
        if sup.__getattribute__('_setup') is False:
            return sup.__getattribute__(name)

        attrs = sup.__getattribute__('attrs')
        if name == '__members__':
            return attrs.keys()

        else:
            try:
                return attrs[name]

            except KeyError:
                if name == 'dump':
                    return object.__getattribute__(self, name)

        raise AttributeError(name)

    def bootstrap(self, *args):
        d = self.protocol.get_info_raw("info/names").addCallback(self._do_setup)
        if self.errback:
            d.addErrback(self.errback)
        d.addCallback(self._setup_complete)
        return d

    def dump(self):
        for x in object.__getattribute__(self, 'attrs').values():
            x.dump('')

    def _do_setup(self, data):
        # FIXME figure out why network-status doesn't work (get nothing back from
        # Tor it seems, although stem does get an answer). this is a space-separated
        # list of ~2500 OR id's; could it be that LineReceiver can't handle it?
        added_magic = []
        for line in data.split('\n'):
            if line == "info/names=" or line.strip() == '':
                continue

            #print "LINE:",line
            (name, documentation) = line.split(' ', 1)
            ## FIXME think about this -- this is the only case where
            ## there's something that's a directory
            ## (i.e. MagicContainer) AND needs to be a ConfigMethod as
            ## well...but doesn't really seem very useful. Somewhat
            ## simpler to not support this case for now...
            if name == 'config/*':
                continue

            if name.endswith('/*'):
                ## this takes an arg, so make a method
                bits = name[:-2].split('/')
                takes_arg = True

            else:
                bits = name.split('/')
                takes_arg = False

            mine = self
            for bit in bits[:-1]:
                bit = bit.replace('-', '_')
                if bit in mine.attrs:
                    mine = mine.attrs[bit]
                    if not isinstance(mine, MagicContainer):
                        raise RuntimeError("Already had something: %s for %s" % (bit, name))

                else:
                    c = MagicContainer(bit)
                    added_magic.append(c)
                    mine._add_attribute(bit, c)
                    mine = c
            n = bits[-1].replace('-', '_')
            if n in mine.attrs:
                raise RuntimeError("Already had something: %s for %s" % (n, name))
            mine._add_attribute(n, ConfigMethod('/'.join(bits), self.protocol, takes_arg))

        for c in added_magic:
            c._setup_complete()
        return None

    def _setup_complete(self, *args):
        pb = self.post_bootstrap
        self._setup = True
        pb.callback(self)

########NEW FILE########
__FILENAME__ = torstate
import datetime
import os
import stat
import types
import warnings

from twisted.python import log
from twisted.internet import defer
from twisted.internet.endpoints import TCP4ClientEndpoint, UNIXClientEndpoint
from twisted.internet.interfaces import IReactorCore, IStreamClientEndpoint
from zope.interface import implements

from txtorcon import TorProtocolFactory
from txtorcon.stream import Stream
from txtorcon.circuit import Circuit
from txtorcon.router import Router, hashFromHexId
from txtorcon.addrmap import AddrMap
from txtorcon.torcontrolprotocol import parse_keywords
from txtorcon.log import txtorlog
from txtorcon.torcontrolprotocol import TorProtocolError

from txtorcon.interface import ITorControlProtocol, IRouterContainer, ICircuitListener
from txtorcon.interface import ICircuitContainer, IStreamListener, IStreamAttacher
from spaghetti import FSM, State, Transition


def _build_state(proto):
    state = TorState(proto)
    return state.post_bootstrap


def _wait_for_proto(proto):
    return proto.post_bootstrap


def build_tor_connection(connection, build_state=True, wait_for_proto=True,
                         password_function=lambda: None):
    """
    This is used to build a valid TorState (which has .protocol for
    the TorControlProtocol). For example::

        from twisted.internet import reactor
        from twisted.internet.endpoints import TCP4ClientEndpoint
        import txtorcon

        def example(state):
            print "Fully bootstrapped state:",state
            print "   with bootstrapped protocol:",state.protocol

        d = txtorcon.build_tor_connection(TCP4ClientEndpoint(reactor,
                                                             "localhost",
                                                             9051))
        d.addCallback(example)
        reactor.run()

    :param password_function:
        See :class:`txtorcon.TorControlProtocol`

    :param build_state:
        If True (the default) a TorState object will be
        built as well. If False, just a TorControlProtocol will be
        returned via the Deferred.

    :return:
        a Deferred that fires with a TorControlProtocol or, if you
        specified build_state=True, a TorState. In both cases, the
        object has finished bootstrapping
        (i.e. TorControlProtocol.post_bootstrap or
        TorState.post_bootstap has fired, as needed)
    """

    if IStreamClientEndpoint.providedBy(connection):
        endpoint = connection

    elif isinstance(connection, tuple):
        if len(connection) == 2:
            reactor, socket = connection
            if (os.path.exists(socket) and
                os.stat(socket).st_mode & (stat.S_IRGRP | stat.S_IRUSR |
                                           stat.S_IROTH)):
                endpoint = UNIXClientEndpoint(reactor, socket)
            else:
                raise ValueError('Can\'t use "%s" as a socket' % (socket, ))
        elif len(connection) == 3:
            endpoint = TCP4ClientEndpoint(*connection)
        else:
            raise TypeError('Expected either a (reactor, socket)- or a '
                            '(reactor, host, port)-tuple for argument '
                            '"connection", got %s' % (connection, ))
    else:
        raise TypeError('Expected a (reactor, socket)- or a (reactor, host, '
                        'port)-tuple or an object implementing IStreamClient'
                        'Endpoint for argument "connection", got %s' %
                        (connection, ))

    d = endpoint.connect(TorProtocolFactory(password_function=password_function))
    if build_state:
        d.addCallback(build_state if callable(build_state) else _build_state)
    elif wait_for_proto:
        d.addCallback(wait_for_proto if callable(wait_for_proto) else
                      _wait_for_proto)
    return d


def build_local_tor_connection(reactor, host='127.0.0.1', port=9051,
                               socket='/var/run/tor/control', *args, **kwargs):
    """
    This builds a connection to a local Tor, either via 127.0.0.1:9051
    (which is tried first) or /var/run/tor/control (by default). See
    also :meth:`build_tor_connection
    <txtorcon.torstate.build_tor_connection>` for other key-word
    arguments that are accepted here also.

    :param host:
        An IP address to find Tor at. Corresponds to the
        ControlListenAddress torrc option.

    :param port:
        The port to use with the address when trying to contact
        Tor. This corresponds to the ControlPort option in torrc
        (default is 9051).
    """

    try:
        return build_tor_connection((reactor, socket), *args, **kwargs)
    except:
        return build_tor_connection((reactor, host, port), *args, **kwargs)


def flags_from_dict(kw):
    """
    This turns a dict with keys that are flags (e.g. for CLOSECIRCUIT,
    CLOSESTREAM) only if the values are true.
    """

    if len(kw) == 0:
        return ''

    flags = ''
    for (k, v) in kw.iteritems():
        if v:
            flags += ' ' + str(k)
    # note that we want the leading space if there's at least one
    # flag.
    return flags


class TorState(object):
    """
    This tracks the current state of Tor using a TorControlProtocol.

    On setup it first queries the initial state of streams and
    circuits. It then asks for updates via the listeners. It requires
    an ITorControlProtocol instance. The control protocol doesn't need
    to be bootstrapped yet. The Deferred .post_boostrap is driggered
    when the TorState instance is fully ready to go.  The easiest way
    is to use the helper method
    :func:`txtorcon.build_tor_connection`. For details, see the
    implementation of that.

    You may add an :class:`txtorcon.interface.IStreamAttacher` to
    provide a custom mapping for Strams to Circuits (by default Tor
    picks by itself).

    This is also a good example of the various listeners, and acts as
    an :class:`txtorcon.interface.ICircuitContainer` and
    :class:`txtorcon.interface.IRouterContainer`.
    """

    implements(ICircuitListener, ICircuitContainer, IRouterContainer,
               IStreamListener)

    def __init__(self, protocol, bootstrap=True, write_state_diagram=False):
        self.protocol = ITorControlProtocol(protocol)
        ## fixme could use protocol.on_disconnect to re-connect; see issue #3

        ## could override these to get your own Circuit/Stream subclasses
        ## to track these things
        self.circuit_factory = Circuit
        self.stream_factory = Stream

        self.attacher = None
        """If set, provides
        :class:`txtorcon.interface.IStreamAttacher` to attach new
        streams we hear about."""

        self.tor_binary = 'tor'

        self.circuit_listeners = []
        self.stream_listeners = []

        self.addrmap = AddrMap()
        self.circuits = {}               # keys on id (integer)
        self.streams = {}                # keys on id (integer)

        self.routers = {}                # keys by hexid (string) and by unique names
        self.routers_by_name = {}        # keys on name, value always list (many duplicate "Unnamed" routers, for example)
        self.guards = {}                 # potentially-usable as entry guards, I think? (any router with 'Guard' flag)
        self.entry_guards = {}           # from GETINFO entry-guards, our current entry guards
        self.unusable_entry_guards = []  # list of entry guards we didn't parse out
        self.authorities = {}            # keys by name

        self.cleanup = None              # see set_attacher

        class die(object):
            __name__ = 'die'             # FIXME? just to ease spagetti.py:82's pain

            def __init__(self, msg):
                self.msg = msg

            def __call__(self, *args):
                raise RuntimeError(self.msg % tuple(args))

        def nothing(*args):
            pass

        waiting_r = State("waiting_r")
        waiting_w = State("waiting_w")
        waiting_p = State("waiting_p")
        waiting_s = State("waiting_s")

        def ignorable_line(x):
            return x.strip() == '.' or x.strip() == 'OK' or x[:3] == 'ns/' or x.strip() == ''

        waiting_r.add_transition(Transition(waiting_r, ignorable_line, nothing))
        waiting_r.add_transition(Transition(waiting_s, lambda x: x[:2] == 'r ', self._router_begin))
        ## FIXME use better method/func than die!!
        waiting_r.add_transition(Transition(waiting_r, lambda x: x[:2] != 'r ', die('Expected "r " while parsing routers not "%s"')))

        waiting_s.add_transition(Transition(waiting_w, lambda x: x[:2] == 's ', self._router_flags))
        waiting_s.add_transition(Transition(waiting_s, lambda x: x[:2] == 'a ', self._router_address))
        waiting_s.add_transition(Transition(waiting_r, ignorable_line, nothing))
        waiting_s.add_transition(Transition(waiting_r, lambda x: x[:2] != 's ' and x[:2] != 'a ', die('Expected "s " while parsing routers not "%s"')))
        waiting_s.add_transition(Transition(waiting_r, lambda x: x.strip() == '.', nothing))

        waiting_w.add_transition(Transition(waiting_p, lambda x: x[:2] == 'w ', self._router_bandwidth))
        waiting_w.add_transition(Transition(waiting_r, ignorable_line, nothing))
        waiting_w.add_transition(Transition(waiting_s, lambda x: x[:2] == 'r ', self._router_begin))  # "w" lines are optional
        waiting_w.add_transition(Transition(waiting_r, lambda x: x[:2] != 'w ', die('Expected "w " while parsing routers not "%s"')))
        waiting_w.add_transition(Transition(waiting_r, lambda x: x.strip() == '.', nothing))

        waiting_p.add_transition(Transition(waiting_r, lambda x: x[:2] == 'p ', self._router_policy))
        waiting_p.add_transition(Transition(waiting_r, ignorable_line, nothing))
        waiting_p.add_transition(Transition(waiting_s, lambda x: x[:2] == 'r ', self._router_begin))  # "p" lines are optional
        waiting_p.add_transition(Transition(waiting_r, lambda x: x[:2] != 'p ', die('Expected "p " while parsing routers not "%s"')))
        waiting_p.add_transition(Transition(waiting_r, lambda x: x.strip() == '.', nothing))

        self._network_status_parser = FSM([waiting_r, waiting_s, waiting_w, waiting_p])
        if write_state_diagram:
            with open('routerfsm.dot', 'w') as fsmfile:
                fsmfile.write(self._network_status_parser.dotty())

        self.post_bootstrap = defer.Deferred()
        if bootstrap:
            if self.protocol.post_bootstrap:
                self.protocol.post_bootstrap.addCallback(self._bootstrap).addErrback(self.post_bootstrap.errback)
            else:
                self._bootstrap()

    def _router_begin(self, data):
        args = data.split()
        self._router = Router(self.protocol)
        self._router.from_consensus = True
        self._router.update(args[1],         # nickname
                            args[2],         # idhash
                            args[3],         # orhash
                            datetime.datetime.strptime(args[4] + args[5], '%Y-%m-%f%H:%M:%S'),
                            args[6],         # ip address
                            args[7],         # ORPort
                            args[8])         # DirPort

        if self._router.id_hex in self.routers:
            ## FIXME should I do an update() on this one??
            self._router = self.routers[self._router.id_hex]
            return

        if self._router.name in self.routers_by_name:
            self.routers_by_name[self._router.name].append(self._router)

        else:
            self.routers_by_name[self._router.name] = [self._router]

        if self._router.name in self.routers:
            self.routers[self._router.name] = None

        else:
            self.routers[self._router.name] = self._router
        self.routers[self._router.id_hex] = self._router

    def _router_flags(self, data):
        args = data.split()
        self._router.flags = args[1:]
        if 'guard' in self._router.flags:
            self.guards[self._router.id_hex] = self._router
        if 'authority' in self._router.flags:
            self.authorities[self._router.name] = self._router

    def _router_address(self, data):
        """only for IPv6 addresses"""
        self._router.ip_v6.append(data.split()[1].strip())

    def _router_bandwidth(self, data):
        args = data.split()
        self._router.bandwidth = int(args[1].split('=')[1])

    def _router_policy(self, data):
        args = data.split()
        self._router.policy = args[1:]
        self._router = None

    @defer.inlineCallbacks
    def _bootstrap(self, arg=None):
        "This takes an arg so we can use it as a callback (see __init__)."

        ## update list of routers (must be before we do the
        ## circuit-status) note that we're feeding each line
        ## incrementally to a state-machine called
        ## _network_status_parser, set up in constructor. "ns" should
        ## be the empty string, but we call _update_network_status for
        ## the de-duplication of named routers

        ns = yield self.protocol.get_info_incremental('ns/all',
                                                      self._network_status_parser.process)
        self._update_network_status(ns)

        ## update list of existing circuits
        cs = yield self.protocol.get_info_raw('circuit-status')
        self._circuit_status(cs)

        ## update list of streams
        ss = yield self.protocol.get_info_raw('stream-status')
        self._stream_status(ss)

        ## update list of existing address-maps
        key = 'address-mappings/all'
        am = yield self.protocol.get_info_raw(key)
        ## strip addressmappsings/all= and OK\n from raw data
        am = am[len(key) + 1:]
        for line in am.split('\n'):
            if len(line.strip()) == 0:
                continue            # FIXME
            self.addrmap.update(line)

        self._add_events()

        entries = yield self.protocol.get_info_raw("entry-guards")
        for line in entries.split('\n')[1:]:
            if len(line.strip()) == 0 or line.strip() == 'OK':
                continue
            args = line.split()
            (name, status) = args[:2]
            name = name[:41]

            ## this is sometimes redundant, as a missing entry guard
            ## usually means it won't be in our list of routers right
            ## now, but just being on the safe side
            if status.lower() != 'up':
                self.unusable_entry_guards.append(line)
                continue

            try:
                self.entry_guards[name] = self.router_from_id(name)
            except KeyError:
                self.unusable_entry_guards.append(line)

        ## in case process/pid doesn't exist and we don't know the PID
        ## because we own it, we just leave it as 0 (previously
        ## guessed using psutil, but that only works if there's
        ## exactly one tor running anyway)
        try:
            pid = yield self.protocol.get_info_raw("process/pid")
        except TorProtocolError:
            pid = None
        self.tor_pid = 0
        if pid:
            try:
                pid = parse_keywords(pid)['process/pid']
                self.tor_pid = int(pid)
            except KeyError:
                self.tor_pid = 0
        elif self.protocol.is_owned:
            self.tor_pid = self.protocol.is_owned

        self.post_bootstrap.callback(self)
        self.post_boostrap = None

    def undo_attacher(self):
        """
        Shouldn't Tor handle this by turning this back to 0 if the
        controller that twiddled it disconnects?
        """

        return self.protocol.set_conf("__LeaveStreamsUnattached", 0)

    def set_attacher(self, attacher, myreactor):
        """
        Provide an :class:`txtorcon.interface.IStreamAttacher to
        associate streams to circuits. This won't get turned on until
        after bootstrapping is completed. ('__LeaveStreamsUnattached'
        needs to be set to '1' and the existing circuits list needs to
        be populated).
        """

        react = IReactorCore(myreactor)
        if attacher:
            self.attacher = IStreamAttacher(attacher)
        else:
            self.attacher = None

        if self.attacher is None:
            self.undo_attacher()
            if self.cleanup:
                react.removeSystemEventTrigger(self.cleanup)
                self.cleanup = None

        else:
            self.protocol.set_conf("__LeaveStreamsUnattached", "1")
            self.cleanup = react.addSystemEventTrigger('before', 'shutdown',
                                                       self.undo_attacher)
        return None

    stream_close_reasons = {
        'REASON_MISC': 1,               # (catch-all for unlisted reasons)
        'REASON_RESOLVEFAILED': 2,      # (couldn't look up hostname)
        'REASON_CONNECTREFUSED': 3,     # (remote host refused connection) [*]
        'REASON_EXITPOLICY': 4,         # (OR refuses to connect to host or port)
        'REASON_DESTROY': 5,            # (Circuit is being destroyed)
        'REASON_DONE': 6,               # (Anonymized TCP connection was closed)
        'REASON_TIMEOUT': 7,            # (Connection timed out, or OR timed out while connecting)
        'REASON_NOROUTE': 8,            # (Routing error while attempting to contact destination)
        'REASON_HIBERNATING': 9,        # (OR is temporarily hibernating)
        'REASON_INTERNAL': 10,          # (Internal error at the OR)
        'REASON_RESOURCELIMIT': 11,     # (OR has no resources to fulfill request)
        'REASON_CONNRESET': 12,         # (Connection was unexpectedly reset)
        'REASON_TORPROTOCOL': 13,       # (Sent when closing connection because of Tor protocol violations.)
        'REASON_NOTDIRECTORY': 14}      # (Client sent RELAY_BEGIN_DIR to a non-directory relay.)

    def close_stream(self, stream, reason='REASON_MISC', **kwargs):
        """
        This sends a STREAMCLOSE command, using the specified reason
        (either an int or one of the 14 strings in section 6.3 of
        tor-spec.txt if the argument is a string). Any kwards are
        passed through as flags if they evaluated to true
        (e.g. "SomeFlag=True"). Currently there are none that Tor accepts.
        """

        if type(stream) != int:
            ## assume it's a Stream instance
            stream = stream.id
        try:
            reason = int(reason)
        except ValueError:
            try:
                reason = TorState.stream_close_reasons[reason]
            except KeyError:
                raise ValueError('Unknown stream close reason "%s"' % str(reason))

        flags = flags_from_dict(kwargs)

        ## stream is now an ID no matter what we passed in
        cmd = 'CLOSESTREAM %d %d%s' % (stream, reason, flags)
        return self.protocol.queue_command(cmd)

    def close_circuit(self, circid, **kwargs):
        """
        This sends a CLOSECIRCUIT command, using any keyword arguments
        passed as the Flags (currently, that is just 'IfUnused' which
        means to only close the circuit when it is no longer used by
        any streams).

        :return: a Deferred which callbacks with the result of queuing
        the command to Tor (usually "OK"). If you want to instead know
        when the circuit is actually-gone, see :meth:`Circuit.close
        <txtorcon.circuit.Circuit.close>`
        """

        if type(circid) != int:
            ## assume it's a Circuit instance
            circid = circid.id
        flags = flags_from_dict(kwargs)
        return self.protocol.queue_command('CLOSECIRCUIT %s%s' % (circid, flags))

    def add_circuit_listener(self, icircuitlistener):
        listen = ICircuitListener(icircuitlistener)
        for circ in self.circuits.values():
            circ.listen(listen)
        self.circuit_listeners.append(listen)

    def add_stream_listener(self, istreamlistener):
        listen = IStreamListener(istreamlistener)
        for stream in self.streams.values():
            stream.listen(listen)
        self.stream_listeners.append(listen)

    def _find_circuit_after_extend(self, x):
        ex, circ_id = x.split()
        if ex != 'EXTENDED':
            raise RuntimeError('Expected EXTENDED, got "%s"' % x)
        circ_id = int(circ_id)
        circ = self._maybe_create_circuit(circ_id)
        circ.update([str(circ_id), 'EXTENDED'])
        return circ

    def build_circuit(self, routers=None):
        """
        Builds a circuit consisting of exactly the routers specified,
        in order.  This issues an EXTENDCIRCUIT call to Tor with all
        the routers specified.

        :param routers: a list of Router instances which is the path
            desired. A warming is issued if the first one isn't in
            self.entry_guards To allow Tor to choose the routers
            itself, pass None (the default) for routers.

        :return:
            A Deferred that will callback with a Circuit instance
            (with the .id member being valid, and probably nothing
            else).
        """

        if routers is None or routers == []:
            cmd = "EXTENDCIRCUIT 0"

        else:
            if routers[0] not in self.entry_guards.values():
                warnings.warn("Building a circuit not starting with a guard: %s" % (str(routers),), RuntimeWarning)
            cmd = "EXTENDCIRCUIT 0 "
            first = True
            for router in routers:
                if first:
                    first = False
                else:
                    cmd += ','
                if isinstance(router, types.StringType) and len(router) == 40 and hashFromHexId(router):
                    cmd += router
                else:
                    cmd += router.id_hex[1:]
        d = self.protocol.queue_command(cmd)
        d.addCallback(self._find_circuit_after_extend)
        return d

    DO_NOT_ATTACH = object()

    def _maybe_attach(self, stream):
        """
        If we've got a custom stream-attachment instance (see
        set_attacher) this will ask it for the appropriate
        circuit. Note that we ignore .exit URIs and let Tor deal with
        those (by passing circuit ID 0).

        The stream attacher is allowed to return a Deferred which will
        callback with the desired circuit.

        You may return the special object DO_NOT_ATTACH which will
        cause the circuit attacher to simply ignore the stream
        (neither attaching it, nor telling Tor to attach it).
        """

        if self.attacher:
            if stream.target_host is not None and '.exit' in stream.target_host:
                ## we want to totally ignore .exit URIs as these are
                ## used to specify a particular exit node, and trying
                ## to do STREAMATTACH on them will fail with an error
                ## from Tor anyway.
                txtorlog.msg("ignore attacher:", stream)
                return

            circ = IStreamAttacher(self.attacher).attach_stream(stream, self.circuits)
            if circ is self.DO_NOT_ATTACH:
                return

            if circ is None:
                self.protocol.queue_command("ATTACHSTREAM %d 0" % stream.id)

            else:
                if isinstance(circ, defer.Deferred):
                    class IssueStreamAttach:
                        def __init__(self, state, streamid):
                            self.stream_id = streamid
                            self.state = state

                        def __call__(self, arg):
                            circid = arg.id
                            self.state.protocol.queue_command("ATTACHSTREAM %d %d" % (self.stream_id, circid))

                    circ.addCallback(IssueStreamAttach(self, stream.id)).addErrback(log.err)

                else:
                    if circ.id not in self.circuits:
                        raise RuntimeError("Attacher returned a circuit unknown to me.")
                    if circ.state != 'BUILT':
                        raise RuntimeError("Can only attach to BUILT circuits; %d is in %s." % (circ.id, circ.state))
                    self.protocol.queue_command("ATTACHSTREAM %d %d" % (stream.id, circ.id))

    def _circuit_status(self, data):
        """Used internally as a callback for updating Circuit information"""

        data = data[len('circuit-status='):].split('\n')
        ## sometimes there's a newline after circuit-status= and
        ## sometimes not, so we get rid of it
        if len(data) and len(data[0].strip()) == 0:
            data = data[1:]

        for line in data:
            self._circuit_update(line)

    def _stream_status(self, data):
        "Used internally as a callback for updating Stream information"
        # there's a slight issue with a single-stream vs >= 2 streams,
        # in that in the latter case we have a line by itself with
        # "stream-status=" on it followed by the streams EXCEPT in the
        # single-stream case which has "stream-status=123 blahblah"
        # (i.e. the key + value on one line)

        lines = data.split('\n')
        if len(lines) == 1:
            d = lines[0][len('stream-status='):]
            # if there are actually 0 streams, then there's nothing
            # left to parse
            if len(d):
                self._stream_update(d)
        else:
            [self._stream_update(line) for line in lines[1:]]

    def _update_network_status(self, data):
        """
        Used internally as a callback for updating Router information
        from NS and NEWCONSENSUS events.
        """

        for line in data.split('\n'):
            self._network_status_parser.process(line)

        txtorlog.msg(len(self.routers_by_name), "named routers found.")
        ## remove any names we added that turned out to have dups
        for (k, v) in self.routers.items():
            if v is None:
                txtorlog.msg(len(self.routers_by_name[k]), "dups:", k)
                del self.routers[k]

        txtorlog.msg(len(self.guards), "GUARDs")

    def _maybe_create_circuit(self, circ_id):
        if circ_id not in self.circuits:
            c = self.circuit_factory(self)
            c.listen(self)
            [c.listen(x) for x in self.circuit_listeners]

        else:
            c = self.circuits[circ_id]
        return c

    def _circuit_update(self, line):
        """
        Used internally as a callback to update Circuit information
        from CIRC events.
        """

        #print "circuit_update",line
        args = line.split()
        circ_id = int(args[0])

        c = self._maybe_create_circuit(circ_id)
        c.update(args)

    def _stream_update(self, line):
        """
        Used internally as a callback to update Stream information
        from STREAM events.
        """

        #print "stream_update",line
        if line.strip() == 'stream-status=':
            ## this happens if there are no active streams
            return

        args = line.split()
        assert len(args) >= 3

        stream_id = int(args[0])
        wasnew = False
        if stream_id not in self.streams:
            stream = self.stream_factory(self)
            self.streams[stream_id] = stream
            stream.listen(self)
            [stream.listen(x) for x in self.stream_listeners]
            wasnew = True
        self.streams[stream_id].update(args)

        ## if the update closed the stream, it won't be in our list
        ## anymore. FIXME: how can we ever hit such a case as the
        ## first update being a CLOSE?
        if wasnew and stream_id in self.streams:
            self._maybe_attach(self.streams[stream_id])

    def _addr_map(self, addr):
        "Internal callback to update DNS cache. Listens to ADDRMAP."
        txtorlog.msg(" --> addr_map", addr)
        self.addrmap.update(addr)

    event_map = {'STREAM': _stream_update,
                 'CIRC': _circuit_update,
                 'NS': _update_network_status,
                 'NEWCONSENSUS': _update_network_status,
                 'ADDRMAP': _addr_map}
    """event_map used by add_events to map event_name -> unbound method"""
    @defer.inlineCallbacks
    def _add_events(self):
        """
        Add listeners for all the events the controller is interested in.
        """

        for (event, func) in self.event_map.items():
            ## the map contains unbound methods, so we bind them
            ## to self so they call the right thing
            yield self.protocol.add_event_listener(event, types.MethodType(func, self, TorState))

    ## ICircuitContainer

    def find_circuit(self, circid):
        "ICircuitContainer API"
        return self.circuits[circid]

    ## IRouterContainer

    def router_from_id(self, routerid):
        """IRouterContainer API"""

        try:
            return self.routers[routerid[:41]]

        except KeyError:
            if routerid[0] != '$':
                raise                   # just re-raise the KeyError

            router = Router(self.protocol)
            idhash = routerid[1:41]
            nick = ''
            is_named = False
            if len(routerid) > 41:
                nick = routerid[42:]
                is_named = routerid[41] == '='
            router.update(nick, hashFromHexId(idhash), '0' * 27, 'unknown',
                          'unknown', '0', '0')
            router.name_is_unique = is_named
            self.routers[router.id_hex] = router
            return router

    ## implement IStreamListener

    def stream_new(self, stream):
        "IStreamListener: a new stream has been created"
        txtorlog.msg("stream_new", stream)

    def stream_succeeded(self, stream):
        "IStreamListener: stream has succeeded"
        txtorlog.msg("stream_succeeded", stream)

    def stream_attach(self, stream, circuit):
        """
        IStreamListener: the stream has been attached to a circuit. It
        seems you get an attach to None followed by an attach to real
        circuit fairly frequently. Perhaps related to __LeaveStreamsUnattached?
        """
        txtorlog.msg("stream_attach", stream.id,
                     stream.target_host, " -> ", circuit)

    def stream_detach(self, stream, **kw):
        """
        IStreamListener
        """
        txtorlog.msg("stream_detach", stream.id)

    def stream_closed(self, stream, **kw):
        """
        IStreamListener: stream has been closed (won't be in
        controller's list anymore)
        """

        txtorlog.msg("stream_closed", stream.id)
        del self.streams[stream.id]

    def stream_failed(self, stream, **kw):
        """
        IStreamListener: stream failed for some reason (won't be in
        controller's list anymore)
        """

        txtorlog.msg("stream_failed", stream.id)
        del self.streams[stream.id]

    ## implement ICircuitListener

    def circuit_launched(self, circuit):
        "ICircuitListener API"
        txtorlog.msg("circuit_launched", circuit)
        self.circuits[circuit.id] = circuit

    def circuit_extend(self, circuit, router):
        "ICircuitListener API"
        txtorlog.msg("circuit_extend:", circuit.id, router)

    def circuit_built(self, circuit):
        "ICircuitListener API"
        txtorlog.msg("circuit_built:", circuit.id,
                     "->".join("%s.%s" % (x.name, x.location.countrycode) for x in circuit.path),
                     circuit.streams)

    def circuit_new(self, circuit):
        "ICircuitListener API"
        txtorlog.msg("circuit_new:", circuit.id)
        self.circuits[circuit.id] = circuit

    def circuit_destroy(self, circuit):
        "Used by circuit_closed and circuit_failed (below)"
        txtorlog.msg("circuit_destroy:", circuit.id)
        del self.circuits[circuit.id]

    def circuit_closed(self, circuit, **kw):
        "ICircuitListener API"
        txtorlog.msg("circuit_closed", circuit)
        self.circuit_destroy(circuit)

    def circuit_failed(self, circuit, **kw):
        "ICircuitListener API"
        txtorlog.msg("circuit_failed", circuit, str(kw))
        self.circuit_destroy(circuit)

########NEW FILE########
__FILENAME__ = util

##
## wrapper for GeoIP since the API for city vs. country is different.
##

import glob
import os
import hmac
import hashlib
import shutil
import socket
import subprocess
import struct

try:
    import GeoIP as _GeoIP
    GeoIP = _GeoIP
except ImportError:
    GeoIP = None

city = None
country = None
asn = None


def create_geoip(fname):
    ## It's more "pythonic" to just wait for the exception,
    ## but GeoIP prints out "Can't open..." messages for you,
    ## which isn't desired here
    if not os.path.isfile(fname):
        raise IOError("Can't find %s" % fname)

    if GeoIP is None:
        return None

    ## just letting any errors make it out
    return GeoIP.open(fname, GeoIP.GEOIP_STANDARD)


def maybe_create_db(path):
    try:
        return create_geoip(path)
    except IOError:
        return None

city, asn, country = map(maybe_create_db,
                         ("/usr/share/GeoIP/GeoLiteCity.dat",
                          "/usr/share/GeoIP/GeoIPASNum.dat",
                          "/usr/share/GeoIP/IP.dat"))

try:
    import ipaddr as _ipaddr
    ipaddr = _ipaddr
except ImportError:
    ipaddr = None


def is_executable(path):
    """Checks if the given path points to an existing, executable file"""
    return os.path.isfile(path) and os.access(path, os.X_OK)


def find_tor_binary(globs=('/usr/sbin/', '/usr/bin/',
                           '/Applications/TorBrowser_*.app/Contents/MacOS/'),
                    system_tor=True):
    """
    Tries to find the tor executable using the shell first or in in the
    paths whose glob-patterns is in the given 'globs'-tuple.

    :param globs:
        A tuple of shell-style globs of directories to use to find tor
        (TODO consider making that globs to actual tor binary?)

    :param system_tor:
        This controls whether bash is used to seach for 'tor' or
        not. If False, we skip that check and use only the 'globs'
        tuple.
    """

    # Try to find the tor executable using the shell
    if system_tor:
        try:
            proc = subprocess.Popen(('which tor'),
                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                    shell=True)
        except OSError:
            pass
        else:
            stdout, _ = proc.communicate()
            if proc.poll() == 0 and stdout != '':
                return stdout.strip()

    # the shell may not provide type and tor is usually not on PATH when using
    # the browser-bundle. Look in specific places
    for pattern in globs:
        for path in glob.glob(pattern):
            torbin = os.path.join(path, 'tor')
            if is_executable(torbin):
                return torbin
    return None


def maybe_ip_addr(addr):
    """
    Tries to return an IPAddress, otherwise returns a string.

    TODO consider explicitly checking for .exit or .onion at the end?
    """

    if ipaddr is not None:
        try:
            return ipaddr.IPAddress(addr)
        except ValueError:
            pass
    return str(addr)


def find_keywords(args, key_filter=lambda x: not x.startswith("$")):
    """
    This splits up strings like name=value, foo=bar into a dict. Does NOT deal
    with quotes in value (e.g. key="value with space" will not work

    By default, note that it takes OUT any key which starts with $ (i.e. a
    single dollar sign) since for many use-cases the way Tor encodes nodes
    with "$hash=name" looks like a keyword argument (but it isn't). If you
    don't want this, override the "key_filter" argument to this method.

    :return:
        a dict of key->value (both strings) of all name=value type
        keywords found in args.
    """
    return dict(x.split('=', 1) for x in args if '=' in x and key_filter(x.split('=')[0]))


def delete_file_or_tree(*args):
    """
    For every path in args, try to delete it as a file or a directory
    tree. Ignores deletion errors.
    """

    for f in args:
        try:
            os.unlink(f)
        except OSError:
            shutil.rmtree(f, ignore_errors=True)


def ip_from_int(ip):
        """ Convert long int back to dotted quad string """
        return socket.inet_ntoa(struct.pack('>I', ip))


def process_from_address(addr, port, torstate=None):
    """
    Determines the PID from the address/port provided by using lsof
    and returns it as an int (or None if it couldn't be
    determined). In the special case the addr is '(Tor_internal)' then
    the PID of the Tor process (as gotten from the torstate object) is
    returned (or 0 if unavailable, e.g. a Tor which doesn't implement
    'GETINFO process/pid'). In this case if no TorState instance is
    given, None is returned.
    """

    if addr is None:
        return None

    if "(tor_internal)" == str(addr).lower():
        if torstate is None:
            return None
        return int(torstate.tor_pid)

    proc = subprocess.Popen(['lsof', '-i', '4tcp@%s:%s' % (addr, port)],
                            stdout=subprocess.PIPE)
    (stdout, stderr) = proc.communicate()
    lines = stdout.split('\n')
    if len(lines) > 1:
        return int(lines[1].split()[1])


def hmac_sha256(key, msg):
    """
    Adapted from rransom's tor-utils git repository. Returns the
    digest (binary) of an HMAC with SHA256 over msg with key.
    """

    return hmac.new(key, msg, hashlib.sha256).digest()


CRYPTOVARIABLE_EQUALITY_COMPARISON_NONCE = os.urandom(32)


def compare_via_hash(x, y):
    """
    Taken from rransom's tor-utils git repository, to compare two
    hashes in something resembling constant time (or at least, not
    leaking timing info?)
    """
    return (hmac_sha256(CRYPTOVARIABLE_EQUALITY_COMPARISON_NONCE, x) ==
            hmac_sha256(CRYPTOVARIABLE_EQUALITY_COMPARISON_NONCE, y))


class NetLocation:
    """
    Represents the location of an IP address, either city or country
    level resolution depending on what GeoIP database was loaded. If
    the ASN database is available you get that also.
    """

    def __init__(self, ipaddr):
        "ipaddr should be a dotted-quad"
        self.ip = ipaddr
        self.latlng = (None, None)
        self.countrycode = None
        self.city = None
        self.asn = None

        if self.ip is None or self.ip == 'unknown':
            return

        if city:
            try:
                r = city.record_by_addr(self.ip)
            except:
                r = None
            if r is not None:
                self.countrycode = r['country_code']
                self.latlng = (r['latitude'], r['longitude'])
                try:
                    self.city = (r['city'], r['region_code'])
                except KeyError:
                    self.city = (r['city'], r['region_name'])

        elif country:
            self.countrycode = country.country_code_by_addr(ipaddr)

        else:
            self.countrycode = ''

        if asn:
            try:
                self.asn = asn.org_by_addr(self.ip)
            except:
                self.asn = None

########NEW FILE########
__FILENAME__ = 0_connection
#!/usr/bin/env python

from twisted.internet import reactor
from twisted.internet.endpoints import TCP4ClientEndpoint
import txtorcon

def example(state):
    """
    This callback gets called after we've connected and loaded all the
    current Tor state.
    """
    print "Fully bootstrapped state:", state
    print "   with bootstrapped protocol:", state.protocol
    reactor.stop()

## change the port to 9151 for Tor Browser Bundle
connection = TCP4ClientEndpoint(reactor, "localhost", 9051)

d = txtorcon.build_tor_connection(connection)
d.addCallback(example)

## this will only return after reactor.stop() is called
reactor.run()

########NEW FILE########
__FILENAME__ = 1_launch
#!/usr/bin/env python

import os
from twisted.internet import reactor, defer
from twisted.internet.endpoints import TCP4ClientEndpoint
import txtorcon

@defer.inlineCallbacks
def launched(process_proto):
    """
    This callback gets called after Tor considers itself fully
    bootstrapped -- it has created a circuit. We get the
    TorProcessProtocol object, which has the TorControlProtocol
    instance as .tor_protocol
    """
    
    protocol = process_proto.tor_protocol
    print "Tor has launched.\nProtocol:", protocol
    info = yield protocol.get_info('traffic/read', 'traffic/written')
    print info
    reactor.stop()

def error(failure):
    print "There was an error", failure.getErrorMessage()
    reactor.stop()

def progress(percent, tag, summary):
    ticks = int((percent/100.0) * 10.0)
    prog = (ticks * '#') + ((10 - ticks) * '.')
    print '%s %s' % (prog, summary)

config = txtorcon.TorConfig()
config.ORPort = 0
config.SocksPort = 9999
try:
    os.mkdir('tor-data')
except OSError:
    pass
config.DataDirectory = './tor-data'

d = txtorcon.launch_tor(config, reactor, progress_updates=progress)
d.addCallback(launched).addErrback(error)

## this will only return after reactor.stop() is called
reactor.run()

########NEW FILE########
__FILENAME__ = 2_monitor
#!/usr/bin/env python

from twisted.internet import reactor, defer
from twisted.internet.endpoints import TCP4ClientEndpoint
from zope.interface import implements
import txtorcon

## change the port to 9151 for Tor Browser Bundle
connection = TCP4ClientEndpoint(reactor, "localhost", 9051)

def error(failure):
    print "Error:", failure.getErrorMessage()
    reactor.stop()

class MyCircuitListener(object):
    implements(txtorcon.ICircuitListener)
    def circuit_new(self, circuit):
        print "new", circuit

    def circuit_launched(self, circuit):
        print "launched", circuit

    def circuit_extend(self, circuit, router):
        print "extend", circuit

    def circuit_built(self, circuit):
        print "built", circuit

    def circuit_closed(self, circuit, **kw):
        print "closed", circuit, kw

    def circuit_failed(self, circuit, **kw):
        print "failed", circuit, kw


@defer.inlineCallbacks
def main(connection):
    version = yield connection.get_info('version', 'events/names')
    print "Connected to Tor.", version['version']
    print version['events/names']

    print "Issuing NEWNYM."
    yield connection.signal('NEWNYM')
    print "OK."

    print "Building state."
    state = txtorcon.TorState(connection)
    yield state.post_bootstrap
    print "State initialized."
    print "Existing circuits:"
    for c in state.circuits.values():
        print ' ', c

    print "listening for circuit events"
    state.add_circuit_listener(MyCircuitListener())

    print "listening for INFO events"
    def print_info(i):
        print "INFO:", i
    connection.add_event_listener('INFO', print_info)

    ## since we don't call reactor.stop(), we keep running

d = txtorcon.build_tor_connection(connection, build_state=False)
d.addCallback(main).addErrback(error)

## this will only return after reactor.stop() is called
reactor.run()

########NEW FILE########
