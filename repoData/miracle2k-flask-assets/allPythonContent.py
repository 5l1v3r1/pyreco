__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Flask-Assets documentation build configuration file, created by
# sphinx-quickstart on Fri Aug  6 14:01:08 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

sys.path.append(os.path.abspath('_themes'))


# make sure we are documenting the local version with autodoc
sys.path.insert(0, os.path.abspath('../src'))
import flask_assets as flaskassets


# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Flask-Assets'
copyright = u'2010, Michael Elsdörfer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(map(str, flaskassets.__version__))
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'flask_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {'github_fork': 'miracle2k/flask-assets', 'index_logo': False}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Flask-Assetsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Flask-Assets.tex', u'Flask-Assets Documentation',
   u'Michael Elsdörfer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'python': ('http://docs.python.org/', None),
    'webassets': ('http://elsdoerfer.name/docs/webassets/', None),
}
########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
import sys
from os import path
sys.path.insert(0, path.join(path.dirname(__file__), '../src'))

from flask import Flask, render_template, url_for
from flask.ext.assets import Environment, Bundle

app = Flask(__name__)

assets = Environment(app)
assets.register('main',
                'style1.css', 'style2.css',
                output='cached.css', filters='cssmin')

@app.route('/')
def index():
    return render_template('index.html')


app.run(debug=True)
########NEW FILE########
__FILENAME__ = fabfile
from fabric.api import run, put, env

env.hosts = ['elsdoerfer.com:2211']

def publish_docs():
    target = '/var/www/elsdoerfer/files/docs/flask-assets'
    run('rm -rf %s' % target)
    run('mkdir %s' % target)
    put('build/sphinx/html/*', '%s' % target)
########NEW FILE########
__FILENAME__ = flask_assets
from __future__ import print_function
from os import path
from flask import _request_ctx_stack
from flask.templating import render_template_string
from webassets.env import (\
    BaseEnvironment, ConfigStorage, env_options, Resolver, url_prefix_join)
from webassets.filter import Filter, register_filter
from webassets.loaders import PythonLoader, YAMLLoader


__version__ = (0, 10, 'dev')
__webassets_version__ = ('dev',)  # webassets core compatibility. used in setup.py


__all__ = ('Environment', 'Bundle',)


# We want to expose this here.
from webassets import Bundle


class Jinja2Filter(Filter):
    """Will compile all source files as Jinja2 templates using the standard
    Flask contexts.
    """
    name = 'jinja2'
    max_debug_level = None

    def __init__(self, context=None):
        super(Jinja2Filter, self).__init__()
        self.context = context or {}

    def input(self, _in, out, source_path, output_path, **kw):
        out.write(render_template_string(_in.read(), **self.context))

# Override the built-in ``jinja2`` filter that ships with ``webassets``. This
# custom filter uses Flask's ``render_template_string`` function to provide all
# the standard Flask template context variables.
register_filter(Jinja2Filter)


class FlaskConfigStorage(ConfigStorage):
    """Uses the config object of a Flask app as the backend: either the app
    instance bound to the extension directly, or the current Flask app on
    the stack.

    Also provides per-application defaults for some values.

    Note that if no app is available, this config object is basically
    unusable - this is by design; this could also let the user set defaults
    by writing to a container not related to any app, which would be used
    as a fallback if a current app does not include a key. However, at least
    for now, I specifically made the choice to keep things simple and not
    allow global across-app defaults.
    """

    def __init__(self, *a, **kw):
        self._defaults = {}
        ConfigStorage.__init__(self, *a, **kw)

    def _transform_key(self, key):
        if key.lower() in env_options:
            return "ASSETS_%s" % key.upper()
        else:
            return key.upper()

    def setdefault(self, key, value):
        """We may not always be connected to an app, but we still need
        to provide a way to the base environment to set it's defaults.
        """
        try:
            super(FlaskConfigStorage, self).setdefault(key, value)
        except RuntimeError:
            self._defaults.__setitem__(key, value)

    def __contains__(self, key):
        return self._transform_key(key) in self.env._app.config

    def __getitem__(self, key):
        value = self._get_deprecated(key)
        if value:
            return value

        # First try the current app's config
        public_key = self._transform_key(key)
        if self.env._app:
            if public_key in self.env._app.config:
                return self.env._app.config[public_key]

        # Try a non-app specific default value
        if key in self._defaults:
            return self._defaults.__getitem__(key)

        # Finally try to use a default based on the current app
        deffunc = getattr(self, "_app_default_%s" % key, False)
        if deffunc:
            return deffunc()

        # We've run out of options
        raise KeyError()

    def __setitem__(self, key, value):
        if not self._set_deprecated(key, value):
            self.env._app.config[self._transform_key(key)] = value

    def __delitem__(self, key):
        del self.env._app.config[self._transform_key(key)]


def get_static_folder(app_or_blueprint):
    """Return the static folder of the given Flask app
    instance, or module/blueprint.

    In newer Flask versions this can be customized, in older
    ones (<=0.6) the folder is fixed.
    """
    if not hasattr(app_or_blueprint, 'static_folder'):
        # I believe this is for app objects in very old Flask
        # versions that did not support ccustom static folders.
        return path.join(app_or_blueprint.root_path, 'static')

    if not app_or_blueprint.has_static_folder:
        # Use an exception type here that is not hidden by spit_prefix.
        raise TypeError(('The referenced blueprint %s has no static '
                         'folder.') % app_or_blueprint)
    return app_or_blueprint.static_folder


class FlaskResolver(Resolver):
    """Adds support for Flask blueprints.

    This resolver is designed to use the Flask staticfile system to
    locate files, by looking at directory prefixes (``foo/bar.png``
    looks in the static folder of the ``foo`` blueprint. ``url_for``
    is used to generate urls to these files.

    This default behaviour changes when you start setting certain
    standard *webassets* path and url configuration values:

    If a :attr:`Environment.directory` is set, output files will
    always be written there, while source files still use the Flask
    system.

    If a :attr:`Environment.load_path` is set, it is used to look
    up source files, replacing the Flask system. Blueprint prefixes
    are no longer resolved.
    """

    def split_prefix(self, ctx, item):
        """See if ``item`` has blueprint prefix, return (directory, rel_path).
        """
        app = ctx.environment._app
        try:
            if hasattr(app, 'blueprints'):
                blueprint, name = item.split('/', 1)
                directory = get_static_folder(app.blueprints[blueprint])
                endpoint = '%s.static' % blueprint
                item = name
            else:
                # Module support for Flask < 0.7
                module, name = item.split('/', 1)
                directory = get_static_folder(app.modules[module])
                endpoint = '%s.static' % module
                item = name
        except (ValueError, KeyError):
            directory = get_static_folder(app)
            endpoint = 'static'

        return directory, item, endpoint

    def use_webassets_system_for_output(self, ctx):
        return ctx.config.get('directory') is not None or \
               ctx.config.get('url') is not None

    def use_webassets_system_for_sources(self, ctx):
        return bool(ctx.load_path)

    def search_for_source(self, ctx, item):
        # If a load_path is set, use it instead of the Flask static system.
        #
        # Note: With only env.directory set, we don't go to default;
        # Setting env.directory only makes the output directory fixed.
        if self.use_webassets_system_for_sources(ctx):
            return Resolver.search_for_source(self, ctx, item)

        # Look in correct blueprint's directory
        directory, item, endpoint = self.split_prefix(ctx, item)
        try:
            return self.consider_single_directory(directory, item)
        except IOError:
            # XXX: Hack to make the tests pass, which are written to not
            # expect an IOError upon missing files. They need to be rewritten.
            return path.normpath(path.join(directory, item))

    def resolve_output_to_path(self, ctx, target, bundle):
        # If a directory/url pair is set, always use it for output files
        if self.use_webassets_system_for_output(ctx):
            return Resolver.resolve_output_to_path(self, ctx, target, bundle)

        # Allow targeting blueprint static folders
        directory, rel_path, endpoint = self.split_prefix(ctx, target)
        return path.normpath(path.join(directory, rel_path))

    def resolve_source_to_url(self, ctx, filepath, item):
        # If a load path is set, use it instead of the Flask static system.
        if self.use_webassets_system_for_sources(ctx):
            return super(FlaskResolver, self).resolve_source_to_url(ctx, filepath, item)

        return self.convert_item_to_flask_url(ctx, item, filepath)

    def resolve_output_to_url(self, ctx, target):
        # With a directory/url pair set, use it for output files.
        if self.use_webassets_system_for_output(ctx):
            return Resolver.resolve_output_to_url(self, ctx, target)

        # Otherwise, behaves like all other flask URLs.
        return self.convert_item_to_flask_url(ctx, target)

    def convert_item_to_flask_url(self, ctx, item, filepath=None):
        """Given a relative reference like `foo/bar.css`, returns
        the Flask static url. By doing so it takes into account
        blueprints, i.e. in the aformentioned example,
        ``foo`` may reference a blueprint.

        If an absolute path is given via ``filepath``, it will be
        used instead. This is needed because ``item`` may be a
        glob instruction that was resolved to multiple files.

        If app.config("FLASK_ASSETS_USE_S3") exists and is True
        then we import the url_for function from flask.ext.s3,
        otherwise we import url_for from flask directly.
        """
        if ctx.environment._app.config.get("FLASK_ASSETS_USE_S3"):
            try:
                from flask.ext.s3 import url_for
            except ImportError as e:
                print("You must have Flask S3 to use FLASK_ASSETS_USE_S3 option")
                raise e
        else:
            from flask import url_for

        directory, rel_path, endpoint = self.split_prefix(ctx, item)

        if filepath is not None:
            filename = filepath[len(directory)+1:]
        else:
            filename = rel_path

        flask_ctx = None
        if not _request_ctx_stack.top:
            flask_ctx = ctx.environment._app.test_request_context()
            flask_ctx.push()
        try:
            return url_for(endpoint, filename=filename)
        finally:
            if flask_ctx:
                flask_ctx.pop()


class Environment(BaseEnvironment):

    config_storage_class = FlaskConfigStorage
    resolver_class = FlaskResolver

    def __init__(self, app=None):
        self.app = app
        super(Environment, self).__init__()
        if app:
            self.init_app(app)

    @property
    def _app(self):
        """The application object to work with; this is either the app
        that we have been bound to, or the current application.
        """
        if self.app is not None:
            return self.app

        ctx = _request_ctx_stack.top
        if ctx is not None:
            return ctx.app

        try:
            from flask import _app_ctx_stack
            app_ctx = _app_ctx_stack.top
            if app_ctx is not None:
                return app_ctx.app
        except ImportError:
            pass

        raise RuntimeError('assets instance not bound to an application, '+
                            'and no application in current context')



    # XXX: This is required because in a couple of places, webassets 0.6
    # still access env.directory, at one point even directly. We need to
    # fix this for 0.6 compatibility, but it might be preferrable to
    # introduce another API similar to _normalize_source_path() for things
    # like the cache directory and output files.
    def set_directory(self, directory):
        self.config['directory'] = directory
    def get_directory(self):
        if self.config.get('directory') is not None:
            return self.config['directory']
        return get_static_folder(self._app)
    directory = property(get_directory, set_directory, doc=
    """The base directory to which all paths will be relative to.
    """)

    def init_app(self, app):
        app.jinja_env.add_extension('webassets.ext.jinja2.AssetsExtension')
        app.jinja_env.assets_environment = self

    def from_yaml(self, path):
        """Register bundles from a YAML configuration file"""
        bundles = YAMLLoader(path).load_bundles()
        for name in bundles:
            self.register(name, bundles[name])

    def from_module(self, path):
        """Register bundles from a Python module"""
        bundles = PythonLoader(path).load_bundles()
        for name in bundles:
            self.register(name, bundles[name])

try:
    from flask.ext import script
except ImportError:
    pass
else:
    import argparse
    from webassets.script import GenericArgparseImplementation, CommandError

    class FlaskArgparseInterface(GenericArgparseImplementation):
        """Subclass the CLI implementation to add a --parse-templates option."""

        def _construct_parser(self, *a, **kw):
            super(FlaskArgparseInterface, self).\
                _construct_parser(*a, **kw)
            self.parser.add_argument(
                '--jinja-extension', default='*.html',
                help='specify the glob pattern for Jinja extensions (default: *.html)')
            self.parser.add_argument(
                '--parse-templates', action='store_true',
                help='search project templates to find bundles')

        def _setup_assets_env(self, ns, log):
            env = super(FlaskArgparseInterface, self)._setup_assets_env(ns, log)
            if env is not None:
                if ns.parse_templates:
                    log.info('Searching templates...')
                    # Note that we exclude container bundles. By their very nature,
                    # they are guaranteed to have been created by solely referencing
                    # other bundles which are already registered.
                    env.add(*[b for b in self.load_from_templates(env, ns.jinja_extension)
                                    if not b.is_container])

                if not len(env):
                    raise CommandError(
                        'No asset bundles were found. '
                        'If you are defining assets directly within '
                        'your templates, you want to use the '
                        '--parse-templates option.')
            return env

        def load_from_templates(self, env, jinja_extension):
            from webassets.ext.jinja2 import Jinja2Loader, AssetsExtension
            from flask import current_app as app

            # Use the application's Jinja environment to parse
            jinja2_env = app.jinja_env

            # Get the template directories of app and blueprints
            template_dirs = [path.join(app.root_path, app.template_folder)]
            for blueprint in app.blueprints.values():
                if blueprint.template_folder is None:
                    continue
                template_dirs.append(
                    path.join(blueprint.root_path, blueprint.template_folder))

            return Jinja2Loader(env, template_dirs, [jinja2_env], jinja_ext=jinja_extension).\
                load_bundles()

    class ManageAssets(script.Command):
        """Manage assets."""
        capture_all_args = True

        def __init__(self, assets_env=None, impl=FlaskArgparseInterface,
                     log=None):
            self.env = assets_env
            self.implementation = impl
            self.log = log

        def run(self, args):
            """Runs the management script.
            If ``self.env`` is not defined, it will import it from
            ``current_app``.
            """

            if not self.env:
                from flask import current_app
                self.env = current_app.jinja_env.assets_environment

            # Determine 'prog' - something like for example
            # "./manage.py assets", to be shown in the help string.
            # While we don't know the command name we are registered with
            # in Flask-Assets, we are lucky to be able to rely on the
            # name being in argv[1].
            import sys, os.path
            prog = '%s %s' % (os.path.basename(sys.argv[0]), sys.argv[1])

            impl = self.implementation(self.env, prog=prog, log=self.log)
            return impl.main(args)

    __all__ = __all__ + ('ManageAssets',)

########NEW FILE########
__FILENAME__ = helpers
from flask.app import Flask
from webassets.test import TempEnvironmentHelper as BaseTempEnvironmentHelper
from flask.ext.assets import Environment

try:
    from flask import Blueprint
    Module = None
except ImportError:
    # Blueprints only available starting with 0.7,
    # fall back to old Modules otherwise.
    Blueprint = None
    from flask import Module


__all__ = ('TempEnvironmentHelper', 'Module', 'Blueprint')


class TempEnvironmentHelper(BaseTempEnvironmentHelper):

    def _create_environment(self, **kwargs):
        if not hasattr(self, 'app'):
            self.app = Flask(__name__, static_folder=self.tempdir, **kwargs)
        self.env = Environment(self.app)
        return self.env


try:
    from test.test_support import check_warnings
except ImportError:
    # Python < 2.6
    import contextlib

    @contextlib.contextmanager
    def check_warnings(*filters, **kwargs):
        # We cannot reasonably support this, we'd have to copy to much code.
        # (or write our own). Since this is only testing warnings output,
        # we might slide by ignoring it.
        yield

########NEW FILE########
__FILENAME__ = test_config
"""The Environment configuration is hooked up to the Flask config dict.
"""

from __future__ import absolute_import
from tests.helpers import check_warnings

from nose.tools import assert_raises
from flask import Flask
from flask.ext.assets import Environment
from webassets.exceptions import ImminentDeprecationWarning

try:
    from webassets.updater import BaseUpdater
except ImportError:
    BaseUpdater = None   # older webassets versions (<=0.5)


if BaseUpdater:
    class MooUpdater(BaseUpdater):
        id = 'MOO'


class TestConfigAppBound:
    """The extension is bound to a specific app.
    """

    def setup(self):
        self.app = Flask(__name__)
        self.env = Environment(self.app)

    def test_set_environment(self):
        """Setting a config value on the environment works.
        """
        self.env.updater = 'foo'
        assert self.app.config['ASSETS_UPDATER'] == 'foo'

    def test_set_config(self):
        """Setting a value in the Flask config works.
        """
        self.app.config['ASSETS_UPDATER'] = 'MOO'
        assert self.env.updater == 'MOO'

    def test_custom_values(self):
        """Custom config values are relayed to the Flask config as.is.
        """
        self.app.config['LESS_PATH'] = '/usr/bin/less'
        assert self.env.config['LESS_PATH'] == '/usr/bin/less'

    def test_no_override(self):
        """Ensure that the webassets defaults do not override existing
        Flask config values.
        """
        app = Flask(__name__)
        app.config['ASSETS_UPDATER'] = 'MOO'
        env = Environment(app)
        assert env.updater == 'MOO'
        assert app.config['ASSETS_UPDATER'] == 'MOO'

         # Neither do the defaults that flask-assets set.
        app = Flask(__name__)
        app.config['ASSETS_URL'] = 'MOO'
        env = Environment(app)
        assert env.url == 'MOO'
        assert app.config['ASSETS_URL'] == 'MOO'


class TestConfigNoAppBound:
    """The application is not bound to a specific app.
    """

    def setup(self):
        self.env = Environment()

    def test_no_app_available(self):
        """Without an application bound, we can't do much."""
        assert_raises(RuntimeError, setattr, self.env, 'debug', True)
        assert_raises(RuntimeError, self.env.config.get, 'debug')

    def test_global_defaults(self):
        """We may set defaults even without an application, however."""
        self.env.config.setdefault('FOO', 'BAR')
        with Flask(__name__).test_request_context():
            assert self.env.config['FOO'] == 'BAR'

    def test_multiple_separate_apps(self):
        """Each app has it's own separate configuration.
        """
        app1 = Flask(__name__)
        self.env.init_app(app1)

        # With no app yet available...
        assert_raises(RuntimeError, getattr, self.env, 'url')
        # ...set a default
        self.env.config.setdefault('FOO', 'BAR')

        # When an app is available, the default is used
        with app1.test_request_context():
            assert self.env.config['FOO'] == 'BAR'

            # If the default is overridden for this application, it
            # is still valid for other apps.
            self.env.config['FOO'] = '42'
            assert self.env.config['FOO'] == '42'
            app2 = Flask(__name__)
            with app2.test_request_context():
                assert self.env.config['FOO'] == 'BAR'

    def test_key_error(self):
        """KeyError is raised if a config value doesn't exist.
        """
        with Flask(__name__).test_request_context():
            assert_raises(KeyError, self.env.config.__getitem__, 'YADDAYADDA')
            # The get() helper, on the other hand, simply returns None
            assert self.env.config.get('YADDAYADDA') == None

########NEW FILE########
__FILENAME__ = test_env
import os
from nose.tools import assert_raises
from flask import Flask
from flask.ext.assets import Environment, Bundle


class TestEnv:

    def setup(self):
        self.app = Flask(__name__)
        self.env = Environment(self.app)
        self.env.debug = True
        self.env.register('test', 'file1', 'file2')

    def test_tag_available(self):
        """Jinja tag has been made available.
        """
        t = self.app.jinja_env.from_string('{% assets "test" %}{{ASSET_URL}};{% endassets %}')
        assert t.render() == '/static/file1;/static/file2;'

    def test_from_yaml(self):
        """YAML configuration gets loaded
        """
        f = open('test.yaml', 'w')
        f.write("""
        yamltest:
            contents:
                - yamlfile1
                - yamlfile2
        """)
        f.close()

        self.env.from_yaml('test.yaml')

        t = self.app.jinja_env.from_string('{% assets "yamltest" %}{{ASSET_URL}};{% endassets %}')
        assert t.render() == '/static/yamlfile1;/static/yamlfile2;'

        os.remove('test.yaml')

    def test_from_python_module(self):
        """Python configuration module gets loaded
        """
        import types
        module = types.ModuleType('test')
        module.pytest = Bundle('pyfile1', 'pyfile2')

        self.env.from_module(module)

        t = self.app.jinja_env.from_string('{% assets "pytest" %}{{ASSET_URL}};{% endassets %}')
        assert t.render() == '/static/pyfile1;/static/pyfile2;'

########NEW FILE########
__FILENAME__ = test_filters
from __future__ import absolute_import
from nose.tools import assert_raises
from nose import SkipTest
from tests.helpers import TempEnvironmentHelper


class TestFilters(TempEnvironmentHelper):

    def test_pyscss(self):
        """This filter used to make trouble because if required
        Environment.url and Environment.directory to be set.
        """
        try:
            import scss
        except ImportError:
            raise SkipTest()

        self.create_files({'foo': ''})
        bundle = self.mkbundle('foo', filters='pyscss', output='out')

        # By default we'd get an error, because the filter can't use
        # any good defaults.
        assert_raises(EnvironmentError, bundle.build)

        # If we set a director/url pair, it works.
        self.env.config['PYSCSS_STATIC_ROOT'] = 'a'
        self.env.config['PYSCSS_STATIC_URL'] = 'b'
        bundle.build()

########NEW FILE########
__FILENAME__ = test_integration
from __future__ import absolute_import
from nose.tools import assert_raises

from flask import Flask
from flask.ext.assets import Environment, Bundle
from webassets.bundle import get_all_bundle_files
from tests.helpers import TempEnvironmentHelper, Module, Blueprint


def test_import():
    # We want to expose these via the assets extension module.
    from flask.ext.assets import Bundle
    from flask.ext.assets import Environment


class TestUrlAndDirectory(TempEnvironmentHelper):
    """By default, the 'url' and 'directory' settings of webassets are
    not used in Flask-Assets; that is, the values are automatically
    handled based on the configuration of the Flask app and the modules
    used.

    The user can disable the automatic handling by setting these values
    if he needs to for some reason.

    Let's test the different scenarios to ensure everything works.
    """

    def setup(self):
        TempEnvironmentHelper.setup(self)

        self.app = Flask(__name__, static_path='/app_static')
        from tests import test_module
        if not Blueprint:
            self.module = Module(test_module.__name__, name='module',
                                 static_path='/mod_static')
            self.app.register_module(self.module)
        else:
            self.blueprint = Blueprint('module', test_module.__name__,
                                       static_url_path='/mod_static',
                                       static_folder='static')
            self.app.register_blueprint(self.blueprint)
        self.env = Environment(self.app)

    def test_config_values_not_set_by_default(self):
        assert not 'directory' in self.env.config
        assert not 'url' in self.env.config
        assert_raises(KeyError, self.env.config.__getitem__, 'directory')
        assert_raises(KeyError, self.env.config.__getitem__, 'url')

    def test_directory_auto(self):
        """Test how we resolve file references through the Flask static
        system by default (if no custom 'env.directory' etc. values
        have been configured manually).
        """
        assert not 'directory' in self.env.config
        root = self.app.root_path
        assert get_all_bundle_files(Bundle('foo'), self.env) == [root + '/static/foo']
        # Modules prefixes in paths are handled specifically.
        assert get_all_bundle_files(Bundle('module/bar'), self.env) == [root + '/test_module/static/bar']
        # Prefixes that aren't valid module names are just considered
        # subfolders of the main app.
        assert get_all_bundle_files(Bundle('nomodule/bar'), self.env) == [root + '/static/nomodule/bar']
        # In case the name of a app-level subfolder conflicts with a
        # module name, you can always use this hack:
        assert get_all_bundle_files(Bundle('./module/bar'), self.env) == [root + '/static/module/bar']

        # Custom static folder
        self.app.static_folder = '/'
        assert get_all_bundle_files(Bundle('foo'), self.env) == ['/foo']

    def test_url_auto(self):
        """Test how urls are generated via the Flask static system
        by default (if no custom 'env.url' etc. values have been
        configured manually).
        """
        assert not 'url' in self.env.config

        assert Bundle('foo', env=self.env).urls() == ['/app_static/foo']
        # Urls for files that point to a module use that module's url prefix.
        assert Bundle('module/bar', env=self.env).urls() == ['/mod_static/bar']
        # Try with a prefix that's not actually a valid module
        assert Bundle('nomodule/bar', env=self.env).urls() == ['/app_static/nomodule/bar']

        # [Regression] Ensure that any request context we may have added
        # to the stack has been removed.
        from flask import _request_ctx_stack
        assert _request_ctx_stack.top is None

    def test_custom_load_path(self):
        """A custom load_path is configured - this will affect how
        we deal with source files.
        """
        self.env.append_path(self.tempdir, '/custom/')
        self.create_files(['foo', 'module/bar'])
        assert get_all_bundle_files(Bundle('foo'), self.env) == [self.path('foo')]
        # We do not recognize references to modules.
        assert get_all_bundle_files(Bundle('module/bar'), self.env) == [self.path('module/bar')]


        assert Bundle('foo', env=self.env).urls() == ['/custom/foo']
        assert Bundle('module/bar', env=self.env).urls() == ['/custom/module/bar']

        # [Regression] With a load path configured, generating output
        # urls still works, and it still uses the flask system.
        self.env.debug = False
        self.env.url_expire = False
        assert Bundle('foo', output='out', env=self.env).urls() == ['/app_static/out']

    def test_custom_directory_and_url(self):
        """Custom directory/url are configured - this will affect how
        we deal with output files."""
        # Create source source file, make it findable (by default,
        # static_folder) is set to a fixed subfolder of the test dir (why?)
        self.create_files({'a': ''})
        self.app.static_folder = self.tempdir
        # Setup custom directory/url pair for output
        self.env.directory = self.tempdir
        self.env.url = '/custom'
        self.env.debug = False   # Return build urls
        self.env.url_expire = False  # No query strings

        assert Bundle('a', output='foo', env=self.env).urls() == ['/custom/foo']
        # We do not recognize references to modules.
        assert Bundle('a', output='module/bar', env=self.env).urls() == ['/custom/module/bar']

    def test_existing_request_object_used(self):
        """[Regression] Check for a bug where the url generation code of
        Flask-Assets always added a dummy test request to the context stack,
        instead of using the existing one if there is one.

        We test this by making the context define a custom SCRIPT_NAME
        prefix, and then we check if it affects the generated urls, as
        it should.
        """
        with self.app.test_request_context(
                  '/', environ_overrides={'SCRIPT_NAME': '/yourapp'}):
            assert Bundle('foo', env=self.env).urls() == ['/yourapp/app_static/foo']

    def test_glob(self):
        """Make sure url generation works with globs."""
        self.app.static_folder = self.tempdir
        self.create_files({'a.js': 'foo', 'b.js': 'bar'})
        assert list(sorted(self.mkbundle('*.js', env=self.env).urls())) == [
            '/app_static/a.js', '/app_static/b.js']


class TestUrlAndDirectoryWithInitApp(object):
    """[Regression] Make sure the automatic "directory" and "url"
    values also work if the application is initialized via "init_app()".
    """

    def setup(self):
        self.app = Flask(__name__, static_path='/initapp_static')
        self.env = Environment()
        self.env.init_app(self.app)

    def test(self):
        """Make sure the "url" and "directory" config values are
        read from the Flask app.
        """
        with self.app.test_request_context():
            assert not 'url' in self.env.config
            assert Bundle('foo', env=self.env).urls() == ['/initapp_static/foo']

            assert not 'directory' in self.env.config
            root = self.app.root_path
            assert get_all_bundle_files(Bundle('foo'), self.env) == [root + '/static/foo']


class TestBuild(TempEnvironmentHelper):
    """[Regression]

    Make sure actually building a bundle works also.
    """

    default_files = {
        'foo': 'function bla  () { /* comment */ var a; }    ',
    }

    def test_build(self):
        self.mkbundle('foo', filters='rjsmin', output='out').build()
        assert self.get('out') == 'function bla(){var a;}'

    def test_with_cache_default_directory(self):
        """[Regression] The cache directory is created in the Flask
        main static folder.
        """
        self.env.cache = True
        self.mkbundle('foo', filters='rjsmin', output='out').build()
        assert self.get('out') == 'function bla(){var a;}'


class TestBlueprints(TempEnvironmentHelper):

    default_files = {
        'foo': 'function bla  () { /* comment */ var a; }    ',
    }

    def make_blueprint(self, name='module', import_name=None, **kw):
        if not import_name:
            from tests import test_module
            import_name = test_module.__name__

        if not Blueprint:
            self.module = Module(import_name, name=name)
            self.app.register_module(self.module)
        else:
            self.blueprint = Blueprint(name, import_name, **kw)
            self.app.register_blueprint(self.blueprint)

    def test_blueprint_output(self):
        """[Regression] Output can point to a blueprint's static
        directory.
        """
        module_static_dir = self.create_directories('module-static')[0]
        self.make_blueprint('module', static_folder=module_static_dir)
        self.mkbundle('foo', filters='rjsmin', output='module/out').build()
        assert self.get('module-static/out') == 'function bla(){var a;}'

    def test_blueprint_urls(self):
        """Urls to blueprint files are generated correctly."""
        self.make_blueprint('module', static_folder='static',
                            static_url_path='/rasputin')

        # source urls
        assert self.mkbundle('module/foo').urls() == ['/rasputin/foo']

        # output urls - env settings are to not touch filesystem
        self.env.auto_build = False
        self.env.url_expire = False
        assert self.mkbundle(output='module/out', debug=False).urls() == ['/rasputin/out']

    def test_blueprint_no_static_folder(self):
        """Test dealing with a blueprint without a static folder."""
        self.make_blueprint('module')
        assert_raises(TypeError, self.mkbundle('module/foo').urls)

    def test_cssrewrite(self):
        """Make sure cssrewrite works with Blueprints.
        """

        module_static_dir = self.create_directories('modfolder')[0]
        self.make_blueprint('modname', static_folder=module_static_dir,
                            static_url_path='/w/u/f/f')
        self.create_files(
                {'modfolder/css': 'h1{background: url("local")}'})

        # Source file is in a Blueprint, output file is app-level.
        self.mkbundle('modname/css', filters='cssrewrite', output='out').build()

        # The urls are NOT rewritten using the filesystem (/modfolder), but
        # within the url space.
        assert self.get('out') == 'h1{background: url("../w/u/f/f/local")}'

########NEW FILE########
__FILENAME__ = test_script
from __future__ import absolute_import

import sys
from nose import SkipTest
from flask import Flask
from flask.ext.assets import Environment, ManageAssets
from webassets.script import GenericArgparseImplementation
from tests.helpers import TempEnvironmentHelper

try:
    from flask.ext.script import Manager
except:
    raise SkipTest()


# The CLI likes to log to stderr, which isn't nice to the test output.
import logging
stdout_log = logging.getLogger(__name__)
stdout_log.addHandler(logging.StreamHandler(sys.stdout))


class TestScript(TempEnvironmentHelper):

    def test_call(self):
        # Setup the webassets.script with a mock main() function,
        # so we can check whether our call via Flask-Script actually
        # goes through.
        test_inst = self
        class DummyArgparseImplementation(GenericArgparseImplementation):
            def run_with_argv(self, argv):
                test_inst.last_script_call = argv
                return 0

        mgmt = Manager(self.app)
        mgmt.add_command('assets',
                ManageAssets(self.env, impl=DummyArgparseImplementation))

        try:
            # -h is a great test as that is something Flask-Script might
            # want to claim for itself.
            sys.argv = ['./manage.py', 'assets', '-h']
            mgmt.run()
        except SystemExit:
            # Always raised, regardless of success or failure of command
            pass
        assert self.last_script_call == ['-h']

    def test_call_auto_env(self):
        """Regression test: Passing the environment to the ManageAssets command
        is optional, it can be auto-detected."""
        mgmt = Manager(self.app)
        mgmt.add_command('assets', ManageAssets())

        try:
            # Used to raise an error due to the env not being properly set.
            sys.argv = ['./manage.py', 'assets', 'build']
            mgmt.run()
        except SystemExit:
            # Always raised, regardless of success or failure of command
            pass

    def test_parse_templates(self):
        """Test the --parse-templates option.
        """
        # Create a file in the app's templates directory
        self.app.template_folder = self.path('templates')
        self.create_files({
            'templates/template.html': """
            {% assets "in", output="output" %}
                {{ ASSET_URL }}
            {% endassets %}
            """,
            'in': "foo"
        })

        # Run the build command with --parse-templates, which should pick
        # up the bundle we defined in above template.
        mgmt = Manager(self.app)
        mgmt.add_command('assets', ManageAssets(log=stdout_log))
        mgmt.handle('test', 'assets', ['--parse-templates', 'build'])

        assert self.exists('output')


########NEW FILE########
