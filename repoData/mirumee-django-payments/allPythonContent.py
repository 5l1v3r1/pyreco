__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-payments documentation build configuration file, created by
# sphinx-quickstart on Thu Sep 30 16:25:38 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-payments'
copyright = u'2010-2013, Mirumee Software'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-paymentsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-payments.tex', u'django-payments Documentation',
   u'Mirumee Software', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

from ..forms import CreditCardPaymentForm

RESPONSE_STATUS = {
    '1': 'confirmed',
    '2': 'rejected'}


class PaymentForm(CreditCardPaymentForm):

    def clean(self):
        cleaned_data = super(PaymentForm, self).clean()

        if not self.errors:
            if not self.payment.transaction_id:
                data = {
                    'x_card_num': cleaned_data.get('number'),
                    'x_exp_date': cleaned_data.get('expiration'),
                    'x_card_code': cleaned_data.get('cvv2')}
                response = self.provider.get_payment_response(data)
                data = response.text.split('|')
                if response.ok and RESPONSE_STATUS.get(data[0], False):
                    self.payment.transaction_id = data[6]
                    self.payment.change_status(
                        RESPONSE_STATUS.get(data[0], 'error'))
                else:
                    errors = [data[3]]
                    self._errors['__all__'] = self.error_class(errors)
                    self.payment.change_status('error')
        return cleaned_data

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

import braintree

from ..forms import CreditCardPaymentFormWithName


class BraintreePaymentForm(CreditCardPaymentFormWithName):

    transaction_id = None

    def clean(self):
        data = self.cleaned_data

        if not self.errors and not self.payment.transaction_id:
            result = braintree.Transaction.sale({
                'amount': str(self.payment.total),
                'billing': self.get_billing_data(),
                'credit_card': self.get_credit_card_clean_data(),
                'customer': self.get_customer_data(),
                'options': {
                    'submit_for_settlement': True
                },
                'order_id': self.payment.description
            })

            if result.is_success:
                self.transaction_id = result.transaction.id
            else:
                self._errors['__all__'] = self.error_class([result.message])
                self.payment.change_status('error')

        return data

    def get_credit_card_clean_data(self):
        if self.cleaned_data:
            return {
                'number': self.cleaned_data.get('number'),
                'cvv': self.cleaned_data.get('cvv2'),
                'cardholder_name': self.cleaned_data.get('name'),
                'expiration_month': self.cleaned_data.get('expiration').month,
                'expiration_year': self.cleaned_data.get('expiration').year}

    def get_billing_data(self):
        return {
            'first_name': self.payment.billing_first_name,
            'last_name': self.payment.billing_last_name,
            'street_address': self.payment.billing_address_1,
            'extended_address': self.payment.billing_address_2,
            'locality': self.payment.billing_city,
            'region': self.payment.billing_country_area,
            'postal_code': self.payment.billing_postcode,
            'country_code_alpha2': self.payment.billing_country_code}

    def get_customer_data(self):
        return {
            'first_name': self.payment.billing_first_name,
            'last_name': self.payment.billing_last_name}

    def save(self):
        braintree.Transaction.submit_for_settlement(self.transaction_id)
        self.payment.transaction_id = self.transaction_id
        self.payment.change_status('confirmed')

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals
import hashlib

from django import forms


NO_MORE_CONFIRMATION = 0
NEW = 1
ACCEPTED = 2
REJECTED = 3
CANCELED = 4

STATUS_CHOICES = map(lambda c: (c, c), (
    NO_MORE_CONFIRMATION,
    NEW,
    ACCEPTED,
    REJECTED,
    CANCELED
))


class ProcessPaymentForm(forms.Form):

    status = forms.ChoiceField(choices=(('OK', 'OK'), ('FAIL', 'FAIL')))
    id = forms.IntegerField()
    control = forms.IntegerField()
    t_id = forms.CharField()
    amount = forms.DecimalField()
    email = forms.EmailField(required=False)
    t_status = forms.TypedChoiceField(coerce=int, choices=STATUS_CHOICES)
    description = forms.CharField(required=False)
    md5 = forms.CharField()

    def __init__(self, payment, pin, **kwargs):
        super(ProcessPaymentForm, self).__init__(**kwargs)
        self.pin = pin
        self.payment = payment

    def clean(self):
        cleaned_data = super(ProcessPaymentForm, self).clean()
        if not self.errors:
            key_vars = (
                self.pin,
                str(cleaned_data['id']),
                str(cleaned_data['control']),
                str(cleaned_data['t_id']),
                str(cleaned_data['amount']),
                cleaned_data.get('email', ''),
                '',  # service
                '',  # code
                '',  # username
                '',  # password
                str(cleaned_data['t_status']))
            key = ':'.join(key_vars)
            md5 = hashlib.md5()
            md5.update(key.encode('utf-8'))
            key_hash = md5.hexdigest()
            if key_hash != self.cleaned_data['md5']:
                self._errors['md5'] = self.error_class(['Bad hash'])
            if cleaned_data['control'] != self.payment.id:
                self._errors['control'] = self.error_class(['Bad payment id'])
        return cleaned_data

    def save(self, *args, **kwargs):
        status = self.cleaned_data['t_status']
        self.payment.transaction_id = self.cleaned_data['t_id']
        self.payment.save()
        payment_status = self.payment.status
        if status == ACCEPTED:
            self.payment.change_status('confirmed')
        elif ((status == NO_MORE_CONFIRMATION and payment_status == 'waiting')
              or status == REJECTED or status == CANCELED):
            self.payment.change_status('rejected')

########NEW FILE########
__FILENAME__ = tests
from __future__ import unicode_literals
import hashlib
from unittest import TestCase

from django.http import HttpResponse, HttpResponseForbidden
from mock import MagicMock

from .forms import ACCEPTED
from . import DotpayProvider

VARIANT = 'dotpay'
PIN = '123'
PROCESS_POST = {
    'status': 'OK',
    'id': '111',
    'control': '1',
    't_id': 't111',
    'amount': '100.0',
    'email': 'chf@o2.pl',
    't_status': str(ACCEPTED),
    'description': 'description',
    'md5': '?'}


def get_post_with_md5(post):
    post = post.copy()
    key_vars = (
        PIN,
        post['id'],
        post['control'],
        post['t_id'],
        post['amount'],
        post.get('email', ''),
        '',  # service
        '',  # code
        '',  # username
        '',  # password
        post['t_status'])
    key = ':'.join(key_vars)
    md5 = hashlib.md5()
    md5.update(key.encode('utf-8'))
    key_hash = md5.hexdigest()
    post['md5'] = key_hash
    return post


class Payment(MagicMock):

    id = 1
    variant = VARIANT
    currency = 'USD'
    total = 100

    def get_process_url(self):
        return 'http://example.com'

    def get_failure_url(self):
        return 'http://cancel.com'

    def get_success_url(self):
        return 'http://success.com'


class TestDotpayProvider(TestCase):

    def setUp(self):
        self.payment = Payment()

    def test_get_hidden_fields(self):
        """DotpayProvider.get_hidden_fields() returns a dictionary"""
        provider = DotpayProvider(self.payment, seller_id='123', pin=PIN)
        self.assertEqual(type(provider.get_hidden_fields()), dict)

    def test_process_data(self):
        """DotpayProvider.process_data() returns a correct HTTP response"""
        request = MagicMock()
        request.POST = get_post_with_md5(PROCESS_POST)
        provider = DotpayProvider(self.payment, seller_id='123', pin=PIN)
        response = provider.process_data(request)
        self.assertEqual(type(response), HttpResponse)

    def test_incorrect_process_data(self):
        """DotpayProvider.process_data() checks POST signature"""
        request = MagicMock()
        request.POST = PROCESS_POST
        provider = DotpayProvider(self.payment, seller_id='123', pin=PIN)
        response = provider.process_data(request)
        self.assertEqual(type(response), HttpResponseForbidden)

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals
from django import forms

from ..forms import PaymentForm
from ..models import PAYMENT_STATUS_CHOICES


class DummyForm(PaymentForm):

    status = forms.ChoiceField(choices=PAYMENT_STATUS_CHOICES)

########NEW FILE########
__FILENAME__ = fields
from __future__ import unicode_literals
from calendar import monthrange
from datetime import date
import re

from django import forms
from django.core import validators
from django.utils.translation import ugettext_lazy as _

from . import get_credit_card_issuer
from .widgets import CreditCardExpiryWidget, CreditCardNumberWidget


class CreditCardNumberField(forms.CharField):

    widget = CreditCardNumberWidget
    default_error_messages = {
        'invalid': _('Please enter a valid card number'),
        'invalid_type': _('We accept only %(valid_types)s')}

    def __init__(self, valid_types=None, *args, **kwargs):
        self.valid_types = valid_types
        kwargs['max_length'] = kwargs.pop('max_length', 32)
        super(CreditCardNumberField, self).__init__(*args, **kwargs)

    def validate(self, value):
        card_type, issuer_name = get_credit_card_issuer(value)
        if value in validators.EMPTY_VALUES and self.required:
            raise forms.ValidationError(self.error_messages['required'])
        if value and not self.cart_number_checksum_validation(self, value):
            raise forms.ValidationError(self.error_messages['invalid'])
        if (value and not self.valid_types is None
                and not card_type in self.valid_types):
            valid_types = map(issuer_name, self.valid_types)
            error_message = self.error_messages['invalid_type'] % {
                'valid_types': ', '.join(valid_types)
            }
            raise forms.ValidationError(error_message)

    @staticmethod
    def cart_number_checksum_validation(cls, number):
        digits = []
        even = False
        if not number.isdigit():
            return False
        for digit in reversed(number):
            digit = ord(digit) - ord('0')
            if even:
                digit *= 2
                if digit >= 10:
                    digit = digit % 10 + digit // 10
            digits.append(digit)
            even = not even
        return sum(digits) % 10 == 0 if digits else False


class CreditCardExpiryField(forms.MultiValueField):

    EXP_MONTH = [(str(x), '%02d' % (x,)) for x in range(1, 13)]
    EXP_YEAR = [(str(x), str(x)) for x in range(date.today().year,
                                                date.today().year + 15)]

    default_error_messages = {
        'invalid_month': 'Enter a valid month.',
        'invalid_year': 'Enter a valid year.'}

    def __init__(self, *args, **kwargs):
        errors = self.default_error_messages.copy()
        if 'error_messages' in kwargs:
            errors.update(kwargs['error_messages'])

        fields = (
            forms.ChoiceField(
                choices=[('', _('Month'))] + self.EXP_MONTH,
                error_messages={'invalid': errors['invalid_month']}),
            forms.ChoiceField(
                choices=[('', _('Year'))] + self.EXP_YEAR,
                error_messages={'invalid': errors['invalid_year']}),
        )

        super(CreditCardExpiryField, self).__init__(fields, *args, **kwargs)
        self.widget = CreditCardExpiryWidget(widgets=[fields[0].widget,
                                                      fields[1].widget])

    def clean(self, value):
        exp = super(CreditCardExpiryField, self).clean(value)
        if date.today() > exp:
            raise forms.ValidationError(
                "The expiration date you entered is in the past.")
        return exp

    def compress(self, data_list):
        if data_list:
            if data_list[1] in forms.fields.EMPTY_VALUES:
                error = self.error_messages['invalid_year']
                raise forms.ValidationError(error)
            if data_list[0] in forms.fields.EMPTY_VALUES:
                error = self.error_messages['invalid_month']
                raise forms.ValidationError(error)
            year = int(data_list[1])
            month = int(data_list[0])
            # find last day of the month
            day = monthrange(year, month)[1]
            return date(year, month, day)
        return None


class CreditCardVerificationField(forms.CharField):

    default_error_messages = {
        'invalid': _('Enter a valid security number.')}

    def __init__(self, *args, **kwargs):
        kwargs['max_length'] = kwargs.pop('max_length', 4)
        super(CreditCardVerificationField, self).__init__(*args, **kwargs)

    def validate(self, value):
        if value in validators.EMPTY_VALUES and self.required:
            raise forms.ValidationError(self.error_messages['required'])
        if value and not re.match('^[0-9]{3,4}$', value):
            raise forms.ValidationError(self.error_messages['invalid'])

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

try:
    from collections import OrderedDict
except ImportError:
    from django.utils.datastructures import SortedDict as OrderedDict

from django import forms
from django.utils.translation import ugettext_lazy as _

from .fields import (CreditCardNumberField, CreditCardExpiryField,
                     CreditCardVerificationField)


class PaymentForm(forms.Form):
    '''
    Payment form, suitable for Django templates.

    When displaying the form remeber to use *action* and *method*.
    '''

    #: Form action URL for template use
    action = ''
    #: Form method for template use, either "get" or "post"
    method = 'post'

    def __init__(self, data=None, action=None, method='post', provider=None,
                 payment=None, hidden_inputs=True):
        if hidden_inputs and data is not None:
            super(PaymentForm, self).__init__(auto_id=False)
            for key, val in data.items():
                widget = forms.widgets.HiddenInput()
                self.fields[key] = forms.CharField(initial=val, widget=widget)
        else:
            super(PaymentForm, self).__init__(data=data)
        self.action = action
        self.method = method
        self.provider = provider
        self.payment = payment


class CreditCardPaymentForm(PaymentForm):

    number = CreditCardNumberField(label=_('Card Number'), max_length=32,
                                   required=True)
    expiration = CreditCardExpiryField()
    cvv2 = CreditCardVerificationField(
        label=_('CVV2 Security Number'), required=False, help_text=_(
            'Last three digits located on the back of your card.'
            ' For American Express the four digits found on the front side.'))

    def __init__(self, *args, **kwargs):
        super(CreditCardPaymentForm, self).__init__(
            hidden_inputs=False, *args,  **kwargs)
        if hasattr(self, 'VALID_TYPES'):
            self.fields['number'].valid_types = self.VALID_TYPES


class CreditCardPaymentFormWithName(CreditCardPaymentForm):

    name = forms.CharField(label=_('Name on Credit Card'), max_length=128)

    def __init__(self, *args, **kwargs):
        super(CreditCardPaymentFormWithName, self).__init__(*args, **kwargs)
        name_field = self.fields.pop('name')
        fields = OrderedDict({'name': name_field})
        fields.update(self.fields)
        self.fields = fields

########NEW FILE########
__FILENAME__ = models
from __future__ import unicode_literals
from uuid import uuid4

from django.conf import settings
from django.core.urlresolvers import reverse
from django.db import models
from django.utils.translation import ugettext_lazy as _

from . import factory

DEFAULT_PAYMENT_STATUS_CHOICES = (
    ('waiting', _('Waiting for confirmation')),
    ('confirmed', _('Confirmed')),
    ('rejected', _('Rejected')),
    ('error', _('Error')),
    ('input', _('Input'))
)
PAYMENT_STATUS_CHOICES = getattr(settings, 'PAYMENT_STATUS_CHOICES',
                                 DEFAULT_PAYMENT_STATUS_CHOICES)


class BasePayment(models.Model):
    '''
    Represents a single transaction. Each instance has one or more PaymentItem.
    '''
    variant = models.CharField(max_length=255)
    #: Transaction status
    status = models.CharField(max_length=10, choices=PAYMENT_STATUS_CHOICES,
                              default='waiting')
    #: Creation date and time
    created = models.DateTimeField(auto_now_add=True)
    #: Date and time of last modification
    modified = models.DateTimeField(auto_now=True)
    #: Transaction ID (if applicable)
    transaction_id = models.CharField(max_length=255, blank=True)
    #: Currency code (may be provider-specific)
    currency = models.CharField(max_length=10)
    #: Total amount (gross)
    total = models.DecimalField(max_digits=9, decimal_places=2, default='0.0')
    delivery = models.DecimalField(max_digits=9, decimal_places=2,
                                   default='0.0')
    tax = models.DecimalField(max_digits=9, decimal_places=2, default='0.0')
    description = models.TextField(blank=True, default='')
    billing_first_name = models.CharField(max_length=256, blank=True)
    billing_last_name = models.CharField(max_length=256, blank=True)
    billing_address_1 = models.CharField(max_length=256, blank=True)
    billing_address_2 = models.CharField(max_length=256, blank=True)
    billing_city = models.CharField(max_length=256, blank=True)
    billing_postcode = models.CharField(max_length=256, blank=True)
    billing_country_code = models.CharField(max_length=2, blank=True)
    billing_country_area = models.CharField(max_length=256, blank=True)
    extra_data = models.TextField(blank=True, default='')
    token = models.CharField(max_length=36, blank=True, default='')

    class Meta:
        abstract = True

    def change_status(self, status):
        '''
        Updates the Payment status and sends the status_changed signal.
        '''
        from .signals import status_changed
        self.status = status
        self.save()
        status_changed.send(sender=type(self), instance=self)

    def save(self, *args, **kwargs):
        if not self.token:
            for _i in range(100):
                token = str(uuid4())
                if not type(self).objects.filter(token=token).exists():
                    self.token = token
                    break
        return super(BasePayment, self).save(*args, **kwargs)

    def __unicode__(self):
        return self.variant

    def get_form(self, data=None):
        provider = factory(self)
        return provider.get_form(data=data)

    def get_purchased_items(self):
        return []

    def get_failure_url(self):
        raise NotImplementedError()

    def get_success_url(self):
        raise NotImplementedError()

    def get_process_url(self):
        return reverse('process_payment', kwargs={'token': self.token})

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

from ..forms import CreditCardPaymentFormWithName
from .. import get_credit_card_issuer


class PaymentForm(CreditCardPaymentFormWithName):

    VALID_TYPES = ['visa', 'mastercard', 'discover', 'amex']

    def clean(self):
        cleaned_data = super(PaymentForm, self).clean()

        if not self.errors:
            if not self.payment.transaction_id:
                number = cleaned_data.get('number')
                card_type, _card_issuer = get_credit_card_issuer(number)
                request_data = {'type': card_type}
                request_data.update(cleaned_data)
                response = self.provider.get_payment_response(cleaned_data)
                data = response.json()
                if response.ok:
                    self.payment.transaction_id = data['id']
                    self.payment.change_status('confirmed')
                else:
                    errors = [error['issue'] for error in data['details']]
                    self._errors['__all__'] = self.error_class(errors)
                    self.payment.change_status('error')
        return cleaned_data

########NEW FILE########
__FILENAME__ = tests
from __future__ import unicode_literals
from decimal import Decimal
import json
from unittest import TestCase

from . import PaypalProvider
from .. import PurchasedItem


CLIENT_ID = 'abc123'
PAYMENT_TOKEN = '5a4dae68-2715-4b1e-8bb2-2c2dbe9255f6'
SECRET = '123abc'
VARIANT = 'wallet'


class Payment(object):

    id = 1
    description = 'payment'
    currency = 'USD'
    delivery = Decimal(10)
    status = 'waiting'
    tax = Decimal(10)
    token = PAYMENT_TOKEN
    total = Decimal(100)
    variant = VARIANT

    def change_status(self, status):
        self.status = status

    def get_failure_url(self):
        return 'http://cancel.com'

    def get_process_url(self):
        return 'http://example.com'

    def get_purchased_items(self):
        return [
            PurchasedItem(
                name='foo', quantity=Decimal('10'), price=Decimal('20'),
                currency='USD', sku='bar')]

    def get_success_url(self):
        return 'http://success.com'


class TestPaypalProvider(TestCase):

    def test_payload_serializable(self):
        payment = Payment()
        provider = PaypalProvider(payment, secret=SECRET, client_id=CLIENT_ID)
        json.dumps(provider.get_product_data())

########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal

# Signal sent whenever status is changed for a Payment. This usually happens
# when a transaction is either accepted or rejected.
status_changed = Signal()

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

from django import forms
import stripe

from ..forms import PaymentForm as BasePaymentForm
from .widgets import StripeWidget
from . import RedirectNeeded


class PaymentForm(BasePaymentForm):

    charge = None

    def __init__(self, *args, **kwargs):
        super(PaymentForm, self).__init__(*args, **kwargs)
        widget = StripeWidget(provider=self.provider, payment=self.payment)
        self.fields['stripe_token'] = forms.CharField(widget=widget)
        if self.is_bound and not self.data.get('stripe_token'):
            self.payment.change_status('rejected')
            raise RedirectNeeded(self.payment.get_failure_url())

    def clean(self):
        data = self.cleaned_data

        if not self.errors and not self.payment.transaction_id:
            stripe.api_key = self.provider.secret_key
            try:
                self.charge = stripe.Charge.create(
                    capture=False,
                    amount=self.payment.total * 100,
                    currency=self.payment.currency,
                    card=data['stripe_token'],
                    description='%s %s' % (self.payment.billing_last_name,
                                           self.payment.billing_first_name)
                )
            except stripe.CardError as e:
                # The card has been declined
                self._errors['__all__'] = self.error_class([e.message])
                self.payment.change_status('error')

        return data

    def save(self):
        self.charge.capture()
        self.payment.transaction_id = self.charge.id
        self.payment.change_status('confirmed')

########NEW FILE########
__FILENAME__ = widgets
from __future__ import unicode_literals

from django.forms.widgets import HiddenInput
from django.utils.translation import ugettext_lazy as _


class StripeWidget(HiddenInput):

    def __init__(self, provider, payment, *args, **kwargs):
        attrs = kwargs.get('attrs', {})
        kwargs['attrs'] = {
            'id': 'stripe-id',
            'data-key': provider.public_key,
            'data-description': payment.description or _('Total payment'),
            # Stripe accepts cents
            'data-amount': payment.total * 100,
            'data-currency': payment.currency
        }
        kwargs['attrs'].update(attrs)
        super(StripeWidget, self).__init__(*args, **kwargs)

    class Media:
        js = ['https://checkout.stripe.com/v2/checkout.js',
              'js/payments/stripe.js']

########NEW FILE########
__FILENAME__ = tests
from unittest import TestCase

import django

if hasattr(django, 'setup'):
    django.setup()

from . import provider_factory
from .dotpay.tests import TestDotpayProvider
from .paypal.tests import TestPaypalProvider
from .wallet.tests import TestGoogleWalletProvider


__all__ = ['TestDotpayProvider', 'TestGoogleWalletProvider',
           'TestPaypalProvider']


class TestProviderFactory(TestCase):

    def test_provider_factory(self):
        provider_factory('default')

########NEW FILE########
__FILENAME__ = urls
'''
This module is responsible for automatic processing of provider callback
data (asynchronous transaction updates).
'''
from __future__ import unicode_literals

from django.conf.urls import patterns, url
from django.http import Http404
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
try:
    from django.db.transaction import atomic
except ImportError:
    def atomic(func):
        return func

from . import factory, get_payment_model, provider_factory


@csrf_exempt
@atomic
def process_data(request, token, provider=None):
    '''
    Calls process_data of an appropriate provider.

    Raises Http404 if variant does not exist.
    '''
    Payment = get_payment_model()
    payment = get_object_or_404(Payment, token=token)
    if provider:
        provider.payment = payment
    else:
        try:
            provider = factory(payment)
        except ValueError:
            raise Http404('No such payment')
    return provider.process_data(request)


@csrf_exempt
@atomic
def static_callback(request, variant):

    try:
        provider = provider_factory(variant)
    except ValueError:
        raise Http404('No such provider')

    token = provider.get_token_from_request(request)
    if not token:
        raise Http404('Invalid response')
    return process_data(request, token, provider)


urlpatterns = patterns(
    '',
    url(r'^process/(?P<token>[0-9a-z]{8}-[0-9a-z]{4}-'
        '[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12})$', process_data,
        name='process_payment'),
    url(r'^process/(?P<variant>[a-z-]+)$', static_callback,
        name='static_process_payment'),)

########NEW FILE########
__FILENAME__ = forms
from __future__ import unicode_literals

from django import forms
import jwt

from ..forms import PaymentForm as BasePaymentForm
from .widgets import WalletWidget


class PaymentForm(BasePaymentForm):

    def __init__(self, *args, **kwargs):
        super(PaymentForm, self).__init__(*args, **kwargs)
        widget = WalletWidget(provider=self.provider)
        self.fields['payment'] = forms.CharField(widget=widget, required=False)


class ProcessPaymentForm(forms.Form):

    jwt = forms.CharField(required=True)

    def __init__(self, payment, provider, **kwargs):
        super(ProcessPaymentForm, self).__init__(**kwargs)
        self.provider = provider
        self.payment = payment

    def clean_jwt(self):
        payload = super(ProcessPaymentForm, self).clean().get('jwt')
        try:
            jwt_data = jwt.decode(payload.encode('utf-8'),
                                  self.provider.seller_secret)
        except jwt.DecodeError:
            raise forms.ValidationError('Incorrect response')

        if (jwt_data['iss'] != 'Google' or
                jwt_data['aud'] != self.provider.seller_id):
            raise forms.ValidationError('Incorrect response')

        self.token = jwt_data['request']['sellerData']

        if self.payment and self.payment.token != self.token:
            raise forms.ValidationError('Incorrect payment token')

        self.order_id = jwt_data['response']['orderId']
        return payload

    def save(self):
        self.payment.transaction_id = self.order_id
        self.payment.change_status('confirmed')
        self.payment.save()

########NEW FILE########
__FILENAME__ = tests
from __future__ import unicode_literals
from decimal import Decimal
from unittest import TestCase

from django.http import HttpResponse, HttpResponseForbidden
import jwt
from mock import MagicMock

from . import GoogleWalletProvider

PAYMENT_TOKEN = '5a4dae68-2715-4b1e-8bb2-2c2dbe9255f6'
SELLER_ID = 'abc123'
SELLER_SECRET = '123abc'
VARIANT = 'wallet'


JWT_DATA = {
    'iss': 'Google',
    'aud': SELLER_ID,
    'typ': 'google/payments/inapp/item/v1/postback/buy',
    'iat': 1309988959,
    'exp': 1409988959,
    'request': {
        'name': 'Test Order #12',
        'price': '22.50',
        'currencyCode': 'USD',
        'sellerData': PAYMENT_TOKEN},
    'response': {
        'orderId': '1234567890'}}


class Payment(object):

    id = 1
    description = 'payment'
    currency = 'USD'
    delivery = Decimal(10)
    status = 'waiting'
    tax = Decimal(10)
    token = PAYMENT_TOKEN
    total = Decimal(100)
    variant = VARIANT

    def change_status(self, status):
        self.status = status

    def get_failure_url(self):
        return 'http://cancel.com'

    def get_process_url(self):
        return 'http://example.com'

    def get_purchased_items(self):
        return []

    def save(self):
        return self

    def get_success_url(self):
        return 'http://success.com'


class TestGoogleWalletProvider(TestCase):

    def test_process_data(self):
        """
        GoogleWalletProvider.process_data() returns a correct HTTP response
        """
        payment = Payment()
        request = MagicMock()
        request.POST = {'jwt': jwt.encode(JWT_DATA, SELLER_SECRET)}
        provider = GoogleWalletProvider(payment, seller_id=SELLER_ID,
                                        seller_secret=SELLER_SECRET)
        response = provider.process_data(request)
        self.assertEqual(type(response), HttpResponse)
        self.assertEqual(payment.status, 'confirmed')

    def test_incorrect_process_data(self):
        """
        GoogleWalletProvider.process_data() checks POST data
        """
        data = dict(JWT_DATA, aud='wrong seller id')
        payment = Payment()
        request = MagicMock()
        payload = jwt.encode(data, SELLER_SECRET)
        request.POST = {'jwt': payload}
        provider = GoogleWalletProvider(payment, seller_id=SELLER_ID,
                                        seller_secret=SELLER_SECRET)
        response = provider.process_data(request)
        self.assertEqual(type(response), HttpResponseForbidden)

    def test_provider_request_payment_token(self):
        request = MagicMock()
        request.POST = {'jwt': jwt.encode(JWT_DATA, SELLER_SECRET)}
        provider = GoogleWalletProvider(payment=None, seller_id=SELLER_ID,
                                        seller_secret=SELLER_SECRET)
        token = provider.get_token_from_request(request)
        self.assertEqual(token, PAYMENT_TOKEN)

    def test_provider_invalid_request(self):
        request = MagicMock()
        request.POST = {'jwt': 'wrong jwt data'}
        provider = GoogleWalletProvider(payment=None, seller_id=SELLER_ID,
                                        seller_secret=SELLER_SECRET)
        token = provider.get_token_from_request(request)
        self.assertFalse(token)

    def test_jwt_encoder(self):
        payment = Payment()
        provider = GoogleWalletProvider(payment, seller_id=SELLER_ID,
                                        seller_secret=SELLER_SECRET)
        payload = provider.get_jwt_data()
        data = jwt.decode(payload, SELLER_SECRET)
        self.assertEqual(data['request']['price'], '100')

########NEW FILE########
__FILENAME__ = widgets
from __future__ import unicode_literals

from django.forms.widgets import HiddenInput


class WalletWidget(HiddenInput):

    def __init__(self, provider, *args, **kwargs):

        kwargs['attrs'] = {
            'id': 'google-wallet-id',
            'data-jwt': provider.get_jwt_data(),
            'data-success-url': provider.payment.get_success_url(),
            'data-failure-url': provider.payment.get_failure_url(),
        }
        super(WalletWidget, self).__init__(*args, **kwargs)
        self.js = [provider.library, 'payments/js/wallet.js']

    @property
    def media(self):
        media = super(WalletWidget, self).media
        media._js = self.js
        return media

########NEW FILE########
__FILENAME__ = widgets
import re

from django.template.loader import render_to_string
from django.forms.widgets import TextInput, MultiWidget


class CreditCardNumberWidget(TextInput):

    def render(self, name, value, attrs=None):
        if value:
            value = re.sub('[\s-]', '', value)
            value = ' '.join([value[i: i + 4]
                              for i in range(0, len(value), 4)])
        return super(CreditCardNumberWidget, self).render(name, value, attrs)


# Credit Card Expiry Fields from:
# http://www.djangosnippets.org/snippets/907/
class CreditCardExpiryWidget(MultiWidget):
    """MultiWidget for representing credit card expiry date."""
    def decompress(self, value):
        if value:
            return [value.month, value.year]
        else:
            return [None, None]

    def format_output(self, rendered_widgets):
        ctx = {'month': rendered_widgets[0], 'year': rendered_widgets[1]}
        return render_to_string('payments/credit_card_expiry_widget.html', ctx)

########NEW FILE########
__FILENAME__ = test_settings
from __future__ import unicode_literals

SECRET_KEY = 'NOTREALLY'
PAYMENT_BASE_URL = 'http://example.com/'

########NEW FILE########
