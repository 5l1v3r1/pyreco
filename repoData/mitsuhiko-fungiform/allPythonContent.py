__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Fungiform documentation build configuration file, created by
# sphinx-quickstart on Mon Jun 21 16:18:04 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.join(os.path.dirname(__file__), os.path.pardir))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Fungiform'
copyright = u'2010, 2010, Armin Ronacher'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Fungiformdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Fungiform.tex', u'Fungiform Documentation',
   u'2010, Armin Ronacher', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = csrf
# -*- coding: utf-8 -*-
"""
    fungiform.csrf
    ~~~~~~~~~~~~~~

    CSRF protection for Fungiform.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import os
import hmac
from functools import update_wrapper
from zlib import adler32
try:
    from hashlib import sha1
except ImportError:
    from sha import new as sha1


#: the maximum number of csrf tokens kept in the session.  After that, the
#: oldest item is deleted
MAX_CSRF_TOKENS = 4


def csrf_url_hash(url):
    """A hash for a URL for the CSRF system."""
    if isinstance(url, unicode):
        url = url.encode('utf-8')
    return int(adler32(url) & 0xffffffff)


def random_token():
    """Creates a random token.  10 byte in size."""
    return os.urandom(10)


def get_csrf_token(session, url, force_update=False):
    """Return a CSRF token."""
    url_hash = csrf_url_hash(url)
    tokens = session.setdefault('csrf_tokens', [])
    token = None

    if not force_update:
        for stored_hash, stored_token in tokens:
            if stored_hash == url_hash:
                token = stored_token
                break
    if token is None:
        if len(tokens) >= MAX_CSRF_TOKENS:
            tokens.pop(0)

        token = random_token()
        tokens.append((url_hash, token))
        session['csrf_tokens'] = tokens

    return token.encode('hex')


def invalidate_csrf_token(session, url):
    """Clears the CSRF token for the given URL."""
    url_hash = csrf_url_hash(url)
    tokens = session.get('csrf_tokens', None)
    if not tokens:
        return
    session['csrf_tokens'] = [(h, t) for h, t in tokens if h != url_hash]

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-
"""
    fungiform.exceptions
    ~~~~~~~~~~~~~~~~~~~~

    Exception classes.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
from fungiform.utils import make_name
from fungiform.widgets import ErrorList


class ValidationError(ValueError):
    """Exception raised when invalid data is encountered."""

    def __init__(self, message):
        if not isinstance(message, (list, tuple)):
            messages = [message]
        # make all items in the list unicode (this also evaluates
        # lazy translations in there)
        messages = map(unicode, messages)
        Exception.__init__(self, messages[0])
        self.messages = messages
        self._messages = None

    def unpack(self, form, key=None):
        if self._messages is None:
            self._messages = ErrorList(form, self.messages)
        return {key: self._messages}


class MultipleValidationErrors(ValidationError):
    """A validation error subclass for multiple errors raised by
    subfields.  This is used by the mapping and list fields.
    """

    def __init__(self, errors):
        ValidationError.__init__(self, '%d error%s' % (
            len(errors), len(errors) != 1 and 's' or ''
        ))
        self.errors = errors

    def __unicode__(self):
        return ', '.join(map(unicode, self.errors.itervalues()))

    def unpack(self, form, key=None):
        rv = {}
        for name, error in self.errors.iteritems():
            rv.update(error.unpack(form, make_name(key, name)))
        return rv

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    fungiform.forms
    ~~~~~~~~~~~~~~~

    This module implements all forms and helpers to implement a proper
    form handling.

    How to use validators
    ---------------------

    Validators are just simple functions with two arguments, the actual form
    and the value to validate.  A simple validator could look like this::

        def is_valid_email(form, value):
            if '@' not in value or len(value) > 200:
                raise ValidationError('Invalid email address')

    Now just apply these validators to the form field::

        class MyForm(FormBase):
            name = TextField(u'Name: ', required=True)
            email = TextField(u'Email: ', validators=[is_valid_email])


    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
from datetime import datetime, date
from itertools import count
from threading import Lock
from urlparse import urljoin

from fungiform import widgets
from fungiform.exceptions import ValidationError, MultipleValidationErrors
from fungiform.utils import OrderedDict, decode_form_data, \
                            format_system_datetime, format_system_date, \
                            parse_datetime, parse_date, get_timezone, \
                            _force_dict, _force_list, _to_string, _to_list, \
                            html, _make_widget, _value_matches_choice, \
                            get_current_url
from fungiform.recaptcha import validate_recaptcha
from fungiform.redirects import get_redirect_target
from fungiform.csrf import get_csrf_token, invalidate_csrf_token


__all__ = ['FormBase', 'Field', 'Mapping', 'Multiple', 'CommaSeparated',
           'LineSeparated', 'TextField', 'PasswordField', 'DateTimeField',
           'DateField', 'ChoiceField', 'MultiChoiceField', 'IntegerField',
           'BooleanField', 'FormBase']


_last_position_hint = -1
_position_hint_lock = Lock()

_next_position_hint = count().next

_dummy_translations = (type('_dummy_translations', (object,), {
    'ugettext':     lambda x, s: s,
    'ungettext':    lambda x, s, p, n: [s, p][n != 1]
}))()


def _bind(obj, form, memo):
    """Helper for the field binding.  This is inspired by the way `deepcopy`
    is implemented.
    """
    if memo is None:
        memo = {}
    obj_id = id(obj)
    if obj_id in memo:
        return memo[obj_id]
    rv = obj._bind(form, memo)
    memo[obj_id] = rv
    return rv


class FieldMeta(type):

    def __new__(cls, name, bases, d):
        messages = {}
        for base in reversed(bases):
            if hasattr(base, 'messages'):
                messages.update(base.messages)
        if 'messages' in d:
            messages.update(d['messages'])
        d['messages'] = messages
        return type.__new__(cls, name, bases, d)


class Field(object):
    """Abstract field base class."""

    __metaclass__ = FieldMeta
    messages = dict(required=None)
    form = None
    widget = widgets.TextInput

    # these attributes are used by the widgets to get an idea what
    # choices to display.  Not every field will also validate them.
    multiple_choices = False
    choices = ()

    # fields that have this attribute set get special treatment on
    # validation.  It means that even though a value was not in the
    # submitted data it's validated against a default value.
    validate_on_omission = False

    def __init__(self, label=None, help_text=None, validators=None,
                 widget=None, messages=None, sentinel=False):
        self._position_hint = _next_position_hint()
        self.label = label
        self.help_text = help_text
        if validators is None:
            validators = []
        self.validators = validators
        self.custom_converter = None
        if widget is not None:
            self.widget = widget
        if messages:
            self.messages = self.messages.copy()
            self.messages.update(messages)
        self.sentinel = sentinel
        assert not issubclass(self.widget, widgets.InternalWidget), \
            'can\'t use internal widgets as widgets for fields'

    def gettext(self, string):
        if self.form is None:
            return string
        return self.form._get_translations().ugettext(string)

    def ngettext(self, sg, pl, n):
        if self.form is None:
            return [sg, pl](n != 1)
        return self.form._get_translations().ungettext(sg, pl, n)

    def __call__(self, value):
        value = self.convert(value)
        self.apply_validators(value)
        return value

    def __copy__(self):
        return _bind(self, None, None)

    def apply_validators(self, value):
        """Applies all validators on the value."""
        if self.should_validate(value):
            for validate in self.validators:
                validate(self.form, value)

    def empty_as_item(self, value):
        """Multiple fields use this method to decide if the field is
        considered empty or not.  Empty fields are not validated and
        stored.  For this function to ever return `True` it has to be
        defined as sentinel.  Example::

            items = Multiple(Mapping(
                name = TextField(required=True),
                count = IntegerField(required=True, sentinel=True)
            ))

        If the count is omitted the item will not be validated and
        added to the list.  As soon as a value is inserted to the
        count field, validation happens.
        """
        return self.sentinel and not value

    def should_validate(self, value):
        """Per default validate if the value is not None.  This method is
        called before the custom validators are applied to not perform
        validation if the field is empty and not required.

        For example a validator like `is_valid_ip` is never called if the
        value is an empty string and the field hasn't raised a validation
        error when checking if the field is required.
        """
        return value is not None

    def convert(self, value):
        """This can be overridden by subclasses and performs the value
        conversion.
        """
        return _to_string(value)

    def to_primitive(self, value):
        """Convert a value into a primitve (string or a list/dict of lists,
        dicts or strings).

        This method must never fail!
        """
        return _to_string(value)

    def _bind(self, form, memo):
        """Method that binds a field to a form. If `form` is None, a copy of
        the field is returned."""
        if form is not None and self.bound:
            raise TypeError('%r already bound' % type(obj).__name__)
        rv = object.__new__(self.__class__)
        rv.__dict__.update(self.__dict__)
        rv.validators = self.validators[:]
        rv.messages = self.messages.copy()
        if form is not None:
            rv.form = form
        return rv

    @property
    def bound(self):
        """True if the form is bound."""
        return 'form' in self.__dict__

    def __repr__(self):
        rv = object.__repr__(self)
        if self.bound:
            rv = rv[:-1] + ' [bound]>'
        return rv


class Mapping(Field):
    """Apply a set of fields to a dictionary of values.

    >>> field = Mapping(name=TextField(), age=IntegerField())
    >>> field({'name': u'John Doe', 'age': u'42'})
    {'age': 42, 'name': u'John Doe'}

    Although it's possible to reassign the widget after field construction
    it's not recommended because the `MappingWidget` is the only builtin
    widget that is able to handle mapping structures.
    """

    widget = widgets.MappingWidget

    def __init__(self, *args, **fields):
        Field.__init__(self)
        if len(args) == 1:
            if fields:
                raise TypeError('keyword arguments and dict given')
            self.fields = OrderedDict(args[0])
        else:
            if args:
                raise TypeError('no positional arguments allowed if keyword '
                                'arguments provided.')
            self.fields = OrderedDict(fields)
        self.fields.sort(key=lambda i: i[1]._position_hint)

    def empty_as_item(self, values):
        for name, field in self.fields.iteritems():
            if field.empty_as_item(values.get(name)):
                return True
        return False

    def convert(self, value):
        value = _force_dict(value)
        errors = {}
        result = {}
        for name, field in self.fields.iteritems():
            try:
                result[name] = field(value.get(name))
            except ValidationError, e:
                errors[name] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        value = _force_dict(value)
        result = {}
        for key, field in self.fields.iteritems():
            result[key] = field.to_primitive(value.get(key))
        return result

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        rv.fields = OrderedDict()
        for key, field in self.fields.iteritems():
            rv.fields[key] = _bind(field, form, memo)
        return rv


class FormMapping(Mapping):
    """Like a mapping but does csrf protection and stuff."""

    widget = widgets.FormWidget

    def convert(self, value):
        if self.form is None:
            raise TypeError('form mapping without form passed is unable '
                            'to convert data')
        if self.form.csrf_protected:
            token = self.form.raw_data.get('_csrf_token')
            if token != self.form.csrf_token:
                message = self.gettext(u'Form submitted multiple times or '
                                       u'session expired.  Try again.')
                raise ValidationError(message)
        if self.form.captcha_protected:
            if not validate_recaptcha(
                    self.form.recaptcha_private_key,
                    self.form.raw_data.get('recaptcha_challenge_field'),
                    self.form.raw_data.get('recaptcha_response_field'),
                    self.form._get_remote_addr()):
                message = self.gettext('You entered an invalid captcha.')
                raise ValidationError(message)
        return Mapping.convert(self, value)


class FormAsField(Mapping):
    """If a form is converted into a field the returned field object is an
    instance of this class.  The behavior is mostly equivalent to a normal
    :class:`Mapping` field with the difference that it as an attribute called
    :attr:`form_class` that points to the form class it was created from.
    """

    def __init__(self):
        raise TypeError('can\'t create %r instances' %
                        self.__class__.__name__)


class Multiple(Field):
    """Apply a single field to a sequence of values.

    >>> field = Multiple(IntegerField())
    >>> field([u'1', u'2', u'3'])
    [1, 2, 3]

    Recommended widgets:

    -   `ListWidget` -- the default one and useful if multiple complex
        fields are in use.
    -   `CheckboxGroup` -- useful in combination with choices
    -   `SelectBoxWidget` -- useful in combination with choices
    """

    widget = widgets.ListWidget
    messages = dict(too_small=None, too_big=None)
    validate_on_omission = True

    def __init__(self, field, label=None, help_text=None, min_size=None,
                 max_size=None, validators=None, widget=None, messages=None):
        Field.__init__(self, label, help_text, validators, widget, messages)
        self.field = field
        self.min_size = min_size
        self.max_size = max_size

    @property
    def multiple_choices(self):
        return self.max_size is None or self.max_size > 1

    def empty_as_item(self, values):
        for idx, value in enumerate(values):
            if self.field.empty_as_item(value):
                return True
        return False

    def _remove_empty(self, values):
        return [(idx, value) for idx, value in enumerate(values)
                if not self.field.empty_as_item(value)]

    def convert(self, value):
        value = self._remove_empty(_force_list(value))
        if self.min_size is not None and len(value) < self.min_size:
            message = self.messages['too_small']
            if message is None:
                message = self.ngettext(
                    u'Please provide at least %d item.',
                    u'Please provide at least %d items.',
                    self.min_size) % self.min_size
            raise ValidationError(message)
        if self.max_size is not None and len(value) > self.max_size:
            message = self.messages['too_big']
            if message is None:
                message = self.ngettext(
                    u'Please provide no more than %d item.',
                    u'Please provide no more than %d items.',
                    self.max_size) % self.max_size
            raise ValidationError(message)
        result = []
        errors = {}
        for idx, item in value:
            try:
                result.append(self.field(item))
            except ValidationError, e:
                errors[idx] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        return map(self.field.to_primitive, _force_list(value))

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        rv.field = _bind(self.field, form, memo)
        return rv


class CommaSeparated(Multiple):
    """Works like the multiple field but for comma separated values:

    >>> field = CommaSeparated(IntegerField())
    >>> field(u'1, 2, 3')
    [1, 2, 3]

    The default widget is a `TextInput` but `Textarea` would be a possible
    choices as well.
    """

    widget = widgets.TextInput

    def __init__(self, field, label=None, help_text=None, min_size=None,
                 max_size=None, sep=u',', validators=None, widget=None,
                 messages=None):
        Multiple.__init__(self, field, label, help_text, min_size,
                          max_size, validators, widget, messages)
        self.sep = sep

    def convert(self, value):
        if isinstance(value, basestring):
            value = filter(None, [x.strip() for x in value.split(self.sep)])
        return Multiple.convert(self, value)

    def to_primitive(self, value):
        if value is None:
            return u''
        if isinstance(value, basestring):
            return value
        return (self.sep + u' ').join(map(self.field.to_primitive, value))


class LineSeparated(Multiple):
    r"""Works like `CommaSeparated` but uses multiple lines:

    >>> field = LineSeparated(IntegerField())
    >>> field(u'1\n2\n3')
    [1, 2, 3]

    The default widget is a `Textarea` and taht is pretty much the only thing
    that makes sense for this widget.
    """
    widget = widgets.Textarea

    def convert(self, value):
        if isinstance(value, basestring):
            value = filter(None, [x.strip() for x in value.splitlines()])
        return Multiple.convert(self, value)

    def to_primitive(self, value):
        if value is None:
            return u''
        if isinstance(value, basestring):
            return value
        return u'\n'.join(map(self.field.to_primitive, value))


class TextField(Field):
    """Field for strings.

    >>> field = TextField(required=True, min_length=6)
    >>> field('foo bar')
    u'foo bar'
    >>> field('')
    Traceback (most recent call last):
      ...
    ValidationError: This field is required.
    """

    messages = dict(too_short=None, too_long=None)

    def __init__(self, label=None, help_text=None, required=False,
                 min_length=None, max_length=None, validators=None,
                 widget=None, messages=None, sentinel=False):
        Field.__init__(self, label, help_text, validators, widget, messages,
                       sentinel)
        self.required = required
        self.min_length = min_length
        self.max_length = max_length

    def convert(self, value):
        value = _to_string(value)
        if self.required:
            if not value:
                message = self.messages['required']
                if message is None:
                    message = self.gettext(u'This field is required.')
                raise ValidationError(message)
        if value:
            if self.min_length is not None and len(value) < self.min_length:
                message = self.messages['too_short']
                if message is None:
                    message = self.ngettext(
                        u'Please enter at least %d character.',
                        u'Please enter at least %d characters.',
                        self.min_length) % self.min_length
                raise ValidationError(message)
            if self.max_length is not None and len(value) > self.max_length:
                message = self.messages['too_long']
                if message is None:
                    message = self.ngettext(
                        u'Please enter no more than %d character.',
                        u'Please enter no more than %d characters.',
                        self.max_length) % self.max_length
                raise ValidationError(message)
        return value

    def should_validate(self, value):
        """Validate if the string is not empty."""
        return bool(value)


class PasswordField(TextField):
    """A special :class:`TextField` for passwords."""

    widget = widgets.PasswordInput


class DateTimeField(Field):
    """Field for datetime objects.

    >>> field = DateTimeField()
    >>> field('1970-01-12 00:00')
    datetime.datetime(1970, 1, 12, 0, 0)

    >>> field('foo')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a valid date.
    """

    messages = dict(invalid_date=None)

    def __init__(self, label=None, help_text=None, required=False,
                 tzinfo=None, validators=None, widget=None, messages=None,
                 date_formats=None, time_formats=None):
        Field.__init__(self, label, help_text, validators, widget, messages)
        self.required = required
        self._tzinfo = get_timezone(tzinfo)
        self.date_formats = date_formats
        self.time_formats = time_formats

    @property
    def tzinfo(self):
        tzinfo = self._tzinfo
        return tzinfo() if hasattr(tzinfo, '__call__') else tzinfo

    def convert(self, value):
        if isinstance(value, datetime):
            return value
        value = _to_string(value)
        if not value:
            if self.required:
                message = self.messages['required']
                if message is None:
                    message = self.gettext(u'This field is required.')
                raise ValidationError(message)
            return None
        try:
            return parse_datetime(value, tzinfo=self.tzinfo,
                                  date_formats=self.date_formats,
                                  time_formats=self.time_formats)
        except ValueError:
            message = self.messages['invalid_date']
            if message is None:
                message = self.gettext('Please enter a valid date.')
            raise ValidationError(message)

    def to_primitive(self, value):
        if isinstance(value, datetime):
            value = format_system_datetime(value, tzinfo=self.tzinfo)
        return value


class DateField(Field):
    """Field for date objects.

    >>> field = DateField()
    >>> field('1970-01-12')
    datetime.date(1970, 1, 12)

    >>> field('foo')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a valid date.
    """

    messages = dict(invalid_date=None)

    def __init__(self, label=None, help_text=None, required=False,
                 validators=None, widget=None, messages=None,
                 date_formats=None):
        Field.__init__(self, label, help_text, validators, widget, messages)
        self.required = required
        self.date_formats = date_formats

    def convert(self, value):
        if isinstance(value, date):
            return value
        value = _to_string(value)
        if not value:
            if self.required:
                message = self.messages['required']
                if message is None:
                    message = self.gettext(u'This field is required.')
                raise ValidationError(message)
            return None
        try:
            return parse_date(value, date_formats=self.date_formats)
        except ValueError:
            message = self.messages['invalid_date']
            if message is None:
                message = self.gettext('Please enter a valid date.')
            raise ValidationError(message)

    def to_primitive(self, value):
        if isinstance(value, date):
            value = format_system_date(value)
        return value


class ChoiceField(Field):
    """A field that lets a user select one out of many choices.

    A choice field accepts some choices that are valid values for it.
    Values are compared after converting to unicode which means that
    ``1 == "1"``:

    >>> field = ChoiceField(choices=[1, 2, 3])
    >>> field('1')
    1
    >>> field('42')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a valid choice.

    Two values `a` and `b` are considered equal if either ``a == b`` or
    ``primitive(a) == primitive(b)`` where `primitive` is the primitive
    of the value.  Primitives are created with the following algorithm:

        1.  if the object is `None` the primitive is the empty string
        2.  otherwise the primitive is the string value of the object

    A choice field also accepts lists of tuples as argument where the
    first item is used for comparing and the second for displaying
    (which is used by the `SelectBoxWidget`):

    >>> field = ChoiceField(choices=[(0, 'inactive'), (1, 'active')])
    >>> field('0')
    0

    Because all fields are bound to the form before validation it's
    possible to assign the choices later:

    >>> class MyForm(FormBase):
    ...     status = ChoiceField()
    ...
    >>> form = MyForm()
    >>> form.status.choices = [(0, 'inactive', 1, 'active')]
    >>> form.validate({'status': '0'})
    True
    >>> form.data
    {'status': 0}

    If a choice field is set to "not required" and a `SelectBox` is used
    as widget you have to provide an empty choice or the field cannot be
    left blank.

    >>> field = ChoiceField(required=False, choices=[('', u'Nothing'),
    ...                                              ('1', u'Something')])
    """

    widget = widgets.SelectBox
    messages = dict(invalid_choice=None)

    def __init__(self, label=None, help_text=None, required=True,
                 choices=None, validators=None, widget=None, messages=None,
                 sentinel=False):
        Field.__init__(self, label, help_text, validators, widget, messages,
                       sentinel)
        self.required = required
        self.choices = choices

    def convert(self, value):
        if not value and not self.required:
            return
        if self.choices:
            for choice in self.choices:
                if isinstance(choice, tuple):
                    choice = choice[0]
                if _value_matches_choice(value, choice):
                    return choice
        message = self.messages['invalid_choice']
        if message is None:
            message = self.gettext('Please enter a valid choice.')
        raise ValidationError(message)

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        if self.choices is not None:
            rv.choices = list(self.choices)
        return rv


class MultiChoiceField(ChoiceField):
    """A field that lets a user select multiple choices."""

    multiple_choices = True
    messages = dict(too_small=None, too_big=None)
    validate_on_omission = True

    def __init__(self, label=None, help_text=None, choices=None,
                 min_size=None, max_size=None, validators=None,
                 widget=None, messages=None, sentinel=False):
        ChoiceField.__init__(self, label, help_text, min_size > 0, choices,
                             validators, widget, messages, sentinel)
        self.min_size = min_size
        self.max_size = max_size

    def convert(self, value):
        result = []
        known_choices = {}
        for choice in self.choices:
            if isinstance(choice, tuple):
                choice = choice[0]
            known_choices[choice] = choice
            known_choices.setdefault(_to_string(choice), choice)

        x = _to_list(value)
        for value in _to_list(value):
            for version in value, _to_string(value):
                if version in known_choices:
                    result.append(known_choices[version])
                    break
            else:
                message = self.gettext(u'"%s" is not a valid choice') % value
                raise ValidationError(message)

        if self.min_size is not None and len(result) < self.min_size:
            message = self.messages['too_small']
            if message is None:
                message = self.ngettext(
                    u'Please provide at least %d item.',
                    u'Please provide at least %d items.',
                    self.min_size) % self.min_size
            raise ValidationError(message)
        if self.max_size is not None and len(result) > self.max_size:
            message = self.messages['too_big']
            if message is None:
                message = self.ngettext(
                    u'Please provide no more than %d item.',
                    u'Please provide no more than %d items.',
                    self.min_size) % self.min_size
            raise ValidationError(message)

        return result

    def to_primitive(self, value):
        return map(unicode, _force_list(value))


class FloatField(Field):
    """Field for floating-point numbers.

    >>> field = FloatField(min_value=0,max_value=99.9)
    >>> field('13')
    13.0

    >>> field('13.123')
    13.122999999999999

    >>> field('thirteen')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a floating-point number.

    >>> field(101)
    Traceback (most recent call last):
      ...
    ValidationError: Ensure this value is less than or equal to 99.9.
    """

    messages = dict(
        too_small=None,
        too_big=None,
        no_float=None
    )

    def __init__(self, label=None, help_text=None, required=False,
                 min_value=None, max_value=None, validators=None,
                 widget=None, messages=None, sentinel=False):
        Field.__init__(self, label, help_text, validators, widget, messages,
                       sentinel)
        self.required = required
        self.min_value = min_value
        self.max_value = max_value

    def convert(self, value):
        value = _to_string(value)
        if not value:
            if self.required:
                message = self.messages['required']
                if message is None:
                    message = self.gettext(u'This field is required.')
                raise ValidationError(message)
            return None
        try:
            value = float(value)
        except ValueError:
            message = self.messages['no_float']
            if message is None:
                message = self.gettext('Please enter a floating-point number.')
            raise ValidationError(message)

        if self.min_value is not None and value < self.min_value:
            message = self.messages['too_small']
            if message is None:
                message = self.gettext(u'Ensure this value is greater than or '
                                       u'equal to %s.') % self.min_value
            raise ValidationError(message)
        if self.max_value is not None and value > self.max_value:
            message = self.messages['too_big']
            if message is None:
                message = self.gettext(u'Ensure this value is less than or '
                                       u'equal to %s.') % self.max_value
            raise ValidationError(message)

        return float(value)


class IntegerField(Field):
    """Field for integers.

    >>> field = IntegerField(min_value=0, max_value=99)
    >>> field('13')
    13

    >>> field('thirteen')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a whole number.

    >>> field('193')
    Traceback (most recent call last):
      ...
    ValidationError: Ensure this value is less than or equal to 99.
    """

    messages = dict(
        too_small=None,
        too_big=None,
        no_integer=None
    )

    def __init__(self, label=None, help_text=None, required=False,
                 min_value=None, max_value=None, validators=None,
                 widget=None, messages=None, sentinel=False):
        Field.__init__(self, label, help_text, validators, widget, messages,
                       sentinel)
        self.required = required
        self.min_value = min_value
        self.max_value = max_value

    def convert(self, value):
        value = _to_string(value)
        if not value:
            if self.required:
                message = self.messages['required']
                if message is None:
                    message = self.gettext(u'This field is required.')
                raise ValidationError(message)
            return None
        try:
            value = int(value)
        except ValueError:
            message = self.messages['no_integer']
            if message is None:
                message = self.gettext('Please enter a whole number.')
            raise ValidationError(message)

        if self.min_value is not None and value < self.min_value:
            message = self.messages['too_small']
            if message is None:
                message = self.gettext(u'Ensure this value is greater than or '
                                       u'equal to %s.') % self.min_value
            raise ValidationError(message)
        if self.max_value is not None and value > self.max_value:
            message = self.messages['too_big']
            if message is None:
                message = self.gettext(u'Ensure this value is less than or '
                                       u'equal to %s.') % self.max_value
            raise ValidationError(message)

        return int(value)


class BooleanField(Field):
    """Field for boolean values.

    >>> field = BooleanField()
    >>> field('1')
    True

    >>> field = BooleanField()
    >>> field('')
    False
    """

    widget = widgets.Checkbox
    validate_on_omission = True
    choices = [u'True', u'False']

    def convert(self, value):
        return value != u'False' and bool(value)

    def to_primitive(self, value):
        if self.convert(value):
            return u'True'
        return u'False'


class FormMeta(type):
    """Meta class for forms.  Handles form inheritance and registers
    validator functions.
    """

    def __new__(cls, name, bases, d):
        fields = {}
        validator_functions = {}
        root_validator_functions = []

        for base in reversed(bases):
            if hasattr(base, '_root_field'):
                # base._root_field is always a FormMapping field
                fields.update(base._root_field.fields)
                root_validator_functions.extend(base._root_field.validators)

        for key, value in d.iteritems():
            if key.startswith('validate_') and callable(value):
                validator_functions[key[9:]] = value
            elif isinstance(value, Field):
                fields[key] = value
                d[key] = FieldDescriptor(key)

        for field_name, func in validator_functions.iteritems():
            if field_name in fields:
                fields[field_name].validators.append(func)

        d['_root_field'] = root = FormMapping(**fields)
        context_validate = d.get('context_validate')
        root.validators.extend(root_validator_functions)
        if context_validate is not None:
            root.validators.append(context_validate)

        return type.__new__(cls, name, bases, d)

    def as_field(cls):
        """Returns a field object for this form.  The field object returned
        is independent of the form and can be modified in the same manner as
        a bound field.
        """
        field = object.__new__(FormAsField)
        field.__dict__.update(cls._root_field.__dict__)
        field.form_class = cls
        field.validators = cls._root_field.validators[:]
        field.fields = cls._root_field.fields.copy()
        return field

    @property
    def validators(cls):
        return cls._root_field.validators

    @property
    def fields(cls):
        return cls._root_field.fields


class FieldDescriptor(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, type=None):
        try:
            return (obj or type).fields[self.name]
        except KeyError:
            raise AttributeError(self.name)

    def __set__(self, obj, value):
        obj.fields[self.name] = value

    def __delete__(self, obj):
        if self.name not in obj.fields:
            raise AttributeError('%r has no attribute %r' %
                                 (type(obj).__name__, self.name))
        del obj.fields[self.name]


class FormBase(object):
    """Form base class.

    >>> class PersonForm(FormBase):
    ...     name = TextField(required=True)
    ...     age = IntegerField()

    >>> form = PersonForm()
    >>> form.validate({'name': 'johnny', 'age': '42'})
    True
    >>> form.data['name']
    u'johnny'
    >>> form.data['age']
    42

    Let's cause a simple validation error:

    >>> form = PersonForm()
    >>> form.validate({'name': '', 'age': 'fourty-two'})
    False
    >>> print form.errors['age'][0]
    Please enter a whole number.
    >>> print form.errors['name'][0]
    This field is required.

    You can also add custom validation routines for fields by adding methods
    that start with the prefix ``validate_`` and the field name that take the
    value as argument. For example:

    >>> class PersonForm(FormBase):
    ...     name = TextField(required=True)
    ...     age = IntegerField()
    ...
    ...     def validate_name(self, value):
    ...         if not value.isalpha():
    ...             message = u'The value must only contain letters'
    ...             raise ValidationError(message)

    >>> form = PersonForm()
    >>> form.validate({'name': 'mr.t', 'age': '42'})
    False
    >>> form.errors
    {'name': [u'The value must only contain letters']}

    You can also validate multiple fields in the context of other fields.
    That validation is performed after all other validations.  Just add a
    method called ``context_validate`` that is passed the dict of all fields:

    >>> class RegisterForm(FormBase):
    ...     username = TextField(required=True)
    ...     password = TextField(required=True)
    ...     password_again = TextField(required=True)
    ...
    ...     def context_validate(self, data):
    ...         if data['password'] != data['password_again']:
    ...             message = u'The two passwords must be the same'
    ...             raise ValidationError(message)
    ...
    >>> form = RegisterForm()
    >>> form.validate({'username': 'admin', 'password': 'blah',
    ...                'password_again': 'blag'})
    ...
    False
    >>> form.errors
    {None: [u'The two passwords must be the same']}

    Forms can be used as fields for other forms.  To create a form field of
    a form you can call the `as_field` class method::

    >>> field = RegisterForm.as_field()

    This field can be used like any other field class.  What's important about
    forms as fields is that validators don't get an instance of `RegisterForm`
    passed as `form` / `self` but the form where it's used in if the field is
    used from a form.

    Form fields are bound to the form on form instanciation.  This makes it
    possible to modify a particular instance of the form.  For example you
    can create an instance of it and drop some fields by using
    ``del form.fields['name']`` or reassign choices of choice fields.  It's
    however not easily possible to add new fields to an instance because newly
    added fields wouldn't be bound.  The fields that are stored directly on
    the form can also be accessed with their name like a regular attribute.

    Example usage:

    >>> class StatusForm(FormBase):
    ...     status = ChoiceField()
    ...
    >>> StatusForm.status.bound
    False
    >>> form = StatusForm()
    >>> form.status.bound
    True
    >>> form.status.choices = [u'happy', u'unhappy']
    >>> form.validate({'status': u'happy'})
    True
    >>> form['status']
    u'happy'

    Forms can be recaptcha protected by setting `captcha_protected` to `True`.
    If captcha protection is enabled the captcha has to be rendered from the
    widget created, like a field.

    Forms are CSRF protected if they are created in the context of an active
    request or if an request is passed to the constructor.  In order for the
    CSRF protection to work it will modify the session on the request.

    The consequence of that is that the application must not ignore session
    changes.
    """
    __metaclass__ = FormMeta

    csrf_protected = None
    redirect_tracking = True
    allowed_redirect_rules = None
    captcha_protected = False
    default_method = 'POST'
    html_builder = html

    recaptcha_public_key = None
    recaptcha_private_key = None
    recaptcha_use_ssl = True

    def __init__(self, initial=None, action=None, request_info=None):
        if request_info is None:
            request_info = self._lookup_request_info()
        self.request_info = request_info
        if initial is None:
            initial = {}
        self.initial = initial
        self.action = action
        self.invalid_redirect_targets = set()

        if self.request_info is not None:
            if self.csrf_protected is None:
                self.csrf_protected = True
            if self.action in (None, u'', u'.'):
                self.action = self._get_default_action()
            else:
                self.action = urljoin(self._get_request_url(), self.action)
        elif self.csrf_protected is None:
            self.csrf_protected = False

        if self.action is None:
            self.action = u''

        self._root_field = _bind(self.__class__._root_field, self, {})
        self.reset()

    def __getitem__(self, key):
        return self.data[key]

    def __contains__(self, key):
        return key in self.data

    def as_widget(self):
        """Return the form as widget."""
        # if there is submitted data, use that for the widget
        if self.raw_data is not None:
            data = self.raw_data
        # otherwise go with the data from the source (eg: database)
        else:
            data = self.data
        return _make_widget(self._root_field, None, data, self.errors)

    def add_invalid_redirect_target(self, *args, **kwargs):
        """Add an invalid target. Invalid targets are URLs we don't want to
        visit again. For example if a post is deleted from the post edit page
        it's a bad idea to redirect back to the edit page because in that
        situation the edit page would return a page not found.

        This function accepts the same parameters as `url_for`.
        """
        self.invalid_redirect_targets.add(self._resolve_url(args, kwargs))

    @property
    def redirect_target(self):
        """The back-redirect target for this form."""
        return self._get_valid_redirect_target()

    def redirect(self, *args, **kwargs):
        """Redirects to the url rule given or back to the URL where we are
        comming from if `redirect_tracking` is enabled.
        """
        target = None
        if self.redirect_tracking:
            target = self.redirect_target
        if target is None:
            return self._redirect_to_url(self._resolve_url(args, kwargs))
        return self._redirect_to_url(target)

    @property
    def csrf_token(self):
        """The unique CSRF security token for this form."""
        if not self.csrf_protected:
            raise AttributeError('no csrf token because form not '
                                 'csrf protected')
        return get_csrf_token(self._get_session(), self.action)

    @property
    def is_valid(self):
        """True if the form is valid."""
        return not self.errors

    @property
    def has_changed(self):
        """True if the form has changed."""
        return self._root_field.to_primitive(self.initial) != \
               self._root_field.to_primitive(self.data)

    @property
    def fields(self):
        return self._root_field.fields

    @property
    def validators(self):
        return self._root_field.validators

    def reset(self):
        """Resets the form."""
        self.data = self.initial.copy()
        self.errors = {}
        self.raw_data = None

    def add_error(self, error, field=None):
        """Adds an error to a field."""
        seq = self.errors.get(field)
        if seq is None:
            seq = self.errors[field] = widgets.ErrorList(self)
        seq.append(error)

    def validate(self, data=None, from_flat=True):
        """Validate the form against the data passed.  If no data is provided
        the form data of the current request is taken.  By default a flat
        representation of the data is assumed.  If you already have a non-flat
        representation of the data (JSON for example) you can disable that
        with ``from_flat=False``.
        """
        if data is None:
            data = self._autodiscover_data()
        if from_flat:
            data = decode_form_data(data)
        self.raw_data = data

        # for each field in the root that requires validation on value
        # omission we add `None` into the raw data dict.  Because the
        # implicit switch between initial data and user submitted data
        # only happens on the "root level" for obvious reasons we only
        # have to hook the data in here.
        for name, field in self._root_field.fields.iteritems():
            if field.validate_on_omission and name not in self.raw_data:
                self.raw_data.setdefault(name)

        d = self.data.copy()
        d.update(self.raw_data)
        errors = {}
        try:
            data = self._root_field(d)
        except ValidationError, e:
            errors = e.unpack(self)
        self.errors = errors

        # every time we validate, we invalidate the csrf token if there
        # was one.
        if self.csrf_protected:
            # FIXME: do we really want action here?
            invalidate_csrf_token(self._get_session(), self.action)

        if errors:
            return False

        self.data.update(data)
        return True

    # extra functionality that has to be implemented

    def _get_translations(self):
        """Has to return a gettext translations object that supports
        unicode.  By default a dummy is returned.
        """
        return _dummy_translations

    def _lookup_request_info(self):
        """Called if no request info is passed to the form.  Might lookup
        the request info from a thread local storage.
        """
        return None

    def _get_wsgi_environ(self):
        """Return the WSGI environment from the request info if possible."""
        return None

    def _get_default_action(self):
        """Returns the default action if no action is given.  If this method
        returns `None` an empty default action is used which will always
        submit to the same URL.
        """
        return None

    def _get_request_url(self):
        """Returns the current URL of the request.  When this is called,
        `self.request_info` is set to the request info passed or the
        one looked up by `_lookup_request_info`.
        """
        env = self._get_wsgi_environ()
        if env is not None:
            return get_current_url(env)
        return ''

    def _autodiscover_data(self):
        """Called by `validate` if no data is provided.  Finds the
        matching data from the request object by default depending
        on the default submit method of the form.
        """
        raise NotImplementedError(
            'No data passed to the validation and data auto discovery not '
            'implemented.  Override the `_autodiscover_data` method.')

    def _get_redirect_user_url(self):
        """Returns the user URL.  By default only the `_redirect_target` from
        the form is taken into account.  You can override this if you want
        to support an URL `next` parameter.
        """
        # FIXME: raw_data is still none, is this wanted?
        return (None if self.raw_data is None else
                self.raw_data.get('_redirect_target'))

    def _get_valid_redirect_target(self):
        environ = self._get_wsgi_environ()
        if environ is None:
            raise NotImplementedError(
                'the default `_get_valid_redirect_target` requires '
                '`_get_wsgi_environ` to return a WSGI environment.')
        user_url = self._get_redirect_user_url()
        return get_redirect_target(environ, user_url,
                                   self.invalid_redirect_targets,
                                   self.allowed_redirect_rules)

    def _redirect_to_url(self, url):
        raise NotImplementedError(
            'if you want to use redirects you have to implement the '
            '`_redirect_to_url` method.')

    def _resolve_url(self, args, kwargs):
        if len(args) == 1:
            return args[0]
        raise NotImplementedError(
            '`_resolve_url` does not know how to handle the arguments that '
            'were forwarded.  If you want to integrate your own url system, '
            'implement a different logic into that method.')

    def _get_session(self):
        raise NotImplementedError(
            'some features require access to the session.  If you want those, '
            'implement `_get_session`.')

    def _get_remote_addr(self):
        return self._get_wsgi_environ()['REMOTE_ADDR']

########NEW FILE########
__FILENAME__ = recaptcha
# -*- coding: utf-8 -*-
"""
    fungiform.recaptcha
    ~~~~~~~~~~~~~~~~~~~

    Recaptcha support.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
from fungiform.utils import Markup
from urllib import urlencode
import urllib2
try:
    from simplejson import dumps
except ImportError:
    try:
        from json import dumps
    except ImportError:

        def dumps(x):
            raise RuntimeError('for captcha support, simplejson has to '
                               'be installed.')


API_SERVER = 'http://api.recaptcha.net/'
SSL_API_SERVER = 'https://api-secure.recaptcha.net/'
VERIFY_SERVER = 'http://api-verify.recaptcha.net/verify'


def get_recaptcha_html(public_key=None, use_ssl=True, error=None,
                       translations=None):
    """Returns the recaptcha input HTML."""
    _ = translations and translations.ugettext or (lambda x: x)
    server = use_ssl and API_SERVER or SSL_API_SERVER
    options = dict(k=public_key.encode('utf-8'))
    if error is not None:
        options['error'] = unicode(error).encode('utf-8')
    query = urlencode(options)
    return Markup(u'''
    <script type="text/javascript">var RecaptchaOptions = %(options)s;</script>
    <script type="text/javascript" src="%(script_url)s"></script>
    <noscript>
      <div><iframe src="%(frame_url)s" height="300" width="500"></iframe></div>
      <div><textarea name="recaptcha_challenge_field"
                     rows="3" cols="40"></textarea>
      <input type="hidden" name="recaptcha_response_field"
             value="manual_challenge"></div>
    </noscript>
    ''' % dict(
        script_url='%schallenge?%s' % (server, query),
        frame_url='%snoscript?%s' % (server, query),
        options=dumps({
            'theme':    'clean',
            'custom_translations': {
                'visual_challenge': _("Get a visual challenge"),
                'audio_challenge': _("Get an audio challenge"),
                'refresh_btn': _("Get a new challenge"),
                'instructions_visual': _("Type the two words:"),
                'instructions_audio': _("Type what you hear:"),
                'help_btn': _("Help"),
                'play_again': _("Play sound again"),
                'cant_hear_this': _("Download sound as MP3"),
                'incorrect_try_again': _("Incorrect. Try again.")
            }
        })
    ))


def validate_recaptcha(private_key, challenge, response, remote_ip):
    """Validates the recaptcha.  If the validation fails
    a `RecaptchaValidationFailed` error is raised.
    """
    request = urllib2.Request(VERIFY_SERVER, data=urlencode({
        'privatekey':       private_key.encode('utf-8'),
        'remoteip':         remote_ip.encode('utf-8'),
        'challenge':        challenge.encode('utf-8'),
        'response':         response.encode('utf-8')
    }))
    response = urllib2.urlopen(request)
    rv = response.read().splitlines()
    response.close()
    if rv and rv[0] == 'true':
        return True
    if len(rv) > 1:
        error = rv[1]
        if error == 'invalid-site-public-key':
            raise RuntimeError('invalid public key for recaptcha set')
        if error == 'invalid-site-private-key':
            raise RuntimeError('invalid private key for recaptcha set')
        if error == 'invalid-referrer':
            raise RuntimeError('key not valid for the current domain')
    return False

########NEW FILE########
__FILENAME__ = redirects
# -*- coding: utf-8 -*-
"""
    fungiform.redirects
    ~~~~~~~~~~~~~~~~~~~

    Helps with redirects in WSGI applications.  Helps to avoid security
    problems.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import urllib
from itertools import chain
from urlparse import urlparse, urlsplit, urljoin
from cgi import parse_qsl as urldecode
from fnmatch import fnmatch


def get_current_url(environ, root_only=False):
    """A handy helper function that recreates the full URL for the current
    request or parts of it.  Here an example:

    >>> def create_environ(path, base_url):
    ...     scheme, netloc, script_root, _, _ = urlsplit(base_url)
    ...     _, _, path_info, qs, anchor = urlsplit(path)
    ...     return {'SCRIPT_NAME':      script_root,
    ...             'PATH_INFO':        path_info,
    ...             'QUERY_STRING':     qs,
    ...             'HTTP_HOST':        netloc,
    ...             'wsgi.url_scheme':  scheme}
    >>> env = create_environ("/?param=foo", "http://localhost/script")
    >>> get_current_url(env)
    'http://localhost/script/?param=foo'
    >>> get_current_url(env, root_only=True)
    'http://localhost/script/'

    :param environ: the WSGI environment to get the current URL from.
    :param root_only: set `True` if you only want the root URL.
    """
    tmp = [environ['wsgi.url_scheme'], '://', get_host(environ)]
    cat = tmp.append
    cat(urllib.quote(environ.get('SCRIPT_NAME', '').rstrip('/')))
    if root_only:
        cat('/')
    else:
        cat(urllib.quote('/' + environ.get('PATH_INFO', '').lstrip('/')))
        qs = environ.get('QUERY_STRING')
        if qs:
            cat('?' + qs)
    return ''.join(tmp)


def get_host(environ):
    """Return the real host for the given WSGI environment.  This takes care
    of the `X-Forwarded-Host` header.

    :param environ: the WSGI environment to get the host of.
    """
    if 'HTTP_X_FORWARDED_HOST' in environ:
        return environ['HTTP_X_FORWARDED_HOST']
    elif 'HTTP_HOST' in environ:
        return environ['HTTP_HOST']
    result = environ['SERVER_NAME']
    if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
       in (('https', '443'), ('http', '80')):
        result += ':' + environ['SERVER_PORT']
    return result


def get_redirect_target(environ, user_url=None, invalid_targets=(),
                        allowed_redirects=None):
    """Check the request and get the redirect target if possible.
    If not this function returns just `None`.  The return value of this
    function is suitable to be passed to `redirect`.
    """
    check_target = user_url or environ.get('HTTP_REFERER')

    # if there is no information in either the form data
    # or the wsgi environment about a jump target we have
    # to use the target url
    if not check_target:
        return

    # otherwise drop the leading slash
    check_target = check_target.lstrip('/')

    root_url = get_current_url(environ)
    root_parts = urlparse(root_url)

    check_parts = urlparse(urljoin(root_url, check_target))
    check_query = dict(urldecode(check_parts[4]))

    def url_equals(to_check):
        if to_check[:4] != check_parts[:4]:
            return False
        args = urldecode(to_check[4])
        for key, value in args:
            if check_query.get(key) != value:
                return False
        return True

    allowed_redirects = chain([get_host(environ)], allowed_redirects or ())

    # if the jump target is on a different server we probably have
    # a security problem and better try to use the target url.
    # except the host is whitelisted in the config
    if root_parts[:2] != check_parts[:2]:
        host = check_parts[1].split(':', 1)[0]
        for rule in allowed_redirects:
            if fnmatch(host, rule):
                break
        else:
            return

    # if the jump url is the same url as the current url we've had
    # a bad redirect before and use the target url to not create a
    # infinite redirect.
    if url_equals(urlparse(get_current_url(environ))):
        return

    # if the `check_target` is one of the invalid targets we also
    # fall back.
    for invalid in invalid_targets:
        if url_equals(urlparse(urljoin(root_url, invalid))):
            return

    return check_target

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
"""
    fungiform.tests.forms
    ~~~~~~~~~~~~~~~~~~~~~

    The unittests for the forms.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import unittest
from fungiform import forms


class FormTestCase(unittest.TestCase):

    def test_simple_form(self):
        class MyForm(forms.FormBase):
            username = forms.TextField()
            item_count = forms.IntegerField()
            is_active = forms.BooleanField()

        form = MyForm()
        form.validate({
            'username':     'foobar',
            'item_count':   '42',
            'is_active':    'a value'
        })

        self.assertEqual(form.raw_data['username'], 'foobar')
        self.assertEqual(form.raw_data['item_count'], '42')
        self.assertEqual(form.raw_data['is_active'], 'a value')

        self.assertEqual(form.data['username'], 'foobar')
        self.assertEqual(form.data['item_count'], 42)
        self.assertEqual(form.data['is_active'], True)

    def test_simple_nesting(self):
        class MyForm(forms.FormBase):
            ints = forms.Multiple(forms.IntegerField())
            strings = forms.CommaSeparated(forms.TextField())

        form = MyForm()
        form.validate({
            'ints.0':       '42',
            'ints.1':       '125',
            'ints.55':      '23',
            'strings':      'foo, bar, baz'
        })

        self.assertEqual(form.data['ints'], [42, 125, 23])
        self.assertEqual(form.data['strings'], 'foo bar baz'.split())

    def test_form_as_field(self):
        class AddressForm(forms.FormBase):
            street = forms.TextField()
            zipcode = forms.IntegerField()

        class MyForm(forms.FormBase):
            username = forms.TextField()
            addresses = forms.Multiple(AddressForm.as_field())

        form = MyForm()
        form.validate({
            'username':     'foobar',
            'addresses.0.street':   'Ici',
            'addresses.0.zipcode':  '11111',
            'addresses.2.street':   'Ailleurs',
            'addresses.2.zipcode':  '55555',
        })
        self.assertEqual(form.data, {
            'username': u'foobar',
            'addresses': [{'street': u'Ici', 'zipcode': 11111},
                          {'street': u'Ailleurs', 'zipcode': 55555}],
        })


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(FormTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
"""
    fungiform.tests.utils
    ~~~~~~~~~~~~~~~~~~~~~

    Unittests for the utilities.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import unittest
from fungiform import utils


class WebObLikeDict(object):

    def items(self):
        yield 'key1', 'value1'
        yield 'key1', 'value2'
        yield 'key1', 'value3'
        yield 'key2', 'awesome'


class WerkzeugLikeDict(object):

    def iterlists(self):
        yield 'key1', ['value1', 'value2', 'value3']
        yield 'key2', ['awesome']


class UtilsTestCase(unittest.TestCase):

    assertEq = unittest.TestCase.assertEqual

    def assertEqual(self, first, second, msg=None):
        # compare both type and value
        self.assertEq(first, second, msg=msg)
        self.assertEq(type(first), type(second))

    def test_decode_list_in_dict(self):
        d = utils.decode_form_data({
            'a_list':       ['foo', 'bar'],
            'a_list.42':    'baz',
            'a_list.23':    'meh'
        })
        self.assertEqual(d['a_list'], ['foo', 'bar', 'meh', 'baz'])

    def test_decode_form_data_multidicts(self):
        for dcls in WebObLikeDict, WerkzeugLikeDict:
            d = utils.decode_form_data(dcls())
            self.assertEqual(d['key1'], ['value1', 'value2', 'value3'])
            self.assertEqual(d['key2'], 'awesome')

    def test_escape(self):
        s1 = ('This string contains "<tags>" & "double-quotes", '
              'and single quotes "\'".')
        q1 = utils.Markup('This string contains &#34;&lt;tags&gt;&#34; &amp; '
                          '&#34;double-quotes&#34;, and single quotes '
                          '&#34;\'&#34;.')
        self.assertEqual(utils.escape(None), '')
        self.assertEqual(utils.escape(s1), q1)

        class HtmlAware(str):
            def __html__(self):
                return '<![CDATA[%s]]>' % self

        self.assertEqual(utils.escape(HtmlAware('xml & you')),
                                               '<![CDATA[xml & you]]>')
        self.assertRaises(TypeError, utils.escape)

    def test_make_name(self):
        self.assertEqual(utils.make_name(None, None), 'None')
        self.assertEqual(utils.make_name(None, ()), '()')
        self.assertEqual(utils.make_name((), None), '().None')
        self.assertEqual(utils.make_name(u'abc', u'def'), 'abc.def')
        self.assertEqual(utils.make_name(u'a\xef', u'd\xef'), u'a\xef.d\xef')
        self.assertEqual(utils.make_name('a\xef', 'd\xef'), 'a\xef.d\xef')
        self.assertRaises(UnicodeDecodeError, utils.make_name, '\xef', u'ef')

    def test_fill_dict(self):
        dic1 = {'foo': 'nothing', 'bar': 'nothing'}
        dic2 = dict(baz=u'moo', **dic1)
        self.assertEqual(utils.fill_dict(dic1), dic1)
        self.assertEqual(utils.fill_dict(None, **dic1), dic1)
        self.assertEqual(utils.fill_dict(dic1, bar=u'moo'), dic1)
        self.assertEqual(utils.fill_dict(dic1, baz=u'moo'), dic2)

    def test_set_fields(self):
        Object = type('Object', (), {})
        an_object = Object()
        dic1 = {'foo': 'Foo', 'bar': u'Bar'}
        utils.set_fields(an_object, dic1)
        self.assertEqual(an_object.__dict__, {})
        self.assertRaises(AttributeError, utils.set_fields,
                          an_object, dic1, 'bar')
        (an_object.foo, an_object.bar) = (None, None)
        self.assertEqual((an_object.foo, an_object.bar), (None, None))
        utils.set_fields(an_object, dic1, 'bar')
        self.assertEqual((an_object.foo, an_object.bar), (None, 'Bar'))
        utils.set_fields(an_object, dic1, *dic1.keys())
        self.assertEqual((an_object.foo, an_object.bar), ('Foo', 'Bar'))
        self.assertEqual(an_object.__dict__, dic1)


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(UtilsTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-
"""
    fungiform.tests.widgets
    ~~~~~~~~~~~~~~~~~~~~~~~

    The unittests for the widgets.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import unittest
from fungiform import forms, widgets


class WidgetTestCase(unittest.TestCase):

    def test_multichoice(self):
        class MyForm(forms.FormBase):
            mc = forms.MultiChoiceField('Foo',
                                        choices=[(1, 'One'), (2, 'Two')],
                                        widget=widgets.CheckboxGroup)
        self.assertEqual(
            u'<form action="" method="post">'
            u'<dl class="mapping">'
              u'<dt><label for="f_mc">Foo</label></dt>'
              u'<dd>'
                u'<ul id="f_mc" class="choicegroup">'
                  u'<li><input type="checkbox" id="f_mc_1" value="1" '
                        u'name="mc"> <label for="f_mc_1">One</label></li>'
                  u'<li><input type="checkbox" id="f_mc_2" value="2" '
                        u'name="mc"> <label for="f_mc_2">Two</label></li>'
                u'</ul>'
              u'</dd>'
            u'</dl>'
            u'<div class="actions"><input type="submit" value="Submit"></div>'
            u'</form>', MyForm().as_widget().render())

    def test_form_as_field(self):
        class AddressForm(forms.FormBase):
            street = forms.TextField()
            zipcode = forms.IntegerField()

        class MyForm(forms.FormBase):
            username = forms.TextField()
            addresses = forms.Multiple(AddressForm.as_field())

        form = MyForm()
        self.assertEqual(
            u'<form action="" method="post">'
              u'<dl class="mapping">'
                u'<dd><input type="text" id="f_username" value="" '
                           u'name="username"></dd>'
                u'<dd>'
                  u'<ul class="multiple-items">'
                    u'<li><dl class="mapping">'
                      u'<dd><input type="text" id="f_addresses__0__street" '
                            u'value="" name="addresses.0.street"></dd>'
                      u'<dd><input type="text" id="f_addresses__0__zipcode" '
                            u'value="" name="addresses.0.zipcode"></dd>'
                    u'</dl></li>'
                  u'</ul>'
                u'</dd>'
              u'</dl>'
              u'<div class="actions">'
                u'<input type="submit" value="Submit"></div>'
            u'</form>', form.as_widget().render())

        form.validate({
            'username':     'foobar',
            'addresses.0.street':   'Ici',
            'addresses.0.zipcode':  '11111',
            'addresses.2.street':   'Ailleurs',
            'addresses.2.zipcode':  '55555',
        })
        self.assertEqual(
            u'<form action="" method="post">'
              u'<dl class="mapping">'
                u'<dd><input type="text" id="f_username" value="foobar" '
                           u'name="username"></dd>'
                u'<dd>'
                  u'<ul class="multiple-items">'
                    u'<li><dl class="mapping">'
                      u'<dd><input type="text" id="f_addresses__0__street" '
                            u'value="Ici" name="addresses.0.street"></dd>'
                      u'<dd><input type="text" id="f_addresses__0__zipcode" '
                            u'value="11111" name="addresses.0.zipcode"></dd>'
                    u'</dl></li>'
                    u'<li><dl class="mapping">'
                      u'<dd><input type="text" id="f_addresses__1__street" '
                            u'value="Ailleurs" name="addresses.1.street"></dd>'
                      u'<dd><input type="text" id="f_addresses__1__zipcode" '
                            u'value="55555" name="addresses.1.zipcode"></dd>'
                    u'</dl></li>'
                    u'<li><dl class="mapping">'
                      u'<dd><input type="text" id="f_addresses__2__street" '
                            u'value="" name="addresses.2.street"></dd>'
                      u'<dd><input type="text" id="f_addresses__2__zipcode" '
                            u'value="" name="addresses.2.zipcode"></dd>'
                    u'</dl></li>'
                  u'</ul>'
                u'</dd>'
              u'</dl>'
              u'<div class="actions">'
                u'<input type="submit" value="Submit"></div>'
            u'</form>', form.as_widget().render())
        self.assertEqual(
            u'<input type="text" id="f_username" value="foobar" '
            u'name="username">', form.as_widget()['username']())
        self.assertEqual(
            u'<input type="text" id="f_addresses__0__zipcode" value="11111" '
            u'name="addresses.0.zipcode">',
            form.as_widget()['addresses'][0]['zipcode']())
        self.assertEqual(
            u'<input type="text" id="f_addresses__42__street" value="" '
            u'name="addresses.42.street">',
            form.as_widget()['addresses'][42]['street']())


def suite():
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(WidgetTestCase))
    return suite


if __name__ == '__main__':
    unittest.main(defaultTest='suite')

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
"""
    fungiform.utils
    ~~~~~~~~~~~~~~~

    Various utilities.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
import re
import urllib
from copy import deepcopy
from itertools import izip, imap
from datetime import datetime, date
from time import strptime

DATE_FORMATS = ['%m/%d/%Y', '%d/%m/%Y', '%Y%m%d', '%d. %m. %Y',
                '%m/%d/%y', '%d/%m/%y', '%d%m%y', '%m%d%y', '%y%m%d']
TIME_FORMATS = ['%H:%M', '%H:%M:%S', '%I:%M %p', '%I:%M:%S %p']
_missing = object()


def get_current_url(environ):
    """A handy helper function that recreates the full URL for the current
    request.

    :param environ: the WSGI environment to get the current URL from.
    """
    tmp = [environ['wsgi.url_scheme'], '://', get_host(environ)]
    cat = tmp.append
    cat(urllib.quote(environ.get('SCRIPT_NAME', '').rstrip('/')))
    cat(urllib.quote('/' + environ.get('PATH_INFO', '').lstrip('/')))
    qs = environ.get('QUERY_STRING')
    if qs:
        cat('?' + qs)
    return ''.join(tmp)


def get_host(environ):
    """Return the real host for the given WSGI environment.  This takes care
    of the `X-Forwarded-Host` header.

    :param environ: the WSGI environment to get the host of.
    """
    if 'HTTP_X_FORWARDED_HOST' in environ:
        return environ['HTTP_X_FORWARDED_HOST']
    elif 'HTTP_HOST' in environ:
        return environ['HTTP_HOST']
    result = environ['SERVER_NAME']
    if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
       in (('https', '443'), ('http', '80')):
        result += ':' + environ['SERVER_PORT']
    return result


def _force_list(value):
    """If the value is not a list, make it one."""
    if value is None:
        return []
    try:
        if isinstance(value, basestring):
            raise TypeError()
        return list(value)
    except TypeError:
        return [value]


def _to_list(value):
    """Similar to `_force_list` but always succeeds and never drops data."""
    if value is None:
        return []
    if isinstance(value, basestring):
        return [value]
    try:
        return list(value)
    except TypeError:
        return [value]


def _force_dict(value):
    """If the value is not a dict, raise an exception."""
    if value is None or not isinstance(value, dict):
        return {}
    return value


def _to_string(value):
    """Convert a value to unicode, None means empty string."""
    if value is None:
        return u''
    return unicode(value)


def _value_matches_choice(value, choice):
    """Checks if a given value matches a choice."""
    # this algorithm is also implemented in `MultiChoiceField.convert`
    # for better scaling with multiple items.  If it's changed here, it
    # must be changed for the multi choice field too.
    return choice == value or _to_string(choice) == _to_string(value)


def _make_widget(field, name, value, errors):
    """Shortcut for widget creation."""
    return field.widget(field, name, value, errors)


def soft_unicode(s):
    """Make something unicode if it's not a string or respond to `__html__`"""
    if hasattr(s, '__html__'):
        return s
    elif not isinstance(s, basestring):
        return unicode(s)
    return s


def escape(s):
    """Replace special characters "&", '"', "<" and ">" to HTML-safe sequences.

    There is a special handling for `None` which escapes to an empty string.

    :param s: the string to escape.
    :param quote: set to true to also escape double quotes.
    """
    if s is None:
        return ''
    elif hasattr(s, '__html__'):
        return s.__html__()
    elif not isinstance(s, basestring):
        s = unicode(s)
    return Markup(s.replace(u'&', u'&amp;').replace(u'<', u'&lt;')
                   .replace(u'>', u'&gt;').replace(u'"', u'&#34;'))


def make_name(parent, child):
    """Joins a name."""
    if parent is None:
        result = child
    else:
        result = '%s.%s' % (parent, child)

    # try to return a ascii only bytestring if possible
    try:
        return str(result)
    except UnicodeError:
        return unicode(result)


def fill_dict(_dict, **kwargs):
    """A helper to fill the dict passed with the items passed as keyword
    arguments if they are not yet in the dict.  If the dict passed was
    `None` a new dict is created and returned.

    This can be used to prepopulate initial dicts in overriden constructors:

        class MyForm(forms.Form):
            foo = forms.TextField()
            bar = forms.TextField()

            def __init__(self, initial=None):
                forms.Form.__init__(self, forms.fill_dict(initial,
                    foo="nothing",
                    bar="nothing"
                ))
    """
    if _dict is None:
        return kwargs
    for key, value in kwargs.iteritems():
        if key not in _dict:
            _dict[key] = value
    return _dict


def set_fields(obj, data, *fields):
    """Set all the fields on obj with data if changed."""
    for field in fields:
        value = data[field]
        if getattr(obj, field) != value:
            setattr(obj, field, value)


def _iter_key_grouped(iterable):
    """A helper that groups an ``(key, value)`` iterable by key and
    accumultates the values in a list.  Used to support webob like dicts in
    the form data decoder.
    """
    last_key = None
    buffered = []
    for key, value in sorted(iterable, key=lambda x: x[0]):
        if key != last_key and buffered:
            yield last_key, buffered
            buffered = []
        last_key = key
        buffered.append(value)
    if buffered:
        yield last_key, buffered


def decode_form_data(data):
    """Decodes the flat dictionary d into a nested structure.

    >>> decode_form_data({'foo': 'bar'})
    {'foo': 'bar'}
    >>> decode_form_data({'foo.0': 'bar', 'foo.1': 'baz'})
    {'foo': ['bar', 'baz']}
    >>> data = decode_form_data({'foo.bar': '1', 'foo.baz': '2'})
    >>> data == {'foo': {'bar': '1', 'baz': '2'}}
    True

    More complex mappings work too:

    >>> decode_form_data({'foo.bar.0': 'baz', 'foo.bar.1': 'buzz'})
    {'foo': {'bar': ['baz', 'buzz']}}
    >>> decode_form_data({'foo.0.bar': '23', 'foo.1.baz': '42'})
    {'foo': [{'bar': '23'}, {'baz': '42'}]}
    >>> decode_form_data({'foo.0.0': '23', 'foo.0.1': '42'})
    {'foo': [['23', '42']]}
    >>> decode_form_data({'foo': ['23', '42']})
    {'foo': ['23', '42']}

    _missing items in lists are ignored for convenience reasons:

    >>> decode_form_data({'foo.42': 'a', 'foo.82': 'b'})
    {'foo': ['a', 'b']}

    This can be used for help client side DOM processing (inserting and
    deleting rows in dynamic forms).

    It also supports werkzeug's and django's multi dicts (or a dict like
    object that provides an `iterlists`):

    >>> class MultiDict(dict):
    ...     def iterlists(self):
    ...         for key, values in dict.iteritems(self):
    ...             yield key, list(values)
    >>> decode_form_data(MultiDict({"foo": ['1', '2']}))
    {'foo': ['1', '2']}
    >>> decode_form_data(MultiDict({"foo.0": '1', "foo.1": '2'}))
    {'foo': ['1', '2']}

    Those two submission ways can also be used combined:

    >>> decode_form_data(MultiDict({"foo": ['1'], "foo.0": '2', "foo.1": '3'}))
    {'foo': ['1', '2', '3']}

    This function will never raise exceptions except for argument errors
    but the recovery behavior for invalid form data is undefined.
    """
    list_marker = object()
    value_marker = object()

    if hasattr(data, 'iterlists'):
        listiter = data.iterlists()
    else:
        if type(data) is dict:
            listiter = data.iteritems()
        else:
            listiter = _iter_key_grouped(data.items())
        listiter = ((k, not isinstance(v, (list, tuple)) and [v] or v)
                    for k, v in listiter)

    def _split_key(name):
        result = name.split('.')
        for idx, part in enumerate(result):
            if part.isdigit():
                result[idx] = int(part)
        return result

    def _enter_container(container, key):
        if key not in container:
            return container.setdefault(key, {list_marker: False})
        return container[key]

    def _convert(container):
        if value_marker in container:
            force_list = False
            values = container.pop(value_marker)
            if container.pop(list_marker):
                force_list = True
                values.extend(_convert(x[1]) for x in
                              sorted(container.items()))
            if not force_list and len(values) == 1:
                values = values[0]
            return values
        elif container.pop(list_marker):
            return [_convert(x[1]) for x in sorted(container.items())]
        return dict((k, _convert(v)) for k, v in container.iteritems())

    result = {list_marker: False}
    for key, values in listiter:
        parts = _split_key(key)
        if not parts:
            continue
        container = result
        for part in parts:
            last_container = container
            container = _enter_container(container, part)
            last_container[list_marker] = isinstance(part, (int, long))
        container[value_marker] = values

    return _convert(result)


class Markup(unicode):
    r"""Marks a string as being safe for inclusion in HTML/XML output without
    needing to be escaped.  This implements the `__html__` interface a couple
    of frameworks and web applications use.  :class:`Markup` is a direct
    subclass of `unicode` and provides all the methods of `unicode` just that
    it escapes arguments passed and always returns `Markup`.

    The constructor of the :class:`Markup` class can be used for three
    different things:  When passed an unicode object it's assumed to be safe,
    when passed an object with an HTML representation (has an `__html__`
    method) that representation is used, otherwise the object passed is
    converted into a unicode string and then assumed to be safe:

    >>> Markup("Hello <em>World</em>!")
    u'Hello <em>World</em>!'
    >>> class Foo(object):
    ...  def __html__(self):
    ...   return '<a href="#">foo</a>'
    ...
    >>> Markup(Foo())
    u'<a href="#">foo</a>'

    """
    __slots__ = ()

    def __new__(cls, base=u'', encoding=None, errors='strict'):
        if hasattr(base, '__html__'):
            base = base.__html__()
        if encoding is None:
            return unicode.__new__(cls, base)
        return unicode.__new__(cls, base, encoding, errors)

    def __html__(self):
        return self

    def __add__(self, other):
        if hasattr(other, '__html__') or isinstance(other, basestring):
            return self.__class__(unicode(self) + unicode(escape(other)))
        return NotImplemented

    def __radd__(self, other):
        if hasattr(other, '__html__') or isinstance(other, basestring):
            return self.__class__(unicode(escape(other)) + unicode(self))
        return NotImplemented

    def __mul__(self, num):
        if isinstance(num, (int, long)):
            return self.__class__(unicode.__mul__(self, num))
        return NotImplemented
    __rmul__ = __mul__

    def __mod__(self, arg):
        if isinstance(arg, tuple):
            arg = tuple(imap(_MarkupEscapeHelper, arg))
        else:
            arg = _MarkupEscapeHelper(arg)
        return self.__class__(unicode.__mod__(self, arg))

    def join(self, seq):
        return self.__class__(unicode.join(self, imap(escape, seq)))
    join.__doc__ = unicode.join.__doc__

    def split(self, *args, **kwargs):
        return map(self.__class__, unicode.split(self, *args, **kwargs))
    split.__doc__ = unicode.split.__doc__

    def rsplit(self, *args, **kwargs):
        return map(self.__class__, unicode.rsplit(self, *args, **kwargs))
    rsplit.__doc__ = unicode.rsplit.__doc__

    def splitlines(self, *args, **kwargs):
        return map(self.__class__, unicode.splitlines(self, *args, **kwargs))
    splitlines.__doc__ = unicode.splitlines.__doc__

    def make_wrapper(name):
        orig = getattr(unicode, name)

        def func(self, *args, **kwargs):
            args = _escape_argspec(list(args), enumerate(args))
            _escape_argspec(kwargs, kwargs.iteritems())
            return self.__class__(orig(self, *args, **kwargs))
        func.__name__ = orig.__name__
        func.__doc__ = orig.__doc__
        return func

    for method in '__getitem__', 'capitalize', \
                  'title', 'lower', 'upper', 'replace', 'ljust', \
                  'rjust', 'lstrip', 'rstrip', 'center', 'strip', \
                  'translate', 'expandtabs', 'swapcase', 'zfill':
        locals()[method] = make_wrapper(method)

    # new in python 2.5
    if hasattr(unicode, 'partition'):
        partition = make_wrapper('partition'),
        rpartition = make_wrapper('rpartition')

    # new in python 2.6
    if hasattr(unicode, 'format'):
        format = make_wrapper('format')

    del method, make_wrapper


def _escape_argspec(obj, iterable):
    """Helper for various string-wrapped functions."""
    for key, value in iterable:
        if hasattr(value, '__html__') or isinstance(value, basestring):
            obj[key] = escape(value)
    return obj


class _MarkupEscapeHelper(object):
    """Helper for Markup.__mod__"""

    def __init__(self, obj):
        self.obj = obj

    __getitem__ = lambda s, x: _MarkupEscapeHelper(s.obj[x])
    __str__ = lambda s: str(escape(s.obj))
    __unicode__ = lambda s: unicode(escape(s.obj))
    __repr__ = lambda s: str(escape(repr(s.obj)))
    __int__ = lambda s: int(s.obj)
    __float__ = lambda s: float(s.obj)


class HTMLBuilder(object):
    """Helper object for HTML generation.

    Per default there are two instances of that class.  The `html` one, and
    the `xhtml` one for those two dialects.  The class uses keyword parameters
    and positional parameters to generate small snippets of HTML.

    Keyword parameters are converted to XML/SGML attributes, positional
    arguments are used as children.  Because Python accepts positional
    arguments before keyword arguments it's a good idea to use a list with the
    star-syntax for some children:

    >>> html.p(class_='foo', *[html.a('foo', href='foo.html'), ' ',
    ...                        html.a('bar', href='bar.html')])
    u'<p class="foo"><a href="foo.html">foo</a> <a href="bar.html">bar</a></p>'

    This class works around some browser limitations and can not be used for
    arbitrary SGML/XML generation.  For that purpose lxml and similar
    libraries exist.

    Calling the builder escapes the string passed:

    >>> html.p(html("<foo>"))
    u'<p>&lt;foo&gt;</p>'
    """
    # this class is taken from werkzeug.utils.  Please modify both in werkzeug
    # and copy over here if you fix bugs.

    from htmlentitydefs import name2codepoint
    _entity_re = re.compile(r'&([^;]+);')
    _entities = name2codepoint.copy()
    _entities['apos'] = 39
    _empty_elements = set([
        'area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'img',
        'input', 'isindex', 'link', 'meta', 'param'
    ])
    _boolean_attributes = set([
        'selected', 'checked', 'compact', 'declare', 'defer', 'disabled',
        'ismap', 'multiple', 'nohref', 'noresize', 'noshade', 'nowrap'
    ])
    _plaintext_elements = set(['textarea'])
    _c_like_cdata = set(['script', 'style'])
    del name2codepoint

    def __init__(self, dialect):
        self._dialect = dialect

    def __call__(self, s):
        return escape(s)

    def __getattr__(self, tag):
        if tag[:2] == '__':
            raise AttributeError(tag)

        def proxy(*children, **arguments):
            buffer = ['<' + tag]
            write = buffer.append
            for key, value in arguments.iteritems():
                if value is None:
                    continue
                if key.endswith('_'):
                    key = key[:-1]
                if key in self._boolean_attributes:
                    if not value:
                        continue
                    value = self._dialect == 'xhtml' and '="%s"' % key or ''
                else:
                    value = '="%s"' % escape(value)
                write(' ' + key + value)
            if not children and tag in self._empty_elements:
                write(self._dialect == 'xhtml' and ' />' or '>')
                return Markup(u''.join(buffer))
            write('>')
            if tag in self._c_like_cdata:
                children_as_string = u''.join(unicode(x) for x in children
                                              if x is not None)
                if self._dialect == 'xhtml':
                    children_as_string = \
                        '/*<![CDATA[*/%s/*]]>*/' % children_as_string
            else:
                children_as_string = Markup(u''.join(
                    escape(x) for x in children if x is not None))
            buffer.extend((children_as_string, '</%s>' % tag))
            return Markup(u''.join(buffer))
        return proxy

    def __repr__(self):
        return '<%s for %r>' % (
            self.__class__.__name__,
            self._dialect
        )


html = HTMLBuilder('html')
xhtml = HTMLBuilder('xhtml')


class OrderedDict(dict):
    """Simple ordered dict implementation.

    It's a dict subclass and provides some list functions.  The implementation
    of this class is inspired by the implementation of Babel but incorporates
    some ideas from the `ordereddict`_ and Django's ordered dict.

    The constructor and `update()` both accept iterables of tuples as well as
    mappings:

    >>> d = OrderedDict([('a', 'b'), ('c', 'd')])
    >>> d.update({'foo': 'bar'})
    >>> d
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])

    Keep in mind that when updating from dict-literals the order is not
    preserved as these dicts are unsorted!

    You can copy an OrderedDict like a dict by using the constructor,
    `copy.copy` or the `copy` method and make deep copies with `copy.deepcopy`:

    >>> from copy import copy, deepcopy
    >>> copy(d)
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> d.copy()
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> OrderedDict(d)
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> d['spam'] = []
    >>> d2 = deepcopy(d)
    >>> d2['spam'].append('eggs')
    >>> d
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])
    >>> d2
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', ['eggs'])])

    All iteration methods as well as `keys`, `values` and `items` return
    the values ordered by the the time the key-value pair is inserted:

    >>> d.keys()
    ['a', 'c', 'foo', 'spam']
    >>> d.values()
    ['b', 'd', 'bar', []]
    >>> d.items()
    [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]
    >>> list(d.iterkeys())
    ['a', 'c', 'foo', 'spam']
    >>> list(d.itervalues())
    ['b', 'd', 'bar', []]
    >>> list(d.iteritems())
    [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]

    Index based lookup is supported too by `byindex` which returns the
    key/value pair for an index:

    >>> d.byindex(2)
    ('foo', 'bar')

    You can reverse the OrderedDict as well:

    >>> d.reverse()
    >>> d
    OrderedDict([('spam', []), ('foo', 'bar'), ('c', 'd'), ('a', 'b')])

    And sort it like a list:

    >>> d.sort(key=lambda x: x[0].lower())
    >>> d
    OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])

    For performance reasons the ordering is not taken into account when
    comparing two ordered dicts.

    .. _ordereddict: http://www.xs4all.nl/~anthon/Python/ordereddict/
    """

    def __init__(self, *args, **kwargs):
        dict.__init__(self)
        self._keys = []
        self.update(*args, **kwargs)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._keys.remove(key)

    def __setitem__(self, key, item):
        if key not in self:
            self._keys.append(key)
        dict.__setitem__(self, key, item)

    def __deepcopy__(self, memo):
        d = memo.get(id(self), _missing)
        memo[id(self)] = d = self.__class__()
        dict.__init__(d, deepcopy(self.items(), memo))
        d._keys = self._keys[:]
        return d

    def __reduce__(self):
        return type(self), self.items()

    def __reversed__(self):
        return reversed(self._keys)

    @classmethod
    def fromkeys(cls, iterable, default=None):
        return cls((key, default) for key in iterable)

    def clear(self):
        del self._keys[:]
        dict.clear(self)

    def move(self, key, index):
        self._keys.remove(key)
        self._keys.insert(index, key)

    def copy(self):
        return self.__class__(self)

    def items(self):
        return zip(self._keys, self.values())

    def iteritems(self):
        return izip(self._keys, self.itervalues())

    def keys(self):
        return self._keys[:]

    def iterkeys(self):
        return iter(self._keys)

    def pop(self, key, default=_missing):
        if default is _missing:
            return dict.pop(self, key)
        elif key not in self:
            return default
        self._keys.remove(key)
        return dict.pop(self, key, default)

    def popitem(self, key):
        self._keys.remove(key)
        return dict.popitem(self, key)

    def setdefault(self, key, default=None):
        if key not in self:
            self._keys.append(key)
        dict.setdefault(self, key, default)

    def update(self, *args, **kwargs):
        sources = []
        if len(args) == 1:
            if hasattr(args[0], 'iteritems'):
                sources.append(args[0].iteritems())
            else:
                sources.append(iter(args[0]))
        elif args:
            raise TypeError('expected at most one positional argument')
        if kwargs:
            sources.append(kwargs.iteritems())
        for iterable in sources:
            for key, val in iterable:
                self[key] = val

    def values(self):
        return map(self.get, self._keys)

    def itervalues(self):
        return imap(self.get, self._keys)

    def index(self, item):
        return self._keys.index(item)

    def byindex(self, item):
        key = self._keys[item]
        return (key, dict.__getitem__(self, key))

    def reverse(self):
        self._keys.reverse()

    def sort(self, cmp=None, key=None, reverse=False):
        if key is not None:
            self._keys.sort(key=lambda k: key((k, self[k])))
        elif cmp is not None:
            self._keys.sort(lambda a, b: cmp((a, self[a]), (b, self[b])))
        else:
            self._keys.sort()
        if reverse:
            self._keys.reverse()

    def __repr__(self):
        return '%s(%r)' % (type(self).__name__, self.items())

    __copy__ = copy
    __iter__ = iterkeys


# Date and Time

try:
    from pytz import timezone, UTC
except ImportError, exc:

    # Naive functions, if the pytz module cannot be imported.

    def to_utc(datetime, tzinfo=None):
        if tzinfo is None:
            return datetime
        raise exc
    to_timezone = to_utc

    def get_timezone(tzinfo=None):
        if tzinfo is None:
            return None
        if isinstance(tzinfo, basestring):
            raise exc
        # Return the object itself: it's probably a tzinfo object
        return tzinfo

else:

    def to_utc(datetime, tzinfo=UTC):
        """Convert a datetime object to UTC and drop tzinfo."""
        if datetime.tzinfo is None:
            datetime = tzinfo.localize(datetime)
        return datetime.astimezone(UTC).replace(tzinfo=None)

    def to_timezone(datetime, tzinfo=UTC):
        """Convert a datetime object to the local timezone."""
        if datetime.tzinfo is None:
            datetime = datetime.replace(tzinfo=UTC)
        return tzinfo.normalize(datetime.astimezone(tzinfo))

    def get_timezone(tzinfo=None):
        """Return the timezone for the given identifier."""
        if tzinfo is None:
            return UTC
        if isinstance(tzinfo, basestring):
            return timezone(tzinfo)
        # Return the object itself: it's probably a tzinfo object
        return tzinfo


def format_system_datetime(datetime=None, tzinfo=None):
    """Formats a system datetime.

    (Format: YYYY-MM-DD hh:mm and in the user timezone
    if tzinfo is provided)
    """
    if tzinfo:
        datetime = to_timezone(datetime, tzinfo)
    return u'%d-%02d-%02d %02d:%02d' % (
        datetime.year,
        datetime.month,
        datetime.day,
        datetime.hour,
        datetime.minute
    )


def format_system_date(date=None):
    """Formats a system date.

    (Format: YYYY-MM-DD)
    """
    return u'%d-%02d-%02d' % (date.year, date.month, date.day)


def parse_datetime(string, tzinfo=None, date_formats=None, time_formats=None):
    """Parses a string into a datetime object.  Per default a conversion
    from the local timezone to UTC is performed but returned as naive
    datetime object (that is tzinfo being None).  If tzinfo is not used,
    the string is expected in UTC.

    The return value is **always** a naive datetime object in UTC.  This
    function should be considered of a lenient counterpart of
    `format_system_datetime`.
    """
    # shortcut: string as None or "now" returns the current timestamp.
    if string is None or string.lower() in ('now',):
        return datetime.utcnow().replace(microsecond=0)

    def convert(format):
        """Helper that parses the string and convers the timezone."""
        rv = datetime(*strptime(string, format)[:7])
        if tzinfo:
            rv = to_utc(rv, tzinfo)
        return rv.replace(microsecond=0)

    # first of all try the following format because this is the format
    # Texpress will output by default for any date time string in the
    # administration panel.
    try:
        return convert(u'%Y-%m-%d %H:%M')
    except ValueError:
        pass

    if not time_formats:
        time_formats = TIME_FORMATS
    # no go with time only, and current day
    for fmt in time_formats:
        try:
            val = convert(fmt)
        except ValueError:
            continue
        return to_utc(datetime.utcnow().replace(hour=val.hour,
                      minute=val.minute, second=val.second, microsecond=0),
                      tzinfo=tzinfo)

    # now try various types of date + time strings
    def combined():
        for t_fmt in time_formats:
            for d_fmt in date_formats:
                yield t_fmt + ' ' + d_fmt
                yield d_fmt + ' ' + t_fmt

    if not date_formats:
        date_formats = DATE_FORMATS
    for fmt in combined():
        try:
            return convert(fmt)
        except ValueError:
            pass

    raise ValueError('invalid date format')


def parse_date(string, date_formats=None):
    """Parses a string into a date object."""
    # shortcut: string as None or "today" returns the current date.
    if string is None or string.lower() in ('today',):
        return date.today()

    def convert(format):
        """Helper that parses the string."""
        return date(*strptime(string, format)[:3])

    # first of all try the ISO 8601 format.
    try:
        return convert(u'%Y-%m-%d')
    except ValueError:
        pass

    # now try various types of date
    for fmt in date_formats or DATE_FORMATS:
        try:
            return convert(fmt)
        except ValueError:
            pass

    raise ValueError('invalid date format')

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-
"""
    fungiform.widgets
    ~~~~~~~~~~~~~~~~~

    The widgets.

    :copyright: (c) 2010 by the Fungiform Team.
    :license: BSD, see LICENSE for more details.
"""
from itertools import chain

from fungiform.utils import make_name, _force_dict, _make_widget,\
                            _value_matches_choice, _force_list,\
                            _to_string, _to_list, Markup, soft_unicode
from fungiform.recaptcha import get_recaptcha_html


def _add_class(attrs, classname):
    """Adds a class to an attribute dict."""
    attrs['class'] = u' '.join([c for c in [attrs.pop('class', u''),
                                            attrs.pop('class_', u'')] if c] +
                               [classname])


def _iter_choices(choices):
    """Iterate over choices."""
    if choices is not None:
        for choice in choices:
            if not isinstance(choice, tuple):
                choice = (choice, choice)
            yield choice


def _is_choice_selected(field, value, choice):
    """Checks if a choice is selected.  If the field is a multi select
    field it's checked if the choice is in the passed iterable of values,
    otherwise it's checked if the value matches the choice.
    """
    if field.multiple_choices:
        for value in value:
            if _value_matches_choice(value, choice):
                return True
        return False
    return _value_matches_choice(value, choice)


class _Renderable(object):
    """Mixin for renderable HTML objects."""

    def render(self):
        return u''

    def __call__(self, *args, **kwargs):
        return self.render(*args, **kwargs)


class Widget(_Renderable):
    """Baseclass for all widgets.  All widgets share a common interface
    that can be used from within templates.

    Take this form as an example:

    >>> from fungiform.forms import FormBase, TextField, MultiChoiceField
    >>> class LoginForm(FormBase):
    ...     username = TextField(required=True)
    ...     password = TextField(widget=PasswordInput)
    ...     flags = MultiChoiceField(choices=[1, 2, 3])
    ...
    >>> form = LoginForm()
    >>> form.validate({'username': '', 'password': '',
    ...                'flags': [1, 3]})
    False
    >>> widget = form.as_widget()

    You can get the subwidgets by using the normal indexing operators:

    >>> username = widget['username']
    >>> password = widget['password']

    To render a widget you can usually invoke the `render()` method.  All
    keyword parameters are used as HTML attribute in the resulting tag.
    You can also call the widget itself (``username()`` instead of
    ``username.render()``) which does the same if there are no errors for
    the field but adds the default error list after the widget if there
    are errors.

    Widgets have some public attributes:

    `errors`

        gives the list of errors:

        >>> username.errors
        [u'This field is required.']

        This error list is printable:

        >>> print username.errors()
        <ul class="errors"><li>This field is required.</li></ul>

        Like any other sequence that yields list items it provides
        `as_ul` and `as_ol` methods:

        >>> print username.errors.as_ul()
        <ul><li>This field is required.</li></ul>

        Keep in mind that ``widget.errors()`` is equivalent to
        ``widget.errors.as_ul(class_='errors', hide_empty=True)``.

    `value`

        returns the value of the widget as primitive.  For basic
        widgets this is always a string, for widgets with subwidgets or
        widgets with multiple values a dict or a list:

        >>> username.value
        u''
        >>> widget['flags'].value
        [u'1', u'3']

    `name` gives you the name of the field for form submissions:

        >>> username.name
        'username'

        Please keep in mind that the name is not always that obvious.  This
        form system supports nested form fields so it's a good idea to
        always use the name attribute.

    `id`

        gives you the default domain for the widget.  This is either none
        if there is no idea for the field or `f_` + the field name with
        underscores instead of dots:

        >>> username.id
        'f_username'

    `all_errors`

        like `errors` but also contains the errors of child widgets.
    """

    disable_dt = False

    def __init__(self, field, name, value, all_errors):
        self._form = field.form
        self._field = field
        self._value = value
        self._all_errors = all_errors
        self.name = name

    @property
    def empty_as_item(self):
        """Works like the method on the field just for the widget plus
        the bound value.
        """
        return self._field.empty_as_item(self.value)

    def hidden(self):
        """Return one or multiple hidden fields for the current value.  This
        also handles subwidgets.  This is useful for transparent form data
        passing.
        """
        fields = []

        def _add_field(name, value):
            html = self._field.form.html_builder
            fields.append(html.input(type='hidden', name=name, value=value))

        def _to_hidden(value, name):
            if isinstance(value, list):
                for idx, value in enumerate(value):
                    _to_hidden(value, make_name(name, idx))
            elif isinstance(value, dict):
                for key, value in value.iteritems():
                    _to_hidden(value, make_name(name, key))
            else:
                _add_field(name, value)

        _to_hidden(self.value, self.name)
        return u'\n'.join(fields)

    @property
    def localname(self):
        """The local name of the field."""
        return self.name.rsplit('.', 1)[-1]

    @property
    def id(self):
        """The proposed id for this widget."""
        if self.name is not None:
            return 'f_' + self.name.replace('.', '__')

    @property
    def value(self):
        """The primitive value for this widget."""
        return self._field.to_primitive(self._value)

    @property
    def label(self):
        """The label for the widget."""
        if self._field.label is not None:
            return Label(self._field, soft_unicode(self._field.label), self.id)

    @property
    def help_text(self):
        """The help text of the widget."""
        if self._field.help_text is not None:
            return unicode(self._field.help_text)

    @property
    def errors(self):
        """The direct errors of this widget."""
        if self.name in self._all_errors:
            return self._all_errors[self.name]
        return ErrorList(self._field.form)

    @property
    def all_errors(self):
        """The current errors and the errors of all child widgets."""
        items = sorted(self._all_errors.items())
        if self.name is None:
            return ErrorList(self._field.form,
                             chain(*(item[1] for item in items)))
        result = ErrorList(self._field.form)
        for key, value in items:
            if key == self.name or (key is not None and
                                    key.startswith(self.name + '.')):
                result.extend(value)
        return result

    @property
    def default_display_errors(self):
        """The errors that should be displayed."""
        return self.errors

    def as_dd(self, **attrs):
        """Return a dt/dd item."""
        html = self._field.form.html_builder
        rv = []
        if not self.disable_dt:
            label = self.label
            if label:
                rv.append(html.dt(label()))
        rv.append(html.dd(self(**attrs)))
        if self.help_text:
            rv.append(html.dd(self.help_text, class_='explanation'))
        return Markup(u''.join(rv))

    def _attr_setdefault(self, attrs):
        """Add an ID to the attrs if there is none."""
        if 'id' not in attrs and self.id is not None:
            attrs['id'] = self.id

    def __call__(self, **attrs):
        """The default display is the form + error list as ul if needed."""
        return self.render(**attrs) + self.default_display_errors()


class Label(_Renderable):
    """Holds a label."""

    def __init__(self, field, text, linked_to=None):
        self._field = field
        self.text = text
        self.linked_to = linked_to

    def render(self, **attrs):
        html = self._field.form.html_builder
        attrs.setdefault('for', self.linked_to)
        return html.label(self.text, **attrs)


class InternalWidget(Widget):
    """Special widgets are widgets that can't be used on arbitrary
    form fields but belong to others.
    """

    def __init__(self, parent):
        self._parent = parent

    errors = all_errors = property(lambda x: ErrorList(x._parent._field.form))
    value = name = None


class Input(Widget):
    """A widget that is a HTML input field."""
    hide_value = False
    type = None

    def render(self, **attrs):
        html = self._field.form.html_builder
        self._attr_setdefault(attrs)
        value = self.value
        if self.hide_value:
            value = u''
        return html.input(name=self.name, value=value, type=self.type,
                          **attrs)


class TextInput(Input):
    """A widget that holds text."""
    type = 'text'


class PasswordInput(TextInput):
    """A widget that holds a password."""
    type = 'password'
    hide_value = True


class HiddenInput(Input):
    """A hidden input field for text."""
    type = 'hidden'


class Textarea(Widget):
    """Displays a textarea."""

    @property
    def default_display_errors(self):
        """A textarea is often used with multiple, it makes sense to
        display the errors of all childwidgets then which are not
        renderable because they are text.
        """
        return self.all_errors

    def _attr_setdefault(self, attrs):
        Widget._attr_setdefault(self, attrs)
        attrs.setdefault('rows', 8)
        attrs.setdefault('cols', 40)

    def render(self, **attrs):
        html = self._field.form.html_builder
        self._attr_setdefault(attrs)
        return html.textarea(self.value, name=self.name, **attrs)


class Checkbox(Widget):
    """A simple checkbox."""

    @property
    def checked(self):
        return self.value != u'False'

    def with_help_text(self, **attrs):
        """Render the checkbox with help text."""
        html = self._field.form.html_builder
        data = self(**attrs)
        if self.help_text:
            data += u' ' + html.label(self.help_text, class_='explanation',
                                      for_=self.id)
        return Markup(data)

    def as_dd(self, **attrs):
        """Return a dt/dd item."""
        html = self._field.form.html_builder
        rv = []
        label = self.label
        if label:
            rv.append(html.dt(label()))
        rv.append(html.dd(self.with_help_text()))
        return Markup(u''.join(rv))

    def as_li(self, **attrs):
        """Return a li item."""
        html = self._field.form.html_builder
        rv = [self.render(**attrs)]
        if self.label:
            rv.append(u' ' + self.label())
        if self.help_text:
            rv.append(html.div(self.help_text, class_='explanation'))
        rv.append(self.default_display_errors())
        return html.li(u''.join(rv))

    def render(self, **attrs):
        html = self._field.form.html_builder
        self._attr_setdefault(attrs)
        return html.input(name=self.name, type='checkbox',
                          checked=self.checked, **attrs)


class SelectBox(Widget):
    """A select box."""

    def _attr_setdefault(self, attrs):
        Widget._attr_setdefault(self, attrs)
        attrs.setdefault('multiple', self._field.multiple_choices)

    def render(self, **attrs):
        html = self._field.form.html_builder
        self._attr_setdefault(attrs)
        items = []
        for choice in self._field.choices:
            if isinstance(choice, tuple):
                key, value = choice
            else:
                key = value = choice
            selected = _is_choice_selected(self._field, self.value, key)
            items.append(html.option(unicode(value), value=unicode(key),
                                     selected=selected))
        return html.select(name=self.name, *items, **attrs)


class _InputGroupMember(InternalWidget):
    """A widget that is a single radio button."""

    # override the label descriptor
    label = None
    inline_label = True

    def __init__(self, parent, value, label):
        InternalWidget.__init__(self, parent)
        self.value = unicode(value)
        self.label = Label(self._parent._field, label, self.id)

    @property
    def name(self):
        return self._parent.name

    @property
    def id(self):
        return 'f_%s_%s' % (self._parent.name, self.value)

    @property
    def checked(self):
        return _is_choice_selected(self._parent._field, self._parent.value,
                                   self.value)

    def render(self, **attrs):
        html = self._parent._field.form.html_builder
        self._attr_setdefault(attrs)
        return html.input(type=self.type, name=self.name, value=self.value,
                          checked=self.checked, **attrs)


class RadioButton(_InputGroupMember):
    """A radio button in an input group."""
    type = 'radio'


class GroupCheckbox(_InputGroupMember):
    """A checkbox in an input group."""
    type = 'checkbox'


class _InputGroup(Widget):

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, value, all_errors)
        self.choices = []
        self._subwidgets = {}
        for value, label in _iter_choices(self._field.choices):
            widget = self.subwidget(self, value, label)
            self.choices.append(widget)
            self._subwidgets[value] = widget

    def __getitem__(self, value):
        """Return a subwidget."""
        return self._subwidgets[value]

    def _as_list(self, list_type, attrs):
        _ = self._field.form._get_translations().ugettext
        if attrs.pop('hide_empty', False) and not self.choices:
            return u''
        self._attr_setdefault(attrs)
        empty_msg = attrs.pop('empty_msg', None)
        label = not attrs.pop('nolabel', False)
        class_ = attrs.pop('class_', attrs.pop('class', None))
        if class_ is None:
            class_ = 'choicegroup'
        attrs['class'] = class_
        choices = [Markup(u'<li>%s %s</li>') % (
            choice(),
            label and choice.label() or u''
        ) for choice in self.choices]
        if not choices:
            if empty_msg is None:
                empty_msg = _('No choices.')
            choices.append(Markup(u'<li>%s</li>') % _(empty_msg))
        return Markup(list_type(*choices, **attrs))

    def as_ul(self, **attrs):
        """Render the radio buttons widget as <ul>"""
        html = self._field.form.html_builder
        return self._as_list(html.ul, attrs)

    def as_ol(self, **attrs):
        """Render the radio buttons widget as <ol>"""
        html = self._field.form.html_builder
        return self._as_list(html.ol, attrs)

    def as_table(self, **attrs):
        """Render the radio buttons widget as <table>"""
        self._attr_setdefault(attrs)
        return Markup(list_type(*[u'<tr><td>%s</td><td>%s</td></tr>' % (
            choice,
            choice.label
        ) for choice in self.choices], **attrs))

    def render(self, **attrs):
        return self.as_ul(**attrs)


class RadioButtonGroup(_InputGroup):
    """A group of radio buttons."""
    subwidget = RadioButton


class CheckboxGroup(_InputGroup):
    """A group of checkboxes."""
    subwidget = GroupCheckbox


class MappingWidget(Widget):
    """Special widget for dict-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_dict(value), all_errors)
        self._subwidgets = {}

    def __getitem__(self, name):
        subwidget = self._subwidgets.get(name)
        if subwidget is None:
            # this could raise a KeyError we pass through
            subwidget = _make_widget(self._field.fields[name],
                                     make_name(self.name, name),
                                     self._value.get(name),
                                     self._all_errors)
            self._subwidgets[name] = subwidget
        return subwidget

    def as_dl(self, **attrs):
        _add_class(attrs, 'mapping')
        html = self._field.form.html_builder
        return html.dl(*[x.as_dd() for x in self], **attrs)

    def __call__(self, *args, **kwargs):
        return self.as_dl(*args, **kwargs)

    def __iter__(self):
        for key in self._field.fields:
            yield self[key]


class FormWidget(MappingWidget):
    """A widget for forms."""

    def get_hidden_fields(self):
        """This method is called by the `hidden_fields` property to return
        a list of (key, value) pairs for the special hidden fields.
        """
        fields = []
        if self._field.form.request_info is not None:
            if self._field.form.csrf_protected:
                fields.append(('_csrf_token', self.csrf_token))
            if self._field.form.redirect_tracking:
                target = self.redirect_target
                if target is not None:
                    fields.append(('_redirect_target', target))
        return fields

    @property
    def hidden_fields(self):
        """The hidden fields as string."""
        html = self._field.form.html_builder
        return u''.join(html.input(type='hidden', name=name, value=value)
                        for name, value in self.get_hidden_fields())

    @property
    def captcha(self):
        """The captcha if one exists for this form."""
        if hasattr(self, '_captcha'):
            return self._captcha
        captcha = None
        if self._field.form.captcha_protected:
            captcha = get_recaptcha_html(self._field.form.recaptcha_public_key,
                                         self._field.form.recaptcha_use_ssl)
        self._captcha = captcha
        return captcha

    @property
    def csrf_token(self):
        """Forward the CSRF check token for templates."""
        return self._field.form.csrf_token

    @property
    def redirect_target(self):
        """The redirect target for this form."""
        return self._field.form.redirect_target

    def default_actions(self, **attrs):
        """Returns a default action div with a submit button."""
        html = self._field.form.html_builder
        label = attrs.pop('label', None)
        if label is None:
            label = self._field.form._get_translations().ugettext('Submit')
        attrs.setdefault('class', 'actions')
        return html.div(html.input(type='submit', value=label), **attrs)

    def render(self, method=None, **attrs):
        html = self._field.form.html_builder
        self._attr_setdefault(attrs)
        with_errors = attrs.pop('with_errors', False)
        if method is None:
            method = self._field.form.default_method.lower()

        # support jinja's caller
        caller = attrs.pop('caller', None)
        if caller is not None:
            body = Markup(caller())
        else:
            body = self.as_dl() + self.default_actions()

        hidden = self.hidden_fields
        if hidden:
            # if there are hidden fields we put an invisible div around
            # it.  the HTML standard doesn't allow input fields as direct
            # childs of a <form> tag...
            body = Markup('<div style="display: none">%s</div>%s'
                              % (hidden, body))

        if with_errors:
            body = self.default_display_errors() + body
        return html.form(body, action=self._field.form.action,
                         method=method, **attrs)

    def __call__(self, *args, **attrs):
        attrs.setdefault('with_errors', True)
        return self.render(*args, **attrs)


class ListWidget(Widget):
    """Special widget for list-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_list(value), all_errors)
        self._subwidgets = {}

    def as_ul(self, **attrs):
        html = self._field.form.html_builder
        return self._as_list(html.ul, attrs)

    def as_ol(self, **attrs):
        html = self._field.form.html_builder
        return self._as_list(html.ol, attrs)

    def _as_list(self, factory, attrs):
        if attrs.pop('hide_empty', False) and not self:
            return u''
        _add_class(attrs, 'multiple-items')
        html = self._field.form.html_builder
        items = []
        empty_streak = 0
        for index in xrange(len(self)):
            subwidget = self[index]
            empty_streak = empty_streak + 1 if subwidget.empty_as_item else 0
            items.append(html.li(subwidget()))

        # insert empty widgets at the end if necessary
        for offset in xrange(attrs.pop('extra_rows', 1) - empty_streak):
            items.append(html.li(self[len(items) + offset]()))

        return factory(*items, **attrs)

    def __getitem__(self, index):
        if not isinstance(index, (int, long)):
            raise TypeError('list widget indices must be integers')
        subwidget = self._subwidgets.get(index)
        if subwidget is None:
            try:
                value = self._value[index]
            except IndexError:
                # return an widget without value if we try
                # to access a field not in the list
                value = None
            subwidget = _make_widget(self._field.field,
                                     make_name(self.name, index), value,
                                     self._all_errors)
            self._subwidgets[index] = subwidget
        return subwidget

    def __iter__(self):
        for index in xrange(len(self)):
            yield self[index]

    def __len__(self):
        return len(self._value)

    def __call__(self, *args, **kwargs):
        return self.as_ul(*args, **kwargs)


class ErrorList(_Renderable, list):
    """The class that is used to display the errors."""

    def __init__(self, form, *args):
        self._form = form
        super(ErrorList, self).__init__(*args)

    def render(self, **attrs):
        return self.as_ul(**attrs)

    def as_ul(self, **attrs):
        html = self._form.html_builder
        return self._as_list(html.ul, attrs)

    def as_ol(self, **attrs):
        html = self._form.html_builder
        return self._as_list(html.ol, attrs)

    def _as_list(self, factory, attrs):
        html = self._form.html_builder
        if attrs.pop('hide_empty', False) and not self:
            return u''
        return factory(*(html.li(item) for item in self), **attrs)

    def __call__(self, **attrs):
        attrs.setdefault('class', attrs.pop('class_', 'errors'))
        attrs.setdefault('hide_empty', True)
        return self.render(**attrs)

########NEW FILE########
