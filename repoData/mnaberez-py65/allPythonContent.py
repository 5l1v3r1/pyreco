__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# test documentation build configuration file, created by
# sphinx-quickstart on Sun Nov 30 14:39:06 2008.
#
# This file is execfile()d with the current dir set to its containing
# directory.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed
# automatically).
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
from datetime import date

# If your extensions are in another directory, add it here. If the directory
# is relative to the documentation root, use os.path.abspath to make it
# absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings.  They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['.templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Py65'
year = date.today().year
copyright = u'2008-%d, Mike Naberezny and contributors' % year

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.21-dev'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'testdoc'


# Options for LaTeX output
# ------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, document class
# [howto/manual]).
latex_documents = [
    ('index', 'test.tex', ur'test Documentation',
     ur'foo', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = assembler
import re
from py65.utils.addressing import AddressParser


class Assembler:
    Statement = re.compile(r'^([A-z]{3}[0-7]?\s+'
                           r'\(?\s*)([^,\s\)]+)(\s*[,xXyY\s]*\)?'
                           r'[,xXyY\s]*)$')

    Addressing8 = [
        ['zpi',  # "($0012)"
         re.compile(r'^\(\$00([0-9A-F]{2})\)$')],
        ['zpx',  # "$0012,X"
         re.compile(r'^\$00([0-9A-F]{2}),X$')],
        ['zpy',  # "$0012,Y"
         re.compile(r'^\$00([0-9A-F]{2}),Y$')],
        ['zpg',  # "$0012"
         re.compile(r'^\$00([0-9A-F]{2})$')],
        ['inx',  # "($0012,X)
         re.compile(r'^\(\$00([0-9A-F]{2}),X\)$')],
        ['iax',  # "($1234,X)
         re.compile(r'^\(\$([0-9A-F]{2})([0-9A-F]{2}),X\)$')],
        ['iny',  # "($0012),Y"
         re.compile(r'^\(\$00([0-9A-F]{2})\),Y$')],
        ['ind',  # "($1234)"
         re.compile(r'^\(\$([0-9A-F]{2})([0-9A-F]{2})\)$')],
        ['abx',  # "$1234,X"
         re.compile(r'^\$([0-9A-F]{2})([0-9A-F]{2}),X$')],
        ['aby',  # "$1234,Y"
         re.compile(r'^\$([0-9A-F]{2})([0-9A-F]{2}),Y$')],
        ['abs',  # "$1234"
         re.compile(r'^\$([0-9A-F]{2})([0-9A-F]{2})$')],
        ['rel',  # "$1234"
         re.compile(r'^\$([0-9A-F]{2})([0-9A-F]{2})$')],
        ['imp',  # ""
         re.compile(r'^$')],
        ['acc',  # ""
         re.compile(r'^$')],
        ['acc',  # "A"
         re.compile(r'^A$')],
        ['imm',  # "#$12"
         re.compile(r'^#\$([0-9A-F]{2})$')]
    ]

    Addressing16 = [
        ['zpi',  # "($00001234)"
         re.compile(r'^\(\$0000([0-9A-F]{4})\)$')],
        ['zpx',  # "$00001234,X"
         re.compile(r'^\$0000([0-9A-F]{4}),X$')],
        ['zpy',  # "$00001234,Y"
         re.compile(r'^\$0000([0-9A-F]{4}),Y$')],
        ['zpg',  # "$00001234"
         re.compile(r'^\$0000([0-9A-F]{4})$')],
        ['inx',  # "($00001234,X)"
         re.compile(r'^\(\$0000([0-9A-F]{4}),X\)$')],
        ['iny',  # "($00001234),Y"
         re.compile(r'^\(\$0000([0-9A-F]{4})\),Y$')],
        ['ind',  # "($12345678)"
         re.compile(r'^\(\$([0-9A-F]{4})([0-9A-F]{4})\)$')],
        ['abx',  # "$12345678,X"
         re.compile(r'^\$([0-9A-F]{4})([0-9A-F]{4}),X$')],
        ['aby',  # "$12345678,Y"
         re.compile(r'^\$([0-9A-F]{4})([0-9A-F]{4}),Y$')],
        ['abs',  # "$12345678"
         re.compile(r'^\$([0-9A-F]{4})([0-9A-F]{4})$')],
        ['rel',  # "$12345678"
         re.compile(r'^\$([0-9A-F]{4})([0-9A-F]{4})$')],
        ['imp',  # ""
         re.compile(r'^$')],
        ['acc',  # ""
         re.compile(r'^$')],
        ['acc',  # "A"
         re.compile(r'^A$')],
        ['imm',  # "#$1234"
         re.compile(r'^#\$([0-9A-F]{4})$')]
    ]
    Addressing = Addressing8

    def __init__(self, mpu, address_parser=None):
        """ If a configured AddressParser is passed, symbolic addresses
        may be used in the assembly statements.
        """
        if address_parser is None:
            address_parser = AddressParser()

        self._mpu = mpu
        self._address_parser = address_parser

        self.addrWidth = mpu.ADDR_WIDTH
        self.byteWidth = mpu.BYTE_WIDTH
        self.addrFmt = mpu.ADDR_FORMAT
        self.byteFmt = mpu.BYTE_FORMAT
        self.addrMask = mpu.addrMask
        self.byteMask = mpu.byteMask

        if self.byteWidth == 8:
            self.Addressing = self.Addressing8
        else:
            self.Addressing = self.Addressing16

    def assemble(self, statement, pc=0000):
        """ Assemble the given assembly language statement.  If the statement
        uses relative addressing, the program counter (pc) must also be given.
        The result is a list of bytes.  Raises when assembly fails.
        """
        opcode, operand = self.normalize_and_split(statement)

        for mode, pattern in self.Addressing:
            match = pattern.match(operand)

            if match:
                try:
                    bytes = [self._mpu.disassemble.index((opcode, mode))]
                except ValueError:
                    continue

                operands = match.groups()

                if mode == 'rel':
                    # relative branch
                    absolute = int(''.join(operands), 16)
                    relative = (absolute - pc) - 2
                    relative = relative & self.byteMask
                    operands = [(self.byteFmt % relative)]

                elif len(operands) == 2:
                    # swap bytes
                    operands = (operands[1], operands[0])

                operands = [int(hex, 16) for hex in operands]
                bytes.extend(operands)

                # raise if the assembled bytes would exceed top of memory
                if (pc + len(bytes)) > (2 ** self._mpu.ADDR_WIDTH):
                    raise OverflowError

                return bytes

        # assembly failed
        raise SyntaxError(statement)

    def normalize_and_split(self, statement):
        """ Given an assembly language statement like "lda $c12,x", normalize
            the statement by uppercasing it, removing unnecessary whitespace,
            and parsing the address part using AddressParser.  The result of
            the normalization is a tuple of two strings (opcode, operand).
        """
        statement = ' '.join(str.split(statement))

        # normalize target in operand
        match = self.Statement.match(statement)
        if match:
            before, target, after = match.groups()

            # target is an immediate number
            if target.startswith('#'):
                number = self._address_parser.number(target[1:])
                if (number < 0x00) or (number > self.byteMask):
                    raise OverflowError
                statement = before + '#$' + self.byteFmt % number

            # target is the accumulator
            elif target in ('a', 'A'):
                pass

            # target is an address or label
            else:
                address = self._address_parser.number(target)
                statement = before + '$' + self.addrFmt % address + after

        # separate opcode and operand
        splitted = statement.split(" ", 2)
        opcode = splitted[0].strip().upper()
        if len(splitted) > 1:
            operand = splitted[1].strip().upper()
        else:
            operand = ''
        return (opcode, operand)

########NEW FILE########
__FILENAME__ = mpu6502
from py65.utils.conversions import itoa
from py65.utils.devices import make_instruction_decorator


class MPU:
    # vectors
    ResetTo = 0xfffc
    IrqTo = 0xfffe
    NMITo = 0xfffa

    # processor flags
    NEGATIVE = 128
    OVERFLOW = 64
    UNUSED = 32
    BREAK = 16  # there is no actual BREAK flag but this indicates BREAK
    DECIMAL = 8
    INTERRUPT = 4
    ZERO = 2
    CARRY = 1

    BYTE_WIDTH = 8
    BYTE_FORMAT = "%02x"
    ADDR_WIDTH = 16
    ADDR_FORMAT = "%04x"

    def __init__(self, memory=None, pc=0x0000):
        # config
        self.name = '6502'
        self.byteMask = ((1 << self.BYTE_WIDTH) - 1)
        self.addrMask = ((1 << self.ADDR_WIDTH) - 1)
        self.addrHighMask = (self.byteMask << self.BYTE_WIDTH)
        self.spBase = 1 << self.BYTE_WIDTH

        # vm status
        self.excycles = 0
        self.addcycles = False
        self.processorCycles = 0

        if memory is None:
            memory = 0x10000 * [0x00]
        self.memory = memory
        self.start_pc = pc

        # init
        self.reset()

    def reprformat(self):
        return ("%s PC  AC XR YR SP NV-BDIZC\n"
                "%s: %04x %02x %02x %02x %02x %s")

    def __repr__(self):
        flags = itoa(self.p, 2).rjust(self.BYTE_WIDTH, '0')
        indent = ' ' * (len(self.name) + 2)

        return self.reprformat() % (indent, self.name, self.pc, self.a,
                                    self.x, self.y, self.sp, flags)

    def step(self):
        instructCode = self.memory[self.pc]
        self.pc = (self.pc + 1) & self.addrMask
        self.excycles = 0
        self.addcycles = self.extracycles[instructCode]
        self.instruct[instructCode](self)
        self.pc &= self.addrMask
        self.processorCycles += self.cycletime[instructCode] + self.excycles
        return self

    def reset(self):
        self.pc = self.start_pc
        self.sp = self.byteMask
        self.a = 0
        self.x = 0
        self.y = 0
        self.p = self.p = self.BREAK | self.UNUSED
        self.processorCycles = 0

    # Helpers for addressing modes

    def ByteAt(self, addr):
        return self.memory[addr]

    def WordAt(self, addr):
        return self.ByteAt(addr) + (self.ByteAt(addr + 1) << self.BYTE_WIDTH)

    def WrapAt(self, addr):
        wrap = lambda x: (x & self.addrHighMask) + ((x + 1) & self.byteMask)
        return self.ByteAt(addr) + (self.ByteAt(wrap(addr)) << self.BYTE_WIDTH)

    def ProgramCounter(self):
        return self.pc

    # Addressing modes

    def ImmediateByte(self):
        return self.ByteAt(self.pc)

    def ZeroPageAddr(self):
        return self.ByteAt(self.pc)

    def ZeroPageXAddr(self):
        return self.byteMask & (self.x + self.ByteAt(self.pc))

    def ZeroPageYAddr(self):
        return self.byteMask & (self.y + self.ByteAt(self.pc))

    def IndirectXAddr(self):
        return self.WrapAt(self.byteMask & (self.ByteAt(self.pc) + self.x))

    def IndirectYAddr(self):
        if self.addcycles:
            a1 = self.WrapAt(self.ByteAt(self.pc))
            a2 = (a1 + self.y) & self.addrMask
            if (a1 & self.addrHighMask) != (a2 & self.addrHighMask):
                self.excycles += 1
            return a2
        else:
            return (self.WrapAt(self.ByteAt(self.pc)) + self.y) & self.addrMask

    def AbsoluteAddr(self):
        return self.WordAt(self.pc)

    def AbsoluteXAddr(self):
        if self.addcycles:
            a1 = self.WordAt(self.pc)
            a2 = (a1 + self.x) & self.addrMask
            if (a1 & self.addrHighMask) != (a2 & self.addrHighMask):
                self.excycles += 1
            return a2
        else:
            return (self.WordAt(self.pc) + self.x) & self.addrMask

    def AbsoluteYAddr(self):
        if self.addcycles:
            a1 = self.WordAt(self.pc)
            a2 = (a1 + self.y) & self.addrMask
            if (a1 & self.addrHighMask) != (a2 & self.addrHighMask):
                self.excycles += 1
            return a2
        else:
            return (self.WordAt(self.pc) + self.y) & self.addrMask

    def BranchRelAddr(self):
        self.excycles += 1
        addr = self.ImmediateByte()
        self.pc += 1

        if addr & self.NEGATIVE:
            addr = self.pc - (addr ^ self.byteMask) - 1
        else:
            addr = self.pc + addr

        if (self.pc & self.addrHighMask) != (addr & self.addrHighMask):
            self.excycles += 1

        self.pc = addr & self.addrMask

    # stack

    def stPush(self, z):
        self.memory[self.sp + self.spBase] = z & self.byteMask
        self.sp -= 1
        self.sp &= self.byteMask

    def stPop(self):
        self.sp += 1
        self.sp &= self.byteMask
        return self.ByteAt(self.sp + self.spBase)

    def stPushWord(self, z):
        self.stPush((z >> self.BYTE_WIDTH) & self.byteMask)
        self.stPush(z & self.byteMask)

    def stPopWord(self):
        z = self.stPop()
        z += self.stPop() << self.BYTE_WIDTH
        return z

    def FlagsNZ(self, value):
        self.p &= ~(self.ZERO | self.NEGATIVE)
        if value == 0:
            self.p |= self.ZERO
        else:
            self.p |= value & self.NEGATIVE

    # operations

    def opORA(self, x):
        self.a |= self.ByteAt(x())
        self.FlagsNZ(self.a)

    def opASL(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        self.p &= ~(self.CARRY | self.NEGATIVE | self.ZERO)

        if tbyte & self.NEGATIVE:
            self.p |= self.CARRY
        tbyte = (tbyte << 1) & self.byteMask

        if tbyte:
            self.p |= tbyte & self.NEGATIVE
        else:
            self.p |= self.ZERO

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opLSR(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        self.p &= ~(self.CARRY | self.NEGATIVE | self.ZERO)
        self.p |= tbyte & 1

        tbyte = tbyte >> 1
        if tbyte:
            pass
        else:
            self.p |= self.ZERO

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opBCL(self, x):
        if self.p & x:
            self.pc += 1
        else:
            self.BranchRelAddr()

    def opBST(self, x):
        if self.p & x:
            self.BranchRelAddr()
        else:
            self.pc += 1

    def opCLR(self, x):
        self.p &= ~x

    def opSET(self, x):
        self.p |= x

    def opAND(self, x):
        self.a &= self.ByteAt(x())
        self.FlagsNZ(self.a)

    def opBIT(self, x):
        tbyte = self.ByteAt(x())
        self.p &= ~(self.ZERO | self.NEGATIVE | self.OVERFLOW)
        if (self.a & tbyte) == 0:
            self.p |= self.ZERO
        self.p |= tbyte & (self.NEGATIVE | self.OVERFLOW)

    def opROL(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        if self.p & self.CARRY:
            if tbyte & self.NEGATIVE:
                pass
            else:
                self.p &= ~self.CARRY
            tbyte = (tbyte << 1) | 1
        else:
            if tbyte & self.NEGATIVE:
                self.p |= self.CARRY
            tbyte = tbyte << 1
        tbyte &= self.byteMask
        self.FlagsNZ(tbyte)

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opEOR(self, x):
        self.a ^= self.ByteAt(x())
        self.FlagsNZ(self.a)

    def opADC(self, x):
        data = self.ByteAt(x())

        if self.p & self.DECIMAL:
            halfcarry = 0
            decimalcarry = 0
            adjust0 = 0
            adjust1 = 0
            nibble0 = (data & 0xf) + (self.a & 0xf) + (self.p & self.CARRY)
            if nibble0 > 9:
                adjust0 = 6
                halfcarry = 1
            nibble1 = ((data >> 4) & 0xf) + ((self.a >> 4) & 0xf) + halfcarry
            if nibble1 > 9:
                adjust1 = 6
                decimalcarry = 1

            # the ALU outputs are not decimally adjusted
            nibble0 = nibble0 & 0xf
            nibble1 = nibble1 & 0xf
            aluresult = (nibble1 << 4) + nibble0

            # the final A contents will be decimally adjusted
            nibble0 = (nibble0 + adjust0) & 0xf
            nibble1 = (nibble1 + adjust1) & 0xf
            self.p &= ~(self.CARRY | self.OVERFLOW | self.NEGATIVE | self.ZERO)
            if aluresult == 0:
                self.p |= self.ZERO
            else:
                self.p |= aluresult & self.NEGATIVE
            if decimalcarry == 1:
                self.p |= self.CARRY
            if (~(self.a ^ data) & (self.a ^ aluresult)) & self.NEGATIVE:
                self.p |= self.OVERFLOW
            self.a = (nibble1 << 4) + nibble0
        else:
            if self.p & self.CARRY:
                tmp = 1
            else:
                tmp = 0
            result = data + self.a + tmp
            self.p &= ~(self.CARRY | self.OVERFLOW | self.NEGATIVE | self.ZERO)
            if (~(self.a ^ data) & (self.a ^ result)) & self.NEGATIVE:
                self.p |= self.OVERFLOW
            data = result
            if data > self.byteMask:
                self.p |= self.CARRY
                data &= self.byteMask
            if data == 0:
                self.p |= self.ZERO
            else:
                self.p |= data & self.NEGATIVE
            self.a = data

    def opROR(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        if self.p & self.CARRY:
            if tbyte & 1:
                pass
            else:
                self.p &= ~self.CARRY
            tbyte = (tbyte >> 1) | self.NEGATIVE
        else:
            if tbyte & 1:
                self.p |= self.CARRY
            tbyte = tbyte >> 1
        self.FlagsNZ(tbyte)

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opSTA(self, x):
        self.memory[x()] = self.a

    def opSTY(self, x):
        self.memory[x()] = self.y

    def opSTX(self, y):
        self.memory[y()] = self.x

    def opCMPR(self, get_address, register_value):
        tbyte = self.ByteAt(get_address())
        self.p &= ~(self.CARRY | self.ZERO | self.NEGATIVE)
        if register_value == tbyte:
            self.p |= self.CARRY | self.ZERO
        elif register_value > tbyte:
            self.p |= self.CARRY
        self.p |= (register_value - tbyte) & self.NEGATIVE

    def opSBC(self, x):
        data = self.ByteAt(x())

        if self.p & self.DECIMAL:
            halfcarry = 1
            decimalcarry = 0
            adjust0 = 0
            adjust1 = 0

            nibble0 = (self.a & 0xf) + (~data & 0xf) + (self.p & self.CARRY)
            if nibble0 <= 0xf:
                halfcarry = 0
                adjust0 = 10
            nibble1 = ((self.a >> 4) & 0xf) + ((~data >> 4) & 0xf) + halfcarry
            if nibble1 <= 0xf:
                adjust1 = 10 << 4

            # the ALU outputs are not decimally adjusted
            aluresult = self.a + (~data & self.byteMask) + \
                (self.p & self.CARRY)

            if aluresult > self.byteMask:
                decimalcarry = 1
            aluresult &= self.byteMask

            # but the final result will be adjusted
            nibble0 = (aluresult + adjust0) & 0xf
            nibble1 = ((aluresult + adjust1) >> 4) & 0xf

            self.p &= ~(self.CARRY | self.ZERO | self.NEGATIVE | self.OVERFLOW)
            if aluresult == 0:
                self.p |= self.ZERO
            else:
                self.p |= aluresult & self.NEGATIVE
            if decimalcarry == 1:
                self.p |= self.CARRY
            if ((self.a ^ data) & (self.a ^ aluresult)) & self.NEGATIVE:
                self.p |= self.OVERFLOW
            self.a = (nibble1 << 4) + nibble0
        else:
            result = self.a + (~data & self.byteMask) + (self.p & self.CARRY)
            self.p &= ~(self.CARRY | self.ZERO | self.OVERFLOW | self.NEGATIVE)
            if ((self.a ^ data) & (self.a ^ result)) & self.NEGATIVE:
                self.p |= self.OVERFLOW
            data = result & self.byteMask
            if data == 0:
                self.p |= self.ZERO
            if result > self.byteMask:
                self.p |= self.CARRY
            self.p |= data & self.NEGATIVE
            self.a = data

    def opDECR(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        self.p &= ~(self.ZERO | self.NEGATIVE)
        tbyte = (tbyte - 1) & self.byteMask
        if tbyte:
            self.p |= tbyte & self.NEGATIVE
        else:
            self.p |= self.ZERO

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opINCR(self, x):
        if x is None:
            tbyte = self.a
        else:
            addr = x()
            tbyte = self.ByteAt(addr)

        self.p &= ~(self.ZERO | self.NEGATIVE)
        tbyte = (tbyte + 1) & self.byteMask
        if tbyte:
            self.p |= tbyte & self.NEGATIVE
        else:
            self.p |= self.ZERO

        if x is None:
            self.a = tbyte
        else:
            self.memory[addr] = tbyte

    def opLDA(self, x):
        self.a = self.ByteAt(x())
        self.FlagsNZ(self.a)

    def opLDY(self, x):
        self.y = self.ByteAt(x())
        self.FlagsNZ(self.y)

    def opLDX(self, y):
        self.x = self.ByteAt(y())
        self.FlagsNZ(self.x)

    # instructions

    def inst_not_implemented(self):
        self.pc += 1

    instruct = [inst_not_implemented] * 256
    cycletime = [0] * 256
    extracycles = [0] * 256
    disassemble = [('???', 'imp')] * 256

    instruction = make_instruction_decorator(instruct, disassemble,
                                             cycletime, extracycles)

    @instruction(name="BRK", mode="imp", cycles=7)
    def inst_0x00(self):
        # pc has already been increased one
        pc = (self.pc + 1) & self.addrMask
        self.stPushWord(pc)

        self.p |= self.BREAK
        self.stPush(self.p | self.BREAK | self.UNUSED)

        self.p |= self.INTERRUPT
        self.pc = self.WordAt(self.IrqTo)

    @instruction(name="ORA", mode="inx", cycles=6)
    def inst_0x01(self):
        self.opORA(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="ORA", mode="zpg", cycles=3)
    def inst_0x05(self):
        self.opORA(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="ASL", mode="zpg", cycles=5)
    def inst_0x06(self):
        self.opASL(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="PHP", mode="imp", cycles=3)
    def inst_0x08(self):
        self.stPush(self.p | self.BREAK | self.UNUSED)

    @instruction(name="ORA", mode="imm", cycles=2)
    def inst_0x09(self):
        self.opORA(self.ProgramCounter)
        self.pc += 1

    @instruction(name="ASL", mode="acc", cycles=2)
    def inst_0x0a(self):
        self.opASL(None)

    @instruction(name="ORA", mode="abs", cycles=4)
    def inst_0x0d(self):
        self.opORA(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="ASL", mode="abs", cycles=6)
    def inst_0x0e(self):
        self.opASL(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BPL", mode="rel", cycles=2, extracycles=2)
    def inst_0x10(self):
        self.opBCL(self.NEGATIVE)

    @instruction(name="ORA", mode="iny", cycles=5, extracycles=1)
    def inst_0x11(self):
        self.opORA(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="ORA", mode="zpx", cycles=4)
    def inst_0x15(self):
        self.opORA(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="ASL", mode="zpx", cycles=6)
    def inst_0x16(self):
        self.opASL(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="CLC", mode="imp", cycles=2)
    def inst_0x18(self):
        self.opCLR(self.CARRY)

    @instruction(name="ORA", mode="aby", cycles=4, extracycles=1)
    def inst_0x19(self):
        self.opORA(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="ORA", mode="abx", cycles=4, extracycles=1)
    def inst_0x1d(self):
        self.opORA(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="ASL", mode="abx", cycles=7)
    def inst_0x1e(self):
        self.opASL(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="JSR", mode="abs", cycles=6)
    def inst_0x20(self):
        self.stPushWord((self.pc + 1) & self.addrMask)
        self.pc = self.WordAt(self.pc)

    @instruction(name="AND", mode="inx", cycles=6)
    def inst_0x21(self):
        self.opAND(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="BIT", mode="zpg", cycles=3)
    def inst_0x24(self):
        self.opBIT(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="AND", mode="zpg", cycles=3)
    def inst_0x25(self):
        self.opAND(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="ROL", mode="zpg", cycles=5)
    def inst_0x26(self):
        self.opROL(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="PLP", mode="imp", cycles=4)
    def inst_0x28(self):
        self.p = (self.stPop() | self.BREAK | self.UNUSED)

    @instruction(name="AND", mode="imm", cycles=2)
    def inst_0x29(self):
        self.opAND(self.ProgramCounter)
        self.pc += 1

    @instruction(name="ROL", mode="acc", cycles=2)
    def inst_0x2a(self):
        self.opROL(None)

    @instruction(name="BIT", mode="abs", cycles=4)
    def inst_0x2c(self):
        self.opBIT(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="AND", mode="abs", cycles=4)
    def inst_0x2d(self):
        self.opAND(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="ROL", mode="abs", cycles=6)
    def inst_0x2e(self):
        self.opROL(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BMI", mode="rel", cycles=2, extracycles=2)
    def inst_0x30(self):
        self.opBST(self.NEGATIVE)

    @instruction(name="AND", mode="iny", cycles=5, extracycles=1)
    def inst_0x31(self):
        self.opAND(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="AND", mode="zpx", cycles=4)
    def inst_0x35(self):
        self.opAND(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="ROL", mode="zpx", cycles=6)
    def inst_0x36(self):
        self.opROL(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="SEC", mode="imp", cycles=2)
    def inst_0x38(self):
        self.opSET(self.CARRY)

    @instruction(name="AND", mode="aby", cycles=4, extracycles=1)
    def inst_0x39(self):
        self.opAND(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="AND", mode="abx", cycles=4, extracycles=1)
    def inst_0x3d(self):
        self.opAND(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="ROL", mode="abx", cycles=7)
    def inst_0x3e(self):
        self.opROL(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="RTI", mode="imp", cycles=6)
    def inst_0x40(self):
        self.p = (self.stPop() | self.BREAK | self.UNUSED)
        self.pc = self.stPopWord()

    @instruction(name="EOR", mode="inx", cycles=6)
    def inst_0x41(self):
        self.opEOR(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="EOR", mode="zpg", cycles=3)
    def inst_0x45(self):
        self.opEOR(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="LSR", mode="zpg", cycles=5)
    def inst_0x46(self):
        self.opLSR(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="PHA", mode="imp", cycles=3)
    def inst_0x48(self):
        self.stPush(self.a)

    @instruction(name="EOR", mode="imm", cycles=2)
    def inst_0x49(self):
        self.opEOR(self.ProgramCounter)
        self.pc += 1

    @instruction(name="LSR", mode="acc", cycles=2)
    def inst_0x4a(self):
        self.opLSR(None)

    @instruction(name="JMP", mode="abs", cycles=3)
    def inst_0x4c(self):
        self.pc = self.WordAt(self.pc)

    @instruction(name="EOR", mode="abs", cycles=4)
    def inst_0x4d(self):
        self.opEOR(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="LSR", mode="abs", cycles=6)
    def inst_0x4e(self):
        self.opLSR(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BVC", mode="rel", cycles=2, extracycles=2)
    def inst_0x50(self):
        self.opBCL(self.OVERFLOW)

    @instruction(name="EOR", mode="iny", cycles=5, extracycles=1)
    def inst_0x51(self):
        self.opEOR(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="EOR", mode="zpx", cycles=4)
    def inst_0x55(self):
        self.opEOR(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="LSR", mode="zpx", cycles=6)
    def inst_0x56(self):
        self.opLSR(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="CLI", mode="imp", cycles=2)
    def inst_0x58(self):
        self.opCLR(self.INTERRUPT)

    @instruction(name="EOR", mode="aby", cycles=4, extracycles=1)
    def inst_0x59(self):
        self.opEOR(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="EOR", mode="abx", cycles=4, extracycles=1)
    def inst_0x5d(self):
        self.opEOR(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="LSR", mode="abx", cycles=7)
    def inst_0x5e(self):
        self.opLSR(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="RTS", mode="imp", cycles=6)
    def inst_0x60(self):
        self.pc = self.stPopWord()
        self.pc += 1

    @instruction(name="ADC", mode="inx", cycles=6)
    def inst_0x61(self):
        self.opADC(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="ADC", mode="zpg", cycles=3)
    def inst_0x65(self):
        self.opADC(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="ROR", mode="zpg", cycles=5)
    def inst_0x66(self):
        self.opROR(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="PLA", mode="imp", cycles=4)
    def inst_0x68(self):
        self.a = self.stPop()
        self.FlagsNZ(self.a)

    @instruction(name="ADC", mode="imm", cycles=2)
    def inst_0x69(self):
        self.opADC(self.ProgramCounter)
        self.pc += 1

    @instruction(name="ROR", mode="acc", cycles=2)
    def inst_0x6a(self):
        self.opROR(None)

    @instruction(name="JMP", mode="ind", cycles=5)
    def inst_0x6c(self):
        ta = self.WordAt(self.pc)
        self.pc = self.WrapAt(ta)

    @instruction(name="ADC", mode="abs", cycles=4)
    def inst_0x6d(self):
        self.opADC(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="ROR", mode="abs", cycles=6)
    def inst_0x6e(self):
        self.opROR(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BVS", mode="rel", cycles=2, extracycles=2)
    def inst_0x70(self):
        self.opBST(self.OVERFLOW)

    @instruction(name="ADC", mode="iny", cycles=5, extracycles=1)
    def inst_0x71(self):
        self.opADC(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="ADC", mode="zpx", cycles=4)
    def inst_0x75(self):
        self.opADC(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="ROR", mode="zpx", cycles=6)
    def inst_0x76(self):
        self.opROR(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="SEI", mode="imp", cycles=2)
    def inst_0x78(self):
        self.opSET(self.INTERRUPT)

    @instruction(name="ADC", mode="aby", cycles=4, extracycles=1)
    def inst_0x79(self):
        self.opADC(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="ADC", mode="abx", cycles=4, extracycles=1)
    def inst_0x7d(self):
        self.opADC(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="ROR", mode="abx", cycles=7)
    def inst_0x7e(self):
        self.opROR(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="STA", mode="inx", cycles=6)
    def inst_0x81(self):
        self.opSTA(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="STY", mode="zpg", cycles=3)
    def inst_0x84(self):
        self.opSTY(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="STA", mode="zpg", cycles=3)
    def inst_0x85(self):
        self.opSTA(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="STX", mode="zpg", cycles=3)
    def inst_0x86(self):
        self.opSTX(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="DEY", mode="imp", cycles=2)
    def inst_0x88(self):
        self.y -= 1
        self.y &= self.byteMask
        self.FlagsNZ(self.y)

    @instruction(name="TXA", mode="imp", cycles=2)
    def inst_0x8a(self):
        self.a = self.x
        self.FlagsNZ(self.a)

    @instruction(name="STY", mode="abs", cycles=4)
    def inst_0x8c(self):
        self.opSTY(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="STA", mode="abs", cycles=4)
    def inst_0x8d(self):
        self.opSTA(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="STX", mode="abs", cycles=4)
    def inst_0x8e(self):
        self.opSTX(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BCC", mode="rel", cycles=2, extracycles=2)
    def inst_0x90(self):
        self.opBCL(self.CARRY)

    @instruction(name="STA", mode="iny", cycles=6)
    def inst_0x91(self):
        self.opSTA(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="STY", mode="zpx", cycles=4)
    def inst_0x94(self):
        self.opSTY(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="STA", mode="zpx", cycles=4)
    def inst_0x95(self):
        self.opSTA(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="STX", mode="zpy", cycles=4)
    def inst_0x96(self):
        self.opSTX(self.ZeroPageYAddr)
        self.pc += 1

    @instruction(name="TYA", mode="imp", cycles=2)
    def inst_0x98(self):
        self.a = self.y
        self.FlagsNZ(self.a)

    @instruction(name="STA", mode="aby", cycles=5)
    def inst_0x99(self):
        self.opSTA(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="TXS", mode="imp", cycles=2)
    def inst_0x9a(self):
        self.sp = self.x

    @instruction(name="STA", mode="abx", cycles=5)
    def inst_0x9d(self):
        self.opSTA(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="LDY", mode="imm", cycles=2)
    def inst_0xa0(self):
        self.opLDY(self.ProgramCounter)
        self.pc += 1

    @instruction(name="LDA", mode="inx", cycles=6)
    def inst_0xa1(self):
        self.opLDA(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="LDX", mode="imm", cycles=2)
    def inst_0xa2(self):
        self.opLDX(self.ProgramCounter)
        self.pc += 1

    @instruction(name="LDY", mode="zpg", cycles=3)
    def inst_0xa4(self):
        self.opLDY(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="LDA", mode="zpg", cycles=3)
    def inst_0xa5(self):
        self.opLDA(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="LDX", mode="zpg", cycles=3)
    def inst_0xa6(self):
        self.opLDX(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="TAY", mode="imp", cycles=2)
    def inst_0xa8(self):
        self.y = self.a
        self.FlagsNZ(self.y)

    @instruction(name="LDA", mode="imm", cycles=2)
    def inst_0xa9(self):
        self.opLDA(self.ProgramCounter)
        self.pc += 1

    @instruction(name="TAX", mode="imp", cycles=2)
    def inst_0xaa(self):
        self.x = self.a
        self.FlagsNZ(self.x)

    @instruction(name="LDY", mode="abs", cycles=4)
    def inst_0xac(self):
        self.opLDY(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="LDA", mode="abs", cycles=4)
    def inst_0xad(self):
        self.opLDA(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="LDX", mode="abs", cycles=4)
    def inst_0xae(self):
        self.opLDX(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BCS", mode="rel", cycles=2, extracycles=2)
    def inst_0xb0(self):
        self.opBST(self.CARRY)

    @instruction(name="LDA", mode="iny", cycles=5, extracycles=1)
    def inst_0xb1(self):
        self.opLDA(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="LDY", mode="zpx", cycles=4)
    def inst_0xb4(self):
        self.opLDY(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="LDA", mode="zpx", cycles=4)
    def inst_0xb5(self):
        self.opLDA(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="LDX", mode="zpy", cycles=4)
    def inst_0xb6(self):
        self.opLDX(self.ZeroPageYAddr)
        self.pc += 1

    @instruction(name="CLV", mode="imp", cycles=2)
    def inst_0xb8(self):
        self.opCLR(self.OVERFLOW)

    @instruction(name="LDA", mode="aby", cycles=4, extracycles=1)
    def inst_0xb9(self):
        self.opLDA(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="TSX", mode="imp", cycles=2)
    def inst_0xba(self):
        self.x = self.sp
        self.FlagsNZ(self.x)

    @instruction(name="LDY", mode="abx", cycles=4, extracycles=1)
    def inst_0xbc(self):
        self.opLDY(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="LDA", mode="abx", cycles=4, extracycles=1)
    def inst_0xbd(self):
        self.opLDA(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="LDX", mode="aby", cycles=4, extracycles=1)
    def inst_0xbe(self):
        self.opLDX(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="CPY", mode="imm", cycles=2)
    def inst_0xc0(self):
        self.opCMPR(self.ProgramCounter, self.y)
        self.pc += 1

    @instruction(name="CMP", mode="inx", cycles=6)
    def inst_0xc1(self):
        self.opCMPR(self.IndirectXAddr, self.a)
        self.pc += 1

    @instruction(name="CPY", mode="zpg", cycles=3)
    def inst_0xc4(self):
        self.opCMPR(self.ZeroPageAddr, self.y)
        self.pc += 1

    @instruction(name="CMP", mode="zpg", cycles=3)
    def inst_0xc5(self):
        self.opCMPR(self.ZeroPageAddr, self.a)
        self.pc += 1

    @instruction(name="DEC", mode="zpg", cycles=5)
    def inst_0xc6(self):
        self.opDECR(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="INY", mode="imp", cycles=2)
    def inst_0xc8(self):
        self.y += 1
        self.y &= self.byteMask
        self.FlagsNZ(self.y)

    @instruction(name="CMP", mode="imm", cycles=2)
    def inst_0xc9(self):
        self.opCMPR(self.ProgramCounter, self.a)
        self.pc += 1

    @instruction(name="DEX", mode="imp", cycles=2)
    def inst_0xca(self):
        self.x -= 1
        self.x &= self.byteMask
        self.FlagsNZ(self.x)

    @instruction(name="CPY", mode="abs", cycles=4)
    def inst_0xcc(self):
        self.opCMPR(self.AbsoluteAddr, self.y)
        self.pc += 2

    @instruction(name="CMP", mode="abs", cycles=4)
    def inst_0xcd(self):
        self.opCMPR(self.AbsoluteAddr, self.a)
        self.pc += 2

    @instruction(name="DEC", mode="abs", cycles=3)
    def inst_0xce(self):
        self.opDECR(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BNE", mode="rel", cycles=2, extracycles=2)
    def inst_0xd0(self):
        self.opBCL(self.ZERO)

    @instruction(name="CMP", mode="iny", cycles=5, extracycles=1)
    def inst_0xd1(self):
        self.opCMPR(self.IndirectYAddr, self.a)
        self.pc += 1

    @instruction(name="CMP", mode="zpx", cycles=4)
    def inst_0xd5(self):
        self.opCMPR(self.ZeroPageXAddr, self.a)
        self.pc += 1

    @instruction(name="DEC", mode="zpx", cycles=6)
    def inst_0xd6(self):
        self.opDECR(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="CLD", mode="imp", cycles=2)
    def inst_0xd8(self):
        self.opCLR(self.DECIMAL)

    @instruction(name="CMP", mode="aby", cycles=4, extracycles=1)
    def inst_0xd9(self):
        self.opCMPR(self.AbsoluteYAddr, self.a)
        self.pc += 2

    @instruction(name="CMP", mode="abx", cycles=4, extracycles=1)
    def inst_0xdd(self):
        self.opCMPR(self.AbsoluteXAddr, self.a)
        self.pc += 2

    @instruction(name="DEC", mode="abx", cycles=7)
    def inst_0xde(self):
        self.opDECR(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="CPX", mode="imm", cycles=2)
    def inst_0xe0(self):
        self.opCMPR(self.ProgramCounter, self.x)
        self.pc += 1

    @instruction(name="SBC", mode="inx", cycles=6)
    def inst_0xe1(self):
        self.opSBC(self.IndirectXAddr)
        self.pc += 1

    @instruction(name="CPX", mode="zpg", cycles=3)
    def inst_0xe4(self):
        self.opCMPR(self.ZeroPageAddr, self.x)
        self.pc += 1

    @instruction(name="SBC", mode="zpg", cycles=3)
    def inst_0xe5(self):
        self.opSBC(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="INC", mode="zpg", cycles=5)
    def inst_0xe6(self):
        self.opINCR(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="INX", mode="imp", cycles=2)
    def inst_0xe8(self):
        self.x += 1
        self.x &= self.byteMask
        self.FlagsNZ(self.x)

    @instruction(name="SBC", mode="imm", cycles=2)
    def inst_0xe9(self):
        self.opSBC(self.ProgramCounter)
        self.pc += 1

    @instruction(name="NOP", mode="imp", cycles=2)
    def inst_0xea(self):
        pass

    @instruction(name="CPX", mode="abs", cycles=4)
    def inst_0xec(self):
        self.opCMPR(self.AbsoluteAddr, self.x)
        self.pc += 2

    @instruction(name="SBC", mode="abs", cycles=4)
    def inst_0xed(self):
        self.opSBC(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="INC", mode="abs", cycles=6)
    def inst_0xee(self):
        self.opINCR(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="BEQ", mode="rel", cycles=2, extracycles=2)
    def inst_0xf0(self):
        self.opBST(self.ZERO)

    @instruction(name="SBC", mode="iny", cycles=5, extracycles=1)
    def inst_0xf1(self):
        self.opSBC(self.IndirectYAddr)
        self.pc += 1

    @instruction(name="SBC", mode="zpx", cycles=4)
    def inst_0xf5(self):
        self.opSBC(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="INC", mode="zpx", cycles=6)
    def inst_0xf6(self):
        self.opINCR(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="SED", mode="imp", cycles=2)
    def inst_0xf8(self):
        self.opSET(self.DECIMAL)

    @instruction(name="SBC", mode="aby", cycles=4, extracycles=1)
    def inst_0xf9(self):
        self.opSBC(self.AbsoluteYAddr)
        self.pc += 2

    @instruction(name="SBC", mode="abx", cycles=4, extracycles=1)
    def inst_0xfd(self):
        self.opSBC(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="INC", mode="abx", cycles=7)
    def inst_0xfe(self):
        self.opINCR(self.AbsoluteXAddr)
        self.pc += 2

########NEW FILE########
__FILENAME__ = mpu65c02
from py65.devices import mpu6502
from py65.utils.devices import make_instruction_decorator


class MPU(mpu6502.MPU):
    def __init__(self, *args, **kwargs):
        mpu6502.MPU.__init__(self, *args, **kwargs)
        self.name = '65C02'
        self.waiting = False

    def step(self):
        if self.waiting:
            self.processorCycles += 1
        else:
            mpu6502.MPU.step(self)
        return self

    # Make copies of the lists
    instruct = mpu6502.MPU.instruct[:]
    cycletime = mpu6502.MPU.cycletime[:]
    extracycles = mpu6502.MPU.extracycles[:]
    disassemble = mpu6502.MPU.disassemble[:]

    instruction = make_instruction_decorator(instruct, disassemble,
                                             cycletime, extracycles)

    # addressing modes

    def ZeroPageIndirectAddr(self):
        return self.WordAt(255 & (self.ByteAt(self.pc)))

    def IndirectAbsXAddr(self):
        return (self.WordAt(self.pc) + self.x) & self.addrMask

    # operations

    def opRMB(self, x, mask):
        address = x()
        self.memory[address] &= mask

    def opSMB(self, x, mask):
        address = x()
        self.memory[address] |= mask

    def opSTZ(self, x):
        self.memory[x()] = 0x00

    def opTSB(self, x):
        address = x()
        m = self.memory[address]
        self.p &= ~self.ZERO
        z = m & self.a
        if z != 0:
            self.p |= self.ZERO
        self.memory[address] = m | self.a

    def opTRB(self, x):
        address = x()
        m = self.memory[address]
        self.p &= ~self.ZERO
        z = m & self.a
        if z != 0:
            self.p |= self.ZERO
        self.memory[address] = m & ~self.a

    # instructions

    @instruction(name="BRK", mode="imp", cycles=7)
    def inst_0x00(self):
        # pc has already been increased one
        pc = (self.pc + 1) & self.addrMask
        self.stPushWord(pc)

        self.p |= self.BREAK
        self.stPush(self.p | self.BREAK | self.UNUSED)

        self.p |= self.INTERRUPT
        self.pc = self.WordAt(self.IrqTo)

        # 65C02 clears decimal flag, NMOS 6502 does not
        self.p &= ~self.DECIMAL

    @instruction(name="TSB", mode="zpg", cycles=5)
    def inst_0x04(self):
        self.opTSB(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="RMB0", mode="zpg", cycles=5)
    def inst_0x07(self):
        self.opRMB(self.ZeroPageAddr, 0xFE)
        self.pc += 1

    @instruction(name="TSB", mode="abs", cycles=6)
    def inst_0x0c(self):
        self.opTSB(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="ORA", mode="zpi", cycles=5)
    def inst_0x12(self):
        self.opORA(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="TRB", mode="zpg", cycles=5)
    def inst_0x14(self):
        self.opTRB(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="RMB1", mode="zpg", cycles=5)
    def inst_0x17(self):
        self.opRMB(self.ZeroPageAddr, 0xFD)
        self.pc += 1

    @instruction(name="INC", mode="acc", cycles=2)
    def inst_0x1a(self):
        self.opINCR(None)

    @instruction(name="TRB", mode="abs", cycles=6)
    def inst_0x1c(self):
        self.opTRB(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="RMB2", mode="zpg", cycles=5)
    def inst_0x27(self):
        self.opRMB(self.ZeroPageAddr, 0xFB)
        self.pc += 1

    @instruction(name="AND", mode="zpi", cycles=5)
    def inst_0x32(self):
        self.opAND(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="BIT", mode="zpx", cycles=4)
    def inst_0x34(self):
        self.opBIT(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="RMB3", mode="zpg", cycles=5)
    def inst_0x37(self):
        self.opRMB(self.ZeroPageAddr, 0xF7)
        self.pc += 1

    @instruction(name="DEC", mode="acc", cycles=2)
    def inst_0x3a(self):
        self.opDECR(None)

    @instruction(name="BIT", mode="abx", cycles=4)
    def inst_0x3c(self):
        self.opBIT(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="RMB4", mode="zpg", cycles=5)
    def inst_0x47(self):
        self.opRMB(self.ZeroPageAddr, 0xEF)
        self.pc += 1

    @instruction(name="EOR", mode="zpi", cycles=5)
    def inst_0x52(self):
        self.opEOR(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="RMB5", mode="zpg", cycles=5)
    def inst_0x57(self):
        self.opRMB(self.ZeroPageAddr, 0xDF)
        self.pc += 1

    @instruction(name="PHY", mode="imp", cycles=3)
    def inst_0x5a(self):
        self.stPush(self.y)

    @instruction(name="STZ", mode="imp", cycles=3)
    def inst_0x64(self):
        self.opSTZ(self.ZeroPageAddr)
        self.pc += 1

    @instruction(name="RMB6", mode="zpg", cycles=5)
    def inst_0x67(self):
        self.opRMB(self.ZeroPageAddr, 0xBF)
        self.pc += 1

    @instruction(name="JMP", mode="ind", cycles=6)
    def inst_0x6c(self):
        ta = self.WordAt(self.pc)
        self.pc = self.WordAt(ta)

    @instruction(name="ADC", mode="zpi", cycles=5)
    def inst_0x72(self):
        self.opADC(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="STZ", mode="zpx", cycles=4)
    def inst_0x74(self):
        self.opSTZ(self.ZeroPageXAddr)
        self.pc += 1

    @instruction(name="RMB7", mode="zpg", cycles=5)
    def inst_0x77(self):
        self.opRMB(self.ZeroPageAddr, 0x7F)
        self.pc += 1

    @instruction(name="PLY", mode="imp", cycles=4)
    def inst_0x7a(self):
        self.y = self.stPop()
        self.FlagsNZ(self.y)

    @instruction(name="JMP", mode="iax", cycles=6)
    def inst_0x7c(self):
        self.pc = self.WordAt(self.IndirectAbsXAddr())

    @instruction(name="BRA", mode="rel", cycles=1, extracycles=1)
    def inst_0x80(self):
        self.BranchRelAddr()

    @instruction(name="SMB0", mode="zpg", cycles=5)
    def inst_0x87(self):
        self.opSMB(self.ZeroPageAddr, 0x01)
        self.pc += 1

    @instruction(name="BIT", mode="imm", cycles=2)
    def inst_0x89(self):
        # This instruction (BIT #$12) does not use opBIT because in the
        # immediate mode, BIT only affects the Z flag.
        tbyte = self.ImmediateByte()
        self.p &= ~(self.ZERO)
        if (self.a & tbyte) == 0:
            self.p |= self.ZERO
        self.pc += 1

    @instruction(name="STA", mode="zpi", cycles=5)
    def inst_0x92(self):
        self.opSTA(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="SMB1", mode="zpg", cycles=5)
    def inst_0x97(self):
        self.opSMB(self.ZeroPageAddr, 0x02)
        self.pc += 1

    @instruction(name="STZ", mode="abs", cycles=4)
    def inst_0x9c(self):
        self.opSTZ(self.AbsoluteAddr)
        self.pc += 2

    @instruction(name="STZ", mode="abx", cycles=5)
    def inst_0x9e(self):
        self.opSTZ(self.AbsoluteXAddr)
        self.pc += 2

    @instruction(name="SMB2", mode="zpg", cycles=5)
    def inst_0xa7(self):
        self.opSMB(self.ZeroPageAddr, 0x04)
        self.pc += 1

    @instruction(name="LDA", mode="zpi", cycles=5)
    def inst_0xb2(self):
        self.opLDA(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="SMB3", mode="zpg", cycles=5)
    def inst_0xb7(self):
        self.opSMB(self.ZeroPageAddr, 0x08)
        self.pc += 1

    @instruction(name="SMB4", mode="zpg", cycles=5)
    def inst_0xc7(self):
        self.opSMB(self.ZeroPageAddr, 0x10)
        self.pc += 1

    @instruction(name="WAI", mode='imp', cycles=3)
    def inst_0xcb(self):
        self.waiting = True

    @instruction(name="CMP", mode='zpi', cycles=5)
    def inst_0xd2(self):
        self.opCMPR(self.ZeroPageIndirectAddr, self.a)
        self.pc += 1

    @instruction(name="SMB5", mode="zpg", cycles=5)
    def inst_0xd7(self):
        self.opSMB(self.ZeroPageAddr, 0x20)
        self.pc += 1

    @instruction(name="PHX", mode="imp", cycles=3)
    def inst_0xda(self):
        self.stPush(self.x)

    @instruction(name="SMB6", mode="zpg", cycles=5)
    def inst_0xe7(self):
        self.opSMB(self.ZeroPageAddr, 0x40)
        self.pc += 1

    @instruction(name="SBC", mode="zpi", cycles=5)
    def inst_0xf2(self):
        self.opSBC(self.ZeroPageIndirectAddr)
        self.pc += 1

    @instruction(name="SMB7", mode="zpg", cycles=5)
    def inst_0xf7(self):
        self.opSMB(self.ZeroPageAddr, 0x80)
        self.pc += 1

    @instruction(name="PLX", mode="imp", cycles=4)
    def inst_0xfa(self):
        self.x = self.stPop()
        self.FlagsNZ(self.x)

########NEW FILE########
__FILENAME__ = mpu65org16
from py65.devices import mpu6502


class MPU(mpu6502.MPU):
    """
    The 65Org16 is a derivative of the 6502 architecture
      - with 32-bit address space (by using 16-bit bytes)
      - with no specific support for 8-bit bytes
      - with BCD mode not supported
      - and otherwise all opcodes and addressing modes are like the NMOS 6502
      - sign bit is bit 15, overflow bit is bit 14

    One implementation can be found here:
    https://github.com/BigEd/verilog-6502/wiki
    """

    BYTE_WIDTH = 16
    BYTE_FORMAT = "%04x"
    ADDR_WIDTH = 32
    ADDR_FORMAT = "%08x"

    def __init__(self, *args, **kwargs):
        mpu6502.MPU.__init__(self, *args, **kwargs)
        self.name = '65Org16'
        self.waiting = False
        self.IrqTo = (1 << self.ADDR_WIDTH) - 2
        self.ResetTo = (1 << self.ADDR_WIDTH) - 4
        self.NMITo = (1 << self.ADDR_WIDTH) - 6
        self.NEGATIVE = 1 << 15
        self.OVERFLOW = 1 << 14

    def step(self):
        if self.waiting:
            self.processorCycles += 1
        else:
            mpu6502.MPU.step(self)
        return self

    # Make copies of the lists
    instruct = mpu6502.MPU.instruct[:]
    cycletime = mpu6502.MPU.cycletime[:]
    extracycles = mpu6502.MPU.extracycles[:]
    disassemble = mpu6502.MPU.disassemble[:]

    def reprformat(self):
        return ("%s   PC     AC   XR   YR   SP  NV---------BDIZC\n" +
                "%s: %08x %04x %04x %04x %04x %s")

########NEW FILE########
__FILENAME__ = disassembler
from py65.utils.addressing import AddressParser


class Disassembler:
    def __init__(self, mpu, address_parser=None):
        if address_parser is None:
            address_parser = AddressParser()

        self._mpu = mpu
        self._address_parser = address_parser

        self.addrWidth = mpu.ADDR_WIDTH
        self.byteWidth = mpu.BYTE_WIDTH
        self.addrFmt = mpu.ADDR_FORMAT
        self.byteFmt = mpu.BYTE_FORMAT
        self.addrMask = mpu.addrMask
        self.byteMask = mpu.byteMask

    def instruction_at(self, pc):
        """ Disassemble the instruction at PC and return a tuple
        containing (instruction byte count, human readable text)
        """

        instruction = self._mpu.ByteAt(pc)
        disasm, addressing = self._mpu.disassemble[instruction]

        if addressing == 'acc':
            disasm += ' A'
            length = 1

        elif addressing == 'abs':
            address = self._mpu.WordAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                address, '$' + self.addrFmt % address)
            disasm += ' ' + address_or_label
            length = 3

        elif addressing == 'abx':
            address = self._mpu.WordAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                address, '$' + self.addrFmt % address)
            disasm += ' %s,X' % address_or_label
            length = 3

        elif addressing == 'aby':
            address = self._mpu.WordAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                address, '$' + self.addrFmt % address)
            disasm += ' %s,Y' % address_or_label
            length = 3

        elif addressing == 'imm':
            byte = self._mpu.ByteAt(pc + 1)
            disasm += ' #$' + self.byteFmt % byte
            length = 2

        elif addressing == 'imp':
            length = 1

        elif addressing == 'ind':
            address = self._mpu.WordAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                address, '$' + self.addrFmt % address)
            disasm += ' (%s)' % address_or_label
            length = 3

        elif addressing == 'iny':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '$' + self.byteFmt % zp_address)
            disasm += ' (%s),Y' % address_or_label
            length = 2

        elif addressing == 'inx':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '$' + self.byteFmt % zp_address)
            disasm += ' (%s,X)' % address_or_label
            length = 2

        elif addressing == 'iax':
            address = self._mpu.WordAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                address, '$' + self.addrFmt % address)
            disasm += ' (%s,X)' % address_or_label
            length = 3

        elif addressing == 'rel':
            opv = self._mpu.ByteAt(pc + 1)
            targ = pc + 2
            if opv & (1 << (self.byteWidth - 1)):
                targ -= (opv ^ self.byteMask) + 1
            else:
                targ += opv
            targ &= self.addrMask

            address_or_label = self._address_parser.label_for(
                targ, '$' + self.addrFmt % targ)
            disasm += ' ' + address_or_label
            length = 2

        elif addressing == 'zpi':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '($' + self.byteFmt % zp_address + ')')
            disasm += ' %s' % address_or_label
            length = 2

        elif addressing == 'zpg':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '$' + self.byteFmt % zp_address)
            disasm += ' %s' % address_or_label
            length = 2

        elif addressing == 'zpx':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '$' + self.byteFmt % zp_address)
            disasm += ' %s,X' % address_or_label
            length = 2

        elif addressing == 'zpy':
            zp_address = self._mpu.ByteAt(pc + 1)
            address_or_label = self._address_parser.label_for(
                zp_address, '$' + self.byteFmt % zp_address)
            disasm += ' %s,Y' % address_or_label
            length = 2

        return (length, disasm)

########NEW FILE########
__FILENAME__ = memory
from collections import defaultdict


class ObservableMemory:
    def __init__(self, subject=None, addrWidth=16):
        self.physMask = 0xffff
        if addrWidth > 16:
            # even with 32-bit address space, model only 256k memory
            self.physMask = 0x3ffff

        if subject is None:
            subject = (self.physMask + 1) * [0x00]
        self._subject = subject

        self._read_subscribers = defaultdict(list)
        self._write_subscribers = defaultdict(list)

    def __setitem__(self, address, value):
        if isinstance(address, slice):
            r = range(*address.indices(self.physMask + 1))
            for n, v in zip(r, value):
                self[n] = v
            return

        address &= self.physMask
        callbacks = self._write_subscribers[address]

        for callback in callbacks:
            result = callback(address, value)
            if result is not None:
                value = result

        self._subject[address] = value

    def __getitem__(self, address):
        if isinstance(address, slice):
            r = range(*address.indices(self.physMask + 1))
            return [ self[n] for n in r ]

        address &= self.physMask
        callbacks = self._read_subscribers[address]
        final_result = None

        for callback in callbacks:
            result = callback(address)
            if result is not None:
                final_result = result

        if final_result is None:
            return self._subject[address]
        else:
            return final_result

    def __getattr__(self, attribute):
        return getattr(self._subject, attribute)

    def subscribe_to_write(self, address_range, callback):
        for address in address_range:
            address &= self.physMask
            callbacks = self._write_subscribers.setdefault(address, [])
            if callback not in callbacks:
                callbacks.append(callback)

    def subscribe_to_read(self, address_range, callback):
        for address in address_range:
            address &= self.physMask
            callbacks = self._read_subscribers.setdefault(address, [])
            if callback not in callbacks:
                callbacks.append(callback)

    def write(self, start_address, bytes):
        start_address &= self.physMask
        self._subject[start_address:start_address + len(bytes)] = bytes

########NEW FILE########
__FILENAME__ = monitor
#!/usr/bin/env python -u

"""py65mon -- interact with a simulated 6502-based system

Usage: %s [options]

Options:
-h, --help           : Show this message
-m, --mpu <device>   : Choose which MPU device (default is 6502)
-l, --load <file>    : Load a file at address 0
-r, --rom <file>     : Load a rom at the top of address space and reset into it
-g, --goto <address> : Perform a goto command after loading any files
"""

import cmd
import getopt
import os
import re
import shlex
import sys

from asyncore import compact_traceback
from py65.devices.mpu6502 import MPU as NMOS6502
from py65.devices.mpu65c02 import MPU as CMOS65C02
from py65.devices.mpu65org16 import MPU as V65Org16
from py65.disassembler import Disassembler
from py65.assembler import Assembler
from py65.utils.addressing import AddressParser
from py65.utils import console
from py65.utils.conversions import itoa
from py65.memory import ObservableMemory

try:
    from urllib2 import urlopen
except ImportError: # Python 3
    from urllib.request import urlopen

class Monitor(cmd.Cmd):

    Microprocessors = {'6502': NMOS6502, '65C02': CMOS65C02,
                       '65Org16': V65Org16}

    def __init__(self, mpu_type=NMOS6502, completekey='tab', stdin=None,
                 stdout=None, argv=None):
        self.mpu_type = mpu_type
        if argv is None:
            argv = sys.argv
        self._reset(self.mpu_type)
        self._width = 78
        self.prompt = "."
        self._add_shortcuts()
        cmd.Cmd.__init__(self, completekey, stdin, stdout)
        self._parse_args(argv)

    def _parse_args(self, argv):
        try:
            shortopts = 'hm:l:r:g:'
            longopts = ['help', 'mpu=', 'load=', 'rom=', 'goto=']
            options, args = getopt.getopt(argv[1:], shortopts, longopts)
        except getopt.GetoptError as exc:
            self._output(exc.args[0])
            self._usage()
            self._exit(1)

        for opt, value in options:
            if opt in ('-l', '--load'):
                cmd = "load %s" % value
                self.onecmd(cmd)

            if opt in ('-r', '--rom'):
                # load a ROM and run from the reset vector
                cmd = "load %s %d" % (value, -1)
                self.onecmd(cmd)
                physMask = self._mpu.memory.physMask
                reset = self._mpu.ResetTo & physMask
                dest = self._mpu.memory[reset] + \
                    (self._mpu.memory[reset + 1] << self.byteWidth)
                cmd = "goto %08x" % dest
                self.onecmd(cmd)

            if opt in ('-g', '--goto'):
                cmd = "goto %s" % value
                self.onecmd(cmd)

            if opt in ('-m', '--mpu'):
                if self._get_mpu(value) is None:
                    mpus = list(self.Microprocessors.keys())
                    mpus.sort()
                    msg = "Fatal: no such MPU. Available MPUs: %s"
                    self._output(msg % ', '.join(mpus))
                    sys.exit(1)
                cmd = "mpu %s" % value
                self.onecmd(cmd)

            elif opt in ("-h", "--help"):
                self._usage()
                self._exit(1)

    def _usage(self):
        usage = __doc__ % sys.argv[0]
        self._output(usage)

    def onecmd(self, line):
        line = self._preprocess_line(line)

        result = None
        try:
            result = cmd.Cmd.onecmd(self, line)
        except KeyboardInterrupt:
            self._output("Interrupt")
        except Exception:
            (file, fun, line), t, v, tbinfo = compact_traceback()
            error = 'Error: %s, %s: file: %s line: %s' % (t, v, file, line)
            self._output(error)

        if not line.startswith("quit"):
            self._output_mpu_status()

        return result

    def _reset(self, mpu_type):
        self._mpu = mpu_type()
        self.addrWidth = self._mpu.ADDR_WIDTH
        self.byteWidth = self._mpu.BYTE_WIDTH
        self.addrFmt = self._mpu.ADDR_FORMAT
        self.byteFmt = self._mpu.BYTE_FORMAT
        self.addrMask = self._mpu.addrMask
        self.byteMask = self._mpu.byteMask
        self._install_mpu_observers()
        self._address_parser = AddressParser()
        self._disassembler = Disassembler(self._mpu, self._address_parser)
        self._assembler = Assembler(self._mpu, self._address_parser)

    def _add_shortcuts(self):
        self._shortcuts = {'EOF':  'quit',
                           '~':    'tilde',
                           'a':    'assemble',
                           'al':   'add_label',
                           'd':    'disassemble',
                           'dl':   'delete_label',
                           'exit': 'quit',
                           'f':    'fill',
                           '>':    'fill',
                           'g':    'goto',
                           'h':    'help',
                           '?':    'help',
                           'l':    'load',
                           'm':    'mem',
                           'q':    'quit',
                           'r':    'registers',
                           'ret':  'return',
                           'rad':  'radix',
                           's':    'save',
                           'shl':  'show_labels',
                           'x':    'quit',
                           'z':    'step'}

    def _preprocess_line(self, line):
        # line comments
        quoted = False
        for pos, char in enumerate(line):
            if char in ('"', "'"):
                quoted = not quoted
            if (not quoted) and (char == ';'):
                line = line[:pos]
                break

        # whitespace & leading dots
        line = line.strip(' \t').lstrip('.')

        # special case for vice compatibility
        if line.startswith('~'):
            line = self._shortcuts['~'] + ' ' + line[1:]

        # command shortcuts
        for shortcut, command in self._shortcuts.items():
            if line == shortcut:
                line = command
                break

            pattern = '^%s\s+' % re.escape(shortcut)
            matches = re.match(pattern, line)
            if matches:
                start, end = matches.span()
                line = "%s %s" % (command, line[end:])
                break

        return line

    def _get_mpu(self, name):
        requested = name.lower()
        mpu = None
        for key, klass in self.Microprocessors.items():
            if key.lower() == requested:
                mpu = klass
                break
        return mpu

    def _install_mpu_observers(self):
        def putc(address, value):
            self.stdout.write(chr(value))
            self.stdout.flush()

        def getc(address):
            char = console.getch_noblock(self.stdin)
            if char:
                byte = ord(char)
            else:
                byte = 0
            return byte

        m = ObservableMemory(addrWidth=self.addrWidth)
        m.subscribe_to_write([0xF001], putc)
        m.subscribe_to_read([0xF004], getc)

        self._mpu.memory = m

    def _output_mpu_status(self):
        self._output("\n" + repr(self._mpu))

    def _output(self, stuff):
        if stuff is not None:
            self.stdout.write(stuff + "\n")

    def _exit(self, exitcode=0):
        sys.exit(exitcode)

    def do_help(self, args):
        args = self._shortcuts.get(args.strip(), args)
        return cmd.Cmd.do_help(self, args)

    def help_version(self):
        self._output("version\t\tDisplay Py65 version information.")

    def do_version(self, args):
        self._output("\nPy65 Monitor")

    def help_help(self):
        self._output("help\t\tPrint a list of available actions.")
        self._output("help <action>\tPrint help for <action>.")

    def help_reset(self):
        self._output("reset\t\tReset the microprocessor")

    def do_reset(self, args):
        klass = self._mpu.__class__
        self._reset(mpu_type=klass)

    def do_mpu(self, args):
        def available_mpus():
            mpus = list(self.Microprocessors.keys())
            mpus.sort()
            self._output("Available MPUs: %s" % ', '.join(mpus))

        if args == '':
            self._output("Current MPU is %s" % self._mpu.name)
            available_mpus()
        else:
            new_mpu = self._get_mpu(args)
            if new_mpu is None:
                self._output("Unknown MPU: %s" % args)
                available_mpus()
            else:
                self._reset(new_mpu)
                self._output("Reset with new MPU %s" % self._mpu.name)

    def help_mpu(self):
        self._output("mpu\t\tPrint available microprocessors.")
        self._output("mpu <type>\tSelect a new microprocessor.")

    def do_quit(self, args):
        self._output('')
        return 1

    def help_quit(self):
        self._output("To quit, type ^D or use the quit command.")

    def do_assemble(self, args):
        splitted = args.split(None, 1)
        if len(splitted) != 2:
            return self._interactive_assemble(args)

        statement = splitted[1]
        try:
            start = self._address_parser.number(splitted[0])
            bytes = self._assembler.assemble(statement, start)
            end = start + len(bytes)
            self._mpu.memory[start:end] = bytes
            self.do_disassemble(self.addrFmt % start)
        except KeyError:
            self._output("Bad label: %s" % args)
        except OverflowError:
            self._output("Overflow error: %s" % args)
        except SyntaxError:
            self._output("Syntax error: %s" % statement)

    def help_assemble(self):
        self._output("assemble\t\t\t"
                     "Start interactive assembly at the program counter.")
        self._output("assemble <address>\t\t"
                     "Start interactive assembly at the address.")
        self._output("assemble <address> <statement>\t"
                     "Assemble a statement at the address.")

    def _interactive_assemble(self, args):
        if args == '':
            start = self._mpu.pc
        else:
            try:
                start = self._address_parser.number(args)
            except KeyError:
                self._output("Bad label: %s" % args)
                return

        while True:
            prompt = "\r$" + (self.addrFmt % start) + "   " + \
                (" " * int(1 + self.byteWidth / 4) * 3)

            line = console.line_input(prompt,
                                      stdin=self.stdin, stdout=self.stdout)

            if not line.strip():
                self.stdout.write("\n")
                return

            # assemble into memory
            try:
                bytes = self._assembler.assemble(line, pc=start)
                numbytes = len(bytes)

                end = start + numbytes
                self._mpu.memory[start:end] = bytes

                # print disassembly
                _, disasm = self._disassembler.instruction_at(start)
                fdisasm = self._format_disassembly(start, numbytes, disasm)
                indent = ' ' * (len(prompt + line) + 5)
                self.stdout.write("\r" + indent + "\r")
                self.stdout.write(fdisasm + "\n")

                # advance to next address
                start += numbytes
                if start >= (2 ** self._mpu.ADDR_WIDTH):
                    start = 0
            except KeyError:
                addr = self.addrFmt % start
                self.stdout.write("\r$%s  ?Label\n" % addr)
            except OverflowError:
                addr = self.addrFmt % start
                self.stdout.write("\r$%s  ?Overflow\n" % addr)
            except SyntaxError:
                addr = self.addrFmt % start
                self.stdout.write("\r$%s  ?Syntax\n" % addr)

    def do_disassemble(self, args):
        splitted = shlex.split(args)
        if len(splitted) != 1:
            return self.help_disassemble()

        address_parts = splitted[0].split(":")
        start = self._address_parser.number(address_parts[0])
        if len(address_parts) > 1:
            end = self._address_parser.number(address_parts[1])
        else:
            end = start

        max_address = (2 ** self._mpu.ADDR_WIDTH) - 1
        cur_address = start
        needs_wrap = start > end

        while needs_wrap or cur_address <= end:
            length, disasm = self._disassembler.instruction_at(cur_address)
            self._output(self._format_disassembly(cur_address, length, disasm))

            remaining = length
            while remaining:
                remaining -= 1
                cur_address += 1
                if start > end and cur_address > max_address:
                    needs_wrap = False
                    cur_address = 0

    def _format_disassembly(self, address, length, disasm):
        cur_address = address
        max_address = (2 ** self._mpu.ADDR_WIDTH) - 1

        bytes_remaining = length
        dump = ''

        while bytes_remaining:
            if cur_address > max_address:
                cur_address = 0
            dump += self.byteFmt % self._mpu.memory[cur_address] + " "
            cur_address += 1
            bytes_remaining -= 1

        fieldwidth = 1 + int(1 + self.byteWidth / 4) * 3
        fieldfmt = "%%-%ds" % fieldwidth
        return "$" + self.addrFmt % address + "  " + fieldfmt % dump + disasm

    def help_disassemble(self):
        self._output("disassemble <address_range>")
        self._output("Disassemble instructions in the address range.")
        self._output('Range is specified like "<start>:<end>".')

    def help_step(self):
        self._output("step")
        self._output("Single-step through instructions.")

    def do_step(self, args):
        self._mpu.step()
        self.do_disassemble(self.addrFmt % self._mpu.pc)

    def help_return(self):
        self._output("return")
        self._output("Continues execution and returns to the monitor just")
        self._output("before the next RTS or RTI is executed.")

    def do_return(self, args):
        returns = [0x60, 0x40]  # RTS, RTI
        self._run(stopcodes=returns)

    def help_goto(self):
        self._output("goto <address>")
        self._output("Change the PC to address and continue execution.")

    def do_goto(self, args):
        if args == '':
            return self.help_goto()

        self._mpu.pc = self._address_parser.number(args)
        brks = [0x00]  # BRK
        self._run(stopcodes=brks)

    def _run(self, stopcodes=[]):
        last_instruct = None
        while last_instruct not in stopcodes:
            self._mpu.step()
            last_instruct = self._mpu.memory[self._mpu.pc]

    def help_radix(self):
        self._output("radix [H|D|O|B]")
        self._output("Set default radix to hex, decimal, octal, or binary.")
        self._output("With no argument, the current radix is printed.")

    def help_cycles(self):
        self._output("Display the total number of cycles executed.")

    def do_cycles(self, args):
        self._output(str(self._mpu.processorCycles))

    def do_radix(self, args):
        radixes = {'Hexadecimal': 16, 'Decimal': 10, 'Octal': 8, 'Binary': 2}

        if args != '':
            new = args[0].lower()
            changed = False
            for name, radix in radixes.items():
                if name[0].lower() == new:
                    self._address_parser.radix = radix
                    changed = True
            if not changed:
                self._output("Illegal radix: %s" % args)

        for name, radix in radixes.items():
            if self._address_parser.radix == radix:
                self._output("Default radix is %s" % name)

    def help_tilde(self):
        self._output("~ <number>")
        self._output("Display a number in decimal, hex, octal, and binary.")

    def do_tilde(self, args):
        if args == '':
            return self.help_tilde()

        try:
            num = self._address_parser.number(args)
            self._output("+%u" % num)
            self._output("$" + self.byteFmt % num)
            self._output("%04o" % num)
            self._output(itoa(num, 2).zfill(8))
        except KeyError:
            self._output("Bad label: %s" % args)
        except OverflowError:
            self._output("Overflow error: %s" % args)

    def help_registers(self):
        self._output("registers[<name>=<value> [, <name>=<value>]*]")
        self._output("Assign respective registers.  With no parameters,")
        self._output("display register values.")

    def do_registers(self, args):
        if args == '':
            return

        pairs = re.findall('([^=,\s]*)=([^=,\s]*)', args)
        if pairs == []:
            return self._output("Syntax error: %s" % args)

        for register, value in pairs:
            if register not in ('pc', 'sp', 'a', 'x', 'y', 'p'):
                self._output("Invalid register: %s" % register)
            else:
                try:
                    intval = self._address_parser.number(value) & self.addrMask
                    if len(register) == 1:
                        intval &= self.byteMask
                    setattr(self._mpu, register, intval)
                except KeyError as exc:
                    self._output(exc.args[0])

    def help_cd(self):
        self._output("cd <directory>")
        self._output("Change the working directory.")

    def do_cd(self, args):
        if args == '':
            return self.help_cd()

        try:
            os.chdir(args)
        except OSError as exc:
            msg = "Cannot change directory: [%d] %s" % (exc.errno,
                exc.strerror)
            self._output(msg)
        self.do_pwd()

    def help_pwd(self):
        self._output("Show the current working directory.")

    def do_pwd(self, args=None):
        cwd = os.getcwd()
        self._output(cwd)

    def help_load(self):
        self._output("load \"filename\" <address>")
        self._output("Load a file into memory at the specified address.")
        self._output("Commodore-style load address bytes are ignored.")

    def do_load(self, args):
        split = shlex.split(args)
        if len(split) > 2:
            self._output("Syntax error: %s" % args)
            return

        filename = split[0]

        if "://" in filename:
            try:
                f = urlopen(filename)
                bytes = f.read()
                f.close()
            except Exception as exc:
                msg = "Cannot fetch remote file: %s" % str(exc)
                self._output(msg)
                return
        else:
            try:
                f = open(filename, 'rb')
                bytes = f.read()
                f.close()
            except (OSError, IOError) as exc:
                msg = "Cannot load file: [%d] %s" % (exc.errno, exc.strerror)
                self._output(msg)
                return

        if len(split) == 2:
            if split[1] == "-1":
                # load a ROM to top of memory
                start = self.addrMask - len(bytes) / int(self.byteWidth / 8) + 1
            else:
                start = self._address_parser.number(split[1])
        else:
            start = self._mpu.pc

        if self.byteWidth == 8:
            if isinstance(bytes, str):
                bytes = map(ord, bytes)
            else: # Python 3
                bytes = [ b for b in bytes ]

        elif self.byteWidth == 16:
            def format(msb, lsb):
                if isinstance(bytes, str):
                    return (ord(msb) << 8) + ord(lsb)
                else: # Python 3
                    return (msb << 8) + lsb
            bytes = list(map(format, bytes[0::2], bytes[1::2]))

        self._fill(start, start, bytes)

    def do_save(self, args):
        split = shlex.split(args)
        if len(split) != 3:
            self._output("Syntax error: %s" % args)
            return

        filename = split[0]
        start = self._address_parser.number(split[1])
        end = self._address_parser.number(split[2])

        mem = self._mpu.memory[start:end + 1]
        try:
            f = open(filename, 'wb')
            for m in mem:
                # output each octect from msb first
                for shift in range(self.byteWidth - 8, -1, -8):
                    f.write(bytearray([(m >> shift) & 0xff]))
            f.close()
        except (OSError, IOError) as exc:
            msg = "Cannot save file: [%d] %s" % (exc.errno, exc.strerror)
            self._output(msg)
            return

        self._output("Saved +%d bytes to %s" % (len(mem), filename))

    def help_save(self):
        self._output("save \"filename\" <start> <end>")
        self._output("Save the specified memory range as a binary file.")
        self._output("Commodore-style load address bytes are not written.")

    def help_fill(self):
        self._output("fill <address_range> <data_list>")
        self._output("Fill memory in the address range with the data in")
        self._output("<data_list>.  If the size of the address range is")
        self._output("greater than the size of the data_list, the data_list ")
        self._output("is repeated.")

    def do_fill(self, args):
        split = shlex.split(args)
        if len(split) < 2:
            return self.help_fill()

        start, end = self._address_parser.range(split[0])
        filler = list(map(self._address_parser.number, split[1:]))

        self._fill(start, end, filler)

    def _fill(self, start, end, filler):
        address = start
        length, index = len(filler), 0

        if start == end:
            end = start + length - 1
            if (end > self.addrMask):
                end = self.addrMask

        while address <= end:
            address &= self.addrMask
            self._mpu.memory[address] = (filler[index] & self.byteMask)
            index += 1
            if index == length:
                index = 0
            address += 1

        fmt = (end - start + 1, start, end)
        starttoend = "$" + self.addrFmt + " to $" + self.addrFmt
        self._output(("Wrote +%d bytes from " + starttoend) % fmt)

    def help_mem(self):
        self._output("mem <address_range>")
        self._output("Display the contents of memory.")
        self._output('Range is specified like "<start:end>".')

    def do_mem(self, args):
        split = shlex.split(args)
        if len(split) != 1:
            return self.help_mem()

        start, end = self._address_parser.range(split[0])

        line = self.addrFmt % start + ":"
        for address in range(start, end + 1):
            byte = self._mpu.memory[address]
            more = "  " + self.byteFmt % byte

            exceeded = len(line) + len(more) > self._width
            if exceeded:
                self._output(line)
                line = self.addrFmt % address + ":"
            line += more
        self._output(line)

    def help_add_label(self):
        self._output("add_label <address> <label>")
        self._output("Map a given address to a label.")

    def do_add_label(self, args):
        split = shlex.split(args)
        if len(split) != 2:
            self._output("Syntax error: %s" % args)
            return self.help_add_label()

        address = self._address_parser.number(split[0])
        label = split[1]

        self._address_parser.labels[label] = address

    def help_show_labels(self):
        self._output("show_labels")
        self._output("Display current label mappings.")

    def do_show_labels(self, args):
        values = list(self._address_parser.labels.values())
        keys = list(self._address_parser.labels.keys())

        byaddress = list(zip(values, keys))
        byaddress.sort()
        for address, label in byaddress:
            self._output(self.addrFmt % address + ": " + label)

    def help_delete_label(self):
        self._output("delete_label <label>")
        self._output("Remove the specified label from the label tables.")

    def do_delete_label(self, args):
        if args == '':
            return self.help_delete_label()

        if args in self._address_parser.labels:
            del self._address_parser.labels[args]

    def do_width(self, args):
        if args != '':
            try:
                new_width = int(args)
                if new_width >= 10:
                    self._width = new_width
                else:
                    self._output("Minimum terminal width is 10")
            except ValueError:
                self._output("Illegal width: %s" % args)

        self._output("Terminal width is %d" % self._width)

    def help_width(self):
        self._output("width <columns>")
        self._output("Set the width used by some commands to wrap output.")
        self._output("With no argument, the current width is printed.")


def main(args=None):
    c = Monitor()

    try:
        import readline
        readline = readline  # pyflakes
    except ImportError:
        pass

    try:
        c.onecmd('version')
        c.cmdloop()
    except KeyboardInterrupt:
        c._output('')

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_mpu6502
import unittest
import sys
import py65.assembler
import py65.devices.mpu6502


class Common6502Tests:
    """Tests common to 6502-based microprocessors"""

    # Reset

    def test_reset_sets_registers_to_initial_states(self):
        mpu = self._make_mpu()
        mpu.reset()
        self.assertEqual(0xFF, mpu.sp)
        self.assertEqual(0, mpu.a)
        self.assertEqual(0, mpu.x)
        self.assertEqual(0, mpu.y)
        self.assertEqual(mpu.BREAK | mpu.UNUSED, mpu.p)

    # ADC Absolute

    def test_adc_bcd_off_absolute_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        self.assertEqual(0x10000, len(mpu.memory))

        mpu.memory[0xC000] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_absolute_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.p |= mpu.CARRY
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_absolute_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0xFE
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_absolute_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_absolute_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_absolute_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0xff
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_absolute_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_absolute_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0xff
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_absolute_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        # $0000 ADC $C000
        self._write(mpu.memory, 0x0000, (0x6D, 0x00, 0xC0))
        mpu.memory[0xC000] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Zero Page

    def test_adc_bcd_off_zp_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.p |= mpu.CARRY
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_zp_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0xff
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0xff
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.a = 0x40
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 ADC $00B0
        self._write(mpu.memory, 0x0000, (0x65, 0xB0))
        mpu.memory[0x00B0] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Immediate

    def test_adc_bcd_off_immediate_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0
        # $0000 ADC #$00
        self._write(mpu.memory, 0x0000, (0x69, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_immediate_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.p |= mpu.CARRY
        # $0000 ADC #$00
        self._write(mpu.memory, 0x0000, (0x69, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_immediate_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        # $0000 ADC #$FE
        self._write(mpu.memory, 0x0000, (0x69, 0xFE))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_immediate_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        # $0000 ADC #$FF
        self._write(mpu.memory, 0x0000, (0x69, 0xFF))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_immediate_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC #$01
        self._write(mpu.memory, 0x000, (0x69, 0x01))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_immediate_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC #$FF
        self._write(mpu.memory, 0x000, (0x69, 0xff))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_immediate_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC #$01
        self._write(mpu.memory, 0x000, (0x69, 0x01))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_immediate_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC #$FF
        self._write(mpu.memory, 0x000, (0x69, 0xff))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_immediate_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.a = 0x40
        # $0000 ADC #$40
        self._write(mpu.memory, 0x0000, (0x69, 0x40))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_on_immediate_79_plus_00_carry_set(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p |= mpu.CARRY
        mpu.a = 0x79
        # $0000 ADC #$00
        self._write(mpu.memory, 0x0000, (0x69, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_adc_bcd_on_immediate_6f_plus_00_carry_set(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p |= mpu.CARRY
        mpu.a = 0x6f
        # $0000 ADC #$00
        self._write(mpu.memory, 0x0000, (0x69, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x76, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_adc_bcd_on_immediate_9c_plus_9d(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x9c
        # $0000 ADC #$9d
        # $0002 ADC #$9d
        self._write(mpu.memory, 0x0000, (0x69, 0x9d))
        self._write(mpu.memory, 0x0002, (0x69, 0x9d))
        mpu.step()
        self.assertEqual(0x9f, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        mpu.step()
        self.assertEqual(0x0004, mpu.pc)
        self.assertEqual(0x93, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ADC Absolute, X-Indexed

    def test_adc_bcd_off_abs_x_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_x_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_abs_x_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0xFE
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_x_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.x = 0x03
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_x_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_x_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0xff
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_x_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_x_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0xff
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_x_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        mpu.x = 0x03
        # $0000 ADC $C000,X
        self._write(mpu.memory, 0x0000, (0x7D, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Absolute, Y-Indexed

    def test_adc_bcd_off_abs_y_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_y_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.y = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_abs_y_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        mpu.y = 0x03
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0xFE
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_y_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.y = 0x03
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_abs_y_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_y_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_y_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_y_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_abs_y_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        mpu.y = 0x03
        # $0000 ADC $C000,Y
        self._write(mpu.memory, 0x0000, (0x79, 0x00, 0xC0))
        mpu.memory[0xC000 + mpu.y] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Zero Page, X-Indexed

    def test_adc_bcd_off_zp_x_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_x_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_zp_x_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_x_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_x_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_x_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_x_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_x_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xff
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_x_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        mpu.x = 0x03
        # $0000 ADC $0010,X
        self._write(mpu.memory, 0x0000, (0x75, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Indirect, Indexed (X)

    def test_adc_bcd_off_ind_indexed_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_ind_indexed_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_ind_indexed_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_ind_indexed_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_ind_indexed_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_ind_indexed_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_ind_indexed_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_ind_indexed_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_ind_indexed_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        mpu.x = 0x03
        # $0000 ADC ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x61, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ADC Indexed, Indirect (Y)

    def test_adc_bcd_off_indexed_ind_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_indexed_ind_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.y = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_indexed_ind_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_indexed_ind_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_indexed_ind_overflow_clr_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.y = 0x03
        # $0000 $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_indexed_ind_overflow_clr_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_indexed_ind_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_indexed_ind_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        mpu.y = 0x03
        # $0000 $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_indexed_ind_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.a = 0x40
        mpu.y = 0x03
        # $0000 ADC ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x71, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND (Absolute)

    def test_and_absolute_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND $ABCD
        self._write(mpu.memory, 0x0000, (0x2D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_absolute_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND $ABCD
        self._write(mpu.memory, 0x0000, (0x2D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xAA
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND (Absolute)

    def test_and_zp_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND $0010
        self._write(mpu.memory, 0x0000, (0x25, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_zp_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND $0010
        self._write(mpu.memory, 0x0000, (0x25, 0x10))
        mpu.memory[0x0010] = 0xAA
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND (Immediate)

    def test_and_immediate_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND #$00
        self._write(mpu.memory, 0x0000, (0x29, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_immediate_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND #$AA
        self._write(mpu.memory, 0x0000, (0x29, 0xAA))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND (Absolute, X-Indexed)

    def test_and_abs_x_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3d, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_abs_x_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3d, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xAA
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND (Absolute, Y-Indexed)

    def test_and_abs_y_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 AND $ABCD,X
        self._write(mpu.memory, 0x0000, (0x39, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_abs_y_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 AND $ABCD,X
        self._write(mpu.memory, 0x0000, (0x39, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xAA
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND Indirect, Indexed (X)

    def test_and_ind_indexed_x_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x21, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_ind_indexed_x_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x21, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xAA
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND Indexed, Indirect (Y)

    def test_and_indexed_ind_y_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 AND ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x31, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_indexed_ind_y_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 AND ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x31, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xAA
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND Zero Page, X-Indexed

    def test_and_zp_x_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND $0010,X
        self._write(mpu.memory, 0x0000, (0x35, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_zp_x_all_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 AND $0010,X
        self._write(mpu.memory, 0x0000, (0x35, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xAA
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ASL Accumulator

    def test_asl_accumulator_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 ASL A
        mpu.memory[0x0000] = 0x0A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_asl_accumulator_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x40
        # $0000 ASL A
        mpu.memory[0x0000] = 0x0A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_asl_accumulator_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0x7F
        # $0000 ASL A
        mpu.memory[0x0000] = 0x0A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFE, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_asl_accumulator_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 ASL A
        mpu.memory[0x0000] = 0x0A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFE, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_asl_accumulator_80_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x80
        mpu.p &= ~(mpu.ZERO)
        # $0000 ASL A
        mpu.memory[0x0000] = 0x0A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # ASL Absolute

    def test_asl_absolute_sets_z_flag(self):
        mpu = self._make_mpu()
        # $0000 ASL $ABCD
        self._write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_asl_absolute_sets_n_flag(self):
        mpu = self._make_mpu()
        # $0000 ASL $ABCD
        self._write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_asl_absolute_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        # $0000 ASL $ABCD
        self._write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_asl_absolute_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        # $0000 ASL $ABCD
        self._write(mpu.memory, 0x0000, (0x0E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0xABCD])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ASL Zero Page

    def test_asl_zp_sets_z_flag(self):
        mpu = self._make_mpu()
        # $0000 ASL $0010
        self._write(mpu.memory, 0x0000, (0x06, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_asl_zp_sets_n_flag(self):
        mpu = self._make_mpu()
        # $0000 ASL $0010
        self._write(mpu.memory, 0x0000, (0x06, 0x10))
        mpu.memory[0x0010] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_asl_zp_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        # $0000 ASL $0010
        self._write(mpu.memory, 0x0000, (0x06, 0x10))
        mpu.memory[0x0010] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_asl_zp_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        # $0000 ASL $0010
        self._write(mpu.memory, 0x0000, (0x06, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0x0010])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ASL Absolute, X-Indexed

    def test_asl_abs_x_indexed_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        # $0000 ASL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_asl_abs_x_indexed_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        # $0000 ASL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_asl_abs_x_indexed_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        mpu.x = 0x03
        # $0000 ASL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_asl_abs_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0xAA
        mpu.x = 0x03
        # $0000 ASL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ASL Zero Page, X-Indexed

    def test_asl_zp_x_indexed_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        # $0000 ASL $0010,X
        self._write(mpu.memory, 0x0000, (0x16, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_asl_zp_x_indexed_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        # $0000 ASL $0010,X
        self._write(mpu.memory, 0x0000, (0x16, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_asl_zp_x_indexed_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.a = 0xAA
        # $0000 ASL $0010,X
        self._write(mpu.memory, 0x0000, (0x16, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_asl_zp_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.a = 0xAA
        # $0000 ASL $0010,X
        self._write(mpu.memory, 0x0000, (0x16, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # BCC

    def test_bcc_carry_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 BCC +6
        self._write(mpu.memory, 0x0000, (0x90, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bcc_carry_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        # $0000 BCC -6
        self._write(mpu.memory, 0x0050, (0x90, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bcc_carry_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 BCC +6
        self._write(mpu.memory, 0x0000, (0x90, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BCS

    def test_bcs_carry_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 BCS +6
        self._write(mpu.memory, 0x0000, (0xB0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bcs_carry_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        # $0000 BCS -6
        self._write(mpu.memory, 0x0050, (0xB0, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bcs_carry_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 BCS +6
        self._write(mpu.memory, 0x0000, (0xB0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BEQ

    def test_beq_zero_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0xF0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_beq_zero_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        # $0000 BEQ -6
        self._write(mpu.memory, 0x0050, (0xF0, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_beq_zero_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0xF0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BIT (Absolute)

    def test_bit_abs_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_bit_abs_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_bit_abs_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_bit_abs_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_bit_abs_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])

    def test_bit_abs_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x01
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0xFEED])

    def test_bit_abs_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT $FEED
        self._write(mpu.memory, 0x0000, (0x2C, 0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])

    # BIT (Zero Page)

    def test_bit_zp_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010])

    def test_bit_zp_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x01
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0x0010])

    def test_bit_zp_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT $0010
        self._write(mpu.memory, 0x0000, (0x24, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010])

    # BMI

    def test_bmi_negative_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BMI +06
        self._write(mpu.memory, 0x0000, (0x30, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bmi_negative_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        mpu.pc = 0x0050
        # $0000 BMI -6
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0x30, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bmi_negative_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BEQ +6
        self._write(mpu.memory, 0x0000, (0x30, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BNE

    def test_bne_zero_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BNE +6
        self._write(mpu.memory, 0x0000, (0xD0, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bne_zero_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.pc = 0x0050
        # $0050 BNE -6
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0xD0, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bne_zero_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BNE +6
        self._write(mpu.memory, 0x0000, (0xD0, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BPL

    def test_bpl_negative_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BPL +06
        self._write(mpu.memory, 0x0000, (0x10, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bpl_negative_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.pc = 0x0050
        # $0050 BPL -6
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        self._write(mpu.memory, 0x0050, (0x10, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bpl_negative_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BPL +6
        self._write(mpu.memory, 0x0000, (0x10, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BRK

    def test_brk_pushes_pc_plus_2_and_status_then_sets_pc_to_irq_vector(self):
        mpu = self._make_mpu()
        mpu.p = mpu.UNUSED
        self._write(mpu.memory, 0xFFFE, (0xCD, 0xAB))
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(0xABCD, mpu.pc)

        self.assertEqual(0xC0, mpu.memory[0x1FF])  # PCH
        self.assertEqual(0x02, mpu.memory[0x1FE])  # PCL
        self.assertEqual(mpu.BREAK | mpu.UNUSED, mpu.memory[0x1FD])  # Status
        self.assertEqual(0xFC, mpu.sp)

        self.assertEqual(mpu.BREAK | mpu.UNUSED | mpu.INTERRUPT, mpu.p)

    # BVC

    def test_bvc_overflow_clear_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BVC +6
        self._write(mpu.memory, 0x0000, (0x50, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bvc_overflow_clear_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        # $0050 BVC -6
        self._write(mpu.memory, 0x0050, (0x50, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bvc_overflow_set_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BVC +6
        self._write(mpu.memory, 0x0000, (0x50, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # BVS

    def test_bvs_overflow_set_branches_relative_forward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BVS +6
        self._write(mpu.memory, 0x0000, (0x70, 0x06))
        mpu.step()
        self.assertEqual(0x0002 + 0x06, mpu.pc)

    def test_bvs_overflow_set_branches_relative_backward(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        mpu.pc = 0x0050
        rel = (0x06 ^ 0xFF + 1)  # two's complement of 6
        # $0050 BVS -6
        self._write(mpu.memory, 0x0050, (0x70, rel))
        mpu.step()
        self.assertEqual(0x0052 + rel, mpu.pc)

    def test_bvs_overflow_clear_does_not_branch(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BVS +6
        self._write(mpu.memory, 0x0000, (0x70, 0x06))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)

    # CLC

    def test_clc_clears_carry_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 CLC
        mpu.memory[0x0000] = 0x18
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    # CLD

    def test_cld_clears_decimal_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        # $0000 CLD
        mpu.memory[0x0000] = 0xD8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.DECIMAL)

    # CLI

    def test_cli_clears_interrupt_mask_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.INTERRUPT
        # $0000 CLI
        mpu.memory[0x0000] = 0x58
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.INTERRUPT)

    # CLV

    def test_clv_clears_overflow_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 CLV
        mpu.memory[0x0000] = 0xB8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    # DEC Absolute

    def test_dec_abs_decrements_memory(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD
        self._write(mpu.memory, 0x0000, (0xCE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x10
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x0F, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dec_abs_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD
        self._write(mpu.memory, 0x0000, (0xCE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_dec_abs_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD
        self._write(mpu.memory, 0x0000, (0xCE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # DEC Zero Page

    def test_dec_zp_decrements_memory(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010
        self._write(mpu.memory, 0x0000, (0xC6, 0x10))
        mpu.memory[0x0010] = 0x10
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x0F, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dec_zp_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010
        self._write(mpu.memory, 0x0000, (0xC6, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_dec_zp_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010
        self._write(mpu.memory, 0x0000, (0xC6, 0x10))
        mpu.memory[0x0010] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # DEC Absolute, X-Indexed

    def test_dec_abs_x_decrements_memory(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD,X
        self._write(mpu.memory, 0x0000, (0xDE, 0xCD, 0xAB))
        mpu.x = 0x03
        mpu.memory[0xABCD + mpu.x] = 0x10
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x0F, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dec_abs_x_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD,X
        self._write(mpu.memory, 0x0000, (0xDE, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_dec_abs_x_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        # $0000 DEC 0xABCD,X
        self._write(mpu.memory, 0x0000, (0xDE, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # DEC Zero Page, X-Indexed

    def test_dec_zp_x_decrements_memory(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010,X
        self._write(mpu.memory, 0x0000, (0xD6, 0x10))
        mpu.x = 0x03
        mpu.memory[0x0010 + mpu.x] = 0x10
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x0F, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dec_zp_x_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010,X
        self._write(mpu.memory, 0x0000, (0xD6, 0x10))
        mpu.x = 0x03
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_dec_zp_x_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        # $0000 DEC 0x0010,X
        self._write(mpu.memory, 0x0000, (0xD6, 0x10))
        mpu.x = 0x03
        mpu.memory[0x0010 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # DEX

    def test_dex_decrements_x(self):
        mpu = self._make_mpu()
        mpu.x = 0x10
        # $0000 DEX
        mpu.memory[0x0000] = 0xCA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x0F, mpu.x)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dex_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        # $0000 DEX
        mpu.memory[0x0000] = 0xCA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFF, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dex_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x01
        # $0000 DEX
        mpu.memory[0x0000] = 0xCA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # DEY

    def test_dey_decrements_y(self):
        mpu = self._make_mpu()
        mpu.y = 0x10
        # $0000 DEY
        mpu.memory[0x0000] = 0x88
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x0F, mpu.y)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_dey_below_00_rolls_over_and_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        # $0000 DEY
        mpu.memory[0x0000] = 0x88
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFF, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_dey_sets_zero_flag_when_decrementing_to_zero(self):
        mpu = self._make_mpu()
        mpu.y = 0x01
        # $0000 DEY
        mpu.memory[0x0000] = 0x88
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # EOR Absolute

    def test_eor_absolute_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        self._write(mpu.memory, 0x0000, (0x4D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_absolute_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        self._write(mpu.memory, 0x0000, (0x4D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Zero Page

    def test_eor_zp_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        self._write(mpu.memory, 0x0000, (0x45, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_zp_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        self._write(mpu.memory, 0x0000, (0x45, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Immediate

    def test_eor_immediate_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        self._write(mpu.memory, 0x0000, (0x49, 0xFF))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_immediate_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        self._write(mpu.memory, 0x0000, (0x49, 0xFF))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Absolute, X-Indexed

    def test_eor_abs_x_indexed_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x5D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_abs_x_indexed_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x5D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Absolute, Y-Indexed

    def test_eor_abs_y_indexed_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        self._write(mpu.memory, 0x0000, (0x59, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_abs_y_indexed_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        self._write(mpu.memory, 0x0000, (0x59, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Indirect, Indexed (X)

    def test_eor_ind_indexed_x_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x41, 0x10))  # => EOR ($0010,X)
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))  # => Vector to $ABCD
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_ind_indexed_x_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x41, 0x10))  # => EOR ($0010,X)
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))  # => Vector to $ABCD
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Indexed, Indirect (Y)

    def test_eor_indexed_ind_y_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        self._write(mpu.memory, 0x0000, (0x51, 0x10))  # => EOR ($0010),Y
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))  # => Vector to $ABCD
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_indexed_ind_y_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        self._write(mpu.memory, 0x0000, (0x51, 0x10))  # => EOR ($0010),Y
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))  # => Vector to $ABCD
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # EOR Zero Page, X-Indexed

    def test_eor_zp_x_indexed_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x55, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_zp_x_indexed_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x55, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # INC Absolute

    def test_inc_abs_increments_memory(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xEE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x09
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x0A, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_abs_increments_memory_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xEE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_abs_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xEE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # INC Zero Page

    def test_inc_zp_increments_memory(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xE6, 0x10))
        mpu.memory[0x0010] = 0x09
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x0A, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_zp_increments_memory_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xE6, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_zp_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xE6, 0x10))
        mpu.memory[0x0010] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # INC Absolute, X-Indexed

    def test_inc_abs_x_increments_memory(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xFE, 0xCD, 0xAB))
        mpu.x = 0x03
        mpu.memory[0xABCD + mpu.x] = 0x09
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x0A, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_abs_x_increments_memory_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xFE, 0xCD, 0xAB))
        mpu.x = 0x03
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_abs_x_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xFE, 0xCD, 0xAB))
        mpu.x = 0x03
        mpu.memory[0xABCD + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # INC Zero Page, X-Indexed

    def test_inc_zp_x_increments_memory(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xF6, 0x10))
        mpu.x = 0x03
        mpu.memory[0x0010 + mpu.x] = 0x09
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x0A, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_zp_x_increments_memory_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xF6, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_zp_x_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x0000, (0xF6, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # INX

    def test_inx_increments_x(self):
        mpu = self._make_mpu()
        mpu.x = 0x09
        mpu.memory[0x0000] = 0xE8  # => INX
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x0A, mpu.x)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inx_above_FF_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        mpu.memory[0x0000] = 0xE8  # => INX
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_inx_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        mpu.x = 0x7f
        mpu.memory[0x0000] = 0xE8  # => INX
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # INY

    def test_iny_increments_y(self):
        mpu = self._make_mpu()
        mpu.y = 0x09
        mpu.memory[0x0000] = 0xC8  # => INY
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x0A, mpu.y)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_iny_above_FF_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        mpu.memory[0x0000] = 0xC8  # => INY
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_iny_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        mpu.y = 0x7f
        mpu.memory[0x0000] = 0xC8  # => INY
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # JMP Absolute

    def test_jmp_abs_jumps_to_absolute_address(self):
        mpu = self._make_mpu()
        # $0000 JMP $ABCD
        self._write(mpu.memory, 0x0000, (0x4C, 0xCD, 0xAB))
        mpu.step()
        self.assertEqual(0xABCD, mpu.pc)

    # JMP Indirect

    def test_jmp_ind_jumps_to_indirect_address(self):
        mpu = self._make_mpu()
        # $0000 JMP ($ABCD)
        self._write(mpu.memory, 0x0000, (0x6C, 0x00, 0x02))
        self._write(mpu.memory, 0x0200, (0xCD, 0xAB))
        mpu.step()
        self.assertEqual(0xABCD, mpu.pc)

    # JSR

    def test_jsr_pushes_pc_plus_2_and_sets_pc(self):
        mpu = self._make_mpu()
        # $C000 JSR $FFD2
        self._write(mpu.memory, 0xC000, (0x20, 0xD2, 0xFF))
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(0xFFD2, mpu.pc)
        self.assertEqual(0xFD,   mpu.sp)
        self.assertEqual(0xC0,   mpu.memory[0x01FF])  # PCH
        self.assertEqual(0x02,   mpu.memory[0x01FE])  # PCL+2

    # LDA Absolute

    def test_lda_absolute_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 LDA $ABCD
        self._write(mpu.memory, 0x0000, (0xAD, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_absolute_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 LDA $ABCD
        self._write(mpu.memory, 0x0000, (0xAD, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDA Zero Page

    def test_lda_zp_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 LDA $0010
        self._write(mpu.memory, 0x0000, (0xA5, 0x10))
        mpu.memory[0x0010] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_zp_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 LDA $0010
        self._write(mpu.memory, 0x0000, (0xA5, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDA Immediate

    def test_lda_immediate_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 LDA #$80
        self._write(mpu.memory, 0x0000, (0xA9, 0x80))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_immediate_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 LDA #$00
        self._write(mpu.memory, 0x0000, (0xA9, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDA Absolute, X-Indexed

    def test_lda_abs_x_indexed_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 LDA $ABCD,X
        self._write(mpu.memory, 0x0000, (0xBD, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_abs_x_indexed_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 LDA $ABCD,X
        self._write(mpu.memory, 0x0000, (0xBD, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lda_abs_x_indexed_does_not_page_wrap(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.x = 0xFF
        # $0000 LDA $0080,X
        self._write(mpu.memory, 0x0000, (0xBD, 0x80, 0x00))
        mpu.memory[0x0080 + mpu.x] = 0x42
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # LDA Absolute, Y-Indexed

    def test_lda_abs_y_indexed_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 LDA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0xB9, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_abs_y_indexed_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 LDA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0xB9, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lda_abs_y_indexed_does_not_page_wrap(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.y = 0xFF
        # $0000 LDA $0080,X
        self._write(mpu.memory, 0x0000, (0xB9, 0x80, 0x00))
        mpu.memory[0x0080 + mpu.y] = 0x42
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # LDA Indirect, Indexed (X)

    def test_lda_ind_indexed_x_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 LDA ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xA1, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_ind_indexed_x_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 LDA ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xA1, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDA Indexed, Indirect (Y)

    def test_lda_indexed_ind_y_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 LDA ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xB1, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_indexed_ind_y_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 LDA ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xB1, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDA Zero Page, X-Indexed

    def test_lda_zp_x_indexed_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 LDA $10,X
        self._write(mpu.memory, 0x0000, (0xB5, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_zp_x_indexed_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 LDA $10,X
        self._write(mpu.memory, 0x0000, (0xB5, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDX Absolute

    def test_ldx_absolute_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        # $0000 LDX $ABCD
        self._write(mpu.memory, 0x0000, (0xAE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldx_absolute_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        # $0000 LDX $ABCD
        self._write(mpu.memory, 0x0000, (0xAE, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDX Zero Page

    def test_ldx_zp_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        # $0000 LDX $0010
        self._write(mpu.memory, 0x0000, (0xA6, 0x10))
        mpu.memory[0x0010] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldx_zp_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        # $0000 LDX $0010
        self._write(mpu.memory, 0x0000, (0xA6, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDX Immediate

    def test_ldx_immediate_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        # $0000 LDX #$80
        self._write(mpu.memory, 0x0000, (0xA2, 0x80))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldx_immediate_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        # $0000 LDX #$00
        self._write(mpu.memory, 0x0000, (0xA2, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDX Absolute, Y-Indexed

    def test_ldx_abs_y_indexed_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        mpu.y = 0x03
        # $0000 LDX $ABCD,Y
        self._write(mpu.memory, 0x0000, (0xBE, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldx_abs_y_indexed_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        mpu.y = 0x03
        # $0000 LDX $ABCD,Y
        self._write(mpu.memory, 0x0000, (0xBE, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDX Zero Page, Y-Indexed

    def test_ldx_zp_y_indexed_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x00
        mpu.y = 0x03
        # $0000 LDX $0010,Y
        self._write(mpu.memory, 0x0000, (0xB6, 0x10))
        mpu.memory[0x0010 + mpu.y] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldx_zp_y_indexed_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0xFF
        mpu.y = 0x03
        # $0000 LDX $0010,Y
        self._write(mpu.memory, 0x0000, (0xB6, 0x10))
        mpu.memory[0x0010 + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDY Absolute

    def test_ldy_absolute_loads_y_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        # $0000 LDY $ABCD
        self._write(mpu.memory, 0x0000, (0xAC, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldy_absolute_loads_y_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        # $0000 LDY $ABCD
        self._write(mpu.memory, 0x0000, (0xAC, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDY Zero Page

    def test_ldy_zp_loads_y_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        # $0000 LDY $0010
        self._write(mpu.memory, 0x0000, (0xA4, 0x10))
        mpu.memory[0x0010] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldy_zp_loads_y_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        # $0000 LDY $0010
        self._write(mpu.memory, 0x0000, (0xA4, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDY Immediate

    def test_ldy_immediate_loads_y_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        # $0000 LDY #$80
        self._write(mpu.memory, 0x0000, (0xA0, 0x80))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldy_immediate_loads_y_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        # $0000 LDY #$00
        self._write(mpu.memory, 0x0000, (0xA0, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDY Absolute, X-Indexed

    def test_ldy_abs_x_indexed_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        mpu.x = 0x03
        # $0000 LDY $ABCD,X
        self._write(mpu.memory, 0x0000, (0xBC, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldy_abs_x_indexed_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        mpu.x = 0x03
        # $0000 LDY $ABCD,X
        self._write(mpu.memory, 0x0000, (0xBC, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LDY Zero Page, X-Indexed

    def test_ldy_zp_x_indexed_loads_x_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0x00
        mpu.x = 0x03
        # $0000 LDY $0010,X
        self._write(mpu.memory, 0x0000, (0xB4, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_ldy_zp_x_indexed_loads_x_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.y = 0xFF
        mpu.x = 0x03
        # $0000 LDY $0010,X
        self._write(mpu.memory, 0x0000, (0xB4, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LSR Accumulator

    def test_lsr_accumulator_rotates_in_zero_not_carry(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR A
        mpu.memory[0x0000] = (0x4A)
        mpu.a = 0x00
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_accumulator_sets_carry_and_zero_flags_after_rotation(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.CARRY
        # $0000 LSR A
        mpu.memory[0x0000] = (0x4A)
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_accumulator_rotates_bits_right(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR A
        mpu.memory[0x0000] = (0x4A)
        mpu.a = 0x04
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LSR Absolute

    def test_lsr_absolute_rotates_in_zero_not_carry(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR $ABCD
        self._write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_absolute_sets_carry_and_zero_flags_after_rotation(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.CARRY
        # $0000 LSR $ABCD
        self._write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_absolute_rotates_bits_right(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR $ABCD
        self._write(mpu.memory, 0x0000, (0x4E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x04
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x02, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LSR Zero Page

    def test_lsr_zp_rotates_in_zero_not_carry(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR $0010
        self._write(mpu.memory, 0x0000, (0x46, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_zp_sets_carry_and_zero_flags_after_rotation(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.CARRY
        # $0000 LSR $0010
        self._write(mpu.memory, 0x0000, (0x46, 0x10))
        mpu.memory[0x0010] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_zp_rotates_bits_right(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR $0010
        self._write(mpu.memory, 0x0000, (0x46, 0x10))
        mpu.memory[0x0010] = 0x04
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LSR Absolute, X-Indexed

    def test_lsr_abs_x_indexed_rotates_in_zero_not_carry(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        mpu.x = 0x03
        # $0000 LSR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_abs_x_indexed_sets_c_and_z_flags_after_rotation(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.CARRY
        mpu.x = 0x03
        # $0000 LSR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_abs_x_indexed_rotates_bits_right(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 LSR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x5E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x04
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x02, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # LSR Zero Page, X-Indexed

    def test_lsr_zp_x_indexed_rotates_in_zero_not_carry(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        mpu.x = 0x03
        # $0000 LSR $0010,X
        self._write(mpu.memory, 0x0000, (0x56, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_zp_x_indexed_sets_carry_and_zero_flags_after_rotation(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.CARRY
        mpu.x = 0x03
        # $0000 LSR $0010,X
        self._write(mpu.memory, 0x0000, (0x56, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_lsr_zp_x_indexed_rotates_bits_right(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        mpu.x = 0x03
        # $0000 LSR $0010,X
        self._write(mpu.memory, 0x0000, (0x56, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x04
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # NOP

    def test_nop_does_nothing(self):
        mpu = self._make_mpu()
        # $0000 NOP
        mpu.memory[0x0000] = 0xEA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)

    # ORA Absolute

    def test_ora_absolute_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 ORA $ABCD
        self._write(mpu.memory, 0x0000, (0x0D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_absolute_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        # $0000 ORA $ABCD
        self._write(mpu.memory, 0x0000, (0x0D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x82
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Zero Page

    def test_ora_zp_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 ORA $0010
        self._write(mpu.memory, 0x0000, (0x05, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_zp_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        # $0000 ORA $0010
        self._write(mpu.memory, 0x0000, (0x05, 0x10))
        mpu.memory[0x0010] = 0x82
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Immediate

    def test_ora_immediate_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 ORA #$00
        self._write(mpu.memory, 0x0000, (0x09, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_immediate_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        # $0000 ORA #$82
        self._write(mpu.memory, 0x0000, (0x09, 0x82))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Absolute, X

    def test_ora_abs_x_indexed_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ORA $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_abs_x_indexed_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        mpu.x = 0x03
        # $0000 ORA $ABCD,X
        self._write(mpu.memory, 0x0000, (0x1D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x82
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Absolute, Y

    def test_ora_abs_y_indexed_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 ORA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0x19, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_abs_y_indexed_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        mpu.y = 0x03
        # $0000 ORA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0x19, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x82
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Indirect, Indexed (X)

    def test_ora_ind_indexed_x_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ORA ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x01, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_ind_indexed_x_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        mpu.x = 0x03
        # $0000 ORA ($0010,X)
        # $0013 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x01, 0x10))
        self._write(mpu.memory, 0x0013, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x82
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Indexed, Indirect (Y)

    def test_ora_indexed_ind_y_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 ORA ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x11, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_indexed_ind_y_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        mpu.y = 0x03
        # $0000 ORA ($0010),Y
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x11, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x82
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # ORA Zero Page, X

    def test_ora_zp_x_indexed_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 ORA $0010,X
        self._write(mpu.memory, 0x0000, (0x15, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_zp_x_indexed_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        mpu.x = 0x03
        # $0000 ORA $0010,X
        self._write(mpu.memory, 0x0000, (0x15, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x82
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # PHA

    def test_pha_pushes_a_and_updates_sp(self):
        mpu = self._make_mpu()
        mpu.a = 0xAB
        # $0000 PHA
        mpu.memory[0x0000] = 0x48
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.memory[0x01FF])
        self.assertEqual(0xFE, mpu.sp)

    # PHP

    def test_php_pushes_processor_status_and_updates_sp(self):
        for flags in range(0x100):
            mpu = self._make_mpu()
            mpu.p = flags | mpu.BREAK | mpu.UNUSED
            # $0000 PHP
            mpu.memory[0x0000] = 0x08
            mpu.step()
            self.assertEqual(0x0001, mpu.pc)
            self.assertEqual((flags | mpu.BREAK | mpu.UNUSED),
                             mpu.memory[0x1FF])
            self.assertEqual(0xFE, mpu.sp)

    # PLA

    def test_pla_pulls_top_byte_from_stack_into_a_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLA
        mpu.memory[0x0000] = 0x68
        mpu.memory[0x01FF] = 0xAB
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB,   mpu.a)
        self.assertEqual(0xFF,   mpu.sp)

    # PLP

    def test_plp_pulls_top_byte_from_stack_into_flags_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLP
        mpu.memory[0x0000] = 0x28
        mpu.memory[0x01FF] = 0xBA  # must have BREAK and UNUSED set
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xBA,   mpu.p)
        self.assertEqual(0xFF,   mpu.sp)

    # ROL Accumulator

    def test_rol_accumulator_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_accumulator_80_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x80
        mpu.p &= ~(mpu.CARRY)
        mpu.p &= ~(mpu.ZERO)
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_accumulator_zero_and_carry_one_clears_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p |= mpu.CARRY
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_accumulator_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x40
        mpu.p |= mpu.CARRY
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x81, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_rol_accumulator_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0x7F
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFE, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_rol_accumulator_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL A
        mpu.memory[0x0000] = 0x2A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xFE, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROL Absolute

    def test_rol_absolute_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_absolute_80_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.p &= ~(mpu.ZERO)
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_absolute_zero_and_carry_one_clears_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p |= mpu.CARRY
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_absolute_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_rol_absolute_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_rol_absolute_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $ABCD
        self._write(mpu.memory, 0x0000, (0x2E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0xABCD])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROL Zero Page

    def test_rol_zp_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_80_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.p &= ~(mpu.ZERO)
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_zero_and_carry_one_clears_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p |= mpu.CARRY
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_rol_zp_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_rol_zp_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $0010
        self._write(mpu.memory, 0x0000, (0x26, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0x0010])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROL Absolute, X-Indexed

    def test_rol_abs_x_indexed_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.x = 0x03
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_abs_x_indexed_80_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.p &= ~(mpu.ZERO)
        mpu.x = 0x03
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_abs_x_indexed_zero_and_carry_one_clears_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x01, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_abs_x_indexed_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_rol_abs_x_indexed_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_rol_abs_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $ABCD,X
        self._write(mpu.memory, 0x0000, (0x3E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROL Zero Page, X-Indexed

    def test_rol_zp_x_indexed_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        # $0000 ROL $0010,X
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_x_indexed_80_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.p &= ~(mpu.ZERO)
        mpu.x = 0x03
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        # $0000 ROL $0010,X
        mpu.memory[0x0010 + mpu.x] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_x_indexed_zero_and_carry_one_clears_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        # $0000 ROL $0010,X
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x01, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_rol_zp_x_indexed_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROL $0010,X
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_rol_zp_x_indexed_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $0010,X
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x7F
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_rol_zp_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROL $0010,X
        self._write(mpu.memory, 0x0000, (0x36, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFE, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROR Accumulator

    def test_ror_accumulator_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROR A
        mpu.memory[0x0000] = 0x6A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_ror_accumulator_zero_and_carry_one_rotates_in_sets_n_flags(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.p |= mpu.CARRY
        # $0000 ROR A
        mpu.memory[0x0000] = 0x6A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_ror_accumulator_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        mpu.p |= mpu.CARRY
        # $0000 ROR A
        mpu.memory[0x0000] = 0x6A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x81, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_ror_accumulator_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.a = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR A
        mpu.memory[0x0000] = 0x6A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x81, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROR Absolute

    def test_ror_absolute_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROR $ABCD
        self._write(mpu.memory, 0x0000, (0x6E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_ror_absolute_zero_and_carry_one_rotates_in_sets_n_flags(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD
        self._write(mpu.memory, 0x0000, (0x6E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_ror_absolute_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD
        self._write(mpu.memory, 0x0000, (0x6E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x02
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_ror_absolute_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD
        self._write(mpu.memory, 0x0000, (0x6E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x03
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROR Zero Page

    def test_ror_zp_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROR $0010
        self._write(mpu.memory, 0x0000, (0x66, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_ror_zp_zero_and_carry_one_rotates_in_sets_n_flags(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010
        self._write(mpu.memory, 0x0000, (0x66, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_ror_zp_zero_absolute_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010
        self._write(mpu.memory, 0x0000, (0x66, 0x10))
        mpu.memory[0x0010] = 0x02
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_ror_zp_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010
        self._write(mpu.memory, 0x0000, (0x66, 0x10))
        mpu.memory[0x0010] = 0x03
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROR Absolute, X-Indexed

    def test_ror_abs_x_indexed_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x7E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_ror_abs_x_indexed_z_and_c_1_rotates_in_sets_n_flags(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x7E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_ror_abs_x_indexed_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x7E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x02
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_ror_abs_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $ABCD,X
        self._write(mpu.memory, 0x0000, (0x7E, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x03
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # ROR Zero Page, X-Indexed

    def test_ror_zp_x_indexed_zero_and_carry_zero_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p &= ~(mpu.CARRY)
        # $0000 ROR $0010,X
        self._write(mpu.memory, 0x0000, (0x76, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_ror_zp_x_indexed_zero_and_carry_one_rotates_in_sets_n_flags(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010,X
        self._write(mpu.memory, 0x0000, (0x76, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_ror_zp_x_indexed_zero_absolute_shifts_out_zero(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010,X
        self._write(mpu.memory, 0x0000, (0x76, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x02
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_ror_zp_x_indexed_shifts_out_one(self):
        mpu = self._make_mpu()
        mpu.x = 0x03
        mpu.p |= mpu.CARRY
        # $0000 ROR $0010,X
        self._write(mpu.memory, 0x0000, (0x76, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x03
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x81, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # RTI

    def test_rti_restores_status_and_pc_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 RTI
        mpu.memory[0x0000] = 0x40
        self._write(mpu.memory, 0x01FD, (0xFC, 0x03, 0xC0))  # Status, PCL, PCH
        mpu.sp = 0xFC

        mpu.step()
        self.assertEqual(0xC003, mpu.pc)
        self.assertEqual(0xFC,   mpu.p)
        self.assertEqual(0xFF,   mpu.sp)

    def test_rti_forces_break_and_unused_flags_high(self):
        mpu = self._make_mpu()
        # $0000 RTI
        mpu.memory[0x0000] = 0x40
        self._write(mpu.memory, 0x01FD, (0x00, 0x03, 0xC0))  # Status, PCL, PCH
        mpu.sp = 0xFC

        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(mpu.UNUSED, mpu.p & mpu.UNUSED)

    # RTS

    def test_rts_restores_pc_and_increments_then_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 RTS
        mpu.memory[0x0000] = 0x60
        self._write(mpu.memory, 0x01FE, (0x03, 0xC0))  # PCL, PCH
        mpu.pc = 0x0000
        mpu.sp = 0xFD

        mpu.step()
        self.assertEqual(0xC004, mpu.pc)
        self.assertEqual(0xFF,   mpu.sp)

    def test_rts_wraps_around_top_of_memory(self):
        mpu = self._make_mpu()
        # $1000 RTS
        mpu.memory[0x1000] = 0x60
        self._write(mpu.memory, 0x01FE, (0xFF, 0xFF))  # PCL, PCH
        mpu.pc = 0x1000
        mpu.sp = 0xFD

        mpu.step()
        self.assertEqual(0x0000, mpu.pc)
        self.assertEqual(0xFF,   mpu.sp)

    # SBC Absolute

    def test_sbc_abs_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC $ABCD
        self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC $ABCD
        self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC $ABCD
        self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC $ABCD
        self._write(mpu.memory, 0x0000, (0xED, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Zero Page

    def test_sbc_zp_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC $10
        self._write(mpu.memory, 0x0000, (0xE5, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC $10
        self._write(mpu.memory, 0x0000, (0xE5, 0x10))
        mpu.memory[0x0010] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # => SBC $10
        self._write(mpu.memory, 0x0000, (0xE5, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # => SBC $10
        self._write(mpu.memory, 0x0000, (0xE5, 0x10))
        mpu.memory[0x0010] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Immediate

    def test_sbc_imm_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xE9, 0x00))
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_imm_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC #$01
        self._write(mpu.memory, 0x0000, (0xE9, 0x01))
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_imm_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xE9, 0x00))
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_imm_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC #$02
        self._write(mpu.memory, 0x0000, (0xE9, 0x02))
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    def test_sbc_bcd_on_immediate_0a_minus_00_carry_set(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p |= mpu.CARRY
        mpu.a = 0x0a
        # $0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xe9, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x0a, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_sbc_bcd_on_immediate_9a_minus_00_carry_set(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p |= mpu.CARRY
        mpu.a = 0x9a
        #$0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xe9, 0x00))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x9a, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_sbc_bcd_on_immediate_00_minus_01_carry_set(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.p |= mpu.OVERFLOW
        mpu.p |= mpu.ZERO
        mpu.p |= mpu.CARRY
        mpu.a = 0x00
        # => $0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xe9, 0x01))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x99, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.CARRY)

    def test_sbc_bcd_on_immediate_20_minus_0a_carry_unset(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.DECIMAL
        mpu.a = 0x20
        # $0000 SBC #$00
        self._write(mpu.memory, 0x0000, (0xe9, 0x0a))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x1f, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # SBC Absolute, X-Indexed

    def test_sbc_abs_x_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC $FEE0,X
        self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
        mpu.x = 0x0D
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_x_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC $FEE0,X
        self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
        mpu.x = 0x0D
        mpu.memory[0xFEED] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_x_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC $FEE0,X
        self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
        mpu.x = 0x0D
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_x_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC $FEE0,X
        self._write(mpu.memory, 0x0000, (0xFD, 0xE0, 0xFE))
        mpu.x = 0x0D
        mpu.memory[0xFEED] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Absolute, Y-Indexed

    def test_sbc_abs_y_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC $FEE0,Y
        self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
        mpu.y = 0x0D
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_y_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC $FEE0,Y
        self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
        mpu.y = 0x0D
        mpu.memory[0xFEED] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_y_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC $FEE0,Y
        self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
        mpu.y = 0x0D
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_abs_y_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC $FEE0,Y
        self._write(mpu.memory, 0x0000, (0xF9, 0xE0, 0xFE))
        mpu.y = 0x0D
        mpu.memory[0xFEED] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Indirect, Indexed (X)

    def test_sbc_ind_x_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC ($10,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xE1, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.x = 0x03
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_x_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC ($10,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xE1, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.x = 0x03
        mpu.memory[0xFEED] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_x_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC ($10,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xE1, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.x = 0x03
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_x_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC ($10,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xE1, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.x = 0x03
        mpu.memory[0xFEED] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Indexed, Indirect (Y)

    def test_sbc_ind_y_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 SBC ($10),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF1, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_y_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC ($10),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF1, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_y_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC ($10),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF1, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_ind_y_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC ($10),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF1, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SBC Zero Page, X-Indexed

    def test_sbc_zp_x_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC $10,X
        self._write(mpu.memory, 0x0000, (0xF5, 0x10))
        mpu.x = 0x0D
        mpu.memory[0x001D] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_x_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC $10,X
        self._write(mpu.memory, 0x0000, (0xF5, 0x10))
        mpu.x = 0x0D
        mpu.memory[0x001D] = 0x01
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_x_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC $10,X
        self._write(mpu.memory, 0x0000, (0xF5, 0x10))
        mpu.x = 0x0D
        mpu.memory[0x001D] = 0x00
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_x_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC $10,X
        self._write(mpu.memory, 0x0000, (0xF5, 0x10))
        mpu.x = 0x0D
        mpu.memory[0x001D] = 0x02
        mpu.step()
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # SEC

    def test_sec_sets_carry_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        # $0000 SEC
        mpu.memory[0x0000] = 0x038
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    # SED

    def test_sed_sets_decimal_mode_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        # $0000 SED
        mpu.memory[0x0000] = 0xF8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(mpu.DECIMAL, mpu.p & mpu.DECIMAL)

    # SEI

    def test_sei_sets_interrupt_disable_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.INTERRUPT)
        # $0000 SEI
        mpu.memory[0x0000] = 0x78
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(mpu.INTERRUPT, mpu.p & mpu.INTERRUPT)

    # STA Absolute

    def test_sta_absolute_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        # $0000 STA $ABCD
        self._write(mpu.memory, 0x0000, (0x8D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_absolute_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 STA $ABCD
        self._write(mpu.memory, 0x0000, (0x8D, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Zero Page

    def test_sta_zp_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        # $0000 STA $0010
        self._write(mpu.memory, 0x0000, (0x85, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_zp_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 STA $0010
        self._write(mpu.memory, 0x0000, (0x85, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Absolute, X-Indexed

    def test_sta_abs_x_indexed_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 STA $ABCD,X
        self._write(mpu.memory, 0x0000, (0x9D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_abs_x_indexed_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 STA $ABCD,X
        self._write(mpu.memory, 0x0000, (0x9D, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.x])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Absolute, Y-Indexed

    def test_sta_abs_y_indexed_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 STA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0x99, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_abs_y_indexed_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 STA $ABCD,Y
        self._write(mpu.memory, 0x0000, (0x99, 0xCD, 0xAB))
        mpu.memory[0xABCD + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD + mpu.y])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Indirect, Indexed (X)

    def test_sta_ind_indexed_x_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 STA ($0010,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x81, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xFEED])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_ind_indexed_x_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 STA ($0010,X)
        # $0013 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x81, 0x10))
        self._write(mpu.memory, 0x0013, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Indexed, Indirect (Y)

    def test_sta_indexed_ind_y_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        mpu.y = 0x03
        # $0000 STA ($0010),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x91, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xFEED + mpu.y])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_indexed_ind_y_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0x03
        # $0000 STA ($0010),Y
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x91, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xFEED + mpu.y])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STA Zero Page, X-Indexed

    def test_sta_zp_x_indexed_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        mpu.x = 0x03
        # $0000 STA $0010,X
        self._write(mpu.memory, 0x0000, (0x95, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_zp_x_indexed_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0x03
        # $0000 STA $0010,X
        self._write(mpu.memory, 0x0000, (0x95, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # STX Absolute

    def test_stx_absolute_stores_x_leaves_x_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.x = 0xFF
        # $0000 STX $ABCD
        self._write(mpu.memory, 0x0000, (0x8E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(0xFF, mpu.x)
        self.assertEqual(flags, mpu.p)

    def test_stx_absolute_stores_x_leaves_x_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.x = 0x00
        # $0000 STX $ABCD
        self._write(mpu.memory, 0x0000, (0x8E, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(flags, mpu.p)

    # STX Zero Page

    def test_stx_zp_stores_x_leaves_x_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.x = 0xFF
        # $0000 STX $0010
        self._write(mpu.memory, 0x0000, (0x86, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(0xFF, mpu.x)
        self.assertEqual(flags, mpu.p)

    def test_stx_zp_stores_x_leaves_x_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.x = 0x00
        # $0000 STX $0010
        self._write(mpu.memory, 0x0000, (0x86, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(flags, mpu.p)

    # STX Zero Page, Y-Indexed

    def test_stx_zp_y_indexed_stores_x_leaves_x_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.x = 0xFF
        mpu.y = 0x03
        # $0000 STX $0010,Y
        self._write(mpu.memory, 0x0000, (0x96, 0x10))
        mpu.memory[0x0010 + mpu.y] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.y])
        self.assertEqual(0xFF, mpu.x)
        self.assertEqual(flags, mpu.p)

    def test_stx_zp_y_indexed_stores_x_leaves_x_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.x = 0x00
        mpu.y = 0x03
        # $0000 STX $0010,Y
        self._write(mpu.memory, 0x0000, (0x96, 0x10))
        mpu.memory[0x0010 + mpu.y] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.y])
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(flags, mpu.p)

    # STY Absolute

    def test_sty_absolute_stores_y_leaves_y_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.y = 0xFF
        # $0000 STY $ABCD
        self._write(mpu.memory, 0x0000, (0x8C, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(0xFF, mpu.y)
        self.assertEqual(flags, mpu.p)

    def test_sty_absolute_stores_y_leaves_y_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.y = 0x00
        # $0000 STY $ABCD
        self._write(mpu.memory, 0x0000, (0x8C, 0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0xABCD])
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(flags, mpu.p)

    # STY Zero Page

    def test_sty_zp_stores_y_leaves_y_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.y = 0xFF
        # $0000 STY $0010
        self._write(mpu.memory, 0x0000, (0x84, 0x10))
        mpu.memory[0x0010] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010])
        self.assertEqual(0xFF, mpu.y)
        self.assertEqual(flags, mpu.p)

    def test_sty_zp_stores_y_leaves_y_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.y = 0x00
        # $0000 STY $0010
        self._write(mpu.memory, 0x0000, (0x84, 0x10))
        mpu.memory[0x0010] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010])
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(flags, mpu.p)

    # STY Zero Page, X-Indexed

    def test_sty_zp_x_indexed_stores_y_leaves_y_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.y = 0xFF
        mpu.x = 0x03
        # $0000 STY $0010,X
        self._write(mpu.memory, 0x0000, (0x94, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0xFF, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0xFF, mpu.y)
        self.assertEqual(flags, mpu.p)

    def test_sty_zp_x_indexed_stores_y_leaves_y_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.y = 0x00
        mpu.x = 0x03
        # $0000 STY $0010,X
        self._write(mpu.memory, 0x0000, (0x94, 0x10))
        mpu.memory[0x0010 + mpu.x] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(flags, mpu.p)

    # TAX

    def test_tax_transfers_accumulator_into_x(self):
        mpu = self._make_mpu()
        mpu.a = 0xAB
        mpu.x = 0x00
        # $0000 TAX
        mpu.memory[0x0000] = 0xAA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.x)

    def test_tax_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x80
        mpu.x = 0x00
        # $0000 TAX
        mpu.memory[0x0000] = 0xAA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_tax_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.x = 0xFF
        # $0000 TAX
        mpu.memory[0x0000] = 0xAA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # TAY

    def test_tay_transfers_accumulator_into_y(self):
        mpu = self._make_mpu()
        mpu.a = 0xAB
        mpu.y = 0x00
        # $0000 TAY
        mpu.memory[0x0000] = 0xA8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.y)

    def test_tay_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x80
        mpu.y = 0x00
        # $0000 TAY
        mpu.memory[0x0000] = 0xA8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_tay_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0xFF
        # $0000 TAY
        mpu.memory[0x0000] = 0xA8
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # TSX

    def test_tsx_transfers_stack_pointer_into_x(self):
        mpu = self._make_mpu()
        mpu.sp = 0xAB
        mpu.x = 0x00
        # $0000 TSX
        mpu.memory[0x0000] = 0xBA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.sp)
        self.assertEqual(0xAB, mpu.x)

    def test_tsx_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.sp = 0x80
        mpu.x = 0x00
        # $0000 TSX
        mpu.memory[0x0000] = 0xBA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.sp)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_tsx_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.sp = 0x00
        mpu.y = 0xFF
        # $0000 TSX
        mpu.memory[0x0000] = 0xBA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.sp)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # TXA

    def test_txa_transfers_x_into_a(self):
        mpu = self._make_mpu()
        mpu.x = 0xAB
        mpu.a = 0x00
        # $0000 TXA
        mpu.memory[0x0000] = 0x8A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.x)

    def test_txa_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.x = 0x80
        mpu.a = 0x00
        # $0000 TXA
        mpu.memory[0x0000] = 0x8A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_txa_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.x = 0x00
        mpu.a = 0xFF
        # $0000 TXA
        mpu.memory[0x0000] = 0x8A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # TXS

    def test_txs_transfers_x_into_stack_pointer(self):
        mpu = self._make_mpu()
        mpu.x = 0xAB
        # $0000 TXS
        mpu.memory[0x0000] = 0x9A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.sp)
        self.assertEqual(0xAB, mpu.x)

    def test_txs_does_not_set_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.x = 0x80
        # $0000 TXS
        mpu.memory[0x0000] = 0x9A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.sp)
        self.assertEqual(0x80, mpu.x)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_txs_does_not_set_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.x = 0x00
        # $0000 TXS
        mpu.memory[0x0000] = 0x9A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.sp)
        self.assertEqual(0x00, mpu.x)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # TYA

    def test_tya_transfers_y_into_a(self):
        mpu = self._make_mpu()
        mpu.y = 0xAB
        mpu.a = 0x00
        # $0000 TYA
        mpu.memory[0x0000] = 0x98
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.a)
        self.assertEqual(0xAB, mpu.y)

    def test_tya_sets_negative_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.y = 0x80
        mpu.a = 0x00
        # $0000 TYA
        mpu.memory[0x0000] = 0x98
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0x80, mpu.y)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_tya_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.y = 0x00
        mpu.a = 0xFF
        # $0000 TYA
        mpu.memory[0x0000] = 0x98
        mpu.step()
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0x00, mpu.y)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0001, mpu.pc)

    def test_decorated_addressing_modes_are_valid(self):
        valid_modes = [x[0] for x in py65.assembler.Assembler.Addressing]
        mpu = self._make_mpu()
        for name, mode in mpu.disassemble:
            self.assertTrue(mode in valid_modes)

    def test_brk_interrupt(self):
        mpu = self._make_mpu()
        mpu.p = 0x00
        self._write(mpu.memory, 0xFFFE, (0x00, 0x04))

        self._write(mpu.memory, 0x0000, (0xA9, 0x01,   # LDA #$01
                                         0x00, 0xEA,   # BRK + skipped byte
                                         0xEA, 0xEA,   # NOP, NOP
                                         0xA9, 0x03))  # LDA #$03

        self._write(mpu.memory, 0x0400, (0xA9, 0x02,   # LDA #$02
                                         0x40))        # RTI

        mpu.step()  # LDA #$01
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x0002, mpu.pc)
        mpu.step()  # BRK
        self.assertEqual(0x0400, mpu.pc)
        mpu.step()  # LDA #$02
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0x0402, mpu.pc)
        mpu.step()  # RTI

        self.assertEqual(0x0004, mpu.pc)
        mpu.step()  # A NOP
        mpu.step()  # The second NOP

        mpu.step()  # LDA #$03
        self.assertEqual(0x03, mpu.a)
        self.assertEqual(0x0008, mpu.pc)

    # Test Helpers

    def _write(self, memory, start_address, bytes):
        memory[start_address:start_address + len(bytes)] = bytes

    def _make_mpu(self, *args, **kargs):
        klass = self._get_target_class()
        mpu = klass(*args, **kargs)
        if 'memory' not in kargs:
            mpu.memory = 0x10000 * [0xAA]
        return mpu

    def _get_target_class(self):
        raise NotImplementedError("Target class not specified")


class MPUTests(unittest.TestCase, Common6502Tests):
    """ NMOS 6502 tests """

    def test_repr(self):
        mpu = self._make_mpu()
        self.assertTrue("6502" in repr(mpu))

    # ADC Indirect, Indexed (X)

    def test_adc_ind_indexed_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.p = 0x00
        mpu.a = 0x01
        mpu.x = 0xFF
        # $0000 ADC ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self._write(mpu.memory, 0x0000, (0x61, 0x80))
        self._write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self._write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.memory[0xBBBB] = 0x02
        mpu.step()
        self.assertEqual(0x03, mpu.a)

    # ADC Indexed, Indirect (Y)

    def test_adc_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.p = 0
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 ADC ($FF),Y
        self._write(mpu.memory, 0x1000, (0x71, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x84, mpu.a)

    # LDA Zero Page, X-Indexed

    def test_lda_zp_x_indexed_page_wraps(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0xFF
        # $0000 LDA $80,X
        self._write(mpu.memory, 0x0000, (0xB5, 0x80))
        mpu.memory[0x007F] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # AND Indexed, Indirect (Y)

    def test_and_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 AND ($FF),Y
        self._write(mpu.memory, 0x1000, (0x31, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0xFF # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # BRK

    def test_brk_preserves_decimal_flag_when_it_is_set(self):
        mpu = self._make_mpu()
        mpu.p = mpu.DECIMAL
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(mpu.DECIMAL, mpu.p & mpu.DECIMAL)

    def test_brk_preserves_decimal_flag_when_it_is_clear(self):
        mpu = self._make_mpu()
        mpu.p = 0
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(0, mpu.p & mpu.DECIMAL)

    # CMP Indirect, Indexed (X)

    def test_cmp_ind_x_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.p = 0
        mpu.a = 0x42
        mpu.x = 0xFF
        # $0000 CMP ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self._write(mpu.memory, 0x0000, (0xC1, 0x80))
        self._write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self._write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.memory[0xBBBB] = 0x42
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # CMP Indexed, Indirect (Y)

    def test_cmp_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.p = 0
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 CMP ($FF),Y
        self._write(mpu.memory, 0x1000, (0xd1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    # EOR Indirect, Indexed (X)

    def test_eor_ind_x_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.p = 0
        mpu.a = 0xAA
        mpu.x = 0xFF
        # $0000 EOR ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self._write(mpu.memory, 0x0000, (0x41, 0x80))
        self._write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self._write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.memory[0xBBBB] = 0xFF
        mpu.step()
        self.assertEqual(0x55, mpu.a)

    # EOR Indexed, Indirect (Y)

    def test_eor_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.a = 0xAA
        mpu.y = 0x02
        # $1000 EOR ($FF),Y
        self._write(mpu.memory, 0x1000, (0x51, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0xFF # read if page wrapped
        mpu.step()
        self.assertEqual(0x55, mpu.a)

    # LDA Indirect, Indexed (X)

    def test_lda_ind_indexed_x_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0xff
        # $0000 LDA ($80,X)
        # $007f Vector to $BBBB (read if page wrapped)
        # $017f Vector to $ABCD (read if no page wrap)
        self._write(mpu.memory, 0x0000, (0xA1, 0x80))
        self._write(mpu.memory, 0x007f, (0xBB, 0xBB))
        self._write(mpu.memory, 0x017f, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x42
        mpu.memory[0xBBBB] = 0xEF
        mpu.step()
        self.assertEqual(0xEF, mpu.a)

    # LDA Indexed, Indirect (Y)

    def test_lda_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.a = 0x00
        mpu.y = 0x02
        # $1000 LDA ($FF),Y
        self._write(mpu.memory, 0x1000, (0xb1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x14 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # LDA Zero Page, X-Indexed

    def test_lda_zp_x_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        mpu.x = 0xFF
        # $0000 LDA $80,X
        self._write(mpu.memory, 0x0000, (0xB5, 0x80))
        mpu.memory[0x007F] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x42, mpu.a)

    # JMP Indirect

    def test_jmp_jumps_to_address_with_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.memory[0x00ff] = 0
        # $0000 JMP ($00)
        self._write(mpu.memory, 0, (0x6c, 0xff, 0x00))
        mpu.step()
        self.assertEqual(0x6c00, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    # ORA Indexed, Indirect (Y)

    def test_ora_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.a = 0x00
        mpu.y = 0x02
        # $1000 ORA ($FF),Y
        self._write(mpu.memory, 0x1000, (0x11, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x00 # read if no page wrap
        mpu.memory[0x0012] = 0x42 # read if page wrapped
        mpu.step()
        self.assertEqual(0x42, mpu.a)

    # SBC Indexed, Indirect (Y)

    def test_sbc_indexed_ind_y_has_page_wrap_bug(self):
        mpu = self._make_mpu()
        mpu.pc = 0x1000
        mpu.p = mpu.CARRY
        mpu.a = 0x42
        mpu.y = 0x02
        # $1000 SBC ($FF),Y
        self._write(mpu.memory, 0x1000, (0xf1, 0xff))
        # Vector
        mpu.memory[0x00ff] = 0x10 # low byte
        mpu.memory[0x0100] = 0x20 # high byte if no page wrap
        mpu.memory[0x0000] = 0x00 # high byte if page wrapped
        # Data
        mpu.memory[0x2012] = 0x02 # read if no page wrap
        mpu.memory[0x0012] = 0x03 # read if page wrapped
        mpu.step()
        self.assertEqual(0x3f, mpu.a)

    def _get_target_class(self):
        return py65.devices.mpu6502.MPU


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_mpu65c02
import unittest
import sys
import py65.devices.mpu65c02
from py65.tests.devices.test_mpu6502 import Common6502Tests


class MPUTests(unittest.TestCase, Common6502Tests):
    """CMOS 65C02 Tests"""

    def test_repr(self):
        mpu = self._make_mpu()
        self.assertTrue('65C02' in repr(mpu))

    # ADC Zero Page, Indirect

    def test_adc_bcd_off_zp_ind_carry_clear_in_accumulator_zeroes(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_ind_carry_set_in_accumulator_zero(self):
        mpu = self._make_mpu()
        mpu.a = 0
        mpu.p |= mpu.CARRY
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertNotEqual(mpu.CARRY, mpu.p & mpu.CARRY)

    def test_adc_bcd_off_zp_ind_carry_clear_in_no_carry_clear_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x01
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFE
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_ind_carry_clear_in_carry_set_out(self):
        mpu = self._make_mpu()
        mpu.a = 0x02
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(mpu.CARRY, mpu.p & mpu.CARRY)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_adc_bcd_off_zp_ind_overflow_cleared_no_carry_01_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x02, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_ind_overflow_cleared_no_carry_01_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x01
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_ind_overflow_set_no_carry_7f_plus_01(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x7f
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_ind_overflow_set_no_carry_80_plus_ff(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.CARRY)
        mpu.a = 0x80
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x7f, mpu.a)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_adc_bcd_off_zp_ind_overflow_set_on_40_plus_40(self):
        mpu = self._make_mpu()
        mpu.a = 0x40
        # $0000 ADC ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x72, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x40
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # AND Zero Page, Indirect

    def test_and_zp_ind_all_zeros_setting_zero_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x32, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_and_zp_ind_zeros_and_ones_setting_negative_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 AND ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x32, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xAA
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0xAA, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # BIT (Absolute, X-Indexed)

    def test_bit_abs_x_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_stores_result_of_and_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0x01
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0xFEED])
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    def test_bit_abs_x_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.x = 0x02
        # $0000 BIT $FEEB,X
        self._write(mpu.memory, 0x0000, (0x3C, 0xEB, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x0003, mpu.pc)

    # BIT (Immediate)

    def test_bit_imm_does_not_affect_n_and_z_flags(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE | mpu.OVERFLOW
        # $0000 BIT #$FF
        self._write(mpu.memory, 0x0000, (0x89, 0xff))
        mpu.a = 0x00
        mpu.step()
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(2, mpu.processorCycles)
        self.assertEqual(0x02, mpu.pc)

    def test_bit_imm_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT #$00
        self._write(mpu.memory, 0x0000, (0x89, 0x00))
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(2, mpu.processorCycles)
        self.assertEqual(0x02, mpu.pc)

    def test_bit_imm_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT #$01
        self._write(mpu.memory, 0x0000, (0x89, 0x01))
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(2, mpu.processorCycles)
        self.assertEqual(0x02, mpu.pc)

    def test_bit_imm_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT #$00
        self._write(mpu.memory, 0x0000, (0x89, 0x00))
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(2, mpu.processorCycles)
        self.assertEqual(0x02, mpu.pc)

    # BIT (Zero Page, X-Indexed)

    def test_bit_zp_x_copies_bit_7_of_memory_to_n_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0xFF
        mpu.x = 0x03
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_x_copies_bit_7_of_memory_to_n_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.NEGATIVE
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0x00
        mpu.x = 0x03
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_bit_zp_x_copies_bit_6_of_memory_to_v_flag_when_0(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.OVERFLOW)
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0xFF
        mpu.x = 0x03
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(mpu.OVERFLOW, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_x_copies_bit_6_of_memory_to_v_flag_when_1(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.OVERFLOW
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0x00
        mpu.x = 0x03
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0, mpu.p & mpu.OVERFLOW)

    def test_bit_zp_x_stores_result_of_and_in_z_preserves_a_when_1(self):
        mpu = self._make_mpu()
        mpu.p &= ~mpu.ZERO
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0x00
        mpu.x = 0x03
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])

    def test_bit_zp_x_stores_result_of_and_when_nonzero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p |= mpu.ZERO
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0x01
        mpu.x = 0x03
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)  # result of AND is non-zero
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x01, mpu.memory[0x0010 + mpu.x])

    def test_bit_zp_x_stores_result_of_and_when_zero_in_z_preserves_a(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        # $0000 BIT $0010,X
        self._write(mpu.memory, 0x0000, (0x34, 0x10))
        mpu.memory[0x0013] = 0x00
        mpu.x = 0x03
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)  # result of AND is zero
        self.assertEqual(0x01, mpu.a)
        self.assertEqual(0x00, mpu.memory[0x0010 + mpu.x])

    # BRK

    def test_brk_clears_decimal_flag(self):
        mpu = self._make_mpu()
        mpu.p = mpu.DECIMAL
        # $C000 BRK
        mpu.memory[0xC000] = 0x00
        mpu.pc = 0xC000
        mpu.step()
        self.assertEqual(mpu.BREAK, mpu.p & mpu.BREAK)
        self.assertEqual(0, mpu.p & mpu.DECIMAL)

    # CMP Zero Page, Indirect

    def test_cmp_zpi_sets_z_flag_if_equal(self):
        mpu = self._make_mpu()
        mpu.a = 0x42
        # $0000 AND ($10)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xd2, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x42, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_cmp_zpi_resets_z_flag_if_unequal(self):
        mpu = self._make_mpu()
        mpu.a = 0x43
        # $0000 AND ($10)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xd2, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x42
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x43, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # EOR Zero Page, Indirect

    def test_eor_zp_ind_flips_bits_over_setting_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0xFF
        # $0000 EOR ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x52, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_eor_zp_ind_flips_bits_over_setting_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 EOR ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x52, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(0xFF, mpu.memory[0xABCD])
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # INC Accumulator

    def test_inc_acc_increments_accum(self):
        mpu = self._make_mpu()
        mpu.memory[0x0000] = 0x1A
        mpu.a = 0x42
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x43, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_acc_increments_accum_rolls_over_and_sets_zero_flag(self):
        mpu = self._make_mpu()
        mpu.memory[0x0000] = 0x1A
        mpu.a = 0xFF
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    def test_inc_acc_sets_negative_flag_when_incrementing_above_7F(self):
        mpu = self._make_mpu()
        mpu.memory[0x0000] = 0x1A
        mpu.a = 0x7F
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)

    # JMP Indirect

    def test_jmp_ind_does_not_have_page_wrap_bug(self):
        mpu = self._make_mpu()
        self._write(mpu.memory, 0x10FF, (0xCD, 0xAB))
        # $0000 JMP ($10FF)
        self._write(mpu.memory, 0, (0x6c, 0xFF, 0x10))
        mpu.step()
        self.assertEqual(0xABCD, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    # JMP Indirect Absolute X-Indexed

    def test_jmp_iax_jumps_to_address(self):
        mpu = self._make_mpu()
        mpu.x = 2
        # $0000 JMP ($ABCD,X)
        # $ABCF Vector to $1234
        self._write(mpu.memory, 0x0000, (0x7C, 0xCD, 0xAB))
        self._write(mpu.memory, 0xABCF, (0x34, 0x12))
        mpu.step()
        self.assertEqual(0x1234, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    # LDA Zero Page, Indirect

    def test_lda_zp_ind_loads_a_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 LDA ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xB2, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x80
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x80, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    def test_lda_zp_ind_loads_a_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.a = 0x00
        # $0000 LDA ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0xB2, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)

    # ORA Zero Page, Indirect

    def test_ora_zp_ind_zeroes_or_zeros_sets_z_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.ZERO)
        mpu.a = 0x00
        mpu.y = 0x12  # These should not affect the ORA
        mpu.x = 0x34
        # $0000 ORA ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x12, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_ora_zp_ind_turns_bits_on_sets_n_flag(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.NEGATIVE)
        mpu.a = 0x03
        # $0000 ORA ($0010)
        # $0010 Vector to $ABCD
        self._write(mpu.memory, 0x0000, (0x12, 0x10))
        self._write(mpu.memory, 0x0010, (0xCD, 0xAB))
        mpu.memory[0xABCD] = 0x82
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x83, mpu.a)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)

    # PHX

    def test_phx_pushes_x_and_updates_sp(self):
        mpu = self._make_mpu()
        mpu.x = 0xAB
        # $0000 PHX
        mpu.memory[0x0000] = 0xDA
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.x)
        self.assertEqual(0xAB, mpu.memory[0x01FF])
        self.assertEqual(0xFE, mpu.sp)
        self.assertEqual(3, mpu.processorCycles)

    # PHY

    def test_phy_pushes_y_and_updates_sp(self):
        mpu = self._make_mpu()
        mpu.y = 0xAB
        # $0000 PHY
        mpu.memory[0x0000] = 0x5A
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB, mpu.y)
        self.assertEqual(0xAB, mpu.memory[0x01FF])
        self.assertEqual(0xFE, mpu.sp)
        self.assertEqual(3, mpu.processorCycles)

    # PLX

    def test_plx_pulls_top_byte_from_stack_into_x_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLX
        mpu.memory[0x0000] = 0xFA
        mpu.memory[0x01FF] = 0xAB
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB,   mpu.x)
        self.assertEqual(0xFF,   mpu.sp)
        self.assertEqual(4, mpu.processorCycles)

    # PLY

    def test_ply_pulls_top_byte_from_stack_into_y_and_updates_sp(self):
        mpu = self._make_mpu()
        # $0000 PLY
        mpu.memory[0x0000] = 0x7A
        mpu.memory[0x01FF] = 0xAB
        mpu.sp = 0xFE
        mpu.step()
        self.assertEqual(0x0001, mpu.pc)
        self.assertEqual(0xAB,   mpu.y)
        self.assertEqual(0xFF,   mpu.sp)
        self.assertEqual(4, mpu.processorCycles)

    # RMB0

    def test_rmb0_clears_bit_0_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB0 $43
        self._write(mpu.memory, 0x0000, (0x07, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11111110', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb0_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB0 $43
        self._write(mpu.memory, 0x0000, (0x07, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB1

    def test_rmb1_clears_bit_1_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB1 $43
        self._write(mpu.memory, 0x0000, (0x17, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11111101', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb1_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB1 $43
        self._write(mpu.memory, 0x0000, (0x17, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB2

    def test_rmb2_clears_bit_2_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB2 $43
        self._write(mpu.memory, 0x0000, (0x27, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11111011', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb2_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB2 $43
        self._write(mpu.memory, 0x0000, (0x27, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB3

    def test_rmb3_clears_bit_3_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB3 $43
        self._write(mpu.memory, 0x0000, (0x37, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11110111', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb3_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB3 $43
        self._write(mpu.memory, 0x0000, (0x37, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB4

    def test_rmb4_clears_bit_4_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB4 $43
        self._write(mpu.memory, 0x0000, (0x47, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11101111', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb4_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB4 $43
        self._write(mpu.memory, 0x0000, (0x47, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB5

    def test_rmb5_clears_bit_5_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB5 $43
        self._write(mpu.memory, 0x0000, (0x57, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('11011111', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb5_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB5 $43
        self._write(mpu.memory, 0x0000, (0x57, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB6

    def test_rmb6_clears_bit_6_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB6 $43
        self._write(mpu.memory, 0x0000, (0x67, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('10111111', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb6_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB6 $43
        self._write(mpu.memory, 0x0000, (0x67, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # RMB7

    def test_rmb7_clears_bit_7_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB7 $43
        self._write(mpu.memory, 0x0000, (0x77, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('01111111', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_rmb7_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('11111111', 2)
        # $0000 RMB7 $43
        self._write(mpu.memory, 0x0000, (0x77, 0x43))
        expected = int('01010101', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # STA Zero Page, Indirect

    def test_sta_zp_ind_stores_a_leaves_a_and_n_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.NEGATIVE)
        mpu.a = 0xFF
        # $0000 STA ($0010)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x92, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0xFF, mpu.memory[0xFEED])
        self.assertEqual(0xFF, mpu.a)
        self.assertEqual(flags, mpu.p)

    def test_sta_zp_ind_stores_a_leaves_a_and_z_flag_unchanged(self):
        mpu = self._make_mpu()
        mpu.p = flags = 0xFF & ~(mpu.ZERO)
        mpu.a = 0x00
        # $0000 STA ($0010)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0x92, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0xFF
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(flags, mpu.p)

    # SMB0

    def test_smb0_sets_bit_0_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB0 $43
        self._write(mpu.memory, 0x0000, (0x87, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00000001', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb0_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB0 $43
        self._write(mpu.memory, 0x0000, (0x87, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB1

    def test_smb1_sets_bit_1_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB1 $43
        self._write(mpu.memory, 0x0000, (0x97, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00000010', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb1_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB1 $43
        self._write(mpu.memory, 0x0000, (0x97, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB2

    def test_smb2_sets_bit_2_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB2 $43
        self._write(mpu.memory, 0x0000, (0xA7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00000100', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb2_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB2 $43
        self._write(mpu.memory, 0x0000, (0xA7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB3

    def test_smb3_sets_bit_3_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB3 $43
        self._write(mpu.memory, 0x0000, (0xB7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00001000', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb3_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB3 $43
        self._write(mpu.memory, 0x0000, (0xB7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB4

    def test_smb4_sets_bit_4_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB4 $43
        self._write(mpu.memory, 0x0000, (0xC7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00010000', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb4_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB4 $43
        self._write(mpu.memory, 0x0000, (0xC7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB5

    def test_smb5_sets_bit_5_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB5 $43
        self._write(mpu.memory, 0x0000, (0xD7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('00100000', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb5_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB5 $43
        self._write(mpu.memory, 0x0000, (0xD7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB6

    def test_smb6_sets_bit_6_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB6 $43
        self._write(mpu.memory, 0x0000, (0xE7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('01000000', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb6_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB6 $43
        self._write(mpu.memory, 0x0000, (0xE7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SMB7

    def test_smb7_sets_bit_7_without_affecting_other_bits(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB7 $43
        self._write(mpu.memory, 0x0000, (0xF7, 0x43))
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        expected = int('10000000', 2)
        self.assertEqual(expected, mpu.memory[0x0043])

    def test_smb7_does_not_affect_status_register(self):
        mpu = self._make_mpu()
        mpu.memory[0x0043] = int('00000000', 2)
        # $0000 SMB7 $43
        self._write(mpu.memory, 0x0000, (0xF7, 0x43))
        expected = int('11001100', 2)
        mpu.p = expected
        mpu.step()
        self.assertEqual(expected, mpu.p)

    # SBC Zero Page, Indirect

    def test_sbc_zp_ind_all_zeros_and_no_borrow_is_zero(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x00
        # $0000 SBC ($10)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF2, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_ind_downto_zero_no_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p |= mpu.CARRY  # borrow = 0
        mpu.a = 0x01
        # $0000 SBC ($10)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF2, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x01
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_ind_downto_zero_with_borrow_sets_z_clears_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x01
        # $0000 SBC ($10)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF2, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x00
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x00, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(mpu.CARRY, mpu.CARRY)
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)

    def test_sbc_zp_ind_downto_four_with_borrow_clears_z_n(self):
        mpu = self._make_mpu()
        mpu.p &= ~(mpu.DECIMAL)
        mpu.p &= ~(mpu.CARRY)  # borrow = 1
        mpu.a = 0x07
        # $0000 SBC ($10)
        # $0010 Vector to $FEED
        self._write(mpu.memory, 0x0000, (0xF2, 0x10))
        self._write(mpu.memory, 0x0010, (0xED, 0xFE))
        mpu.memory[0xFEED] = 0x02
        mpu.step()
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)
        self.assertEqual(0x04, mpu.a)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.CARRY, mpu.CARRY)

    # STZ Zero Page

    def test_stz_zp_stores_zero(self):
        mpu = self._make_mpu()
        mpu.memory[0x0032] = 0x88
        # #0000 STZ $32
        mpu.memory[0x0000:0x0000 + 2] = [0x64, 0x32]
        self.assertEqual(0x88, mpu.memory[0x0032])
        mpu.step()
        self.assertEqual(0x00, mpu.memory[0x0032])
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)

    # STZ Zero Page, X-Indexed

    def test_stz_zp_x_stores_zero(self):
        mpu = self._make_mpu()
        mpu.memory[0x0032] = 0x88
        # $0000 STZ $32,X
        mpu.memory[0x0000:0x0000 + 2] = [0x74, 0x32]
        self.assertEqual(0x88, mpu.memory[0x0032])
        mpu.step()
        self.assertEqual(0x00, mpu.memory[0x0032])
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)

    # STZ Absolute

    def test_stz_abs_stores_zero(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0x88
        # $0000 STZ $FEED
        mpu.memory[0x0000:0x0000 + 3] = [0x9C, 0xED, 0xFE]
        self.assertEqual(0x88, mpu.memory[0xFEED])
        mpu.step()
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(4, mpu.processorCycles)

    # STZ Absolute, X-Indexed

    def test_stz_abs_x_stores_zero(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0x88
        mpu.x = 0x0D
        # $0000 STZ $FEE0,X
        mpu.memory[0x0000:0x0000 + 3] = [0x9E, 0xE0, 0xFE]
        self.assertEqual(0x88, mpu.memory[0xFEED])
        self.assertEqual(0x0D, mpu.x)
        mpu.step()
        self.assertEqual(0x00, mpu.memory[0xFEED])
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    # TSB Zero Page

    def test_tsb_sp_ones(self):
        mpu = self._make_mpu()
        mpu.memory[0x00BB] = 0xE0
        # $0000 TSB $BD
        self._write(mpu.memory, 0x0000, [0x04, 0xBB])
        mpu.a = 0x70
        self.assertEqual(0xE0, mpu.memory[0x00BB])
        mpu.step()
        self.assertEqual(0xF0, mpu.memory[0x00BB])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    def test_tsb_sp_zeros(self):
        mpu = self._make_mpu()
        mpu.memory[0x00BB] = 0x80
        # $0000 TSB $BD
        self._write(mpu.memory, 0x0000, [0x04, 0xBB])
        mpu.a = 0x60
        self.assertEqual(0x80, mpu.memory[0x00BB])
        mpu.step()
        self.assertEqual(0xE0, mpu.memory[0x00BB])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    # TSB Absolute

    def test_tsb_abs_ones(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0xE0
        # $0000 TSB $FEED
        self._write(mpu.memory, 0x0000, [0x0C, 0xED, 0xFE])
        mpu.a = 0x70
        self.assertEqual(0xE0, mpu.memory[0xFEED])
        mpu.step()
        self.assertEqual(0xF0, mpu.memory[0xFEED])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    def test_tsb_abs_zeros(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0x80
        # $0000 TSB $FEED
        self._write(mpu.memory, 0x0000, [0x0C, 0xED, 0xFE])
        mpu.a = 0x60
        self.assertEqual(0x80, mpu.memory[0xFEED])
        mpu.step()
        self.assertEqual(0xE0, mpu.memory[0xFEED])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    # TRB Zero Page

    def test_trb_sp_ones(self):
        mpu = self._make_mpu()
        mpu.memory[0x00BB] = 0xE0
        # $0000 TRB $BD
        self._write(mpu.memory, 0x0000, [0x14, 0xBB])
        mpu.a = 0x70
        self.assertEqual(0xE0, mpu.memory[0x00BB])
        mpu.step()
        self.assertEqual(0x80, mpu.memory[0x00BB])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    def test_trb_sp_zeros(self):
        mpu = self._make_mpu()
        mpu.memory[0x00BB] = 0x80
        # $0000 TRB $BD
        self._write(mpu.memory, 0x0000, [0x14, 0xBB])
        mpu.a = 0x60
        self.assertEqual(0x80, mpu.memory[0x00BB])
        mpu.step()
        self.assertEqual(0x80, mpu.memory[0x00BB])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0x0002, mpu.pc)
        self.assertEqual(5, mpu.processorCycles)

    # TRB Absolute

    def test_trb_abs_ones(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0xE0
        # $0000 TRB $FEED
        self._write(mpu.memory, 0x0000, [0x1C, 0xED, 0xFE])
        mpu.a = 0x70
        self.assertEqual(0xE0, mpu.memory[0xFEED])
        mpu.step()
        self.assertEqual(0x80, mpu.memory[0xFEED])
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    def test_trb_abs_zeros(self):
        mpu = self._make_mpu()
        mpu.memory[0xFEED] = 0x80
        # $0000 TRB $FEED
        self._write(mpu.memory, 0x0000, [0x1C, 0xED, 0xFE])
        mpu.a = 0x60
        self.assertEqual(0x80, mpu.memory[0xFEED])
        mpu.step()
        self.assertEqual(0x80, mpu.memory[0xFEED])
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0x0003, mpu.pc)
        self.assertEqual(6, mpu.processorCycles)

    def test_dec_a_decreases_a(self):
        mpu = self._make_mpu()
        # $0000 DEC A
        self._write(mpu.memory, 0x0000, [0x3A])
        mpu.a = 0x48
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0x47, mpu.a)

    def test_dec_a_sets_zero_flag(self):
        mpu = self._make_mpu()
        # $0000 DEC A
        self._write(mpu.memory, 0x0000, [0x3A])
        mpu.a = 0x01
        mpu.step()
        self.assertEqual(mpu.ZERO, mpu.p & mpu.ZERO)
        self.assertEqual(0, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0x00, mpu.a)

    def test_dec_a_wraps_at_zero(self):
        mpu = self._make_mpu()
        # $0000 DEC A
        self._write(mpu.memory, 0x0000, [0x3A])
        mpu.a = 0x00
        mpu.step()
        self.assertEqual(0, mpu.p & mpu.ZERO)
        self.assertEqual(mpu.NEGATIVE, mpu.p & mpu.NEGATIVE)
        self.assertEqual(0xFF, mpu.a)

    def test_bra_forward(self):
        mpu = self._make_mpu()
        # $0000 BRA $10
        self._write(mpu.memory, 0x0000, [0x80, 0x10])
        mpu.step()
        self.assertEqual(0x12, mpu.pc)
        self.assertEqual(2, mpu.processorCycles)

    def test_bra_backward(self):
        mpu = self._make_mpu()
        # $0240 BRA $F0
        self._write(mpu.memory, 0x0204, [0x80, 0xF0])
        mpu.pc = 0x0204
        mpu.step()
        self.assertEqual(0x1F6, mpu.pc)
        self.assertEqual(3, mpu.processorCycles)  # Crossed boundry

    # Test Helpers

    def _get_target_class(self):
        return py65.devices.mpu65c02.MPU


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_assembler
import unittest
import sys
from py65.devices.mpu6502 import MPU
from py65.devices.mpu65c02 import MPU as MPU65C02
from py65.devices.mpu65org16 import MPU as MPU65Org16
from py65.assembler import Assembler
from py65.utils.addressing import AddressParser


class AssemblerTests(unittest.TestCase):
    def test_ctor_uses_provided_mpu_and_address_parser(self):
        mpu = MPU()
        address_parser = AddressParser()
        asm = Assembler(mpu, address_parser)
        self.assertTrue(asm._mpu is mpu)
        self.assertTrue(asm._address_parser is address_parser)

    def test_ctor_optionally_creates_address_parser(self):
        mpu = MPU()
        asm = Assembler(mpu)
        self.assertFalse(asm._address_parser is None)

    def test_ctor_uses_bus_width_from_mpu(self):
        asm = Assembler(MPU())
        self.assertEqual(16, asm.addrWidth)
        asm = Assembler(MPU65Org16())
        self.assertEqual(32, asm.addrWidth)

    def test_assemble_bad_syntax_raises_syntaxerror(self):
        self.assertRaises(SyntaxError,
                          self.assemble, 'foo')

    def test_assemble_bad_label_raises_keyerror(self):
        self.assertRaises(KeyError,
                          self.assemble, 'lda foo')

    def test_assemble_tolerates_extra_whitespace(self):
        self.assemble('   lda   #$00   ')  # should not raise

    def test_assemble_bad_number_raises_overflowerror(self):
        self.assertRaises(OverflowError,
                          self.assemble, 'lda #$fff')

    def test_assemble_1_byte_at_top_of_mem_should_not_overflow(self):
        self.assemble('nop', pc=0xFFFF)  # should not raise

    def test_assemble_3_bytes_at_top_of_mem_should_not_overflow(self):
        self.assemble('jmp $1234', pc=0xFFFD)  # should not raise

    def test_assemble_should_overflow_if_over_top_of_mem(self):
        # jmp $1234 requires 3 bytes but there's only 2 at $FFFE-FFFF
        self.assertRaises(OverflowError,
                          self.assemble, "jmp $1234", pc=0xFFFE)

    def test_assembles_00(self):
        self.assertEqual([0x00],
                         self.assemble('BRK'))

    def test_assembles_01(self):
        self.assertEqual([0x01, 0x44],
                         self.assemble('ORA ($44,X)'))

    def dont_test_assembles_02(self):
        pass

    def dont_test_assembles_03(self):
        pass

    def dont_test_assembles_04(self):
        pass

    def test_assembles_04_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x04, 0x42],
                         self.assemble('TSB $42', 0x0000, mpu))

    def test_assembles_05(self):
        self.assertEqual([0x05, 0x44],
                         self.assemble('ORA $44'))

    def test_assembles_06(self):
        self.assertEqual([0x06, 0x44],
                         self.assemble('ASL $44'))

    def test_assembles_07(self):
        self.assertRaises(SyntaxError,
                          self.assemble, "RMB0 $42")

    def test_assembles_07_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x07, 0x42],
                         self.assemble('RMB0 $42', 0x0000, mpu))

    def test_assembles_08(self):
        self.assertEqual([0x08],
                         self.assemble('PHP'))

    def test_assembles_09(self):
        self.assertEqual([0x09, 0x44],
                         self.assemble('ORA #$44'))

    def test_assembles_0a(self):
        self.assertEqual([0x0a],
                         self.assemble('ASL A'))

    def dont_test_assembles_0b(self):
        pass

    def dont_test_assembles_0c(self):
        pass

    def test_assembles_0c_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x0c, 0x34, 0x12],
                         self.assemble('TSB $1234', 0x0000, mpu))

    def test_assembles_0d(self):
        self.assertEqual([0x0d, 0x00, 0x44],
                         self.assemble('ORA $4400'))

    def test_assembles_0e(self):
        self.assertEqual([0x0e, 0x00, 0x44],
                         self.assemble('ASL $4400'))

    def dont_test_assembles_0f(self):
        pass

    def test_assembles_10(self):
        self.assertEqual([0x10, 0x44],
                         self.assemble('BPL $0046'))

    def test_assembles_11(self):
        self.assertEqual([0x11, 0x44],
                         self.assemble('ORA ($44),Y'))

    def dont_test_assembles_12(self):
        pass

    def test_assembles_12_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x12, 0x44],
                         self.assemble('ORA ($44)', 0x0000, mpu))

    def dont_test_assembles_13(self):
        pass

    def dont_test_assembles_14(self):
        pass

    def test_assembles_14_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x14, 0x42],
                         self.assemble('TRB $42', 0x0000, mpu))

    def test_assembles_15(self):
        self.assertEqual([0x15, 0x44],
                         self.assemble('ORA $44,X'))

    def test_assembles_16(self):
        self.assertEqual([0x16, 0x44],
                         self.assemble('ASL $44,X'))

    def dont_test_assembles_17(self):
        pass

    def test_assembles_17_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x17, 0x42],
                         self.assemble('RMB1 $42', 0x0000, mpu))

    def test_assembles_18(self):
        self.assertEqual([0x18],
                         self.assemble('CLC'))

    def test_assembles_19(self):
        self.assertEqual([0x19, 0x00, 0x44],
                         self.assemble('ORA $4400,Y'))

    def dont_test_assembles_1a(self):
        pass

    def test_assembles_1a_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x1a],
                         self.assemble('INC', 0x0000, mpu))

    def dont_test_assembles_1b(self):
        pass

    def test_assembles_1c(self):
        pass

    def test_assembles_1c_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x1c, 0x34, 0x12],
                         self.assemble('TRB $1234', 0x0000, mpu))

    def test_assembles_1d(self):
        self.assertEqual([0x1d, 0x00, 0x44],
                         self.assemble('ORA $4400,X'))

    def test_assembles_1e(self):
        self.assertEqual([0x1e, 0x00, 0x44],
                         self.assemble('ASL $4400,X'))

    def dont_test_assembles_1f(self):
        pass

    def test_assembles_20(self):
        self.assertEqual([0x20, 0x97, 0x55],
                         self.assemble('JSR $5597'))

    def test_assembles_21(self):
        self.assertEqual([0x21, 0x44],
                         self.assemble('AND ($44,X)'))

    def dont_test_assembles_22(self):
        pass

    def dont_test_assembles_23(self):
        pass

    def test_assembles_24(self):
        self.assertEqual([0x24, 0x44],
                         self.assemble('BIT $44'))

    def test_assembles_25(self):
        self.assertEqual([0x25, 0x44],
                         self.assemble('AND $44'))

    def test_assembles_26(self):
        self.assertEqual([0x26, 0x44],
                         self.assemble('ROL $44'))

    def dont_test_assembles_27(self):
        pass

    def test_assembles_27_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x27, 0x42],
                         self.assemble('RMB2 $42', 0x0000, mpu))

    def test_assembles_28(self):
        self.assertEqual([0x28],
                         self.assemble('PLP'))

    def test_assembles_29(self):
        self.assertEqual([0x29, 0x44],
                         self.assemble('AND #$44'))

    def test_assembles_2a(self):
        self.assertEqual([0x2a],
                         self.assemble('ROL A'))

    def dont_test_assembles_2b(self):
        pass

    def test_assembles_2c(self):
        self.assertEqual([0x2c, 0x00, 0x44],
                         self.assemble('BIT $4400'))

    def test_assembles_2d(self):
        self.assertEqual([0x2d, 0x00, 0x44],
                         self.assemble('AND $4400'))

    def test_assembles_2e(self):
        self.assertEqual([0x2e, 0x00, 0x44],
                         self.assemble('ROL $4400'))

    def dont_test_assembles_2f(self):
        pass

    def test_assembles_30(self):
        self.assertEqual([0x30, 0x44],
                         self.assemble('BMI $0046'))

    def test_assembles_31(self):
        self.assertEqual([0x31, 0x44],
                         self.assemble('AND ($44),Y'))

    def dont_test_assembles_32(self):
        pass

    def test_assembles_32_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x32, 0x44],
                         self.assemble('AND ($44)', 0x0000, mpu))

    def dont_test_assembles_33(self):
        pass

    def dont_test_assembles_34(self):
        pass

    def test_assembles_34_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x34, 0x44],
                         self.assemble('BIT $44,X', 0x0000, mpu))

    def test_assembles_35(self):
        self.assertEqual([0x35, 0x44],
                         self.assemble('AND $44,X'))

    def test_assembles_36(self):
        self.assertEqual([0x36, 0x44],
                         self.assemble('ROL $44,X'))

    def dont_test_assembles_37(self):
        pass

    def test_assembles_37_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x37, 0x42],
                         self.assemble('RMB3 $42', 0x0000, mpu))

    def test_assembles_38(self):
        self.assertEqual([0x38],
                         self.assemble('SEC'))

    def test_assembles_39(self):
        self.assertEqual([0x39, 0x00, 0x44],
                         self.assemble('AND $4400,Y'))

    def dont_test_assembles_3a(self):
        pass

    def test_assembles_3a_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x3a],
                         self.assemble('DEC', 0x0000, mpu))

    def dont_test_assembles_3b(self):
        pass

    def dont_test_assembles_3c(self):
        pass

    def test_assembles_3c_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x3c, 0x34, 0x12],
                         self.assemble('BIT $1234,X', 0x0000, mpu))

    def test_assembles_3d(self):
        self.assertEqual([0x3d, 0x00, 0x44],
                         self.assemble('AND $4400,X'))

    def test_assembles_3e(self):
        self.assertEqual([0x3e, 0x00, 0x44],
                         self.assemble('ROL $4400,X'))

    def dont_test_assembles_3f(self):
        pass

    def test_assembles_40(self):
        self.assertEqual([0x40],
                         self.assemble('RTI'))

    def test_assembles_41(self):
        self.assertEqual([0x41, 0x44],
                         self.assemble('EOR ($44,X)'))

    def dont_test_assembles_42(self):
        pass

    def dont_test_assembles_43(self):
        pass

    def dont_test_assembles_44(self):
        pass

    def test_assembles_45(self):
        self.assertEqual([0x45, 0x44],
                         self.assemble('EOR $44'))

    def test_assembles_46(self):
        self.assertEqual([0x46, 0x44],
                         self.assemble('LSR $44'))

    def dont_test_assembles_47(self):
        pass

    def test_assembles_47_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x47, 0x42],
                         self.assemble('RMB4 $42', 0x0000, mpu))

    def test_assembles_48(self):
        self.assertEqual([0x48],
                         self.assemble('PHA'))

    def test_assembles_49(self):
        self.assertEqual([0x49, 0x44],
                         self.assemble('EOR #$44'))

    def test_assembles_4a(self):
        self.assertEqual([0x4a],
                         self.assemble('LSR A'))

    def dont_test_assembles_4b(self):
        pass

    def test_assembles_4c(self):
        self.assertEqual([0x4c, 0x97, 0x55],
                         self.assemble('JMP $5597'))

    def test_assembles_4d(self):
        self.assertEqual([0x4d, 0x00, 0x44],
                         self.assemble('EOR $4400'))

    def test_assembles_4e(self):
        self.assertEqual([0x4e, 0x00, 0x44],
                         self.assemble('LSR $4400'))

    def dont_test_assembles_4f(self):
        pass

    def test_assembles_50(self):
        self.assertEqual([0x50, 0x44],
                         self.assemble('BVC $0046'))

    def test_assembles_51(self):
        self.assertEqual([0x51, 0x44],
                         self.assemble('EOR ($44),Y'))

    def dont_test_assembles_52(self):
        pass

    def test_assembles_52_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x52, 0x44],
                         self.assemble('EOR ($44)', 0x0000, mpu))

    def dont_test_assembles_53(self):
        pass

    def dont_test_assembles_54(self):
        pass

    def test_assembles_55(self):
        self.assertEqual([0x55, 0x44],
                         self.assemble('EOR $44,X'))

    def test_assembles_56(self):
        self.assertEqual([0x56, 0x44],
                         self.assemble('LSR $44,X'))

    def dont_test_assembles_57(self):
        pass

    def test_assembles_57_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x57, 0x42],
                         self.assemble('RMB5 $42', 0x0000, mpu))

    def test_assembles_58(self):
        self.assertEqual([0x58],
                         self.assemble('CLI'))

    def test_assembles_59(self):
        self.assertEqual([0x59, 0x00, 0x44],
                         self.assemble('EOR $4400,Y'))

    def dont_test_assembles_5a(self):
        pass

    def test_assembles_5a_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x5a],
                         self.assemble('PHY', 0x0000, mpu))

    def dont_test_assembles_5b(self):
        pass

    def dont_test_assembles_5c(self):
        pass

    def test_assembles_5d(self):
        self.assertEqual([0x5d, 0x00, 0x44],
                         self.assemble('EOR $4400,X'))

    def test_assembles_5e(self):
        self.assertEqual([0x5e, 0x00, 0x44],
                         self.assemble('LSR $4400,X'))

    def dont_test_assembles_5f(self):
        pass

    def test_assembles_60(self):
        self.assertEqual([0x60],
                         self.assemble('RTS'))

    def test_assembles_61(self):
        self.assertEqual([0x61, 0x44],
                         self.assemble('ADC ($44,X)'))

    def dont_test_assembles_62(self):
        pass

    def dont_test_assembles_63(self):
        pass

    def dont_test_assembles_64(self):
        pass

    def test_assembles_64_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x64],
                         self.assemble('STZ', 0x0000, mpu))

    def test_assembles_65(self):
        self.assertEqual([0x65, 0x44],
                         self.assemble('ADC $44'))

    def test_assembles_66(self):
        self.assertEqual([0x66, 0x44],
                         self.assemble('ROR $44'))

    def dont_test_assembles_67(self):
        pass

    def test_assembles_67_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x67, 0x42],
                         self.assemble('RMB6 $42', 0x0000, mpu))

    def test_assembles_68(self):
        self.assertEqual([0x68],
                         self.assemble('PLA'))

    def test_assembles_69(self):
        self.assertEqual([0x69, 0x44],
                         self.assemble('ADC #$44'))

    def test_assembles_6a(self):
        self.assertEqual([0x6a],
                         self.assemble('ROR A'))

    def dont_test_assembles_6b(self):
        pass

    def test_assembles_6c(self):
        self.assertEqual([0x6c, 0x97, 0x55],
                         self.assemble('JMP ($5597)'))

    def test_assembles_6d(self):
        self.assertEqual([0x6d, 0x00, 0x44],
                         self.assemble('ADC $4400'))

    def test_assembles_6e(self):
        self.assertEqual([0x6e, 0x00, 0x44],
                         self.assemble('ROR $4400'))

    def dont_test_assembles_6f(self):
        pass

    def test_assembles_70(self):
        self.assertEqual([0x70, 0x44],
                         self.assemble('BVS $0046'))

    def test_assembles_71(self):
        self.assertEqual([0x71, 0x44],
                         self.assemble('ADC ($44),Y'))

    def dont_test_assembles_72(self):
        pass

    def test_assembles_72_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x72, 0x44],
                         self.assemble('ADC ($44)', 0x0000, mpu))

    def dont_test_assembles_73(self):
        pass

    def dont_test_assembles_74(self):
        pass

    def test_assembles_74_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x74, 0x44],
                         self.assemble('STZ $44,X', 0x0000, mpu))

    def test_assembles_75(self):
        self.assertEqual([0x75, 0x44],
                         self.assemble('ADC $44,X'))

    def test_assembles_76(self):
        self.assertEqual([0x76, 0x44],
                         self.assemble('ROR $44,X'))

    def test_assembles_77(self):
        pass

    def test_assembles_77_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x77, 0x42],
                         self.assemble('RMB7 $42', 0x0000, mpu))

    def test_assembles_78(self):
        self.assertEqual([0x78],
                         self.assemble('SEI'))

    def test_assembles_79(self):
        self.assertEqual([0x79, 0x00, 0x44],
                         self.assemble('ADC $4400,Y'))

    def dont_test_assembles_7a(self):
        pass

    def test_assembles_7a_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x7a],
                         self.assemble('PLY', 0x0000, mpu))

    def dont_test_assembles_7b(self):
        pass

    def test_assembles_7c_6502(self):
        self.assertRaises(SyntaxError,
                          self.assemble, "JMP ($1234,X)")

    def test_assembles_7c_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x7c, 0x34, 0x12],
                         self.assemble('JMP ($1234,X)', 0x0000, mpu))

    def test_assembles_7d(self):
        self.assertEqual([0x7d, 0x00, 0x44],
                         self.assemble('ADC $4400,X'))

    def test_assembles_7e(self):
        self.assertEqual([0x7e, 0x00, 0x44],
                         self.assemble('ROR $4400,X'))

    def dont_test_assembles_7f(self):
        pass

    def dont_test_assembles_80(self):
        pass

    def test_assembles_80_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x80, 0x44],
                         self.assemble('BRA $0046', 0x0000, mpu))

    def test_assembles_81(self):
        self.assertEqual([0x81, 0x44],
                         self.assemble('STA ($44,X)'))

    def dont_test_assembles_82(self):
        pass

    def dont_test_assembles_83(self):
        pass

    def test_assembles_84(self):
        self.assertEqual([0x84, 0x44],
                         self.assemble('STY $44'))

    def test_assembles_85(self):
        self.assertEqual([0x85, 0x44],
                         self.assemble('STA $44'))

    def test_assembles_86(self):
        self.assertEqual([0x86, 0x44],
                         self.assemble('STX $44'))

    def dont_test_assembles_87(self):
        pass

    def test_assembles_87_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x87, 0x42],
                         self.assemble('SMB0 $42', 0x0000, mpu))

    def test_assembles_88(self):
        self.assertEqual([0x88],
                         self.assemble('DEY'))

    def dont_test_assembles_89(self):
        pass

    def test_assembles_89_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x89, 0x42],
                         self.assemble('BIT #$42', 0x0000, mpu))

    def test_assembles_8a(self):
        self.assertEqual([0x8a],
                         self.assemble('TXA'))

    def dont_test_assembles_8b(self):
        pass

    def test_assembles_8c(self):
        self.assertEqual([0x8c, 0x00, 0x44],
                         self.assemble('STY $4400'))

    def test_assembles_8d(self):
        self.assertEqual([0x8d, 0x00, 0x44],
                         self.assemble('STA $4400'))

    def test_assembles_8e(self):
        self.assertEqual([0x8e, 0x00, 0x44],
                         self.assemble('STX $4400'))

    def dont_test_assembles_8f(self):
        pass

    def test_assembles_90(self):
        self.assertEqual([0x90, 0x44],
                         self.assemble('BCC $0046'))

    def test_assembles_91(self):
        self.assertEqual([0x91, 0x44],
                         self.assemble('STA ($44),Y'))

    def dont_test_assembles_92(self):
        pass

    def test_assembles_92_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x92, 0x44],
                         self.assemble('STA ($44)', 0x0000, mpu))

    def dont_test_assembles_93(self):
        pass

    def test_assembles_94(self):
        self.assertEqual([0x94, 0x44],
                         self.assemble('STY $44,X'))

    def test_assembles_95(self):
        self.assertEqual([0x95, 0x44],
                         self.assemble('STA $44,X'))

    def test_assembles_96(self):
        self.assertEqual([0x96, 0x44],
                         self.assemble('STX $44,Y'))

    def dont_test_assembles_97(self):
        pass

    def test_assembles_97_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x97, 0x42],
                         self.assemble('SMB1 $42', 0x0000, mpu))

    def test_assembles_98(self):
        self.assertEqual([0x98],
                         self.assemble('TYA'))

    def test_assembles_99(self):
        self.assertEqual([0x99, 0x00, 0x44],
                         self.assemble('STA $4400,Y'))

    def test_assembles_9a(self):
        self.assertEqual([0x9a],
                         self.assemble('TXS'))

    def dont_test_assembles_9b(self):
        pass

    def dont_test_assembles_9c(self):
        pass

    def test_assembles_9c_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x9c, 0x34, 0x12],
                         self.assemble('STZ $1234', 0x0000, mpu))

    def test_assembles_9d(self):
        self.assertEqual([0x9d, 0x00, 0x44],
                         self.assemble('STA $4400,X'))

    def dont_test_assembles_9e(self):
        pass

    def test_assembles_9e_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0x9e, 0x34, 0x12],
                         self.assemble('STZ $1234,X', 0x0000, mpu))

    def dont_test_assembles_9f(self):
        pass

    def test_assembles_a0(self):
        self.assertEqual([0xa0, 0x44],
                         self.assemble('LDY #$44'))

    def test_assembles_a1(self):
        self.assertEqual([0xa1, 0x44],
                         self.assemble('LDA ($44,X)'))

    def test_assembles_a2(self):
        self.assertEqual([0xa2, 0x44],
                         self.assemble('LDX #$44'))

    def dont_test_assembles_a3(self):
        pass

    def test_assembles_a4(self):
        self.assertEqual([0xa4, 0x44],
                         self.assemble('LDY $44'))

    def test_assembles_a5(self):
        self.assertEqual([0xa5, 0x44],
                         self.assemble('LDA $44'))

    def test_assembles_a6(self):
        self.assertEqual([0xa6, 0x44],
                         self.assemble('LDX $44'))

    def dont_test_assembles_a7(self):
        pass

    def test_assembles_a7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xa7, 0x42],
                         self.assemble('SMB2 $42', 0x0000, mpu))

    def test_assembles_a8(self):
        self.assertEqual([0xa8],
                         self.assemble('TAY'))

    def test_assembles_a9(self):
        self.assertEqual([0xa9, 0x44],
                         self.assemble('LDA #$44'))

    def test_assembles_aa(self):
        self.assertEqual([0xaa],
                         self.assemble('TAX'))

    def dont_test_assembles_ab(self):
        pass

    def test_assembles_ac(self):
        self.assertEqual([0xac, 0x00, 0x44],
                         self.assemble('LDY $4400'))

    def test_assembles_ad(self):
        self.assertEqual([0xad, 0x00, 0x44],
                         self.assemble('LDA $4400'))

    def test_assembles_ae(self):
        self.assertEqual([0xae, 0x00, 0x44],
                         self.assemble('LDX $4400'))

    def dont_test_assembles_af(self):
        pass

    def test_assembles_b0(self):
        self.assertEqual([0xb0, 0x44],
                         self.assemble('BCS $0046'))

    def test_assembles_b1(self):
        self.assertEqual([0xb1, 0x44],
                         self.assemble('LDA ($44),Y'))

    def dont_test_assembles_b2(self):
        pass

    def test_assembles_b2_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xb2, 0x44],
                         self.assemble('LDA ($44)', 0x0000, mpu))

    def dont_test_assembles_b3(self):
        pass

    def test_assembles_b4(self):
        self.assertEqual([0xb4, 0x44],
                         self.assemble('LDY $44,X'))

    def test_assembles_b5(self):
        self.assertEqual([0xb5, 0x44],
                         self.assemble('LDA $44,X'))

    def test_assembles_b6(self):
        self.assertEqual([0xb6, 0x44],
                         self.assemble('LDX $44,Y'))

    def dont_test_assembles_b7(self):
        pass

    def test_assembles_b7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xb7, 0x42],
                         self.assemble('SMB3 $42', 0x0000, mpu))

    def test_assembles_b8(self):
        self.assertEqual([0xb8],
                         self.assemble('CLV'))

    def test_assembles_b9(self):
        self.assertEqual([0xb9, 0x00, 0x44],
                         self.assemble('LDA $4400,Y'))

    def test_assembles_ba(self):
        self.assertEqual([0xba],
                         self.assemble('TSX'))

    def dont_test_assembles_bb(self):
        pass

    def test_assembles_bc(self):
        self.assertEqual([0xbc, 0x00, 0x44],
                         self.assemble('LDY $4400,X'))

    def test_assembles_bd(self):
        self.assertEqual([0xbd, 0x00, 0x44],
                         self.assemble('LDA $4400,X'))

    def test_assembles_be(self):
        self.assertEqual([0xbe, 0x00, 0x44],
                         self.assemble('LDX $4400,Y'))

    def dont_test_assembles_bf(self):
        pass

    def test_assembles_c0(self):
        self.assertEqual([0xc0, 0x44],
                         self.assemble('CPY #$44'))

    def test_assembles_c1(self):
        self.assertEqual([0xc1, 0x44],
                         self.assemble('CMP ($44,X)'))

    def dont_test_assembles_c2(self):
        pass

    def dont_test_assembles_c3(self):
        pass

    def test_assembles_c4(self):
        self.assertEqual([0xc4, 0x44],
                         self.assemble('CPY $44'))

    def test_assembles_c5(self):
        self.assertEqual([0xc5, 0x44],
                         self.assemble('CMP $44'))

    def test_assembles_c6(self):
        self.assertEqual([0xc6, 0x44],
                         self.assemble('DEC $44'))

    def dont_test_assembles_c7(self):
        pass

    def test_assembles_c7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xc7, 0x42],
                         self.assemble('SMB4 $42', 0x0000, mpu))

    def test_assembles_c8(self):
        self.assertEqual([0xc8],
                         self.assemble('INY'))

    def test_assembles_c9(self):
        self.assertEqual([0xc9, 0x44],
                         self.assemble('CMP #$44'))

    def test_assembles_ca(self):
        self.assertEqual([0xca],
                         self.assemble('DEX'))

    def dont_test_assembles_cb(self):
        pass

    def test_assembles_cb_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xcb],
                         self.assemble('WAI', 0x0000, mpu))

    def test_assembles_cc(self):
        self.assertEqual([0xcc, 0x00, 0x44],
                         self.assemble('CPY $4400'))

    def test_assembles_cd(self):
        self.assertEqual([0xcd, 0x00, 0x44],
                         self.assemble('CMP $4400'))

    def test_assembles_ce(self):
        self.assertEqual([0xce, 0x00, 0x44],
                         self.assemble('DEC $4400'))

    def dont_test_assembles_cf(self):
        pass

    def test_assembles_d0(self):
        self.assertEqual([0xd0, 0x44],
                         self.assemble('BNE $0046'))

    def test_assembles_d1(self):
        self.assertEqual([0xd1, 0x44],
                         self.assemble('CMP ($44),Y'))

    def dont_test_assembles_d2(self):
        pass

    def test_assembles_d2_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xd2, 0x42],
                         self.assemble('CMP ($42)', 0x0000, mpu))

    def dont_test_assembles_d3(self):
        pass

    def dont_test_assembles_d4(self):
        pass

    def test_assembles_d5(self):
        self.assertEqual([0xd5, 0x44],
                         self.assemble('CMP $44,X'))

    def test_assembles_d6(self):
        self.assertEqual([0xd6, 0x44],
                         self.assemble('DEC $44,X'))

    def dont_test_assembles_d7(self):
        pass

    def test_assembles_d7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xd7, 0x42],
                         self.assemble('SMB5 $42', 0x0000, mpu))

    def test_assembles_d8(self):
        self.assertEqual([0xd8],
                         self.assemble('CLD'))

    def dont_test_assembles_da(self):
        pass

    def test_assembles_da_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xda],
                         self.assemble('PHX', 0x0000, mpu))

    def dont_test_assembles_db(self):
        pass

    def dont_test_assembles_dc(self):
        pass

    def test_assembles_dd(self):
        self.assertEqual([0xdd, 0x00, 0x44],
                         self.assemble('CMP $4400,X'))

    def test_assembles_de(self):
        self.assertEqual([0xde, 0x00, 0x44],
                         self.assemble('DEC $4400,X'))

    def dont_test_assembles_df(self):
        pass

    def test_assembles_e0(self):
        self.assertEqual([0xe0, 0x44],
                         self.assemble('CPX #$44'))

    def test_assembles_e1(self):
        self.assertEqual([0xe1, 0x44],
                         self.assemble('SBC ($44,X)'))

    def dont_test_assembles_e2(self):
        pass

    def dont_test_assembles_e3(self):
        pass

    def test_assembles_e4(self):
        self.assertEqual([0xe4, 0x44],
                         self.assemble('CPX $44'))

    def test_assembles_e5(self):
        self.assertEqual([0xe5, 0x44],
                         self.assemble('SBC $44'))

    def test_assembles_e6(self):
        self.assertEqual([0xe6, 0x44],
                         self.assemble('INC $44'))

    def dont_test_assembles_e7(self):
        pass

    def test_assembles_e7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xe7, 0x42],
                         self.assemble('SMB6 $42', 0x0000, mpu))

    def test_assembles_e8(self):
        self.assertEqual([0xe8],
                         self.assemble('INX'))

    def test_assembles_e9(self):
        self.assertEqual([0xe9, 0x44],
                         self.assemble('SBC #$44'))

    def test_assembles_ea(self):
        self.assertEqual([0xea],
                         self.assemble('NOP'))

    def dont_test_assembles_eb(self):
        pass

    def test_assembles_ec(self):
        self.assertEqual([0xec, 0x00, 0x44],
                         self.assemble('CPX $4400'))

    def test_assembles_ed(self):
        self.assertEqual([0xed, 0x00, 0x44],
                         self.assemble('SBC $4400'))

    def test_assembles_ee(self):
        self.assertEqual([0xee, 0x00, 0x44],
                         self.assemble('INC $4400'))

    def dont_test_assembles_ef(self):
        pass

    def test_assembles_f0_forward(self):
        self.assertEqual([0xf0, 0x44],
                         self.assemble('BEQ $0046'))

    def test_assembles_f0_backward(self):
        self.assertEqual([0xf0, 0xfc],
                         self.assemble('BEQ $BFFE', pc=0xc000))

    def test_assembles_f1(self):
        self.assertEqual([0xf1, 0x44],
                         self.assemble('SBC ($44),Y'))

    def dont_test_assembles_f2(self):
        pass

    def test_assembles_f2_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xf2, 0x42],
                         self.assemble('SBC ($42)', 0x0000, mpu))

    def dont_test_assembles_f3(self):
        pass

    def dont_test_assembles_f4(self):
        pass

    def test_assembles_f5(self):
        self.assertEqual([0xf5, 0x44],
                         self.assemble('SBC $44,X'))

    def test_assembles_f6(self):
        self.assertEqual([0xf6, 0x44],
                         self.assemble('INC $44,X'))

    def dont_test_assembles_f7(self):
        pass

    def test_assembles_f7_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xf7, 0x42],
                         self.assemble('SMB7 $42', 0x0000, mpu))

    def test_assembles_f8(self):
        self.assertEqual([0xf8],
                         self.assemble('SED'))

    def test_assembles_f9(self):
        self.assertEqual([0xf9, 0x00, 0x44],
                         self.assemble('SBC $4400,Y'))

    def dont_test_assembles_fa(self):
        pass

    def test_assembles_fa_65c02(self):
        mpu = MPU65C02()
        self.assertEqual([0xfa],
                         self.assemble('PLX', 0x0000, mpu))

    def dont_test_assembles_fb(self):
        pass

    def dont_test_assembles_fc(self):
        pass

    def test_assembles_fd(self):
        self.assertEqual([0xfd, 0x00, 0x44],
                         self.assemble('SBC $4400,X'))

    def test_assembles_fe(self):
        self.assertEqual([0xfe, 0x00, 0x44],
                         self.assemble('INC $4400,X'))

    def dont_test_assembles_ff(self):
        pass

    # Test Helpers

    def assemble(self, statement, pc=0000, mpu=None):
        if mpu is None:
            mpu = MPU()
        address_parser = AddressParser()
        assembler = Assembler(mpu, address_parser)
        return assembler.assemble(statement, pc)


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_disassembler
import unittest
import sys
from py65.devices.mpu6502 import MPU
from py65.devices.mpu65c02 import MPU as MPU65C02
from py65.disassembler import Disassembler
from py65.utils.addressing import AddressParser


class DisassemblerTests(unittest.TestCase):

    def _dont_test_disassemble_wraps_after_top_of_mem(self):
        '''
        TODO: This test fails with IndexError.  We should fix this
        so that it does not attempt to index memory out of range.
        It does not affect most Py65 users because py65mon uses
        ObservableMemory, which does not raise IndexError.
        '''
        mpu = MPU()
        mpu.memory[0xFFFF] = 0x20  # JSR
        mpu.memory[0x0000] = 0xD2  #
        mpu.memory[0x0001] = 0xFF  # $FFD2

        dis = Disassembler(mpu)
        length, disasm = dis.instruction_at(0xFFFF)
        self.assertEqual(3, length)
        self.assertEqual('JSR $ffd2', disasm)

    def test_disassembles_00(self):
        length, disasm = self.disassemble([0x00])
        self.assertEqual(1, length)
        self.assertEqual('BRK', disasm)

    def test_disassembles_01(self):
        length, disasm = self.disassemble([0x01, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ORA ($44,X)', disasm)

    def test_disassembles_02(self):
        length, disasm = self.disassemble([0x02])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_03(self):
        length, disasm = self.disassemble([0x03])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_04(self):
        length, disasm = self.disassemble([0x04])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_05(self):
        length, disasm = self.disassemble([0x05, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ORA $44', disasm)

    def test_disassembles_06(self):
        length, disasm = self.disassemble([0x06, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ASL $44', disasm)

    def test_disassembles_07_6502(self):
        length, disasm = self.disassemble([0x07])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_07_65c02(self):
        mpu = MPU65C02()
        length, disasm = self.disassemble([0x07, 0x42], 0x0000, mpu)
        self.assertEqual(2, length)
        self.assertEqual('RMB0 $42', disasm)

    def test_disassembles_08(self):
        length, disasm = self.disassemble([0x08])
        self.assertEqual(1, length)
        self.assertEqual('PHP', disasm)

    def test_disassembles_09(self):
        length, disasm = self.disassemble([0x09, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ORA #$44', disasm)

    def test_disassembles_0a(self):
        length, disasm = self.disassemble([0x0a])
        self.assertEqual(1, length)
        self.assertEqual('ASL A', disasm)

    def test_disassembles_0b(self):
        length, disasm = self.disassemble([0x0b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_0c(self):
        length, disasm = self.disassemble([0x0c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_0d(self):
        length, disasm = self.disassemble([0x0d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ORA $4400', disasm)

    def test_disassembles_0e(self):
        length, disasm = self.disassemble([0x0e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ASL $4400', disasm)

    def test_disassembles_0f(self):
        length, disasm = self.disassemble([0x0f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_10(self):
        length, disasm = self.disassemble([0x10, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BPL $0046', disasm)

    def test_disassembles_11(self):
        length, disasm = self.disassemble([0x11, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ORA ($44),Y', disasm)

    def test_disassembles_12(self):
        length, disasm = self.disassemble([0x12])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_13(self):
        length, disasm = self.disassemble([0x13])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_14(self):
        length, disasm = self.disassemble([0x14])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_15(self):
        length, disasm = self.disassemble([0x15, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ORA $44,X', disasm)

    def test_disassembles_16(self):
        length, disasm = self.disassemble([0x16, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ASL $44,X', disasm)

    def test_disassembles_17(self):
        length, disasm = self.disassemble([0x17])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_18(self):
        length, disasm = self.disassemble([0x18])
        self.assertEqual(1, length)
        self.assertEqual('CLC', disasm)

    def test_disassembles_19(self):
        length, disasm = self.disassemble([0x19, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ORA $4400,Y', disasm)

    def test_disassembles_1a(self):
        length, disasm = self.disassemble([0x1a])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_1b(self):
        length, disasm = self.disassemble([0x1b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_1c(self):
        length, disasm = self.disassemble([0x1c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_1d(self):
        length, disasm = self.disassemble([0x1d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ORA $4400,X', disasm)

    def test_disassembles_1e(self):
        length, disasm = self.disassemble([0x1e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ASL $4400,X', disasm)

    def test_disassembles_1f(self):
        length, disasm = self.disassemble([0x1f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_20(self):
        length, disasm = self.disassemble([0x20, 0x97, 0x55])
        self.assertEqual(3, length)
        self.assertEqual('JSR $5597', disasm)

    def test_disassembles_21(self):
        length, disasm = self.disassemble([0x21, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('AND ($44,X)', disasm)

    def test_disassembles_22(self):
        length, disasm = self.disassemble([0x22])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_23(self):
        length, disasm = self.disassemble([0x23])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_24(self):
        length, disasm = self.disassemble([0x24, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BIT $44', disasm)

    def test_disassembles_25(self):
        length, disasm = self.disassemble([0x25, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('AND $44', disasm)

    def test_disassembles_26(self):
        length, disasm = self.disassemble([0x26, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ROL $44', disasm)

    def test_disassembles_27(self):
        length, disasm = self.disassemble([0x27])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_28(self):
        length, disasm = self.disassemble([0x28])
        self.assertEqual(1, length)
        self.assertEqual('PLP', disasm)

    def test_disassembles_29(self):
        length, disasm = self.disassemble([0x29, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('AND #$44', disasm)

    def test_disassembles_2a(self):
        length, disasm = self.disassemble([0x2a])
        self.assertEqual(1, length)
        self.assertEqual('ROL A', disasm)

    def test_disassembles_2b(self):
        length, disasm = self.disassemble([0x2b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_2c(self):
        length, disasm = self.disassemble([0x2c, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('BIT $4400', disasm)

    def test_disassembles_2d(self):
        length, disasm = self.disassemble([0x2d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('AND $4400', disasm)

    def test_disassembles_2e(self):
        length, disasm = self.disassemble([0x2e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ROL $4400', disasm)

    def test_disassembles_2f(self):
        length, disasm = self.disassemble([0x2f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_30(self):
        length, disasm = self.disassemble([0x30, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BMI $0046', disasm)

    def test_disassembles_31(self):
        length, disasm = self.disassemble([0x31, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('AND ($44),Y', disasm)

    def test_disassembles_32(self):
        length, disasm = self.disassemble([0x32])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_33(self):
        length, disasm = self.disassemble([0x33])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_34(self):
        length, disasm = self.disassemble([0x34])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_35(self):
        length, disasm = self.disassemble([0x35, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('AND $44,X', disasm)

    def test_disassembles_36(self):
        length, disasm = self.disassemble([0x36, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ROL $44,X', disasm)

    def test_disassembles_37(self):
        length, disasm = self.disassemble([0x37])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_38(self):
        length, disasm = self.disassemble([0x38])
        self.assertEqual(1, length)
        self.assertEqual('SEC', disasm)

    def test_disassembles_39(self):
        length, disasm = self.disassemble([0x39, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('AND $4400,Y', disasm)

    def test_disassembles_3a(self):
        length, disasm = self.disassemble([0x3a])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_3b(self):
        length, disasm = self.disassemble([0x3b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_3c(self):
        length, disasm = self.disassemble([0x3c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_3d(self):
        length, disasm = self.disassemble([0x3d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('AND $4400,X', disasm)

    def test_disassembles_3e(self):
        length, disasm = self.disassemble([0x3e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ROL $4400,X', disasm)

    def test_disassembles_3f(self):
        length, disasm = self.disassemble([0x3f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_40(self):
        length, disasm = self.disassemble([0x40])
        self.assertEqual(1, length)
        self.assertEqual('RTI', disasm)

    def test_disassembles_41(self):
        length, disasm = self.disassemble([0x41, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('EOR ($44,X)', disasm)

    def test_disassembles_42(self):
        length, disasm = self.disassemble([0x42])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_43(self):
        length, disasm = self.disassemble([0x43])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_44(self):
        length, disasm = self.disassemble([0x44])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_45(self):
        length, disasm = self.disassemble([0x45, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('EOR $44', disasm)

    def test_disassembles_46(self):
        length, disasm = self.disassemble([0x46, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LSR $44', disasm)

    def test_disassembles_47(self):
        length, disasm = self.disassemble([0x47])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_48(self):
        length, disasm = self.disassemble([0x48])
        self.assertEqual(1, length)
        self.assertEqual('PHA', disasm)

    def test_disassembles_49(self):
        length, disasm = self.disassemble([0x49, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('EOR #$44', disasm)

    def test_disassembles_4a(self):
        length, disasm = self.disassemble([0x4a])
        self.assertEqual(1, length)
        self.assertEqual('LSR A', disasm)

    def test_disassembles_4b(self):
        length, disasm = self.disassemble([0x4b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_4c(self):
        length, disasm = self.disassemble([0x4c, 0x97, 0x55])
        self.assertEqual(3, length)
        self.assertEqual('JMP $5597', disasm)

    def test_disassembles_4d(self):
        length, disasm = self.disassemble([0x4d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('EOR $4400', disasm)

    def test_disassembles_4e(self):
        length, disasm = self.disassemble([0x4e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LSR $4400', disasm)

    def test_disassembles_4f(self):
        length, disasm = self.disassemble([0x4f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_50(self):
        length, disasm = self.disassemble([0x50, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BVC $0046', disasm)

    def test_disassembles_51(self):
        length, disasm = self.disassemble([0x51, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('EOR ($44),Y', disasm)

    def test_disassembles_52(self):
        length, disasm = self.disassemble([0x52])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_53(self):
        length, disasm = self.disassemble([0x53])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_54(self):
        length, disasm = self.disassemble([0x54])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_55(self):
        length, disasm = self.disassemble([0x55, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('EOR $44,X', disasm)

    def test_disassembles_56(self):
        length, disasm = self.disassemble([0x56, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LSR $44,X', disasm)

    def test_disassembles_57(self):
        length, disasm = self.disassemble([0x57])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_58(self):
        length, disasm = self.disassemble([0x58])
        self.assertEqual(1, length)
        self.assertEqual('CLI', disasm)

    def test_disassembles_59(self):
        length, disasm = self.disassemble([0x59, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('EOR $4400,Y', disasm)

    def test_disassembles_5a(self):
        length, disasm = self.disassemble([0x5a])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_5b(self):
        length, disasm = self.disassemble([0x5b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_5c(self):
        length, disasm = self.disassemble([0x5c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_5d(self):
        length, disasm = self.disassemble([0x5d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('EOR $4400,X', disasm)

    def test_disassembles_5e(self):
        length, disasm = self.disassemble([0x5e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LSR $4400,X', disasm)

    def test_disassembles_5f(self):
        length, disasm = self.disassemble([0x5f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_60(self):
        length, disasm = self.disassemble([0x60])
        self.assertEqual(1, length)
        self.assertEqual('RTS', disasm)

    def test_disassembles_61(self):
        length, disasm = self.disassemble([0x61, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ADC ($44,X)', disasm)

    def test_disassembles_62(self):
        length, disasm = self.disassemble([0x62])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_63(self):
        length, disasm = self.disassemble([0x63])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_64(self):
        length, disasm = self.disassemble([0x64])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_65(self):
        length, disasm = self.disassemble([0x65, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ADC $44', disasm)

    def test_disassembles_66(self):
        length, disasm = self.disassemble([0x66, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ROR $44', disasm)

    def test_disassembles_67(self):
        length, disasm = self.disassemble([0x67])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_68(self):
        length, disasm = self.disassemble([0x68])
        self.assertEqual(1, length)
        self.assertEqual('PLA', disasm)

    def test_disassembles_69(self):
        length, disasm = self.disassemble([0x69, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ADC #$44', disasm)

    def test_disassembles_6a(self):
        length, disasm = self.disassemble([0x6a])
        self.assertEqual(1, length)
        self.assertEqual('ROR A', disasm)

    def test_disassembles_6b(self):
        length, disasm = self.disassemble([0x6b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_6c(self):
        length, disasm = self.disassemble([0x6c, 0x97, 0x55])
        self.assertEqual(3, length)
        self.assertEqual('JMP ($5597)', disasm)

    def test_disassembles_6d(self):
        length, disasm = self.disassemble([0x6d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ADC $4400', disasm)

    def test_disassembles_6e(self):
        length, disasm = self.disassemble([0x6e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ROR $4400', disasm)

    def test_disassembles_6f(self):
        length, disasm = self.disassemble([0x6f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_70(self):
        length, disasm = self.disassemble([0x70, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BVS $0046', disasm)

    def test_disassembles_71(self):
        length, disasm = self.disassemble([0x71, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ADC ($44),Y', disasm)

    def test_disassembles_72(self):
        length, disasm = self.disassemble([0x72])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_73(self):
        length, disasm = self.disassemble([0x73])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_74(self):
        length, disasm = self.disassemble([0x74])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_75(self):
        length, disasm = self.disassemble([0x75, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ADC $44,X', disasm)

    def test_disassembles_76(self):
        length, disasm = self.disassemble([0x76, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('ROR $44,X', disasm)

    def test_disassembles_77(self):
        length, disasm = self.disassemble([0x77])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_78(self):
        length, disasm = self.disassemble([0x78])
        self.assertEqual(1, length)
        self.assertEqual('SEI', disasm)

    def test_disassembles_79(self):
        length, disasm = self.disassemble([0x79, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ADC $4400,Y', disasm)

    def test_disassembles_7a(self):
        length, disasm = self.disassemble([0x7a])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_7b(self):
        length, disasm = self.disassemble([0x7b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_7c_6502(self):
        length, disasm = self.disassemble([0x7c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_7c_65c02(self):
        mpu = MPU65C02()
        length, disasm = self.disassemble([0x7c, 0x34, 0x12], 0x0000, mpu)
        self.assertEqual(3, length)
        self.assertEqual('JMP ($1234,X)', disasm)

    def test_disassembles_7d(self):
        length, disasm = self.disassemble([0x7d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ADC $4400,X', disasm)

    def test_disassembles_7e(self):
        length, disasm = self.disassemble([0x7e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('ROR $4400,X', disasm)

    def test_disassembles_7f(self):
        length, disasm = self.disassemble([0x7f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_80(self):
        length, disasm = self.disassemble([0x80])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_81(self):
        length, disasm = self.disassemble([0x81, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STA ($44,X)', disasm)

    def test_disassembles_82(self):
        length, disasm = self.disassemble([0x82])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_83(self):
        length, disasm = self.disassemble([0x83])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_84(self):
        length, disasm = self.disassemble([0x84, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STY $44', disasm)

    def test_disassembles_85(self):
        length, disasm = self.disassemble([0x85, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STA $44', disasm)

    def test_disassembles_86(self):
        length, disasm = self.disassemble([0x86, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STX $44', disasm)

    def test_disassembles_87(self):
        length, disasm = self.disassemble([0x87])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_88(self):
        length, disasm = self.disassemble([0x88])
        self.assertEqual(1, length)
        self.assertEqual('DEY', disasm)

    def test_disassembles_89(self):
        length, disasm = self.disassemble([0x89])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_8a(self):
        length, disasm = self.disassemble([0x8a])
        self.assertEqual(1, length)
        self.assertEqual('TXA', disasm)

    def test_disassembles_8b(self):
        length, disasm = self.disassemble([0x8b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_8c(self):
        length, disasm = self.disassemble([0x8c, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('STY $4400', disasm)

    def test_disassembles_8d(self):
        length, disasm = self.disassemble([0x8d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('STA $4400', disasm)

    def test_disassembles_8e(self):
        length, disasm = self.disassemble([0x8e, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('STX $4400', disasm)

    def test_disassembles_8f(self):
        length, disasm = self.disassemble([0x8f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_90(self):
        length, disasm = self.disassemble([0x90, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BCC $0046', disasm)

    def test_disassembles_91(self):
        length, disasm = self.disassemble([0x91, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STA ($44),Y', disasm)

    def test_disassembles_92(self):
        length, disasm = self.disassemble([0x92])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_92_65c02(self):
        mpu = MPU65C02()
        length, disasm = self.disassemble([0x92, 0x12], 0x0000, mpu)
        self.assertEqual(2, length)
        self.assertEqual('STA ($12)', disasm)

    def test_disassembles_93(self):
        length, disasm = self.disassemble([0x93])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_94(self):
        length, disasm = self.disassemble([0x94, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STY $44,X', disasm)

    def test_disassembles_95(self):
        length, disasm = self.disassemble([0x95, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STA $44,X', disasm)

    def test_disassembles_96(self):
        length, disasm = self.disassemble([0x96, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('STX $44,Y', disasm)

    def test_disassembles_97(self):
        length, disasm = self.disassemble([0x97])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_98(self):
        length, disasm = self.disassemble([0x98])
        self.assertEqual(1, length)
        self.assertEqual('TYA', disasm)

    def test_disassembles_99(self):
        length, disasm = self.disassemble([0x99, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('STA $4400,Y', disasm)

    def test_disassembles_9a(self):
        length, disasm = self.disassemble([0x9a])
        self.assertEqual(1, length)
        self.assertEqual('TXS', disasm)

    def test_disassembles_9b(self):
        length, disasm = self.disassemble([0x9b])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_9c(self):
        length, disasm = self.disassemble([0x9c])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_9d(self):
        length, disasm = self.disassemble([0x9d, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('STA $4400,X', disasm)

    def test_disassembles_9e(self):
        length, disasm = self.disassemble([0x9e])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_9f(self):
        length, disasm = self.disassemble([0x9f])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_a0(self):
        length, disasm = self.disassemble([0xa0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDY #$44', disasm)

    def test_disassembles_a1(self):
        length, disasm = self.disassemble([0xa1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDA ($44,X)', disasm)

    def test_disassembles_a2(self):
        length, disasm = self.disassemble([0xa2, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDX #$44', disasm)

    def test_disassembles_a3(self):
        length, disasm = self.disassemble([0xa3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_a4(self):
        length, disasm = self.disassemble([0xa4, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDY $44', disasm)

    def test_disassembles_a5(self):
        length, disasm = self.disassemble([0xa5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDA $44', disasm)

    def test_disassembles_a6(self):
        length, disasm = self.disassemble([0xa6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDX $44', disasm)

    def test_disassembles_a7(self):
        length, disasm = self.disassemble([0xa7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_a8(self):
        length, disasm = self.disassemble([0xa8])
        self.assertEqual(1, length)
        self.assertEqual('TAY', disasm)

    def test_disassembles_a9(self):
        length, disasm = self.disassemble([0xa9, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDA #$44', disasm)

    def test_disassembles_aa(self):
        length, disasm = self.disassemble([0xaa])
        self.assertEqual(1, length)
        self.assertEqual('TAX', disasm)

    def test_disassembles_ab(self):
        length, disasm = self.disassemble([0xab])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_ac(self):
        length, disasm = self.disassemble([0xac, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDY $4400', disasm)

    def test_disassembles_ad(self):
        length, disasm = self.disassemble([0xad, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDA $4400', disasm)

    def test_disassembles_ae(self):
        length, disasm = self.disassemble([0xae, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDX $4400', disasm)

    def test_disassembles_af(self):
        length, disasm = self.disassemble([0xaf])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_b0(self):
        length, disasm = self.disassemble([0xb0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BCS $0046', disasm)

    def test_disassembles_b1(self):
        length, disasm = self.disassemble([0xb1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDA ($44),Y', disasm)

    def test_disassembles_b2(self):
        length, disasm = self.disassemble([0xb2])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_b3(self):
        length, disasm = self.disassemble([0xb3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_b4(self):
        length, disasm = self.disassemble([0xb4, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDY $44,X', disasm)

    def test_disassembles_b5(self):
        length, disasm = self.disassemble([0xb5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDA $44,X', disasm)

    def test_disassembles_b6(self):
        length, disasm = self.disassemble([0xb6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('LDX $44,Y', disasm)

    def test_disassembles_b7(self):
        length, disasm = self.disassemble([0xb7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_b8(self):
        length, disasm = self.disassemble([0xb8])
        self.assertEqual(1, length)
        self.assertEqual('CLV', disasm)

    def test_disassembles_b9(self):
        length, disasm = self.disassemble([0xb9, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDA $4400,Y', disasm)

    def test_disassembles_ba(self):
        length, disasm = self.disassemble([0xba])
        self.assertEqual(1, length)
        self.assertEqual('TSX', disasm)

    def test_disassembles_bb(self):
        length, disasm = self.disassemble([0xbb])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_bc(self):
        length, disasm = self.disassemble([0xbc, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDY $4400,X', disasm)

    def test_disassembles_bd(self):
        length, disasm = self.disassemble([0xbd, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDA $4400,X', disasm)

    def test_disassembles_be(self):
        length, disasm = self.disassemble([0xbe, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('LDX $4400,Y', disasm)

    def test_disassembles_bf(self):
        length, disasm = self.disassemble([0xbf])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_c0(self):
        length, disasm = self.disassemble([0xc0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CPY #$44', disasm)

    def test_disassembles_c1(self):
        length, disasm = self.disassemble([0xc1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CMP ($44,X)', disasm)

    def test_disassembles_c2(self):
        length, disasm = self.disassemble([0xc2])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_c3(self):
        length, disasm = self.disassemble([0xc3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_c4(self):
        length, disasm = self.disassemble([0xc4, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CPY $44', disasm)

    def test_disassembles_c5(self):
        length, disasm = self.disassemble([0xc5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CMP $44', disasm)

    def test_disassembles_c6(self):
        length, disasm = self.disassemble([0xc6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('DEC $44', disasm)

    def test_disassembles_c7(self):
        length, disasm = self.disassemble([0xc7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_c8(self):
        length, disasm = self.disassemble([0xc8])
        self.assertEqual(1, length)
        self.assertEqual('INY', disasm)

    def test_disassembles_c9(self):
        length, disasm = self.disassemble([0xc9, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CMP #$44', disasm)

    def test_disassembles_ca(self):
        length, disasm = self.disassemble([0xca])
        self.assertEqual(1, length)
        self.assertEqual('DEX', disasm)

    def test_disassembles_cb(self):
        length, disasm = self.disassemble([0xcb])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_cc(self):
        length, disasm = self.disassemble([0xcc, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('CPY $4400', disasm)

    def test_disassembles_cd(self):
        length, disasm = self.disassemble([0xcd, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('CMP $4400', disasm)

    def test_disassembles_ce(self):
        length, disasm = self.disassemble([0xce, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('DEC $4400', disasm)

    def test_disassembles_cf(self):
        length, disasm = self.disassemble([0xcf])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_d0(self):
        length, disasm = self.disassemble([0xd0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BNE $0046', disasm)

    def test_disassembles_d1(self):
        length, disasm = self.disassemble([0xd1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CMP ($44),Y', disasm)

    def test_disassembles_d2(self):
        length, disasm = self.disassemble([0xd2])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_d3(self):
        length, disasm = self.disassemble([0xd3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_d4(self):
        length, disasm = self.disassemble([0xd4])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_d5(self):
        length, disasm = self.disassemble([0xd5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CMP $44,X', disasm)

    def test_disassembles_d6(self):
        length, disasm = self.disassemble([0xd6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('DEC $44,X', disasm)

    def test_disassembles_d7(self):
        length, disasm = self.disassemble([0xd7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_d8(self):
        length, disasm = self.disassemble([0xd8])
        self.assertEqual(1, length)
        self.assertEqual('CLD', disasm)

    def test_disassembles_d9(self):
        length, disasm = self.disassemble([0xd9, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('CMP $4400,Y', disasm)

    def test_disassembles_da(self):
        length, disasm = self.disassemble([0xda])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_db(self):
        length, disasm = self.disassemble([0xdb])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_dc(self):
        length, disasm = self.disassemble([0xdc])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_dd(self):
        length, disasm = self.disassemble([0xdd, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('CMP $4400,X', disasm)

    def test_disassembles_de(self):
        length, disasm = self.disassemble([0xde, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('DEC $4400,X', disasm)

    def test_disassembles_df(self):
        length, disasm = self.disassemble([0xdf])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_e0(self):
        length, disasm = self.disassemble([0xe0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CPX #$44', disasm)

    def test_disassembles_e1(self):
        length, disasm = self.disassemble([0xe1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('SBC ($44,X)', disasm)

    def test_disassembles_e2(self):
        length, disasm = self.disassemble([0xe2])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_e3(self):
        length, disasm = self.disassemble([0xe3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_e4(self):
        length, disasm = self.disassemble([0xe4, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('CPX $44', disasm)

    def test_disassembles_e5(self):
        length, disasm = self.disassemble([0xe5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('SBC $44', disasm)

    def test_disassembles_e6(self):
        length, disasm = self.disassemble([0xe6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('INC $44', disasm)

    def test_disassembles_e7(self):
        length, disasm = self.disassemble([0xe7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_e8(self):
        length, disasm = self.disassemble([0xe8])
        self.assertEqual(1, length)
        self.assertEqual('INX', disasm)

    def test_disassembles_e9(self):
        length, disasm = self.disassemble([0xe9, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('SBC #$44', disasm)

    def test_disassembles_ea(self):
        length, disasm = self.disassemble([0xea])
        self.assertEqual(1, length)
        self.assertEqual('NOP', disasm)

    def test_disassembles_eb(self):
        length, disasm = self.disassemble([0xeb])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_ec(self):
        length, disasm = self.disassemble([0xec, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('CPX $4400', disasm)

    def test_disassembles_ed(self):
        length, disasm = self.disassemble([0xed, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('SBC $4400', disasm)

    def test_disassembles_ee(self):
        length, disasm = self.disassemble([0xee, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('INC $4400', disasm)

    def test_disassembles_ef(self):
        length, disasm = self.disassemble([0xef])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_f0_forward(self):
        length, disasm = self.disassemble([0xf0, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('BEQ $0046', disasm)

    def test_disassembled_f0_backward(self):
        length, disasm = self.disassemble([0xf0, 0xfc], pc=0xc000)
        self.assertEqual(2, length)
        self.assertEqual('BEQ $bffe', disasm)

    def test_disassembles_f1(self):
        length, disasm = self.disassemble([0xf1, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('SBC ($44),Y', disasm)

    def test_disassembles_f2(self):
        length, disasm = self.disassemble([0xf2])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_f3(self):
        length, disasm = self.disassemble([0xf3])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_f4(self):
        length, disasm = self.disassemble([0xf4])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_f5(self):
        length, disasm = self.disassemble([0xf5, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('SBC $44,X', disasm)

    def test_disassembles_f6(self):
        length, disasm = self.disassemble([0xf6, 0x44])
        self.assertEqual(2, length)
        self.assertEqual('INC $44,X', disasm)

    def test_disassembles_f7(self):
        length, disasm = self.disassemble([0xf7])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_f8(self):
        length, disasm = self.disassemble([0xf8])
        self.assertEqual(1, length)
        self.assertEqual('SED', disasm)

    def test_disassembles_f9(self):
        length, disasm = self.disassemble([0xf9, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('SBC $4400,Y', disasm)

    def test_disassembles_fa(self):
        length, disasm = self.disassemble([0xfa])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_fb(self):
        length, disasm = self.disassemble([0xfb])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_fc(self):
        length, disasm = self.disassemble([0xfc])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    def test_disassembles_fd(self):
        length, disasm = self.disassemble([0xfd, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('SBC $4400,X', disasm)

    def test_disassembles_fe(self):
        length, disasm = self.disassemble([0xfe, 0x00, 0x44])
        self.assertEqual(3, length)
        self.assertEqual('INC $4400,X', disasm)

    def test_disassembles_ff(self):
        length, disasm = self.disassemble([0xff])
        self.assertEqual(1, length)
        self.assertEqual('???', disasm)

    # Test Helpers

    def disassemble(self, bytes, pc=0, mpu=None):
        if mpu is None:
            mpu = MPU()
        address_parser = AddressParser()
        disasm = Disassembler(mpu, address_parser)
        mpu.memory[pc:len(bytes) - 81] = bytes
        return disasm.instruction_at(pc)


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_memory
import unittest
from py65.memory import ObservableMemory


class ObservableMemoryTests(unittest.TestCase):

    # __setitem__

    def test___setitem__with_no_listeners_changes_memory(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        mem[0xC000] = 0xAB
        self.assertEqual(0xAB, subject[0xC000])

    def test___setitem__ignores_subscribers_returning_none(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        def write_subscriber_1(address, value):
            return None

        def write_subscriber_2(address, value):
            return None

        mem.subscribe_to_write([0xC000], write_subscriber_1)
        mem.subscribe_to_write([0xC000], write_subscriber_2)

        mem[0xC000] = 0xAB
        self.assertEqual(0xAB, subject[0xC000])

    def test___setitem__uses_result_of_last_subscriber(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        def write_subscriber_1(address, value):
            return 0x01

        def write_subscriber_2(address, value):
            return 0x02

        mem.subscribe_to_write([0xC000], write_subscriber_1)
        mem.subscribe_to_write([0xC000], write_subscriber_2)

        mem[0xC000] = 0xAB
        self.assertEqual(0x02, subject[0xC000])

    # subscribe_to_read

    def test_subscribe_to_read_covers_all_addresses_in_range(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        def read_subscriber(address, value):
            return 0xAB

        mem.subscribe_to_read(range(0xC000, 0xC001 + 1), read_subscriber)

        mem[0xC000] = 0xAB
        mem[0xC001] = 0xAB
        self.assertEqual(0xAB, subject[0xC001])
        self.assertEqual(0xAB, subject[0xC001])

    def test__subscribe_to_read_does_not_register_same_listener_twice(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        calls = []

        def read_subscriber(address):
            calls.append('read_subscriber')

        mem.subscribe_to_read([0xC000], read_subscriber)
        mem.subscribe_to_read([0xC000], read_subscriber)

        value = mem[0xC000]
        value = value  # pyflakes
        self.assertEqual(['read_subscriber'], calls)

    # __getitem__

    def test___getitem__with_no_write_subscribers_changes_memory(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        subject[0xC000] = 0xAB
        self.assertEqual(0xAB, mem[0xC000])

    def test___getitem__ignores_read_subscribers_returning_none(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        def read_subscriber_1(address):
            return None

        def read_subscriber_2(address):
            return None

        mem.subscribe_to_read([0xC000], read_subscriber_1)
        mem.subscribe_to_read([0xC000], read_subscriber_2)

        mem[0xC000] = 0xAB
        self.assertEqual(0xAB, subject[0xC000])

    def test___getitem__calls_all_read_subscribers_uses_last_result(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        calls = []

        def read_subscriber_1(address):
            calls.append('read_subscriber_1')
            return 0x01

        def read_subscriber_2(address):
            calls.append('read_subscriber_2')
            return 0x02

        mem.subscribe_to_read([0xC000], read_subscriber_1)
        mem.subscribe_to_read([0xC000], read_subscriber_2)

        subject[0xC000] = 0xAB
        self.assertEqual(0x02, mem[0xC000])

        expected_calls = ['read_subscriber_1', 'read_subscriber_2']
        self.assertEqual(expected_calls, calls)

    # __getattr__

    def test__getattr__proxies_subject(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)
        self.assertEqual(subject.count, mem.count)

    # write

    def test_write_directly_writes_values_to_subject(self):
        subject = self._make_subject()
        mem = ObservableMemory(subject=subject)

        def write_subscriber(address, value):
            return 0xFF
        mem.subscribe_to_write([0xC000, 0xC001], write_subscriber)

        mem.write(0xC000, [0x01, 0x02])
        self.assertEqual(0x01, subject[0xC000])
        self.assertEqual(0x02, subject[0xC001])

    # Test Helpers

    def _make_subject(self):
        subject = 0x10000 * [0x00]
        return subject

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_monitor
import unittest
import sys
import os
import tempfile
from py65.monitor import Monitor

try:
    from StringIO import StringIO
except ImportError: # Python 3
    from io import StringIO


class MonitorTests(unittest.TestCase):

    # line processing

    def test__preprocess_line_removes_leading_dots_after_whitespace(self):
        mon = Monitor()
        self.assertEqual('help', mon._preprocess_line('  ...help'))

    def test__preprocess_line_removes_leading_and_trailing_whitespace(self):
        mon = Monitor()
        self.assertEqual('help', mon._preprocess_line(' \t help \t '))

    def test__preprocess_line_rewrites_shortcut_when_alone_on_line(self):
        mon = Monitor()
        self.assertEqual('assemble', mon._preprocess_line(' a'))

    def test__preprocess_line_rewrites_shortcut_with_arguments_on_line(self):
        mon = Monitor()
        self.assertEqual('assemble c000', mon._preprocess_line('a c000'))

    def test__preprocess_line_removes_semicolon_comments(self):
        mon = Monitor()
        self.assertEqual('assemble', mon._preprocess_line('a ;comment'))

    def test__preprocess_line_does_not_remove_semicolons_in_quotes(self):
        mon = Monitor()
        self.assertEqual('assemble lda #$";"',
                         mon._preprocess_line('a lda #$";" ;comment'))

    def test__preprocess_line_does_not_remove_semicolons_in_apostrophes(self):
        mon = Monitor()
        self.assertEqual("assemble lda #$';'",
                         mon._preprocess_line("assemble lda #$';' ;comment"))

    # add_label

    def test_shortcut_for_add_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('al')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('add_label'))

    def test_do_add_label_syntax_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_add_label('should be label space value')
        out = stdout.getvalue()
        err = "Syntax error: should be label space value\n"
        self.assertTrue(out.startswith(err))

    def test_do_add_label_adds_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_add_label('$c000 foo')
        address_parser = mon._address_parser
        self.assertEqual(0xC000, address_parser.number('foo'))

    def test_help_add_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_add_label()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("add_label"))

    # assemble

    def test_shortcut_for_assemble(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('a')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('assemble'))

    def test_do_assemble_assembles_valid_statement(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('c000 lda #$ab')

        mpu = mon._mpu
        self.assertEqual(0xA9, mpu.memory[0xC000])
        self.assertEqual(0xAB, mpu.memory[0xC001])

    def test_do_assemble_outputs_disassembly(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('c000 lda #$ab')

        out = stdout.getvalue()
        self.assertEqual("$c000  a9 ab     LDA #$ab\n", out)

    def test_do_assemble_parses_start_address_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_add_label('c000 base')
        mon.do_assemble('c000 rts')

        mpu = mon._mpu
        self.assertEqual(0x60, mpu.memory[0xC000])

    def test_do_assemble_shows_bad_label_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('nonexistant rts')

        out = stdout.getvalue()
        self.assertEqual("Bad label: nonexistant rts\n", out)

    def test_do_assemble_shows_bad_syntax_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('c000 foo')

        out = stdout.getvalue()
        self.assertEqual("Syntax error: foo\n", out)

    def test_do_assemble_shows_overflow_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('c000 lda #$fff')

        out = stdout.getvalue()
        self.assertEqual("Overflow error: c000 lda #$fff\n", out)

    def test_do_assemble_passes_addr_for_relative_branch_calc(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble('4000 bvs $4005')

        out = stdout.getvalue()
        self.assertEqual("$4000  70 03     BVS $4005\n", out)

    def test_do_assemble_constrains_address_to_valid_range(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_assemble("-1 lda #$ab")

        out = stdout.getvalue()
        self.assertEqual("Overflow error: -1 lda #$ab\n", out)

    def test_help_assemble(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_assemble()

        out = stdout.getvalue()
        self.assertTrue("assemble <address>" in out)

    # cd

    def test_help_cd(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_cd()

        out = stdout.getvalue()
        self.assertTrue(out.startswith("cd <directory>"))

    def test_do_cd_with_no_dir_shows_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_cd("")

        out = stdout.getvalue()
        self.assertTrue(out.startswith("cd <directory>"))

    def test_do_cd_changes_cwd(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        here = os.path.abspath(os.path.dirname(__file__))
        mon.do_cd(here)

        out = stdout.getvalue()
        self.assertTrue(out.startswith(here))
        self.assertEqual(here, os.getcwd())

    def test_do_cd_with_bad_dir_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_cd("/path/to/a/nonexistant/directory")

        out = stdout.getvalue()
        self.assertTrue(out.startswith("Cannot change directory"))

    # cycles

    def test_help_cycles(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_cycles()

        out = stdout.getvalue()
        self.assertTrue(out.startswith("Display the total number of cycles"))

    def test_do_cycles_shows_zero_initially(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_cycles("")

        out = stdout.getvalue()
        self.assertEqual(out, "0\n")

    def test_do_cycles_shows_count_after_step(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0x0000] = 0xEA  # => NOP (2 cycles)
        mon._mpu.step()
        mon.do_cycles("")

        out = stdout.getvalue()
        self.assertEqual(out, "2\n")

    # delete_label

    def test_shortcut_for_delete_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('dl')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('delete_label'))

    def test_do_delete_label_no_args_displays_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_delete_label('')
        out = stdout.getvalue()
        self.assertTrue(out.startswith('delete_label'))

    def test_do_delete_label_with_bad_label_fails_silently(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_delete_label('non-existant-label')
        out = stdout.getvalue()
        self.assertEqual('', out)

    def test_do_delete_label_with_delete_label(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._address_parser.labels['foo'] = 0xc000
        mon.do_delete_label('foo')
        self.assertFalse('foo' in mon._address_parser.labels)
        out = stdout.getvalue()
        self.assertEqual('', out)

    # disassemble

    def test_shortcut_for_disassemble(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('d')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('disassemble'))

    def test_help_disassemble(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_disassemble()
        out = stdout.getvalue()
        self.assertTrue(out.startswith('disassemble <address_range>'))

    def test_disassemble_shows_help_when_given_extra_args(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_disassemble("c000 c001")
        out = stdout.getvalue()
        self.assertTrue(out.startswith('disassemble <address_range>'))

    def test_disassemble_will_disassemble_one_address(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xc000] = 0xEA  # => NOP
        mon._mpu.step()
        mon.do_disassemble("c000")

        out = stdout.getvalue()
        disasm = "$c000  ea        NOP\n"
        self.assertEqual(out, disasm)

    def test_disassemble_will_disassemble_an_address_range(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xc000] = 0xEA  # => NOP
        mon._mpu.memory[0xc001] = 0xEA  # => NOP
        mon._mpu.step()
        mon.do_disassemble("c000:c001")

        out = stdout.getvalue()
        disasm = "$c000  ea        NOP\n$c001  ea        NOP\n"
        self.assertEqual(out, disasm)

    def test_disassemble_wraps_an_instruction_around_memory(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xffff] = 0x20  # => JSR
        mon._mpu.memory[0x0000] = 0xD2  #
        mon._mpu.memory[0x0001] = 0xFF  # => $FFD2
        mon.do_disassemble("ffff")

        out = stdout.getvalue()
        disasm = "$ffff  20 d2 ff  JSR $ffd2\n"
        self.assertEqual(out, disasm)

    def test_disassemble_wraps_disassembly_list_around_memory(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xffff] = 0x20  # => JSR
        mon._mpu.memory[0x0000] = 0xD2
        mon._mpu.memory[0x0001] = 0xFF  # => $FFD2
        mon._mpu.memory[0x0002] = 0x20  # => JSR
        mon._mpu.memory[0x0003] = 0xE4
        mon._mpu.memory[0x0004] = 0xFF  # => $FFE4
        mon._mpu.memory[0x0005] = 0xEA  # => NOP
        mon.do_disassemble("ffff:5")
        out = stdout.getvalue()
        disasm = ("$ffff  20 d2 ff  JSR $ffd2\n"
                  "$0002  20 e4 ff  JSR $ffe4\n"
                  "$0005  ea        NOP\n")
        self.assertEqual(out, disasm)

    # fill

    def test_shortcut_f_for_fill(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('f')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('fill <address_range>'))

    def test_shortcut_gt_for_fill(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('>')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('fill <address_range>'))

    def test_help_fill(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_fill()

        out = stdout.getvalue()
        self.assertTrue(out.startswith('fill <address_range>'))

    def test_do_fill_with_no_args_shows_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_fill('')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('fill <address_range>'))

    def test_do_fill_will_fill_one_address(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xc000] = 0x00
        mon.do_fill('c000 aa')

        self.assertEqual(0xAA, mon._mpu.memory[0xc000])
        out = stdout.getvalue()
        self.assertTrue(out.startswith('Wrote +1 bytes from $c000 to $c000'))

    def test_do_fill_will_fill_an_address_range_with_a_single_byte(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xc000] = 0x00
        mon._mpu.memory[0xc001] = 0x00
        mon._mpu.memory[0xc002] = 0x00
        mon.do_fill('c000:c001 aa')

        self.assertEqual(0xAA, mon._mpu.memory[0xc000])
        self.assertEqual(0xAA, mon._mpu.memory[0xc001])
        self.assertEqual(0x00, mon._mpu.memory[0xc002])
        out = stdout.getvalue()
        self.assertTrue(out.startswith('Wrote +2 bytes from $c000 to $c001'))

    def test_do_fill_will_fill_an_address_range_with_byte_sequence(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xc000] = 0x00
        mon._mpu.memory[0xc001] = 0x00
        mon._mpu.memory[0xc002] = 0x00
        mon._mpu.memory[0xc003] = 0x00
        mon.do_fill('c000:c003 aa bb')

        self.assertEqual(0xAA, mon._mpu.memory[0xc000])
        self.assertEqual(0xBB, mon._mpu.memory[0xc001])
        self.assertEqual(0xAA, mon._mpu.memory[0xc002])
        self.assertEqual(0xBB, mon._mpu.memory[0xc003])
        out = stdout.getvalue()
        self.assertTrue(out.startswith('Wrote +4 bytes from $c000 to $c003'))

    # goto

    def test_shortcut_for_goto(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('g')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('goto'))

    def test_goto_without_args_shows_command_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('goto')
        out = stdout.getvalue()
        self.assertTrue("goto <address>" in out)

    # help

    def test_help_without_args_shows_documented_commands(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('help')
        out = stdout.getvalue()
        self.assertTrue("Documented commands" in out)

        stdout.truncate(0)
        mon.onecmd('h')
        out = stdout.getvalue()
        self.assertTrue("Documented commands" in out)

        stdout.truncate(0)
        mon.onecmd('?')
        out = stdout.getvalue()
        self.assertTrue("Documented commands" in out)

    def test_help_with_args_shows_command_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('help assemble')
        out = stdout.getvalue()
        self.assertTrue("assemble <address>" in out)

        stdout.truncate(0)
        mon.onecmd('h a')
        out = stdout.getvalue()
        self.assertTrue("assemble <address>" in out)

    def test_help_with_invalid_args_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('help foo')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("*** No help on foo"))

    # load

    def test_shortcut_for_load(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('l')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('load'))

    def test_load_with_more_than_two_args_syntax_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_load('one two three')
        out = stdout.getvalue()
        self.assertTrue(out.startswith('Syntax error'))

    def test_load(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)

        filename = tempfile.mktemp()
        try:
            f = open(filename, 'wb')
            f.write(b'\xaa\xbb\xcc')
            f.close()

            mon.do_load("'%s' a600" % filename)
            self.assertEqual('Wrote +3 bytes from $a600 to $a602\n',
                             stdout.getvalue())
            self.assertEqual([0xAA, 0xBB, 0xCC],
                             mon._mpu.memory[0xA600:0xA603])
        finally:
            os.unlink(filename)

    def test_help_load(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_load()
        out = stdout.getvalue()
        self.assertTrue(out.startswith('load'))

    # mem

    def test_shortcut_for_mem(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('m')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('mem <address_range>'))

    def test_do_mem_shows_help_when_given_no_args(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mem('')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('mem <address_range>'))

    def test_do_mem_shows_help_when_given_extra_args(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mem('c000 c001')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('mem <address_range>'))

    def test_do_mem_shows_memory_for_a_single_address(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xC000] = 0xAA
        mon.do_mem('c000')

        out = stdout.getvalue()
        self.assertEqual('c000:  aa\n', out)

    def test_do_mem_shows_memory_for_an_address_range(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0xC000] = 0xAA
        mon._mpu.memory[0xC001] = 0xBB
        mon._mpu.memory[0xC002] = 0xCC
        mon.do_mem('c000:c002')

        out = stdout.getvalue()
        self.assertEqual('c000:  aa  bb  cc\n', out)

    def test_do_mem_wraps_at_terminal_width(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._width = 14
        mon.do_mem('c000:c003')

        out = stdout.getvalue()
        self.assertEqual('c000:  00  00\n'
                         'c002:  00  00\n', out)

    # mpu

    def test_mpu_with_no_args_prints_current_lists_available_mpus(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mpu('')

        lines = stdout.getvalue().splitlines()
        self.assertEqual(2, len(lines))
        self.assertTrue(lines[0].startswith('Current MPU is '))
        self.assertTrue(lines[1].startswith('Available MPUs:'))

    def test_mpu_with_bad_arg_gives_error_lists_available_mpus(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mpu('z80')

        lines = stdout.getvalue().splitlines()
        self.assertEqual(2, len(lines))
        self.assertEqual('Unknown MPU: z80', lines[0])
        self.assertTrue(lines[1].startswith('Available MPUs:'))

    def test_mpu_selects_6502(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mpu('6502')

        lines = stdout.getvalue().splitlines()
        self.assertEqual(1, len(lines))
        self.assertEqual('Reset with new MPU 6502', lines[0])
        self.assertEqual('6502', mon._mpu.name)

    def test_mpu_selects_65C02(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mpu('65C02')

        lines = stdout.getvalue().splitlines()
        self.assertEqual(1, len(lines))
        self.assertEqual('Reset with new MPU 65C02', lines[0])
        self.assertEqual('65C02', mon._mpu.name)

    def test_mpu_select_is_not_case_sensitive(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_mpu('65c02')
        self.assertEqual('65C02', mon._mpu.name)

    def test_help_mpu(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_mpu()

        lines = stdout.getvalue().splitlines()
        self.assertEqual("mpu\t\tPrint available microprocessors.",
                         lines[0])
        self.assertEqual("mpu <type>\tSelect a new microprocessor.",
                         lines[1])

    # quit

    def test_shortcuts_for_quit(self):
        for shortcut in ["exit", "x", "q", "EOF"]:
            stdout = StringIO()
            mon = Monitor(stdout=stdout)
            mon.do_help(shortcut)

            out = stdout.getvalue()
            self.assertTrue(out.startswith('To quit'))

    def test_do_quit(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        exitnow = mon.do_quit('')
        self.assertEqual(True, exitnow)

    def test_help_quit(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_quit()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("To quit,"))

    # pwd

    def test_pwd_shows_os_getcwd(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_pwd()

        out = stdout.getvalue()
        self.assertEqual("%s\n" % os.getcwd(), out)

    def test_help_pwd(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_pwd()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Show the current working"))

    # radix

    def test_shortcut_for_radix(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('rad')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('radix'))

    def test_help_radix(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_radix()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("radix [H|D|O|B]"))

    def test_radix_no_arg_displays_radix(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Default radix is Hexadecimal"))

    def test_radix_invalid_radix_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('f')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Illegal radix: f"))

    def test_radix_sets_binary(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('b')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Default radix is Binary"))

    def test_radix_sets_decimal(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('d')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Default radix is Decimal"))

    def test_radix_sets_hexadecimal(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('h')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Default radix is Hexadecimal"))

    def test_radix_sets_octal(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_radix('o')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("Default radix is Octal"))

    # registers

    def test_shortcut_for_registers(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('r')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('registers'))

    def test_registers_display_returns_to_prompt(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('')
        out = stdout.getvalue()
        self.assertEqual('', out)

    def test_registers_syntax_error_bad_format(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('x')
        out = stdout.getvalue()
        self.assertEqual("Syntax error: x\n", out)

    def test_registers_label_error_bad_value(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('x=pony')
        out = stdout.getvalue()
        self.assertEqual("Label not found: pony\n", out)

    def test_registers_invalid_register_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('z=3')
        out = stdout.getvalue()
        self.assertEqual("Invalid register: z\n", out)

    def test_registers_updates_single_register(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('x=42')
        out = stdout.getvalue()
        self.assertEqual("", out)
        self.assertEqual(0x42, mon._mpu.x)

    def test_registers_updates_all_registers(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_registers('a=42,x=43,y=44,p=45, sp=46, pc=4600')
        out = stdout.getvalue()
        self.assertEqual("", out)
        self.assertEqual(0x42, mon._mpu.a)
        self.assertEqual(0x43, mon._mpu.x)
        self.assertEqual(0x44, mon._mpu.y)
        self.assertEqual(0x45, mon._mpu.p)
        self.assertEqual(0x46, mon._mpu.sp)
        self.assertEqual(0x4600, mon._mpu.pc)

    def test_help_registers(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_registers()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("registers[<name>"))

    # return

    def test_shortcut_for_return(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('ret')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('return'))

    # reset

    def test_do_reset(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        old_mpu = mon._mpu
        old_name = mon._mpu.name
        mon.do_reset('')
        self.assertNotEqual(old_mpu, mon._mpu)
        self.assertEqual(old_name, mon._mpu.name)

    def test_help_reset(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_reset()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("reset\t"))

    # save

    def test_shortcut_for_save(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('s')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('save'))

    def test_save_with_less_than_three_args_syntax_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_save('filename start')
        out = stdout.getvalue()
        self.assertTrue(out.startswith('Syntax error'))

    def test_save(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._mpu.memory[0:3] = [0xAA, 0xBB, 0xCC]

        filename = tempfile.mktemp()
        try:
            mon.do_save("'%s' 0 2" % filename)
            self.assertEqual('Saved +3 bytes to %s\n' % filename,
                             stdout.getvalue())

            f = open(filename, 'rb')
            contents = f.read()
            f.close()
            self.assertEqual(b'\xaa\xbb\xcc', contents)
        finally:
            os.unlink(filename)

    def test_help_save(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_save()
        out = stdout.getvalue()
        self.assertTrue(out.startswith('save'))

    # step

    def test_shortcut_for_step(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('z')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('step'))

    # tilde

    def test_tilde_shortcut_with_space(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('~ $10')
        out = stdout.getvalue()
        expected = "+16\n$10\n0020\n00010000\n"
        self.assertTrue(out.startswith(expected))

    def test_tilde_shortcut_without_space_for_vice_compatibility(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.onecmd('~$10')
        out = stdout.getvalue()
        expected = "+16\n$10\n0020\n00010000\n"
        self.assertTrue(out.startswith(expected))

    def test_do_tilde(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_tilde('$10')
        out = stdout.getvalue()
        expected = "+16\n$10\n0020\n00010000\n"
        self.assertTrue(out.startswith(expected))

    def test_do_tilde_with_no_arg_shows_help(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_tilde('')
        out = stdout.getvalue()
        expected = "~ <number>"
        self.assertTrue(out.startswith(expected))

    def test_do_tilde_with_bad_label_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_tilde('bad_label')
        out = stdout.getvalue()
        expected = "Bad label: bad_label"
        self.assertTrue(out.startswith(expected))

    def test_do_tilde_with_overflow_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_tilde('$FFFFFFFFFFFF')
        out = stdout.getvalue()
        expected = "Overflow error: $FFFFFFFFFFFF"
        self.assertTrue(out.startswith(expected))

    def test_help_tilde(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_tilde()
        out = stdout.getvalue()
        expected = "~ <number>"
        self.assertTrue(out.startswith(expected))

    # show_labels

    def test_shortcut_for_show_labels(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_help('shl')

        out = stdout.getvalue()
        self.assertTrue(out.startswith('show_labels'))

    def test_show_labels_displays_labels(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._address_parser.labels = {'chrin': 0xffc4, 'chrout': 0xffd2}
        mon.do_show_labels('')
        out = stdout.getvalue()
        self.assertEqual("ffc4: chrin\nffd2: chrout\n", out)

    def test_help_show_labels(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon._address_parser.labels = {'chrin': 0xffc4, 'chrout': 0xffd2}
        mon.do_show_labels('')
        out = stdout.getvalue()
        self.assertEqual("ffc4: chrin\nffd2: chrout\n", out)

    # version

    def test_do_version(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_version('')
        out = stdout.getvalue()
        self.assertTrue(out.startswith("\nPy65"))

    def test_help_version(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_version()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("version\t"))

    # width

    def test_do_width_with_no_args_shows_current_width(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_width('')
        out = stdout.getvalue()
        self.assertEqual("Terminal width is 78\n", out)

    def test_do_width_with_arg_changes_width(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_width('38')
        out = stdout.getvalue()
        self.assertEqual("Terminal width is 38\n", out)

    def test_do_width_with_less_than_min_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_width('3')
        out = stdout.getvalue()
        expected = "Minimum terminal width is 10\nTerminal width is 78\n"
        self.assertEqual(expected, out)

    def test_do_width_with_bad_arg_shows_error(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.do_width('bad')
        out = stdout.getvalue()
        expected = "Illegal width: bad\nTerminal width is 78\n"
        self.assertEqual(expected, out)

    def test_help_width(self):
        stdout = StringIO()
        mon = Monitor(stdout=stdout)
        mon.help_width()
        out = stdout.getvalue()
        self.assertTrue(out.startswith("width <columns>"))

def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_addressing
import unittest
import sys
from py65.utils.addressing import AddressParser


class AddressParserTests(unittest.TestCase):
    def test_maxwidth_can_be_set_in_constructor(self):
        parser = AddressParser(maxwidth=24)
        self.assertEqual(24, parser.maxwidth)
        self.assertEqual(0xFFFFFF, parser._maxaddr)

    def test_maxwidth_defaults_to_16_bits(self):
        parser = AddressParser()
        self.assertEqual(16, parser.maxwidth)
        self.assertEqual(0xFFFF, parser._maxaddr)

    def test_maxwidth_setter(self):
        parser = AddressParser()
        parser.maxwidth = 24
        self.assertEqual(24, parser.maxwidth)
        self.assertEqual(0xFFFFFF, parser._maxaddr)

    # number

    def test_number_hex_literal(self):
        parser = AddressParser()
        self.assertEqual(49152, parser.number('$c000'))

    def test_number_dec_literal(self):
        parser = AddressParser()
        self.assertEqual(49152, parser.number('+49152'))

    def test_number_bin_literal(self):
        parser = AddressParser()
        self.assertEqual(129, parser.number('%10000001'))

    def test_number_default_radix(self):
        parser = AddressParser()
        parser.radix = 10
        self.assertEqual(10, parser.number('10'))
        parser.radix = 16
        self.assertEqual(16, parser.number('10'))

    def test_number_label(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xC000}
        self.assertEqual(0xC000, parser.number('foo'))

    def test_number_bad_label(self):
        parser = AddressParser()
        try:
            parser.number('bad_label')
            self.fail()
        except KeyError as exc:
            self.assertEqual('Label not found: bad_label', exc.args[0])

    def test_number_label_hex_offset(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xC000}
        self.assertEqual(0xC003, parser.number('foo+$3'))
        self.assertEqual(0xBFFD, parser.number('foo-$3'))
        self.assertEqual(0xC003, parser.number('foo + $3'))
        self.assertEqual(0xBFFD, parser.number('foo - $3'))

    def test_number_label_dec_offset(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xC000}
        self.assertEqual(0xC003, parser.number('foo++3'))
        self.assertEqual(0xBFFD, parser.number('foo-+3'))
        self.assertEqual(0xC003, parser.number('foo + +3'))
        self.assertEqual(0xBFFD, parser.number('foo - +3'))

    def test_number_label_bin_offset(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xC000}
        self.assertEqual(0xC003, parser.number('foo+%00000011'))
        self.assertEqual(0xBFFD, parser.number('foo-%00000011'))
        self.assertEqual(0xC003, parser.number('foo + %00000011'))
        self.assertEqual(0xBFFD, parser.number('foo - %00000011'))

    def test_number_label_offset_default_radix(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xC000}
        parser.radix = 16
        self.assertEqual(0xC010, parser.number('foo+10'))
        self.assertEqual(0xBFF0, parser.number('foo-10'))
        self.assertEqual(0xC010, parser.number('foo + 10'))
        self.assertEqual(0xBFF0, parser.number('foo - 10'))
        parser.radix = 10
        self.assertEqual(0xC00A, parser.number('foo+10'))
        self.assertEqual(0xBFF6, parser.number('foo-10'))
        self.assertEqual(0xC00A, parser.number('foo + 10'))
        self.assertEqual(0xBFF6, parser.number('foo - 10'))

    def test_number_bad_label_with_offset(self):
        parser = AddressParser()
        try:
            parser.number('bad_label+3')
            self.fail()
        except KeyError as exc:
            self.assertEqual('Label not found: bad_label', exc.args[0])

    def test_number_bad_label_syntax(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xFFFF}
        try:
            parser.number('#$foo')
            self.fail()
        except KeyError as exc:
            self.assertEqual('Label not found: #$foo', exc.args[0])

    def test_number_constrains_address_at_zero_or_above(self):
        parser = AddressParser()
        self.assertRaises(OverflowError, parser.number, '-1')

    def test_number_constrains_address_at_maxwidth_16(self):
        parser = AddressParser()
        parser.labels = {'foo': 0xFFFF}
        self.assertRaises(OverflowError, parser.number, 'foo+5')

    def test_number_constrains_address_at_maxwidth_24(self):
        parser = AddressParser()
        parser.maxwidth = 24
        parser.labels = {'foo': 0xFFFFFF}
        self.assertRaises(OverflowError, parser.number, 'foo+5')

    # label_for

    def test_label_for_returns_label(self):
        parser = AddressParser(labels={'chrout': 0xFFD2})
        self.assertEqual('chrout', parser.label_for(0xFFD2))

    def test_label_for_returns_none_by_default(self):
        parser = AddressParser(labels={})
        self.assertEqual(None, parser.label_for(0xFFD2))

    def test_label_for_returns_alternate_default(self):
        parser = AddressParser(labels={})
        self.assertEqual('foo', parser.label_for(0xFFD2, 'foo'))

    # range

    def test_range_one_number(self):
        parser = AddressParser(labels={})
        self.assertEqual((0xFFD2, 0xFFD2), parser.range('ffd2'))

    def test_range_one_label(self):
        parser = AddressParser(labels={'chrout':0xFFD2})
        self.assertEqual((0xFFD2, 0xFFD2), parser.range('chrout'))

    def test_range_two_numbers(self):
        parser = AddressParser(labels={})
        self.assertEqual((0xFFD2, 0xFFD4), parser.range('ffd2:ffd4'))

    def test_range_mixed(self):
        parser = AddressParser(labels={'chrout':0xFFD2})
        self.assertEqual((0xFFD2, 0xFFD4), parser.range('chrout:ffd4'))

    def test_range_start_exceeds_end(self):
        parser = AddressParser(labels={})
        self.assertEqual((0xFFD2, 0xFFD4), parser.range('ffd4:ffd2'))

def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_console
import sys
import unittest


class ConsoleTopLevelTests(unittest.TestCase):
    pass


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_conversions
import sys
import unittest
from py65.utils.conversions import itoa


class ConversionsTopLevelTests(unittest.TestCase):
    def test_itoa_decimal_output(self):
        self.assertEqual('10', itoa(10, base=10))

    def test_itoa_hex_output(self):
        self.assertEqual('a', itoa(10, base=16))

    def test_itoa_bin_output(self):
        self.assertEqual('1010', itoa(10, base=2))


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = test_devices
# this file is a stub

########NEW FILE########
__FILENAME__ = test_hexdump
import unittest
import sys
from py65.utils.hexdump import load, Loader


class TopLevelHexdumpTests(unittest.TestCase):
    def test_load(self):
        text = 'c000: aa bb'
        start, data = load(text)
        self.assertEqual(0xC000, start)
        self.assertEqual([0xAA, 0xBB], data)


class HexdumpLoaderTests(unittest.TestCase):
    def test_empty_string_does_nothing(self):
        text = ''
        loader = Loader(text)
        self.assertEqual(None, loader.start_address)
        self.assertEqual([], loader.data)

    def test_all_whitespace_does_nothing(self):
        text = "  \r\n  \t  \n"
        loader = Loader(text)
        self.assertEqual(None, loader.start_address)
        self.assertEqual([], loader.data)

    def test_raises_when_start_address_not_found(self):
        text = 'aa bb cc'
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Start address was not found in data'
            self.assertEqual(msg, str(exc))

    def test_raises_when_start_address_is_invalid(self):
        text = 'oops: aa bb cc'
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Could not parse address: oops'
            self.assertEqual(msg, str(exc))

    def test_raises_when_start_address_is_too_short(self):
        text = '01: aa bb cc'
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Expected address to be 2 bytes, got 1'
            self.assertEqual(msg, str(exc))

    def test_raises_when_start_address_is_too_long(self):
        text = '010304: aa bb cc'
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Expected address to be 2 bytes, got 3'
            self.assertEqual(msg, str(exc))

    def test_raises_when_next_address_is_unexpected(self):
        text = "c000: aa\nc002: cc"
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Non-contigous block detected.  Expected next ' \
                  'address to be $c001, label was $c002'
            self.assertEqual(msg, str(exc))

    def test_raises_when_data_is_invalid(self):
        text = 'c000: foo'
        try:
            Loader(text)
            self.fail()
        except ValueError as exc:
            msg = 'Could not parse data: foo'
            self.assertEqual(msg, str(exc))

    def test_loads_data_without_dollar_signs(self):
        text = 'c000: aa bb'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB], load.data)

    def test_loads_data_with_some_dollar_signs(self):
        text = '$c000: aa $bb'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB], load.data)

    def test_loads_multiline_data_with_unix_endings(self):
        text = '$c000: aa bb\n$c002: cc'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB, 0xCC], load.data)

    def test_loads_multiline_data_with_dos_endings(self):
        text = '$c000: aa bb\r\n$c002: cc'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB, 0xCC], load.data)

    def test_ignores_semicolon_comments(self):
        text = 'c000: aa bb ;comment'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB], load.data)

    def test_ignores_double_dash_comments(self):
        text = 'c000: aa bb -- comment'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB], load.data)

    def test_ignores_pound_comments(self):
        text = 'c000: aa bb # comment'
        load = Loader(text)
        self.assertEqual(0xC000, load.start_address)
        self.assertEqual([0xAA, 0xBB], load.data)


def test_suite():
    return unittest.findTestCases(sys.modules[__name__])

if __name__ == '__main__':
    unittest.main(defaultTest='test_suite')

########NEW FILE########
__FILENAME__ = addressing
import re


class AddressParser(object):
    """Parse user input into addresses or ranges of addresses.
    """

    def __init__(self, maxwidth=16, radix=16, labels={}):
        """Maxwidth is the maximum width of an address in bits.
        Radix is the default radix to use when one is not specified
        as a prefix of any input.  Labels are a dictionary of label
        names that can be substituted for addresses.
        """
        self.radix = radix
        self.maxwidth = maxwidth

        self.labels = {}
        for k, v in labels.items():
            self.labels[k] = self._constrain(v)

    def _get_maxwidth(self):
        return self._maxwidth

    def _set_maxwidth(self, width):
        self._maxwidth = width
        self._maxaddr = pow(2, width) - 1

    maxwidth = property(_get_maxwidth, _set_maxwidth)

    def label_for(self, address, default=None):
        """Given an address, return the corresponding label or a default.
        """
        for label, label_address in self.labels.items():
            if label_address == address:
                return label
        return default

    def number(self, num):
        """Parse a string containing a label or number into an address.
        """
        try:
            if num.startswith('$'):
                # hexadecimal
                return self._constrain(int(num[1:], 16))

            elif num.startswith('+'):
                # decimal
                return self._constrain(int(num[1:], 10))

            elif num.startswith('%'):
                # binary
                return self._constrain(int(num[1:], 2))

            elif num in self.labels:
                # label name
                return self.labels[num]

            else:
                matches = re.match('^([^\s+-]+)\s*([+\-])\s*([$+%]?\d+)$', num)
                if matches:
                    label, sign, offset = matches.groups()

                    if label not in self.labels:
                        raise KeyError("Label not found: %s" % label)

                    base = self.labels[label]
                    offset = self.number(offset)

                    if sign == '+':
                        address = base + offset
                    else:
                        address = base - offset

                    return self._constrain(address)

                else:
                    return self._constrain(int(num, self.radix))

        except ValueError:
            raise KeyError("Label not found: %s" % num)

    def range(self, addresses):
        """Parse a string containing an address or a range of addresses
        into a tuple of (start address, end address)
        """
        matches = re.match('^([^:,]+)\s*[:,]+\s*([^:,]+)$', addresses)
        if matches:
            start, end = map(self.number, matches.groups(0))
        else:
            start = end = self.number(addresses)

        if start > end:
            start, end = end, start
        return (start, end)

    def _constrain(self, address):
        '''Raises OverflowError if the address is illegal'''
        if address < 0 or address > self._maxaddr:
            raise OverflowError(address)
        return address

########NEW FILE########
__FILENAME__ = console
import sys

if sys.platform[:3] == "win":
    import msvcrt

    def getch(stdin):
        """ Read one character from the Windows console, blocking until one
        is available.  Does not echo the character.  The stdin argument is
        for function signature compatibility and is ignored.
        """
        return msvcrt.getch()

    def getch_noblock(stdin):
        """ Read one character from the Windows console without blocking.
        Does not echo the character.  If no character is available, an
        emptry string is returned.
        """
        if msvcrt.kbhit():
            return msvcrt.getch()
        return ''

else:
    import select
    import os
    import termios
    import fcntl

    def getch(stdin):
        """ Read one character from stdin, blocking until one is available.
        Does not echo the character.
        """
        fd = stdin.fileno()
        oldattr = termios.tcgetattr(fd)
        newattr = oldattr[:]
        newattr[3] &= ~termios.ICANON & ~termios.ECHO
        try:
            termios.tcsetattr(fd, termios.TCSANOW, newattr)
            char = stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSAFLUSH, oldattr)
        return char

    def getch_noblock(stdin):
        """ Read one character from stdin without blocking.  Does not echo the
        character.  If no character is available, an empty string is returned.
        """

        fd = stdin.fileno()

        oldterm = termios.tcgetattr(fd)
        newattr = oldterm[:]
        newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
        termios.tcsetattr(fd, termios.TCSANOW, newattr)

        oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)

        try:
            char = ''
            r, w, e = select.select([fd], [], [], 0.1)
            if r:
                char = stdin.read(1)
                if char == "\n":
                    char = "\r"
        finally:
            termios.tcsetattr(fd, termios.TCSAFLUSH, oldterm)
            fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
        return char


def line_input(prompt='', stdin=sys.stdin, stdout=sys.stdout):
    """ Read a line from stdin, printing each character as it is typed.
    Does not echo a newline at the end.  This allows the calling program
    to overwrite the line by first sending a carriage return ('\r'), which
    is useful in modes like the interactive assembler.
    """
    stdout.write(prompt)
    line = ''
    while True:
        char = getch(stdin)
        code = ord(char)
        if char in ("\n", "\r"):
            break
        elif code in (0x7f, 0x08):  # backspace
            if len(line) > 0:
                line = line[:-1]
                stdout.write("\r%s\r%s%s" %
                             (' ' * (len(prompt + line) + 5), prompt, line))
        elif code == 0x1b:  # escape
            pass
        else:
            line += char
            stdout.write(char)
            stdout.flush()
    return line

########NEW FILE########
__FILENAME__ = conversions


def itoa(num, base=10):
    """ Convert a decimal number to its equivalent in another base.
    This is essentially the inverse of int(num, base).
    """
    negative = num < 0
    if negative:
        num = -num
    digits = []
    while num > 0:
        num, last_digit = divmod(num, base)
        digits.append('0123456789abcdefghijklmnopqrstuvwxyz'[last_digit])
    if negative:
        digits.append('-')
    digits.reverse()
    return ''.join(digits)


def convert_to_bin(bcd):
    return bcd2bin[bcd]


def convert_to_bcd(bin):
    return bin2bcd[bin]


bcd2bin = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 30, 31, 32, 33, 34, 35, 36, 37,
    38, 39, 40, 41, 42, 43, 44, 45, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
    50, 51, 52, 53, 54, 55, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
    62, 63, 64, 65, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
    74, 75, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 90, 91,
    92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 100, 101,
    102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
    110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
    124, 125, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
    132, 133, 134, 135, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
    140, 141, 142, 143, 144, 145, 140, 141, 142, 143, 144, 145, 146, 147,
    148, 149, 150, 151, 152, 153, 154, 155, 150, 151, 152, 153, 154, 155,
    156, 157, 158, 159, 160, 161, 162, 163, 164, 165
]


bin2bcd = [
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99
]

########NEW FILE########
__FILENAME__ = devices


def make_instruction_decorator(instruct, disasm, allcycles, allextras):
    def instruction(name, mode, cycles, extracycles=0):
        def decorate(f):
            opcode = int(f.__name__.split('_')[-1], 16)
            instruct[opcode] = f
            disasm[opcode] = (name, mode)
            allcycles[opcode] = cycles
            allextras[opcode] = extracycles
            return f  # Return the original function
        return decorate
    return instruction

########NEW FILE########
__FILENAME__ = hexdump
from binascii import a2b_hex


def load(text):
    load = Loader(text)
    return (load.start_address, load.data)


class Loader:
    def __init__(self, text):
        self.load(text)

    def load(self, text):
        self._reset()

        for line in text.splitlines():
            self._parse_line(line)

    def _reset(self):
        self.data = []
        self.start_address = None
        self.current_address = None

    def _parse_line(self, line):
        line = self._remove_comments(line)
        pieces = line.strip().split()

        for piece in pieces:
            if piece.startswith('$'):
                piece = piece[1:]

            if piece.endswith(':'):
                self._parse_address(piece[:-1])

            else:
                self._parse_bytes(piece)

    def _remove_comments(self, line):
        for delimiter in (';', '--', '#'):
            pos = line.find(delimiter)
            if pos != -1:
                line = line[:pos]
        return line

    def _parse_address(self, piece):
        try:
            binstr = a2b_hex(piece.encode('utf-8'))
            if isinstance(binstr, str):
                addr_bytes = [ ord(b) for b in binstr ]
            else: # Python 3
                addr_bytes = [ b for b in binstr ]
        except (TypeError, ValueError):
            msg = "Could not parse address: %s" % piece
            raise ValueError(msg)

        if len(addr_bytes) != 2:
            msg = "Expected address to be 2 bytes, got %d" % (
                  len(addr_bytes))
            raise ValueError(msg)

        address = (addr_bytes[0] << 8) + addr_bytes[1]

        if self.start_address is None:
            self.start_address = address
            self.current_address = address

        elif address != (self.current_address):
            msg = "Non-contigous block detected.  Expected next address " \
                  "to be $%04x, label was $%04x" % (self.current_address,
                                                    address)
            raise ValueError(msg)

    def _parse_bytes(self, piece):
        if self.start_address is None:
            msg = "Start address was not found in data"
            raise ValueError(msg)

        else:
            try:
                binstr = a2b_hex(piece.encode('utf-8'))
                if isinstance(binstr, str):
                    data_bytes = [ ord(b) for b in binstr ]
                else: # Python 3
                    data_bytes = [ b for b in binstr ]
            except (TypeError, ValueError):
                msg = "Could not parse data: %s" % piece
                raise ValueError(msg)

            self.current_address += len(data_bytes)
            self.data.extend(data_bytes)

########NEW FILE########
